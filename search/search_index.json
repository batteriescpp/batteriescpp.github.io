{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Batteries C++! \ud83d\udd17 Ever get the feeling that there's a lot of nice stuff in other programming languages that was just left out of C++? Like the batteries weren't included? Batteries is a library designed to fix that! Features: Header-only: makes including/using in your program super easy A la carte: only include what you need, don't pay for the rest Many useful facilities, including: Enhanced Runtime Checks/Assertions Fast, User-Space Asynchronous Tasks batt::case_of, An Ergonomic Replacement For std::visit Support for Exception-Free Coding in C++ @copy; 2019-2022 Anthony Paul Astolfi, et al.","title":"Home"},{"location":"assert.hpp/","text":"<batteries/assert.hpp> : Fatal error check macros \ud83d\udd17 File Reference This header includes enhanced drop-in replacements for standard assert() statements. All the supported assertion types have a version ( BATT_CHECK* ) which is always on, even in optimized/release builds, and a version ( BATT_ASSERT* ) that is automatically stripped out of non-Debug builds. NOTE: Batteries assumes the build type is Release/Optimized if the macro NDEBUG is defined; in this case, all BATT_ASSERT* statements will be stripped out of the compilation. Advantages \ud83d\udd17 Informative Messages \ud83d\udd17 Using a more descriptive assertion macro allows your program to print a more informative error message if an assertion does fail. For example, you might use the statement: 1 assert ( x == 1 ); But if this assertion fails, all you know is that x was not equal to 1. What was it equal to?! Batteries will answer this question automatically if you write: 1 BATT_ASSERT_EQ ( x , 1 ); You don't have to worry about making sure that the types you're comparing support std::ostream output to take advantage of this feature; Batteries will automatically do its best to print out something that might be useful, regardless of type. If you want to take advantage of this feature explicitly (when writing some arbitrary type to a stream), you can use: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <batteries/assert.hpp> struct MyCustomType { int x ; int y ; }; int main () { MyCustomType x ; // Works even though MyCustomType has no ostream operator<<! // std :: cout << batt :: make_printable ( x ); return 0 ; } Stack Traces \ud83d\udd17 Full stack traces, with source symbols if available, are automatically printed whenever an assertion failure happens. Always On Checks \ud83d\udd17 BATT_CHECK_* allows you to write assertions that are guaranteed never to be compiled out of your program, even in optimized/release builds. - All BATT_CHECK_* / BATT_ASSERT_* statements support operator<< like std::ostream objects, so that you can add more contextual information to help diagnose an assertion failure. Example: 1 2 3 4 5 6 int y = get_y (); int z = get_z (); int x = ( y + z ) / 2 ; BATT_ASSERT_EQ ( x , 1 ) << \"y = \" << y << \", z = \" << z << \" (expected the average of y and z to be 1)\" ; Low-Overhead \ud83d\udd17 Diagnostic output expressions added via << are never evaluated unless the assertion actually fails, so don't worry if they are somewhat expensive. Prevent Code Rot \ud83d\udd17 Even on Release builds, all expressions that appear in a BATT_ASSERT_* statement will be compiled, so you don't have to worry about breaking Debug builds when compiling primarily using optimization. Quick Reference \ud83d\udd17 Logical Assertions \ud83d\udd17 Debug-only Always Enabled Description BATT_ASSERT(cond) BATT_CHECK(cond) Assert that bool{cond} == true BATT_ASSERT_IMPLES(p, q) BATT_CHECK_IMPLIES(p, q) Assert that if (p) is true, then so is (q) (i.e., (!(p) || (q)) ) BATT_ASSERT_NOT_NULLPTR(x) BATT_CHECK_NOT_NULLPTR(x) Assert that (x) != nullptr Comparison Assertions \ud83d\udd17 Debug-only Always Enabled Description BATT_ASSERT_EQ(a, b) BATT_CHECK_EQ(a, b) Assert that (a) == (b) BATT_ASSERT_NE(a, b) BATT_CHECK_NE(a, b) Assert that (a) != (b) BATT_ASSERT_LT(a, b) BATT_CHECK_LT(a, b) Assert that (a) < (b) BATT_ASSERT_GT(a, b) BATT_CHECK_GT(a, b) Assert that (a) > (b) BATT_ASSERT_LE(a, b) BATT_CHECK_LE(a, b) Assert that (a) <= (b) BATT_ASSERT_GE(a, b) BATT_CHECK_GE(a, b) Assert that (a) >= (b) Other/Advanced \ud83d\udd17 Name Description BATT_PANIC() Forces the program to exit immediately, printing a full stack trace and any message << -inserted to the [BATT_PANIC() statement. Example: [BATT_PANIC() << \"Something has gone horribly wrong! x = \" << x; BATT_UNREACHABLE() Statement that tells the compiler this point in the code should be unreachable; for example, it is right after a call to std::abort() or std::terminate() . Use this to silence spurious warnings about dead code. BATT_NORETURN When added to a function declaration (before the return type), tells the compiler that a function never returns. Use this to silence spurious warnings. Example: BATT_NORETURN void print_stuff_and_exit(); batt::make_printable(obj) Makes any expression printable, even if it doesn't have an overloaded std::ostream& operator<<(std::ostream&, T) . If the type of obj does define such an operator, however, that will be invoked when using batt::make_printable . obj is passed/forwarded by reference only; no copy of the original object/value is made.","title":"&lt;batteries/assert.hpp&gt; : Fatal error check macros"},{"location":"assert.hpp/#advantages","text":"","title":"Advantages"},{"location":"assert.hpp/#informative-messages","text":"Using a more descriptive assertion macro allows your program to print a more informative error message if an assertion does fail. For example, you might use the statement: 1 assert ( x == 1 ); But if this assertion fails, all you know is that x was not equal to 1. What was it equal to?! Batteries will answer this question automatically if you write: 1 BATT_ASSERT_EQ ( x , 1 ); You don't have to worry about making sure that the types you're comparing support std::ostream output to take advantage of this feature; Batteries will automatically do its best to print out something that might be useful, regardless of type. If you want to take advantage of this feature explicitly (when writing some arbitrary type to a stream), you can use: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <batteries/assert.hpp> struct MyCustomType { int x ; int y ; }; int main () { MyCustomType x ; // Works even though MyCustomType has no ostream operator<<! // std :: cout << batt :: make_printable ( x ); return 0 ; }","title":"Informative Messages"},{"location":"assert.hpp/#stack-traces","text":"Full stack traces, with source symbols if available, are automatically printed whenever an assertion failure happens.","title":"Stack Traces"},{"location":"assert.hpp/#always-on-checks","text":"BATT_CHECK_* allows you to write assertions that are guaranteed never to be compiled out of your program, even in optimized/release builds. - All BATT_CHECK_* / BATT_ASSERT_* statements support operator<< like std::ostream objects, so that you can add more contextual information to help diagnose an assertion failure. Example: 1 2 3 4 5 6 int y = get_y (); int z = get_z (); int x = ( y + z ) / 2 ; BATT_ASSERT_EQ ( x , 1 ) << \"y = \" << y << \", z = \" << z << \" (expected the average of y and z to be 1)\" ;","title":"Always On Checks"},{"location":"assert.hpp/#low-overhead","text":"Diagnostic output expressions added via << are never evaluated unless the assertion actually fails, so don't worry if they are somewhat expensive.","title":"Low-Overhead"},{"location":"assert.hpp/#prevent-code-rot","text":"Even on Release builds, all expressions that appear in a BATT_ASSERT_* statement will be compiled, so you don't have to worry about breaking Debug builds when compiling primarily using optimization.","title":"Prevent Code Rot"},{"location":"assert.hpp/#quick-reference","text":"","title":"Quick Reference"},{"location":"assert.hpp/#logical-assertions","text":"Debug-only Always Enabled Description BATT_ASSERT(cond) BATT_CHECK(cond) Assert that bool{cond} == true BATT_ASSERT_IMPLES(p, q) BATT_CHECK_IMPLIES(p, q) Assert that if (p) is true, then so is (q) (i.e., (!(p) || (q)) ) BATT_ASSERT_NOT_NULLPTR(x) BATT_CHECK_NOT_NULLPTR(x) Assert that (x) != nullptr","title":"Logical Assertions"},{"location":"assert.hpp/#comparison-assertions","text":"Debug-only Always Enabled Description BATT_ASSERT_EQ(a, b) BATT_CHECK_EQ(a, b) Assert that (a) == (b) BATT_ASSERT_NE(a, b) BATT_CHECK_NE(a, b) Assert that (a) != (b) BATT_ASSERT_LT(a, b) BATT_CHECK_LT(a, b) Assert that (a) < (b) BATT_ASSERT_GT(a, b) BATT_CHECK_GT(a, b) Assert that (a) > (b) BATT_ASSERT_LE(a, b) BATT_CHECK_LE(a, b) Assert that (a) <= (b) BATT_ASSERT_GE(a, b) BATT_CHECK_GE(a, b) Assert that (a) >= (b)","title":"Comparison Assertions"},{"location":"assert.hpp/#otheradvanced","text":"Name Description BATT_PANIC() Forces the program to exit immediately, printing a full stack trace and any message << -inserted to the [BATT_PANIC() statement. Example: [BATT_PANIC() << \"Something has gone horribly wrong! x = \" << x; BATT_UNREACHABLE() Statement that tells the compiler this point in the code should be unreachable; for example, it is right after a call to std::abort() or std::terminate() . Use this to silence spurious warnings about dead code. BATT_NORETURN When added to a function declaration (before the return type), tells the compiler that a function never returns. Use this to silence spurious warnings. Example: BATT_NORETURN void print_stuff_and_exit(); batt::make_printable(obj) Makes any expression printable, even if it doesn't have an overloaded std::ostream& operator<<(std::ostream&, T) . If the type of obj does define such an operator, however, that will be invoked when using batt::make_printable . obj is passed/forwarded by reference only; no copy of the original object/value is made.","title":"Other/Advanced"},{"location":"async/","text":"<batteries/async/...> : Async Tasks and I/O \ud83d\udd17 Quick Reference batt::Task batt::Watch<T> batt::Mutex<T> batt::Task \ud83d\udd17 Summary \ud83d\udd17 1 #include <batteries/async/task.hpp> Constructors Task(executor, stack_size, body_fn) Task(executor, body_fn, name, stack_size, stack_type, priority) Static Methods current current_name current_priority current_stack_pos current_stack_pos_of default_name yield sleep await backtrace_all Getters Modifiers Synchronization id name try_join join get_executor get_priority set_priority call_when_done stack_pos stack_pos_of wake Description \ud83d\udd17 A batt::Task is similar to std::thread , but much lighter weight. Like std::thread , each batt::Task has an independent call stack. Unlike std::thread , however, batt::Task is implemented 100% in user space, and does not support preemption. This makes the context swap overhead of batt::Task very low in comparison to a std::thread , which means it is possible to have many more batt::Task instances without losing efficiency. Asynchronous I/O \ud83d\udd17 The primary use case for batt::Task is to support asynchronous I/O for efficiency, while retaining the programming model of traditional threads. This makes asynchronous code much easier to write, read, debug, and maintain than equivalent code using asynchronous continuation handlers (in the style of Boost Asio or Node.js). An important feature of batt::Task to highlight is the static method batt::Task::await . This method allows the use of asynchronous continuation handler-based APIs (e.g., Boost Asio) in a \"blocking\" style. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <batteries/async/task.hpp> #include <batteries/async/io_result.hpp> #include <batteries/assert.hpp> #include <batteries/utility.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/ip/tcp.hpp> // Some function to get a server endpoint to which to connect. // extern boost :: asio :: ip :: tcp :: endpoint get_server_endpoint (); int main () { // Create an io_context to schedule our Task and manage all asynchronous I/O. // boost :: asio :: io_context io ; // Create a TCP/IP socket; we will use this to connect to the server endpoint. // boost :: asio :: ip :: tcp :: socket s { io }; // Launch a task to act as our client. // batt :: Task client_task { io . get_executor (), /*body_fn=*/ [ & ] { // Connect to the server. batt::Task::await will not return until the handler passed // to `async_connect` has been invoked. // boost :: system :: error_code ec = batt :: Task :: await < boost :: system :: error_code > ([ & ]( auto && handler ){ s . async_connect ( get_server_endpoint (), BATT_FORWARD ( handler )); }); BATT_CHECK ( ! ec ); // Interact with the server via the connected socket... }}; // VERY IMPORTANT: without this line, nothing will happen! // io . run (); return 0 ; } All continuation handler based async APIs require a callback (the continuation handler). In order to simplify the code, we want to \"pause\" our code until the I/O is finished, but the async API, async_connect in this case, will return immediately. batt::Task::await gives us access to the \"continuation\" of the task, in this case everything that happens after await returns, as a handler that can be passed directly to async_connect . All the context swapping, scheduling, memory managment, and synchronization is handled automatically by batt::Task , allowing the programmer to focus on the application's natural flow of control, and not the mechanics used to implement this flow. Task Scheduling and Priorities \ud83d\udd17 When a batt::Task is created, it is passed a Boost Asio executor object. All execution of task code on the task's stack will happen via boost::asio::dispatch or boost::asio::post using this executor. NOTE: this means if, for example, you use the executor from a boost::asio::io_context to create a task, that task will not run unless you call io_context::run() ! A running batt::Task is never preempted by another task. Instead it must yield control of the current thread to allow another task to run. There are four ways to do this: batt::Task::join() batt::Task::await() batt::Task::yield() batt::Task::sleep() WARNING: if you use a kernel or standard library synchronization mechanism or blocking call, for example std::mutex , from inside a batt::Task , that task WILL NOT YIELD! This is why the Batteries Async library contains its own synchronization primitives, like batt::Watch , batt::Queue , and batt::Mutex . All of these primitives are implemented on top one or more of the four methods enumerated above. Each batt::Task is assigned a scheduling priority, which is a signed 32-bit integer. Greater values of the priority int mean more urgent priority; lesser values mean less urgency. Even though tasks don't interrupt each other (i.e. preemption), they sometimes perform actions that cause another task to move from a \"waiting\" state to a \"ready to run\" state. For example, one task may be blocked inside a call to batt::Watch<T>::await_equal , and another task (let's call it the \"notifier\") may call batt::Watch<T>::set_value , activating the first task (let's call it the \"listener\"). As noted above, the newly activated (\"listener\") task will be run via boost::asio::dispatch or boost::asio::post . Which mechanism is used depends on the relative priority of the two tasks: If the \"notifier\" has a higher (numerically greater) priority value than the \"listener\", the \"listener\" is scheduled via boost::asio::post . Otherwise, the \"notifier\" is immediately suspended and re-scheduled via boost::asio::post ; then the \"listener\" is scheduled via boost::asio::dispatch . In any case, activating another task will not cause a running task to go from a \"running\" state to a \"waiting\" state. It may however \"bounce\" it to another thread, or to be pushed to the back of an execution queue. This only matters when there are more tasks ready to run than there are available threads for a given ExecutionContext: higher priority tasks are scheduled before lower priority ones in general. NOTE: you may still end up with a priority inversion situation when multiple tasks with different priorities are boost::asio::post -ed to the same queue. In this case, there is no mechanism currently for re-ordering the tasks to give preference based on priority. Overall, it is best to consider priority \"best-effort\" rather than a guarantee of scheduling order. It should be used for performance tuning, not to control execution semantics in a way that affects the functional behavior of a program. Methods \ud83d\udd17 batt::Task ::Task(executor, stack_size, body_fn) \ud83d\udd17 Create a new Task with a custom stack size. 1 2 3 4 template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , batt :: StackSize stack_size , BodyFn && body_fn ) noexcept ; batt::Task ::Task(executor, body_fn, name, stack_size, stack_type, priority) \ud83d\udd17 Create a new Task, optionally setting name, stack size, stack type, and priority. 1 2 3 4 5 6 7 template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , BodyFn && body_fn , std :: string && name = Task :: default_name (), StackSize stack_size = batt :: StackSize { 512 * 1024 }, batt :: StackType stack_type = batt :: StackType :: kFixedSize , batt :: Optional < Priority > priority = None ) noexcept ; The default priority for a Task is the current task priority plus 100; this means that a new Task by default will always \"soft-preempt\" the currently running task. batt::Task ::await \ud83d\udd17 Block the current thread until some asynchronous operation completes. 1 2 3 4 5 6 7 8 template < typename R , typename Fn = void ( Handler ) > static R await ( Fn && fn ); // (1) template < typename R , typename Fn = void ( Handler ) > static R await ( batt :: StaticType < R > , Fn && fn ); // (2) template < typename T > static batt :: StatusOr < T > await ( const batt :: Future < T >& future_result ); // (3) Overloads (1) & (2) take a function whose job is to initiate an asynchronous operation. Since async ops require a callback (which is invoked when the op completes), the function fn is passed a Handler which serves to wake up the task and resume its execution. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 boost :: asio :: ip :: tcp :: socket s ; using ReadResult = std :: pair < boost :: system :: error_code , std :: size_t > ; ReadResult r = batt :: Task :: await < ReadResult > ([ & ]( auto && handler ) { s . async_read_some ( buffers , BATT_FORWARD ( handler )); }); if ( r . first ) { std :: cout << \"Error! ec=\" << r . first ; } else { std :: cout << r . second << \" bytes were read.\" ; } The template parameter R is the return type of the await operation. R can be any type that is movable and constructible from the arguments passed to the callback Handler . In the example above, we define R to be a std::pair of the error code and the count of bytes read (size_t). This is the exact signature required by the async op initiated inside the lambda expression passed to await . When the socket implementation causes handler(ec, n_bytes_read) to be invoked, the Handler provided by batt::Task::await constructs an instance of R by forwarding the handler arguments ( auto retval = std::make_pair(ec, n_bytes_read); ), and resumes the task that was paused inside await , returning retval . Return Value \ud83d\udd17 (1) & (2): the instance of R constructed from callback arguments. (3): the value of the passed batt::Future<T> if successful; non-ok status if the future completed with an error. batt::Task ::backtrace_all \ud83d\udd17 Dumps stack trace and debug information for all active batt::Task s to stderr. 1 static i32 backtrace_all ( bool force ); If force is true, then this function will attempt to dump debug information for running tasks, even though this may cause data races (if you're debugging a tricky threading issue, sometimes the risk of a crash is outweighed by the benefit of some additional clues about what's going on!). Return Value \ud83d\udd17 The number of tasks dumped. batt::Task ::call_when_done \ud83d\udd17 Attaches a listener callback to the task; this callback will be invoked when the task completes execution. 1 2 template < typename F = void () > void call_when_done ( F && handler ); This method can be thought of as an asynchronous version of join() . batt::Task ::current \ud83d\udd17 Returns a reference to the currently running Task, if there is one. 1 static batt :: Task & current (); WARNING: if this method is called outside of any batt::Task , behavior is undefined. Return Value \ud83d\udd17 The current task. batt::Task ::current_name \ud83d\udd17 Returns the current task name, or \"\" if there is no current task. 1 static std :: string_view current_name (); Unlike batt::Task::current() , this method is safe to call outside a task. Return Value \ud83d\udd17 The current task name. batt::Task ::current_priority \ud83d\udd17 1 static batt :: Task :: Priority current_priority (); NOTE: this function is safe to call outside of a task; in this case, the default priority (0) is returned. See Task Scheduling and Priorities . Return Value \ud83d\udd17 The priority of the current task. batt::Task ::current_stack_pos \ud83d\udd17 Returns the offset of the current locus of control relative to the base of the stack. 1 static batt :: Optional < usize > current_stack_pos (); Return Value \ud83d\udd17 If called from inside a task, the current stack position in bytes Else batt::None batt::Task ::current_stack_pos_of \ud83d\udd17 Returns the offset of some address relative to the base of the current task stack. 1 static batt :: Optional < usize > current_stack_pos_of ( const volatile void * ptr ); NOTE: If ptr isn't actually on the current task's stack, then this function will still return a number, but it will be essentially a garbage value. It's up to the caller to make sure that ptr points at something on the task stack. Return Value \ud83d\udd17 If called from inside a task, the stack offset in bytes of ptr Else batt::None batt::Task ::default_name \ud83d\udd17 1 static std :: string default_name () Return Value \ud83d\udd17 The name given to a batt::Task if none is passed into the constructor. batt::Task ::sleep \ud83d\udd17 Puts a batt::Task to sleep for the specified real-time duration. 1 2 template < typename Duration = boost :: posix_time :: ptime > static batt :: ErrorCode sleep ( const Duration & duration ); This operation can be interrupted by a batt::Task::wake() , in which case a \"cancelled\" error code is returned instead of success (no error). This method is safe to call outside a task; in this case, it is implemented via std::this_task::sleep_for . Return Value \ud83d\udd17 batt::ErrorCode{} (no error) if the specified duration passed A value equal to boost::asio::error::operation_aborted if batt::Task::wake() was called on the given task batt::Task ::get_executor \ud83d\udd17 Returns a copy of the executor passed to the given task at construction time. 1 batt :: Task :: executor_type get_executor () const ; Return Value \ud83d\udd17 The executor for this task. batt::Task ::get_priority \ud83d\udd17 Get the priority of this task. 1 batt :: Task :: Priority get_priority () const ; See Task Scheduling and Priorities . Return Value \ud83d\udd17 The priority of the task. batt::Task ::id \ud83d\udd17 Get the process-unique serial number of this task. 1 i32 id () const ; Return Value \ud83d\udd17 The serial number of the task. batt::Task ::join \ud83d\udd17 Block until the task has finished. 1 void join (); batt::Task ::name \ud83d\udd17 Get the human-friendly name of this task. 1 std :: string_view name () const ; This string is not necessarily unique to this task. It is optionally passed in when the task is constructed. The purpose is to identify the task for debugging purposes. Return Value \ud83d\udd17 The name of the task. batt::Task ::set_priority \ud83d\udd17 Set the scheduling priority of this task. 1 void set_priority ( batt :: Task :: Priority new_priority ); See Task Scheduling and Priorities . batt::Task ::stack_pos \ud83d\udd17 Get the byte offset between the current stack position and the base of this task's stack. This value is only meaningful if this method is called while on the current task. Usually you should just call batt::Task::current_stack_pos() instead. 1 usize stack_pos() const; Return Value \ud83d\udd17 The byte offset between the current stack position and the base of this task's stack. batt::Task ::stack_pos_of \ud83d\udd17 Get the byte offset between the given pointer and the base of this task's stack. It is up to the caller to make sure that ptr is the address of something on the task's stack. Usually you should just call batt::Task::current_stack_pos_of instead. 1 usize stack_pos_of ( const volatile void * ptr ) const ;; Return Value \ud83d\udd17 The byte offset between the given pointer and the base of this task's stack. batt::Task ::try_join \ud83d\udd17 Test whether this task has finished. 1 bool try_join (); This function is guaranteed never to block. See batt::Task::join() . Return Value \ud83d\udd17 true iff the task has finished executing. batt::Task ::wake \ud83d\udd17 Interrupts a call to batt::Task::sleep on the given task. 1 bool wake (); NOTE: if the given task is suspended for some other reason (i.e., it is not inside a call to batt::Task::sleep ), this method will not wake the task (in this case it will return false ). Return Value \ud83d\udd17 true iff the task was inside a call to sleep and was successfully activated batt::Task ::yield \ud83d\udd17 Suspend the current task and immediately schedule it to resume via boost::asio::post . 1 static void yield (); batt::Watch<T> \ud83d\udd17 Summary \ud83d\udd17 1 #include <batteries/async/watch.hpp> Constructors Watch() Watch(T) Getters Modifiers Synchronization is_closed close fetch_add async_wait await_not_equal get_value set_value fetch_sub await_equal modify fetch_or await_true modify_if fetch_and await_modify Description \ud83d\udd17 A batt::Watch is like a std::atomic that you can block on, synchronously and asynchronously. Like std::atomic , it has methods to atomically get/set/increment/etc. But unlike std::atomic , you can also block a task waiting for some condition to be true. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <batteries/async/watch.hpp> #include <batteries/assert.hpp> // for BATT_CHECK_OK #include <batteries/status.hpp> // for batt::Status int main () { batt :: Watch < bool > done { false }; // Launch some background task that will do stuff, then set `done` // to `true` when it is finished. // launch_background_task ( & done ); batt :: Status status = done . await_equal ( true ); BATT_CHECK_OK ( status ); return 0 ; } Methods \ud83d\udd17 batt::Watch ::Watch() \ud83d\udd17 Constructs a batt::Watch object with a default-initialized value of T . batt::Watch ::Watch(T init_value) \ud83d\udd17 Constructs a batt::Watch object with the given initial value. batt::Watch ::async_wait \ud83d\udd17 Invokes the passed handler fn with the described value as soon as one of the following conditions is true: * When the Watch value is not equal to the passed value last_seen , invoke fn with the current value of the Watch. * When the Watch is closed, invoke fn with batt::StatusCode::kClosed . 1 2 template < typename Handler = void ( batt :: StatusOr < T > new_value ) > void async_wait ( T last_seen , Handler && fn ) const ; batt::Watch ::await_equal \ud83d\udd17 Blocks the current task/thread until the Watch contains the specified value. 1 batt :: Status await_equal ( T val ) const ; Return Value \ud83d\udd17 batt::OkStatus() if the Watch value was observed to be val batt::StatusCode::kClosed if the Watch was closed before val was observed batt::Watch ::await_modify \ud83d\udd17 Retries fn on the Watch value until it succeeds or the Watch is closed. 1 2 template < typename Fn = batt :: Optional < T > ( T ) > batt :: StatusOr < T > await_modify ( Fn && fn ); If fn returns batt::None , this indicates fn should not be called again until a new value is available. fn MUST be safe to call multiple times within a single call to await_modify . This is because await_modify may be implemented via an atomic compare-and-swap loop. Return Value \ud83d\udd17 If successful, the old (pre-modify) value on which fn finally succeeded batt::StatusCode::kClosed if the Watch was closed before fn was successful batt::Watch ::await_not_equal \ud83d\udd17 Blocks the current task/thread until the Watch value is not equal to last_seen . 1 batt :: StatusOr < T > await_not_equal ( T last_seen ); Return Value \ud83d\udd17 On success, the current value of the Watch, which is guaranteed to not equal last_seen batt::StatusCode::kClosed if the Watch was closed before a satisfactory value was observed batt::Watch ::await_true \ud83d\udd17 Blocks the current task/thread until the passed predicate function returns true for the current value of the Watch. 1 2 template < typename Pred = bool ( T ) > batt :: StatusOr < T > await_true ( Pred && pred ); This is the most general of Watch's blocking getter methods. Return Value \ud83d\udd17 On success, the Watch value for which pred returned true batt::StatusCode::kClosed if the Watch was closed before a satisfactory value was observed batt::Watch ::close \ud83d\udd17 Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. 1 void close (); This method is safe to call multiple times. The Watch value can still be modified and retrieved after it is closed; this only disables the methods in the \"Synchronization\" category (see Summary section above). batt::Watch ::fetch_add \ud83d\udd17 Atomically adds the specified amount to the Watch value, returning the previous value. 1 T fetch_add ( T arg ); NOTE: This method is only available if T is a primitive integer type. Return Value \ud83d\udd17 The prior value of the Watch. batt::Watch ::fetch_and \ud83d\udd17 Atomically sets the Watch value to the bitwise-and of the current value and the passed arg , returning the previous value. 1 T fetch_and ( T arg ); NOTE: This method is only available if T is a primitive integer type. Return Value \ud83d\udd17 The prior value of the Watch. batt::Watch ::fetch_or \ud83d\udd17 Atomically sets the Watch value to the bitwise-and of the current value and the passed arg , returning the previous value. 1 T fetch_or ( T arg ); NOTE: This method is only available if T is a primitive integer type. Return Value \ud83d\udd17 The prior value of the Watch. batt::Watch ::fetch_sub \ud83d\udd17 Atomically subtracts the specified amount to the Watch value, returning the previous value. 1 T fetch_sub ( T arg ); NOTE: This method is only available if T is a primitive integer type. Return Value \ud83d\udd17 The prior value of the Watch. batt::Watch ::get_value \ud83d\udd17 Returns the current value of the Watch to the caller. 1 T get_value () const ; Return Value \ud83d\udd17 The current Watch value. batt::Watch ::is_closed \ud83d\udd17 Returns whether the Watch is in a \"closed\" state. 1 bool is_closed () const ; Return Value \ud83d\udd17 true if the Watch is closed false otherwise batt::Watch ::modify \ud83d\udd17 Atomically modifies the Watch value by applying the passed transform fn . 1 2 template < typename Fn = T ( T ) > T modify ( Fn && fn ); fn MUST be safe to call multiple times within a single call to modify . This is because modify may be implemented via an atomic compare-and-swap loop. Return Value \ud83d\udd17 if T is a primitive integer type (including bool ), the new value of the Watch else, the old value of the Watch NOTE: This behavior is acknowledged to be less than ideal and will be fixed in the future to be consistent, regardless of T batt::Watch ::modify_if \ud83d\udd17 Retries calling fn on the Watch value until EITHER of: * fn returns batt::None * BOTH of: * fn returns a non- batt::None value * the Watch value is atomically updated via compare-and-swap 1 2 template < typename Fn = batt :: Optional < T > ( T ) > batt :: Optional < T > modify_if ( Fn && fn ); fn MUST be safe to call multiple times within a single call to modify_if . This is because modify_if may be implemented via an atomic compare-and-swap loop. Unlike await_modify , this method never puts the current task/thread to sleep; it keeps actively polling the Watch value until it reaches one of the exit criteria described above. Return Value \ud83d\udd17 The final value returned by fn , which is either batt::None or the new Watch value. batt::Watch ::set_value \ud83d\udd17 Atomically set the value of the Watch. 1 void set_value ( T new_value ); batt::Mutex<T> \ud83d\udd17 Summary \ud83d\udd17 1 #include <batteries/async/mutex.hpp> Constructors Mutex() Mutex(args...) Methods lock lock (const) with_lock Operators operator-> Static Methods thread_safe_base Description \ud83d\udd17 Provides mutually-exclusive access to an instance of type T . This class has two advantages over std::mutex : It will yield the current batt::Task (if there is one) when blocking to acquire a lock, allowing the current thread to be used by other tasks By embedding the protected type T within the object, there is a much lower chance that state which should be accessed via a mutex will accidentally be accessed directly This mutex implementation is mostly fair because it uses Lamport's Bakery Algorithm . It is non-recursive, so threads/tasks that attempt to acquire a lock that they already have will deadlock. Also, an attempt to acquire a lock on a batt::Mutex can't be cancelled, so it is not possible to set a timeout on lock acquisition. An instance of batt::Mutex<T> may be locked in a few different ways: Lock via guard class (similar to std::unique_lock) \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 batt :: Mutex < std :: string > s ; { batt :: Mutex < std :: string >:: Lock lock { s }; // Once the lock is acquired, you can access the protected object via pointer... // std :: string * ptr = lock . get (); // ... or by reference ... // std :: string & ref = lock . value (); // ... by operator* like a smart pointer... // std :: string & ref2 = * lock ; // ... or you can access its members via operator->: // const char * cs = lock -> c_str (); } // The lock is released when the guard class goes out of scope. Equivalently, an instance of batt::Mutex<T>::Lock can be created via the lock() method: 1 2 3 4 5 6 7 batt :: Mutex < std :: string > s ; { auto locked = s . lock (); static_assert ( std :: is_same_v < decltype ( locked ), batt :: Mutex < std :: string >:: Lock > , \"It is nice to use auto in this case!\" ); } As the second example implies, batt::Mutex<T>::Lock is a movable type (however it is non-copyable). Run function with lock acquired \ud83d\udd17 1 2 3 4 5 batt :: Mutex < std :: string > s { \"Some string\" }; s . with_lock ([]( std :: string & locked_s ) { locked_s += \" and then some!\" ; }); Lock-free access to T \ud83d\udd17 Even though access to the protected object of type T mostly happens via a lock, batt::Mutex supports types with a partial interface that is thread-safe without locking. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct MyStateBase { explicit MyStateBase ( std :: string && init_val ) : initial_value { std :: move ( init_val )} {} const std :: string initial_value ; }; struct MyState : MyStateBase { // IMPORTANT: this member type alias tells batt::Mutex to enable the `no_lock()` method/feature. // using ThreadSafeBase = MyStateBase ; explicit MyState ( std :: string && init_val ) : MyStateBase { init_val } , current_value { init_val } {} }; batt :: Mutex < MyState > state { \"initial\" }; // No lock needed to read a const value. // std :: cout << \"initial value = \" << state . no_lock (). initial_value << std :: endl ; // We still need to acquire the lock to access the derived class. // state . with_lock ([]( MyState & s ) { std :: cout << \"current value = \" << s . current_value << std :: endl ; s . current_value = \"changed\" ; }); // batt::Mutex::nolock returns a reference to the ThreadSafeBase type declared in MyState. // MyStateBase & base = state . no_lock ();","title":"&lt;batteries/async/...&gt; : Async Tasks and I/O"},{"location":"async/#batttask","text":"","title":"batt::Task"},{"location":"async/#summary","text":"1 #include <batteries/async/task.hpp> Constructors Task(executor, stack_size, body_fn) Task(executor, body_fn, name, stack_size, stack_type, priority) Static Methods current current_name current_priority current_stack_pos current_stack_pos_of default_name yield sleep await backtrace_all Getters Modifiers Synchronization id name try_join join get_executor get_priority set_priority call_when_done stack_pos stack_pos_of wake","title":"Summary"},{"location":"async/#description","text":"A batt::Task is similar to std::thread , but much lighter weight. Like std::thread , each batt::Task has an independent call stack. Unlike std::thread , however, batt::Task is implemented 100% in user space, and does not support preemption. This makes the context swap overhead of batt::Task very low in comparison to a std::thread , which means it is possible to have many more batt::Task instances without losing efficiency.","title":"Description"},{"location":"async/#asynchronous-io","text":"The primary use case for batt::Task is to support asynchronous I/O for efficiency, while retaining the programming model of traditional threads. This makes asynchronous code much easier to write, read, debug, and maintain than equivalent code using asynchronous continuation handlers (in the style of Boost Asio or Node.js). An important feature of batt::Task to highlight is the static method batt::Task::await . This method allows the use of asynchronous continuation handler-based APIs (e.g., Boost Asio) in a \"blocking\" style. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include <batteries/async/task.hpp> #include <batteries/async/io_result.hpp> #include <batteries/assert.hpp> #include <batteries/utility.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/ip/tcp.hpp> // Some function to get a server endpoint to which to connect. // extern boost :: asio :: ip :: tcp :: endpoint get_server_endpoint (); int main () { // Create an io_context to schedule our Task and manage all asynchronous I/O. // boost :: asio :: io_context io ; // Create a TCP/IP socket; we will use this to connect to the server endpoint. // boost :: asio :: ip :: tcp :: socket s { io }; // Launch a task to act as our client. // batt :: Task client_task { io . get_executor (), /*body_fn=*/ [ & ] { // Connect to the server. batt::Task::await will not return until the handler passed // to `async_connect` has been invoked. // boost :: system :: error_code ec = batt :: Task :: await < boost :: system :: error_code > ([ & ]( auto && handler ){ s . async_connect ( get_server_endpoint (), BATT_FORWARD ( handler )); }); BATT_CHECK ( ! ec ); // Interact with the server via the connected socket... }}; // VERY IMPORTANT: without this line, nothing will happen! // io . run (); return 0 ; } All continuation handler based async APIs require a callback (the continuation handler). In order to simplify the code, we want to \"pause\" our code until the I/O is finished, but the async API, async_connect in this case, will return immediately. batt::Task::await gives us access to the \"continuation\" of the task, in this case everything that happens after await returns, as a handler that can be passed directly to async_connect . All the context swapping, scheduling, memory managment, and synchronization is handled automatically by batt::Task , allowing the programmer to focus on the application's natural flow of control, and not the mechanics used to implement this flow.","title":"Asynchronous I/O"},{"location":"async/#task-scheduling-and-priorities","text":"When a batt::Task is created, it is passed a Boost Asio executor object. All execution of task code on the task's stack will happen via boost::asio::dispatch or boost::asio::post using this executor. NOTE: this means if, for example, you use the executor from a boost::asio::io_context to create a task, that task will not run unless you call io_context::run() ! A running batt::Task is never preempted by another task. Instead it must yield control of the current thread to allow another task to run. There are four ways to do this: batt::Task::join() batt::Task::await() batt::Task::yield() batt::Task::sleep() WARNING: if you use a kernel or standard library synchronization mechanism or blocking call, for example std::mutex , from inside a batt::Task , that task WILL NOT YIELD! This is why the Batteries Async library contains its own synchronization primitives, like batt::Watch , batt::Queue , and batt::Mutex . All of these primitives are implemented on top one or more of the four methods enumerated above. Each batt::Task is assigned a scheduling priority, which is a signed 32-bit integer. Greater values of the priority int mean more urgent priority; lesser values mean less urgency. Even though tasks don't interrupt each other (i.e. preemption), they sometimes perform actions that cause another task to move from a \"waiting\" state to a \"ready to run\" state. For example, one task may be blocked inside a call to batt::Watch<T>::await_equal , and another task (let's call it the \"notifier\") may call batt::Watch<T>::set_value , activating the first task (let's call it the \"listener\"). As noted above, the newly activated (\"listener\") task will be run via boost::asio::dispatch or boost::asio::post . Which mechanism is used depends on the relative priority of the two tasks: If the \"notifier\" has a higher (numerically greater) priority value than the \"listener\", the \"listener\" is scheduled via boost::asio::post . Otherwise, the \"notifier\" is immediately suspended and re-scheduled via boost::asio::post ; then the \"listener\" is scheduled via boost::asio::dispatch . In any case, activating another task will not cause a running task to go from a \"running\" state to a \"waiting\" state. It may however \"bounce\" it to another thread, or to be pushed to the back of an execution queue. This only matters when there are more tasks ready to run than there are available threads for a given ExecutionContext: higher priority tasks are scheduled before lower priority ones in general. NOTE: you may still end up with a priority inversion situation when multiple tasks with different priorities are boost::asio::post -ed to the same queue. In this case, there is no mechanism currently for re-ordering the tasks to give preference based on priority. Overall, it is best to consider priority \"best-effort\" rather than a guarantee of scheduling order. It should be used for performance tuning, not to control execution semantics in a way that affects the functional behavior of a program.","title":"Task Scheduling and Priorities"},{"location":"async/#methods","text":"","title":"Methods"},{"location":"async/#batttasktaskexecutor-stack_size-body_fn","text":"Create a new Task with a custom stack size. 1 2 3 4 template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , batt :: StackSize stack_size , BodyFn && body_fn ) noexcept ;","title":"batt::Task::Task(executor, stack_size, body_fn)"},{"location":"async/#batttasktaskexecutor-body_fn-name-stack_size-stack_type-priority","text":"Create a new Task, optionally setting name, stack size, stack type, and priority. 1 2 3 4 5 6 7 template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , BodyFn && body_fn , std :: string && name = Task :: default_name (), StackSize stack_size = batt :: StackSize { 512 * 1024 }, batt :: StackType stack_type = batt :: StackType :: kFixedSize , batt :: Optional < Priority > priority = None ) noexcept ; The default priority for a Task is the current task priority plus 100; this means that a new Task by default will always \"soft-preempt\" the currently running task.","title":"batt::Task::Task(executor, body_fn, name, stack_size, stack_type, priority)"},{"location":"async/#batttaskawait","text":"Block the current thread until some asynchronous operation completes. 1 2 3 4 5 6 7 8 template < typename R , typename Fn = void ( Handler ) > static R await ( Fn && fn ); // (1) template < typename R , typename Fn = void ( Handler ) > static R await ( batt :: StaticType < R > , Fn && fn ); // (2) template < typename T > static batt :: StatusOr < T > await ( const batt :: Future < T >& future_result ); // (3) Overloads (1) & (2) take a function whose job is to initiate an asynchronous operation. Since async ops require a callback (which is invoked when the op completes), the function fn is passed a Handler which serves to wake up the task and resume its execution. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 boost :: asio :: ip :: tcp :: socket s ; using ReadResult = std :: pair < boost :: system :: error_code , std :: size_t > ; ReadResult r = batt :: Task :: await < ReadResult > ([ & ]( auto && handler ) { s . async_read_some ( buffers , BATT_FORWARD ( handler )); }); if ( r . first ) { std :: cout << \"Error! ec=\" << r . first ; } else { std :: cout << r . second << \" bytes were read.\" ; } The template parameter R is the return type of the await operation. R can be any type that is movable and constructible from the arguments passed to the callback Handler . In the example above, we define R to be a std::pair of the error code and the count of bytes read (size_t). This is the exact signature required by the async op initiated inside the lambda expression passed to await . When the socket implementation causes handler(ec, n_bytes_read) to be invoked, the Handler provided by batt::Task::await constructs an instance of R by forwarding the handler arguments ( auto retval = std::make_pair(ec, n_bytes_read); ), and resumes the task that was paused inside await , returning retval .","title":"batt::Task::await"},{"location":"async/#batttaskbacktrace_all","text":"Dumps stack trace and debug information for all active batt::Task s to stderr. 1 static i32 backtrace_all ( bool force ); If force is true, then this function will attempt to dump debug information for running tasks, even though this may cause data races (if you're debugging a tricky threading issue, sometimes the risk of a crash is outweighed by the benefit of some additional clues about what's going on!).","title":"batt::Task::backtrace_all"},{"location":"async/#batttaskcall_when_done","text":"Attaches a listener callback to the task; this callback will be invoked when the task completes execution. 1 2 template < typename F = void () > void call_when_done ( F && handler ); This method can be thought of as an asynchronous version of join() .","title":"batt::Task::call_when_done"},{"location":"async/#batttaskcurrent","text":"Returns a reference to the currently running Task, if there is one. 1 static batt :: Task & current (); WARNING: if this method is called outside of any batt::Task , behavior is undefined.","title":"batt::Task::current"},{"location":"async/#batttaskcurrent_name","text":"Returns the current task name, or \"\" if there is no current task. 1 static std :: string_view current_name (); Unlike batt::Task::current() , this method is safe to call outside a task.","title":"batt::Task::current_name"},{"location":"async/#batttaskcurrent_priority","text":"1 static batt :: Task :: Priority current_priority (); NOTE: this function is safe to call outside of a task; in this case, the default priority (0) is returned. See Task Scheduling and Priorities .","title":"batt::Task::current_priority"},{"location":"async/#batttaskcurrent_stack_pos","text":"Returns the offset of the current locus of control relative to the base of the stack. 1 static batt :: Optional < usize > current_stack_pos ();","title":"batt::Task::current_stack_pos"},{"location":"async/#batttaskcurrent_stack_pos_of","text":"Returns the offset of some address relative to the base of the current task stack. 1 static batt :: Optional < usize > current_stack_pos_of ( const volatile void * ptr ); NOTE: If ptr isn't actually on the current task's stack, then this function will still return a number, but it will be essentially a garbage value. It's up to the caller to make sure that ptr points at something on the task stack.","title":"batt::Task::current_stack_pos_of"},{"location":"async/#batttaskdefault_name","text":"1 static std :: string default_name ()","title":"batt::Task::default_name"},{"location":"async/#batttasksleep","text":"Puts a batt::Task to sleep for the specified real-time duration. 1 2 template < typename Duration = boost :: posix_time :: ptime > static batt :: ErrorCode sleep ( const Duration & duration ); This operation can be interrupted by a batt::Task::wake() , in which case a \"cancelled\" error code is returned instead of success (no error). This method is safe to call outside a task; in this case, it is implemented via std::this_task::sleep_for .","title":"batt::Task::sleep"},{"location":"async/#batttaskget_executor","text":"Returns a copy of the executor passed to the given task at construction time. 1 batt :: Task :: executor_type get_executor () const ;","title":"batt::Task::get_executor"},{"location":"async/#batttaskget_priority","text":"Get the priority of this task. 1 batt :: Task :: Priority get_priority () const ; See Task Scheduling and Priorities .","title":"batt::Task::get_priority"},{"location":"async/#batttaskid","text":"Get the process-unique serial number of this task. 1 i32 id () const ;","title":"batt::Task::id"},{"location":"async/#batttaskjoin","text":"Block until the task has finished. 1 void join ();","title":"batt::Task::join"},{"location":"async/#batttaskname","text":"Get the human-friendly name of this task. 1 std :: string_view name () const ; This string is not necessarily unique to this task. It is optionally passed in when the task is constructed. The purpose is to identify the task for debugging purposes.","title":"batt::Task::name"},{"location":"async/#batttaskset_priority","text":"Set the scheduling priority of this task. 1 void set_priority ( batt :: Task :: Priority new_priority ); See Task Scheduling and Priorities .","title":"batt::Task::set_priority"},{"location":"async/#batttaskstack_pos","text":"Get the byte offset between the current stack position and the base of this task's stack. This value is only meaningful if this method is called while on the current task. Usually you should just call batt::Task::current_stack_pos() instead. 1 usize stack_pos() const;","title":"batt::Task::stack_pos"},{"location":"async/#batttaskstack_pos_of","text":"Get the byte offset between the given pointer and the base of this task's stack. It is up to the caller to make sure that ptr is the address of something on the task's stack. Usually you should just call batt::Task::current_stack_pos_of instead. 1 usize stack_pos_of ( const volatile void * ptr ) const ;;","title":"batt::Task::stack_pos_of"},{"location":"async/#batttasktry_join","text":"Test whether this task has finished. 1 bool try_join (); This function is guaranteed never to block. See batt::Task::join() .","title":"batt::Task::try_join"},{"location":"async/#batttaskwake","text":"Interrupts a call to batt::Task::sleep on the given task. 1 bool wake (); NOTE: if the given task is suspended for some other reason (i.e., it is not inside a call to batt::Task::sleep ), this method will not wake the task (in this case it will return false ).","title":"batt::Task::wake"},{"location":"async/#batttaskyield","text":"Suspend the current task and immediately schedule it to resume via boost::asio::post . 1 static void yield ();","title":"batt::Task::yield"},{"location":"async/#battwatcht","text":"","title":"batt::Watch&lt;T&gt;"},{"location":"async/#summary_1","text":"1 #include <batteries/async/watch.hpp> Constructors Watch() Watch(T) Getters Modifiers Synchronization is_closed close fetch_add async_wait await_not_equal get_value set_value fetch_sub await_equal modify fetch_or await_true modify_if fetch_and await_modify","title":"Summary"},{"location":"async/#description_1","text":"A batt::Watch is like a std::atomic that you can block on, synchronously and asynchronously. Like std::atomic , it has methods to atomically get/set/increment/etc. But unlike std::atomic , you can also block a task waiting for some condition to be true. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <batteries/async/watch.hpp> #include <batteries/assert.hpp> // for BATT_CHECK_OK #include <batteries/status.hpp> // for batt::Status int main () { batt :: Watch < bool > done { false }; // Launch some background task that will do stuff, then set `done` // to `true` when it is finished. // launch_background_task ( & done ); batt :: Status status = done . await_equal ( true ); BATT_CHECK_OK ( status ); return 0 ; }","title":"Description"},{"location":"async/#methods_1","text":"","title":"Methods"},{"location":"async/#battwatchwatch","text":"Constructs a batt::Watch object with a default-initialized value of T .","title":"batt::Watch::Watch()"},{"location":"async/#battwatchwatcht-init_value","text":"Constructs a batt::Watch object with the given initial value.","title":"batt::Watch::Watch(T init_value)"},{"location":"async/#battwatchasync_wait","text":"Invokes the passed handler fn with the described value as soon as one of the following conditions is true: * When the Watch value is not equal to the passed value last_seen , invoke fn with the current value of the Watch. * When the Watch is closed, invoke fn with batt::StatusCode::kClosed . 1 2 template < typename Handler = void ( batt :: StatusOr < T > new_value ) > void async_wait ( T last_seen , Handler && fn ) const ;","title":"batt::Watch::async_wait"},{"location":"async/#battwatchawait_equal","text":"Blocks the current task/thread until the Watch contains the specified value. 1 batt :: Status await_equal ( T val ) const ;","title":"batt::Watch::await_equal"},{"location":"async/#battwatchawait_modify","text":"Retries fn on the Watch value until it succeeds or the Watch is closed. 1 2 template < typename Fn = batt :: Optional < T > ( T ) > batt :: StatusOr < T > await_modify ( Fn && fn ); If fn returns batt::None , this indicates fn should not be called again until a new value is available. fn MUST be safe to call multiple times within a single call to await_modify . This is because await_modify may be implemented via an atomic compare-and-swap loop.","title":"batt::Watch::await_modify"},{"location":"async/#battwatchawait_not_equal","text":"Blocks the current task/thread until the Watch value is not equal to last_seen . 1 batt :: StatusOr < T > await_not_equal ( T last_seen );","title":"batt::Watch::await_not_equal"},{"location":"async/#battwatchawait_true","text":"Blocks the current task/thread until the passed predicate function returns true for the current value of the Watch. 1 2 template < typename Pred = bool ( T ) > batt :: StatusOr < T > await_true ( Pred && pred ); This is the most general of Watch's blocking getter methods.","title":"batt::Watch::await_true"},{"location":"async/#battwatchclose","text":"Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. 1 void close (); This method is safe to call multiple times. The Watch value can still be modified and retrieved after it is closed; this only disables the methods in the \"Synchronization\" category (see Summary section above).","title":"batt::Watch::close"},{"location":"async/#battwatchfetch_add","text":"Atomically adds the specified amount to the Watch value, returning the previous value. 1 T fetch_add ( T arg ); NOTE: This method is only available if T is a primitive integer type.","title":"batt::Watch::fetch_add"},{"location":"async/#battwatchfetch_and","text":"Atomically sets the Watch value to the bitwise-and of the current value and the passed arg , returning the previous value. 1 T fetch_and ( T arg ); NOTE: This method is only available if T is a primitive integer type.","title":"batt::Watch::fetch_and"},{"location":"async/#battwatchfetch_or","text":"Atomically sets the Watch value to the bitwise-and of the current value and the passed arg , returning the previous value. 1 T fetch_or ( T arg ); NOTE: This method is only available if T is a primitive integer type.","title":"batt::Watch::fetch_or"},{"location":"async/#battwatchfetch_sub","text":"Atomically subtracts the specified amount to the Watch value, returning the previous value. 1 T fetch_sub ( T arg ); NOTE: This method is only available if T is a primitive integer type.","title":"batt::Watch::fetch_sub"},{"location":"async/#battwatchget_value","text":"Returns the current value of the Watch to the caller. 1 T get_value () const ;","title":"batt::Watch::get_value"},{"location":"async/#battwatchis_closed","text":"Returns whether the Watch is in a \"closed\" state. 1 bool is_closed () const ;","title":"batt::Watch::is_closed"},{"location":"async/#battwatchmodify","text":"Atomically modifies the Watch value by applying the passed transform fn . 1 2 template < typename Fn = T ( T ) > T modify ( Fn && fn ); fn MUST be safe to call multiple times within a single call to modify . This is because modify may be implemented via an atomic compare-and-swap loop.","title":"batt::Watch::modify"},{"location":"async/#battwatchmodify_if","text":"Retries calling fn on the Watch value until EITHER of: * fn returns batt::None * BOTH of: * fn returns a non- batt::None value * the Watch value is atomically updated via compare-and-swap 1 2 template < typename Fn = batt :: Optional < T > ( T ) > batt :: Optional < T > modify_if ( Fn && fn ); fn MUST be safe to call multiple times within a single call to modify_if . This is because modify_if may be implemented via an atomic compare-and-swap loop. Unlike await_modify , this method never puts the current task/thread to sleep; it keeps actively polling the Watch value until it reaches one of the exit criteria described above.","title":"batt::Watch::modify_if"},{"location":"async/#battwatchset_value","text":"Atomically set the value of the Watch. 1 void set_value ( T new_value );","title":"batt::Watch::set_value"},{"location":"async/#battmutext","text":"","title":"batt::Mutex&lt;T&gt;"},{"location":"async/#summary_2","text":"1 #include <batteries/async/mutex.hpp> Constructors Mutex() Mutex(args...) Methods lock lock (const) with_lock Operators operator-> Static Methods thread_safe_base","title":"Summary"},{"location":"async/#description_2","text":"Provides mutually-exclusive access to an instance of type T . This class has two advantages over std::mutex : It will yield the current batt::Task (if there is one) when blocking to acquire a lock, allowing the current thread to be used by other tasks By embedding the protected type T within the object, there is a much lower chance that state which should be accessed via a mutex will accidentally be accessed directly This mutex implementation is mostly fair because it uses Lamport's Bakery Algorithm . It is non-recursive, so threads/tasks that attempt to acquire a lock that they already have will deadlock. Also, an attempt to acquire a lock on a batt::Mutex can't be cancelled, so it is not possible to set a timeout on lock acquisition. An instance of batt::Mutex<T> may be locked in a few different ways:","title":"Description"},{"location":"async/#lock-via-guard-class-similar-to-stdunique_lock","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 batt :: Mutex < std :: string > s ; { batt :: Mutex < std :: string >:: Lock lock { s }; // Once the lock is acquired, you can access the protected object via pointer... // std :: string * ptr = lock . get (); // ... or by reference ... // std :: string & ref = lock . value (); // ... by operator* like a smart pointer... // std :: string & ref2 = * lock ; // ... or you can access its members via operator->: // const char * cs = lock -> c_str (); } // The lock is released when the guard class goes out of scope. Equivalently, an instance of batt::Mutex<T>::Lock can be created via the lock() method: 1 2 3 4 5 6 7 batt :: Mutex < std :: string > s ; { auto locked = s . lock (); static_assert ( std :: is_same_v < decltype ( locked ), batt :: Mutex < std :: string >:: Lock > , \"It is nice to use auto in this case!\" ); } As the second example implies, batt::Mutex<T>::Lock is a movable type (however it is non-copyable).","title":"Lock via guard class (similar to std::unique_lock)"},{"location":"async/#run-function-with-lock-acquired","text":"1 2 3 4 5 batt :: Mutex < std :: string > s { \"Some string\" }; s . with_lock ([]( std :: string & locked_s ) { locked_s += \" and then some!\" ; });","title":"Run function with lock acquired"},{"location":"async/#lock-free-access-to-t","text":"Even though access to the protected object of type T mostly happens via a lock, batt::Mutex supports types with a partial interface that is thread-safe without locking. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 struct MyStateBase { explicit MyStateBase ( std :: string && init_val ) : initial_value { std :: move ( init_val )} {} const std :: string initial_value ; }; struct MyState : MyStateBase { // IMPORTANT: this member type alias tells batt::Mutex to enable the `no_lock()` method/feature. // using ThreadSafeBase = MyStateBase ; explicit MyState ( std :: string && init_val ) : MyStateBase { init_val } , current_value { init_val } {} }; batt :: Mutex < MyState > state { \"initial\" }; // No lock needed to read a const value. // std :: cout << \"initial value = \" << state . no_lock (). initial_value << std :: endl ; // We still need to acquire the lock to access the derived class. // state . with_lock ([]( MyState & s ) { std :: cout << \"current value = \" << s . current_value << std :: endl ; s . current_value = \"changed\" ; }); // batt::Mutex::nolock returns a reference to the ThreadSafeBase type declared in MyState. // MyStateBase & base = state . no_lock ();","title":"Lock-free access to T"},{"location":"case_of.hpp/","text":"<batteries/case_of.hpp>: switch -like handling for std::variant \ud83d\udd17 batt::case_of is a replacement for std::visit . Example: 1 2 3 4 5 6 7 8 9 10 11 12 std :: variant < Foo , Bar > var = Bar {}; int result = batt :: case_of ( var , []( const Foo & ) { return 1 ; }, []( const Bar & ) { return 2 ; }); BATT_CHECK_EQ ( result , 2 ); batt::case_of \ud83d\udd17 The form of batt::case_of is: batt::case_of( variant-object , handler-for-case-1 , handler-for-case-2 , ...); The \"handlers\" can be any callable type that takes one argument whose type matches one of the types in the variant passed as variant-object . The handlers do not have to return a value, but if any of them do, they must all return the same type. The handler that will be invoked is the first one (from left to right) that is invokable for a given variant case type. This behavior allows you to write things like: 1 2 3 4 5 6 7 8 9 10 11 12 13 std :: variant < std :: logic_error , std :: runtime_error , std :: string , int , double > v ; batt :: case_of ( v , []( const std :: exception & e ) { // common code for all types deriving from std::exception }, []( int i ) { // a special case for integers }, []( const auto & value ) { // A default case for everything else }); batt::make_case_of_visitor \ud83d\udd17 You can construct an overloaded functor from a list of functions with the same number of arguments using batt::make_cose_of_visitor . This functor behaves similarly to batt::case_of (and in fact is used to implement case_of ): the function that actually gets invoked on a particular set of arguments is the first one in the list whose paramaeters will bind to those arguments. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 auto do_stuff = batt :: make_case_of_visitor ( []( int ) { std :: cout << \"one int\" << std :: endl ; }, []( int , int ) { std :: cout << \"two ints\" << std :: endl ; }, []( auto && ...) { std :: cout << \"something else!\" << std :: endl ; }); do_stuff ( 5 ); do_stuff ( 9 , 4 ); do_stuff (); do_stuff ( \"hello, world!\" ); Output: 1 2 3 4 one int two ints something else ! something else !","title":"&lt;batteries/case_of.hpp&gt;: `switch`-like handling for `std::variant`"},{"location":"case_of.hpp/#battcase_of","text":"The form of batt::case_of is: batt::case_of( variant-object , handler-for-case-1 , handler-for-case-2 , ...); The \"handlers\" can be any callable type that takes one argument whose type matches one of the types in the variant passed as variant-object . The handlers do not have to return a value, but if any of them do, they must all return the same type. The handler that will be invoked is the first one (from left to right) that is invokable for a given variant case type. This behavior allows you to write things like: 1 2 3 4 5 6 7 8 9 10 11 12 13 std :: variant < std :: logic_error , std :: runtime_error , std :: string , int , double > v ; batt :: case_of ( v , []( const std :: exception & e ) { // common code for all types deriving from std::exception }, []( int i ) { // a special case for integers }, []( const auto & value ) { // A default case for everything else });","title":"batt::case_of"},{"location":"case_of.hpp/#battmake_case_of_visitor","text":"You can construct an overloaded functor from a list of functions with the same number of arguments using batt::make_cose_of_visitor . This functor behaves similarly to batt::case_of (and in fact is used to implement case_of ): the function that actually gets invoked on a particular set of arguments is the first one in the list whose paramaeters will bind to those arguments. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 auto do_stuff = batt :: make_case_of_visitor ( []( int ) { std :: cout << \"one int\" << std :: endl ; }, []( int , int ) { std :: cout << \"two ints\" << std :: endl ; }, []( auto && ...) { std :: cout << \"something else!\" << std :: endl ; }); do_stuff ( 5 ); do_stuff ( 9 , 4 ); do_stuff (); do_stuff ( \"hello, world!\" ); Output: 1 2 3 4 one int two ints something else ! something else !","title":"batt::make_case_of_visitor"},{"location":"coding_style/","text":"Batteries C++ Coding Style Guide \ud83d\udd17 This document describes the coding conventions to be followed in this library. File Names \ud83d\udd17 Source, header, inline/implementation, and test sources should be colocated within the same directory. Source files should use the .cpp extension. Header files should use the .hpp extension. Test files for a given source/header should use the .test.cpp suffix. For example, if you have a header file: src/some_namespace/myutils.hpp , then you should also have: src/some_namespace/myutils.cpp src/some_namespace/myutils.test.cpp src/some_namespace/myutils.ipp Class Member Access \ud83d\udd17 To enhance readability, all implicit uses of this within a class should be made explicit. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // DO NOT write: // class MyClass { public : void my_method () { internal_method (); } private : void internal_method () { ++ counter_ ; } int counter_ ; }; // Instead, DO write: // class MyClass { public : void my_method () { this -> internal_method (); } private : void internal_method () { ++ this -> counter_ ; } int counter_ ; };","title":"Batteries C++ Coding Style Guide"},{"location":"coding_style/#file-names","text":"Source, header, inline/implementation, and test sources should be colocated within the same directory. Source files should use the .cpp extension. Header files should use the .hpp extension. Test files for a given source/header should use the .test.cpp suffix. For example, if you have a header file: src/some_namespace/myutils.hpp , then you should also have: src/some_namespace/myutils.cpp src/some_namespace/myutils.test.cpp src/some_namespace/myutils.ipp","title":"File Names"},{"location":"coding_style/#class-member-access","text":"To enhance readability, all implicit uses of this within a class should be made explicit. For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // DO NOT write: // class MyClass { public : void my_method () { internal_method (); } private : void internal_method () { ++ counter_ ; } int counter_ ; }; // Instead, DO write: // class MyClass { public : void my_method () { this -> internal_method (); } private : void internal_method () { ++ this -> counter_ ; } int counter_ ; };","title":"Class Member Access"},{"location":"cpu_align.hpp/","text":"<batteries/cpu_align.hpp>: Prevent false sharing by isolating a type in its own cache line(s). \ud83d\udd17 File Reference Features \ud83d\udd17 Class template batt::CpuCacheLineIsolated for guaranteed cache-line isolation of an object. Details \ud83d\udd17 Sometimes when objects modified by different threads are packed too closely in memory, performance can degrade significantly due to a \"ping-pong\" effect where each CPU/core that modifies an object in the same cache line (the minimum-sized block of memory fetched from main memory into cache) must wait to read changes made to the other objects in that cache line. This problem can be solved by padding the memory into which the objects are placed to ensure each resides within its own cache line. batt::CpuCacheLineIsolated<T> makes this very simple and easy to do. 1 2 3 4 5 6 7 8 9 10 11 12 // More compact, but slower due to false sharing between CPUs: // std :: array < int , 100 > slow_ints ; // Each int is padded and aligned so it gets its own cache line: // std :: array < batt :: CpuCacheLineIsolated < int > , 100 > fast_ints ; // The underlying `T` (int in this case) is accessed via `*` and `->` // operators, like a pointer or `std::optional`. // int & i_ref = * fast_int [ 0 ];","title":"&lt;batteries/cpu\\_align.hpp&gt;: Prevent false sharing by isolating a type in its own cache line(s)."},{"location":"cpu_align.hpp/#features","text":"Class template batt::CpuCacheLineIsolated for guaranteed cache-line isolation of an object.","title":"Features"},{"location":"cpu_align.hpp/#details","text":"Sometimes when objects modified by different threads are packed too closely in memory, performance can degrade significantly due to a \"ping-pong\" effect where each CPU/core that modifies an object in the same cache line (the minimum-sized block of memory fetched from main memory into cache) must wait to read changes made to the other objects in that cache line. This problem can be solved by padding the memory into which the objects are placed to ensure each resides within its own cache line. batt::CpuCacheLineIsolated<T> makes this very simple and easy to do. 1 2 3 4 5 6 7 8 9 10 11 12 // More compact, but slower due to false sharing between CPUs: // std :: array < int , 100 > slow_ints ; // Each int is padded and aligned so it gets its own cache line: // std :: array < batt :: CpuCacheLineIsolated < int > , 100 > fast_ints ; // The underlying `T` (int in this case) is accessed via `*` and `->` // operators, like a pointer or `std::optional`. // int & i_ref = * fast_int [ 0 ];","title":"Details"},{"location":"faq/","text":"Frequently Asked Questions \ud83d\udd17 TOC {:toc} Why is it called 'batteries'? \ud83d\udd17 The name derives from the idomatic expression \"batteries not included,\" referring to something that is missing some essential pieces in order to be useful. Anyone who has ever had their C++ program crash with nothing but the following output... 1 2 Segmentation fault ( core dumped ) $ ...knows what I'm talking about. Um, stack trace please? It's also a bit of a pun on the statement you use to import the batteries library: 1 #include <batteries.hpp>","title":"Frequently Asked Questions"},{"location":"faq/#why-is-it-called-batteries","text":"The name derives from the idomatic expression \"batteries not included,\" referring to something that is missing some essential pieces in order to be useful. Anyone who has ever had their C++ program crash with nothing but the following output... 1 2 Segmentation fault ( core dumped ) $ ...knows what I'm talking about. Um, stack trace please? It's also a bit of a pun on the statement you use to import the batteries library: 1 #include <batteries.hpp>","title":"Why is it called 'batteries'?"},{"location":"finally.hpp/","text":"Function batt::finally to execute arbitrary code at scope exit. File Reference","title":"Finally.hpp"},{"location":"getting-started/","text":"Getting Started \ud83d\udd17 Add the batteriesincluded repo to your conan remotes: 1 conan remote add batteriesincluded https://api.bintray.com/conan/batteriesincluded/conan Add a ref to batteries (latest release=0.2.0): 1 conan remote add_ref batteries/0.2.0@demo/testing batteriesincluded Now add this to your conan project requirements (conanfile.py): 1 2 3 4 requires = [ ... \"batteries/0.2.0@demo/testing\", ]","title":"Getting Started"},{"location":"hint.hpp/","text":"Branch prediction hint macros: BATT_HINT_TRUE , BATT_HINT_FALSE File Reference","title":"Hint.hpp"},{"location":"int_types.hpp/","tags":["ergonomics","portability"],"text":"Rust-like type aliases for standard integer types. File Reference","title":"<batteries/int_types.hpp>"},{"location":"nullable.hpp/","text":"Trait batt::Nullable for transforming arbitrary types into a type that can be given a \"null\" or empty value. File Reference","title":"Nullable.hpp"},{"location":"platforms/","text":"Supported Platforms \ud83d\udd17 Batteries is written in C++17. Supported Compilers: Clang/LLVM 11 (x86_54) GCC 9.3 Supported Operating Systems: GNU/Linux (kernel 5.8 or newer) macOS Catalina","title":"Supported Platforms"},{"location":"segv.hpp/","text":"Just include this header to enable automatic stack trace dump to STDERR on seg fault. File Reference","title":"Segv.hpp"},{"location":"seq/","text":"<batteries/seq/...%gt;: Fast, Ergonomic Sequence Processing \ud83d\udd17 The Batteries Seq abstraction builds on top of STL iterator ranges, seeking to offer more readable and maintainable code without sacrificing efficiency. Intro Example \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <batteries/seq.hpp> #include <iostream> #include <vector> int main () { std :: vector < int > nums = { 1 , 2 , 3 , 4 , 5 }; int sum_of_lens_under_5 = batt :: as_seq ( nums ) | batt :: seq :: map ([]( int n ) { return batt :: to_string ( n ); }) | batt :: seq :: filter ([]( const std :: string & s ) { return s . length () < 5 ; }) | batt :: seq :: map ([]( const std :: string & s ) { return s . length (); }) | batt :: seq :: sum (); std :: cout << \"The total length of strings under 5 is: \" << ( 3 + 3 + 4 + 4 ) << std :: endl ; return 0 ; } Output: 1 The total length of strings under 5 is: 14 The Seq<T> Abstraction \ud83d\udd17 Seq<T> is a concept that represents an ordered sequence of objects of type T . The class batt::BoxedSeq is a type-erased container for an object that models this concept. The type requirements/interface of batt::BoxedSeq<T> are: Seq<T> must be copy-constructible, copy-assignable, and publically destructible Seq<T> must have a public type member or type alias/typedef named Item , equivalent to T Given an object seq of type Seq<T> : seq.peek() must return a value of type batt::Optional<T> ; if the sequence is empty or at its end, batt::None is returned, otherwise the next item in the sequence is returned seq.next() is the same in terms of returned value, but it additionally has the side effect of consuming the returned item from the sequence Converting STL Containers and Iterator Ranges to Seqs \ud83d\udd17 The function batt::as_seq is used to create a Seq from STL containers and ranges in order to access the rest of the Seq API. You can pass a range, a pair of iterators, or a starting iterator and a size to overloads of batt::as_seq to do this. Manipulating Sequences By Composing Operators \ud83d\udd17","title":"&lt;batteries/seq/...%gt;: Fast, Ergonomic Sequence Processing"},{"location":"seq/#intro-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <batteries/seq.hpp> #include <iostream> #include <vector> int main () { std :: vector < int > nums = { 1 , 2 , 3 , 4 , 5 }; int sum_of_lens_under_5 = batt :: as_seq ( nums ) | batt :: seq :: map ([]( int n ) { return batt :: to_string ( n ); }) | batt :: seq :: filter ([]( const std :: string & s ) { return s . length () < 5 ; }) | batt :: seq :: map ([]( const std :: string & s ) { return s . length (); }) | batt :: seq :: sum (); std :: cout << \"The total length of strings under 5 is: \" << ( 3 + 3 + 4 + 4 ) << std :: endl ; return 0 ; } Output: 1 The total length of strings under 5 is: 14","title":"Intro Example"},{"location":"seq/#the-seqt-abstraction","text":"Seq<T> is a concept that represents an ordered sequence of objects of type T . The class batt::BoxedSeq is a type-erased container for an object that models this concept. The type requirements/interface of batt::BoxedSeq<T> are: Seq<T> must be copy-constructible, copy-assignable, and publically destructible Seq<T> must have a public type member or type alias/typedef named Item , equivalent to T Given an object seq of type Seq<T> : seq.peek() must return a value of type batt::Optional<T> ; if the sequence is empty or at its end, batt::None is returned, otherwise the next item in the sequence is returned seq.next() is the same in terms of returned value, but it additionally has the side effect of consuming the returned item from the sequence","title":"The Seq&lt;T&gt; Abstraction"},{"location":"seq/#converting-stl-containers-and-iterator-ranges-to-seqs","text":"The function batt::as_seq is used to create a Seq from STL containers and ranges in order to access the rest of the Seq API. You can pass a range, a pair of iterators, or a starting iterator and a size to overloads of batt::as_seq to do this.","title":"Converting STL Containers and Iterator Ranges to Seqs"},{"location":"seq/#manipulating-sequences-by-composing-operators","text":"","title":"Manipulating Sequences By Composing Operators"},{"location":"small_fn.hpp/","text":"Type-erased function wrappers that are guaranteed not to allocate: batt::SmallFn , batt::UniqueSmallFn . File Reference","title":"Small fn.hpp"},{"location":"static_assert.hpp/","text":"Comparison based static assertion macros that, when failure occurs, cause compiler output to contain the values being compared. Macro Name Assertion BATT_STATIC_ASSERT_EQ (x,y) x == y BATT_STATIC_ASSERT_NE (x,y) x != y BATT_STATIC_ASSERT_LT (x,y) x < y BATT_STATIC_ASSERT_GT (x,y) x > y BATT_STATIC_ASSERT_LE (x,y) x <= y BATT_STATIC_ASSERT_GE (x,y) x >= y File Reference","title":"Static assert.hpp"},{"location":"static_dispatcher.hpp/","text":"Function batt::static_dispatch that transforms a runtime integer value into a compile-time (static) integer constant type. Macro BATT_CONST for turning constant integer expressions into static types. File Reference","title":"Static dispatcher.hpp"},{"location":"status.hpp/","text":"<batteries/status.hpp>: Efficient, Ergonomic Error Handling \ud83d\udd17 Summary \ud83d\udd17 1 #include <batteries/status.hpp> Types Functions Macros batt::Status batt::to_status BATT_REQUIRE_OK batt::StatusCode batt::OkStatus BATT_CHECK_OK batt::StatusOr<T> batt::status_from_retval BATT_OK_RESULT_OR_PANIC batt::ErrnoValue batt::status_from_errno BATT_ASSIGN_OK_RESULT batt::IsStatusOr<T> batt::status_is_retryable batt::RemoveStatusOr<T> batt::is_ok_status batt::LogLevel batt::ok_result_or_panic<T> Why not exceptions? \ud83d\udd17 Batteries C++ discourages the use of exceptions as an error handling mechanism. Exceptions tend to hurt the readability and maintainability of code because they introduce non-local control flow (throw statements can jump to catch statements arbitrarily far away with no obvious connection between the two points), break the separation of interface and implementation (because implementations can silently introduce new failure modes because of a deep change, even several layers down), and add to the complexity of syntax because when you program with exceptions now there are multiple ways to return a value from a function, each with its own caveats and idiosyncrasies. The purported benefit of exceptions, that they clean up the code by hiding error handling code, does more harm than good because failure modes are an essential element to understanding any code. What instead of exceptions? (batt::Status) \ud83d\udd17 In place of exceptions, Batteries provides batt::Status and many related constructs. DISCLAIMER/ACKNOWLEDGMENT: batt::Status is modelled very closely after absl::Status from Google's Abseil library. A batt::Status is like an exception in that it represents a specific error condition, but it can also represent no error at all. When a function that returns a value, say an int , can also fail, it is best to write it as: 1 batt :: StatusOr < int > parse_int ( std :: string_view s ); In this example, we imagine a function that takes a string and parses it as an integer value. Because this operation may fail (if for example it is handed an invalid string like \"hello, world\"), we declare the return type as batt::StatusOr<int> . Functions returning no value that can fail should just return batt::Status . To make the use of Status easier in practice, Batteries provides several macros to automatically unwrap a Status or propagate it up a call stack. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 batt :: StatusOr < Endpoint > resolve_url ( std :: string url ); batt :: StatusOr < std :: string > download_from_server ( std :: string url ) { // This will panic (crash) our program if the url fails to resolve. // Endpoint endpoint = BATT_OK_RESULT_OR_PANIC ( resolve_url ( url )); // Connect to the server. // batt :: StatusOr < Socket > maybe_socket = connect_to_server ( endpoint ); BATT_REQUIRE_OK ( maybe_socket ); // // ^^^ This will cause the current function to return the non-ok status // code if there is an error, or continue otherwise. // We can unwrap the StatusOr like this. // Socket & socket = * maybe_socket ; // This macro combines the two steps above, checking for errors // and unwrapping the value. // BATT_ASSIGN_OK_RESULT ( std :: string data , socket . read_all ()); // Done! // return data ; } Standard Status Codes \ud83d\udd17 Batteries provides the same standard status codes as Abseil Status, plus a few extras: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 enum class StatusCode : int { kOk = 0 , kCancelled = 1 , kUnknown = 2 , kInvalidArgument = 3 , kDeadlineExceeded = 4 , kNotFound = 5 , kAlreadyExists = 6 , kPermissionDenied = 7 , kResourceExhausted = 8 , kFailedPrecondition = 9 , kAborted = 10 , kOutOfRange = 11 , kUnimplemented = 12 , kInternal = 13 , kUnavailable = 14 , kDataLoss = 15 , kUnauthenticated = 16 , // ... // This range reserved for future allocation of Abseil status codes. // ... kClosed = 100 , kGrantUnavailable = 101 , kLoopBreak = 102 , }; Handling System Errors \ud83d\udd17 In addition, batt::Status can accept standard errno values from system calls: 1 2 3 4 5 6 7 8 9 batt :: Status example () { int fd = open ( \"something.txt\" , 0 ); if ( fd == -1 ) { return batt :: status_from_errno ( errno ); } return batt :: OkStatus (); } In fact, because this pattern is so common when invoking system APIs, the above example can also be written as: 1 2 3 4 5 6 7 batt :: Status even_better_example () { int fd = open ( \"something.txt\" , 0 ); BATT_REQUIRE_OK ( batt :: status_from_retval ( fd )); return batt :: OkStatus (); } batt::Status \ud83d\udd17 Summary \ud83d\udd17 1 #include <batteries/status.hpp> Constructors Operators Methods Status() operator= ok group Status(enum_value) operator<< code IgnoreError Status(const Status&) operator== message Update Static Methods Types Constants code_group_for_type value_type kGroupSizeBits message_from_code CodeEntry kGroupSize register_codes CodeGroup kMaxGroups unknown_enum_value_message Constructors \ud83d\udd17 Operators \ud83d\udd17 Methods \ud83d\udd17 Static Methods \ud83d\udd17 Types \ud83d\udd17 Constants \ud83d\udd17","title":"&lt;batteries/status.hpp&gt;: Efficient, Ergonomic Error Handling"},{"location":"status.hpp/#summary","text":"1 #include <batteries/status.hpp> Types Functions Macros batt::Status batt::to_status BATT_REQUIRE_OK batt::StatusCode batt::OkStatus BATT_CHECK_OK batt::StatusOr<T> batt::status_from_retval BATT_OK_RESULT_OR_PANIC batt::ErrnoValue batt::status_from_errno BATT_ASSIGN_OK_RESULT batt::IsStatusOr<T> batt::status_is_retryable batt::RemoveStatusOr<T> batt::is_ok_status batt::LogLevel batt::ok_result_or_panic<T>","title":"Summary"},{"location":"status.hpp/#why-not-exceptions","text":"Batteries C++ discourages the use of exceptions as an error handling mechanism. Exceptions tend to hurt the readability and maintainability of code because they introduce non-local control flow (throw statements can jump to catch statements arbitrarily far away with no obvious connection between the two points), break the separation of interface and implementation (because implementations can silently introduce new failure modes because of a deep change, even several layers down), and add to the complexity of syntax because when you program with exceptions now there are multiple ways to return a value from a function, each with its own caveats and idiosyncrasies. The purported benefit of exceptions, that they clean up the code by hiding error handling code, does more harm than good because failure modes are an essential element to understanding any code.","title":"Why not exceptions?"},{"location":"status.hpp/#what-instead-of-exceptions-battstatus","text":"In place of exceptions, Batteries provides batt::Status and many related constructs. DISCLAIMER/ACKNOWLEDGMENT: batt::Status is modelled very closely after absl::Status from Google's Abseil library. A batt::Status is like an exception in that it represents a specific error condition, but it can also represent no error at all. When a function that returns a value, say an int , can also fail, it is best to write it as: 1 batt :: StatusOr < int > parse_int ( std :: string_view s ); In this example, we imagine a function that takes a string and parses it as an integer value. Because this operation may fail (if for example it is handed an invalid string like \"hello, world\"), we declare the return type as batt::StatusOr<int> . Functions returning no value that can fail should just return batt::Status . To make the use of Status easier in practice, Batteries provides several macros to automatically unwrap a Status or propagate it up a call stack. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 batt :: StatusOr < Endpoint > resolve_url ( std :: string url ); batt :: StatusOr < std :: string > download_from_server ( std :: string url ) { // This will panic (crash) our program if the url fails to resolve. // Endpoint endpoint = BATT_OK_RESULT_OR_PANIC ( resolve_url ( url )); // Connect to the server. // batt :: StatusOr < Socket > maybe_socket = connect_to_server ( endpoint ); BATT_REQUIRE_OK ( maybe_socket ); // // ^^^ This will cause the current function to return the non-ok status // code if there is an error, or continue otherwise. // We can unwrap the StatusOr like this. // Socket & socket = * maybe_socket ; // This macro combines the two steps above, checking for errors // and unwrapping the value. // BATT_ASSIGN_OK_RESULT ( std :: string data , socket . read_all ()); // Done! // return data ; }","title":"What instead of exceptions? (batt::Status)"},{"location":"status.hpp/#standard-status-codes","text":"Batteries provides the same standard status codes as Abseil Status, plus a few extras: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 enum class StatusCode : int { kOk = 0 , kCancelled = 1 , kUnknown = 2 , kInvalidArgument = 3 , kDeadlineExceeded = 4 , kNotFound = 5 , kAlreadyExists = 6 , kPermissionDenied = 7 , kResourceExhausted = 8 , kFailedPrecondition = 9 , kAborted = 10 , kOutOfRange = 11 , kUnimplemented = 12 , kInternal = 13 , kUnavailable = 14 , kDataLoss = 15 , kUnauthenticated = 16 , // ... // This range reserved for future allocation of Abseil status codes. // ... kClosed = 100 , kGrantUnavailable = 101 , kLoopBreak = 102 , };","title":"Standard Status Codes"},{"location":"status.hpp/#handling-system-errors","text":"In addition, batt::Status can accept standard errno values from system calls: 1 2 3 4 5 6 7 8 9 batt :: Status example () { int fd = open ( \"something.txt\" , 0 ); if ( fd == -1 ) { return batt :: status_from_errno ( errno ); } return batt :: OkStatus (); } In fact, because this pattern is so common when invoking system APIs, the above example can also be written as: 1 2 3 4 5 6 7 batt :: Status even_better_example () { int fd = open ( \"something.txt\" , 0 ); BATT_REQUIRE_OK ( batt :: status_from_retval ( fd )); return batt :: OkStatus (); }","title":"Handling System Errors"},{"location":"status.hpp/#battstatus","text":"","title":"batt::Status"},{"location":"status.hpp/#summary_1","text":"1 #include <batteries/status.hpp> Constructors Operators Methods Status() operator= ok group Status(enum_value) operator<< code IgnoreError Status(const Status&) operator== message Update Static Methods Types Constants code_group_for_type value_type kGroupSizeBits message_from_code CodeEntry kGroupSize register_codes CodeGroup kMaxGroups unknown_enum_value_message","title":"Summary"},{"location":"status.hpp/#constructors","text":"","title":"Constructors"},{"location":"status.hpp/#operators","text":"","title":"Operators"},{"location":"status.hpp/#methods","text":"","title":"Methods"},{"location":"status.hpp/#static-methods","text":"","title":"Static Methods"},{"location":"status.hpp/#types","text":"","title":"Types"},{"location":"status.hpp/#constants","text":"","title":"Constants"},{"location":"stream_util.hpp/","tags":["collections","diagnostics","string processing"],"text":"Enables insertion of lambda expressions into std::ostream , provides {{< doxfn \"batt::to_string\" >}} and {{< doxfn \"batt::from_string\" >}} functions, C-string literal escaping ({{< doxfn \"batt::c_str_literal\" >}}), and dumping range values with and without pretty printing ({{< doxfn \"batt::dump_range\" >}}). File Reference Inserting Lambdas into std::ostream \ud83d\udd17 Example: 1 2 3 4 5 std :: cout << \"Here is some output: \" << []( std :: ostream & out ) { for ( int i = 0 ; i < 10 ; ++ i ) { out << i << \", \" ; } }; Output: 1 Here is some output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,","title":"<batteries/stream_util.hpp>"},{"location":"stream_util.hpp/#inserting-lambdas-into-stdostream","text":"Example: 1 2 3 4 5 std :: cout << \"Here is some output: \" << []( std :: ostream & out ) { for ( int i = 0 ; i < 10 ; ++ i ) { out << i << \", \" ; } }; Output: 1 Here is some output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,","title":"Inserting Lambdas into std::ostream"},{"location":"strict.hpp/","tags":["compile-time","diagnostics"],"text":"Including this header enables strict-level compiler warnings and tells the compiler to treat all warnings as errors. File Reference","title":"<batteries/strict.hpp>"},{"location":"suppress.hpp/","tags":["compile-time","diagnostics","performance","portability"],"text":"Provides {{< doxdefine file=\"suppress.hpp\" name=\"BATT_SUPPRESS\" >}}(warn_id)/{{< doxdefine file=\"suppress.hpp\" name=\"BATT_UNSUPPRESS\" >}}() macros to suppress compiler warnings, {{< doxdefine file=\"suppress.hpp\" name=\"BATT_NO_OPTIMIZE\" >}} to suppress optimization of a specific function. File Reference","title":"<batteries/suppress.hpp>"},{"location":"_autogen/Classes/","text":"Classes \ud83d\udd17 namespace batt class AbstractHandler struct Deleter class AbstractStackAllocator class AbstractValue class AbstractValueImpl class AbstractValuePointer class BasicFakeExecutor struct BasicInterval struct LexicographicalOrder struct LinearOrder class BasicRateLimiter class BasicStateMachineEntropySource class BoxedSeq class AbstractSeq class SeqImpl class BufferSource class AbstractBufferSource class BufferSourceImpl class BufferViewImpl class CaseOfVisitor class Channel class ConstBufferView class CountMetric class CountMetricExporter class CpuCacheLineIsolated class CustomAllocHandler class DebugInfoFrame struct DecayRValueRefImpl class DefaultHttpClient class DerivedMetricExporter struct DoNothing struct EscapedStringLiteral class ExhaustiveModelChecker struct ExponentialBackoff class FakeExecutionContext struct AlwaysReturnZero class FakeTaskScheduler class ScopeGuard class FakeTimeService class State struct TimerInstance struct Impl class FilterBufferSource class FinalAct class Future class Grant class Issuer struct GreatestLowerBound class HandlerAllocator class HandlerBinder class HandlerImpl class HandlerMemory class HandlerMemoryBase struct HexByteDumper struct HostAddress class HttpChunkDecoder class HttpClient class HttpClientConnection struct ResponseInfo class HttpClientHostContext struct HttpData class HttpMessageBase class HttpRequest class HttpResponse class HttpServer struct HttpVersion struct IClosed struct IClosedOpen class IOResult struct InPlaceInitType struct IntervalTraits struct IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn > struct IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn > struct IntervalTraitsBase struct IsBoxedSeq struct IsBoxedSeq< BoxedSeq< T > > struct IsTuple struct IsTuple< std::tuple< Ts... > > struct IsVariant struct IsVariant< std::variant< Ts... > > class Latch class AsyncGetHandler class LatencyMetric class LatencyTimer struct LeastUpperBound class ManagedBuffer class MapBufferSource struct MapTuple struct MapTuple< PerTypeT, std::tuple< Ts... > > class MetricCsvFormatter class MetricDumper class MetricExporter class MetricFormatter struct MetricLabel class MetricRegistry struct MorphTuple struct MorphTuple< TemplateT, std::tuple< Ts... > > class MutableBufferView class Mutex class LockImpl struct ThreadSafeBaseIsNotSupportedByType struct NoneType struct NoopDeleter class NullTaskScheduler class Optional class Optional< T & > class Pin class Pinnable class PrependBufferSource class Promise class Queue class QueueBase class QueueDepthExporter class RadixQueue struct Hash struct Segment class RangeDumper class RateMetric class Ref struct RemoveStatusOrImpl struct RemoveStatusOrImpl< StatusOr< T > > struct RetryState class RunningTotal class Iterator class Runtime class DefaultScheduler class ScopedWorkContext class SeqBufferSource struct SeqItem_Impl struct SharedPtrImpl class SkipN struct SkipNBinder class SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. class StackAllocator class StackAllocatorImpl struct StateMachineBranch class StateMachineModel struct StateMachineModelCheckAdvancedOptions struct StateMachineResult struct StateMachineTraits struct StaticBinaryAssertion struct StaticSameTypeAssertion struct StaticType struct StaticValue class Status struct CodeEntry struct CodeGroup class StatusOr class StatusOr< Status > class StatusOr< StatusOr< T > > class StochasticModelChecker class StreamBuffer class StrongType struct Delta struct Hash class SubRangeSeq class TakeNSource class Task struct DebugTrace class SpinLockGuard class Trampoline class TaskScheduler struct TaskSleepImpl struct TupleIndexOf struct TupleIndexOf< std::tuple< First, Rest... >, T > struct TupleIndexOf< std::tuple< T, Rest... >, T > struct TupleIndexOf< std::tuple<>, T > class TypeErasedStorage class TypeErasedStorageBase class UniqueHandler struct UrlParse class VarSizeArray class VariableExporter class VecSeq struct VecSeqBase class Watch class Watch< bool > class Watch< i16 > class Watch< i32 > class Watch< i64 > class Watch< i8 > class Watch< u16 > class Watch< u32 > class Watch< u64 > class Watch< u8 > class Watch< void * > class WatchAtomic class WatchExporter class WorkContext struct WorkSliceParams struct WorkSlicePlan class Worker class WorkerPool namespace constants namespace detail class AbstractCopyFn class AbstractMoveFn class CopyFnImpl struct FirstMatchImpl struct FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > > struct FirstMatchImpl< std::tuple<>, std::tuple< Args... > > struct FirstPhase class FutureImpl class HttpClientRequestContext struct IsStatusOrImpl struct IsStatusOrImpl< StatusOr< T > > struct ModelCheckShardMetrics class MoveFnImpl class NotOkStatusWrapper struct NullableImpl struct NullableImpl< T * > struct NullableImpl< std::optional< T > > struct NullableImpl< std::shared_ptr< T > > struct NullableImpl< std::unique_ptr< T > > class ParallelModelCheckState struct SecondPhase class SigInfoHandler class StatusBase class StatusOrValueContainer class StatusOrValueContainer< T & > struct ThirdPhase struct VisitorResult struct VisitorResult< Visitor, std::variant< Ts... > & > struct VisitorResult< Visitor, std::variant< Ts... > && > struct VisitorResult< Visitor, std::variant< Ts... > > struct VisitorResult< Visitor, std::variant< Ts... > const & > struct VisitorResult< Visitor, std::variant< Ts... > const && > struct VisitorResult< Visitor, std::variant< Ts... > const > namespace int_types class kMoveOnly namespace seq struct Addition struct AllBinder struct AnyBinder struct ApplyBinder class Attach struct AttachBinder struct BoxedBinder class CacheNext struct CacheNextBinder class Chain struct ChainBinder struct Collect struct CollectVec struct Consume struct CountBinder struct DecayItem struct Deref class Empty class Filter struct FilterBinder class FilterMap struct FilterMapBinder struct FirstBinder class Flatten struct FlattenBinder struct ForEachBinder class Fuse struct FuseBinder class GroupBy class SubGroup struct GroupByBinder struct InnerReduceBinder class InspectAdjacent struct InspectAdjacentBinder struct IsNotFalse struct IsSortedBinder class KMergeBy struct HeapOrder struct KMergeByBinder struct LastBinder class Lazy class Map class MapAdjacent struct MapAdjacentBinder struct MapBinder class MapFold struct MapFoldBinder class MapPairwise struct MapPairwiseBinder class MergeBy struct ToItem struct MergeByBinder struct NaturalEquals struct NaturalOrder struct PrependBinder struct PrintOut class Printable struct PrintableBinder struct ProductBinder struct ReduceBinder struct Reverse struct RollingBinder struct RunningTotalBinder class SingleItem class Splice struct SpliceBinder class StatusOk struct StatusOkBinder struct SumBinder class TakeN struct TakeNBinder class TakeWhile struct TakeWhileBinder struct WriteToBinder namespace batt::@104 namespace batteries namespace pico_http struct ChunkedDecoder struct DecodeResult struct MessageHeader struct Request struct Response namespace detail namespace pico_http::detail::@107 namespace std Updated on 26 August 2022 at 17:30:03 UTC","title":"Classes"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/","text":"batt::AbstractHandler \ud83d\udd17 More... Inherits from boost::intrusive::list_base_hook<> Public Classes \ud83d\udd17 Name struct Deleter Public Functions \ud83d\udd17 Name AbstractHandler (const AbstractHandler & ) =deleted AbstractHandler & operator= (const AbstractHandler & ) =deleted virtual void notify (Args... args) =0 virtual void destroy () =0 virtual void dump (std::ostream & out) =0 Protected Functions \ud83d\udd17 Name AbstractHandler () =default virtual ~AbstractHandler () =default Detailed Description \ud83d\udd17 1 2 template < typename ... Args > class batt :: AbstractHandler ; Public Functions Documentation \ud83d\udd17 function AbstractHandler \ud83d\udd17 1 2 3 AbstractHandler ( const AbstractHandler & ) = deleted function operator= \ud83d\udd17 1 2 3 AbstractHandler & operator = ( const AbstractHandler & ) = deleted function notify \ud83d\udd17 1 2 3 virtual void notify ( Args ... args ) = 0 Reimplemented by : batt::HandlerImpl::notify function destroy \ud83d\udd17 1 virtual void destroy () = 0 Reimplemented by : batt::HandlerImpl::destroy function dump \ud83d\udd17 1 2 3 virtual void dump ( std :: ostream & out ) = 0 Reimplemented by : batt::HandlerImpl::dump Protected Functions Documentation \ud83d\udd17 function AbstractHandler \ud83d\udd17 1 AbstractHandler () = default function ~AbstractHandler \ud83d\udd17 1 virtual ~ AbstractHandler () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::AbstractHandler"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#public-classes","text":"Name struct Deleter","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#public-functions","text":"Name AbstractHandler (const AbstractHandler & ) =deleted AbstractHandler & operator= (const AbstractHandler & ) =deleted virtual void notify (Args... args) =0 virtual void destroy () =0 virtual void dump (std::ostream & out) =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#protected-functions","text":"Name AbstractHandler () =default virtual ~AbstractHandler () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#detailed-description","text":"1 2 template < typename ... Args > class batt :: AbstractHandler ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-abstracthandler","text":"1 2 3 AbstractHandler ( const AbstractHandler & ) = deleted","title":"function AbstractHandler"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-operator","text":"1 2 3 AbstractHandler & operator = ( const AbstractHandler & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-notify","text":"1 2 3 virtual void notify ( Args ... args ) = 0 Reimplemented by : batt::HandlerImpl::notify","title":"function notify"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-destroy","text":"1 virtual void destroy () = 0 Reimplemented by : batt::HandlerImpl::destroy","title":"function destroy"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-dump","text":"1 2 3 virtual void dump ( std :: ostream & out ) = 0 Reimplemented by : batt::HandlerImpl::dump","title":"function dump"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-abstracthandler_1","text":"1 AbstractHandler () = default","title":"function AbstractHandler"},{"location":"_autogen/Classes/classbatt_1_1AbstractHandler/#function-abstracthandler_2","text":"1 virtual ~ AbstractHandler () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function ~AbstractHandler"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/","text":"batt::AbstractStackAllocator \ud83d\udd17 Inherits from boost::intrusive_ref_counter< AbstractStackAllocator > Inherited by batt::StackAllocatorImpl< T > Public Functions \ud83d\udd17 Name AbstractStackAllocator (const AbstractStackAllocator & ) =deleted AbstractStackAllocator & operator= (const AbstractStackAllocator & ) =deleted virtual ~AbstractStackAllocator () =default virtual boost::context::stack_context allocate () =0 virtual void deallocate (boost::context::stack_context & ) =0 Protected Functions \ud83d\udd17 Name AbstractStackAllocator () =default Public Functions Documentation \ud83d\udd17 function AbstractStackAllocator \ud83d\udd17 1 2 3 AbstractStackAllocator ( const AbstractStackAllocator & ) = deleted function operator= \ud83d\udd17 1 2 3 AbstractStackAllocator & operator = ( const AbstractStackAllocator & ) = deleted function ~AbstractStackAllocator \ud83d\udd17 1 virtual ~ AbstractStackAllocator () = default function allocate \ud83d\udd17 1 virtual boost :: context :: stack_context allocate () = 0 Reimplemented by : batt::StackAllocatorImpl::allocate function deallocate \ud83d\udd17 1 2 3 virtual void deallocate ( boost :: context :: stack_context & ) = 0 Reimplemented by : batt::StackAllocatorImpl::deallocate Protected Functions Documentation \ud83d\udd17 function AbstractStackAllocator \ud83d\udd17 1 AbstractStackAllocator () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::AbstractStackAllocator"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#public-functions","text":"Name AbstractStackAllocator (const AbstractStackAllocator & ) =deleted AbstractStackAllocator & operator= (const AbstractStackAllocator & ) =deleted virtual ~AbstractStackAllocator () =default virtual boost::context::stack_context allocate () =0 virtual void deallocate (boost::context::stack_context & ) =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#protected-functions","text":"Name AbstractStackAllocator () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-abstractstackallocator","text":"1 2 3 AbstractStackAllocator ( const AbstractStackAllocator & ) = deleted","title":"function AbstractStackAllocator"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-operator","text":"1 2 3 AbstractStackAllocator & operator = ( const AbstractStackAllocator & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-abstractstackallocator_1","text":"1 virtual ~ AbstractStackAllocator () = default","title":"function ~AbstractStackAllocator"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-allocate","text":"1 virtual boost :: context :: stack_context allocate () = 0 Reimplemented by : batt::StackAllocatorImpl::allocate","title":"function allocate"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-deallocate","text":"1 2 3 virtual void deallocate ( boost :: context :: stack_context & ) = 0 Reimplemented by : batt::StackAllocatorImpl::deallocate","title":"function deallocate"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-abstractstackallocator_2","text":"1 AbstractStackAllocator () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function AbstractStackAllocator"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/","text":"batt::AbstractValue \ud83d\udd17 More... Inherited by batt::AbstractValuePointer< T > Public Functions \ud83d\udd17 Name AbstractValue (const AbstractValue & ) =deleted AbstractValue & operator= (const AbstractValue & ) =deleted virtual ~AbstractValue () =default virtual T * copy_to (MutableBuffer memory) =0 virtual T * move_to (MutableBuffer memory) =0 Protected Functions \ud83d\udd17 Name AbstractValue () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: AbstractValue ; Public Functions Documentation \ud83d\udd17 function AbstractValue \ud83d\udd17 1 2 3 AbstractValue ( const AbstractValue & ) = deleted function operator= \ud83d\udd17 1 2 3 AbstractValue & operator = ( const AbstractValue & ) = deleted function ~AbstractValue \ud83d\udd17 1 virtual ~ AbstractValue () = default function copy_to \ud83d\udd17 1 2 3 virtual T * copy_to ( MutableBuffer memory ) = 0 Reimplemented by : batt::AbstractValuePointer::copy_to function move_to \ud83d\udd17 1 2 3 virtual T * move_to ( MutableBuffer memory ) = 0 Reimplemented by : batt::AbstractValuePointer::move_to Protected Functions Documentation \ud83d\udd17 function AbstractValue \ud83d\udd17 1 AbstractValue () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::AbstractValue"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#public-functions","text":"Name AbstractValue (const AbstractValue & ) =deleted AbstractValue & operator= (const AbstractValue & ) =deleted virtual ~AbstractValue () =default virtual T * copy_to (MutableBuffer memory) =0 virtual T * move_to (MutableBuffer memory) =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#protected-functions","text":"Name AbstractValue () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#detailed-description","text":"1 2 template < typename T > class batt :: AbstractValue ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-abstractvalue","text":"1 2 3 AbstractValue ( const AbstractValue & ) = deleted","title":"function AbstractValue"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-operator","text":"1 2 3 AbstractValue & operator = ( const AbstractValue & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-abstractvalue_1","text":"1 virtual ~ AbstractValue () = default","title":"function ~AbstractValue"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-copy_to","text":"1 2 3 virtual T * copy_to ( MutableBuffer memory ) = 0 Reimplemented by : batt::AbstractValuePointer::copy_to","title":"function copy_to"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-move_to","text":"1 2 3 virtual T * move_to ( MutableBuffer memory ) = 0 Reimplemented by : batt::AbstractValuePointer::move_to","title":"function move_to"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-abstractvalue_2","text":"1 AbstractValue () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function AbstractValue"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/","text":"batt::AbstractValueImpl \ud83d\udd17 More... Inherits from AbstractType Public Functions \ud83d\udd17 Name AbstractValueImpl (T && obj) AbstractType * copy_to (MutableBuffer memory) override AbstractType * move_to (MutableBuffer memory) override Protected Attributes \ud83d\udd17 Name T obj_ Detailed Description \ud83d\udd17 1 2 3 4 template < typename AbstractType , template < typename > class TypedImpl , typename T > class batt :: AbstractValueImpl ; Public Functions Documentation \ud83d\udd17 function AbstractValueImpl \ud83d\udd17 1 2 3 inline explicit AbstractValueImpl ( T && obj ) function copy_to \ud83d\udd17 1 2 3 inline AbstractType * copy_to ( MutableBuffer memory ) override function move_to \ud83d\udd17 1 2 3 inline AbstractType * move_to ( MutableBuffer memory ) override Protected Attributes Documentation \ud83d\udd17 variable obj_ \ud83d\udd17 1 T obj_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::AbstractValueImpl"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#public-functions","text":"Name AbstractValueImpl (T && obj) AbstractType * copy_to (MutableBuffer memory) override AbstractType * move_to (MutableBuffer memory) override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#protected-attributes","text":"Name T obj_","title":"Protected Attributes"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#detailed-description","text":"1 2 3 4 template < typename AbstractType , template < typename > class TypedImpl , typename T > class batt :: AbstractValueImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#function-abstractvalueimpl","text":"1 2 3 inline explicit AbstractValueImpl ( T && obj )","title":"function AbstractValueImpl"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#function-copy_to","text":"1 2 3 inline AbstractType * copy_to ( MutableBuffer memory ) override","title":"function copy_to"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#function-move_to","text":"1 2 3 inline AbstractType * move_to ( MutableBuffer memory ) override","title":"function move_to"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#variable-obj_","text":"1 T obj_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable obj_"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/","text":"batt::AbstractValuePointer \ud83d\udd17 More... Inherits from batt::AbstractValue< T > Public Functions \ud83d\udd17 Name AbstractValuePointer (std::unique_ptr< T > ptr) virtual T * copy_to (MutableBuffer memory) override virtual T * move_to (MutableBuffer memory) override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::AbstractValue< T > Name AbstractValue (const AbstractValue & ) =deleted AbstractValue & operator= (const AbstractValue & ) =deleted virtual ~AbstractValue () =default Protected Functions inherited from batt::AbstractValue< T > Name AbstractValue () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: AbstractValuePointer ; Public Functions Documentation \ud83d\udd17 function AbstractValuePointer \ud83d\udd17 1 2 3 inline explicit AbstractValuePointer ( std :: unique_ptr < T > ptr ) function copy_to \ud83d\udd17 1 2 3 inline virtual T * copy_to ( MutableBuffer memory ) override Reimplements : batt::AbstractValue::copy_to function move_to \ud83d\udd17 1 2 3 inline virtual T * move_to ( MutableBuffer memory ) override Reimplements : batt::AbstractValue::move_to Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::AbstractValuePointer"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#public-functions","text":"Name AbstractValuePointer (std::unique_ptr< T > ptr) virtual T * copy_to (MutableBuffer memory) override virtual T * move_to (MutableBuffer memory) override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#additional-inherited-members","text":"Public Functions inherited from batt::AbstractValue< T > Name AbstractValue (const AbstractValue & ) =deleted AbstractValue & operator= (const AbstractValue & ) =deleted virtual ~AbstractValue () =default Protected Functions inherited from batt::AbstractValue< T > Name AbstractValue () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#detailed-description","text":"1 2 template < typename T > class batt :: AbstractValuePointer ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#function-abstractvaluepointer","text":"1 2 3 inline explicit AbstractValuePointer ( std :: unique_ptr < T > ptr )","title":"function AbstractValuePointer"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#function-copy_to","text":"1 2 3 inline virtual T * copy_to ( MutableBuffer memory ) override Reimplements : batt::AbstractValue::copy_to","title":"function copy_to"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#function-move_to","text":"1 2 3 inline virtual T * move_to ( MutableBuffer memory ) override Reimplements : batt::AbstractValue::move_to Updated on 26 August 2022 at 17:30:03 UTC","title":"function move_to"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/","text":"batt::BasicFakeExecutor \ud83d\udd17 More... Public Types \ud83d\udd17 Name using BasicFakeExecutor Self Public Functions \ud83d\udd17 Name constexpr BasicFakeExecutor () constexpr BasicFakeExecutor ( FakeExecutionContext * context) constexpr BasicFakeExecutor (const Self & other) constexpr BasicFakeExecutor ( Self && other) Self & operator= (const Self & other) Self & operator= ( Self && other) ~BasicFakeExecutor () void swap ( Self & other) FakeExecutionContext & context () const constexpr Self require (boost::asio::execution::blocking_t::possibly_t ) const constexpr Self require (boost::asio::execution::blocking_t::never_t ) const constexpr Self require (boost::asio::execution::relationship_t::fork_t ) const constexpr Self require (boost::asio::execution::relationship_t::continuation_t ) const constexpr auto require (boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto require (boost::asio::execution::outstanding_work_t::untracked_t ) const template <typename OtherAllocator > constexpr Self require (boost::asio::execution::allocator_t< OtherAllocator > ) const constexpr Self require (boost::asio::execution::allocator_t< void > ) const constexpr Self prefer (boost::asio::execution::blocking_t::possibly_t ) const constexpr Self prefer (boost::asio::execution::blocking_t::never_t ) const constexpr Self prefer (boost::asio::execution::relationship_t::fork_t ) const constexpr Self prefer (boost::asio::execution::relationship_t::continuation_t ) const constexpr auto prefer (boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto prefer (boost::asio::execution::outstanding_work_t::untracked_t ) const template <typename OtherAllocator > constexpr Self prefer (boost::asio::execution::allocator_t< OtherAllocator > ) const constexpr Self prefer (boost::asio::execution::allocator_t< void > ) const FakeExecutionContext & query (boost::asio::execution::context_t ) const boost::asio::execution_context & query (boost::asio::execution::context_as_t< boost::asio::execution_context & > ) const constexpr boost::asio::execution::blocking_t query (boost::asio::execution::blocking_t ) const constexpr boost::asio::execution::relationship_t query (boost::asio::execution::relationship_t ) const template <typename OtherAllocator > constexpr std::allocator< void > query (boost::asio::execution::allocator_t< OtherAllocator > ) const constexpr std::allocator< void > query (boost::asio::execution::allocator_t< void > ) const void on_work_started () const void on_work_finished () const template <typename Fn > void execute (Fn && fn) const template <typename Fn ,typename FnAllocator > void dispatch (Fn && fn, FnAllocator && ) const template <typename Fn ,typename FnAllocator > void post (Fn && fn, FnAllocator && ) const template <typename Fn ,typename FnAllocator > void defer (Fn && fn, FnAllocator && ) const constexpr boost::asio::execution::mapping_t query (boost::asio::execution::mapping_t ) constexpr boost::asio::execution::outstanding_work_t query (boost::asio::execution::outstanding_work_t ) Detailed Description \ud83d\udd17 1 2 template < typename OutstandingWorkP > class batt :: BasicFakeExecutor ; Public Types Documentation \ud83d\udd17 using Self \ud83d\udd17 1 using batt :: BasicFakeExecutor < OutstandingWorkP >:: Self = BasicFakeExecutor ; Public Functions Documentation \ud83d\udd17 function BasicFakeExecutor \ud83d\udd17 1 inline explicit constexpr BasicFakeExecutor () function BasicFakeExecutor \ud83d\udd17 1 2 3 inline explicit constexpr BasicFakeExecutor ( FakeExecutionContext * context ) function BasicFakeExecutor \ud83d\udd17 1 2 3 inline constexpr BasicFakeExecutor ( const Self & other ) function BasicFakeExecutor \ud83d\udd17 1 2 3 inline constexpr BasicFakeExecutor ( Self && other ) function operator= \ud83d\udd17 1 2 3 inline Self & operator = ( const Self & other ) function operator= \ud83d\udd17 1 2 3 inline Self & operator = ( Self && other ) function ~BasicFakeExecutor \ud83d\udd17 1 inline ~ BasicFakeExecutor () function swap \ud83d\udd17 1 2 3 inline void swap ( Self & other ) function context \ud83d\udd17 1 inline FakeExecutionContext & context () const function require \ud83d\udd17 1 2 3 inline constexpr Self require ( boost :: asio :: execution :: blocking_t :: possibly_t ) const function require \ud83d\udd17 1 2 3 inline constexpr Self require ( boost :: asio :: execution :: blocking_t :: never_t ) const function require \ud83d\udd17 1 2 3 inline constexpr Self require ( boost :: asio :: execution :: relationship_t :: fork_t ) const function require \ud83d\udd17 1 2 3 inline constexpr Self require ( boost :: asio :: execution :: relationship_t :: continuation_t ) const function require \ud83d\udd17 1 2 3 inline constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const function require \ud83d\udd17 1 2 3 inline constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const function require \ud83d\udd17 1 2 3 4 template < typename OtherAllocator > inline constexpr Self require ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const function require \ud83d\udd17 1 2 3 inline constexpr Self require ( boost :: asio :: execution :: allocator_t < void > ) const function prefer \ud83d\udd17 1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: possibly_t ) const function prefer \ud83d\udd17 1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: never_t ) const function prefer \ud83d\udd17 1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: fork_t ) const function prefer \ud83d\udd17 1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: continuation_t ) const function prefer \ud83d\udd17 1 2 3 inline constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const function prefer \ud83d\udd17 1 2 3 inline constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const function prefer \ud83d\udd17 1 2 3 4 template < typename OtherAllocator > inline constexpr Self prefer ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const function prefer \ud83d\udd17 1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: allocator_t < void > ) const function query \ud83d\udd17 1 2 3 inline FakeExecutionContext & query ( boost :: asio :: execution :: context_t ) const function query \ud83d\udd17 1 2 3 inline boost :: asio :: execution_context & query ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context & > ) const function query \ud83d\udd17 1 2 3 inline constexpr boost :: asio :: execution :: blocking_t query ( boost :: asio :: execution :: blocking_t ) const function query \ud83d\udd17 1 2 3 inline constexpr boost :: asio :: execution :: relationship_t query ( boost :: asio :: execution :: relationship_t ) const function query \ud83d\udd17 1 2 3 4 template < typename OtherAllocator > constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const function query \ud83d\udd17 1 2 3 inline constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < void > ) const function on_work_started \ud83d\udd17 1 inline void on_work_started () const function on_work_finished \ud83d\udd17 1 inline void on_work_finished () const function execute \ud83d\udd17 1 2 3 4 template < typename Fn > void execute ( Fn && fn ) const function dispatch \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename FnAllocator > inline void dispatch ( Fn && fn , FnAllocator && ) const function post \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename FnAllocator > inline void post ( Fn && fn , FnAllocator && ) const function defer \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename FnAllocator > inline void defer ( Fn && fn , FnAllocator && ) const function query \ud83d\udd17 1 2 3 static inline constexpr boost :: asio :: execution :: mapping_t query ( boost :: asio :: execution :: mapping_t ) function query \ud83d\udd17 1 2 3 static inline constexpr boost :: asio :: execution :: outstanding_work_t query ( boost :: asio :: execution :: outstanding_work_t ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-types","text":"Name using BasicFakeExecutor Self","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-functions","text":"Name constexpr BasicFakeExecutor () constexpr BasicFakeExecutor ( FakeExecutionContext * context) constexpr BasicFakeExecutor (const Self & other) constexpr BasicFakeExecutor ( Self && other) Self & operator= (const Self & other) Self & operator= ( Self && other) ~BasicFakeExecutor () void swap ( Self & other) FakeExecutionContext & context () const constexpr Self require (boost::asio::execution::blocking_t::possibly_t ) const constexpr Self require (boost::asio::execution::blocking_t::never_t ) const constexpr Self require (boost::asio::execution::relationship_t::fork_t ) const constexpr Self require (boost::asio::execution::relationship_t::continuation_t ) const constexpr auto require (boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto require (boost::asio::execution::outstanding_work_t::untracked_t ) const template <typename OtherAllocator > constexpr Self require (boost::asio::execution::allocator_t< OtherAllocator > ) const constexpr Self require (boost::asio::execution::allocator_t< void > ) const constexpr Self prefer (boost::asio::execution::blocking_t::possibly_t ) const constexpr Self prefer (boost::asio::execution::blocking_t::never_t ) const constexpr Self prefer (boost::asio::execution::relationship_t::fork_t ) const constexpr Self prefer (boost::asio::execution::relationship_t::continuation_t ) const constexpr auto prefer (boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto prefer (boost::asio::execution::outstanding_work_t::untracked_t ) const template <typename OtherAllocator > constexpr Self prefer (boost::asio::execution::allocator_t< OtherAllocator > ) const constexpr Self prefer (boost::asio::execution::allocator_t< void > ) const FakeExecutionContext & query (boost::asio::execution::context_t ) const boost::asio::execution_context & query (boost::asio::execution::context_as_t< boost::asio::execution_context & > ) const constexpr boost::asio::execution::blocking_t query (boost::asio::execution::blocking_t ) const constexpr boost::asio::execution::relationship_t query (boost::asio::execution::relationship_t ) const template <typename OtherAllocator > constexpr std::allocator< void > query (boost::asio::execution::allocator_t< OtherAllocator > ) const constexpr std::allocator< void > query (boost::asio::execution::allocator_t< void > ) const void on_work_started () const void on_work_finished () const template <typename Fn > void execute (Fn && fn) const template <typename Fn ,typename FnAllocator > void dispatch (Fn && fn, FnAllocator && ) const template <typename Fn ,typename FnAllocator > void post (Fn && fn, FnAllocator && ) const template <typename Fn ,typename FnAllocator > void defer (Fn && fn, FnAllocator && ) const constexpr boost::asio::execution::mapping_t query (boost::asio::execution::mapping_t ) constexpr boost::asio::execution::outstanding_work_t query (boost::asio::execution::outstanding_work_t )","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#detailed-description","text":"1 2 template < typename OutstandingWorkP > class batt :: BasicFakeExecutor ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#using-self","text":"1 using batt :: BasicFakeExecutor < OutstandingWorkP >:: Self = BasicFakeExecutor ;","title":"using Self"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor","text":"1 inline explicit constexpr BasicFakeExecutor ()","title":"function BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_1","text":"1 2 3 inline explicit constexpr BasicFakeExecutor ( FakeExecutionContext * context )","title":"function BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_2","text":"1 2 3 inline constexpr BasicFakeExecutor ( const Self & other )","title":"function BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_3","text":"1 2 3 inline constexpr BasicFakeExecutor ( Self && other )","title":"function BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-operator","text":"1 2 3 inline Self & operator = ( const Self & other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-operator_1","text":"1 2 3 inline Self & operator = ( Self && other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_4","text":"1 inline ~ BasicFakeExecutor ()","title":"function ~BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-swap","text":"1 2 3 inline void swap ( Self & other )","title":"function swap"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-context","text":"1 inline FakeExecutionContext & context () const","title":"function context"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require","text":"1 2 3 inline constexpr Self require ( boost :: asio :: execution :: blocking_t :: possibly_t ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_1","text":"1 2 3 inline constexpr Self require ( boost :: asio :: execution :: blocking_t :: never_t ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_2","text":"1 2 3 inline constexpr Self require ( boost :: asio :: execution :: relationship_t :: fork_t ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_3","text":"1 2 3 inline constexpr Self require ( boost :: asio :: execution :: relationship_t :: continuation_t ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_4","text":"1 2 3 inline constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_5","text":"1 2 3 inline constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_6","text":"1 2 3 4 template < typename OtherAllocator > inline constexpr Self require ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_7","text":"1 2 3 inline constexpr Self require ( boost :: asio :: execution :: allocator_t < void > ) const","title":"function require"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer","text":"1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: possibly_t ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_1","text":"1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: never_t ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_2","text":"1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: fork_t ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_3","text":"1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: continuation_t ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_4","text":"1 2 3 inline constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_5","text":"1 2 3 inline constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_6","text":"1 2 3 4 template < typename OtherAllocator > inline constexpr Self prefer ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_7","text":"1 2 3 inline constexpr Self prefer ( boost :: asio :: execution :: allocator_t < void > ) const","title":"function prefer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query","text":"1 2 3 inline FakeExecutionContext & query ( boost :: asio :: execution :: context_t ) const","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_1","text":"1 2 3 inline boost :: asio :: execution_context & query ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context & > ) const","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_2","text":"1 2 3 inline constexpr boost :: asio :: execution :: blocking_t query ( boost :: asio :: execution :: blocking_t ) const","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_3","text":"1 2 3 inline constexpr boost :: asio :: execution :: relationship_t query ( boost :: asio :: execution :: relationship_t ) const","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_4","text":"1 2 3 4 template < typename OtherAllocator > constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_5","text":"1 2 3 inline constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < void > ) const","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-on_work_started","text":"1 inline void on_work_started () const","title":"function on_work_started"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-on_work_finished","text":"1 inline void on_work_finished () const","title":"function on_work_finished"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-execute","text":"1 2 3 4 template < typename Fn > void execute ( Fn && fn ) const","title":"function execute"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-dispatch","text":"1 2 3 4 5 6 template < typename Fn , typename FnAllocator > inline void dispatch ( Fn && fn , FnAllocator && ) const","title":"function dispatch"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-post","text":"1 2 3 4 5 6 template < typename Fn , typename FnAllocator > inline void post ( Fn && fn , FnAllocator && ) const","title":"function post"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-defer","text":"1 2 3 4 5 6 template < typename Fn , typename FnAllocator > inline void defer ( Fn && fn , FnAllocator && ) const","title":"function defer"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_6","text":"1 2 3 static inline constexpr boost :: asio :: execution :: mapping_t query ( boost :: asio :: execution :: mapping_t )","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_7","text":"1 2 3 static inline constexpr boost :: asio :: execution :: outstanding_work_t query ( boost :: asio :: execution :: outstanding_work_t ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function query"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/","text":"batt::BasicRateLimiter \ud83d\udd17 More... Public Functions \ud83d\udd17 Name BasicRateLimiter (double rate, i64 burst =1) bool poll () i64 available () const double time_remaining_sec () const double elapsed_usec () const double elapsed_sec () const double period_sec () const Detailed Description \ud83d\udd17 1 2 template < typename Clock > class batt :: BasicRateLimiter ; Public Functions Documentation \ud83d\udd17 function BasicRateLimiter \ud83d\udd17 1 2 3 4 inline explicit BasicRateLimiter ( double rate , i64 burst = 1 ) function poll \ud83d\udd17 1 inline bool poll () function available \ud83d\udd17 1 inline i64 available () const function time_remaining_sec \ud83d\udd17 1 inline double time_remaining_sec () const function elapsed_usec \ud83d\udd17 1 inline double elapsed_usec () const function elapsed_sec \ud83d\udd17 1 inline double elapsed_sec () const function period_sec \ud83d\udd17 1 inline double period_sec () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BasicRateLimiter"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#public-functions","text":"Name BasicRateLimiter (double rate, i64 burst =1) bool poll () i64 available () const double time_remaining_sec () const double elapsed_usec () const double elapsed_sec () const double period_sec () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#detailed-description","text":"1 2 template < typename Clock > class batt :: BasicRateLimiter ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-basicratelimiter","text":"1 2 3 4 inline explicit BasicRateLimiter ( double rate , i64 burst = 1 )","title":"function BasicRateLimiter"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-poll","text":"1 inline bool poll ()","title":"function poll"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-available","text":"1 inline i64 available () const","title":"function available"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-time_remaining_sec","text":"1 inline double time_remaining_sec () const","title":"function time_remaining_sec"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-elapsed_usec","text":"1 inline double elapsed_usec () const","title":"function elapsed_usec"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-elapsed_sec","text":"1 inline double elapsed_sec () const","title":"function elapsed_sec"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-period_sec","text":"1 inline double period_sec () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function period_sec"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/","text":"batt::BasicStateMachineEntropySource \ud83d\udd17 More... Public Types \ud83d\udd17 Name using Fn PickIntFn Public Functions \ud83d\udd17 Name BasicStateMachineEntropySource () =default BasicStateMachineEntropySource (PickIntFn && pick_int_fn) usize pick_int (usize min_value, usize max_value) const bool pick_branch () const template <typename T > T pick_one_of (std::initializer_list< T > values) const bool run_one ( FakeExecutionContext & context) const template <typename... ActionFn> void do_one_of (ActionFn &&... actions) const Detailed Description \ud83d\udd17 1 2 template < typename Fn > class batt :: BasicStateMachineEntropySource ; Public Types Documentation \ud83d\udd17 using PickIntFn \ud83d\udd17 1 using batt :: BasicStateMachineEntropySource < Fn >:: PickIntFn = Fn ; Public Functions Documentation \ud83d\udd17 function BasicStateMachineEntropySource \ud83d\udd17 1 BasicStateMachineEntropySource () = default function BasicStateMachineEntropySource \ud83d\udd17 1 2 3 inline explicit BasicStateMachineEntropySource ( PickIntFn && pick_int_fn ) function pick_int \ud83d\udd17 1 2 3 4 inline usize pick_int ( usize min_value , usize max_value ) const function pick_branch \ud83d\udd17 1 inline bool pick_branch () const function pick_one_of \ud83d\udd17 1 2 3 4 template < typename T > inline T pick_one_of ( std :: initializer_list < T > values ) const function run_one \ud83d\udd17 1 2 3 inline bool run_one ( FakeExecutionContext & context ) const function do_one_of \ud83d\udd17 1 2 3 4 template < typename ... ActionFn > inline void do_one_of ( ActionFn && ... actions ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BasicStateMachineEntropySource"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-types","text":"Name using Fn PickIntFn","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-functions","text":"Name BasicStateMachineEntropySource () =default BasicStateMachineEntropySource (PickIntFn && pick_int_fn) usize pick_int (usize min_value, usize max_value) const bool pick_branch () const template <typename T > T pick_one_of (std::initializer_list< T > values) const bool run_one ( FakeExecutionContext & context) const template <typename... ActionFn> void do_one_of (ActionFn &&... actions) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#detailed-description","text":"1 2 template < typename Fn > class batt :: BasicStateMachineEntropySource ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#using-pickintfn","text":"1 using batt :: BasicStateMachineEntropySource < Fn >:: PickIntFn = Fn ;","title":"using PickIntFn"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-basicstatemachineentropysource","text":"1 BasicStateMachineEntropySource () = default","title":"function BasicStateMachineEntropySource"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-basicstatemachineentropysource_1","text":"1 2 3 inline explicit BasicStateMachineEntropySource ( PickIntFn && pick_int_fn )","title":"function BasicStateMachineEntropySource"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-pick_int","text":"1 2 3 4 inline usize pick_int ( usize min_value , usize max_value ) const","title":"function pick_int"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-pick_branch","text":"1 inline bool pick_branch () const","title":"function pick_branch"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-pick_one_of","text":"1 2 3 4 template < typename T > inline T pick_one_of ( std :: initializer_list < T > values ) const","title":"function pick_one_of"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-run_one","text":"1 2 3 inline bool run_one ( FakeExecutionContext & context ) const","title":"function run_one"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-do_one_of","text":"1 2 3 4 template < typename ... ActionFn > inline void do_one_of ( ActionFn && ... actions ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function do_one_of"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/","text":"batt::BoxedSeq \ud83d\udd17 More... Public Classes \ud83d\udd17 Name class AbstractSeq class SeqImpl Public Types \ud83d\udd17 Name using TypeErasedStorage < AbstractSeq , SeqImpl > storage_type using ItemT Item Public Functions \ud83d\udd17 Name BoxedSeq () =default template <typename T ,typename =EnableIfNoShadow ,typename =EnableIfSeq ,typename =std::enable_if_t<!std::is_same_v , Status> && !std::is_same_v , StatusCode>>> BoxedSeq (T && seq) template <typename U ,typename =std::enable_if_t<!std::is_same_v >> BoxedSeq (const BoxedSeq < U > & other_seq) =deleted template <typename U ,typename =std::enable_if_t<!std::is_same_v >> BoxedSeq ( BoxedSeq < U > && other_seq) =deleted BoxedSeq ( BoxedSeq && ) =default BoxedSeq (const BoxedSeq & that) =default BoxedSeq & operator= ( BoxedSeq && ) =default BoxedSeq & operator= (const BoxedSeq & that) =default Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename ItemT > class batt :: BoxedSeq ; Public Types Documentation \ud83d\udd17 using storage_type \ud83d\udd17 1 using batt :: BoxedSeq < ItemT >:: storage_type = TypeErasedStorage < AbstractSeq , SeqImpl > ; using Item \ud83d\udd17 1 using batt :: BoxedSeq < ItemT >:: Item = ItemT ; Public Functions Documentation \ud83d\udd17 function BoxedSeq \ud83d\udd17 1 BoxedSeq () = default function BoxedSeq \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename = EnableIfNoShadow < BoxedSeq , T &&> , typename = EnableIfSeq < T > , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < T > , Status > && ! std :: is_same_v < std :: decay_t < T > , StatusCode >>> inline explicit BoxedSeq ( T && seq ) function BoxedSeq \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( const BoxedSeq < U > & other_seq ) = deleted function BoxedSeq \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( BoxedSeq < U > && other_seq ) = deleted function BoxedSeq \ud83d\udd17 1 2 3 BoxedSeq ( BoxedSeq && ) = default function BoxedSeq \ud83d\udd17 1 2 3 BoxedSeq ( const BoxedSeq & that ) = default function operator= \ud83d\udd17 1 2 3 BoxedSeq & operator = ( BoxedSeq && ) = default function operator= \ud83d\udd17 1 2 3 BoxedSeq & operator = ( const BoxedSeq & that ) = default function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-classes","text":"Name class AbstractSeq class SeqImpl","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-types","text":"Name using TypeErasedStorage < AbstractSeq , SeqImpl > storage_type using ItemT Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-functions","text":"Name BoxedSeq () =default template <typename T ,typename =EnableIfNoShadow ,typename =EnableIfSeq ,typename =std::enable_if_t<!std::is_same_v , Status> && !std::is_same_v , StatusCode>>> BoxedSeq (T && seq) template <typename U ,typename =std::enable_if_t<!std::is_same_v >> BoxedSeq (const BoxedSeq < U > & other_seq) =deleted template <typename U ,typename =std::enable_if_t<!std::is_same_v >> BoxedSeq ( BoxedSeq < U > && other_seq) =deleted BoxedSeq ( BoxedSeq && ) =default BoxedSeq (const BoxedSeq & that) =default BoxedSeq & operator= ( BoxedSeq && ) =default BoxedSeq & operator= (const BoxedSeq & that) =default Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#detailed-description","text":"1 2 template < typename ItemT > class batt :: BoxedSeq ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#using-storage_type","text":"1 using batt :: BoxedSeq < ItemT >:: storage_type = TypeErasedStorage < AbstractSeq , SeqImpl > ;","title":"using storage_type"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#using-item","text":"1 using batt :: BoxedSeq < ItemT >:: Item = ItemT ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq","text":"1 BoxedSeq () = default","title":"function BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_1","text":"1 2 3 4 5 6 7 template < typename T , typename = EnableIfNoShadow < BoxedSeq , T &&> , typename = EnableIfSeq < T > , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < T > , Status > && ! std :: is_same_v < std :: decay_t < T > , StatusCode >>> inline explicit BoxedSeq ( T && seq )","title":"function BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_2","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( const BoxedSeq < U > & other_seq ) = deleted","title":"function BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_3","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( BoxedSeq < U > && other_seq ) = deleted","title":"function BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_4","text":"1 2 3 BoxedSeq ( BoxedSeq && ) = default","title":"function BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_5","text":"1 2 3 BoxedSeq ( const BoxedSeq & that ) = default","title":"function BoxedSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-operator","text":"1 2 3 BoxedSeq & operator = ( BoxedSeq && ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-operator_1","text":"1 2 3 BoxedSeq & operator = ( const BoxedSeq & that ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/","text":"batt::BoxedSeq::AbstractSeq \ud83d\udd17 Inherits from batt::AbstractValue< AbstractSeq > Public Functions \ud83d\udd17 Name AbstractSeq () =default AbstractSeq (const AbstractSeq & ) =deleted AbstractSeq & operator= (const AbstractSeq & ) =deleted virtual ~AbstractSeq () =default virtual Optional < ItemT > peek () =0 virtual Optional < ItemT > next () =0 Additional inherited members \ud83d\udd17 Public Functions inherited from batt::AbstractValue< AbstractSeq > Name AbstractValue (const AbstractValue & ) =deleted virtual ~AbstractValue () =default virtual T * copy_to (MutableBuffer memory) =0 virtual T * move_to (MutableBuffer memory) =0 Protected Functions inherited from batt::AbstractValue< AbstractSeq > Name AbstractValue () =default Public Functions Documentation \ud83d\udd17 function AbstractSeq \ud83d\udd17 1 AbstractSeq () = default function AbstractSeq \ud83d\udd17 1 2 3 AbstractSeq ( const AbstractSeq & ) = deleted function operator= \ud83d\udd17 1 2 3 AbstractSeq & operator = ( const AbstractSeq & ) = deleted function ~AbstractSeq \ud83d\udd17 1 virtual ~ AbstractSeq () = default function peek \ud83d\udd17 1 virtual Optional < ItemT > peek () = 0 function next \ud83d\udd17 1 virtual Optional < ItemT > next () = 0 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BoxedSeq::AbstractSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#public-functions","text":"Name AbstractSeq () =default AbstractSeq (const AbstractSeq & ) =deleted AbstractSeq & operator= (const AbstractSeq & ) =deleted virtual ~AbstractSeq () =default virtual Optional < ItemT > peek () =0 virtual Optional < ItemT > next () =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#additional-inherited-members","text":"Public Functions inherited from batt::AbstractValue< AbstractSeq > Name AbstractValue (const AbstractValue & ) =deleted virtual ~AbstractValue () =default virtual T * copy_to (MutableBuffer memory) =0 virtual T * move_to (MutableBuffer memory) =0 Protected Functions inherited from batt::AbstractValue< AbstractSeq > Name AbstractValue () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-abstractseq","text":"1 AbstractSeq () = default","title":"function AbstractSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-abstractseq_1","text":"1 2 3 AbstractSeq ( const AbstractSeq & ) = deleted","title":"function AbstractSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-operator","text":"1 2 3 AbstractSeq & operator = ( const AbstractSeq & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-abstractseq_2","text":"1 virtual ~ AbstractSeq () = default","title":"function ~AbstractSeq"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-peek","text":"1 virtual Optional < ItemT > peek () = 0","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-next","text":"1 virtual Optional < ItemT > next () = 0 Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/","text":"batt::BoxedSeq::SeqImpl \ud83d\udd17 More... Public Types \ud83d\udd17 Name using AbstractValueImpl < AbstractSeq , SeqImpl , T > Super Public Functions \ud83d\udd17 Name SeqImpl (T && seq) Optional < ItemT > peek () override Optional < ItemT > next () override Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: BoxedSeq :: SeqImpl ; Public Types Documentation \ud83d\udd17 using Super \ud83d\udd17 1 using batt :: BoxedSeq < ItemT >:: SeqImpl < T >:: Super = AbstractValueImpl < AbstractSeq , SeqImpl , T > ; Public Functions Documentation \ud83d\udd17 function SeqImpl \ud83d\udd17 1 2 3 inline explicit SeqImpl ( T && seq ) function peek \ud83d\udd17 1 inline Optional < ItemT > peek () override function next \ud83d\udd17 1 inline Optional < ItemT > next () override Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BoxedSeq::SeqImpl"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-types","text":"Name using AbstractValueImpl < AbstractSeq , SeqImpl , T > Super","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-functions","text":"Name SeqImpl (T && seq) Optional < ItemT > peek () override Optional < ItemT > next () override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#detailed-description","text":"1 2 template < typename T > class batt :: BoxedSeq :: SeqImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#using-super","text":"1 using batt :: BoxedSeq < ItemT >:: SeqImpl < T >:: Super = AbstractValueImpl < AbstractSeq , SeqImpl , T > ;","title":"using Super"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#function-seqimpl","text":"1 2 3 inline explicit SeqImpl ( T && seq )","title":"function SeqImpl"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#function-peek","text":"1 inline Optional < ItemT > peek () override","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#function-next","text":"1 inline Optional < ItemT > next () override Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/","text":"batt::BufferSource \ud83d\udd17 Public Classes \ud83d\udd17 Name class AbstractBufferSource Public Functions \ud83d\udd17 Name BufferSource () =default template <typename T ,typename =EnableIfNoShadow ,typename =EnableIfBufferSource >,typename =std::enable_if_t , T>>> BufferSource (T && obj) operator bool () const void clear () usize size () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) void close_for_read () Public Functions Documentation \ud83d\udd17 function BufferSource \ud83d\udd17 1 BufferSource () = default function BufferSource \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename = EnableIfNoShadow < BufferSource , T &&> , typename = EnableIfBufferSource < UnwrapRefType < T >> , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , T >>> inline BufferSource ( T && obj ) function operator bool \ud83d\udd17 1 inline explicit operator bool () const function clear \ud83d\udd17 1 void clear () function size \ud83d\udd17 1 inline usize size () const function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) function close_for_read \ud83d\udd17 1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BufferSource"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#public-classes","text":"Name class AbstractBufferSource","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#public-functions","text":"Name BufferSource () =default template <typename T ,typename =EnableIfNoShadow ,typename =EnableIfBufferSource >,typename =std::enable_if_t , T>>> BufferSource (T && obj) operator bool () const void clear () usize size () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) void close_for_read ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource","text":"1 BufferSource () = default","title":"function BufferSource"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource_1","text":"1 2 3 4 5 6 7 template < typename T , typename = EnableIfNoShadow < BufferSource , T &&> , typename = EnableIfBufferSource < UnwrapRefType < T >> , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , T >>> inline BufferSource ( T && obj )","title":"function BufferSource"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-clear","text":"1 void clear ()","title":"function clear"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count )","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-consume","text":"1 2 3 inline void consume ( i64 count )","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-close_for_read","text":"1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/","text":"batt::BufferSource::AbstractBufferSource \ud83d\udd17 Inherits from batt::AbstractValue< AbstractBufferSource > Public Functions \ud83d\udd17 Name virtual usize size () const =0 virtual StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) =0 virtual void consume (i64 count) =0 virtual void close_for_read () =0 Additional inherited members \ud83d\udd17 Public Functions inherited from batt::AbstractValue< AbstractBufferSource > Name AbstractValue (const AbstractValue & ) =deleted AbstractValue & operator= (const AbstractValue & ) =deleted virtual ~AbstractValue () =default virtual T * copy_to (MutableBuffer memory) =0 virtual T * move_to (MutableBuffer memory) =0 Protected Functions inherited from batt::AbstractValue< AbstractBufferSource > Name AbstractValue () =default Public Functions Documentation \ud83d\udd17 function size \ud83d\udd17 1 virtual usize size () const = 0 function fetch_at_least \ud83d\udd17 1 2 3 virtual StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) = 0 function consume \ud83d\udd17 1 2 3 virtual void consume ( i64 count ) = 0 function close_for_read \ud83d\udd17 1 virtual void close_for_read () = 0 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BufferSource::AbstractBufferSource"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#public-functions","text":"Name virtual usize size () const =0 virtual StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) =0 virtual void consume (i64 count) =0 virtual void close_for_read () =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#additional-inherited-members","text":"Public Functions inherited from batt::AbstractValue< AbstractBufferSource > Name AbstractValue (const AbstractValue & ) =deleted AbstractValue & operator= (const AbstractValue & ) =deleted virtual ~AbstractValue () =default virtual T * copy_to (MutableBuffer memory) =0 virtual T * move_to (MutableBuffer memory) =0 Protected Functions inherited from batt::AbstractValue< AbstractBufferSource > Name AbstractValue () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#function-size","text":"1 virtual usize size () const = 0","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#function-fetch_at_least","text":"1 2 3 virtual StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) = 0","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#function-consume","text":"1 2 3 virtual void consume ( i64 count ) = 0","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1AbstractBufferSource/#function-close_for_read","text":"1 virtual void close_for_read () = 0 Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/","text":"batt::BufferSource::BufferSourceImpl \ud83d\udd17 More... Public Functions \ud83d\udd17 Name usize size () const override StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) override void consume (i64 count) override void close_for_read () override Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: BufferSource :: BufferSourceImpl ; Public Functions Documentation \ud83d\udd17 function size \ud83d\udd17 1 inline usize size () const override function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) override function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) override function close_for_read \ud83d\udd17 1 inline void close_for_read () override Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BufferSource::BufferSourceImpl"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#public-functions","text":"Name usize size () const override StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) override void consume (i64 count) override void close_for_read () override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#detailed-description","text":"1 2 template < typename T > class batt :: BufferSource :: BufferSourceImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#function-size","text":"1 inline usize size () const override","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) override","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#function-consume","text":"1 2 3 inline void consume ( i64 count ) override","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#function-close_for_read","text":"1 inline void close_for_read () override Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/","text":"batt::BufferViewImpl \ud83d\udd17 Public Types \ud83d\udd17 Name using BufferViewImpl Self Public Functions \ud83d\udd17 Name BufferViewImpl (SharedPtr< ManagedBuffer > && buffer, usize offset =0) BufferViewImpl (SharedPtr< ManagedBuffer > && buffer, usize offset, usize length) void * data () const usize size () const Self & operator+= (usize delta) bool append ( Self && next) Public Types Documentation \ud83d\udd17 using Self \ud83d\udd17 1 using batt :: BufferViewImpl :: Self = BufferViewImpl ; Public Functions Documentation \ud83d\udd17 function BufferViewImpl \ud83d\udd17 1 2 3 4 inline explicit BufferViewImpl ( SharedPtr < ManagedBuffer > && buffer , usize offset = 0 ) function BufferViewImpl \ud83d\udd17 1 2 3 4 5 inline explicit BufferViewImpl ( SharedPtr < ManagedBuffer > && buffer , usize offset , usize length ) function data \ud83d\udd17 1 inline void * data () const function size \ud83d\udd17 1 inline usize size () const function operator+= \ud83d\udd17 1 2 3 inline Self & operator += ( usize delta ) function append \ud83d\udd17 1 2 3 inline bool append ( Self && next ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BufferViewImpl"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-types","text":"Name using BufferViewImpl Self","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-functions","text":"Name BufferViewImpl (SharedPtr< ManagedBuffer > && buffer, usize offset =0) BufferViewImpl (SharedPtr< ManagedBuffer > && buffer, usize offset, usize length) void * data () const usize size () const Self & operator+= (usize delta) bool append ( Self && next)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#using-self","text":"1 using batt :: BufferViewImpl :: Self = BufferViewImpl ;","title":"using Self"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-bufferviewimpl","text":"1 2 3 4 inline explicit BufferViewImpl ( SharedPtr < ManagedBuffer > && buffer , usize offset = 0 )","title":"function BufferViewImpl"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-bufferviewimpl_1","text":"1 2 3 4 5 inline explicit BufferViewImpl ( SharedPtr < ManagedBuffer > && buffer , usize offset , usize length )","title":"function BufferViewImpl"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-data","text":"1 inline void * data () const","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-operator","text":"1 2 3 inline Self & operator += ( usize delta )","title":"function operator+="},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-append","text":"1 2 3 inline bool append ( Self && next ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function append"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/","text":"batt::CaseOfVisitor \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::tuple< Cases... > CaseTuple template <typename... Args> using detail::FirstMatchImpl < CaseTuple, std::tuple< Args... > > FirstMatch Public Functions \ud83d\udd17 Name template <typename... CaseArgs> CaseOfVisitor (CaseArgs &&... case_args) template <typename... Args> decltype(auto) operator() (Args &&... args) template <typename... Args> decltype(auto) operator() (Args &&... args) template <typename... Args> decltype(auto) operator() (Args &&... args) const template <typename... Args> decltype(auto) operator() (Args &&... args) const Detailed Description \ud83d\udd17 1 2 template < typename ... Cases > class batt :: CaseOfVisitor ; Public Types Documentation \ud83d\udd17 using CaseTuple \ud83d\udd17 1 using batt :: CaseOfVisitor < Cases >:: CaseTuple = std :: tuple < Cases ... > ; using FirstMatch \ud83d\udd17 1 2 template < typename ... Args > using batt :: CaseOfVisitor < Cases >:: FirstMatch = detail :: FirstMatchImpl < CaseTuple , std :: tuple < Args ... > > ; Public Functions Documentation \ud83d\udd17 function CaseOfVisitor \ud83d\udd17 1 2 3 4 template < typename ... CaseArgs > inline explicit CaseOfVisitor ( CaseArgs && ... case_args ) function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args ) function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args ) function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args ) const function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::CaseOfVisitor"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-types","text":"Name using std::tuple< Cases... > CaseTuple template <typename... Args> using detail::FirstMatchImpl < CaseTuple, std::tuple< Args... > > FirstMatch","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-functions","text":"Name template <typename... CaseArgs> CaseOfVisitor (CaseArgs &&... case_args) template <typename... Args> decltype(auto) operator() (Args &&... args) template <typename... Args> decltype(auto) operator() (Args &&... args) template <typename... Args> decltype(auto) operator() (Args &&... args) const template <typename... Args> decltype(auto) operator() (Args &&... args) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#detailed-description","text":"1 2 template < typename ... Cases > class batt :: CaseOfVisitor ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#using-casetuple","text":"1 using batt :: CaseOfVisitor < Cases >:: CaseTuple = std :: tuple < Cases ... > ;","title":"using CaseTuple"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#using-firstmatch","text":"1 2 template < typename ... Args > using batt :: CaseOfVisitor < Cases >:: FirstMatch = detail :: FirstMatchImpl < CaseTuple , std :: tuple < Args ... > > ;","title":"using FirstMatch"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-caseofvisitor","text":"1 2 3 4 template < typename ... CaseArgs > inline explicit CaseOfVisitor ( CaseArgs && ... case_args )","title":"function CaseOfVisitor"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args )","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator_1","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args )","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator_2","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args ) const","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator_3","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) operator ()( Args && ... args ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1Channel/","text":"batt::Channel \ud83d\udd17 More... Public Functions \ud83d\udd17 Name Channel () Channel (const Channel & ) =deleted Channel & operator= (const Channel & ) =deleted ~Channel () bool is_active () const StatusOr < T & > read () void consume () void close_for_read () template <typename Handler =void(Status)> void async_write (T & value, Handler && handler) Status write (T & value) void close_for_write () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Channel ; Public Functions Documentation \ud83d\udd17 function Channel \ud83d\udd17 1 inline Channel () function Channel \ud83d\udd17 1 2 3 Channel ( const Channel & ) = deleted function operator= \ud83d\udd17 1 2 3 Channel & operator = ( const Channel & ) = deleted function ~Channel \ud83d\udd17 1 inline ~ Channel () function is_active \ud83d\udd17 1 inline bool is_active () const function read \ud83d\udd17 1 inline StatusOr < T & > read () function consume \ud83d\udd17 1 inline void consume () function close_for_read \ud83d\udd17 1 inline void close_for_read () function async_write \ud83d\udd17 1 2 3 4 5 template < typename Handler = void ( Status ) > void async_write ( T & value , Handler && handler ) function write \ud83d\udd17 1 2 3 inline Status write ( T & value ) function close_for_write \ud83d\udd17 1 inline void close_for_write () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Channel"},{"location":"_autogen/Classes/classbatt_1_1Channel/#public-functions","text":"Name Channel () Channel (const Channel & ) =deleted Channel & operator= (const Channel & ) =deleted ~Channel () bool is_active () const StatusOr < T & > read () void consume () void close_for_read () template <typename Handler =void(Status)> void async_write (T & value, Handler && handler) Status write (T & value) void close_for_write ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Channel/#detailed-description","text":"1 2 template < typename T > class batt :: Channel ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-channel","text":"1 inline Channel ()","title":"function Channel"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-channel_1","text":"1 2 3 Channel ( const Channel & ) = deleted","title":"function Channel"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-operator","text":"1 2 3 Channel & operator = ( const Channel & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-channel_2","text":"1 inline ~ Channel ()","title":"function ~Channel"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-is_active","text":"1 inline bool is_active () const","title":"function is_active"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-read","text":"1 inline StatusOr < T & > read ()","title":"function read"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-consume","text":"1 inline void consume ()","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-close_for_read","text":"1 inline void close_for_read ()","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-async_write","text":"1 2 3 4 5 template < typename Handler = void ( Status ) > void async_write ( T & value , Handler && handler )","title":"function async_write"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-write","text":"1 2 3 inline Status write ( T & value )","title":"function write"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-close_for_write","text":"1 inline void close_for_write () Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_write"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/","text":"batt::ConstBufferView \ud83d\udd17 Public Functions \ud83d\udd17 Name ConstBufferView (const ConstBufferView & ) =default ConstBufferView & operator= (const ConstBufferView & ) =default ConstBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset =0) ConstBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset, usize length) ConstBufferView (const MutableBufferView & other) ConstBufferView ( MutableBufferView && other) ConstBufferView & operator= (const MutableBufferView & other) ConstBufferView & operator= ( MutableBufferView && other) operator ConstBuffer () const ConstBufferView & operator+= (usize delta) const void * data () const usize size () const bool append ( ConstBufferView && next) bool append ( MutableBufferView && next) Friends \ud83d\udd17 Name class MutableBufferView Public Functions Documentation \ud83d\udd17 function ConstBufferView \ud83d\udd17 1 2 3 ConstBufferView ( const ConstBufferView & ) = default function operator= \ud83d\udd17 1 2 3 ConstBufferView & operator = ( const ConstBufferView & ) = default function ConstBufferView \ud83d\udd17 1 2 3 4 inline explicit ConstBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset = 0 ) function ConstBufferView \ud83d\udd17 1 2 3 4 5 inline explicit ConstBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset , usize length ) function ConstBufferView \ud83d\udd17 1 2 3 inline ConstBufferView ( const MutableBufferView & other ) function ConstBufferView \ud83d\udd17 1 2 3 inline ConstBufferView ( MutableBufferView && other ) function operator= \ud83d\udd17 1 2 3 inline ConstBufferView & operator = ( const MutableBufferView & other ) function operator= \ud83d\udd17 1 2 3 inline ConstBufferView & operator = ( MutableBufferView && other ) function operator ConstBuffer \ud83d\udd17 1 inline operator ConstBuffer () const function operator+= \ud83d\udd17 1 2 3 inline ConstBufferView & operator += ( usize delta ) function data \ud83d\udd17 1 inline const void * data () const function size \ud83d\udd17 1 inline usize size () const function append \ud83d\udd17 1 2 3 inline bool append ( ConstBufferView && next ) function append \ud83d\udd17 1 2 3 inline bool append ( MutableBufferView && next ) Friends \ud83d\udd17 friend MutableBufferView \ud83d\udd17 1 friend class MutableBufferView ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#public-functions","text":"Name ConstBufferView (const ConstBufferView & ) =default ConstBufferView & operator= (const ConstBufferView & ) =default ConstBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset =0) ConstBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset, usize length) ConstBufferView (const MutableBufferView & other) ConstBufferView ( MutableBufferView && other) ConstBufferView & operator= (const MutableBufferView & other) ConstBufferView & operator= ( MutableBufferView && other) operator ConstBuffer () const ConstBufferView & operator+= (usize delta) const void * data () const usize size () const bool append ( ConstBufferView && next) bool append ( MutableBufferView && next)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#friends","text":"Name class MutableBufferView","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview","text":"1 2 3 ConstBufferView ( const ConstBufferView & ) = default","title":"function ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator","text":"1 2 3 ConstBufferView & operator = ( const ConstBufferView & ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_1","text":"1 2 3 4 inline explicit ConstBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset = 0 )","title":"function ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_2","text":"1 2 3 4 5 inline explicit ConstBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset , usize length )","title":"function ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_3","text":"1 2 3 inline ConstBufferView ( const MutableBufferView & other )","title":"function ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_4","text":"1 2 3 inline ConstBufferView ( MutableBufferView && other )","title":"function ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator_1","text":"1 2 3 inline ConstBufferView & operator = ( const MutableBufferView & other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator_2","text":"1 2 3 inline ConstBufferView & operator = ( MutableBufferView && other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator-constbuffer","text":"1 inline operator ConstBuffer () const","title":"function operator ConstBuffer"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator_3","text":"1 2 3 inline ConstBufferView & operator += ( usize delta )","title":"function operator+="},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-data","text":"1 inline const void * data () const","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-append","text":"1 2 3 inline bool append ( ConstBufferView && next )","title":"function append"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-append_1","text":"1 2 3 inline bool append ( MutableBufferView && next )","title":"function append"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#friend-mutablebufferview","text":"1 friend class MutableBufferView ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend MutableBufferView"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/","text":"batt::CountMetric \ud83d\udd17 More... Public Functions \ud83d\udd17 Name CountMetric () =default CountMetric (T init_val) void set (T value) template <typename D > void add (D delta) template <typename D > decltype(auto) fetch_add (D delta) operator T () const decltype(auto) operator++ (int ) decltype(auto) operator++ () template <typename D > decltype(auto) operator+= (D delta) T load () const void reset () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: CountMetric ; Public Functions Documentation \ud83d\udd17 function CountMetric \ud83d\udd17 1 CountMetric () = default function CountMetric \ud83d\udd17 1 2 3 inline CountMetric ( T init_val ) function set \ud83d\udd17 1 2 3 inline void set ( T value ) function add \ud83d\udd17 1 2 3 4 template < typename D > inline void add ( D delta ) function fetch_add \ud83d\udd17 1 2 3 4 template < typename D > inline decltype ( auto ) fetch_add ( D delta ) function operator T \ud83d\udd17 1 inline operator T () const function operator++ \ud83d\udd17 1 2 3 inline decltype ( auto ) operator ++ ( int ) function operator++ \ud83d\udd17 1 inline decltype ( auto ) operator ++ () function operator+= \ud83d\udd17 1 2 3 4 template < typename D > inline decltype ( auto ) operator += ( D delta ) function load \ud83d\udd17 1 inline T load () const function reset \ud83d\udd17 1 inline void reset () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::CountMetric"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#public-functions","text":"Name CountMetric () =default CountMetric (T init_val) void set (T value) template <typename D > void add (D delta) template <typename D > decltype(auto) fetch_add (D delta) operator T () const decltype(auto) operator++ (int ) decltype(auto) operator++ () template <typename D > decltype(auto) operator+= (D delta) T load () const void reset ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#detailed-description","text":"1 2 template < typename T > class batt :: CountMetric ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-countmetric","text":"1 CountMetric () = default","title":"function CountMetric"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-countmetric_1","text":"1 2 3 inline CountMetric ( T init_val )","title":"function CountMetric"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-set","text":"1 2 3 inline void set ( T value )","title":"function set"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-add","text":"1 2 3 4 template < typename D > inline void add ( D delta )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-fetch_add","text":"1 2 3 4 template < typename D > inline decltype ( auto ) fetch_add ( D delta )","title":"function fetch_add"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator-t","text":"1 inline operator T () const","title":"function operator T"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator","text":"1 2 3 inline decltype ( auto ) operator ++ ( int )","title":"function operator++"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator_1","text":"1 inline decltype ( auto ) operator ++ ()","title":"function operator++"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator_2","text":"1 2 3 4 template < typename D > inline decltype ( auto ) operator += ( D delta )","title":"function operator+="},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-load","text":"1 inline T load () const","title":"function load"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-reset","text":"1 inline void reset () Updated on 26 August 2022 at 17:30:03 UTC","title":"function reset"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/","text":"batt::CountMetricExporter \ud83d\udd17 More... Inherits from batt::MetricExporter Public Functions \ud83d\udd17 Name CountMetricExporter (const std::string & name, CountMetric < T > & counter) virtual Token get_name () const override virtual double get_value () const override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: CountMetricExporter ; Public Functions Documentation \ud83d\udd17 function CountMetricExporter \ud83d\udd17 1 2 3 4 inline explicit CountMetricExporter ( const std :: string & name , CountMetric < T > & counter ) function get_name \ud83d\udd17 1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name function get_value \ud83d\udd17 1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::CountMetricExporter"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#public-functions","text":"Name CountMetricExporter (const std::string & name, CountMetric < T > & counter) virtual Token get_name () const override virtual double get_value () const override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#additional-inherited-members","text":"Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#detailed-description","text":"1 2 template < typename T > class batt :: CountMetricExporter ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#function-countmetricexporter","text":"1 2 3 4 inline explicit CountMetricExporter ( const std :: string & name , CountMetric < T > & counter )","title":"function CountMetricExporter"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#function-get_name","text":"1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name","title":"function get_name"},{"location":"_autogen/Classes/classbatt_1_1CountMetricExporter/#function-get_value","text":"1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/","text":"batt::CpuCacheLineIsolated \ud83d\udd17 More... Public Types \ud83d\udd17 Name using T value_type Public Functions \ud83d\udd17 Name CpuCacheLineIsolated * pointer_from (T * inner_obj) const CpuCacheLineIsolated * pointer_from (const T * inner_obj) CpuCacheLineIsolated () template <typename... Args,typename =EnableIfNoShadow > CpuCacheLineIsolated (Args &&... args) CpuCacheLineIsolated (const CpuCacheLineIsolated & that) CpuCacheLineIsolated ( CpuCacheLineIsolated && that) CpuCacheLineIsolated & operator= (const CpuCacheLineIsolated & that) template <typename V ,typename =std::enable_if_t<!std::is_same_v , CpuCacheLineIsolated>>> CpuCacheLineIsolated & operator= (V && val) CpuCacheLineIsolated & operator= ( CpuCacheLineIsolated && that) ~CpuCacheLineIsolated () T * get () const T * get () const T & value () const T & value () const T && value () const T && value () const =deleted T * operator-> () const T * operator-> () const T & operator* () const T & operator* () const T && operator* () Public Attributes \ud83d\udd17 Name constexpr usize kIsolatedSize Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: CpuCacheLineIsolated ; Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: CpuCacheLineIsolated < T >:: value_type = T ; Public Functions Documentation \ud83d\udd17 function pointer_from \ud83d\udd17 1 2 3 static inline CpuCacheLineIsolated * pointer_from ( T * inner_obj ) function pointer_from \ud83d\udd17 1 2 3 static inline const CpuCacheLineIsolated * pointer_from ( const T * inner_obj ) function CpuCacheLineIsolated \ud83d\udd17 1 inline CpuCacheLineIsolated () function CpuCacheLineIsolated \ud83d\udd17 1 2 3 4 5 template < typename ... Args , typename = EnableIfNoShadow < CpuCacheLineIsolated , Args ... >> inline explicit CpuCacheLineIsolated ( Args && ... args ) function CpuCacheLineIsolated \ud83d\udd17 1 2 3 inline CpuCacheLineIsolated ( const CpuCacheLineIsolated & that ) function CpuCacheLineIsolated \ud83d\udd17 1 2 3 inline CpuCacheLineIsolated ( CpuCacheLineIsolated && that ) function operator= \ud83d\udd17 1 2 3 inline CpuCacheLineIsolated & operator = ( const CpuCacheLineIsolated & that ) function operator= \ud83d\udd17 1 2 3 4 5 template < typename V , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < V > , CpuCacheLineIsolated >>> inline CpuCacheLineIsolated & operator = ( V && val ) function operator= \ud83d\udd17 1 2 3 inline CpuCacheLineIsolated & operator = ( CpuCacheLineIsolated && that ) function ~CpuCacheLineIsolated \ud83d\udd17 1 inline ~ CpuCacheLineIsolated () function get \ud83d\udd17 1 inline T * get () function get \ud83d\udd17 1 inline const T * get () const function value \ud83d\udd17 1 inline T & value () function value \ud83d\udd17 1 inline const T & value () const function value \ud83d\udd17 1 inline T && value () function value \ud83d\udd17 1 const T && value () const = deleted function operator-> \ud83d\udd17 1 inline T * operator -> () function operator-> \ud83d\udd17 1 inline const T * operator -> () const function operator* \ud83d\udd17 1 inline T & operator * () function operator* \ud83d\udd17 1 inline const T & operator * () const function operator* \ud83d\udd17 1 inline T && operator * () Public Attributes Documentation \ud83d\udd17 variable kIsolatedSize \ud83d\udd17 1 2 static constexpr usize kIsolatedSize = ( sizeof ( T ) + kCpuCacheLineSize - 1 ) - (( sizeof ( T ) + kCpuCacheLineSize - 1 ) % kCpuCacheLineSize ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::CpuCacheLineIsolated"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-types","text":"Name using T value_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-functions","text":"Name CpuCacheLineIsolated * pointer_from (T * inner_obj) const CpuCacheLineIsolated * pointer_from (const T * inner_obj) CpuCacheLineIsolated () template <typename... Args,typename =EnableIfNoShadow > CpuCacheLineIsolated (Args &&... args) CpuCacheLineIsolated (const CpuCacheLineIsolated & that) CpuCacheLineIsolated ( CpuCacheLineIsolated && that) CpuCacheLineIsolated & operator= (const CpuCacheLineIsolated & that) template <typename V ,typename =std::enable_if_t<!std::is_same_v , CpuCacheLineIsolated>>> CpuCacheLineIsolated & operator= (V && val) CpuCacheLineIsolated & operator= ( CpuCacheLineIsolated && that) ~CpuCacheLineIsolated () T * get () const T * get () const T & value () const T & value () const T && value () const T && value () const =deleted T * operator-> () const T * operator-> () const T & operator* () const T & operator* () const T && operator* ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-attributes","text":"Name constexpr usize kIsolatedSize","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#detailed-description","text":"1 2 template < typename T > class batt :: CpuCacheLineIsolated ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#using-value_type","text":"1 using batt :: CpuCacheLineIsolated < T >:: value_type = T ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-pointer_from","text":"1 2 3 static inline CpuCacheLineIsolated * pointer_from ( T * inner_obj )","title":"function pointer_from"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-pointer_from_1","text":"1 2 3 static inline const CpuCacheLineIsolated * pointer_from ( const T * inner_obj )","title":"function pointer_from"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated","text":"1 inline CpuCacheLineIsolated ()","title":"function CpuCacheLineIsolated"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_1","text":"1 2 3 4 5 template < typename ... Args , typename = EnableIfNoShadow < CpuCacheLineIsolated , Args ... >> inline explicit CpuCacheLineIsolated ( Args && ... args )","title":"function CpuCacheLineIsolated"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_2","text":"1 2 3 inline CpuCacheLineIsolated ( const CpuCacheLineIsolated & that )","title":"function CpuCacheLineIsolated"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_3","text":"1 2 3 inline CpuCacheLineIsolated ( CpuCacheLineIsolated && that )","title":"function CpuCacheLineIsolated"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator","text":"1 2 3 inline CpuCacheLineIsolated & operator = ( const CpuCacheLineIsolated & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_1","text":"1 2 3 4 5 template < typename V , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < V > , CpuCacheLineIsolated >>> inline CpuCacheLineIsolated & operator = ( V && val )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_2","text":"1 2 3 inline CpuCacheLineIsolated & operator = ( CpuCacheLineIsolated && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_4","text":"1 inline ~ CpuCacheLineIsolated ()","title":"function ~CpuCacheLineIsolated"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-get","text":"1 inline T * get ()","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-get_1","text":"1 inline const T * get () const","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value","text":"1 inline T & value ()","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value_1","text":"1 inline const T & value () const","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value_2","text":"1 inline T && value ()","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value_3","text":"1 const T && value () const = deleted","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator-","text":"1 inline T * operator -> ()","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator-_1","text":"1 inline const T * operator -> () const","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_3","text":"1 inline T & operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_4","text":"1 inline const T & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_5","text":"1 inline T && operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#variable-kisolatedsize","text":"1 2 static constexpr usize kIsolatedSize = ( sizeof ( T ) + kCpuCacheLineSize - 1 ) - (( sizeof ( T ) + kCpuCacheLineSize - 1 ) % kCpuCacheLineSize ); Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kIsolatedSize"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/","text":"batt::CustomAllocHandler \ud83d\udd17 More... Public Types \ud83d\udd17 Name using HandlerAllocator < Handler > allocator_type Public Functions \ud83d\udd17 Name template <typename HandlerArg > CustomAllocHandler ( HandlerMemoryBase & m, HandlerArg && h) allocator_type get_allocator () const template <typename... Args> void operator() (Args &&... args) Detailed Description \ud83d\udd17 1 2 template < typename Handler > class batt :: CustomAllocHandler ; Public Types Documentation \ud83d\udd17 using allocator_type \ud83d\udd17 1 using batt :: CustomAllocHandler < Handler >:: allocator_type = HandlerAllocator < Handler > ; Public Functions Documentation \ud83d\udd17 function CustomAllocHandler \ud83d\udd17 1 2 3 4 5 template < typename HandlerArg > inline CustomAllocHandler ( HandlerMemoryBase & m , HandlerArg && h ) function get_allocator \ud83d\udd17 1 inline allocator_type get_allocator () const function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline void operator ()( Args && ... args ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::CustomAllocHandler"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-types","text":"Name using HandlerAllocator < Handler > allocator_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-functions","text":"Name template <typename HandlerArg > CustomAllocHandler ( HandlerMemoryBase & m, HandlerArg && h) allocator_type get_allocator () const template <typename... Args> void operator() (Args &&... args)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#detailed-description","text":"1 2 template < typename Handler > class batt :: CustomAllocHandler ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#using-allocator_type","text":"1 using batt :: CustomAllocHandler < Handler >:: allocator_type = HandlerAllocator < Handler > ;","title":"using allocator_type"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-customallochandler","text":"1 2 3 4 5 template < typename HandlerArg > inline CustomAllocHandler ( HandlerMemoryBase & m , HandlerArg && h )","title":"function CustomAllocHandler"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-get_allocator","text":"1 inline allocator_type get_allocator () const","title":"function get_allocator"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-operator","text":"1 2 3 4 template < typename ... Args > inline void operator ()( Args && ... args ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/","text":"batt::DebugInfoFrame \ud83d\udd17 Public Functions \ud83d\udd17 Name Slice< DebugInfoFrame * > all_threads () DebugInfoFrame *& top () template <typename Fn > DebugInfoFrame (Fn && fn) ~DebugInfoFrame () Friends \ud83d\udd17 Name void print_debug_info ( DebugInfoFrame * p, std::ostream & out) Public Functions Documentation \ud83d\udd17 function all_threads \ud83d\udd17 1 static inline Slice < DebugInfoFrame * > all_threads () function top \ud83d\udd17 1 static inline DebugInfoFrame *& top () function DebugInfoFrame \ud83d\udd17 1 2 3 4 template < typename Fn > inline explicit DebugInfoFrame ( Fn && fn ) function ~DebugInfoFrame \ud83d\udd17 1 inline ~ DebugInfoFrame () Friends \ud83d\udd17 friend print_debug_info \ud83d\udd17 1 2 3 4 5 friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::DebugInfoFrame"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#public-functions","text":"Name Slice< DebugInfoFrame * > all_threads () DebugInfoFrame *& top () template <typename Fn > DebugInfoFrame (Fn && fn) ~DebugInfoFrame ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#friends","text":"Name void print_debug_info ( DebugInfoFrame * p, std::ostream & out)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-all_threads","text":"1 static inline Slice < DebugInfoFrame * > all_threads ()","title":"function all_threads"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-top","text":"1 static inline DebugInfoFrame *& top ()","title":"function top"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-debuginfoframe","text":"1 2 3 4 template < typename Fn > inline explicit DebugInfoFrame ( Fn && fn )","title":"function DebugInfoFrame"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-debuginfoframe_1","text":"1 inline ~ DebugInfoFrame ()","title":"function ~DebugInfoFrame"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#friend-print_debug_info","text":"1 2 3 4 5 friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend print_debug_info"},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/","text":"batt::DefaultHttpClient \ud83d\udd17 Public Functions \ud83d\udd17 Name HttpClient & get () Public Functions Documentation \ud83d\udd17 function get \ud83d\udd17 1 static inline HttpClient & get () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::DefaultHttpClient"},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/#public-functions","text":"Name HttpClient & get ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/#function-get","text":"1 static inline HttpClient & get () Updated on 26 August 2022 at 17:30:03 UTC","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/","text":"batt::DerivedMetricExporter \ud83d\udd17 More... Inherits from batt::MetricExporter Public Functions \ud83d\udd17 Name DerivedMetricExporter (const std::string & name, DerivedMetric< T > & metric) virtual Token get_name () const override virtual double get_value () const override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: DerivedMetricExporter ; Public Functions Documentation \ud83d\udd17 function DerivedMetricExporter \ud83d\udd17 1 2 3 4 inline explicit DerivedMetricExporter ( const std :: string & name , DerivedMetric < T > & metric ) function get_name \ud83d\udd17 1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name function get_value \ud83d\udd17 1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::DerivedMetricExporter"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#public-functions","text":"Name DerivedMetricExporter (const std::string & name, DerivedMetric< T > & metric) virtual Token get_name () const override virtual double get_value () const override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#additional-inherited-members","text":"Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#detailed-description","text":"1 2 template < typename T > class batt :: DerivedMetricExporter ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#function-derivedmetricexporter","text":"1 2 3 4 inline explicit DerivedMetricExporter ( const std :: string & name , DerivedMetric < T > & metric )","title":"function DerivedMetricExporter"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#function-get_name","text":"1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name","title":"function get_name"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#function-get_value","text":"1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/","text":"batt::ExhaustiveModelChecker \ud83d\udd17 More... Public Types \ud83d\udd17 Name using ModelT StateMachineModel using typename StateMachineModel::Branch Branch using typename StateMachineModel::state_type StateT using StateMachineResult Result using StateMachineModelCheckAdvancedOptions AdvancedOptions using typename Branch::delta_type BranchDelta using typename StateMachineModel::VisitResult VisitResult using :: batt::StrongType < bool, BATT_STRONG_TYPEDEF_PASTE_( ForceSend , _TAG)> ForceSend Public Functions \ud83d\udd17 Name constexpr bool strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( ForceSend , _TAG) * ) ExhaustiveModelChecker (StateMachineModel & model, detail::ParallelModelCheckState < Branch > & mesh, usize shard_i) ~ExhaustiveModelChecker () Result run () usize pick_int (usize min_value, usize max_value) Detailed Description \ud83d\udd17 1 2 template < typename ModelT > class batt :: ExhaustiveModelChecker ; Public Types Documentation \ud83d\udd17 using StateMachineModel \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: StateMachineModel = ModelT ; using Branch \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: Branch = typename StateMachineModel :: Branch ; using StateT \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: StateT = typename StateMachineModel :: state_type ; using Result \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: Result = StateMachineResult ; using AdvancedOptions \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: AdvancedOptions = StateMachineModelCheckAdvancedOptions ; using BranchDelta \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: BranchDelta = typename Branch :: delta_type ; using VisitResult \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: VisitResult = typename StateMachineModel :: VisitResult ; using ForceSend \ud83d\udd17 1 using batt :: ExhaustiveModelChecker < ModelT >:: ForceSend = :: batt :: StrongType < bool , BATT_STRONG_TYPEDEF_PASTE_ ( ForceSend , _TAG ) > ; Public Functions Documentation \ud83d\udd17 function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr bool strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( ForceSend , _TAG ) * ) function ExhaustiveModelChecker \ud83d\udd17 1 2 3 4 5 inline explicit ExhaustiveModelChecker ( StateMachineModel & model , detail :: ParallelModelCheckState < Branch > & mesh , usize shard_i ) function ~ExhaustiveModelChecker \ud83d\udd17 1 inline ~ ExhaustiveModelChecker () function run \ud83d\udd17 1 Result run () function pick_int \ud83d\udd17 1 2 3 4 inline usize pick_int ( usize min_value , usize max_value ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::ExhaustiveModelChecker"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-types","text":"Name using ModelT StateMachineModel using typename StateMachineModel::Branch Branch using typename StateMachineModel::state_type StateT using StateMachineResult Result using StateMachineModelCheckAdvancedOptions AdvancedOptions using typename Branch::delta_type BranchDelta using typename StateMachineModel::VisitResult VisitResult using :: batt::StrongType < bool, BATT_STRONG_TYPEDEF_PASTE_( ForceSend , _TAG)> ForceSend","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-functions","text":"Name constexpr bool strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( ForceSend , _TAG) * ) ExhaustiveModelChecker (StateMachineModel & model, detail::ParallelModelCheckState < Branch > & mesh, usize shard_i) ~ExhaustiveModelChecker () Result run () usize pick_int (usize min_value, usize max_value)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#detailed-description","text":"1 2 template < typename ModelT > class batt :: ExhaustiveModelChecker ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-statemachinemodel","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: StateMachineModel = ModelT ;","title":"using StateMachineModel"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-branch","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: Branch = typename StateMachineModel :: Branch ;","title":"using Branch"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-statet","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: StateT = typename StateMachineModel :: state_type ;","title":"using StateT"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-result","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: Result = StateMachineResult ;","title":"using Result"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-advancedoptions","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: AdvancedOptions = StateMachineModelCheckAdvancedOptions ;","title":"using AdvancedOptions"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-branchdelta","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: BranchDelta = typename Branch :: delta_type ;","title":"using BranchDelta"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-visitresult","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: VisitResult = typename StateMachineModel :: VisitResult ;","title":"using VisitResult"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-forcesend","text":"1 using batt :: ExhaustiveModelChecker < ModelT >:: ForceSend = :: batt :: StrongType < bool , BATT_STRONG_TYPEDEF_PASTE_ ( ForceSend , _TAG ) > ;","title":"using ForceSend"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-strong_typedef_default_value","text":"1 2 3 inline constexpr bool strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( ForceSend , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-exhaustivemodelchecker","text":"1 2 3 4 5 inline explicit ExhaustiveModelChecker ( StateMachineModel & model , detail :: ParallelModelCheckState < Branch > & mesh , usize shard_i )","title":"function ExhaustiveModelChecker"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-exhaustivemodelchecker_1","text":"1 inline ~ ExhaustiveModelChecker ()","title":"function ~ExhaustiveModelChecker"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-run","text":"1 Result run ()","title":"function run"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-pick_int","text":"1 2 3 4 inline usize pick_int ( usize min_value , usize max_value ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function pick_int"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/","text":"batt::FakeExecutionContext \ud83d\udd17 Inherits from execution_context Public Classes \ud83d\udd17 Name struct AlwaysReturnZero Public Types \ud83d\udd17 Name using BasicFakeExecutor < boost::asio::execution::outstanding_work_t::untracked_t > executor_type Public Functions \ud83d\udd17 Name FakeExecutionContext () =default ~FakeExecutionContext () =default executor_type get_executor () Watch < i64 > & work_count () void push_ready_handler ( UniqueHandler <> && handler) UniqueHandler pop_ready_handler (const std::function< usize(usize)> & picker = AlwaysReturnZero {}) std::allocator< void > get_allocator () const bool poll_one () usize poll () usize run () Friends \ud83d\udd17 Name class BasicFakeExecutor Public Types Documentation \ud83d\udd17 using executor_type \ud83d\udd17 1 using batt :: FakeExecutionContext :: executor_type = BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; Public Functions Documentation \ud83d\udd17 function FakeExecutionContext \ud83d\udd17 1 FakeExecutionContext () = default function ~FakeExecutionContext \ud83d\udd17 1 ~ FakeExecutionContext () = default function get_executor \ud83d\udd17 1 inline executor_type get_executor () function work_count \ud83d\udd17 1 inline Watch < i64 > & work_count () function push_ready_handler \ud83d\udd17 1 2 3 inline void push_ready_handler ( UniqueHandler <> && handler ) function pop_ready_handler \ud83d\udd17 1 2 3 inline UniqueHandler pop_ready_handler ( const std :: function < usize ( usize ) > & picker = AlwaysReturnZero {} ) function get_allocator \ud83d\udd17 1 inline std :: allocator < void > get_allocator () const function poll_one \ud83d\udd17 1 inline bool poll_one () function poll \ud83d\udd17 1 inline usize poll () function run \ud83d\udd17 1 inline usize run () Friends \ud83d\udd17 friend BasicFakeExecutor \ud83d\udd17 1 friend class BasicFakeExecutor ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeExecutionContext"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-classes","text":"Name struct AlwaysReturnZero","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-types","text":"Name using BasicFakeExecutor < boost::asio::execution::outstanding_work_t::untracked_t > executor_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-functions","text":"Name FakeExecutionContext () =default ~FakeExecutionContext () =default executor_type get_executor () Watch < i64 > & work_count () void push_ready_handler ( UniqueHandler <> && handler) UniqueHandler pop_ready_handler (const std::function< usize(usize)> & picker = AlwaysReturnZero {}) std::allocator< void > get_allocator () const bool poll_one () usize poll () usize run ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#friends","text":"Name class BasicFakeExecutor","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#using-executor_type","text":"1 using batt :: FakeExecutionContext :: executor_type = BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ;","title":"using executor_type"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-fakeexecutioncontext","text":"1 FakeExecutionContext () = default","title":"function FakeExecutionContext"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-fakeexecutioncontext_1","text":"1 ~ FakeExecutionContext () = default","title":"function ~FakeExecutionContext"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-get_executor","text":"1 inline executor_type get_executor ()","title":"function get_executor"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-work_count","text":"1 inline Watch < i64 > & work_count ()","title":"function work_count"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-push_ready_handler","text":"1 2 3 inline void push_ready_handler ( UniqueHandler <> && handler )","title":"function push_ready_handler"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-pop_ready_handler","text":"1 2 3 inline UniqueHandler pop_ready_handler ( const std :: function < usize ( usize ) > & picker = AlwaysReturnZero {} )","title":"function pop_ready_handler"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-get_allocator","text":"1 inline std :: allocator < void > get_allocator () const","title":"function get_allocator"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-poll_one","text":"1 inline bool poll_one ()","title":"function poll_one"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-poll","text":"1 inline usize poll ()","title":"function poll"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-run","text":"1 inline usize run ()","title":"function run"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#friend-basicfakeexecutor","text":"1 friend class BasicFakeExecutor ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/","text":"batt::FakeTaskScheduler \ud83d\udd17 Inherits from batt::TaskScheduler Public Classes \ud83d\udd17 Name class ScopeGuard Public Functions \ud83d\udd17 Name FakeTaskScheduler () =default FakeExecutionContext & get_context () FakeExecutor get_executor () virtual boost::asio::any_io_executor schedule_task () override virtual void halt () override virtual void join () override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::TaskScheduler Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default Protected Functions inherited from batt::TaskScheduler Name TaskScheduler () =default Public Functions Documentation \ud83d\udd17 function FakeTaskScheduler \ud83d\udd17 1 FakeTaskScheduler () = default function get_context \ud83d\udd17 1 inline FakeExecutionContext & get_context () function get_executor \ud83d\udd17 1 inline FakeExecutor get_executor () function schedule_task \ud83d\udd17 1 inline virtual boost :: asio :: any_io_executor schedule_task () override Reimplements : batt::TaskScheduler::schedule_task function halt \ud83d\udd17 1 inline virtual void halt () override Reimplements : batt::TaskScheduler::halt function join \ud83d\udd17 1 inline virtual void join () override Reimplements : batt::TaskScheduler::join Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeTaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#public-classes","text":"Name class ScopeGuard","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#public-functions","text":"Name FakeTaskScheduler () =default FakeExecutionContext & get_context () FakeExecutor get_executor () virtual boost::asio::any_io_executor schedule_task () override virtual void halt () override virtual void join () override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#additional-inherited-members","text":"Public Functions inherited from batt::TaskScheduler Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default Protected Functions inherited from batt::TaskScheduler Name TaskScheduler () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-faketaskscheduler","text":"1 FakeTaskScheduler () = default","title":"function FakeTaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-get_context","text":"1 inline FakeExecutionContext & get_context ()","title":"function get_context"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-get_executor","text":"1 inline FakeExecutor get_executor ()","title":"function get_executor"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-schedule_task","text":"1 inline virtual boost :: asio :: any_io_executor schedule_task () override Reimplements : batt::TaskScheduler::schedule_task","title":"function schedule_task"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-halt","text":"1 inline virtual void halt () override Reimplements : batt::TaskScheduler::halt","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-join","text":"1 inline virtual void join () override Reimplements : batt::TaskScheduler::join Updated on 26 August 2022 at 17:30:03 UTC","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/","text":"batt::FakeTaskScheduler::ScopeGuard \ud83d\udd17 Public Functions \ud83d\udd17 Name ScopeGuard (const ScopeGuard & ) =deleted ScopeGuard & operator= (const ScopeGuard & ) =deleted ScopeGuard ( FakeTaskScheduler & scheduler) ~ScopeGuard () Public Functions Documentation \ud83d\udd17 function ScopeGuard \ud83d\udd17 1 2 3 ScopeGuard ( const ScopeGuard & ) = deleted function operator= \ud83d\udd17 1 2 3 ScopeGuard & operator = ( const ScopeGuard & ) = deleted function ScopeGuard \ud83d\udd17 1 2 3 inline explicit ScopeGuard ( FakeTaskScheduler & scheduler ) function ~ScopeGuard \ud83d\udd17 1 inline ~ ScopeGuard () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeTaskScheduler::ScopeGuard"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#public-functions","text":"Name ScopeGuard (const ScopeGuard & ) =deleted ScopeGuard & operator= (const ScopeGuard & ) =deleted ScopeGuard ( FakeTaskScheduler & scheduler) ~ScopeGuard ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-scopeguard","text":"1 2 3 ScopeGuard ( const ScopeGuard & ) = deleted","title":"function ScopeGuard"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-operator","text":"1 2 3 ScopeGuard & operator = ( const ScopeGuard & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-scopeguard_1","text":"1 2 3 inline explicit ScopeGuard ( FakeTaskScheduler & scheduler )","title":"function ScopeGuard"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-scopeguard_2","text":"1 inline ~ ScopeGuard () Updated on 26 August 2022 at 17:30:03 UTC","title":"function ~ScopeGuard"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/","text":"batt::FakeTimeService \ud83d\udd17 Inherits from service Public Classes \ud83d\udd17 Name class State struct TimerInstance Public Types \ud83d\udd17 Name using FakeTimeService Self using boost::posix_time::ptime TimePoint using boost::posix_time::time_duration Duration using boost::heap::d_ary_heap< TimerInstance , boost::heap::arity< 2 >, boost::heap::compare< std::greater<> >, boost::heap::mutable_< true > > TimerQueue Public Functions \ud83d\udd17 Name State & state () TimePoint now () void advance_time (Duration delta) FakeTimeService (boost::asio::execution_context & context) void shutdown () override template <typename HandlerFn > void async_wait (const boost::asio::any_io_executor & executor, TimePoint expires_at, HandlerFn && fn) Public Attributes \ud83d\udd17 Name boost::asio::execution_context::id id Public Types Documentation \ud83d\udd17 using Self \ud83d\udd17 1 using batt :: FakeTimeService :: Self = FakeTimeService ; using TimePoint \ud83d\udd17 1 using batt :: FakeTimeService :: TimePoint = boost :: posix_time :: ptime ; using Duration \ud83d\udd17 1 using batt :: FakeTimeService :: Duration = boost :: posix_time :: time_duration ; using TimerQueue \ud83d\udd17 1 using batt :: FakeTimeService :: TimerQueue = boost :: heap :: d_ary_heap < TimerInstance , boost :: heap :: arity < 2 > , boost :: heap :: compare < std :: greater <> > , boost :: heap :: mutable_ < true > > ; Public Functions Documentation \ud83d\udd17 function state \ud83d\udd17 1 static inline State & state () function now \ud83d\udd17 1 static inline TimePoint now () function advance_time \ud83d\udd17 1 2 3 static inline void advance_time ( Duration delta ) function FakeTimeService \ud83d\udd17 1 2 3 inline explicit FakeTimeService ( boost :: asio :: execution_context & context ) function shutdown \ud83d\udd17 1 inline void shutdown () override function async_wait \ud83d\udd17 1 2 3 4 5 6 template < typename HandlerFn > inline void async_wait ( const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ) Public Attributes Documentation \ud83d\udd17 variable id \ud83d\udd17 1 static boost :: asio :: execution_context :: id id ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeTimeService"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-classes","text":"Name class State struct TimerInstance","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-types","text":"Name using FakeTimeService Self using boost::posix_time::ptime TimePoint using boost::posix_time::time_duration Duration using boost::heap::d_ary_heap< TimerInstance , boost::heap::arity< 2 >, boost::heap::compare< std::greater<> >, boost::heap::mutable_< true > > TimerQueue","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-functions","text":"Name State & state () TimePoint now () void advance_time (Duration delta) FakeTimeService (boost::asio::execution_context & context) void shutdown () override template <typename HandlerFn > void async_wait (const boost::asio::any_io_executor & executor, TimePoint expires_at, HandlerFn && fn)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-attributes","text":"Name boost::asio::execution_context::id id","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-self","text":"1 using batt :: FakeTimeService :: Self = FakeTimeService ;","title":"using Self"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-timepoint","text":"1 using batt :: FakeTimeService :: TimePoint = boost :: posix_time :: ptime ;","title":"using TimePoint"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-duration","text":"1 using batt :: FakeTimeService :: Duration = boost :: posix_time :: time_duration ;","title":"using Duration"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-timerqueue","text":"1 using batt :: FakeTimeService :: TimerQueue = boost :: heap :: d_ary_heap < TimerInstance , boost :: heap :: arity < 2 > , boost :: heap :: compare < std :: greater <> > , boost :: heap :: mutable_ < true > > ;","title":"using TimerQueue"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-state","text":"1 static inline State & state ()","title":"function state"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-now","text":"1 static inline TimePoint now ()","title":"function now"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-advance_time","text":"1 2 3 static inline void advance_time ( Duration delta )","title":"function advance_time"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-faketimeservice","text":"1 2 3 inline explicit FakeTimeService ( boost :: asio :: execution_context & context )","title":"function FakeTimeService"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-shutdown","text":"1 inline void shutdown () override","title":"function shutdown"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-async_wait","text":"1 2 3 4 5 6 template < typename HandlerFn > inline void async_wait ( const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn )","title":"function async_wait"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#variable-id","text":"1 static boost :: asio :: execution_context :: id id ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable id"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/","text":"batt::FakeTimeService::State \ud83d\udd17 Public Types \ud83d\udd17 Name using std::unique_lock< std::mutex > Lock Public Functions \ud83d\udd17 Name State () TimePoint now () template <typename HandlerFn > void schedule_timer ( FakeTimeService * service_instance, const boost::asio::any_io_executor & executor, TimePoint expires_at, HandlerFn && fn) void advance_time (Duration delta) Public Types Documentation \ud83d\udd17 using Lock \ud83d\udd17 1 using batt :: FakeTimeService :: State :: Lock = std :: unique_lock < std :: mutex > ; Public Functions Documentation \ud83d\udd17 function State \ud83d\udd17 1 inline State () function now \ud83d\udd17 1 inline TimePoint now () function schedule_timer \ud83d\udd17 1 2 3 4 5 6 7 template < typename HandlerFn > inline void schedule_timer ( FakeTimeService * service_instance , const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ) function advance_time \ud83d\udd17 1 2 3 inline void advance_time ( Duration delta ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeTimeService::State"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-types","text":"Name using std::unique_lock< std::mutex > Lock","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-functions","text":"Name State () TimePoint now () template <typename HandlerFn > void schedule_timer ( FakeTimeService * service_instance, const boost::asio::any_io_executor & executor, TimePoint expires_at, HandlerFn && fn) void advance_time (Duration delta)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#using-lock","text":"1 using batt :: FakeTimeService :: State :: Lock = std :: unique_lock < std :: mutex > ;","title":"using Lock"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-state","text":"1 inline State ()","title":"function State"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-now","text":"1 inline TimePoint now ()","title":"function now"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-schedule_timer","text":"1 2 3 4 5 6 7 template < typename HandlerFn > inline void schedule_timer ( FakeTimeService * service_instance , const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn )","title":"function schedule_timer"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-advance_time","text":"1 2 3 inline void advance_time ( Duration delta ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function advance_time"},{"location":"_autogen/Classes/classbatt_1_1FilterBufferSource/","text":"batt::FilterBufferSource \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < typename Src , typename MapFn > class batt :: FilterBufferSource ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FilterBufferSource"},{"location":"_autogen/Classes/classbatt_1_1FilterBufferSource/#detailed-description","text":"1 2 3 template < typename Src , typename MapFn > class batt :: FilterBufferSource ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/","text":"batt::FinalAct \ud83d\udd17 More... Public Functions \ud83d\udd17 Name FinalAct (const FinalAct & ) =deleted FinalAct & operator= (const FinalAct & ) =deleted FinalAct ( FinalAct && that) template <typename FnArg ,typename =EnableIfNoShadow > FinalAct (FnArg && arg) ~FinalAct () void cancel () Detailed Description \ud83d\udd17 1 2 template < typename Fn > class batt :: FinalAct ; Public Functions Documentation \ud83d\udd17 function FinalAct \ud83d\udd17 1 2 3 FinalAct ( const FinalAct & ) = deleted function operator= \ud83d\udd17 1 2 3 FinalAct & operator = ( const FinalAct & ) = deleted function FinalAct \ud83d\udd17 1 2 3 inline FinalAct ( FinalAct && that ) function FinalAct \ud83d\udd17 1 2 3 4 5 template < typename FnArg , typename = EnableIfNoShadow < FinalAct , FnArg &&>> inline explicit FinalAct ( FnArg && arg ) function ~FinalAct \ud83d\udd17 1 inline ~ FinalAct () function cancel \ud83d\udd17 1 inline void cancel () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FinalAct"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#public-functions","text":"Name FinalAct (const FinalAct & ) =deleted FinalAct & operator= (const FinalAct & ) =deleted FinalAct ( FinalAct && that) template <typename FnArg ,typename =EnableIfNoShadow > FinalAct (FnArg && arg) ~FinalAct () void cancel ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#detailed-description","text":"1 2 template < typename Fn > class batt :: FinalAct ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact","text":"1 2 3 FinalAct ( const FinalAct & ) = deleted","title":"function FinalAct"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-operator","text":"1 2 3 FinalAct & operator = ( const FinalAct & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact_1","text":"1 2 3 inline FinalAct ( FinalAct && that )","title":"function FinalAct"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact_2","text":"1 2 3 4 5 template < typename FnArg , typename = EnableIfNoShadow < FinalAct , FnArg &&>> inline explicit FinalAct ( FnArg && arg )","title":"function FinalAct"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact_3","text":"1 inline ~ FinalAct ()","title":"function ~FinalAct"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-cancel","text":"1 inline void cancel () Updated on 26 August 2022 at 17:30:03 UTC","title":"function cancel"},{"location":"_autogen/Classes/classbatt_1_1Future/","text":"batt::Future \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename Handler > void async_wait (Handler && handler) const bool is_ready () const Friends \ud83d\udd17 Name Future < U > get_future (const Promise < U > & promise) Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Future ; Public Functions Documentation \ud83d\udd17 function async_wait \ud83d\udd17 1 2 3 4 template < typename Handler > inline void async_wait ( Handler && handler ) const function is_ready \ud83d\udd17 1 inline bool is_ready () const Friends \ud83d\udd17 friend get_future \ud83d\udd17 1 2 3 friend Future < U > get_future ( const Promise < U > & promise ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Future"},{"location":"_autogen/Classes/classbatt_1_1Future/#public-functions","text":"Name template <typename Handler > void async_wait (Handler && handler) const bool is_ready () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Future/#friends","text":"Name Future < U > get_future (const Promise < U > & promise)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Future/#detailed-description","text":"1 2 template < typename T > class batt :: Future ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Future/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-async_wait","text":"1 2 3 4 template < typename Handler > inline void async_wait ( Handler && handler ) const","title":"function async_wait"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-is_ready","text":"1 inline bool is_ready () const","title":"function is_ready"},{"location":"_autogen/Classes/classbatt_1_1Future/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Future/#friend-get_future","text":"1 2 3 friend Future < U > get_future ( const Promise < U > & promise ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend get_future"},{"location":"_autogen/Classes/classbatt_1_1Grant/","text":"batt::Grant \ud83d\udd17 Public Classes \ud83d\udd17 Name class Issuer Public Functions \ud83d\udd17 Name Grant (const Grant & ) =deleted Grant & operator= (const Grant & ) =deleted Grant ( Grant && that) Grant & operator= ( Grant && ) =deleted ~Grant () const Issuer * get_issuer () const bool empty () const operator bool () const bool is_valid () const bool is_revoked () const void revoke () u64 size () const StatusOr < Grant > spend (u64 count, WaitForResource wait_for_resource =WaitForResource::kFalse) u64 spend_all () Grant & subsume ( Grant && that) void swap ( Grant & that) Public Functions Documentation \ud83d\udd17 function Grant \ud83d\udd17 1 2 3 Grant ( const Grant & ) = deleted function operator= \ud83d\udd17 1 2 3 Grant & operator = ( const Grant & ) = deleted function Grant \ud83d\udd17 1 2 3 inline Grant ( Grant && that ) function operator= \ud83d\udd17 1 2 3 Grant & operator = ( Grant && ) = deleted function ~Grant \ud83d\udd17 1 inline ~ Grant () function get_issuer \ud83d\udd17 1 inline const Issuer * get_issuer () const function empty \ud83d\udd17 1 inline bool empty () const function operator bool \ud83d\udd17 1 inline explicit operator bool () const function is_valid \ud83d\udd17 1 inline bool is_valid () const function is_revoked \ud83d\udd17 1 inline bool is_revoked () const function revoke \ud83d\udd17 1 inline void revoke () function size \ud83d\udd17 1 inline u64 size () const function spend \ud83d\udd17 1 2 3 4 inline StatusOr < Grant > spend ( u64 count , WaitForResource wait_for_resource = WaitForResource :: kFalse ) function spend_all \ud83d\udd17 1 inline u64 spend_all () function subsume \ud83d\udd17 1 2 3 inline Grant & subsume ( Grant && that ) function swap \ud83d\udd17 1 2 3 inline void swap ( Grant & that ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Grant"},{"location":"_autogen/Classes/classbatt_1_1Grant/#public-classes","text":"Name class Issuer","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1Grant/#public-functions","text":"Name Grant (const Grant & ) =deleted Grant & operator= (const Grant & ) =deleted Grant ( Grant && that) Grant & operator= ( Grant && ) =deleted ~Grant () const Issuer * get_issuer () const bool empty () const operator bool () const bool is_valid () const bool is_revoked () const void revoke () u64 size () const StatusOr < Grant > spend (u64 count, WaitForResource wait_for_resource =WaitForResource::kFalse) u64 spend_all () Grant & subsume ( Grant && that) void swap ( Grant & that)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Grant/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-grant","text":"1 2 3 Grant ( const Grant & ) = deleted","title":"function Grant"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-operator","text":"1 2 3 Grant & operator = ( const Grant & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-grant_1","text":"1 2 3 inline Grant ( Grant && that )","title":"function Grant"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-operator_1","text":"1 2 3 Grant & operator = ( Grant && ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-grant_2","text":"1 inline ~ Grant ()","title":"function ~Grant"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-get_issuer","text":"1 inline const Issuer * get_issuer () const","title":"function get_issuer"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-empty","text":"1 inline bool empty () const","title":"function empty"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-is_valid","text":"1 inline bool is_valid () const","title":"function is_valid"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-is_revoked","text":"1 inline bool is_revoked () const","title":"function is_revoked"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-revoke","text":"1 inline void revoke ()","title":"function revoke"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-size","text":"1 inline u64 size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-spend","text":"1 2 3 4 inline StatusOr < Grant > spend ( u64 count , WaitForResource wait_for_resource = WaitForResource :: kFalse )","title":"function spend"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-spend_all","text":"1 inline u64 spend_all ()","title":"function spend_all"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-subsume","text":"1 2 3 inline Grant & subsume ( Grant && that )","title":"function subsume"},{"location":"_autogen/Classes/classbatt_1_1Grant/#function-swap","text":"1 2 3 inline void swap ( Grant & that ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function swap"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/","text":"batt::Grant::Issuer \ud83d\udd17 Public Functions \ud83d\udd17 Name Issuer () =default Issuer (u64 initial_count) Issuer (const Issuer & ) =deleted Issuer & operator= (const Issuer & ) =deleted ~Issuer () StatusOr < Grant > issue_grant (u64 count, WaitForResource wait_for_resource) void grow (u64 count) void close () u64 available () const Friends \ud83d\udd17 Name class Grant Public Functions Documentation \ud83d\udd17 function Issuer \ud83d\udd17 1 Issuer () = default function Issuer \ud83d\udd17 1 2 3 inline explicit Issuer ( u64 initial_count ) function Issuer \ud83d\udd17 1 2 3 Issuer ( const Issuer & ) = deleted function operator= \ud83d\udd17 1 2 3 Issuer & operator = ( const Issuer & ) = deleted function ~Issuer \ud83d\udd17 1 inline ~ Issuer () function issue_grant \ud83d\udd17 1 2 3 4 inline StatusOr < Grant > issue_grant ( u64 count , WaitForResource wait_for_resource ) function grow \ud83d\udd17 1 2 3 inline void grow ( u64 count ) function close \ud83d\udd17 1 inline void close () function available \ud83d\udd17 1 inline u64 available () const Friends \ud83d\udd17 friend Grant \ud83d\udd17 1 friend class Grant ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Grant::Issuer"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#public-functions","text":"Name Issuer () =default Issuer (u64 initial_count) Issuer (const Issuer & ) =deleted Issuer & operator= (const Issuer & ) =deleted ~Issuer () StatusOr < Grant > issue_grant (u64 count, WaitForResource wait_for_resource) void grow (u64 count) void close () u64 available () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#friends","text":"Name class Grant","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-issuer","text":"1 Issuer () = default","title":"function Issuer"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-issuer_1","text":"1 2 3 inline explicit Issuer ( u64 initial_count )","title":"function Issuer"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-issuer_2","text":"1 2 3 Issuer ( const Issuer & ) = deleted","title":"function Issuer"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-operator","text":"1 2 3 Issuer & operator = ( const Issuer & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-issuer_3","text":"1 inline ~ Issuer ()","title":"function ~Issuer"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-issue_grant","text":"1 2 3 4 inline StatusOr < Grant > issue_grant ( u64 count , WaitForResource wait_for_resource )","title":"function issue_grant"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-grow","text":"1 2 3 inline void grow ( u64 count )","title":"function grow"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-close","text":"1 inline void close ()","title":"function close"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#function-available","text":"1 inline u64 available () const","title":"function available"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Grant_1_1Issuer/#friend-grant","text":"1 friend class Grant ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend Grant"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/","text":"batt::HandlerAllocator \ud83d\udd17 More... Public Types \ud83d\udd17 Name using T value_type Public Functions \ud83d\udd17 Name HandlerAllocator ( HandlerMemoryBase & mem) template <typename U > HandlerAllocator (const HandlerAllocator < U > & that) bool operator== (const HandlerAllocator & that) const bool operator!= (const HandlerAllocator & that) const T * allocate (usize n) const void deallocate (T * p, usize ) const Friends \ud83d\udd17 Name class HandlerAllocator Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: HandlerAllocator ; Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: HandlerAllocator < T >:: value_type = T ; Public Functions Documentation \ud83d\udd17 function HandlerAllocator \ud83d\udd17 1 2 3 inline explicit HandlerAllocator ( HandlerMemoryBase & mem ) function HandlerAllocator \ud83d\udd17 1 2 3 4 template < typename U > inline HandlerAllocator ( const HandlerAllocator < U > & that ) function operator== \ud83d\udd17 1 2 3 inline bool operator == ( const HandlerAllocator & that ) const function operator!= \ud83d\udd17 1 2 3 inline bool operator != ( const HandlerAllocator & that ) const function allocate \ud83d\udd17 1 2 3 inline T * allocate ( usize n ) const function deallocate \ud83d\udd17 1 2 3 4 inline void deallocate ( T * p , usize ) const Friends \ud83d\udd17 friend HandlerAllocator \ud83d\udd17 1 friend class HandlerAllocator ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HandlerAllocator"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-types","text":"Name using T value_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-functions","text":"Name HandlerAllocator ( HandlerMemoryBase & mem) template <typename U > HandlerAllocator (const HandlerAllocator < U > & that) bool operator== (const HandlerAllocator & that) const bool operator!= (const HandlerAllocator & that) const T * allocate (usize n) const void deallocate (T * p, usize ) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#friends","text":"Name class HandlerAllocator","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#detailed-description","text":"1 2 template < typename T > class batt :: HandlerAllocator ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#using-value_type","text":"1 using batt :: HandlerAllocator < T >:: value_type = T ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-handlerallocator","text":"1 2 3 inline explicit HandlerAllocator ( HandlerMemoryBase & mem )","title":"function HandlerAllocator"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-handlerallocator_1","text":"1 2 3 4 template < typename U > inline HandlerAllocator ( const HandlerAllocator < U > & that )","title":"function HandlerAllocator"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-operator","text":"1 2 3 inline bool operator == ( const HandlerAllocator & that ) const","title":"function operator=="},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-operator_1","text":"1 2 3 inline bool operator != ( const HandlerAllocator & that ) const","title":"function operator!="},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-allocate","text":"1 2 3 inline T * allocate ( usize n ) const","title":"function allocate"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-deallocate","text":"1 2 3 4 inline void deallocate ( T * p , usize ) const","title":"function deallocate"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#friend-handlerallocator","text":"1 friend class HandlerAllocator ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend HandlerAllocator"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/","text":"batt::HandlerBinder \ud83d\udd17 More... Public Types \ud83d\udd17 Name using boost::asio::associated_allocator_t< InnerFn > allocator_type Public Functions \ud83d\udd17 Name template <typename InnerFnArg ,typename OuterFnArg > HandlerBinder (InnerFnArg && inner, OuterFnArg && outer) allocator_type get_allocator () const template <typename... Args> void operator() (Args &&... args) Public Attributes \ud83d\udd17 Name InnerFn inner_fn_ OuterFn outer_fn_ Detailed Description \ud83d\udd17 1 2 3 template < typename InnerFn , typename OuterFn > class batt :: HandlerBinder ; Public Types Documentation \ud83d\udd17 using allocator_type \ud83d\udd17 1 using batt :: HandlerBinder < InnerFn , OuterFn >:: allocator_type = boost :: asio :: associated_allocator_t < InnerFn > ; Public Functions Documentation \ud83d\udd17 function HandlerBinder \ud83d\udd17 1 2 3 4 5 6 template < typename InnerFnArg , typename OuterFnArg > inline explicit HandlerBinder ( InnerFnArg && inner , OuterFnArg && outer ) function get_allocator \ud83d\udd17 1 inline allocator_type get_allocator () const function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline void operator ()( Args && ... args ) Public Attributes Documentation \ud83d\udd17 variable inner_fn_ \ud83d\udd17 1 InnerFn inner_fn_ ; variable outer_fn_ \ud83d\udd17 1 OuterFn outer_fn_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HandlerBinder"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-types","text":"Name using boost::asio::associated_allocator_t< InnerFn > allocator_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-functions","text":"Name template <typename InnerFnArg ,typename OuterFnArg > HandlerBinder (InnerFnArg && inner, OuterFnArg && outer) allocator_type get_allocator () const template <typename... Args> void operator() (Args &&... args)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-attributes","text":"Name InnerFn inner_fn_ OuterFn outer_fn_","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#detailed-description","text":"1 2 3 template < typename InnerFn , typename OuterFn > class batt :: HandlerBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#using-allocator_type","text":"1 using batt :: HandlerBinder < InnerFn , OuterFn >:: allocator_type = boost :: asio :: associated_allocator_t < InnerFn > ;","title":"using allocator_type"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#function-handlerbinder","text":"1 2 3 4 5 6 template < typename InnerFnArg , typename OuterFnArg > inline explicit HandlerBinder ( InnerFnArg && inner , OuterFnArg && outer )","title":"function HandlerBinder"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#function-get_allocator","text":"1 inline allocator_type get_allocator () const","title":"function get_allocator"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#function-operator","text":"1 2 3 4 template < typename ... Args > inline void operator ()( Args && ... args )","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#variable-inner_fn_","text":"1 InnerFn inner_fn_ ;","title":"variable inner_fn_"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#variable-outer_fn_","text":"1 OuterFn outer_fn_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable outer_fn_"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/","text":"batt::HandlerImpl \ud83d\udd17 More... Inherits from batt::AbstractHandler< Args... > , boost::intrusive::list_base_hook<> Public Types \ud83d\udd17 Name using typename std::allocator_traits< boost::asio::associated_allocator_t< HandlerFn > >::template rebind_alloc< HandlerImpl > allocator_type Public Functions \ud83d\udd17 Name template <typename HandlerFnArg > HandlerImpl * make_new (HandlerFnArg && h) template <typename HandlerFnArg > HandlerImpl * make_new (HandlerFnArg && h, usize extra_bytes) template <typename HandlerFnArg ,typename =batt::EnableIfNoShadow > HandlerImpl (HandlerFnArg && h) virtual void notify (Args... args) override virtual void destroy () override virtual void dump (std::ostream & out) override HandlerFn & get_fn () Additional inherited members \ud83d\udd17 Public Classes inherited from batt::AbstractHandler< Args... > Name struct Deleter Public Functions inherited from batt::AbstractHandler< Args... > Name AbstractHandler (const AbstractHandler & ) =deleted AbstractHandler & operator= (const AbstractHandler & ) =deleted Protected Functions inherited from batt::AbstractHandler< Args... > Name AbstractHandler () =default virtual ~AbstractHandler () =default Detailed Description \ud83d\udd17 1 2 3 template < typename HandlerFn , typename ... Args > class batt :: HandlerImpl ; Public Types Documentation \ud83d\udd17 using allocator_type \ud83d\udd17 1 using batt :: HandlerImpl < HandlerFn , Args >:: allocator_type = typename std :: allocator_traits < boost :: asio :: associated_allocator_t < HandlerFn > >:: template rebind_alloc < HandlerImpl > ; Public Functions Documentation \ud83d\udd17 function make_new \ud83d\udd17 1 2 3 4 template < typename HandlerFnArg > static inline HandlerImpl * make_new ( HandlerFnArg && h ) function make_new \ud83d\udd17 1 2 3 4 5 template < typename HandlerFnArg > static inline HandlerImpl * make_new ( HandlerFnArg && h , usize extra_bytes ) function HandlerImpl \ud83d\udd17 1 2 3 4 5 template < typename HandlerFnArg , typename = batt :: EnableIfNoShadow < HandlerImpl , HandlerFnArg &&>> inline explicit HandlerImpl ( HandlerFnArg && h ) function notify \ud83d\udd17 1 2 3 inline virtual void notify ( Args ... args ) override Reimplements : batt::AbstractHandler::notify function destroy \ud83d\udd17 1 inline virtual void destroy () override Reimplements : batt::AbstractHandler::destroy function dump \ud83d\udd17 1 2 3 inline virtual void dump ( std :: ostream & out ) override Reimplements : batt::AbstractHandler::dump function get_fn \ud83d\udd17 1 inline HandlerFn & get_fn () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HandlerImpl"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#public-types","text":"Name using typename std::allocator_traits< boost::asio::associated_allocator_t< HandlerFn > >::template rebind_alloc< HandlerImpl > allocator_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#public-functions","text":"Name template <typename HandlerFnArg > HandlerImpl * make_new (HandlerFnArg && h) template <typename HandlerFnArg > HandlerImpl * make_new (HandlerFnArg && h, usize extra_bytes) template <typename HandlerFnArg ,typename =batt::EnableIfNoShadow > HandlerImpl (HandlerFnArg && h) virtual void notify (Args... args) override virtual void destroy () override virtual void dump (std::ostream & out) override HandlerFn & get_fn ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#additional-inherited-members","text":"Public Classes inherited from batt::AbstractHandler< Args... > Name struct Deleter Public Functions inherited from batt::AbstractHandler< Args... > Name AbstractHandler (const AbstractHandler & ) =deleted AbstractHandler & operator= (const AbstractHandler & ) =deleted Protected Functions inherited from batt::AbstractHandler< Args... > Name AbstractHandler () =default virtual ~AbstractHandler () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#detailed-description","text":"1 2 3 template < typename HandlerFn , typename ... Args > class batt :: HandlerImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#using-allocator_type","text":"1 using batt :: HandlerImpl < HandlerFn , Args >:: allocator_type = typename std :: allocator_traits < boost :: asio :: associated_allocator_t < HandlerFn > >:: template rebind_alloc < HandlerImpl > ;","title":"using allocator_type"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-make_new","text":"1 2 3 4 template < typename HandlerFnArg > static inline HandlerImpl * make_new ( HandlerFnArg && h )","title":"function make_new"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-make_new_1","text":"1 2 3 4 5 template < typename HandlerFnArg > static inline HandlerImpl * make_new ( HandlerFnArg && h , usize extra_bytes )","title":"function make_new"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-handlerimpl","text":"1 2 3 4 5 template < typename HandlerFnArg , typename = batt :: EnableIfNoShadow < HandlerImpl , HandlerFnArg &&>> inline explicit HandlerImpl ( HandlerFnArg && h )","title":"function HandlerImpl"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-notify","text":"1 2 3 inline virtual void notify ( Args ... args ) override Reimplements : batt::AbstractHandler::notify","title":"function notify"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-destroy","text":"1 inline virtual void destroy () override Reimplements : batt::AbstractHandler::destroy","title":"function destroy"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-dump","text":"1 2 3 inline virtual void dump ( std :: ostream & out ) override Reimplements : batt::AbstractHandler::dump","title":"function dump"},{"location":"_autogen/Classes/classbatt_1_1HandlerImpl/#function-get_fn","text":"1 inline HandlerFn & get_fn () Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_fn"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/","text":"batt::HandlerMemory \ud83d\udd17 More... Inherits from batt::HandlerMemoryBase Public Functions \ud83d\udd17 Name HandlerMemory () HandlerMemory (const HandlerMemory & ) =deleted HandlerMemory & operator= (const HandlerMemory & ) =deleted virtual void * allocate (usize size) override virtual void deallocate (void * pointer) override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::HandlerMemoryBase Name HandlerMemoryBase (const HandlerMemoryBase & ) =deleted virtual ~HandlerMemoryBase () =default bool in_use () const Protected Functions inherited from batt::HandlerMemoryBase Name HandlerMemoryBase () =default Protected Attributes inherited from batt::HandlerMemoryBase Name bool in_use_ Detailed Description \ud83d\udd17 1 2 template < usize kSize > class batt :: HandlerMemory ; Public Functions Documentation \ud83d\udd17 function HandlerMemory \ud83d\udd17 1 inline HandlerMemory () function HandlerMemory \ud83d\udd17 1 2 3 HandlerMemory ( const HandlerMemory & ) = deleted function operator= \ud83d\udd17 1 2 3 HandlerMemory & operator = ( const HandlerMemory & ) = deleted function allocate \ud83d\udd17 1 2 3 inline virtual void * allocate ( usize size ) override Reimplements : batt::HandlerMemoryBase::allocate function deallocate \ud83d\udd17 1 2 3 inline virtual void deallocate ( void * pointer ) override Reimplements : batt::HandlerMemoryBase::deallocate Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HandlerMemory"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#public-functions","text":"Name HandlerMemory () HandlerMemory (const HandlerMemory & ) =deleted HandlerMemory & operator= (const HandlerMemory & ) =deleted virtual void * allocate (usize size) override virtual void deallocate (void * pointer) override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#additional-inherited-members","text":"Public Functions inherited from batt::HandlerMemoryBase Name HandlerMemoryBase (const HandlerMemoryBase & ) =deleted virtual ~HandlerMemoryBase () =default bool in_use () const Protected Functions inherited from batt::HandlerMemoryBase Name HandlerMemoryBase () =default Protected Attributes inherited from batt::HandlerMemoryBase Name bool in_use_","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#detailed-description","text":"1 2 template < usize kSize > class batt :: HandlerMemory ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-handlermemory","text":"1 inline HandlerMemory ()","title":"function HandlerMemory"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-handlermemory_1","text":"1 2 3 HandlerMemory ( const HandlerMemory & ) = deleted","title":"function HandlerMemory"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-operator","text":"1 2 3 HandlerMemory & operator = ( const HandlerMemory & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-allocate","text":"1 2 3 inline virtual void * allocate ( usize size ) override Reimplements : batt::HandlerMemoryBase::allocate","title":"function allocate"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-deallocate","text":"1 2 3 inline virtual void deallocate ( void * pointer ) override Reimplements : batt::HandlerMemoryBase::deallocate Updated on 26 August 2022 at 17:30:03 UTC","title":"function deallocate"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/","text":"batt::HandlerMemoryBase \ud83d\udd17 Inherited by batt::HandlerMemory< kSize > , batt::HandlerMemory< kHandlerMemoryBytes > Public Functions \ud83d\udd17 Name HandlerMemoryBase (const HandlerMemoryBase & ) =deleted HandlerMemoryBase & operator= (const HandlerMemoryBase & ) =deleted virtual ~HandlerMemoryBase () =default virtual void * allocate (usize size) =0 virtual void deallocate (void * pointer) =0 bool in_use () const Protected Functions \ud83d\udd17 Name HandlerMemoryBase () =default Protected Attributes \ud83d\udd17 Name bool in_use_ Public Functions Documentation \ud83d\udd17 function HandlerMemoryBase \ud83d\udd17 1 2 3 HandlerMemoryBase ( const HandlerMemoryBase & ) = deleted function operator= \ud83d\udd17 1 2 3 HandlerMemoryBase & operator = ( const HandlerMemoryBase & ) = deleted function ~HandlerMemoryBase \ud83d\udd17 1 virtual ~ HandlerMemoryBase () = default function allocate \ud83d\udd17 1 2 3 virtual void * allocate ( usize size ) = 0 Reimplemented by : batt::HandlerMemory::allocate , batt::HandlerMemory::allocate function deallocate \ud83d\udd17 1 2 3 virtual void deallocate ( void * pointer ) = 0 Reimplemented by : batt::HandlerMemory::deallocate , batt::HandlerMemory::deallocate function in_use \ud83d\udd17 1 inline bool in_use () const Protected Functions Documentation \ud83d\udd17 function HandlerMemoryBase \ud83d\udd17 1 HandlerMemoryBase () = default Protected Attributes Documentation \ud83d\udd17 variable in_use_ \ud83d\udd17 1 bool in_use_ = false ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HandlerMemoryBase"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#public-functions","text":"Name HandlerMemoryBase (const HandlerMemoryBase & ) =deleted HandlerMemoryBase & operator= (const HandlerMemoryBase & ) =deleted virtual ~HandlerMemoryBase () =default virtual void * allocate (usize size) =0 virtual void deallocate (void * pointer) =0 bool in_use () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#protected-functions","text":"Name HandlerMemoryBase () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#protected-attributes","text":"Name bool in_use_","title":"Protected Attributes"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase","text":"1 2 3 HandlerMemoryBase ( const HandlerMemoryBase & ) = deleted","title":"function HandlerMemoryBase"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-operator","text":"1 2 3 HandlerMemoryBase & operator = ( const HandlerMemoryBase & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase_1","text":"1 virtual ~ HandlerMemoryBase () = default","title":"function ~HandlerMemoryBase"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-allocate","text":"1 2 3 virtual void * allocate ( usize size ) = 0 Reimplemented by : batt::HandlerMemory::allocate , batt::HandlerMemory::allocate","title":"function allocate"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-deallocate","text":"1 2 3 virtual void deallocate ( void * pointer ) = 0 Reimplemented by : batt::HandlerMemory::deallocate , batt::HandlerMemory::deallocate","title":"function deallocate"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-in_use","text":"1 inline bool in_use () const","title":"function in_use"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase_2","text":"1 HandlerMemoryBase () = default","title":"function HandlerMemoryBase"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#variable-in_use_","text":"1 bool in_use_ = false ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable in_use_"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/","text":"batt::HttpChunkDecoder \ud83d\udd17 More... Public Functions \ud83d\udd17 Name HttpChunkDecoder (Src && src, IncludeHttpTrailer consume_trailer = IncludeHttpTrailer {false}) usize size () const bool done () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (const i64 min_count_i) void consume (i64 count) void close_for_read () Detailed Description \ud83d\udd17 1 2 template < typename Src > class batt :: HttpChunkDecoder ; Public Functions Documentation \ud83d\udd17 function HttpChunkDecoder \ud83d\udd17 1 2 3 4 inline explicit HttpChunkDecoder ( Src && src , IncludeHttpTrailer consume_trailer = IncludeHttpTrailer { false } ) function size \ud83d\udd17 1 inline usize size () const function done \ud83d\udd17 1 inline bool done () const function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( const i64 min_count_i ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) function close_for_read \ud83d\udd17 1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpChunkDecoder"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#public-functions","text":"Name HttpChunkDecoder (Src && src, IncludeHttpTrailer consume_trailer = IncludeHttpTrailer {false}) usize size () const bool done () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (const i64 min_count_i) void consume (i64 count) void close_for_read ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#detailed-description","text":"1 2 template < typename Src > class batt :: HttpChunkDecoder ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-httpchunkdecoder","text":"1 2 3 4 inline explicit HttpChunkDecoder ( Src && src , IncludeHttpTrailer consume_trailer = IncludeHttpTrailer { false } )","title":"function HttpChunkDecoder"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-done","text":"1 inline bool done () const","title":"function done"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( const i64 min_count_i )","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-consume","text":"1 2 3 inline void consume ( i64 count )","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-close_for_read","text":"1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/","text":"batt::HttpClient \ud83d\udd17 Public Functions \ud83d\udd17 Name HttpClient (boost::asio::io_context & io) boost::asio::io_context & get_io_context () const Status submit_request (const HostAddress & host_address, Pin < HttpRequest > && request, Pin < HttpResponse > && response) Public Attributes \ud83d\udd17 Name constexpr usize kDefaultMaxConnectionsPerHost Public Functions Documentation \ud83d\udd17 function HttpClient \ud83d\udd17 1 2 3 inline explicit HttpClient ( boost :: asio :: io_context & io ) function get_io_context \ud83d\udd17 1 inline boost :: asio :: io_context & get_io_context () const function submit_request \ud83d\udd17 1 2 3 4 5 inline Status submit_request ( const HostAddress & host_address , Pin < HttpRequest > && request , Pin < HttpResponse > && response ) Public Attributes Documentation \ud83d\udd17 variable kDefaultMaxConnectionsPerHost \ud83d\udd17 1 static constexpr usize kDefaultMaxConnectionsPerHost = HttpClientHostContext :: kDefaultMaxConnections ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpClient"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-functions","text":"Name HttpClient (boost::asio::io_context & io) boost::asio::io_context & get_io_context () const Status submit_request (const HostAddress & host_address, Pin < HttpRequest > && request, Pin < HttpResponse > && response)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-attributes","text":"Name constexpr usize kDefaultMaxConnectionsPerHost","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-httpclient","text":"1 2 3 inline explicit HttpClient ( boost :: asio :: io_context & io )","title":"function HttpClient"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-get_io_context","text":"1 inline boost :: asio :: io_context & get_io_context () const","title":"function get_io_context"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-submit_request","text":"1 2 3 4 5 inline Status submit_request ( const HostAddress & host_address , Pin < HttpRequest > && request , Pin < HttpResponse > && response )","title":"function submit_request"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#variable-kdefaultmaxconnectionsperhost","text":"1 static constexpr usize kDefaultMaxConnectionsPerHost = HttpClientHostContext :: kDefaultMaxConnections ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kDefaultMaxConnectionsPerHost"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/","text":"batt::HttpClientConnection \ud83d\udd17 Public Classes \ud83d\udd17 Name struct ResponseInfo Public Functions \ud83d\udd17 Name HttpClientConnection ( HttpClientHostContext & context) void start () void halt () void join () Status process_requests () Status fill_input_buffer () Status process_responses () Status open_connection () void close_connection () StatusOr < i32 > read_next_response ( pico_http::Response & response) boost::asio::io_context & get_io_context () Public Attributes \ud83d\udd17 Name HttpClientHostContext & context_ boost::asio::ip::tcp::socket socket_ Queue < Pin < HttpResponse > > response_queue_ StreamBuffer input_buffer_ Optional < Task > task_ Public Functions Documentation \ud83d\udd17 function HttpClientConnection \ud83d\udd17 1 2 3 inline explicit HttpClientConnection ( HttpClientHostContext & context ) function start \ud83d\udd17 1 inline void start () function halt \ud83d\udd17 1 void halt () function join \ud83d\udd17 1 inline void join () function process_requests \ud83d\udd17 1 inline Status process_requests () function fill_input_buffer \ud83d\udd17 1 inline Status fill_input_buffer () function process_responses \ud83d\udd17 1 inline Status process_responses () function open_connection \ud83d\udd17 1 inline Status open_connection () function close_connection \ud83d\udd17 1 void close_connection () function read_next_response \ud83d\udd17 1 2 3 inline StatusOr < i32 > read_next_response ( pico_http :: Response & response ) function get_io_context \ud83d\udd17 1 inline boost :: asio :: io_context & get_io_context () Public Attributes Documentation \ud83d\udd17 variable context_ \ud83d\udd17 1 HttpClientHostContext & context_ ; variable socket_ \ud83d\udd17 1 boost :: asio :: ip :: tcp :: socket socket_ ; variable response_queue_ \ud83d\udd17 1 Queue < Pin < HttpResponse > > response_queue_ ; variable input_buffer_ \ud83d\udd17 1 StreamBuffer input_buffer_ { 16 * 1024 }; variable task_ \ud83d\udd17 1 Optional < Task > task_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpClientConnection"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#public-classes","text":"Name struct ResponseInfo","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#public-functions","text":"Name HttpClientConnection ( HttpClientHostContext & context) void start () void halt () void join () Status process_requests () Status fill_input_buffer () Status process_responses () Status open_connection () void close_connection () StatusOr < i32 > read_next_response ( pico_http::Response & response) boost::asio::io_context & get_io_context ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#public-attributes","text":"Name HttpClientHostContext & context_ boost::asio::ip::tcp::socket socket_ Queue < Pin < HttpResponse > > response_queue_ StreamBuffer input_buffer_ Optional < Task > task_","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-httpclientconnection","text":"1 2 3 inline explicit HttpClientConnection ( HttpClientHostContext & context )","title":"function HttpClientConnection"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-start","text":"1 inline void start ()","title":"function start"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-halt","text":"1 void halt ()","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-process_requests","text":"1 inline Status process_requests ()","title":"function process_requests"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-fill_input_buffer","text":"1 inline Status fill_input_buffer ()","title":"function fill_input_buffer"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-process_responses","text":"1 inline Status process_responses ()","title":"function process_responses"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-open_connection","text":"1 inline Status open_connection ()","title":"function open_connection"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-close_connection","text":"1 void close_connection ()","title":"function close_connection"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-read_next_response","text":"1 2 3 inline StatusOr < i32 > read_next_response ( pico_http :: Response & response )","title":"function read_next_response"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#function-get_io_context","text":"1 inline boost :: asio :: io_context & get_io_context ()","title":"function get_io_context"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#variable-context_","text":"1 HttpClientHostContext & context_ ;","title":"variable context_"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#variable-socket_","text":"1 boost :: asio :: ip :: tcp :: socket socket_ ;","title":"variable socket_"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#variable-response_queue_","text":"1 Queue < Pin < HttpResponse > > response_queue_ ;","title":"variable response_queue_"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#variable-input_buffer_","text":"1 StreamBuffer input_buffer_ { 16 * 1024 };","title":"variable input_buffer_"},{"location":"_autogen/Classes/classbatt_1_1HttpClientConnection/#variable-task_","text":"1 Optional < Task > task_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable task_"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/","text":"batt::HttpClientHostContext \ud83d\udd17 Inherits from RefCounted< HttpClientHostContext > Public Functions \ud83d\udd17 Name HttpClientHostContext ( HttpClient & client, const HostAddress & host_address) boost::asio::io_context & get_io_context () HttpClient & client () const Status submit_request ( Pin < HttpRequest > && request, Pin < HttpResponse > && response) void join () bool can_grow () const const HostAddress & host_address () const StatusOr < std::tuple< Pin < HttpRequest >, Pin < HttpResponse > > > await_next_request () Public Attributes \ud83d\udd17 Name constexpr usize kDefaultMaxConnections Public Functions Documentation \ud83d\udd17 function HttpClientHostContext \ud83d\udd17 1 2 3 4 inline explicit HttpClientHostContext ( HttpClient & client , const HostAddress & host_address ) function get_io_context \ud83d\udd17 1 inline boost :: asio :: io_context & get_io_context () function client \ud83d\udd17 1 inline HttpClient & client () const function submit_request \ud83d\udd17 1 2 3 4 inline Status submit_request ( Pin < HttpRequest > && request , Pin < HttpResponse > && response ) function join \ud83d\udd17 1 inline void join () function can_grow \ud83d\udd17 1 inline bool can_grow () const function host_address \ud83d\udd17 1 inline const HostAddress & host_address () const function await_next_request \ud83d\udd17 1 inline StatusOr < std :: tuple < Pin < HttpRequest > , Pin < HttpResponse > > > await_next_request () Public Attributes Documentation \ud83d\udd17 variable kDefaultMaxConnections \ud83d\udd17 1 static constexpr usize kDefaultMaxConnections = 2 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpClientHostContext"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-functions","text":"Name HttpClientHostContext ( HttpClient & client, const HostAddress & host_address) boost::asio::io_context & get_io_context () HttpClient & client () const Status submit_request ( Pin < HttpRequest > && request, Pin < HttpResponse > && response) void join () bool can_grow () const const HostAddress & host_address () const StatusOr < std::tuple< Pin < HttpRequest >, Pin < HttpResponse > > > await_next_request ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-attributes","text":"Name constexpr usize kDefaultMaxConnections","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-httpclienthostcontext","text":"1 2 3 4 inline explicit HttpClientHostContext ( HttpClient & client , const HostAddress & host_address )","title":"function HttpClientHostContext"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-get_io_context","text":"1 inline boost :: asio :: io_context & get_io_context ()","title":"function get_io_context"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-client","text":"1 inline HttpClient & client () const","title":"function client"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-submit_request","text":"1 2 3 4 inline Status submit_request ( Pin < HttpRequest > && request , Pin < HttpResponse > && response )","title":"function submit_request"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-can_grow","text":"1 inline bool can_grow () const","title":"function can_grow"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-host_address","text":"1 inline const HostAddress & host_address () const","title":"function host_address"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-await_next_request","text":"1 inline StatusOr < std :: tuple < Pin < HttpRequest > , Pin < HttpResponse > > > await_next_request ()","title":"function await_next_request"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#variable-kdefaultmaxconnections","text":"1 static constexpr usize kDefaultMaxConnections = 2 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kDefaultMaxConnections"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/","text":"batt::HttpMessageBase \ud83d\udd17 More... Inherits from batt::Pinnable Public Types \ud83d\udd17 Name enum State { kCreated = 0, kInitialized = 1, kConsumed = 2} using T Message Public Functions \ud83d\udd17 Name HttpMessageBase (const HttpMessageBase & ) =deleted HttpMessageBase & operator= (const HttpMessageBase & ) =deleted HttpMessageBase () ~HttpMessageBase () Watch < i32 > & state () void update_status ( Status status) Status get_status () const void async_set_message (Message & message) Status await_set_message (Message & message) StatusOr < Message & > await_message () Message & await_message_or_panic () void release_message () void async_set_data ( HttpData & data) Status await_set_data ( HttpData & data) StatusOr < HttpData & > await_data () void release_data () const SmallVecBase< HttpHeader > & headers () const Optional < std::string_view > find_header (const std::string_view & name) const Protected Attributes \ud83d\udd17 Name Status status_ Watch < i32 > state_ Channel < Message > message_ Channel < HttpData > data_ Additional inherited members \ud83d\udd17 Public Functions inherited from batt::Pinnable Name Pinnable () =default Pinnable (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: HttpMessageBase ; Public Types Documentation \ud83d\udd17 enum State \ud83d\udd17 Enumerator Value Description kCreated 0 kInitialized 1 kConsumed 2 using Message \ud83d\udd17 1 using batt :: HttpMessageBase < T >:: Message = T ; Public Functions Documentation \ud83d\udd17 function HttpMessageBase \ud83d\udd17 1 2 3 HttpMessageBase ( const HttpMessageBase & ) = deleted function operator= \ud83d\udd17 1 2 3 HttpMessageBase & operator = ( const HttpMessageBase & ) = deleted function HttpMessageBase \ud83d\udd17 1 inline HttpMessageBase () function ~HttpMessageBase \ud83d\udd17 1 inline ~ HttpMessageBase () function state \ud83d\udd17 1 inline Watch < i32 > & state () function update_status \ud83d\udd17 1 2 3 inline void update_status ( Status status ) function get_status \ud83d\udd17 1 inline Status get_status () const function async_set_message \ud83d\udd17 1 2 3 inline void async_set_message ( Message & message ) function await_set_message \ud83d\udd17 1 2 3 inline Status await_set_message ( Message & message ) function await_message \ud83d\udd17 1 inline StatusOr < Message & > await_message () function await_message_or_panic \ud83d\udd17 1 inline Message & await_message_or_panic () function release_message \ud83d\udd17 1 inline void release_message () function async_set_data \ud83d\udd17 1 2 3 inline void async_set_data ( HttpData & data ) function await_set_data \ud83d\udd17 1 2 3 inline Status await_set_data ( HttpData & data ) function await_data \ud83d\udd17 1 inline StatusOr < HttpData & > await_data () function release_data \ud83d\udd17 1 inline void release_data () function headers \ud83d\udd17 1 inline const SmallVecBase < HttpHeader > & headers () const function find_header \ud83d\udd17 1 2 3 inline Optional < std :: string_view > find_header ( const std :: string_view & name ) const Protected Attributes Documentation \ud83d\udd17 variable status_ \ud83d\udd17 1 Status status_ { OkStatus ()}; variable state_ \ud83d\udd17 1 Watch < i32 > state_ { kCreated }; variable message_ \ud83d\udd17 1 Channel < Message > message_ ; variable data_ \ud83d\udd17 1 Channel < HttpData > data_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpMessageBase"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-types","text":"Name enum State { kCreated = 0, kInitialized = 1, kConsumed = 2} using T Message","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-functions","text":"Name HttpMessageBase (const HttpMessageBase & ) =deleted HttpMessageBase & operator= (const HttpMessageBase & ) =deleted HttpMessageBase () ~HttpMessageBase () Watch < i32 > & state () void update_status ( Status status) Status get_status () const void async_set_message (Message & message) Status await_set_message (Message & message) StatusOr < Message & > await_message () Message & await_message_or_panic () void release_message () void async_set_data ( HttpData & data) Status await_set_data ( HttpData & data) StatusOr < HttpData & > await_data () void release_data () const SmallVecBase< HttpHeader > & headers () const Optional < std::string_view > find_header (const std::string_view & name) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#protected-attributes","text":"Name Status status_ Watch < i32 > state_ Channel < Message > message_ Channel < HttpData > data_","title":"Protected Attributes"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#additional-inherited-members","text":"Public Functions inherited from batt::Pinnable Name Pinnable () =default Pinnable (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#detailed-description","text":"1 2 template < typename T > class batt :: HttpMessageBase ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#enum-state","text":"Enumerator Value Description kCreated 0 kInitialized 1 kConsumed 2","title":"enum State"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#using-message","text":"1 using batt :: HttpMessageBase < T >:: Message = T ;","title":"using Message"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-httpmessagebase","text":"1 2 3 HttpMessageBase ( const HttpMessageBase & ) = deleted","title":"function HttpMessageBase"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-operator","text":"1 2 3 HttpMessageBase & operator = ( const HttpMessageBase & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-httpmessagebase_1","text":"1 inline HttpMessageBase ()","title":"function HttpMessageBase"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-httpmessagebase_2","text":"1 inline ~ HttpMessageBase ()","title":"function ~HttpMessageBase"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-state","text":"1 inline Watch < i32 > & state ()","title":"function state"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-update_status","text":"1 2 3 inline void update_status ( Status status )","title":"function update_status"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-get_status","text":"1 inline Status get_status () const","title":"function get_status"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-async_set_message","text":"1 2 3 inline void async_set_message ( Message & message )","title":"function async_set_message"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_set_message","text":"1 2 3 inline Status await_set_message ( Message & message )","title":"function await_set_message"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_message","text":"1 inline StatusOr < Message & > await_message ()","title":"function await_message"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_message_or_panic","text":"1 inline Message & await_message_or_panic ()","title":"function await_message_or_panic"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-release_message","text":"1 inline void release_message ()","title":"function release_message"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-async_set_data","text":"1 2 3 inline void async_set_data ( HttpData & data )","title":"function async_set_data"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_set_data","text":"1 2 3 inline Status await_set_data ( HttpData & data )","title":"function await_set_data"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_data","text":"1 inline StatusOr < HttpData & > await_data ()","title":"function await_data"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-release_data","text":"1 inline void release_data ()","title":"function release_data"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-headers","text":"1 inline const SmallVecBase < HttpHeader > & headers () const","title":"function headers"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-find_header","text":"1 2 3 inline Optional < std :: string_view > find_header ( const std :: string_view & name ) const","title":"function find_header"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-status_","text":"1 Status status_ { OkStatus ()};","title":"variable status_"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-state_","text":"1 Watch < i32 > state_ { kCreated };","title":"variable state_"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-message_","text":"1 Channel < Message > message_ ;","title":"variable message_"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-data_","text":"1 Channel < HttpData > data_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable data_"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/","text":"batt::HttpRequest \ud83d\udd17 Inherits from batt::HttpMessageBase< pico_http::Request > , batt::Pinnable Public Functions \ud83d\udd17 Name template <typename AsyncWriteStream > Status serialize (AsyncWriteStream & stream) Additional inherited members \ud83d\udd17 Public Types inherited from batt::HttpMessageBase< pico_http::Request > Name enum State { kCreated, kInitialized, kConsumed} using T Message Public Functions inherited from batt::HttpMessageBase< pico_http::Request > Name HttpMessageBase (const HttpMessageBase & ) =deleted HttpMessageBase & operator= (const HttpMessageBase & ) =deleted HttpMessageBase () ~HttpMessageBase () Watch < i32 > & state () void update_status ( Status status) Status get_status () const void async_set_message (Message & message) Status await_set_message (Message & message) StatusOr < Message & > await_message () Message & await_message_or_panic () void release_message () void async_set_data ( HttpData & data) Status await_set_data ( HttpData & data) StatusOr < HttpData & > await_data () void release_data () const SmallVecBase< HttpHeader > & headers () const Optional < std::string_view > find_header (const std::string_view & name) const Protected Attributes inherited from batt::HttpMessageBase< pico_http::Request > Name Status status_ Watch < i32 > state_ Channel < Message > message_ Channel < HttpData > data_ Public Functions inherited from batt::Pinnable Name Pinnable () =default Pinnable (const Pinnable & ) =deleted Pinnable & operator= (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin () Public Functions Documentation \ud83d\udd17 function serialize \ud83d\udd17 1 2 3 4 template < typename AsyncWriteStream > inline Status serialize ( AsyncWriteStream & stream ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpRequest"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#public-functions","text":"Name template <typename AsyncWriteStream > Status serialize (AsyncWriteStream & stream)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#additional-inherited-members","text":"Public Types inherited from batt::HttpMessageBase< pico_http::Request > Name enum State { kCreated, kInitialized, kConsumed} using T Message Public Functions inherited from batt::HttpMessageBase< pico_http::Request > Name HttpMessageBase (const HttpMessageBase & ) =deleted HttpMessageBase & operator= (const HttpMessageBase & ) =deleted HttpMessageBase () ~HttpMessageBase () Watch < i32 > & state () void update_status ( Status status) Status get_status () const void async_set_message (Message & message) Status await_set_message (Message & message) StatusOr < Message & > await_message () Message & await_message_or_panic () void release_message () void async_set_data ( HttpData & data) Status await_set_data ( HttpData & data) StatusOr < HttpData & > await_data () void release_data () const SmallVecBase< HttpHeader > & headers () const Optional < std::string_view > find_header (const std::string_view & name) const Protected Attributes inherited from batt::HttpMessageBase< pico_http::Request > Name Status status_ Watch < i32 > state_ Channel < Message > message_ Channel < HttpData > data_ Public Functions inherited from batt::Pinnable Name Pinnable () =default Pinnable (const Pinnable & ) =deleted Pinnable & operator= (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#function-serialize","text":"1 2 3 4 template < typename AsyncWriteStream > inline Status serialize ( AsyncWriteStream & stream ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function serialize"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/","text":"batt::HttpResponse \ud83d\udd17 Inherits from batt::HttpMessageBase< pico_http::Response > , batt::Pinnable Public Functions \ud83d\udd17 Name i32 major_version () i32 minor_version () i32 code () std::string_view message_text () Additional inherited members \ud83d\udd17 Public Types inherited from batt::HttpMessageBase< pico_http::Response > Name enum State { kCreated, kInitialized, kConsumed} using T Message Public Functions inherited from batt::HttpMessageBase< pico_http::Response > Name HttpMessageBase (const HttpMessageBase & ) =deleted HttpMessageBase & operator= (const HttpMessageBase & ) =deleted HttpMessageBase () ~HttpMessageBase () Watch < i32 > & state () void update_status ( Status status) Status get_status () const void async_set_message (Message & message) Status await_set_message (Message & message) StatusOr < Message & > await_message () Message & await_message_or_panic () void release_message () void async_set_data ( HttpData & data) Status await_set_data ( HttpData & data) StatusOr < HttpData & > await_data () void release_data () const SmallVecBase< HttpHeader > & headers () const Optional < std::string_view > find_header (const std::string_view & name) const Protected Attributes inherited from batt::HttpMessageBase< pico_http::Response > Name Status status_ Watch < i32 > state_ Channel < Message > message_ Channel < HttpData > data_ Public Functions inherited from batt::Pinnable Name Pinnable () =default Pinnable (const Pinnable & ) =deleted Pinnable & operator= (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin () Public Functions Documentation \ud83d\udd17 function major_version \ud83d\udd17 1 inline i32 major_version () function minor_version \ud83d\udd17 1 inline i32 minor_version () function code \ud83d\udd17 1 inline i32 code () function message_text \ud83d\udd17 1 inline std :: string_view message_text () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpResponse"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#public-functions","text":"Name i32 major_version () i32 minor_version () i32 code () std::string_view message_text ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#additional-inherited-members","text":"Public Types inherited from batt::HttpMessageBase< pico_http::Response > Name enum State { kCreated, kInitialized, kConsumed} using T Message Public Functions inherited from batt::HttpMessageBase< pico_http::Response > Name HttpMessageBase (const HttpMessageBase & ) =deleted HttpMessageBase & operator= (const HttpMessageBase & ) =deleted HttpMessageBase () ~HttpMessageBase () Watch < i32 > & state () void update_status ( Status status) Status get_status () const void async_set_message (Message & message) Status await_set_message (Message & message) StatusOr < Message & > await_message () Message & await_message_or_panic () void release_message () void async_set_data ( HttpData & data) Status await_set_data ( HttpData & data) StatusOr < HttpData & > await_data () void release_data () const SmallVecBase< HttpHeader > & headers () const Optional < std::string_view > find_header (const std::string_view & name) const Protected Attributes inherited from batt::HttpMessageBase< pico_http::Response > Name Status status_ Watch < i32 > state_ Channel < Message > message_ Channel < HttpData > data_ Public Functions inherited from batt::Pinnable Name Pinnable () =default Pinnable (const Pinnable & ) =deleted Pinnable & operator= (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#function-major_version","text":"1 inline i32 major_version ()","title":"function major_version"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#function-minor_version","text":"1 inline i32 minor_version ()","title":"function minor_version"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#function-code","text":"1 inline i32 code ()","title":"function code"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#function-message_text","text":"1 inline std :: string_view message_text () Updated on 26 August 2022 at 17:30:03 UTC","title":"function message_text"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/","text":"batt::HttpServer \ud83d\udd17 Public Types \ud83d\udd17 Name using SmallFn < StatusOr < std::unique_ptr< HttpResponse > >(const HttpRequest &request)> RequestDispatcherFn using SmallFn < StatusOr < RequestDispatcherFn >()> RequestDispatcherFactoryFn Public Functions \ud83d\udd17 Name HttpServer (boost::asio::io_context & io, HostAddress && host_address, RequestDispatcherFactoryFn && dispatcher_factory) ~HttpServer () boost::asio::io_context & get_io_context () const void halt () void join () Status get_final_status () const Public Types Documentation \ud83d\udd17 using RequestDispatcherFn \ud83d\udd17 1 using batt :: HttpServer :: RequestDispatcherFn = SmallFn < StatusOr < std :: unique_ptr < HttpResponse > > ( const HttpRequest & request ) > ; using RequestDispatcherFactoryFn \ud83d\udd17 1 using batt :: HttpServer :: RequestDispatcherFactoryFn = SmallFn < StatusOr < RequestDispatcherFn > () > ; Public Functions Documentation \ud83d\udd17 function HttpServer \ud83d\udd17 1 2 3 4 5 inline explicit HttpServer ( boost :: asio :: io_context & io , HostAddress && host_address , RequestDispatcherFactoryFn && dispatcher_factory ) function ~HttpServer \ud83d\udd17 1 inline ~ HttpServer () function get_io_context \ud83d\udd17 1 inline boost :: asio :: io_context & get_io_context () const function halt \ud83d\udd17 1 inline void halt () function join \ud83d\udd17 1 inline void join () function get_final_status \ud83d\udd17 1 Status get_final_status () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpServer"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#public-types","text":"Name using SmallFn < StatusOr < std::unique_ptr< HttpResponse > >(const HttpRequest &request)> RequestDispatcherFn using SmallFn < StatusOr < RequestDispatcherFn >()> RequestDispatcherFactoryFn","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#public-functions","text":"Name HttpServer (boost::asio::io_context & io, HostAddress && host_address, RequestDispatcherFactoryFn && dispatcher_factory) ~HttpServer () boost::asio::io_context & get_io_context () const void halt () void join () Status get_final_status () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#using-requestdispatcherfn","text":"1 using batt :: HttpServer :: RequestDispatcherFn = SmallFn < StatusOr < std :: unique_ptr < HttpResponse > > ( const HttpRequest & request ) > ;","title":"using RequestDispatcherFn"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#using-requestdispatcherfactoryfn","text":"1 using batt :: HttpServer :: RequestDispatcherFactoryFn = SmallFn < StatusOr < RequestDispatcherFn > () > ;","title":"using RequestDispatcherFactoryFn"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-httpserver","text":"1 2 3 4 5 inline explicit HttpServer ( boost :: asio :: io_context & io , HostAddress && host_address , RequestDispatcherFactoryFn && dispatcher_factory )","title":"function HttpServer"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-httpserver_1","text":"1 inline ~ HttpServer ()","title":"function ~HttpServer"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-get_io_context","text":"1 inline boost :: asio :: io_context & get_io_context () const","title":"function get_io_context"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-halt","text":"1 inline void halt ()","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-get_final_status","text":"1 Status get_final_status () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_final_status"},{"location":"_autogen/Classes/classbatt_1_1IOResult/","text":"batt::IOResult \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::tuple_element_t< 0, std::conditional_t<(sizeof...(Ts)==1), std::tuple< Ts... >, std::tuple< std::tuple< Ts... > >> > value_type Public Functions \ud83d\udd17 Name template <typename... Args,typename =std::enable_if_t >> IOResult (const ErrorCode & ec, Args &&... args) bool ok () const const ErrorCode & error () const value_type & operator* () const value_type & operator* () const value_type & value () const value_type & value () const value_type * operator-> () const value_type * operator-> () const Detailed Description \ud83d\udd17 1 2 template < typename ... Ts > class batt :: IOResult ; Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: IOResult < Ts >:: value_type = std :: tuple_element_t < 0 , std :: conditional_t < ( sizeof ...( Ts ) == 1 ), std :: tuple < Ts ... > , std :: tuple < std :: tuple < Ts ... > >> > ; Public Functions Documentation \ud83d\udd17 function IOResult \ud83d\udd17 1 2 3 4 5 6 template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < value_type , Args && ... >>> inline explicit IOResult ( const ErrorCode & ec , Args && ... args ) function ok \ud83d\udd17 1 inline bool ok () const function error \ud83d\udd17 1 inline const ErrorCode & error () const function operator* \ud83d\udd17 1 inline value_type & operator * () function operator* \ud83d\udd17 1 inline const value_type & operator * () const function value \ud83d\udd17 1 inline value_type & value () function value \ud83d\udd17 1 inline const value_type & value () const function operator-> \ud83d\udd17 1 inline value_type * operator -> () function operator-> \ud83d\udd17 1 inline const value_type * operator -> () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IOResult"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-types","text":"Name using std::tuple_element_t< 0, std::conditional_t<(sizeof...(Ts)==1), std::tuple< Ts... >, std::tuple< std::tuple< Ts... > >> > value_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-functions","text":"Name template <typename... Args,typename =std::enable_if_t >> IOResult (const ErrorCode & ec, Args &&... args) bool ok () const const ErrorCode & error () const value_type & operator* () const value_type & operator* () const value_type & value () const value_type & value () const value_type * operator-> () const value_type * operator-> () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#detailed-description","text":"1 2 template < typename ... Ts > class batt :: IOResult ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#using-value_type","text":"1 using batt :: IOResult < Ts >:: value_type = std :: tuple_element_t < 0 , std :: conditional_t < ( sizeof ...( Ts ) == 1 ), std :: tuple < Ts ... > , std :: tuple < std :: tuple < Ts ... > >> > ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-ioresult","text":"1 2 3 4 5 6 template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < value_type , Args && ... >>> inline explicit IOResult ( const ErrorCode & ec , Args && ... args )","title":"function IOResult"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-ok","text":"1 inline bool ok () const","title":"function ok"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-error","text":"1 inline const ErrorCode & error () const","title":"function error"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator","text":"1 inline value_type & operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator_1","text":"1 inline const value_type & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-value","text":"1 inline value_type & value ()","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-value_1","text":"1 inline const value_type & value () const","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator-","text":"1 inline value_type * operator -> ()","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator-_1","text":"1 inline const value_type * operator -> () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1Latch/","text":"batt::Latch \ud83d\udd17 More... Public Classes \ud83d\udd17 Name class AsyncGetHandler Public Types \ud83d\udd17 Name enum u32 State { kInitial = 0, kSetting = 1, kReady = 3} Public Functions \ud83d\udd17 Name Latch () =default Latch (const Latch & ) =deleted Latch & operator= (const Latch & ) =deleted template <typename... Args> bool set_value (Args &&... args) bool is_ready () const StatusOr < T > await () StatusOr < T > poll () StatusOr < T > get_ready_value_or_panic () template <typename Handler > void async_get (Handler && handler) void invalidate () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Latch ; Public Types Documentation \ud83d\udd17 enum State \ud83d\udd17 Enumerator Value Description kInitial 0 kSetting 1 kReady 3 Public Functions Documentation \ud83d\udd17 function Latch \ud83d\udd17 1 Latch () = default function Latch \ud83d\udd17 1 2 3 Latch ( const Latch & ) = deleted function operator= \ud83d\udd17 1 2 3 Latch & operator = ( const Latch & ) = deleted function set_value \ud83d\udd17 1 2 3 4 template < typename ... Args > inline bool set_value ( Args && ... args ) function is_ready \ud83d\udd17 1 inline bool is_ready () const function await \ud83d\udd17 1 inline StatusOr < T > await () function poll \ud83d\udd17 1 inline StatusOr < T > poll () function get_ready_value_or_panic \ud83d\udd17 1 inline StatusOr < T > get_ready_value_or_panic () function async_get \ud83d\udd17 1 2 3 4 template < typename Handler > inline void async_get ( Handler && handler ) function invalidate \ud83d\udd17 1 inline void invalidate () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Latch"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-classes","text":"Name class AsyncGetHandler","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-types","text":"Name enum u32 State { kInitial = 0, kSetting = 1, kReady = 3}","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-functions","text":"Name Latch () =default Latch (const Latch & ) =deleted Latch & operator= (const Latch & ) =deleted template <typename... Args> bool set_value (Args &&... args) bool is_ready () const StatusOr < T > await () StatusOr < T > poll () StatusOr < T > get_ready_value_or_panic () template <typename Handler > void async_get (Handler && handler) void invalidate ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Latch/#detailed-description","text":"1 2 template < typename T > class batt :: Latch ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1Latch/#enum-state","text":"Enumerator Value Description kInitial 0 kSetting 1 kReady 3","title":"enum State"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-latch","text":"1 Latch () = default","title":"function Latch"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-latch_1","text":"1 2 3 Latch ( const Latch & ) = deleted","title":"function Latch"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-operator","text":"1 2 3 Latch & operator = ( const Latch & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-set_value","text":"1 2 3 4 template < typename ... Args > inline bool set_value ( Args && ... args )","title":"function set_value"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-is_ready","text":"1 inline bool is_ready () const","title":"function is_ready"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-await","text":"1 inline StatusOr < T > await ()","title":"function await"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-poll","text":"1 inline StatusOr < T > poll ()","title":"function poll"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-get_ready_value_or_panic","text":"1 inline StatusOr < T > get_ready_value_or_panic ()","title":"function get_ready_value_or_panic"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-async_get","text":"1 2 3 4 template < typename Handler > inline void async_get ( Handler && handler )","title":"function async_get"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-invalidate","text":"1 inline void invalidate () Updated on 26 August 2022 at 17:30:03 UTC","title":"function invalidate"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/","text":"batt::Latch::AsyncGetHandler \ud83d\udd17 Public Functions \ud83d\udd17 Name AsyncGetHandler ( Latch * latch) template <typename Handler > void operator() (Handler && handler, const StatusOr < u32 > & result) const Public Functions Documentation \ud83d\udd17 function AsyncGetHandler \ud83d\udd17 1 2 3 inline explicit AsyncGetHandler ( Latch * latch ) function operator() \ud83d\udd17 1 2 3 4 5 template < typename Handler > inline void operator ()( Handler && handler , const StatusOr < u32 > & result ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Latch::AsyncGetHandler"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#public-functions","text":"Name AsyncGetHandler ( Latch * latch) template <typename Handler > void operator() (Handler && handler, const StatusOr < u32 > & result) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#function-asyncgethandler","text":"1 2 3 inline explicit AsyncGetHandler ( Latch * latch )","title":"function AsyncGetHandler"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#function-operator","text":"1 2 3 4 5 template < typename Handler > inline void operator ()( Handler && handler , const StatusOr < u32 > & result ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/","text":"batt::LatencyMetric \ud83d\udd17 Public Functions \ud83d\udd17 Name void update (std::chrono::steady_clock::time_point start, u64 count_delta =1) void update (std::chrono::steady_clock::duration elapsed_duration, u64 count_delta =1) double rate_per_second () const void reset () Public Attributes \ud83d\udd17 Name CountMetric < u64 > total_usec CountMetric < u64 > count Public Functions Documentation \ud83d\udd17 function update \ud83d\udd17 1 2 3 4 inline void update ( std :: chrono :: steady_clock :: time_point start , u64 count_delta = 1 ) function update \ud83d\udd17 1 2 3 4 inline void update ( std :: chrono :: steady_clock :: duration elapsed_duration , u64 count_delta = 1 ) function rate_per_second \ud83d\udd17 1 inline double rate_per_second () const function reset \ud83d\udd17 1 inline void reset () Public Attributes Documentation \ud83d\udd17 variable total_usec \ud83d\udd17 1 CountMetric < u64 > total_usec { 0 }; variable count \ud83d\udd17 1 CountMetric < u64 > count { 0 }; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::LatencyMetric"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-functions","text":"Name void update (std::chrono::steady_clock::time_point start, u64 count_delta =1) void update (std::chrono::steady_clock::duration elapsed_duration, u64 count_delta =1) double rate_per_second () const void reset ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-attributes","text":"Name CountMetric < u64 > total_usec CountMetric < u64 > count","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-update","text":"1 2 3 4 inline void update ( std :: chrono :: steady_clock :: time_point start , u64 count_delta = 1 )","title":"function update"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-update_1","text":"1 2 3 4 inline void update ( std :: chrono :: steady_clock :: duration elapsed_duration , u64 count_delta = 1 )","title":"function update"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-rate_per_second","text":"1 inline double rate_per_second () const","title":"function rate_per_second"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-reset","text":"1 inline void reset ()","title":"function reset"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#variable-total_usec","text":"1 CountMetric < u64 > total_usec { 0 };","title":"variable total_usec"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#variable-count","text":"1 CountMetric < u64 > count { 0 }; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable count"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/","text":"batt::LatencyTimer \ud83d\udd17 Public Functions \ud83d\udd17 Name LatencyTimer (const LatencyTimer & ) =deleted LatencyTimer & operator= (const LatencyTimer & ) =deleted LatencyTimer ( LatencyMetric & counter, u64 delta =1) ~LatencyTimer () i64 read_usec () const void stop () Public Functions Documentation \ud83d\udd17 function LatencyTimer \ud83d\udd17 1 2 3 LatencyTimer ( const LatencyTimer & ) = deleted function operator= \ud83d\udd17 1 2 3 LatencyTimer & operator = ( const LatencyTimer & ) = deleted function LatencyTimer \ud83d\udd17 1 2 3 4 inline explicit LatencyTimer ( LatencyMetric & counter , u64 delta = 1 ) function ~LatencyTimer \ud83d\udd17 1 inline ~ LatencyTimer () function read_usec \ud83d\udd17 1 inline i64 read_usec () const function stop \ud83d\udd17 1 inline void stop () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::LatencyTimer"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#public-functions","text":"Name LatencyTimer (const LatencyTimer & ) =deleted LatencyTimer & operator= (const LatencyTimer & ) =deleted LatencyTimer ( LatencyMetric & counter, u64 delta =1) ~LatencyTimer () i64 read_usec () const void stop ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-latencytimer","text":"1 2 3 LatencyTimer ( const LatencyTimer & ) = deleted","title":"function LatencyTimer"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-operator","text":"1 2 3 LatencyTimer & operator = ( const LatencyTimer & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-latencytimer_1","text":"1 2 3 4 inline explicit LatencyTimer ( LatencyMetric & counter , u64 delta = 1 )","title":"function LatencyTimer"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-latencytimer_2","text":"1 inline ~ LatencyTimer ()","title":"function ~LatencyTimer"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-read_usec","text":"1 inline i64 read_usec () const","title":"function read_usec"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-stop","text":"1 inline void stop () Updated on 26 August 2022 at 17:30:03 UTC","title":"function stop"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/","text":"batt::ManagedBuffer \ud83d\udd17 Inherits from RefCounted< ManagedBuffer > Public Functions \ud83d\udd17 Name char * data () const char * data () const usize size () const Public Attributes \ud83d\udd17 Name constexpr usize kCapacity Public Functions Documentation \ud83d\udd17 function data \ud83d\udd17 1 inline char * data () function data \ud83d\udd17 1 inline const char * data () const function size \ud83d\udd17 1 inline usize size () const Public Attributes Documentation \ud83d\udd17 variable kCapacity \ud83d\udd17 1 static constexpr usize kCapacity = 4096 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::ManagedBuffer"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-functions","text":"Name char * data () const char * data () const usize size () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-attributes","text":"Name constexpr usize kCapacity","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#function-data","text":"1 inline char * data ()","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#function-data_1","text":"1 inline const char * data () const","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#variable-kcapacity","text":"1 static constexpr usize kCapacity = 4096 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kCapacity"},{"location":"_autogen/Classes/classbatt_1_1MapBufferSource/","text":"batt::MapBufferSource \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < typename Src , typename MapFn > class batt :: MapBufferSource ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MapBufferSource"},{"location":"_autogen/Classes/classbatt_1_1MapBufferSource/#detailed-description","text":"1 2 3 template < typename Src , typename MapFn > class batt :: MapBufferSource ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/","text":"batt::MetricCsvFormatter \ud83d\udd17 Inherits from batt::MetricFormatter Public Functions \ud83d\udd17 Name virtual void initialize ( MetricRegistry & src, std::ostream & dst) override virtual void format_values ( MetricRegistry & src, std::ostream & dst) override virtual void finished ( MetricRegistry & src, std::ostream & dst) override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::MetricFormatter Name MetricFormatter (const MetricFormatter & ) =deleted MetricFormatter & operator= (const MetricFormatter & ) =deleted virtual ~MetricFormatter () =default Protected Functions inherited from batt::MetricFormatter Name MetricFormatter () =default Public Functions Documentation \ud83d\udd17 function initialize \ud83d\udd17 1 2 3 4 virtual void initialize ( MetricRegistry & src , std :: ostream & dst ) override Reimplements : batt::MetricFormatter::initialize function format_values \ud83d\udd17 1 2 3 4 virtual void format_values ( MetricRegistry & src , std :: ostream & dst ) override Reimplements : batt::MetricFormatter::format_values function finished \ud83d\udd17 1 2 3 4 virtual void finished ( MetricRegistry & src , std :: ostream & dst ) override Reimplements : batt::MetricFormatter::finished Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MetricCsvFormatter"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#public-functions","text":"Name virtual void initialize ( MetricRegistry & src, std::ostream & dst) override virtual void format_values ( MetricRegistry & src, std::ostream & dst) override virtual void finished ( MetricRegistry & src, std::ostream & dst) override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#additional-inherited-members","text":"Public Functions inherited from batt::MetricFormatter Name MetricFormatter (const MetricFormatter & ) =deleted MetricFormatter & operator= (const MetricFormatter & ) =deleted virtual ~MetricFormatter () =default Protected Functions inherited from batt::MetricFormatter Name MetricFormatter () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#function-initialize","text":"1 2 3 4 virtual void initialize ( MetricRegistry & src , std :: ostream & dst ) override Reimplements : batt::MetricFormatter::initialize","title":"function initialize"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#function-format_values","text":"1 2 3 4 virtual void format_values ( MetricRegistry & src , std :: ostream & dst ) override Reimplements : batt::MetricFormatter::format_values","title":"function format_values"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#function-finished","text":"1 2 3 4 virtual void finished ( MetricRegistry & src , std :: ostream & dst ) override Reimplements : batt::MetricFormatter::finished Updated on 26 August 2022 at 17:30:03 UTC","title":"function finished"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/","text":"batt::MetricDumper \ud83d\udd17 Public Functions \ud83d\udd17 Name MetricDumper ( MetricRegistry & registry, double rows_per_sec, std::ostream & out, std::unique_ptr< MetricFormatter > formatter) ~MetricDumper () void halt () void join () void stop () Public Functions Documentation \ud83d\udd17 function MetricDumper \ud83d\udd17 1 2 3 4 5 6 inline explicit MetricDumper ( MetricRegistry & registry , double rows_per_sec , std :: ostream & out , std :: unique_ptr < MetricFormatter > formatter ) function ~MetricDumper \ud83d\udd17 1 inline ~ MetricDumper () function halt \ud83d\udd17 1 inline void halt () function join \ud83d\udd17 1 inline void join () function stop \ud83d\udd17 1 inline void stop () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MetricDumper"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#public-functions","text":"Name MetricDumper ( MetricRegistry & registry, double rows_per_sec, std::ostream & out, std::unique_ptr< MetricFormatter > formatter) ~MetricDumper () void halt () void join () void stop ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-metricdumper","text":"1 2 3 4 5 6 inline explicit MetricDumper ( MetricRegistry & registry , double rows_per_sec , std :: ostream & out , std :: unique_ptr < MetricFormatter > formatter )","title":"function MetricDumper"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-metricdumper_1","text":"1 inline ~ MetricDumper ()","title":"function ~MetricDumper"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-halt","text":"1 inline void halt ()","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-stop","text":"1 inline void stop () Updated on 26 August 2022 at 17:30:03 UTC","title":"function stop"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/","text":"batt::MetricExporter \ud83d\udd17 Inherited by batt::CountMetricExporter< T > , batt::DerivedMetricExporter< T > , batt::QueueDepthExporter , batt::VariableExporter< T > , batt::WatchExporter< T > Public Functions \ud83d\udd17 Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual Token get_name () const =0 virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) virtual double get_value () const =0 Protected Functions \ud83d\udd17 Name MetricExporter () =default Public Functions Documentation \ud83d\udd17 function MetricExporter \ud83d\udd17 1 2 3 MetricExporter ( const MetricExporter & ) = deleted function operator= \ud83d\udd17 1 2 3 MetricExporter & operator = ( const MetricExporter & ) = deleted function ~MetricExporter \ud83d\udd17 1 virtual ~ MetricExporter () = default function get_name \ud83d\udd17 1 virtual Token get_name () const = 0 Reimplemented by : batt::CountMetricExporter::get_name , batt::DerivedMetricExporter::get_name , batt::VariableExporter::get_name , batt::WatchExporter::get_name , batt::QueueDepthExporter::get_name function get_description \ud83d\udd17 1 inline virtual std :: string_view get_description () const function get_type \ud83d\udd17 1 inline virtual std :: string_view get_type () const function get_labels \ud83d\udd17 1 inline virtual const MetricLabelSet & get_labels () const function set_labels \ud83d\udd17 1 2 3 inline virtual void set_labels ( MetricLabelSet && labels ) function get_value \ud83d\udd17 1 virtual double get_value () const = 0 Reimplemented by : batt::CountMetricExporter::get_value , batt::DerivedMetricExporter::get_value , batt::VariableExporter::get_value , batt::WatchExporter::get_value , batt::QueueDepthExporter::get_value Protected Functions Documentation \ud83d\udd17 function MetricExporter \ud83d\udd17 1 MetricExporter () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MetricExporter"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#public-functions","text":"Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual Token get_name () const =0 virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) virtual double get_value () const =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#protected-functions","text":"Name MetricExporter () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-metricexporter","text":"1 2 3 MetricExporter ( const MetricExporter & ) = deleted","title":"function MetricExporter"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-operator","text":"1 2 3 MetricExporter & operator = ( const MetricExporter & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-metricexporter_1","text":"1 virtual ~ MetricExporter () = default","title":"function ~MetricExporter"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_name","text":"1 virtual Token get_name () const = 0 Reimplemented by : batt::CountMetricExporter::get_name , batt::DerivedMetricExporter::get_name , batt::VariableExporter::get_name , batt::WatchExporter::get_name , batt::QueueDepthExporter::get_name","title":"function get_name"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_description","text":"1 inline virtual std :: string_view get_description () const","title":"function get_description"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_type","text":"1 inline virtual std :: string_view get_type () const","title":"function get_type"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_labels","text":"1 inline virtual const MetricLabelSet & get_labels () const","title":"function get_labels"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-set_labels","text":"1 2 3 inline virtual void set_labels ( MetricLabelSet && labels )","title":"function set_labels"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_value","text":"1 virtual double get_value () const = 0 Reimplemented by : batt::CountMetricExporter::get_value , batt::DerivedMetricExporter::get_value , batt::VariableExporter::get_value , batt::WatchExporter::get_value , batt::QueueDepthExporter::get_value","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-metricexporter_2","text":"1 MetricExporter () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function MetricExporter"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/","text":"batt::MetricFormatter \ud83d\udd17 Inherited by batt::MetricCsvFormatter Public Functions \ud83d\udd17 Name MetricFormatter (const MetricFormatter & ) =deleted MetricFormatter & operator= (const MetricFormatter & ) =deleted virtual ~MetricFormatter () =default virtual void initialize ( MetricRegistry & src, std::ostream & dst) =0 virtual void format_values ( MetricRegistry & src, std::ostream & dst) =0 virtual void finished ( MetricRegistry & src, std::ostream & dst) =0 Protected Functions \ud83d\udd17 Name MetricFormatter () =default Public Functions Documentation \ud83d\udd17 function MetricFormatter \ud83d\udd17 1 2 3 MetricFormatter ( const MetricFormatter & ) = deleted function operator= \ud83d\udd17 1 2 3 MetricFormatter & operator = ( const MetricFormatter & ) = deleted function ~MetricFormatter \ud83d\udd17 1 virtual ~ MetricFormatter () = default function initialize \ud83d\udd17 1 2 3 4 virtual void initialize ( MetricRegistry & src , std :: ostream & dst ) = 0 Reimplemented by : batt::MetricCsvFormatter::initialize function format_values \ud83d\udd17 1 2 3 4 virtual void format_values ( MetricRegistry & src , std :: ostream & dst ) = 0 Reimplemented by : batt::MetricCsvFormatter::format_values function finished \ud83d\udd17 1 2 3 4 virtual void finished ( MetricRegistry & src , std :: ostream & dst ) = 0 Reimplemented by : batt::MetricCsvFormatter::finished Protected Functions Documentation \ud83d\udd17 function MetricFormatter \ud83d\udd17 1 MetricFormatter () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MetricFormatter"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#public-functions","text":"Name MetricFormatter (const MetricFormatter & ) =deleted MetricFormatter & operator= (const MetricFormatter & ) =deleted virtual ~MetricFormatter () =default virtual void initialize ( MetricRegistry & src, std::ostream & dst) =0 virtual void format_values ( MetricRegistry & src, std::ostream & dst) =0 virtual void finished ( MetricRegistry & src, std::ostream & dst) =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#protected-functions","text":"Name MetricFormatter () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-metricformatter","text":"1 2 3 MetricFormatter ( const MetricFormatter & ) = deleted","title":"function MetricFormatter"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-operator","text":"1 2 3 MetricFormatter & operator = ( const MetricFormatter & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-metricformatter_1","text":"1 virtual ~ MetricFormatter () = default","title":"function ~MetricFormatter"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-initialize","text":"1 2 3 4 virtual void initialize ( MetricRegistry & src , std :: ostream & dst ) = 0 Reimplemented by : batt::MetricCsvFormatter::initialize","title":"function initialize"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-format_values","text":"1 2 3 4 virtual void format_values ( MetricRegistry & src , std :: ostream & dst ) = 0 Reimplemented by : batt::MetricCsvFormatter::format_values","title":"function format_values"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-finished","text":"1 2 3 4 virtual void finished ( MetricRegistry & src , std :: ostream & dst ) = 0 Reimplemented by : batt::MetricCsvFormatter::finished","title":"function finished"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-metricformatter_2","text":"1 MetricFormatter () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function MetricFormatter"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/","text":"batt::MetricRegistry \ud83d\udd17 Public Functions \ud83d\udd17 Name MetricRegistry & add_exporter (const void * obj, std::unique_ptr< MetricExporter > exporter, MetricLabelSet && labels) template <typename T > MetricRegistry & add (std::string_view name, CountMetric < T > & counter, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, LatencyMetric & latency, MetricLabelSet && labels =MetricLabelSet{}) template <typename T > MetricRegistry & add (std::string_view name, Watch < T > & watch, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, QueueBase & queue, MetricLabelSet && labels =MetricLabelSet{}) template <typename T > MetricRegistry & add (std::string_view name, DerivedMetric< T > & metric, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, const double & var, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, const usize & var, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, const isize & var, MetricLabelSet && labels =MetricLabelSet{}) void read_all (std::function< void(std::string_view name, double value, const MetricLabelSet &labels)> && fn) const template <typename T > MetricRegistry & remove (T & obj) template <typename T > auto scoped_add (std::string_view name, T & obj) Public Functions Documentation \ud83d\udd17 function add_exporter \ud83d\udd17 1 2 3 4 5 inline MetricRegistry & add_exporter ( const void * obj , std :: unique_ptr < MetricExporter > exporter , MetricLabelSet && labels ) function add \ud83d\udd17 1 2 3 4 5 6 template < typename T > inline MetricRegistry & add ( std :: string_view name , CountMetric < T > & counter , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , LatencyMetric & latency , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 6 template < typename T > inline MetricRegistry & add ( std :: string_view name , Watch < T > & watch , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , QueueBase & queue , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 6 template < typename T > inline MetricRegistry & add ( std :: string_view name , DerivedMetric < T > & metric , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , const double & var , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , const usize & var , MetricLabelSet && labels = MetricLabelSet {} ) function add \ud83d\udd17 1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , const isize & var , MetricLabelSet && labels = MetricLabelSet {} ) function read_all \ud83d\udd17 1 2 3 inline void read_all ( std :: function < void ( std :: string_view name , double value , const MetricLabelSet & labels ) > && fn ) const function remove \ud83d\udd17 1 2 3 4 template < typename T > inline MetricRegistry & remove ( T & obj ) function scoped_add \ud83d\udd17 1 2 3 4 5 template < typename T > inline auto scoped_add ( std :: string_view name , T & obj ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MetricRegistry"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#public-functions","text":"Name MetricRegistry & add_exporter (const void * obj, std::unique_ptr< MetricExporter > exporter, MetricLabelSet && labels) template <typename T > MetricRegistry & add (std::string_view name, CountMetric < T > & counter, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, LatencyMetric & latency, MetricLabelSet && labels =MetricLabelSet{}) template <typename T > MetricRegistry & add (std::string_view name, Watch < T > & watch, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, QueueBase & queue, MetricLabelSet && labels =MetricLabelSet{}) template <typename T > MetricRegistry & add (std::string_view name, DerivedMetric< T > & metric, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, const double & var, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, const usize & var, MetricLabelSet && labels =MetricLabelSet{}) MetricRegistry & add (std::string_view name, const isize & var, MetricLabelSet && labels =MetricLabelSet{}) void read_all (std::function< void(std::string_view name, double value, const MetricLabelSet &labels)> && fn) const template <typename T > MetricRegistry & remove (T & obj) template <typename T > auto scoped_add (std::string_view name, T & obj)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_exporter","text":"1 2 3 4 5 inline MetricRegistry & add_exporter ( const void * obj , std :: unique_ptr < MetricExporter > exporter , MetricLabelSet && labels )","title":"function add_exporter"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add","text":"1 2 3 4 5 6 template < typename T > inline MetricRegistry & add ( std :: string_view name , CountMetric < T > & counter , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_1","text":"1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , LatencyMetric & latency , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_2","text":"1 2 3 4 5 6 template < typename T > inline MetricRegistry & add ( std :: string_view name , Watch < T > & watch , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_3","text":"1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , QueueBase & queue , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_4","text":"1 2 3 4 5 6 template < typename T > inline MetricRegistry & add ( std :: string_view name , DerivedMetric < T > & metric , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_5","text":"1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , const double & var , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_6","text":"1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , const usize & var , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_7","text":"1 2 3 4 5 inline MetricRegistry & add ( std :: string_view name , const isize & var , MetricLabelSet && labels = MetricLabelSet {} )","title":"function add"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-read_all","text":"1 2 3 inline void read_all ( std :: function < void ( std :: string_view name , double value , const MetricLabelSet & labels ) > && fn ) const","title":"function read_all"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-remove","text":"1 2 3 4 template < typename T > inline MetricRegistry & remove ( T & obj )","title":"function remove"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-scoped_add","text":"1 2 3 4 5 template < typename T > inline auto scoped_add ( std :: string_view name , T & obj ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function scoped_add"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/","text":"batt::MutableBufferView \ud83d\udd17 Public Functions \ud83d\udd17 Name MutableBufferView (const MutableBufferView & ) =default MutableBufferView & operator= (const MutableBufferView & ) =default MutableBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset =0) MutableBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset, usize length) operator MutableBuffer () const operator ConstBuffer () const MutableBufferView & operator+= (usize delta) void * data () const usize size () const bool append ( ConstBufferView && next) bool append ( MutableBufferView && next) Friends \ud83d\udd17 Name class ConstBufferView Public Functions Documentation \ud83d\udd17 function MutableBufferView \ud83d\udd17 1 2 3 MutableBufferView ( const MutableBufferView & ) = default function operator= \ud83d\udd17 1 2 3 MutableBufferView & operator = ( const MutableBufferView & ) = default function MutableBufferView \ud83d\udd17 1 2 3 4 inline explicit MutableBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset = 0 ) function MutableBufferView \ud83d\udd17 1 2 3 4 5 inline explicit MutableBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset , usize length ) function operator MutableBuffer \ud83d\udd17 1 inline operator MutableBuffer () const function operator ConstBuffer \ud83d\udd17 1 inline operator ConstBuffer () const function operator+= \ud83d\udd17 1 2 3 inline MutableBufferView & operator += ( usize delta ) function data \ud83d\udd17 1 inline void * data () const function size \ud83d\udd17 1 inline usize size () const function append \ud83d\udd17 1 2 3 inline bool append ( ConstBufferView && next ) function append \ud83d\udd17 1 2 3 inline bool append ( MutableBufferView && next ) Friends \ud83d\udd17 friend ConstBufferView \ud83d\udd17 1 friend class ConstBufferView ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MutableBufferView"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#public-functions","text":"Name MutableBufferView (const MutableBufferView & ) =default MutableBufferView & operator= (const MutableBufferView & ) =default MutableBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset =0) MutableBufferView (SharedPtr< ManagedBuffer > && buffer, usize offset, usize length) operator MutableBuffer () const operator ConstBuffer () const MutableBufferView & operator+= (usize delta) void * data () const usize size () const bool append ( ConstBufferView && next) bool append ( MutableBufferView && next)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#friends","text":"Name class ConstBufferView","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-mutablebufferview","text":"1 2 3 MutableBufferView ( const MutableBufferView & ) = default","title":"function MutableBufferView"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator","text":"1 2 3 MutableBufferView & operator = ( const MutableBufferView & ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-mutablebufferview_1","text":"1 2 3 4 inline explicit MutableBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset = 0 )","title":"function MutableBufferView"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-mutablebufferview_2","text":"1 2 3 4 5 inline explicit MutableBufferView ( SharedPtr < ManagedBuffer > && buffer , usize offset , usize length )","title":"function MutableBufferView"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator-mutablebuffer","text":"1 inline operator MutableBuffer () const","title":"function operator MutableBuffer"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator-constbuffer","text":"1 inline operator ConstBuffer () const","title":"function operator ConstBuffer"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator_1","text":"1 2 3 inline MutableBufferView & operator += ( usize delta )","title":"function operator+="},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-data","text":"1 inline void * data () const","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-append","text":"1 2 3 inline bool append ( ConstBufferView && next )","title":"function append"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-append_1","text":"1 2 3 inline bool append ( MutableBufferView && next )","title":"function append"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#friend-constbufferview","text":"1 friend class ConstBufferView ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1Mutex/","text":"batt::Mutex \ud83d\udd17 More... Public Classes \ud83d\udd17 Name class LockImpl struct ThreadSafeBaseIsNotSupportedByType Public Types \ud83d\udd17 Name using LockImpl < T, Mutex > Lock using LockImpl < const T, const Mutex > ConstLock Public Functions \ud83d\udd17 Name Mutex (const Mutex & ) =deleted Mutex & operator= (const Mutex & ) =deleted Mutex () =default template <typename... Args,typename =EnableIfNoShadow > Mutex (Args &&... args) Lock lock () ConstLock lock () const template <typename Action > decltype(auto) with_lock (Action && action) auto operator-> () decltype(auto) no_lock () decltype(auto) no_lock () const template <typename Self ,typename Base =typename Self::ThreadSafeBase> Base * thread_safe_base (Self * ptr) template <typename Self ,typename Base =typename Self::ThreadSafeBase> const Base * thread_safe_base (const Self * ptr) template <typename Self ,typename Base =typename Self::ThreadSafeBase,typename =void> Base * thread_safe_base (const std::unique_ptr< Self > * ptr) ThreadSafeBaseIsNotSupportedByType < T > * thread_safe_base (... ) Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Mutex ; Public Types Documentation \ud83d\udd17 using Lock \ud83d\udd17 1 using batt :: Mutex < T >:: Lock = LockImpl < T , Mutex > ; using ConstLock \ud83d\udd17 1 using batt :: Mutex < T >:: ConstLock = LockImpl < const T , const Mutex > ; Public Functions Documentation \ud83d\udd17 function Mutex \ud83d\udd17 1 2 3 Mutex ( const Mutex & ) = deleted function operator= \ud83d\udd17 1 2 3 Mutex & operator = ( const Mutex & ) = deleted function Mutex \ud83d\udd17 1 Mutex () = default function Mutex \ud83d\udd17 1 2 3 4 5 template < typename ... Args , typename = EnableIfNoShadow < Mutex , Args ... >> inline explicit Mutex ( Args && ... args ) function lock \ud83d\udd17 1 inline Lock lock () function lock \ud83d\udd17 1 inline ConstLock lock () const function with_lock \ud83d\udd17 1 2 3 4 template < typename Action > inline decltype ( auto ) with_lock ( Action && action ) function operator-> \ud83d\udd17 1 inline auto operator -> () function no_lock \ud83d\udd17 1 inline decltype ( auto ) no_lock () function no_lock \ud83d\udd17 1 inline decltype ( auto ) no_lock () const function thread_safe_base \ud83d\udd17 1 2 3 4 5 template < typename Self , typename Base = typename Self :: ThreadSafeBase > static inline Base * thread_safe_base ( Self * ptr ) function thread_safe_base \ud83d\udd17 1 2 3 4 5 template < typename Self , typename Base = typename Self :: ThreadSafeBase > static inline const Base * thread_safe_base ( const Self * ptr ) function thread_safe_base \ud83d\udd17 1 2 3 4 5 6 template < typename Self , typename Base = typename Self :: ThreadSafeBase , typename = void > static inline Base * thread_safe_base ( const std :: unique_ptr < Self > * ptr ) function thread_safe_base \ud83d\udd17 1 2 3 static inline ThreadSafeBaseIsNotSupportedByType < T > * thread_safe_base ( ... ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Mutex"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-classes","text":"Name class LockImpl struct ThreadSafeBaseIsNotSupportedByType","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-types","text":"Name using LockImpl < T, Mutex > Lock using LockImpl < const T, const Mutex > ConstLock","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-functions","text":"Name Mutex (const Mutex & ) =deleted Mutex & operator= (const Mutex & ) =deleted Mutex () =default template <typename... Args,typename =EnableIfNoShadow > Mutex (Args &&... args) Lock lock () ConstLock lock () const template <typename Action > decltype(auto) with_lock (Action && action) auto operator-> () decltype(auto) no_lock () decltype(auto) no_lock () const template <typename Self ,typename Base =typename Self::ThreadSafeBase> Base * thread_safe_base (Self * ptr) template <typename Self ,typename Base =typename Self::ThreadSafeBase> const Base * thread_safe_base (const Self * ptr) template <typename Self ,typename Base =typename Self::ThreadSafeBase,typename =void> Base * thread_safe_base (const std::unique_ptr< Self > * ptr) ThreadSafeBaseIsNotSupportedByType < T > * thread_safe_base (... )","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#detailed-description","text":"1 2 template < typename T > class batt :: Mutex ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#using-lock","text":"1 using batt :: Mutex < T >:: Lock = LockImpl < T , Mutex > ;","title":"using Lock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#using-constlock","text":"1 using batt :: Mutex < T >:: ConstLock = LockImpl < const T , const Mutex > ;","title":"using ConstLock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-mutex","text":"1 2 3 Mutex ( const Mutex & ) = deleted","title":"function Mutex"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-operator","text":"1 2 3 Mutex & operator = ( const Mutex & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-mutex_1","text":"1 Mutex () = default","title":"function Mutex"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-mutex_2","text":"1 2 3 4 5 template < typename ... Args , typename = EnableIfNoShadow < Mutex , Args ... >> inline explicit Mutex ( Args && ... args )","title":"function Mutex"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-lock","text":"1 inline Lock lock ()","title":"function lock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-lock_1","text":"1 inline ConstLock lock () const","title":"function lock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-with_lock","text":"1 2 3 4 template < typename Action > inline decltype ( auto ) with_lock ( Action && action )","title":"function with_lock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-operator-","text":"1 inline auto operator -> ()","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-no_lock","text":"1 inline decltype ( auto ) no_lock ()","title":"function no_lock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-no_lock_1","text":"1 inline decltype ( auto ) no_lock () const","title":"function no_lock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base","text":"1 2 3 4 5 template < typename Self , typename Base = typename Self :: ThreadSafeBase > static inline Base * thread_safe_base ( Self * ptr )","title":"function thread_safe_base"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base_1","text":"1 2 3 4 5 template < typename Self , typename Base = typename Self :: ThreadSafeBase > static inline const Base * thread_safe_base ( const Self * ptr )","title":"function thread_safe_base"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base_2","text":"1 2 3 4 5 6 template < typename Self , typename Base = typename Self :: ThreadSafeBase , typename = void > static inline Base * thread_safe_base ( const std :: unique_ptr < Self > * ptr )","title":"function thread_safe_base"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base_3","text":"1 2 3 static inline ThreadSafeBaseIsNotSupportedByType < T > * thread_safe_base ( ... ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function thread_safe_base"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/","text":"batt::Mutex::LockImpl \ud83d\udd17 More... Public Functions \ud83d\udd17 Name LockImpl (MutexT & m) LockImpl (const LockImpl & ) =deleted LockImpl & operator= (const LockImpl & ) =deleted LockImpl ( LockImpl && ) =default LockImpl & operator= ( LockImpl && ) =default ~LockImpl () bool is_held () const operator bool () const U & operator* () U * get () U & value () U * operator-> () bool release () Detailed Description \ud83d\udd17 1 2 3 template < typename U , typename MutexT > class batt :: Mutex :: LockImpl ; Public Functions Documentation \ud83d\udd17 function LockImpl \ud83d\udd17 1 2 3 inline explicit LockImpl ( MutexT & m ) function LockImpl \ud83d\udd17 1 2 3 LockImpl ( const LockImpl & ) = deleted function operator= \ud83d\udd17 1 2 3 LockImpl & operator = ( const LockImpl & ) = deleted function LockImpl \ud83d\udd17 1 2 3 LockImpl ( LockImpl && ) = default function operator= \ud83d\udd17 1 2 3 LockImpl & operator = ( LockImpl && ) = default function ~LockImpl \ud83d\udd17 1 inline ~ LockImpl () function is_held \ud83d\udd17 1 inline bool is_held () const function operator bool \ud83d\udd17 1 inline explicit operator bool () const function operator* \ud83d\udd17 1 inline U & operator * () function get \ud83d\udd17 1 inline U * get () function value \ud83d\udd17 1 inline U & value () function operator-> \ud83d\udd17 1 inline U * operator -> () function release \ud83d\udd17 1 inline bool release () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Mutex::LockImpl"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#public-functions","text":"Name LockImpl (MutexT & m) LockImpl (const LockImpl & ) =deleted LockImpl & operator= (const LockImpl & ) =deleted LockImpl ( LockImpl && ) =default LockImpl & operator= ( LockImpl && ) =default ~LockImpl () bool is_held () const operator bool () const U & operator* () U * get () U & value () U * operator-> () bool release ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#detailed-description","text":"1 2 3 template < typename U , typename MutexT > class batt :: Mutex :: LockImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl","text":"1 2 3 inline explicit LockImpl ( MutexT & m )","title":"function LockImpl"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl_1","text":"1 2 3 LockImpl ( const LockImpl & ) = deleted","title":"function LockImpl"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator","text":"1 2 3 LockImpl & operator = ( const LockImpl & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl_2","text":"1 2 3 LockImpl ( LockImpl && ) = default","title":"function LockImpl"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator_1","text":"1 2 3 LockImpl & operator = ( LockImpl && ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl_3","text":"1 inline ~ LockImpl ()","title":"function ~LockImpl"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-is_held","text":"1 inline bool is_held () const","title":"function is_held"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator_2","text":"1 inline U & operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-get","text":"1 inline U * get ()","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-value","text":"1 inline U & value ()","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator-","text":"1 inline U * operator -> ()","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-release","text":"1 inline bool release () Updated on 26 August 2022 at 17:30:03 UTC","title":"function release"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/","text":"batt::NullTaskScheduler \ud83d\udd17 Inherits from batt::TaskScheduler Public Functions \ud83d\udd17 Name NullTaskScheduler & instance () NullTaskScheduler () virtual boost::asio::any_io_executor schedule_task () override virtual void halt () override virtual void join () override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::TaskScheduler Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default Protected Functions inherited from batt::TaskScheduler Name TaskScheduler () =default Public Functions Documentation \ud83d\udd17 function instance \ud83d\udd17 1 static inline NullTaskScheduler & instance () function NullTaskScheduler \ud83d\udd17 1 inline NullTaskScheduler () function schedule_task \ud83d\udd17 1 inline virtual boost :: asio :: any_io_executor schedule_task () override Reimplements : batt::TaskScheduler::schedule_task function halt \ud83d\udd17 1 inline virtual void halt () override Reimplements : batt::TaskScheduler::halt function join \ud83d\udd17 1 inline virtual void join () override Reimplements : batt::TaskScheduler::join Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::NullTaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#public-functions","text":"Name NullTaskScheduler & instance () NullTaskScheduler () virtual boost::asio::any_io_executor schedule_task () override virtual void halt () override virtual void join () override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#additional-inherited-members","text":"Public Functions inherited from batt::TaskScheduler Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default Protected Functions inherited from batt::TaskScheduler Name TaskScheduler () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-instance","text":"1 static inline NullTaskScheduler & instance ()","title":"function instance"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-nulltaskscheduler","text":"1 inline NullTaskScheduler ()","title":"function NullTaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-schedule_task","text":"1 inline virtual boost :: asio :: any_io_executor schedule_task () override Reimplements : batt::TaskScheduler::schedule_task","title":"function schedule_task"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-halt","text":"1 inline virtual void halt () override Reimplements : batt::TaskScheduler::halt","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-join","text":"1 inline virtual void join () override Reimplements : batt::TaskScheduler::join Updated on 26 August 2022 at 17:30:03 UTC","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1Optional/","text":"batt::Optional \ud83d\udd17 More... Public Functions \ud83d\udd17 Name Optional () Optional ( NoneType ) template <typename... Args,typename =std::enable_if_t >> Optional ( InPlaceInitType , Args &&... args) Optional (std::optional< T > && init) template <typename U ,typename =std::enable_if_t && !std::is_same_v\\ > >,typename =batt::EnableIfNoShadow > Optional ( Optional < U > && u) template <typename U ,typename =std::enable_if_t && !std::is_same_v\\ > >,typename =batt::EnableIfNoShadow > Optional (const Optional < U > & u) template <typename... Args,typename =std::enable_if_t >,typename =batt::EnableIfNoShadow > Optional (Args &&... args) Optional (const T & val) ~Optional () Optional ( Optional && that) Optional (const Optional & that) Optional & operator= ( Optional && that) Optional & operator= (const Optional & that) template <typename... Args> T & emplace (Args &&... args) template <typename U > T value_or (U && else_val) const template <typename Fn ,typename U =std::invoke_result_t > Optional < U > map (Fn && fn) const template <typename Fn ,typename OptionalU =std::invoke_result_t > OptionalU flat_map (Fn && fn) const operator bool () const bool has_value () const Optional & operator= ( NoneType ) T & operator* () const T & operator* () const T operator* () T operator* () const =deleted T * operator-> () const T * operator-> () const T * get_ptr () const T * get_ptr () const Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Optional ; Public Functions Documentation \ud83d\udd17 function Optional \ud83d\udd17 1 inline Optional () function Optional \ud83d\udd17 1 2 3 inline Optional ( NoneType ) function Optional \ud83d\udd17 1 2 3 4 5 6 template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > >> inline Optional ( InPlaceInitType , Args && ... args ) function Optional \ud83d\udd17 1 2 3 inline Optional ( std :: optional < T > && init ) function Optional \ud83d\udd17 1 2 3 4 5 6 template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U >> inline Optional ( Optional < U > && u ) function Optional \ud83d\udd17 1 2 3 4 5 6 template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U >> inline Optional ( const Optional < U > & u ) function Optional \ud83d\udd17 1 2 3 4 5 6 template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > > , typename = batt :: EnableIfNoShadow < Optional , Args ... >> inline Optional ( Args && ... args ) function Optional \ud83d\udd17 1 2 3 inline Optional ( const T & val ) function ~Optional \ud83d\udd17 1 inline ~ Optional () function Optional \ud83d\udd17 1 2 3 inline Optional ( Optional && that ) function Optional \ud83d\udd17 1 2 3 inline Optional ( const Optional & that ) function operator= \ud83d\udd17 1 2 3 inline Optional & operator = ( Optional && that ) function operator= \ud83d\udd17 1 2 3 inline Optional & operator = ( const Optional & that ) function emplace \ud83d\udd17 1 2 3 4 template < typename ... Args > inline T & emplace ( Args && ... args ) function value_or \ud83d\udd17 1 2 3 4 template < typename U > inline T value_or ( U && else_val ) const function map \ud83d\udd17 1 2 3 4 5 template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &>> inline Optional < U > map ( Fn && fn ) const function flat_map \ud83d\udd17 1 2 3 4 5 template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &>> inline OptionalU flat_map ( Fn && fn ) const function operator bool \ud83d\udd17 1 inline explicit operator bool () const function has_value \ud83d\udd17 1 inline bool has_value () const function operator= \ud83d\udd17 1 2 3 inline Optional & operator = ( NoneType ) function operator* \ud83d\udd17 1 inline T & operator * () function operator* \ud83d\udd17 1 inline const T & operator * () const function operator* \ud83d\udd17 1 inline T operator * () function operator* \ud83d\udd17 1 T operator * () const = deleted function operator-> \ud83d\udd17 1 inline T * operator -> () function operator-> \ud83d\udd17 1 inline const T * operator -> () const function get_ptr \ud83d\udd17 1 inline T * get_ptr () function get_ptr \ud83d\udd17 1 inline const T * get_ptr () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#public-functions","text":"Name Optional () Optional ( NoneType ) template <typename... Args,typename =std::enable_if_t >> Optional ( InPlaceInitType , Args &&... args) Optional (std::optional< T > && init) template <typename U ,typename =std::enable_if_t && !std::is_same_v\\ > >,typename =batt::EnableIfNoShadow > Optional ( Optional < U > && u) template <typename U ,typename =std::enable_if_t && !std::is_same_v\\ > >,typename =batt::EnableIfNoShadow > Optional (const Optional < U > & u) template <typename... Args,typename =std::enable_if_t >,typename =batt::EnableIfNoShadow > Optional (Args &&... args) Optional (const T & val) ~Optional () Optional ( Optional && that) Optional (const Optional & that) Optional & operator= ( Optional && that) Optional & operator= (const Optional & that) template <typename... Args> T & emplace (Args &&... args) template <typename U > T value_or (U && else_val) const template <typename Fn ,typename U =std::invoke_result_t > Optional < U > map (Fn && fn) const template <typename Fn ,typename OptionalU =std::invoke_result_t > OptionalU flat_map (Fn && fn) const operator bool () const bool has_value () const Optional & operator= ( NoneType ) T & operator* () const T & operator* () const T operator* () T operator* () const =deleted T * operator-> () const T * operator-> () const T * get_ptr () const T * get_ptr () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Optional/#detailed-description","text":"1 2 template < typename T > class batt :: Optional ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Optional/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional","text":"1 inline Optional ()","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_1","text":"1 2 3 inline Optional ( NoneType )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_2","text":"1 2 3 4 5 6 template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > >> inline Optional ( InPlaceInitType , Args && ... args )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_3","text":"1 2 3 inline Optional ( std :: optional < T > && init )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_4","text":"1 2 3 4 5 6 template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U >> inline Optional ( Optional < U > && u )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_5","text":"1 2 3 4 5 6 template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U >> inline Optional ( const Optional < U > & u )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_6","text":"1 2 3 4 5 6 template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > > , typename = batt :: EnableIfNoShadow < Optional , Args ... >> inline Optional ( Args && ... args )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_7","text":"1 2 3 inline Optional ( const T & val )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_8","text":"1 inline ~ Optional ()","title":"function ~Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_9","text":"1 2 3 inline Optional ( Optional && that )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_10","text":"1 2 3 inline Optional ( const Optional & that )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator","text":"1 2 3 inline Optional & operator = ( Optional && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_1","text":"1 2 3 inline Optional & operator = ( const Optional & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-emplace","text":"1 2 3 4 template < typename ... Args > inline T & emplace ( Args && ... args )","title":"function emplace"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-value_or","text":"1 2 3 4 template < typename U > inline T value_or ( U && else_val ) const","title":"function value_or"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-map","text":"1 2 3 4 5 template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &>> inline Optional < U > map ( Fn && fn ) const","title":"function map"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-flat_map","text":"1 2 3 4 5 template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &>> inline OptionalU flat_map ( Fn && fn ) const","title":"function flat_map"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-has_value","text":"1 inline bool has_value () const","title":"function has_value"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_2","text":"1 2 3 inline Optional & operator = ( NoneType )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_3","text":"1 inline T & operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_4","text":"1 inline const T & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_5","text":"1 inline T operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_6","text":"1 T operator * () const = deleted","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator-","text":"1 inline T * operator -> ()","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator-_1","text":"1 inline const T * operator -> () const","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-get_ptr","text":"1 inline T * get_ptr ()","title":"function get_ptr"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-get_ptr_1","text":"1 inline const T * get_ptr () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_ptr"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/","text":"batt::Optional< T & > \ud83d\udd17 More... Public Functions \ud83d\udd17 Name Optional ( NoneType ) Optional (T & ref) ~Optional () template <typename Fn ,typename U =std::invoke_result_t > Optional < U > map (Fn && fn) const template <typename Fn ,typename OptionalU =std::invoke_result_t > OptionalU flat_map (Fn && fn) const T & operator* () const operator bool () const bool operator! () const Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Optional < T & > ; Public Functions Documentation \ud83d\udd17 function Optional \ud83d\udd17 1 2 3 inline Optional ( NoneType ) function Optional \ud83d\udd17 1 2 3 inline Optional ( T & ref ) function ~Optional \ud83d\udd17 1 inline ~ Optional () function map \ud83d\udd17 1 2 3 4 5 template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &>> inline Optional < U > map ( Fn && fn ) const function flat_map \ud83d\udd17 1 2 3 4 5 template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &>> inline OptionalU flat_map ( Fn && fn ) const function operator* \ud83d\udd17 1 inline T & operator * () const function operator bool \ud83d\udd17 1 inline explicit operator bool () const function operator! \ud83d\udd17 1 inline bool operator ! () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Optional< T & >"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#public-functions","text":"Name Optional ( NoneType ) Optional (T & ref) ~Optional () template <typename Fn ,typename U =std::invoke_result_t > Optional < U > map (Fn && fn) const template <typename Fn ,typename OptionalU =std::invoke_result_t > OptionalU flat_map (Fn && fn) const T & operator* () const operator bool () const bool operator! () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#detailed-description","text":"1 2 template < typename T > class batt :: Optional < T & > ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional","text":"1 2 3 inline Optional ( NoneType )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_1","text":"1 2 3 inline Optional ( T & ref )","title":"function Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_2","text":"1 inline ~ Optional ()","title":"function ~Optional"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-map","text":"1 2 3 4 5 template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &>> inline Optional < U > map ( Fn && fn ) const","title":"function map"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-flat_map","text":"1 2 3 4 5 template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &>> inline OptionalU flat_map ( Fn && fn ) const","title":"function flat_map"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator","text":"1 inline T & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator_1","text":"1 inline bool operator ! () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator!"},{"location":"_autogen/Classes/classbatt_1_1Pin/","text":"batt::Pin \ud83d\udd17 More... Public Functions \ud83d\udd17 Name Pin () Pin (std::nullptr_t ) Pin (T * object) Pin (const Pin & other) Pin ( Pin && other) ~Pin () Pin & operator= (const Pin & other) Pin & operator= ( Pin && other) operator bool () const void swap ( Pin & other) void release () T * get () const T & operator* () const T * operator-> () const Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Pin ; Public Functions Documentation \ud83d\udd17 function Pin \ud83d\udd17 1 inline Pin () function Pin \ud83d\udd17 1 2 3 inline explicit Pin ( std :: nullptr_t ) function Pin \ud83d\udd17 1 2 3 inline explicit Pin ( T * object ) function Pin \ud83d\udd17 1 2 3 inline Pin ( const Pin & other ) function Pin \ud83d\udd17 1 2 3 inline Pin ( Pin && other ) function ~Pin \ud83d\udd17 1 inline ~ Pin () function operator= \ud83d\udd17 1 2 3 inline Pin & operator = ( const Pin & other ) function operator= \ud83d\udd17 1 2 3 inline Pin & operator = ( Pin && other ) function operator bool \ud83d\udd17 1 inline explicit operator bool () const function swap \ud83d\udd17 1 2 3 inline void swap ( Pin & other ) function release \ud83d\udd17 1 inline void release () function get \ud83d\udd17 1 inline T * get () const function operator* \ud83d\udd17 1 inline T & operator * () const function operator-> \ud83d\udd17 1 inline T * operator -> () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#public-functions","text":"Name Pin () Pin (std::nullptr_t ) Pin (T * object) Pin (const Pin & other) Pin ( Pin && other) ~Pin () Pin & operator= (const Pin & other) Pin & operator= ( Pin && other) operator bool () const void swap ( Pin & other) void release () T * get () const T & operator* () const T * operator-> () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Pin/#detailed-description","text":"1 2 template < typename T > class batt :: Pin ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Pin/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin","text":"1 inline Pin ()","title":"function Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_1","text":"1 2 3 inline explicit Pin ( std :: nullptr_t )","title":"function Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_2","text":"1 2 3 inline explicit Pin ( T * object )","title":"function Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_3","text":"1 2 3 inline Pin ( const Pin & other )","title":"function Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_4","text":"1 2 3 inline Pin ( Pin && other )","title":"function Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_5","text":"1 inline ~ Pin ()","title":"function ~Pin"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator","text":"1 2 3 inline Pin & operator = ( const Pin & other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator_1","text":"1 2 3 inline Pin & operator = ( Pin && other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-swap","text":"1 2 3 inline void swap ( Pin & other )","title":"function swap"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-release","text":"1 inline void release ()","title":"function release"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-get","text":"1 inline T * get () const","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator_2","text":"1 inline T & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator-","text":"1 inline T * operator -> () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/","text":"batt::Pinnable \ud83d\udd17 Inherited by batt::HttpMessageBase< T > , batt::HttpMessageBase< pico_http::Request > , batt::HttpMessageBase< pico_http::Response > Public Functions \ud83d\udd17 Name Pinnable () =default Pinnable (const Pinnable & ) =deleted Pinnable & operator= (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin () Public Functions Documentation \ud83d\udd17 function Pinnable \ud83d\udd17 1 Pinnable () = default function Pinnable \ud83d\udd17 1 2 3 Pinnable ( const Pinnable & ) = deleted function operator= \ud83d\udd17 1 2 3 Pinnable & operator = ( const Pinnable & ) = deleted function ~Pinnable \ud83d\udd17 1 inline ~ Pinnable () function pin \ud83d\udd17 1 inline void pin () function unpin \ud83d\udd17 1 inline void unpin () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Pinnable"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#public-functions","text":"Name Pinnable () =default Pinnable (const Pinnable & ) =deleted Pinnable & operator= (const Pinnable & ) =deleted ~Pinnable () void pin () void unpin ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pinnable","text":"1 Pinnable () = default","title":"function Pinnable"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pinnable_1","text":"1 2 3 Pinnable ( const Pinnable & ) = deleted","title":"function Pinnable"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-operator","text":"1 2 3 Pinnable & operator = ( const Pinnable & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pinnable_2","text":"1 inline ~ Pinnable ()","title":"function ~Pinnable"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pin","text":"1 inline void pin ()","title":"function pin"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-unpin","text":"1 inline void unpin () Updated on 26 August 2022 at 17:30:03 UTC","title":"function unpin"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/","text":"batt::PrependBufferSource \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::decay_t< decltype(boost::asio::buffer_sequence_begin(std::declval< ConstBufferSequence >()))> BufferIter Public Functions \ud83d\udd17 Name PrependBufferSource (ConstBufferSequence && buffers, Src && rest) usize size () const StatusOr < SmallVec< ConstBuffer, 3 > > fetch_at_least (i64 min_count_i) void consume (i64 count_i) void close_for_read () Detailed Description \ud83d\udd17 1 2 3 template < typename Src , typename ConstBufferSequence > class batt :: PrependBufferSource ; Public Types Documentation \ud83d\udd17 using BufferIter \ud83d\udd17 1 using batt :: PrependBufferSource < Src , ConstBufferSequence >:: BufferIter = std :: decay_t < decltype ( boost :: asio :: buffer_sequence_begin ( std :: declval < ConstBufferSequence > ())) > ; Public Functions Documentation \ud83d\udd17 function PrependBufferSource \ud83d\udd17 1 2 3 4 inline explicit PrependBufferSource ( ConstBufferSequence && buffers , Src && rest ) function size \ud83d\udd17 1 inline usize size () const function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 3 > > fetch_at_least ( i64 min_count_i ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count_i ) function close_for_read \ud83d\udd17 1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::PrependBufferSource"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-types","text":"Name using std::decay_t< decltype(boost::asio::buffer_sequence_begin(std::declval< ConstBufferSequence >()))> BufferIter","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-functions","text":"Name PrependBufferSource (ConstBufferSequence && buffers, Src && rest) usize size () const StatusOr < SmallVec< ConstBuffer, 3 > > fetch_at_least (i64 min_count_i) void consume (i64 count_i) void close_for_read ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#detailed-description","text":"1 2 3 template < typename Src , typename ConstBufferSequence > class batt :: PrependBufferSource ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#using-bufferiter","text":"1 using batt :: PrependBufferSource < Src , ConstBufferSequence >:: BufferIter = std :: decay_t < decltype ( boost :: asio :: buffer_sequence_begin ( std :: declval < ConstBufferSequence > ())) > ;","title":"using BufferIter"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-prependbuffersource","text":"1 2 3 4 inline explicit PrependBufferSource ( ConstBufferSequence && buffers , Src && rest )","title":"function PrependBufferSource"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 3 > > fetch_at_least ( i64 min_count_i )","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-consume","text":"1 2 3 inline void consume ( i64 count_i )","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-close_for_read","text":"1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1Promise/","text":"batt::Promise \ud83d\udd17 More... Public Functions \ud83d\udd17 Name Promise () void set_value (T && value) Friends \ud83d\udd17 Name Future < U > get_future (const Promise < U > & promise) Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Promise ; Public Functions Documentation \ud83d\udd17 function Promise \ud83d\udd17 1 inline Promise () function set_value \ud83d\udd17 1 2 3 inline void set_value ( T && value ) Friends \ud83d\udd17 friend get_future \ud83d\udd17 1 2 3 friend Future < U > get_future ( const Promise < U > & promise ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Promise"},{"location":"_autogen/Classes/classbatt_1_1Promise/#public-functions","text":"Name Promise () void set_value (T && value)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Promise/#friends","text":"Name Future < U > get_future (const Promise < U > & promise)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Promise/#detailed-description","text":"1 2 template < typename T > class batt :: Promise ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Promise/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-promise","text":"1 inline Promise ()","title":"function Promise"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-set_value","text":"1 2 3 inline void set_value ( T && value )","title":"function set_value"},{"location":"_autogen/Classes/classbatt_1_1Promise/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Promise/#friend-get_future","text":"1 2 3 friend Future < U > get_future ( const Promise < U > & promise ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend get_future"},{"location":"_autogen/Classes/classbatt_1_1Queue/","text":"batt::Queue \ud83d\udd17 More... Inherits from batt::QueueBase Public Functions \ud83d\udd17 Name template <typename... Args> bool push (Args &&... args) template <typename FactoryFn > bool push_with_lock (FactoryFn && factory_fn) template <typename Items > bool push_all (Items && items) StatusOr < T > await_next () Optional < T > try_pop_next () T pop_next_or_panic () usize drain () Additional inherited members \ud83d\udd17 Public Functions inherited from batt::QueueBase Name bool is_open () const bool is_closed () const i64 size () const bool empty () const template <typename Predicate =bool(i64)> StatusOr < i64 > await_size_is_truly (Predicate && predicate) StatusOr < i64 > await_empty () void close () Protected Functions inherited from batt::QueueBase Name Status await_one () bool try_acquire () void notify (i64 count) Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Queue ; Public Functions Documentation \ud83d\udd17 function push \ud83d\udd17 1 2 3 4 template < typename ... Args > inline bool push ( Args && ... args ) function push_with_lock \ud83d\udd17 1 2 3 4 template < typename FactoryFn > inline bool push_with_lock ( FactoryFn && factory_fn ) function push_all \ud83d\udd17 1 2 3 4 template < typename Items > inline bool push_all ( Items && items ) function await_next \ud83d\udd17 1 inline StatusOr < T > await_next () function try_pop_next \ud83d\udd17 1 inline Optional < T > try_pop_next () function pop_next_or_panic \ud83d\udd17 1 inline T pop_next_or_panic () function drain \ud83d\udd17 1 inline usize drain () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Queue"},{"location":"_autogen/Classes/classbatt_1_1Queue/#public-functions","text":"Name template <typename... Args> bool push (Args &&... args) template <typename FactoryFn > bool push_with_lock (FactoryFn && factory_fn) template <typename Items > bool push_all (Items && items) StatusOr < T > await_next () Optional < T > try_pop_next () T pop_next_or_panic () usize drain ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Queue/#additional-inherited-members","text":"Public Functions inherited from batt::QueueBase Name bool is_open () const bool is_closed () const i64 size () const bool empty () const template <typename Predicate =bool(i64)> StatusOr < i64 > await_size_is_truly (Predicate && predicate) StatusOr < i64 > await_empty () void close () Protected Functions inherited from batt::QueueBase Name Status await_one () bool try_acquire () void notify (i64 count)","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Queue/#detailed-description","text":"1 2 template < typename T > class batt :: Queue ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Queue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-push","text":"1 2 3 4 template < typename ... Args > inline bool push ( Args && ... args )","title":"function push"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-push_with_lock","text":"1 2 3 4 template < typename FactoryFn > inline bool push_with_lock ( FactoryFn && factory_fn )","title":"function push_with_lock"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-push_all","text":"1 2 3 4 template < typename Items > inline bool push_all ( Items && items )","title":"function push_all"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-await_next","text":"1 inline StatusOr < T > await_next ()","title":"function await_next"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-try_pop_next","text":"1 inline Optional < T > try_pop_next ()","title":"function try_pop_next"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-pop_next_or_panic","text":"1 inline T pop_next_or_panic ()","title":"function pop_next_or_panic"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-drain","text":"1 inline usize drain () Updated on 26 August 2022 at 17:30:03 UTC","title":"function drain"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/","text":"batt::QueueBase \ud83d\udd17 Inherited by batt::Queue< T > , batt::Queue< batt::Pin< batt::HttpResponse > > , batt::Queue< batt::SmallFn > , batt::Queue< std::tuple< batt::Pin< batt::HttpRequest >, batt::Pin< batt::HttpResponse > > > Public Functions \ud83d\udd17 Name bool is_open () const bool is_closed () const i64 size () const bool empty () const template <typename Predicate =bool(i64)> StatusOr < i64 > await_size_is_truly (Predicate && predicate) StatusOr < i64 > await_empty () void close () Protected Functions \ud83d\udd17 Name Status await_one () bool try_acquire () void notify (i64 count) Public Functions Documentation \ud83d\udd17 function is_open \ud83d\udd17 1 inline bool is_open () const function is_closed \ud83d\udd17 1 inline bool is_closed () const function size \ud83d\udd17 1 inline i64 size () const function empty \ud83d\udd17 1 inline bool empty () const function await_size_is_truly \ud83d\udd17 1 2 3 4 template < typename Predicate = bool ( i64 ) > inline StatusOr < i64 > await_size_is_truly ( Predicate && predicate ) function await_empty \ud83d\udd17 1 inline StatusOr < i64 > await_empty () function close \ud83d\udd17 1 inline void close () Protected Functions Documentation \ud83d\udd17 function await_one \ud83d\udd17 1 inline Status await_one () function try_acquire \ud83d\udd17 1 inline bool try_acquire () function notify \ud83d\udd17 1 2 3 inline void notify ( i64 count ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::QueueBase"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#public-functions","text":"Name bool is_open () const bool is_closed () const i64 size () const bool empty () const template <typename Predicate =bool(i64)> StatusOr < i64 > await_size_is_truly (Predicate && predicate) StatusOr < i64 > await_empty () void close ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#protected-functions","text":"Name Status await_one () bool try_acquire () void notify (i64 count)","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-is_open","text":"1 inline bool is_open () const","title":"function is_open"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-is_closed","text":"1 inline bool is_closed () const","title":"function is_closed"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-size","text":"1 inline i64 size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-empty","text":"1 inline bool empty () const","title":"function empty"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_size_is_truly","text":"1 2 3 4 template < typename Predicate = bool ( i64 ) > inline StatusOr < i64 > await_size_is_truly ( Predicate && predicate )","title":"function await_size_is_truly"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_empty","text":"1 inline StatusOr < i64 > await_empty ()","title":"function await_empty"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-close","text":"1 inline void close ()","title":"function close"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_one","text":"1 inline Status await_one ()","title":"function await_one"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-try_acquire","text":"1 inline bool try_acquire ()","title":"function try_acquire"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-notify","text":"1 2 3 inline void notify ( i64 count ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function notify"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/","text":"batt::QueueDepthExporter \ud83d\udd17 Inherits from batt::MetricExporter Public Functions \ud83d\udd17 Name QueueDepthExporter (const std::string & name, QueueBase & queue) virtual Token get_name () const override virtual double get_value () const override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default Public Functions Documentation \ud83d\udd17 function QueueDepthExporter \ud83d\udd17 1 2 3 4 inline explicit QueueDepthExporter ( const std :: string & name , QueueBase & queue ) function get_name \ud83d\udd17 1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name function get_value \ud83d\udd17 1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::QueueDepthExporter"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#public-functions","text":"Name QueueDepthExporter (const std::string & name, QueueBase & queue) virtual Token get_name () const override virtual double get_value () const override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#additional-inherited-members","text":"Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#function-queuedepthexporter","text":"1 2 3 4 inline explicit QueueDepthExporter ( const std :: string & name , QueueBase & queue )","title":"function QueueDepthExporter"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#function-get_name","text":"1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name","title":"function get_name"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#function-get_value","text":"1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/","text":"batt::RadixQueue \ud83d\udd17 More... Public Classes \ud83d\udd17 Name struct Hash struct Segment Public Types \ud83d\udd17 Name using std::conditional_t<(kCapacityInBits<=std::numeric_limits< u16 >::max()), std::conditional_t<(kCapacityInBits<=std::numeric_limits< u8 >::max()), u8, u16 >, std::conditional_t<(kCapacityInBits<=std::numeric_limits< u32 >::max()), u32, u64 > > index_type Public Functions \ud83d\udd17 Name bool operator== (const RadixQueue & other) const RadixQueue () =default bool empty () const bool full () const void clear () void push (u64 radix, u64 value) u64 pop (u64 radix) Public Attributes \ud83d\udd17 Name constexpr usize kQueueSize Friends \ud83d\udd17 Name std::ostream & operator<< (std::ostream & out, const RadixQueue < N_ > & t) Detailed Description \ud83d\udd17 1 2 template < usize kCapacityInBits > class batt :: RadixQueue ; Public Types Documentation \ud83d\udd17 using index_type \ud83d\udd17 1 using batt :: RadixQueue < kCapacityInBits >:: index_type = std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u16 >:: max ()), std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u8 >:: max ()), u8 , u16 > , std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u32 >:: max ()), u32 , u64 > > ; Public Functions Documentation \ud83d\udd17 function operator== \ud83d\udd17 1 2 3 inline bool operator == ( const RadixQueue & other ) const function RadixQueue \ud83d\udd17 1 RadixQueue () = default function empty \ud83d\udd17 1 inline bool empty () const function full \ud83d\udd17 1 inline bool full () const function clear \ud83d\udd17 1 inline void clear () function push \ud83d\udd17 1 2 3 4 inline void push ( u64 radix , u64 value ) function pop \ud83d\udd17 1 2 3 inline u64 pop ( u64 radix ) Public Attributes Documentation \ud83d\udd17 variable kQueueSize \ud83d\udd17 1 static constexpr usize kQueueSize = kCapacityInBits / 64 ; Friends \ud83d\udd17 friend operator<< \ud83d\udd17 1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ > & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RadixQueue"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-classes","text":"Name struct Hash struct Segment","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-types","text":"Name using std::conditional_t<(kCapacityInBits<=std::numeric_limits< u16 >::max()), std::conditional_t<(kCapacityInBits<=std::numeric_limits< u8 >::max()), u8, u16 >, std::conditional_t<(kCapacityInBits<=std::numeric_limits< u32 >::max()), u32, u64 > > index_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-functions","text":"Name bool operator== (const RadixQueue & other) const RadixQueue () =default bool empty () const bool full () const void clear () void push (u64 radix, u64 value) u64 pop (u64 radix)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-attributes","text":"Name constexpr usize kQueueSize","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#friends","text":"Name std::ostream & operator<< (std::ostream & out, const RadixQueue < N_ > & t)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#detailed-description","text":"1 2 template < usize kCapacityInBits > class batt :: RadixQueue ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#using-index_type","text":"1 using batt :: RadixQueue < kCapacityInBits >:: index_type = std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u16 >:: max ()), std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u8 >:: max ()), u8 , u16 > , std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u32 >:: max ()), u32 , u64 > > ;","title":"using index_type"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-operator","text":"1 2 3 inline bool operator == ( const RadixQueue & other ) const","title":"function operator=="},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-radixqueue","text":"1 RadixQueue () = default","title":"function RadixQueue"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-empty","text":"1 inline bool empty () const","title":"function empty"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-full","text":"1 inline bool full () const","title":"function full"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-clear","text":"1 inline void clear ()","title":"function clear"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-push","text":"1 2 3 4 inline void push ( u64 radix , u64 value )","title":"function push"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-pop","text":"1 2 3 inline u64 pop ( u64 radix )","title":"function pop"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#variable-kqueuesize","text":"1 static constexpr usize kQueueSize = kCapacityInBits / 64 ;","title":"variable kQueueSize"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#friend-operator","text":"1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ > & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend operator&lt;&lt;"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/","text":"batt::RangeDumper \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename Arg > RangeDumper (Arg && arg, Pretty pretty) Friends \ud83d\udd17 Name std::ostream & operator<< (std::ostream & out, const RangeDumper & t) Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: RangeDumper ; Public Functions Documentation \ud83d\udd17 function RangeDumper \ud83d\udd17 1 2 3 4 5 template < typename Arg > inline explicit RangeDumper ( Arg && arg , Pretty pretty ) Friends \ud83d\udd17 friend operator<< \ud83d\udd17 1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const RangeDumper & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RangeDumper"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#public-functions","text":"Name template <typename Arg > RangeDumper (Arg && arg, Pretty pretty)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#friends","text":"Name std::ostream & operator<< (std::ostream & out, const RangeDumper & t)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#detailed-description","text":"1 2 template < typename T > class batt :: RangeDumper ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#function-rangedumper","text":"1 2 3 4 5 template < typename Arg > inline explicit RangeDumper ( Arg && arg , Pretty pretty )","title":"function RangeDumper"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#friend-operator","text":"1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const RangeDumper & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend operator&lt;&lt;"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/","text":"batt::RateMetric \ud83d\udd17 More... Public Functions \ud83d\udd17 Name const auto & base_time () void update (T value) double get () const Detailed Description \ud83d\udd17 1 2 3 template < typename T , i64 kIntervalSeconds > class batt :: RateMetric ; Public Functions Documentation \ud83d\udd17 function base_time \ud83d\udd17 1 static inline const auto & base_time () function update \ud83d\udd17 1 2 3 inline void update ( T value ) function get \ud83d\udd17 1 inline double get () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RateMetric"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-functions","text":"Name const auto & base_time () void update (T value) double get () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#detailed-description","text":"1 2 3 template < typename T , i64 kIntervalSeconds > class batt :: RateMetric ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-base_time","text":"1 static inline const auto & base_time ()","title":"function base_time"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-update","text":"1 2 3 inline void update ( T value )","title":"function update"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-get","text":"1 inline double get () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1Ref/","text":"batt::Ref \ud83d\udd17 More... Public Types \ud83d\udd17 Name using typename std::conditional_t< batt::HasSeqRequirements< T >{}, batt::SeqItem_Impl < T >, batt::StaticType < void > >::type Item Public Functions \ud83d\udd17 Name template <typename U ,typename =std::enable_if_t >> Ref (U & obj_ref) Ref () template <typename U ,typename =std::enable_if_t >> Ref (const Ref < U > & that) template <typename U ,typename =std::enable_if_t >> Ref & operator= (const Ref < U > & that) bool is_valid () const T & get () const T * pointer () const operator T& () const template <typename... Args,typename =std::enable_if_t<!std::is_same_v , std::tuple\\ >>> decltype(auto) operator() (Args &&... args) const template <typename... Args> decltype(auto) poll (Args &&... args) const template <typename... Args> decltype(auto) poll (Args &&... args) template <typename... Args> decltype(auto) peek (Args &&... args) const template <typename... Args> decltype(auto) peek (Args &&... args) template <typename... Args> decltype(auto) next (Args &&... args) const template <typename... Args> decltype(auto) next (Args &&... args) template <typename... Args> decltype(auto) push_frame (Args &&... args) const template <typename... Args> decltype(auto) await_frame_consumed (Args &&... args) const template <typename... Args> decltype(auto) Update (Args &&... args) const template <typename... Args> decltype(auto) ok (Args &&... args) const template <typename... Args> decltype(auto) recycle_pages (Args &&... args) const template <typename... Args> decltype(auto) await_flush (Args &&... args) const Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Ref ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: Ref < T >:: Item = typename std :: conditional_t < batt :: HasSeqRequirements < T > {}, batt :: SeqItem_Impl < T > , batt :: StaticType < void > >:: type ; Public Functions Documentation \ud83d\udd17 function Ref \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> inline Ref ( U & obj_ref ) function Ref \ud83d\udd17 1 inline Ref () function Ref \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> inline Ref ( const Ref < U > & that ) function operator= \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> inline Ref & operator = ( const Ref < U > & that ) function is_valid \ud83d\udd17 1 inline bool is_valid () const function get \ud83d\udd17 1 inline T & get () const function pointer \ud83d\udd17 1 inline T * pointer () const function operator T& \ud83d\udd17 1 inline operator T & () const function operator() \ud83d\udd17 1 2 3 4 5 template < typename ... Args , typename = std :: enable_if_t <! std :: is_same_v < std :: tuple < std :: ostream &> , std :: tuple < Args ... >>>> inline decltype ( auto ) operator ()( Args && ... args ) const function poll \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) poll ( Args && ... args ) const function poll \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) poll ( Args && ... args ) function peek \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) peek ( Args && ... args ) const function peek \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) peek ( Args && ... args ) function next \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) next ( Args && ... args ) const function next \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) next ( Args && ... args ) function push_frame \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) push_frame ( Args && ... args ) const function await_frame_consumed \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) await_frame_consumed ( Args && ... args ) const function Update \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) Update ( Args && ... args ) const function ok \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) ok ( Args && ... args ) const function recycle_pages \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) recycle_pages ( Args && ... args ) const function await_flush \ud83d\udd17 1 2 3 4 template < typename ... Args > inline decltype ( auto ) await_flush ( Args && ... args ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Ref"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-types","text":"Name using typename std::conditional_t< batt::HasSeqRequirements< T >{}, batt::SeqItem_Impl < T >, batt::StaticType < void > >::type Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-functions","text":"Name template <typename U ,typename =std::enable_if_t >> Ref (U & obj_ref) Ref () template <typename U ,typename =std::enable_if_t >> Ref (const Ref < U > & that) template <typename U ,typename =std::enable_if_t >> Ref & operator= (const Ref < U > & that) bool is_valid () const T & get () const T * pointer () const operator T& () const template <typename... Args,typename =std::enable_if_t<!std::is_same_v , std::tuple\\ >>> decltype(auto) operator() (Args &&... args) const template <typename... Args> decltype(auto) poll (Args &&... args) const template <typename... Args> decltype(auto) poll (Args &&... args) template <typename... Args> decltype(auto) peek (Args &&... args) const template <typename... Args> decltype(auto) peek (Args &&... args) template <typename... Args> decltype(auto) next (Args &&... args) const template <typename... Args> decltype(auto) next (Args &&... args) template <typename... Args> decltype(auto) push_frame (Args &&... args) const template <typename... Args> decltype(auto) await_frame_consumed (Args &&... args) const template <typename... Args> decltype(auto) Update (Args &&... args) const template <typename... Args> decltype(auto) ok (Args &&... args) const template <typename... Args> decltype(auto) recycle_pages (Args &&... args) const template <typename... Args> decltype(auto) await_flush (Args &&... args) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Ref/#detailed-description","text":"1 2 template < typename T > class batt :: Ref ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1Ref/#using-item","text":"1 using batt :: Ref < T >:: Item = typename std :: conditional_t < batt :: HasSeqRequirements < T > {}, batt :: SeqItem_Impl < T > , batt :: StaticType < void > >:: type ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ref","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> inline Ref ( U & obj_ref )","title":"function Ref"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ref_1","text":"1 inline Ref ()","title":"function Ref"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ref_2","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> inline Ref ( const Ref < U > & that )","title":"function Ref"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-operator","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> inline Ref & operator = ( const Ref < U > & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-is_valid","text":"1 inline bool is_valid () const","title":"function is_valid"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-get","text":"1 inline T & get () const","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-pointer","text":"1 inline T * pointer () const","title":"function pointer"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-operator-t","text":"1 inline operator T & () const","title":"function operator T&amp;"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-operator_1","text":"1 2 3 4 5 template < typename ... Args , typename = std :: enable_if_t <! std :: is_same_v < std :: tuple < std :: ostream &> , std :: tuple < Args ... >>>> inline decltype ( auto ) operator ()( Args && ... args ) const","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-poll","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) poll ( Args && ... args ) const","title":"function poll"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-poll_1","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) poll ( Args && ... args )","title":"function poll"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-peek","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) peek ( Args && ... args ) const","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-peek_1","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) peek ( Args && ... args )","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-next","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) next ( Args && ... args ) const","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-next_1","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) next ( Args && ... args )","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-push_frame","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) push_frame ( Args && ... args ) const","title":"function push_frame"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-await_frame_consumed","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) await_frame_consumed ( Args && ... args ) const","title":"function await_frame_consumed"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-update","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) Update ( Args && ... args ) const","title":"function Update"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ok","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) ok ( Args && ... args ) const","title":"function ok"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-recycle_pages","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) recycle_pages ( Args && ... args ) const","title":"function recycle_pages"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-await_flush","text":"1 2 3 4 template < typename ... Args > inline decltype ( auto ) await_flush ( Args && ... args ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function await_flush"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/","text":"batt::RunningTotal \ud83d\udd17 Public Classes \ud83d\udd17 Name class Iterator Public Types \ud83d\udd17 Name using Iterator iterator using Iterator const_iterator using usize value_type using boost::iterator_range< Iterator > slice_type Public Functions \ud83d\udd17 Name RunningTotal () =default RunningTotal ( RunningTotal && ) =default RunningTotal ( PartsCount count, PartSize size) ~RunningTotal () =default RunningTotal & operator= ( RunningTotal && ) =default PartsCount parts_count () const PartSize part_size () const usize size () const bool empty () const usize front () const usize back () const iterator begin () const iterator end () const slice_type slice (usize begin_index, usize end_index) const slice_type slice ( Interval < usize > interval) const void reset ( PartsCount count, PartSize size) void set_size (usize new_size) Slice< const usize > const_part (usize i) const Slice< usize > mutable_part (usize i) Slice< const usize > const_summary () const Slice< usize > mutable_summary () usize operator[] (isize i) const Slice< const usize > raw_values () const std::function< void(std::ostream &)> dump () const void update_summary () Public Types Documentation \ud83d\udd17 using iterator \ud83d\udd17 1 using batt :: RunningTotal :: iterator = Iterator ; using const_iterator \ud83d\udd17 1 using batt :: RunningTotal :: const_iterator = Iterator ; using value_type \ud83d\udd17 1 using batt :: RunningTotal :: value_type = usize ; using slice_type \ud83d\udd17 1 using batt :: RunningTotal :: slice_type = boost :: iterator_range < Iterator > ; Public Functions Documentation \ud83d\udd17 function RunningTotal \ud83d\udd17 1 RunningTotal () = default function RunningTotal \ud83d\udd17 1 2 3 RunningTotal ( RunningTotal && ) = default function RunningTotal \ud83d\udd17 1 2 3 4 inline explicit RunningTotal ( PartsCount count , PartSize size ) function ~RunningTotal \ud83d\udd17 1 ~ RunningTotal () = default function operator= \ud83d\udd17 1 2 3 RunningTotal & operator = ( RunningTotal && ) = default function parts_count \ud83d\udd17 1 inline PartsCount parts_count () const function part_size \ud83d\udd17 1 inline PartSize part_size () const function size \ud83d\udd17 1 inline usize size () const function empty \ud83d\udd17 1 inline bool empty () const function front \ud83d\udd17 1 inline usize front () const function back \ud83d\udd17 1 inline usize back () const function begin \ud83d\udd17 1 inline iterator begin () const function end \ud83d\udd17 1 inline iterator end () const function slice \ud83d\udd17 1 2 3 4 inline slice_type slice ( usize begin_index , usize end_index ) const function slice \ud83d\udd17 1 2 3 inline slice_type slice ( Interval < usize > interval ) const function reset \ud83d\udd17 1 2 3 4 inline void reset ( PartsCount count , PartSize size ) function set_size \ud83d\udd17 1 2 3 inline void set_size ( usize new_size ) function const_part \ud83d\udd17 1 2 3 inline Slice < const usize > const_part ( usize i ) const function mutable_part \ud83d\udd17 1 2 3 inline Slice < usize > mutable_part ( usize i ) function const_summary \ud83d\udd17 1 inline Slice < const usize > const_summary () const function mutable_summary \ud83d\udd17 1 inline Slice < usize > mutable_summary () function operator[] \ud83d\udd17 1 2 3 inline usize operator []( isize i ) const function raw_values \ud83d\udd17 1 inline Slice < const usize > raw_values () const function dump \ud83d\udd17 1 inline std :: function < void ( std :: ostream & ) > dump () const function update_summary \ud83d\udd17 1 inline void update_summary () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RunningTotal"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#public-classes","text":"Name class Iterator","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#public-types","text":"Name using Iterator iterator using Iterator const_iterator using usize value_type using boost::iterator_range< Iterator > slice_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#public-functions","text":"Name RunningTotal () =default RunningTotal ( RunningTotal && ) =default RunningTotal ( PartsCount count, PartSize size) ~RunningTotal () =default RunningTotal & operator= ( RunningTotal && ) =default PartsCount parts_count () const PartSize part_size () const usize size () const bool empty () const usize front () const usize back () const iterator begin () const iterator end () const slice_type slice (usize begin_index, usize end_index) const slice_type slice ( Interval < usize > interval) const void reset ( PartsCount count, PartSize size) void set_size (usize new_size) Slice< const usize > const_part (usize i) const Slice< usize > mutable_part (usize i) Slice< const usize > const_summary () const Slice< usize > mutable_summary () usize operator[] (isize i) const Slice< const usize > raw_values () const std::function< void(std::ostream &)> dump () const void update_summary ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#using-iterator","text":"1 using batt :: RunningTotal :: iterator = Iterator ;","title":"using iterator"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#using-const_iterator","text":"1 using batt :: RunningTotal :: const_iterator = Iterator ;","title":"using const_iterator"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#using-value_type","text":"1 using batt :: RunningTotal :: value_type = usize ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#using-slice_type","text":"1 using batt :: RunningTotal :: slice_type = boost :: iterator_range < Iterator > ;","title":"using slice_type"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-runningtotal","text":"1 RunningTotal () = default","title":"function RunningTotal"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-runningtotal_1","text":"1 2 3 RunningTotal ( RunningTotal && ) = default","title":"function RunningTotal"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-runningtotal_2","text":"1 2 3 4 inline explicit RunningTotal ( PartsCount count , PartSize size )","title":"function RunningTotal"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-runningtotal_3","text":"1 ~ RunningTotal () = default","title":"function ~RunningTotal"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-operator","text":"1 2 3 RunningTotal & operator = ( RunningTotal && ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-parts_count","text":"1 inline PartsCount parts_count () const","title":"function parts_count"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-part_size","text":"1 inline PartSize part_size () const","title":"function part_size"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-empty","text":"1 inline bool empty () const","title":"function empty"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-front","text":"1 inline usize front () const","title":"function front"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-back","text":"1 inline usize back () const","title":"function back"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-begin","text":"1 inline iterator begin () const","title":"function begin"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-end","text":"1 inline iterator end () const","title":"function end"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-slice","text":"1 2 3 4 inline slice_type slice ( usize begin_index , usize end_index ) const","title":"function slice"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-slice_1","text":"1 2 3 inline slice_type slice ( Interval < usize > interval ) const","title":"function slice"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-reset","text":"1 2 3 4 inline void reset ( PartsCount count , PartSize size )","title":"function reset"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-set_size","text":"1 2 3 inline void set_size ( usize new_size )","title":"function set_size"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-const_part","text":"1 2 3 inline Slice < const usize > const_part ( usize i ) const","title":"function const_part"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-mutable_part","text":"1 2 3 inline Slice < usize > mutable_part ( usize i )","title":"function mutable_part"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-const_summary","text":"1 inline Slice < const usize > const_summary () const","title":"function const_summary"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-mutable_summary","text":"1 inline Slice < usize > mutable_summary ()","title":"function mutable_summary"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-operator_1","text":"1 2 3 inline usize operator []( isize i ) const","title":"function operator[]"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-raw_values","text":"1 inline Slice < const usize > raw_values () const","title":"function raw_values"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-dump","text":"1 inline std :: function < void ( std :: ostream & ) > dump () const","title":"function dump"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal/#function-update_summary","text":"1 inline void update_summary () Updated on 26 August 2022 at 17:30:03 UTC","title":"function update_summary"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/","text":"batt::RunningTotal::Iterator \ud83d\udd17 Inherits from boost::iterator_facade< Iterator, usize, std::random_access_iterator_tag, usize, isize > Public Types \ud83d\udd17 Name using Iterator Self using std::random_access_iterator_tag iterator_category using usize value_type using value_type reference Public Functions \ud83d\udd17 Name Iterator (const RunningTotal * container, usize position) reference dereference () const bool equal (const Self & other) const void increment () void decrement () void advance (isize delta) isize distance_to (const Self & other) const const RunningTotal * container () const isize position () const Public Types Documentation \ud83d\udd17 using Self \ud83d\udd17 1 using batt :: RunningTotal :: Iterator :: Self = Iterator ; using iterator_category \ud83d\udd17 1 using batt :: RunningTotal :: Iterator :: iterator_category = std :: random_access_iterator_tag ; using value_type \ud83d\udd17 1 using batt :: RunningTotal :: Iterator :: value_type = usize ; using reference \ud83d\udd17 1 using batt :: RunningTotal :: Iterator :: reference = value_type ; Public Functions Documentation \ud83d\udd17 function Iterator \ud83d\udd17 1 2 3 4 inline explicit Iterator ( const RunningTotal * container , usize position ) function dereference \ud83d\udd17 1 inline reference dereference () const function equal \ud83d\udd17 1 2 3 inline bool equal ( const Self & other ) const function increment \ud83d\udd17 1 inline void increment () function decrement \ud83d\udd17 1 inline void decrement () function advance \ud83d\udd17 1 2 3 inline void advance ( isize delta ) function distance_to \ud83d\udd17 1 2 3 inline isize distance_to ( const Self & other ) const function container \ud83d\udd17 1 inline const RunningTotal * container () const function position \ud83d\udd17 1 inline isize position () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RunningTotal::Iterator"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#public-types","text":"Name using Iterator Self using std::random_access_iterator_tag iterator_category using usize value_type using value_type reference","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#public-functions","text":"Name Iterator (const RunningTotal * container, usize position) reference dereference () const bool equal (const Self & other) const void increment () void decrement () void advance (isize delta) isize distance_to (const Self & other) const const RunningTotal * container () const isize position () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#using-self","text":"1 using batt :: RunningTotal :: Iterator :: Self = Iterator ;","title":"using Self"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#using-iterator_category","text":"1 using batt :: RunningTotal :: Iterator :: iterator_category = std :: random_access_iterator_tag ;","title":"using iterator_category"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#using-value_type","text":"1 using batt :: RunningTotal :: Iterator :: value_type = usize ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#using-reference","text":"1 using batt :: RunningTotal :: Iterator :: reference = value_type ;","title":"using reference"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-iterator","text":"1 2 3 4 inline explicit Iterator ( const RunningTotal * container , usize position )","title":"function Iterator"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-dereference","text":"1 inline reference dereference () const","title":"function dereference"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-equal","text":"1 2 3 inline bool equal ( const Self & other ) const","title":"function equal"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-increment","text":"1 inline void increment ()","title":"function increment"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-decrement","text":"1 inline void decrement ()","title":"function decrement"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-advance","text":"1 2 3 inline void advance ( isize delta )","title":"function advance"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-distance_to","text":"1 2 3 inline isize distance_to ( const Self & other ) const","title":"function distance_to"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-container","text":"1 inline const RunningTotal * container () const","title":"function container"},{"location":"_autogen/Classes/classbatt_1_1RunningTotal_1_1Iterator/#function-position","text":"1 inline isize position () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function position"},{"location":"_autogen/Classes/classbatt_1_1Runtime/","text":"batt::Runtime \ud83d\udd17 Public Classes \ud83d\udd17 Name class DefaultScheduler Public Functions \ud83d\udd17 Name Runtime & instance () Runtime () TaskScheduler & default_scheduler () boost::asio::any_io_executor schedule_task () TaskScheduler * exchange_task_scheduler ( TaskScheduler * new_scheduler) void halt () void join () template <typename... Ts> void notify (const Ts &... objs) const template <typename CheckCondition ,typename... Ts> auto await_condition (const CheckCondition & check_condition, const Ts &... objs) const Public Functions Documentation \ud83d\udd17 function instance \ud83d\udd17 1 static inline Runtime & instance () function Runtime \ud83d\udd17 1 inline explicit Runtime () function default_scheduler \ud83d\udd17 1 inline TaskScheduler & default_scheduler () function schedule_task \ud83d\udd17 1 inline boost :: asio :: any_io_executor schedule_task () function exchange_task_scheduler \ud83d\udd17 1 2 3 inline TaskScheduler * exchange_task_scheduler ( TaskScheduler * new_scheduler ) function halt \ud83d\udd17 1 inline void halt () function join \ud83d\udd17 1 inline void join () function notify \ud83d\udd17 1 2 3 4 template < typename ... Ts > inline void notify ( const Ts & ... objs ) const function await_condition \ud83d\udd17 1 2 3 4 5 6 template < typename CheckCondition , typename ... Ts > inline auto await_condition ( const CheckCondition & check_condition , const Ts & ... objs ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Runtime"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#public-classes","text":"Name class DefaultScheduler","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#public-functions","text":"Name Runtime & instance () Runtime () TaskScheduler & default_scheduler () boost::asio::any_io_executor schedule_task () TaskScheduler * exchange_task_scheduler ( TaskScheduler * new_scheduler) void halt () void join () template <typename... Ts> void notify (const Ts &... objs) const template <typename CheckCondition ,typename... Ts> auto await_condition (const CheckCondition & check_condition, const Ts &... objs) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-instance","text":"1 static inline Runtime & instance ()","title":"function instance"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-runtime","text":"1 inline explicit Runtime ()","title":"function Runtime"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-default_scheduler","text":"1 inline TaskScheduler & default_scheduler ()","title":"function default_scheduler"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-schedule_task","text":"1 inline boost :: asio :: any_io_executor schedule_task ()","title":"function schedule_task"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-exchange_task_scheduler","text":"1 2 3 inline TaskScheduler * exchange_task_scheduler ( TaskScheduler * new_scheduler )","title":"function exchange_task_scheduler"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-halt","text":"1 inline void halt ()","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-notify","text":"1 2 3 4 template < typename ... Ts > inline void notify ( const Ts & ... objs ) const","title":"function notify"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-await_condition","text":"1 2 3 4 5 6 template < typename CheckCondition , typename ... Ts > inline auto await_condition ( const CheckCondition & check_condition , const Ts & ... objs ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function await_condition"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/","text":"batt::Runtime::DefaultScheduler \ud83d\udd17 Inherits from batt::TaskScheduler Public Functions \ud83d\udd17 Name DefaultScheduler () ~DefaultScheduler () virtual boost::asio::any_io_executor schedule_task () override virtual void halt () override virtual void join () override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::TaskScheduler Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default Protected Functions inherited from batt::TaskScheduler Name TaskScheduler () =default Public Functions Documentation \ud83d\udd17 function DefaultScheduler \ud83d\udd17 1 inline explicit DefaultScheduler () function ~DefaultScheduler \ud83d\udd17 1 inline ~ DefaultScheduler () function schedule_task \ud83d\udd17 1 inline virtual boost :: asio :: any_io_executor schedule_task () override Reimplements : batt::TaskScheduler::schedule_task function halt \ud83d\udd17 1 inline virtual void halt () override Reimplements : batt::TaskScheduler::halt function join \ud83d\udd17 1 inline virtual void join () override Reimplements : batt::TaskScheduler::join Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Runtime::DefaultScheduler"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#public-functions","text":"Name DefaultScheduler () ~DefaultScheduler () virtual boost::asio::any_io_executor schedule_task () override virtual void halt () override virtual void join () override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#additional-inherited-members","text":"Public Functions inherited from batt::TaskScheduler Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default Protected Functions inherited from batt::TaskScheduler Name TaskScheduler () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-defaultscheduler","text":"1 inline explicit DefaultScheduler ()","title":"function DefaultScheduler"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-defaultscheduler_1","text":"1 inline ~ DefaultScheduler ()","title":"function ~DefaultScheduler"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-schedule_task","text":"1 inline virtual boost :: asio :: any_io_executor schedule_task () override Reimplements : batt::TaskScheduler::schedule_task","title":"function schedule_task"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-halt","text":"1 inline virtual void halt () override Reimplements : batt::TaskScheduler::halt","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-join","text":"1 inline virtual void join () override Reimplements : batt::TaskScheduler::join Updated on 26 August 2022 at 17:30:03 UTC","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/","text":"batt::ScopedWorkContext \ud83d\udd17 Inherits from batt::WorkContext Public Functions \ud83d\udd17 Name void cancel () ~ScopedWorkContext () WorkContext (const WorkContext & ) =deleted WorkContext ( WorkerPool & worker_pool) Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WorkContext Name WorkContext & operator= (const WorkContext & ) =deleted template <typename Fn > decltype(auto) async_run (Fn && work_fn) void on_work_started () void on_work_finished () void await_done () Public Functions Documentation \ud83d\udd17 function cancel \ud83d\udd17 1 inline void cancel () function ~ScopedWorkContext \ud83d\udd17 1 inline ~ ScopedWorkContext () function WorkContext \ud83d\udd17 1 2 3 WorkContext ( const WorkContext & ) = deleted function WorkContext \ud83d\udd17 1 2 3 inline explicit WorkContext ( WorkerPool & worker_pool ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::ScopedWorkContext"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#public-functions","text":"Name void cancel () ~ScopedWorkContext () WorkContext (const WorkContext & ) =deleted WorkContext ( WorkerPool & worker_pool)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#additional-inherited-members","text":"Public Functions inherited from batt::WorkContext Name WorkContext & operator= (const WorkContext & ) =deleted template <typename Fn > decltype(auto) async_run (Fn && work_fn) void on_work_started () void on_work_finished () void await_done ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-cancel","text":"1 inline void cancel ()","title":"function cancel"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-scopedworkcontext","text":"1 inline ~ ScopedWorkContext ()","title":"function ~ScopedWorkContext"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-workcontext","text":"1 2 3 WorkContext ( const WorkContext & ) = deleted","title":"function WorkContext"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-workcontext_1","text":"1 2 3 inline explicit WorkContext ( WorkerPool & worker_pool ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function WorkContext"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/","text":"batt::SeqBufferSource \ud83d\udd17 More... Public Types \ud83d\udd17 Name using ConstBuffer Item Public Functions \ud83d\udd17 Name StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) Detailed Description \ud83d\udd17 1 2 template < typename Seq > class batt :: SeqBufferSource ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: SeqBufferSource < Seq >:: Item = ConstBuffer ; Public Functions Documentation \ud83d\udd17 function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SeqBufferSource"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-types","text":"Name using ConstBuffer Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-functions","text":"Name StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#detailed-description","text":"1 2 template < typename Seq > class batt :: SeqBufferSource ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#using-item","text":"1 using batt :: SeqBufferSource < Seq >:: Item = ConstBuffer ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count )","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#function-consume","text":"1 2 3 inline void consume ( i64 count ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1SkipN/","text":"batt::SkipN \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name SkipN (Seq && seq, usize n) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename Seq > class batt :: SkipN ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: SkipN < Seq >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function SkipN \ud83d\udd17 1 2 3 4 inline explicit SkipN ( Seq && seq , usize n ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SkipN"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-functions","text":"Name SkipN (Seq && seq, usize n) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#detailed-description","text":"1 2 template < typename Seq > class batt :: SkipN ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#using-item","text":"1 using batt :: SkipN < Seq >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#function-skipn","text":"1 2 3 4 inline explicit SkipN ( Seq && seq , usize n )","title":"function SkipN"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1SmallFn/","text":"batt::SmallFn \ud83d\udd17 A type-erased container for a callable function-like object with a statically bounded maximum size. More... #include <batteries/small_fn.hpp> Detailed Description \ud83d\udd17 1 2 3 4 template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ), bool kMoveOnly = false > class batt :: SmallFn ; A type-erased container for a callable function-like object with a statically bounded maximum size. By default, the static buffer allocated internal to SmallFn is sized such that sizeof(SmallFn) is equal to a single CPU cache line. This class can be used to type-erase both regular copyable types and move-only callable types. UniqueSmallFn can be used to type-erase move-only callable types. Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SmallFn"},{"location":"_autogen/Classes/classbatt_1_1SmallFn/#detailed-description","text":"1 2 3 4 template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ), bool kMoveOnly = false > class batt :: SmallFn ; A type-erased container for a callable function-like object with a statically bounded maximum size. By default, the static buffer allocated internal to SmallFn is sized such that sizeof(SmallFn) is equal to a single CPU cache line. This class can be used to type-erase both regular copyable types and move-only callable types. UniqueSmallFn can be used to type-erase move-only callable types. Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/","text":"batt::StackAllocator \ud83d\udd17 Public Functions \ud83d\udd17 Name StackAllocator () StackAllocator (const StackAllocator & ) =default StackAllocator & operator= (const StackAllocator & ) =default template <typename T ,typename =EnableIfNoShadow > StackAllocator (T && obj) template <typename T ,typename =EnableIfNoShadow > StackAllocator & operator= (T && obj) boost::context::stack_context allocate () const void deallocate (boost::context::stack_context & ctx) const Public Functions Documentation \ud83d\udd17 function StackAllocator \ud83d\udd17 1 inline StackAllocator () function StackAllocator \ud83d\udd17 1 2 3 StackAllocator ( const StackAllocator & ) = default function operator= \ud83d\udd17 1 2 3 StackAllocator & operator = ( const StackAllocator & ) = default function StackAllocator \ud83d\udd17 1 2 3 4 5 template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> inline StackAllocator ( T && obj ) function operator= \ud83d\udd17 1 2 3 4 5 template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> inline StackAllocator & operator = ( T && obj ) function allocate \ud83d\udd17 1 inline boost :: context :: stack_context allocate () const function deallocate \ud83d\udd17 1 2 3 inline void deallocate ( boost :: context :: stack_context & ctx ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StackAllocator"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#public-functions","text":"Name StackAllocator () StackAllocator (const StackAllocator & ) =default StackAllocator & operator= (const StackAllocator & ) =default template <typename T ,typename =EnableIfNoShadow > StackAllocator (T && obj) template <typename T ,typename =EnableIfNoShadow > StackAllocator & operator= (T && obj) boost::context::stack_context allocate () const void deallocate (boost::context::stack_context & ctx) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-stackallocator","text":"1 inline StackAllocator ()","title":"function StackAllocator"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-stackallocator_1","text":"1 2 3 StackAllocator ( const StackAllocator & ) = default","title":"function StackAllocator"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-operator","text":"1 2 3 StackAllocator & operator = ( const StackAllocator & ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-stackallocator_2","text":"1 2 3 4 5 template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> inline StackAllocator ( T && obj )","title":"function StackAllocator"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-operator_1","text":"1 2 3 4 5 template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> inline StackAllocator & operator = ( T && obj )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-allocate","text":"1 inline boost :: context :: stack_context allocate () const","title":"function allocate"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-deallocate","text":"1 2 3 inline void deallocate ( boost :: context :: stack_context & ctx ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function deallocate"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/","text":"batt::StackAllocatorImpl \ud83d\udd17 More... Inherits from batt::AbstractStackAllocator , boost::intrusive_ref_counter< AbstractStackAllocator > Public Functions \ud83d\udd17 Name template <typename... Args,typename =EnableIfNoShadow > StackAllocatorImpl (Args &&... args) virtual boost::context::stack_context allocate () override virtual void deallocate (boost::context::stack_context & ctx) override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::AbstractStackAllocator Name AbstractStackAllocator (const AbstractStackAllocator & ) =deleted AbstractStackAllocator & operator= (const AbstractStackAllocator & ) =deleted virtual ~AbstractStackAllocator () =default Protected Functions inherited from batt::AbstractStackAllocator Name AbstractStackAllocator () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: StackAllocatorImpl ; Public Functions Documentation \ud83d\udd17 function StackAllocatorImpl \ud83d\udd17 1 2 3 4 5 template < typename ... Args , typename = EnableIfNoShadow < StackAllocatorImpl , Args && ... >> inline explicit StackAllocatorImpl ( Args && ... args ) function allocate \ud83d\udd17 1 inline virtual boost :: context :: stack_context allocate () override Reimplements : batt::AbstractStackAllocator::allocate function deallocate \ud83d\udd17 1 2 3 inline virtual void deallocate ( boost :: context :: stack_context & ctx ) override Reimplements : batt::AbstractStackAllocator::deallocate Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StackAllocatorImpl"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#public-functions","text":"Name template <typename... Args,typename =EnableIfNoShadow > StackAllocatorImpl (Args &&... args) virtual boost::context::stack_context allocate () override virtual void deallocate (boost::context::stack_context & ctx) override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#additional-inherited-members","text":"Public Functions inherited from batt::AbstractStackAllocator Name AbstractStackAllocator (const AbstractStackAllocator & ) =deleted AbstractStackAllocator & operator= (const AbstractStackAllocator & ) =deleted virtual ~AbstractStackAllocator () =default Protected Functions inherited from batt::AbstractStackAllocator Name AbstractStackAllocator () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#detailed-description","text":"1 2 template < typename T > class batt :: StackAllocatorImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#function-stackallocatorimpl","text":"1 2 3 4 5 template < typename ... Args , typename = EnableIfNoShadow < StackAllocatorImpl , Args && ... >> inline explicit StackAllocatorImpl ( Args && ... args )","title":"function StackAllocatorImpl"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#function-allocate","text":"1 inline virtual boost :: context :: stack_context allocate () override Reimplements : batt::AbstractStackAllocator::allocate","title":"function allocate"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#function-deallocate","text":"1 2 3 inline virtual void deallocate ( boost :: context :: stack_context & ctx ) override Reimplements : batt::AbstractStackAllocator::deallocate Updated on 26 August 2022 at 17:30:03 UTC","title":"function deallocate"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/","text":"batt::StateMachineModel \ud83d\udd17 More... Public Types \ud83d\udd17 Name enum VisitResult { kFirstTime, kSeenBefore} using StateT state_type using StateHash state_hash_type using StateEqual state_equal_type using StateMachineModel Base using StateMachineBranch < StateT, StateHash, StateEqual > Branch using StateMachineResult Result using StateMachineModelCheckAdvancedOptions AdvancedOptions Public Functions \ud83d\udd17 Name StateMachineModel (const StateMachineModel & ) =deleted StateMachineModel & operator= (const StateMachineModel & ) =deleted virtual ~StateMachineModel () =default StateMachineModel () =default template <typename Checker =ExhaustiveModelChecker > Result check_model ( StaticType < Checker > ={}) bool state_visited (const state_type & s) const void set_entropy ( StateMachineEntropySource && entropy_source) void reset_visited_states () VisitResult visit (const StateT & state, const Branch & src_branch) virtual state_type initialize () =0 virtual void enter_state (const state_type & ) =0 virtual void step () =0 virtual state_type leave_state () =0 virtual bool check_invariants () =0 virtual bool check_stepwise_invariants () virtual state_type normalize (const state_type & s) virtual double progress_report_interval_seconds () const virtual void report_progress (const Result & ) virtual usize max_concurrency () const virtual std::unique_ptr< StateMachineModel > clone () const virtual AdvancedOptions advanced_options () const usize pick_int (usize min_value, usize max_value) bool pick_branch () template <typename T > T pick_one_of (std::initializer_list< T > values) bool run_one ( FakeExecutionContext & context) template <typename... Fn> void do_one_of (Fn &&... actions) StateMachineEntropySource entropy () template <typename Checker > auto check_model ( StaticType < Checker > ) Public Attributes \ud83d\udd17 Name std::shared_ptr< std::ostringstream > debug_out Detailed Description \ud83d\udd17 1 2 3 4 template < typename StateT , typename StateHash = std :: hash < StateT > , typename StateEqual = std :: equal_to < StateT >> class batt :: StateMachineModel ; Public Types Documentation \ud83d\udd17 enum VisitResult \ud83d\udd17 Enumerator Value Description kFirstTime kSeenBefore using state_type \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: state_type = StateT ; using state_hash_type \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: state_hash_type = StateHash ; using state_equal_type \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: state_equal_type = StateEqual ; using Base \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: Base = StateMachineModel ; using Branch \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: Branch = StateMachineBranch < StateT , StateHash , StateEqual > ; using Result \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: Result = StateMachineResult ; using AdvancedOptions \ud83d\udd17 1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: AdvancedOptions = StateMachineModelCheckAdvancedOptions ; Public Functions Documentation \ud83d\udd17 function StateMachineModel \ud83d\udd17 1 2 3 StateMachineModel ( const StateMachineModel & ) = deleted function operator= \ud83d\udd17 1 2 3 StateMachineModel & operator = ( const StateMachineModel & ) = deleted function ~StateMachineModel \ud83d\udd17 1 virtual ~ StateMachineModel () = default function StateMachineModel \ud83d\udd17 1 StateMachineModel () = default function check_model \ud83d\udd17 1 2 3 4 template < typename Checker = ExhaustiveModelChecker < StateMachineModel >> Result check_model ( StaticType < Checker > = {} ) function state_visited \ud83d\udd17 1 2 3 inline bool state_visited ( const state_type & s ) const function set_entropy \ud83d\udd17 1 2 3 inline void set_entropy ( StateMachineEntropySource && entropy_source ) function reset_visited_states \ud83d\udd17 1 inline void reset_visited_states () function visit \ud83d\udd17 1 2 3 4 inline VisitResult visit ( const StateT & state , const Branch & src_branch ) function initialize \ud83d\udd17 1 virtual state_type initialize () = 0 function enter_state \ud83d\udd17 1 2 3 virtual void enter_state ( const state_type & ) = 0 function step \ud83d\udd17 1 virtual void step () = 0 function leave_state \ud83d\udd17 1 virtual state_type leave_state () = 0 function check_invariants \ud83d\udd17 1 virtual bool check_invariants () = 0 function check_stepwise_invariants \ud83d\udd17 1 inline virtual bool check_stepwise_invariants () function normalize \ud83d\udd17 1 2 3 inline virtual state_type normalize ( const state_type & s ) function progress_report_interval_seconds \ud83d\udd17 1 inline virtual double progress_report_interval_seconds () const function report_progress \ud83d\udd17 1 2 3 inline virtual void report_progress ( const Result & ) function max_concurrency \ud83d\udd17 1 inline virtual usize max_concurrency () const function clone \ud83d\udd17 1 inline virtual std :: unique_ptr < StateMachineModel > clone () const function advanced_options \ud83d\udd17 1 inline virtual AdvancedOptions advanced_options () const function pick_int \ud83d\udd17 1 2 3 4 inline usize pick_int ( usize min_value , usize max_value ) function pick_branch \ud83d\udd17 1 inline bool pick_branch () function pick_one_of \ud83d\udd17 1 2 3 4 template < typename T > inline T pick_one_of ( std :: initializer_list < T > values ) function run_one \ud83d\udd17 1 2 3 inline bool run_one ( FakeExecutionContext & context ) function do_one_of \ud83d\udd17 1 2 3 4 template < typename ... Fn > inline void do_one_of ( Fn && ... actions ) function entropy \ud83d\udd17 1 inline StateMachineEntropySource entropy () function check_model \ud83d\udd17 1 2 3 4 template < typename Checker > auto check_model ( StaticType < Checker > ) Public Attributes Documentation \ud83d\udd17 variable debug_out \ud83d\udd17 1 std :: shared_ptr < std :: ostringstream > debug_out = std :: make_shared < std :: ostringstream > (); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StateMachineModel"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-types","text":"Name enum VisitResult { kFirstTime, kSeenBefore} using StateT state_type using StateHash state_hash_type using StateEqual state_equal_type using StateMachineModel Base using StateMachineBranch < StateT, StateHash, StateEqual > Branch using StateMachineResult Result using StateMachineModelCheckAdvancedOptions AdvancedOptions","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-functions","text":"Name StateMachineModel (const StateMachineModel & ) =deleted StateMachineModel & operator= (const StateMachineModel & ) =deleted virtual ~StateMachineModel () =default StateMachineModel () =default template <typename Checker =ExhaustiveModelChecker > Result check_model ( StaticType < Checker > ={}) bool state_visited (const state_type & s) const void set_entropy ( StateMachineEntropySource && entropy_source) void reset_visited_states () VisitResult visit (const StateT & state, const Branch & src_branch) virtual state_type initialize () =0 virtual void enter_state (const state_type & ) =0 virtual void step () =0 virtual state_type leave_state () =0 virtual bool check_invariants () =0 virtual bool check_stepwise_invariants () virtual state_type normalize (const state_type & s) virtual double progress_report_interval_seconds () const virtual void report_progress (const Result & ) virtual usize max_concurrency () const virtual std::unique_ptr< StateMachineModel > clone () const virtual AdvancedOptions advanced_options () const usize pick_int (usize min_value, usize max_value) bool pick_branch () template <typename T > T pick_one_of (std::initializer_list< T > values) bool run_one ( FakeExecutionContext & context) template <typename... Fn> void do_one_of (Fn &&... actions) StateMachineEntropySource entropy () template <typename Checker > auto check_model ( StaticType < Checker > )","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-attributes","text":"Name std::shared_ptr< std::ostringstream > debug_out","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#detailed-description","text":"1 2 3 4 template < typename StateT , typename StateHash = std :: hash < StateT > , typename StateEqual = std :: equal_to < StateT >> class batt :: StateMachineModel ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#enum-visitresult","text":"Enumerator Value Description kFirstTime kSeenBefore","title":"enum VisitResult"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-state_type","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: state_type = StateT ;","title":"using state_type"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-state_hash_type","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: state_hash_type = StateHash ;","title":"using state_hash_type"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-state_equal_type","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: state_equal_type = StateEqual ;","title":"using state_equal_type"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-base","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: Base = StateMachineModel ;","title":"using Base"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-branch","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: Branch = StateMachineBranch < StateT , StateHash , StateEqual > ;","title":"using Branch"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-result","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: Result = StateMachineResult ;","title":"using Result"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-advancedoptions","text":"1 using batt :: StateMachineModel < StateT , StateHash , StateEqual >:: AdvancedOptions = StateMachineModelCheckAdvancedOptions ;","title":"using AdvancedOptions"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-statemachinemodel","text":"1 2 3 StateMachineModel ( const StateMachineModel & ) = deleted","title":"function StateMachineModel"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-operator","text":"1 2 3 StateMachineModel & operator = ( const StateMachineModel & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-statemachinemodel_1","text":"1 virtual ~ StateMachineModel () = default","title":"function ~StateMachineModel"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-statemachinemodel_2","text":"1 StateMachineModel () = default","title":"function StateMachineModel"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_model","text":"1 2 3 4 template < typename Checker = ExhaustiveModelChecker < StateMachineModel >> Result check_model ( StaticType < Checker > = {} )","title":"function check_model"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-state_visited","text":"1 2 3 inline bool state_visited ( const state_type & s ) const","title":"function state_visited"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-set_entropy","text":"1 2 3 inline void set_entropy ( StateMachineEntropySource && entropy_source )","title":"function set_entropy"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-reset_visited_states","text":"1 inline void reset_visited_states ()","title":"function reset_visited_states"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-visit","text":"1 2 3 4 inline VisitResult visit ( const StateT & state , const Branch & src_branch )","title":"function visit"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-initialize","text":"1 virtual state_type initialize () = 0","title":"function initialize"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-enter_state","text":"1 2 3 virtual void enter_state ( const state_type & ) = 0","title":"function enter_state"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-step","text":"1 virtual void step () = 0","title":"function step"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-leave_state","text":"1 virtual state_type leave_state () = 0","title":"function leave_state"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_invariants","text":"1 virtual bool check_invariants () = 0","title":"function check_invariants"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_stepwise_invariants","text":"1 inline virtual bool check_stepwise_invariants ()","title":"function check_stepwise_invariants"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-normalize","text":"1 2 3 inline virtual state_type normalize ( const state_type & s )","title":"function normalize"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-progress_report_interval_seconds","text":"1 inline virtual double progress_report_interval_seconds () const","title":"function progress_report_interval_seconds"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-report_progress","text":"1 2 3 inline virtual void report_progress ( const Result & )","title":"function report_progress"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-max_concurrency","text":"1 inline virtual usize max_concurrency () const","title":"function max_concurrency"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-clone","text":"1 inline virtual std :: unique_ptr < StateMachineModel > clone () const","title":"function clone"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-advanced_options","text":"1 inline virtual AdvancedOptions advanced_options () const","title":"function advanced_options"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-pick_int","text":"1 2 3 4 inline usize pick_int ( usize min_value , usize max_value )","title":"function pick_int"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-pick_branch","text":"1 inline bool pick_branch ()","title":"function pick_branch"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-pick_one_of","text":"1 2 3 4 template < typename T > inline T pick_one_of ( std :: initializer_list < T > values )","title":"function pick_one_of"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-run_one","text":"1 2 3 inline bool run_one ( FakeExecutionContext & context )","title":"function run_one"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-do_one_of","text":"1 2 3 4 template < typename ... Fn > inline void do_one_of ( Fn && ... actions )","title":"function do_one_of"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-entropy","text":"1 inline StateMachineEntropySource entropy ()","title":"function entropy"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_model_1","text":"1 2 3 4 template < typename Checker > auto check_model ( StaticType < Checker > )","title":"function check_model"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#variable-debug_out","text":"1 std :: shared_ptr < std :: ostringstream > debug_out = std :: make_shared < std :: ostringstream > (); Updated on 26 August 2022 at 17:30:03 UTC","title":"variable debug_out"},{"location":"_autogen/Classes/classbatt_1_1Status/","text":"batt::Status \ud83d\udd17 Inherits from batt::detail::StatusBase Inherited by batt::StatusOr< Status > Public Classes \ud83d\udd17 Name struct CodeEntry struct CodeGroup Public Types \ud83d\udd17 Name using i32 value_type Public Functions \ud83d\udd17 Name template <typename EnumT > const CodeGroup & code_group_for_type () const std::string & unknown_enum_value_message () template <typename EnumT > bool register_codes (const std::vector< std::pair< EnumT, std::string >> & codes) std::string_view message_from_code (value_type value) Status () Status (const Status & ) =default Status & operator= (const Status & ) =default template <typename EnumT ,typename =std::enable_if_t >> Status (EnumT enum_value) bool ok () const value_type code () const std::string_view message () const const CodeGroup & group () const void IgnoreError () const void Update (const Status & new_status) Public Attributes \ud83d\udd17 Name constexpr i32 kGroupSizeBits constexpr i32 kGroupSize constexpr i32 kMaxGroups Friends \ud83d\udd17 Name class detail::StatusBase Additional inherited members \ud83d\udd17 Public Functions inherited from batt::detail::StatusBase Name StatusBase () Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: Status :: value_type = i32 ; Public Functions Documentation \ud83d\udd17 function code_group_for_type \ud83d\udd17 1 2 template < typename EnumT > static inline const CodeGroup & code_group_for_type () function unknown_enum_value_message \ud83d\udd17 1 static inline const std :: string & unknown_enum_value_message () function register_codes \ud83d\udd17 1 2 3 4 template < typename EnumT > static inline bool register_codes ( const std :: vector < std :: pair < EnumT , std :: string >> & codes ) function message_from_code \ud83d\udd17 1 2 3 static inline std :: string_view message_from_code ( value_type value ) function Status \ud83d\udd17 1 inline Status () function Status \ud83d\udd17 1 2 3 Status ( const Status & ) = default function operator= \ud83d\udd17 1 2 3 Status & operator = ( const Status & ) = default function Status \ud83d\udd17 1 2 3 4 5 template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> inline Status ( EnumT enum_value ) function ok \ud83d\udd17 1 inline bool ok () const function code \ud83d\udd17 1 inline value_type code () const function message \ud83d\udd17 1 inline std :: string_view message () const function group \ud83d\udd17 1 inline const CodeGroup & group () const function IgnoreError \ud83d\udd17 1 inline void IgnoreError () const function Update \ud83d\udd17 1 2 3 inline void Update ( const Status & new_status ) Public Attributes Documentation \ud83d\udd17 variable kGroupSizeBits \ud83d\udd17 1 static constexpr i32 kGroupSizeBits = 12 ; variable kGroupSize \ud83d\udd17 1 static constexpr i32 kGroupSize = i32 { 1 } << kGroupSizeBits ; variable kMaxGroups \ud83d\udd17 1 static constexpr i32 kMaxGroups = 0x7fffff00l - kGroupSize ; Friends \ud83d\udd17 friend detail::StatusBase \ud83d\udd17 1 friend class detail :: StatusBase ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Status"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-classes","text":"Name struct CodeEntry struct CodeGroup","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-types","text":"Name using i32 value_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-functions","text":"Name template <typename EnumT > const CodeGroup & code_group_for_type () const std::string & unknown_enum_value_message () template <typename EnumT > bool register_codes (const std::vector< std::pair< EnumT, std::string >> & codes) std::string_view message_from_code (value_type value) Status () Status (const Status & ) =default Status & operator= (const Status & ) =default template <typename EnumT ,typename =std::enable_if_t >> Status (EnumT enum_value) bool ok () const value_type code () const std::string_view message () const const CodeGroup & group () const void IgnoreError () const void Update (const Status & new_status)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-attributes","text":"Name constexpr i32 kGroupSizeBits constexpr i32 kGroupSize constexpr i32 kMaxGroups","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1Status/#friends","text":"Name class detail::StatusBase","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Status/#additional-inherited-members","text":"Public Functions inherited from batt::detail::StatusBase Name StatusBase ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1Status/#using-value_type","text":"1 using batt :: Status :: value_type = i32 ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-code_group_for_type","text":"1 2 template < typename EnumT > static inline const CodeGroup & code_group_for_type ()","title":"function code_group_for_type"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-unknown_enum_value_message","text":"1 static inline const std :: string & unknown_enum_value_message ()","title":"function unknown_enum_value_message"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-register_codes","text":"1 2 3 4 template < typename EnumT > static inline bool register_codes ( const std :: vector < std :: pair < EnumT , std :: string >> & codes )","title":"function register_codes"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-message_from_code","text":"1 2 3 static inline std :: string_view message_from_code ( value_type value )","title":"function message_from_code"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status","text":"1 inline Status ()","title":"function Status"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_1","text":"1 2 3 Status ( const Status & ) = default","title":"function Status"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-operator","text":"1 2 3 Status & operator = ( const Status & ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_2","text":"1 2 3 4 5 template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> inline Status ( EnumT enum_value )","title":"function Status"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-ok","text":"1 inline bool ok () const","title":"function ok"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-code","text":"1 inline value_type code () const","title":"function code"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-message","text":"1 inline std :: string_view message () const","title":"function message"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-group","text":"1 inline const CodeGroup & group () const","title":"function group"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-ignoreerror","text":"1 inline void IgnoreError () const","title":"function IgnoreError"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-update","text":"1 2 3 inline void Update ( const Status & new_status )","title":"function Update"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1Status/#variable-kgroupsizebits","text":"1 static constexpr i32 kGroupSizeBits = 12 ;","title":"variable kGroupSizeBits"},{"location":"_autogen/Classes/classbatt_1_1Status/#variable-kgroupsize","text":"1 static constexpr i32 kGroupSize = i32 { 1 } << kGroupSizeBits ;","title":"variable kGroupSize"},{"location":"_autogen/Classes/classbatt_1_1Status/#variable-kmaxgroups","text":"1 static constexpr i32 kMaxGroups = 0x7fffff00l - kGroupSize ;","title":"variable kMaxGroups"},{"location":"_autogen/Classes/classbatt_1_1Status/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Status/#friend-detailstatusbase","text":"1 friend class detail :: StatusBase ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend detail::StatusBase"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/","text":"batt::StatusOr \ud83d\udd17 More... Inherited by batt::StatusOr< StatusOr< T > > Public Types \ud83d\udd17 Name using T value_type Public Functions \ud83d\udd17 Name StatusOr () StatusOr (const Status & s) StatusOr ( StatusOr && that) StatusOr (const StatusOr & that) StatusOr (const std::decay_t< T > & obj) StatusOr (std::decay_t< T > & obj) StatusOr (std::decay_t< T > && obj) template <typename U ,typename =EnableIfNoShadow ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >,typename =void> StatusOr (U && obj) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr ( StatusOr < U > && that) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr (const StatusOr < U > & that) ~StatusOr () StatusOr & operator= (std::decay_t< T > && obj) StatusOr & operator= (const T & obj) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr & operator= (U && obj) StatusOr & operator= (const StatusOr & that) StatusOr & operator= ( StatusOr && that) StatusOr & operator= (const Status & new_status) template <typename... Args> void emplace (Args &&... args) template <typename U > void emplace ( StatusOr < U > && that) template <typename U > void emplace (const StatusOr < U > & that) void IgnoreError () const bool ok () const const Status & status () const T & value () const T & value () const T & operator* () const T & operator* () const T operator* () const std::decay_t< T > * operator-> () const std::decay_t< T > * operator-> () Friends \ud83d\udd17 Name class StatusOr Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: StatusOr ; Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: StatusOr < T >:: value_type = T ; Public Functions Documentation \ud83d\udd17 function StatusOr \ud83d\udd17 1 inline explicit StatusOr () function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( const Status & s ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( StatusOr && that ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( const StatusOr & that ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( const std :: decay_t < T > & obj ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( std :: decay_t < T > & obj ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( std :: decay_t < T > && obj ) function StatusOr \ud83d\udd17 1 2 3 4 5 6 7 template < typename U , typename = EnableIfNoShadow < StatusOr , U &&> , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>> , typename = void > inline StatusOr ( U && obj ) function StatusOr \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> inline StatusOr ( StatusOr < U > && that ) function StatusOr \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , const U &>>> inline StatusOr ( const StatusOr < U > & that ) function ~StatusOr \ud83d\udd17 1 inline ~ StatusOr () function operator= \ud83d\udd17 1 2 3 inline StatusOr & operator = ( std :: decay_t < T > && obj ) function operator= \ud83d\udd17 1 2 3 inline StatusOr & operator = ( const T & obj ) function operator= \ud83d\udd17 1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> inline StatusOr & operator = ( U && obj ) function operator= \ud83d\udd17 1 2 3 inline StatusOr & operator = ( const StatusOr & that ) function operator= \ud83d\udd17 1 2 3 inline StatusOr & operator = ( StatusOr && that ) function operator= \ud83d\udd17 1 2 3 inline StatusOr & operator = ( const Status & new_status ) function emplace \ud83d\udd17 1 2 3 4 template < typename ... Args > inline void emplace ( Args && ... args ) function emplace \ud83d\udd17 1 2 3 4 template < typename U > inline void emplace ( StatusOr < U > && that ) function emplace \ud83d\udd17 1 2 3 4 template < typename U > inline void emplace ( const StatusOr < U > & that ) function IgnoreError \ud83d\udd17 1 inline void IgnoreError () const function ok \ud83d\udd17 1 inline bool ok () const function status \ud83d\udd17 1 inline const Status & status () const function value \ud83d\udd17 1 inline T & value () function value \ud83d\udd17 1 inline const T & value () const function operator* \ud83d\udd17 1 inline T & operator * () function operator* \ud83d\udd17 1 inline const T & operator * () const function operator* \ud83d\udd17 1 inline T operator * () function operator-> \ud83d\udd17 1 inline const std :: decay_t < T > * operator -> () const function operator-> \ud83d\udd17 1 inline std :: decay_t < T > * operator -> () Friends \ud83d\udd17 friend StatusOr \ud83d\udd17 1 friend class StatusOr ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-types","text":"Name using T value_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-functions","text":"Name StatusOr () StatusOr (const Status & s) StatusOr ( StatusOr && that) StatusOr (const StatusOr & that) StatusOr (const std::decay_t< T > & obj) StatusOr (std::decay_t< T > & obj) StatusOr (std::decay_t< T > && obj) template <typename U ,typename =EnableIfNoShadow ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >,typename =void> StatusOr (U && obj) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr ( StatusOr < U > && that) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr (const StatusOr < U > & that) ~StatusOr () StatusOr & operator= (std::decay_t< T > && obj) StatusOr & operator= (const T & obj) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr & operator= (U && obj) StatusOr & operator= (const StatusOr & that) StatusOr & operator= ( StatusOr && that) StatusOr & operator= (const Status & new_status) template <typename... Args> void emplace (Args &&... args) template <typename U > void emplace ( StatusOr < U > && that) template <typename U > void emplace (const StatusOr < U > & that) void IgnoreError () const bool ok () const const Status & status () const T & value () const T & value () const T & operator* () const T & operator* () const T operator* () const std::decay_t< T > * operator-> () const std::decay_t< T > * operator-> ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#friends","text":"Name class StatusOr","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#detailed-description","text":"1 2 template < typename T > class batt :: StatusOr ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#using-value_type","text":"1 using batt :: StatusOr < T >:: value_type = T ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor","text":"1 inline explicit StatusOr ()","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_1","text":"1 2 3 inline StatusOr ( const Status & s )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_2","text":"1 2 3 inline StatusOr ( StatusOr && that )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_3","text":"1 2 3 inline StatusOr ( const StatusOr & that )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_4","text":"1 2 3 inline StatusOr ( const std :: decay_t < T > & obj )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_5","text":"1 2 3 inline StatusOr ( std :: decay_t < T > & obj )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_6","text":"1 2 3 inline StatusOr ( std :: decay_t < T > && obj )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_7","text":"1 2 3 4 5 6 7 template < typename U , typename = EnableIfNoShadow < StatusOr , U &&> , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>> , typename = void > inline StatusOr ( U && obj )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_8","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> inline StatusOr ( StatusOr < U > && that )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_9","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , const U &>>> inline StatusOr ( const StatusOr < U > & that )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_10","text":"1 inline ~ StatusOr ()","title":"function ~StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator","text":"1 2 3 inline StatusOr & operator = ( std :: decay_t < T > && obj )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_1","text":"1 2 3 inline StatusOr & operator = ( const T & obj )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_2","text":"1 2 3 4 5 template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> inline StatusOr & operator = ( U && obj )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_3","text":"1 2 3 inline StatusOr & operator = ( const StatusOr & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_4","text":"1 2 3 inline StatusOr & operator = ( StatusOr && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_5","text":"1 2 3 inline StatusOr & operator = ( const Status & new_status )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-emplace","text":"1 2 3 4 template < typename ... Args > inline void emplace ( Args && ... args )","title":"function emplace"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-emplace_1","text":"1 2 3 4 template < typename U > inline void emplace ( StatusOr < U > && that )","title":"function emplace"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-emplace_2","text":"1 2 3 4 template < typename U > inline void emplace ( const StatusOr < U > & that )","title":"function emplace"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-ignoreerror","text":"1 inline void IgnoreError () const","title":"function IgnoreError"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-ok","text":"1 inline bool ok () const","title":"function ok"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-status","text":"1 inline const Status & status () const","title":"function status"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-value","text":"1 inline T & value ()","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-value_1","text":"1 inline const T & value () const","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_6","text":"1 inline T & operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_7","text":"1 inline const T & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_8","text":"1 inline T operator * ()","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator-","text":"1 inline const std :: decay_t < T > * operator -> () const","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator-_1","text":"1 inline std :: decay_t < T > * operator -> ()","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#friend-statusor","text":"1 friend class StatusOr ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/","text":"batt::StatusOr< StatusOr< T > > \ud83d\udd17 More... Inherits from batt::StatusOr< T > Public Functions \ud83d\udd17 Name StatusOr (const StatusOr < T > & status_or) StatusOr ( StatusOr < T > && status_or) Additional inherited members \ud83d\udd17 Public Types inherited from batt::StatusOr< T > Name using T value_type Public Functions inherited from batt::StatusOr< T > Name ~StatusOr () StatusOr & operator= (std::decay_t< T > && obj) StatusOr & operator= (const T & obj) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr & operator= (U && obj) StatusOr & operator= (const StatusOr & that) StatusOr & operator= ( StatusOr && that) StatusOr & operator= (const Status & new_status) template <typename... Args> void emplace (Args &&... args) template <typename U > void emplace ( StatusOr < U > && that) template <typename U > void emplace (const StatusOr < U > & that) void IgnoreError () const bool ok () const const Status & status () const T & value () const T & value () const T & operator* () const T & operator* () const T operator* () const std::decay_t< T > * operator-> () const std::decay_t< T > * operator-> () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: StatusOr < StatusOr < T > > ; Public Functions Documentation \ud83d\udd17 function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( const StatusOr < T > & status_or ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( StatusOr < T > && status_or ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StatusOr< StatusOr< T > >"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#public-functions","text":"Name StatusOr (const StatusOr < T > & status_or) StatusOr ( StatusOr < T > && status_or)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#additional-inherited-members","text":"Public Types inherited from batt::StatusOr< T > Name using T value_type Public Functions inherited from batt::StatusOr< T > Name ~StatusOr () StatusOr & operator= (std::decay_t< T > && obj) StatusOr & operator= (const T & obj) template <typename U ,typename =std::enable_if_t<!std::is_same_v , T> && std::is_constructible_v >> StatusOr & operator= (U && obj) StatusOr & operator= (const StatusOr & that) StatusOr & operator= ( StatusOr && that) StatusOr & operator= (const Status & new_status) template <typename... Args> void emplace (Args &&... args) template <typename U > void emplace ( StatusOr < U > && that) template <typename U > void emplace (const StatusOr < U > & that) void IgnoreError () const bool ok () const const Status & status () const T & value () const T & value () const T & operator* () const T & operator* () const T operator* () const std::decay_t< T > * operator-> () const std::decay_t< T > * operator-> ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > class batt :: StatusOr < StatusOr < T > > ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#function-statusor","text":"1 2 3 inline StatusOr ( const StatusOr < T > & status_or )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#function-statusor_1","text":"1 2 3 inline StatusOr ( StatusOr < T > && status_or ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/","text":"batt::StatusOr< Status > \ud83d\udd17 Inherits from batt::Status , batt::detail::StatusBase Public Functions \ud83d\udd17 Name StatusOr (const Status & status) StatusOr ( Status && status) Status () Status (const Status & ) =default template <typename EnumT ,typename =std::enable_if_t >> Status (EnumT enum_value) Additional inherited members \ud83d\udd17 Public Classes inherited from batt::Status Name struct CodeEntry struct CodeGroup Public Types inherited from batt::Status Name using i32 value_type Public Functions inherited from batt::Status Name template <typename EnumT > const CodeGroup & code_group_for_type () const std::string & unknown_enum_value_message () template <typename EnumT > bool register_codes (const std::vector< std::pair< EnumT, std::string >> & codes) std::string_view message_from_code (value_type value) Status & operator= (const Status & ) =default bool ok () const value_type code () const std::string_view message () const const CodeGroup & group () const void IgnoreError () const void Update (const Status & new_status) Public Attributes inherited from batt::Status Name constexpr i32 kGroupSizeBits constexpr i32 kGroupSize constexpr i32 kMaxGroups Friends inherited from batt::Status Name class detail::StatusBase Public Functions inherited from batt::detail::StatusBase Name StatusBase () Public Functions Documentation \ud83d\udd17 function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( const Status & status ) function StatusOr \ud83d\udd17 1 2 3 inline StatusOr ( Status && status ) function Status \ud83d\udd17 1 inline Status () function Status \ud83d\udd17 1 2 3 Status ( const Status & ) = default function Status \ud83d\udd17 1 2 3 4 5 template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> inline Status ( EnumT enum_value ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StatusOr< Status >"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#public-functions","text":"Name StatusOr (const Status & status) StatusOr ( Status && status) Status () Status (const Status & ) =default template <typename EnumT ,typename =std::enable_if_t >> Status (EnumT enum_value)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#additional-inherited-members","text":"Public Classes inherited from batt::Status Name struct CodeEntry struct CodeGroup Public Types inherited from batt::Status Name using i32 value_type Public Functions inherited from batt::Status Name template <typename EnumT > const CodeGroup & code_group_for_type () const std::string & unknown_enum_value_message () template <typename EnumT > bool register_codes (const std::vector< std::pair< EnumT, std::string >> & codes) std::string_view message_from_code (value_type value) Status & operator= (const Status & ) =default bool ok () const value_type code () const std::string_view message () const const CodeGroup & group () const void IgnoreError () const void Update (const Status & new_status) Public Attributes inherited from batt::Status Name constexpr i32 kGroupSizeBits constexpr i32 kGroupSize constexpr i32 kMaxGroups Friends inherited from batt::Status Name class detail::StatusBase Public Functions inherited from batt::detail::StatusBase Name StatusBase ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-statusor","text":"1 2 3 inline StatusOr ( const Status & status )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-statusor_1","text":"1 2 3 inline StatusOr ( Status && status )","title":"function StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status","text":"1 inline Status ()","title":"function Status"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_1","text":"1 2 3 Status ( const Status & ) = default","title":"function Status"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_2","text":"1 2 3 4 5 template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> inline Status ( EnumT enum_value ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function Status"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/","text":"batt::StochasticModelChecker \ud83d\udd17 More... Public Types \ud83d\udd17 Name using typename ModelT::Branch Branch using typename Branch::delta_type BranchDelta using typename ModelT::VisitResult VisitResult Public Functions \ud83d\udd17 Name StochasticModelChecker (typename ModelT::Base & model, detail::ParallelModelCheckState < Branch > & mesh, usize shard_i) ~StochasticModelChecker () StateMachineResult run () Detailed Description \ud83d\udd17 1 2 template < typename ModelT > class batt :: StochasticModelChecker ; Public Types Documentation \ud83d\udd17 using Branch \ud83d\udd17 1 using batt :: StochasticModelChecker < ModelT >:: Branch = typename ModelT :: Branch ; using BranchDelta \ud83d\udd17 1 using batt :: StochasticModelChecker < ModelT >:: BranchDelta = typename Branch :: delta_type ; using VisitResult \ud83d\udd17 1 using batt :: StochasticModelChecker < ModelT >:: VisitResult = typename ModelT :: VisitResult ; Public Functions Documentation \ud83d\udd17 function StochasticModelChecker \ud83d\udd17 1 2 3 4 5 inline explicit StochasticModelChecker ( typename ModelT :: Base & model , detail :: ParallelModelCheckState < Branch > & mesh , usize shard_i ) function ~StochasticModelChecker \ud83d\udd17 1 inline ~ StochasticModelChecker () function run \ud83d\udd17 1 inline StateMachineResult run () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StochasticModelChecker"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-types","text":"Name using typename ModelT::Branch Branch using typename Branch::delta_type BranchDelta using typename ModelT::VisitResult VisitResult","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-functions","text":"Name StochasticModelChecker (typename ModelT::Base & model, detail::ParallelModelCheckState < Branch > & mesh, usize shard_i) ~StochasticModelChecker () StateMachineResult run ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#detailed-description","text":"1 2 template < typename ModelT > class batt :: StochasticModelChecker ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#using-branch","text":"1 using batt :: StochasticModelChecker < ModelT >:: Branch = typename ModelT :: Branch ;","title":"using Branch"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#using-branchdelta","text":"1 using batt :: StochasticModelChecker < ModelT >:: BranchDelta = typename Branch :: delta_type ;","title":"using BranchDelta"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#using-visitresult","text":"1 using batt :: StochasticModelChecker < ModelT >:: VisitResult = typename ModelT :: VisitResult ;","title":"using VisitResult"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#function-stochasticmodelchecker","text":"1 2 3 4 5 inline explicit StochasticModelChecker ( typename ModelT :: Base & model , detail :: ParallelModelCheckState < Branch > & mesh , usize shard_i )","title":"function StochasticModelChecker"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#function-stochasticmodelchecker_1","text":"1 inline ~ StochasticModelChecker ()","title":"function ~StochasticModelChecker"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#function-run","text":"1 inline StateMachineResult run () Updated on 26 August 2022 at 17:30:03 UTC","title":"function run"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/","text":"batt::StreamBuffer \ud83d\udd17 Public Types \ud83d\udd17 Name using boost::asio::any_io_executor executor_type Public Functions \ud83d\udd17 Name StreamBuffer (usize capacity) ~StreamBuffer () usize capacity () const usize size () const usize space () const executor_type get_executor () const StatusOr < SmallVec< MutableBuffer, 2 > > prepare_exactly (i64 exact_count) StatusOr < SmallVec< MutableBuffer, 2 > > prepare_at_least (i64 min_count) template <typename Handler =void(const ErrorCode& ec, SmallVec )> void async_prepare_at_least (i64 min_count, Handler && handler) void commit (i64 count) template <typename T > Status write_type ( StaticType < T > , const T & value) template <typename ConstBuffers ,typename Handler =void(const ErrorCode& ec, usize n_bytes_written)> void async_write_some (ConstBuffers && buffers, Handler && handler) Status write_all (ConstBuffer buffer) void close_for_write () StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) template <typename T > StatusOr < std::reference_wrapper< const T > > fetch_type ( StaticType < T > ={}) template <typename T > void consume_type ( StaticType < T > ={}) template <typename T > StatusOr < T > read_type ( StaticType < T > ={}) void close_for_read () void close () Public Attributes \ud83d\udd17 Name constexpr usize kTempBufferSize Public Types Documentation \ud83d\udd17 using executor_type \ud83d\udd17 1 using batt :: StreamBuffer :: executor_type = boost :: asio :: any_io_executor ; Public Functions Documentation \ud83d\udd17 function StreamBuffer \ud83d\udd17 1 2 3 inline explicit StreamBuffer ( usize capacity ) function ~StreamBuffer \ud83d\udd17 1 inline ~ StreamBuffer () function capacity \ud83d\udd17 1 inline usize capacity () const function size \ud83d\udd17 1 inline usize size () const function space \ud83d\udd17 1 inline usize space () const function get_executor \ud83d\udd17 1 inline executor_type get_executor () const function prepare_exactly \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < MutableBuffer , 2 > > prepare_exactly ( i64 exact_count ) function prepare_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < MutableBuffer , 2 > > prepare_at_least ( i64 min_count ) function async_prepare_at_least \ud83d\udd17 1 2 3 4 5 template < typename Handler = void ( const ErrorCode & ec , SmallVec < MutableBuffer , 2 > ) > void async_prepare_at_least ( i64 min_count , Handler && handler ) function commit \ud83d\udd17 1 2 3 inline void commit ( i64 count ) function write_type \ud83d\udd17 1 2 3 4 5 template < typename T > Status write_type ( StaticType < T > , const T & value ) function async_write_some \ud83d\udd17 1 2 3 4 5 6 template < typename ConstBuffers , typename Handler = void ( const ErrorCode & ec , usize n_bytes_written ) > void async_write_some ( ConstBuffers && buffers , Handler && handler ) function write_all \ud83d\udd17 1 2 3 inline Status write_all ( ConstBuffer buffer ) function close_for_write \ud83d\udd17 1 inline void close_for_write () function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) function fetch_type \ud83d\udd17 1 2 3 4 template < typename T > StatusOr < std :: reference_wrapper < const T > > fetch_type ( StaticType < T > = {} ) function consume_type \ud83d\udd17 1 2 3 4 template < typename T > void consume_type ( StaticType < T > = {} ) function read_type \ud83d\udd17 1 2 3 4 template < typename T > StatusOr < T > read_type ( StaticType < T > = {} ) function close_for_read \ud83d\udd17 1 inline void close_for_read () function close \ud83d\udd17 1 inline void close () Public Attributes Documentation \ud83d\udd17 variable kTempBufferSize \ud83d\udd17 1 static constexpr usize kTempBufferSize = 512 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StreamBuffer"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-types","text":"Name using boost::asio::any_io_executor executor_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-functions","text":"Name StreamBuffer (usize capacity) ~StreamBuffer () usize capacity () const usize size () const usize space () const executor_type get_executor () const StatusOr < SmallVec< MutableBuffer, 2 > > prepare_exactly (i64 exact_count) StatusOr < SmallVec< MutableBuffer, 2 > > prepare_at_least (i64 min_count) template <typename Handler =void(const ErrorCode& ec, SmallVec )> void async_prepare_at_least (i64 min_count, Handler && handler) void commit (i64 count) template <typename T > Status write_type ( StaticType < T > , const T & value) template <typename ConstBuffers ,typename Handler =void(const ErrorCode& ec, usize n_bytes_written)> void async_write_some (ConstBuffers && buffers, Handler && handler) Status write_all (ConstBuffer buffer) void close_for_write () StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) template <typename T > StatusOr < std::reference_wrapper< const T > > fetch_type ( StaticType < T > ={}) template <typename T > void consume_type ( StaticType < T > ={}) template <typename T > StatusOr < T > read_type ( StaticType < T > ={}) void close_for_read () void close ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-attributes","text":"Name constexpr usize kTempBufferSize","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#using-executor_type","text":"1 using batt :: StreamBuffer :: executor_type = boost :: asio :: any_io_executor ;","title":"using executor_type"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-streambuffer","text":"1 2 3 inline explicit StreamBuffer ( usize capacity )","title":"function StreamBuffer"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-streambuffer_1","text":"1 inline ~ StreamBuffer ()","title":"function ~StreamBuffer"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-capacity","text":"1 inline usize capacity () const","title":"function capacity"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-space","text":"1 inline usize space () const","title":"function space"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-get_executor","text":"1 inline executor_type get_executor () const","title":"function get_executor"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-prepare_exactly","text":"1 2 3 inline StatusOr < SmallVec < MutableBuffer , 2 > > prepare_exactly ( i64 exact_count )","title":"function prepare_exactly"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-prepare_at_least","text":"1 2 3 inline StatusOr < SmallVec < MutableBuffer , 2 > > prepare_at_least ( i64 min_count )","title":"function prepare_at_least"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-async_prepare_at_least","text":"1 2 3 4 5 template < typename Handler = void ( const ErrorCode & ec , SmallVec < MutableBuffer , 2 > ) > void async_prepare_at_least ( i64 min_count , Handler && handler )","title":"function async_prepare_at_least"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-commit","text":"1 2 3 inline void commit ( i64 count )","title":"function commit"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-write_type","text":"1 2 3 4 5 template < typename T > Status write_type ( StaticType < T > , const T & value )","title":"function write_type"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-async_write_some","text":"1 2 3 4 5 6 template < typename ConstBuffers , typename Handler = void ( const ErrorCode & ec , usize n_bytes_written ) > void async_write_some ( ConstBuffers && buffers , Handler && handler )","title":"function async_write_some"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-write_all","text":"1 2 3 inline Status write_all ( ConstBuffer buffer )","title":"function write_all"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-close_for_write","text":"1 inline void close_for_write ()","title":"function close_for_write"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count )","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-consume","text":"1 2 3 inline void consume ( i64 count )","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-fetch_type","text":"1 2 3 4 template < typename T > StatusOr < std :: reference_wrapper < const T > > fetch_type ( StaticType < T > = {} )","title":"function fetch_type"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-consume_type","text":"1 2 3 4 template < typename T > void consume_type ( StaticType < T > = {} )","title":"function consume_type"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-read_type","text":"1 2 3 4 template < typename T > StatusOr < T > read_type ( StaticType < T > = {} )","title":"function read_type"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-close_for_read","text":"1 inline void close_for_read ()","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-close","text":"1 inline void close ()","title":"function close"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#variable-ktempbuffersize","text":"1 static constexpr usize kTempBufferSize = 512 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kTempBufferSize"},{"location":"_autogen/Classes/classbatt_1_1StrongType/","text":"batt::StrongType \ud83d\udd17 More... Inherited by batt::StrongType< T, Tag >::Delta Public Classes \ud83d\udd17 Name struct Delta struct Hash Public Types \ud83d\udd17 Name using T value_type using Tag tag_type Public Functions \ud83d\udd17 Name constexpr StrongType () constexpr StrongType (T init_value) constexpr T value () const constexpr operator T () const StrongType & operator+= ( Delta d) StrongType & operator-= ( Delta d) Detailed Description \ud83d\udd17 1 2 3 template < typename T , typename Tag > class batt :: StrongType ; Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: StrongType < T , Tag >:: value_type = T ; using tag_type \ud83d\udd17 1 using batt :: StrongType < T , Tag >:: tag_type = Tag ; Public Functions Documentation \ud83d\udd17 function StrongType \ud83d\udd17 1 inline constexpr StrongType () function StrongType \ud83d\udd17 1 2 3 inline explicit constexpr StrongType ( T init_value ) function value \ud83d\udd17 1 inline constexpr T value () const function operator T \ud83d\udd17 1 inline constexpr operator T () const function operator+= \ud83d\udd17 1 2 3 inline StrongType & operator += ( Delta d ) function operator-= \ud83d\udd17 1 2 3 inline StrongType & operator -= ( Delta d ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StrongType"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-classes","text":"Name struct Delta struct Hash","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-types","text":"Name using T value_type using Tag tag_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-functions","text":"Name constexpr StrongType () constexpr StrongType (T init_value) constexpr T value () const constexpr operator T () const StrongType & operator+= ( Delta d) StrongType & operator-= ( Delta d)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#detailed-description","text":"1 2 3 template < typename T , typename Tag > class batt :: StrongType ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#using-value_type","text":"1 using batt :: StrongType < T , Tag >:: value_type = T ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#using-tag_type","text":"1 using batt :: StrongType < T , Tag >:: tag_type = Tag ;","title":"using tag_type"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-strongtype","text":"1 inline constexpr StrongType ()","title":"function StrongType"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-strongtype_1","text":"1 2 3 inline explicit constexpr StrongType ( T init_value )","title":"function StrongType"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-value","text":"1 inline constexpr T value () const","title":"function value"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-operator-t","text":"1 inline constexpr operator T () const","title":"function operator T"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-operator","text":"1 2 3 inline StrongType & operator += ( Delta d )","title":"function operator+="},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-operator-","text":"1 2 3 inline StrongType & operator -= ( Delta d ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator-="},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/","text":"batt::SubRangeSeq \ud83d\udd17 More... Public Types \ud83d\udd17 Name using decltype(std::declval< T >().front()) Item Public Functions \ud83d\udd17 Name SubRangeSeq (T && sub_range) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: SubRangeSeq ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: SubRangeSeq < T >:: Item = decltype ( std :: declval < T > (). front ()); Public Functions Documentation \ud83d\udd17 function SubRangeSeq \ud83d\udd17 1 2 3 inline explicit SubRangeSeq ( T && sub_range ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SubRangeSeq"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-types","text":"Name using decltype(std::declval< T >().front()) Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-functions","text":"Name SubRangeSeq (T && sub_range) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#detailed-description","text":"1 2 template < typename T > class batt :: SubRangeSeq ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#using-item","text":"1 using batt :: SubRangeSeq < T >:: Item = decltype ( std :: declval < T > (). front ());","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#function-subrangeseq","text":"1 2 3 inline explicit SubRangeSeq ( T && sub_range )","title":"function SubRangeSeq"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/","text":"batt::TakeNSource \ud83d\udd17 More... Public Functions \ud83d\udd17 Name TakeNSource (Src && src, usize limit) usize size () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) void close_for_read () Detailed Description \ud83d\udd17 1 2 template < typename Src > class batt :: TakeNSource ; Public Functions Documentation \ud83d\udd17 function TakeNSource \ud83d\udd17 1 2 3 4 inline explicit TakeNSource ( Src && src , usize limit ) function size \ud83d\udd17 1 inline usize size () const function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) function close_for_read \ud83d\udd17 1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TakeNSource"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#public-functions","text":"Name TakeNSource (Src && src, usize limit) usize size () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) void close_for_read ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#detailed-description","text":"1 2 template < typename Src > class batt :: TakeNSource ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-takensource","text":"1 2 3 4 inline explicit TakeNSource ( Src && src , usize limit )","title":"function TakeNSource"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count )","title":"function fetch_at_least"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-consume","text":"1 2 3 inline void consume ( i64 count )","title":"function consume"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-close_for_read","text":"1 inline void close_for_read () Updated on 26 August 2022 at 17:30:03 UTC","title":"function close_for_read"},{"location":"_autogen/Classes/classbatt_1_1Task/","text":"batt::Task \ud83d\udd17 Inherits from boost::intrusive::list_base_hook< boost::intrusive::link_mode< boost::intrusive::auto_unlink > > Public Classes \ud83d\udd17 Name struct DebugTrace Public Types \ud83d\udd17 Name using u32 state_type using :: batt::StrongType < i32, BATT_STRONG_TYPEDEF_PASTE_( Priority , _TAG)> Priority using :: batt::StrongType < bool, BATT_STRONG_TYPEDEF_PASTE_( IsDone , _TAG)> IsDone using boost::asio::any_io_executor executor_type using boost::intrusive::list< Task , boost::intrusive::constant_time_size< false > > AllTaskList using std::bitset< kNumStateFlags > StateBitset Public Functions \ud83d\udd17 Name constexpr i32 strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( Priority , _TAG) * ) constexpr bool strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( IsDone , _TAG) * ) Task (const Task & ) =deleted Task & operator= (const Task & ) =deleted template <typename BodyFn =void()> Task (const boost::asio::any_io_executor & ex, StackSize stack_size, BodyFn && body_fn) template <typename BodyFn =void()> Task (const boost::asio::any_io_executor & ex, BodyFn && body_fn, std::string && name =default_name(), StackSize stack_size = StackSize {512 *1024}, StackType stack_type =StackType::kFixedSize, Optional < Priority > priority =None) =default ~Task () i32 id () const std::string_view name () const Priority get_priority () const void set_priority ( Priority new_priority) usize stack_pos () const usize stack_pos_of (const volatile void * ptr) const void join () IsDone try_join () bool wake () executor_type get_executor () const IsDone is_done () const template <typename F =void()> void call_when_done (F && handler) usize & nesting_depth () constexpr bool is_running_state (state_type state) constexpr bool is_ready_state (state_type state) constexpr bool is_terminal_state (state_type state) std::mutex & global_mutex () AllTaskList & all_tasks () Task & current () std::string_view current_name () i32 current_id () Optional < usize > current_stack_pos () Optional < usize > current_stack_pos_of (const volatile void * ptr) i32 backtrace_all (bool force) void yield () template <typename Duration =boost::posix_time::ptime> ErrorCode sleep (const Duration & duration) template <typename R ,typename Fn > R await (Fn && fn) template <typename R ,typename Fn > R await ( batt::StaticType < R > , Fn && fn) template <typename T > StatusOr < T > await (const Future < T > & future_result) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_read_some (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_read (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_write_some (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_write (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename Endpoint > ErrorCode await_connect (AsyncStream & s, const Endpoint & endpoint) template <typename AsyncAcceptor ,typename ProtocolT =typename AsyncAcceptor::protocol_type,typename StreamT =typename ProtocolT::socket> IOResult < StreamT > await_accept (AsyncAcceptor & a) std::string default_name () Priority current_priority () bool & inside_work_fn () Public Attributes \ud83d\udd17 Name constexpr usize kMaxNestingDepth constexpr usize kHandlerMemoryBytes constexpr state_type kNeedSignal constexpr state_type kHaveSignal constexpr state_type kSuspended constexpr state_type kTerminated constexpr state_type kStackTrace constexpr state_type kSleepTimerLock constexpr state_type kCompletionHandlersLock constexpr state_type kSleepTimerLockSuspend constexpr state_type kCompletionHandlersClosed constexpr usize kNumStateFlags DebugInfoFrame * debug_info Friends \ud83d\udd17 Name class DebugInfoFrame void print_debug_info ( DebugInfoFrame * p, std::ostream & out) Public Types Documentation \ud83d\udd17 using state_type \ud83d\udd17 1 using batt :: Task :: state_type = u32 ; using Priority \ud83d\udd17 1 using batt :: Task :: Priority = :: batt :: StrongType < i32 , BATT_STRONG_TYPEDEF_PASTE_ ( Priority , _TAG ) > ; using IsDone \ud83d\udd17 1 using batt :: Task :: IsDone = :: batt :: StrongType < bool , BATT_STRONG_TYPEDEF_PASTE_ ( IsDone , _TAG ) > ; using executor_type \ud83d\udd17 1 using batt :: Task :: executor_type = boost :: asio :: any_io_executor ; using AllTaskList \ud83d\udd17 1 using batt :: Task :: AllTaskList = boost :: intrusive :: list < Task , boost :: intrusive :: constant_time_size < false > > ; using StateBitset \ud83d\udd17 1 using batt :: Task :: StateBitset = std :: bitset < kNumStateFlags > ; Public Functions Documentation \ud83d\udd17 function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr i32 strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( Priority , _TAG ) * ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr bool strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( IsDone , _TAG ) * ) function Task \ud83d\udd17 1 2 3 Task ( const Task & ) = deleted function operator= \ud83d\udd17 1 2 3 Task & operator = ( const Task & ) = deleted function Task \ud83d\udd17 1 2 3 4 5 6 template < typename BodyFn = void () > inline explicit Task ( const boost :: asio :: any_io_executor & ex , StackSize stack_size , BodyFn && body_fn ) function Task \ud83d\udd17 1 2 3 4 5 6 7 8 9 template < typename BodyFn = void () > inline explicit Task ( const boost :: asio :: any_io_executor & ex , BodyFn && body_fn , std :: string && name = default_name (), StackSize stack_size = StackSize { 512 * 1024 }, StackType stack_type = StackType :: kFixedSize , Optional < Priority > priority = None ) = default function ~Task \ud83d\udd17 1 inline ~ Task () function id \ud83d\udd17 1 inline i32 id () const function name \ud83d\udd17 1 inline std :: string_view name () const function get_priority \ud83d\udd17 1 inline Priority get_priority () const function set_priority \ud83d\udd17 1 2 3 inline void set_priority ( Priority new_priority ) function stack_pos \ud83d\udd17 1 inline usize stack_pos () const function stack_pos_of \ud83d\udd17 1 2 3 inline usize stack_pos_of ( const volatile void * ptr ) const function join \ud83d\udd17 1 inline void join () function try_join \ud83d\udd17 1 inline IsDone try_join () function wake \ud83d\udd17 1 inline bool wake () function get_executor \ud83d\udd17 1 inline executor_type get_executor () const function is_done \ud83d\udd17 1 inline IsDone is_done () const function call_when_done \ud83d\udd17 1 2 3 4 template < typename F = void () > inline void call_when_done ( F && handler ) function nesting_depth \ud83d\udd17 1 static inline usize & nesting_depth () function is_running_state \ud83d\udd17 1 2 3 static inline constexpr bool is_running_state ( state_type state ) function is_ready_state \ud83d\udd17 1 2 3 static inline constexpr bool is_ready_state ( state_type state ) function is_terminal_state \ud83d\udd17 1 2 3 static inline constexpr bool is_terminal_state ( state_type state ) function global_mutex \ud83d\udd17 1 static inline std :: mutex & global_mutex () function all_tasks \ud83d\udd17 1 static inline AllTaskList & all_tasks () function current \ud83d\udd17 1 static inline Task & current () function current_name \ud83d\udd17 1 static inline std :: string_view current_name () function current_id \ud83d\udd17 1 static inline i32 current_id () function current_stack_pos \ud83d\udd17 1 static inline Optional < usize > current_stack_pos () function current_stack_pos_of \ud83d\udd17 1 2 3 static inline Optional < usize > current_stack_pos_of ( const volatile void * ptr ) function backtrace_all \ud83d\udd17 1 2 3 static inline i32 backtrace_all ( bool force ) function yield \ud83d\udd17 1 static inline void yield () function sleep \ud83d\udd17 1 2 3 4 template < typename Duration = boost :: posix_time :: ptime > static inline ErrorCode sleep ( const Duration & duration ) function await \ud83d\udd17 1 2 3 4 5 template < typename R , typename Fn > static inline R await ( Fn && fn ) function await \ud83d\udd17 1 2 3 4 5 6 template < typename R , typename Fn > static inline R await ( batt :: StaticType < R > , Fn && fn ) function await \ud83d\udd17 1 2 3 4 template < typename T > static inline StatusOr < T > await ( const Future < T > & future_result ) function await_read_some \ud83d\udd17 1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_read_some ( AsyncStream & s , BufferSequence && buffers ) function await_read \ud83d\udd17 1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_read ( AsyncStream & s , BufferSequence && buffers ) function await_write_some \ud83d\udd17 1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_write_some ( AsyncStream & s , BufferSequence && buffers ) function await_write \ud83d\udd17 1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_write ( AsyncStream & s , BufferSequence && buffers ) function await_connect \ud83d\udd17 1 2 3 4 5 6 template < typename AsyncStream , typename Endpoint > static inline ErrorCode await_connect ( AsyncStream & s , const Endpoint & endpoint ) function await_accept \ud83d\udd17 1 2 3 4 5 6 template < typename AsyncAcceptor , typename ProtocolT = typename AsyncAcceptor :: protocol_type , typename StreamT = typename ProtocolT :: socket > static inline IOResult < StreamT > await_accept ( AsyncAcceptor & a ) function default_name \ud83d\udd17 1 static inline std :: string default_name () function current_priority \ud83d\udd17 1 static inline Priority current_priority () function inside_work_fn \ud83d\udd17 1 static inline bool & inside_work_fn () Public Attributes Documentation \ud83d\udd17 variable kMaxNestingDepth \ud83d\udd17 1 static constexpr usize kMaxNestingDepth = 8 ; variable kHandlerMemoryBytes \ud83d\udd17 1 static constexpr usize kHandlerMemoryBytes = 128 ; variable kNeedSignal \ud83d\udd17 1 static constexpr state_type kNeedSignal = state_type { 1 } << 0 ; variable kHaveSignal \ud83d\udd17 1 static constexpr state_type kHaveSignal = state_type { 1 } << 1 ; variable kSuspended \ud83d\udd17 1 static constexpr state_type kSuspended = state_type { 1 } << 2 ; variable kTerminated \ud83d\udd17 1 static constexpr state_type kTerminated = state_type { 1 } << 3 ; variable kStackTrace \ud83d\udd17 1 static constexpr state_type kStackTrace = state_type { 1 } << 4 ; variable kSleepTimerLock \ud83d\udd17 1 static constexpr state_type kSleepTimerLock = state_type { 1 } << 5 ; variable kCompletionHandlersLock \ud83d\udd17 1 static constexpr state_type kCompletionHandlersLock = state_type { 1 } << 6 ; variable kSleepTimerLockSuspend \ud83d\udd17 1 static constexpr state_type kSleepTimerLockSuspend = state_type { 1 } << 7 ; variable kCompletionHandlersClosed \ud83d\udd17 1 static constexpr state_type kCompletionHandlersClosed = state_type { 1 } << 8 ; variable kNumStateFlags \ud83d\udd17 1 static constexpr usize kNumStateFlags = 9 ; variable debug_info \ud83d\udd17 1 DebugInfoFrame * debug_info = nullptr ; Friends \ud83d\udd17 friend DebugInfoFrame \ud83d\udd17 1 friend class DebugInfoFrame ; friend print_debug_info \ud83d\udd17 1 2 3 4 5 friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Task"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-classes","text":"Name struct DebugTrace","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-types","text":"Name using u32 state_type using :: batt::StrongType < i32, BATT_STRONG_TYPEDEF_PASTE_( Priority , _TAG)> Priority using :: batt::StrongType < bool, BATT_STRONG_TYPEDEF_PASTE_( IsDone , _TAG)> IsDone using boost::asio::any_io_executor executor_type using boost::intrusive::list< Task , boost::intrusive::constant_time_size< false > > AllTaskList using std::bitset< kNumStateFlags > StateBitset","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-functions","text":"Name constexpr i32 strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( Priority , _TAG) * ) constexpr bool strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( IsDone , _TAG) * ) Task (const Task & ) =deleted Task & operator= (const Task & ) =deleted template <typename BodyFn =void()> Task (const boost::asio::any_io_executor & ex, StackSize stack_size, BodyFn && body_fn) template <typename BodyFn =void()> Task (const boost::asio::any_io_executor & ex, BodyFn && body_fn, std::string && name =default_name(), StackSize stack_size = StackSize {512 *1024}, StackType stack_type =StackType::kFixedSize, Optional < Priority > priority =None) =default ~Task () i32 id () const std::string_view name () const Priority get_priority () const void set_priority ( Priority new_priority) usize stack_pos () const usize stack_pos_of (const volatile void * ptr) const void join () IsDone try_join () bool wake () executor_type get_executor () const IsDone is_done () const template <typename F =void()> void call_when_done (F && handler) usize & nesting_depth () constexpr bool is_running_state (state_type state) constexpr bool is_ready_state (state_type state) constexpr bool is_terminal_state (state_type state) std::mutex & global_mutex () AllTaskList & all_tasks () Task & current () std::string_view current_name () i32 current_id () Optional < usize > current_stack_pos () Optional < usize > current_stack_pos_of (const volatile void * ptr) i32 backtrace_all (bool force) void yield () template <typename Duration =boost::posix_time::ptime> ErrorCode sleep (const Duration & duration) template <typename R ,typename Fn > R await (Fn && fn) template <typename R ,typename Fn > R await ( batt::StaticType < R > , Fn && fn) template <typename T > StatusOr < T > await (const Future < T > & future_result) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_read_some (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_read (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_write_some (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename BufferSequence > IOResult < usize > await_write (AsyncStream & s, BufferSequence && buffers) template <typename AsyncStream ,typename Endpoint > ErrorCode await_connect (AsyncStream & s, const Endpoint & endpoint) template <typename AsyncAcceptor ,typename ProtocolT =typename AsyncAcceptor::protocol_type,typename StreamT =typename ProtocolT::socket> IOResult < StreamT > await_accept (AsyncAcceptor & a) std::string default_name () Priority current_priority () bool & inside_work_fn ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-attributes","text":"Name constexpr usize kMaxNestingDepth constexpr usize kHandlerMemoryBytes constexpr state_type kNeedSignal constexpr state_type kHaveSignal constexpr state_type kSuspended constexpr state_type kTerminated constexpr state_type kStackTrace constexpr state_type kSleepTimerLock constexpr state_type kCompletionHandlersLock constexpr state_type kSleepTimerLockSuspend constexpr state_type kCompletionHandlersClosed constexpr usize kNumStateFlags DebugInfoFrame * debug_info","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1Task/#friends","text":"Name class DebugInfoFrame void print_debug_info ( DebugInfoFrame * p, std::ostream & out)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-state_type","text":"1 using batt :: Task :: state_type = u32 ;","title":"using state_type"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-priority","text":"1 using batt :: Task :: Priority = :: batt :: StrongType < i32 , BATT_STRONG_TYPEDEF_PASTE_ ( Priority , _TAG ) > ;","title":"using Priority"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-isdone","text":"1 using batt :: Task :: IsDone = :: batt :: StrongType < bool , BATT_STRONG_TYPEDEF_PASTE_ ( IsDone , _TAG ) > ;","title":"using IsDone"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-executor_type","text":"1 using batt :: Task :: executor_type = boost :: asio :: any_io_executor ;","title":"using executor_type"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-alltasklist","text":"1 using batt :: Task :: AllTaskList = boost :: intrusive :: list < Task , boost :: intrusive :: constant_time_size < false > > ;","title":"using AllTaskList"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-statebitset","text":"1 using batt :: Task :: StateBitset = std :: bitset < kNumStateFlags > ;","title":"using StateBitset"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-strong_typedef_default_value","text":"1 2 3 inline constexpr i32 strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( Priority , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-strong_typedef_default_value_1","text":"1 2 3 inline constexpr bool strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( IsDone , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task","text":"1 2 3 Task ( const Task & ) = deleted","title":"function Task"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-operator","text":"1 2 3 Task & operator = ( const Task & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_1","text":"1 2 3 4 5 6 template < typename BodyFn = void () > inline explicit Task ( const boost :: asio :: any_io_executor & ex , StackSize stack_size , BodyFn && body_fn )","title":"function Task"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_2","text":"1 2 3 4 5 6 7 8 9 template < typename BodyFn = void () > inline explicit Task ( const boost :: asio :: any_io_executor & ex , BodyFn && body_fn , std :: string && name = default_name (), StackSize stack_size = StackSize { 512 * 1024 }, StackType stack_type = StackType :: kFixedSize , Optional < Priority > priority = None ) = default","title":"function Task"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_3","text":"1 inline ~ Task ()","title":"function ~Task"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-id","text":"1 inline i32 id () const","title":"function id"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-name","text":"1 inline std :: string_view name () const","title":"function name"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-get_priority","text":"1 inline Priority get_priority () const","title":"function get_priority"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-set_priority","text":"1 2 3 inline void set_priority ( Priority new_priority )","title":"function set_priority"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-stack_pos","text":"1 inline usize stack_pos () const","title":"function stack_pos"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-stack_pos_of","text":"1 2 3 inline usize stack_pos_of ( const volatile void * ptr ) const","title":"function stack_pos_of"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-try_join","text":"1 inline IsDone try_join ()","title":"function try_join"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-wake","text":"1 inline bool wake ()","title":"function wake"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-get_executor","text":"1 inline executor_type get_executor () const","title":"function get_executor"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_done","text":"1 inline IsDone is_done () const","title":"function is_done"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-call_when_done","text":"1 2 3 4 template < typename F = void () > inline void call_when_done ( F && handler )","title":"function call_when_done"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-nesting_depth","text":"1 static inline usize & nesting_depth ()","title":"function nesting_depth"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_running_state","text":"1 2 3 static inline constexpr bool is_running_state ( state_type state )","title":"function is_running_state"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_ready_state","text":"1 2 3 static inline constexpr bool is_ready_state ( state_type state )","title":"function is_ready_state"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_terminal_state","text":"1 2 3 static inline constexpr bool is_terminal_state ( state_type state )","title":"function is_terminal_state"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-global_mutex","text":"1 static inline std :: mutex & global_mutex ()","title":"function global_mutex"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-all_tasks","text":"1 static inline AllTaskList & all_tasks ()","title":"function all_tasks"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current","text":"1 static inline Task & current ()","title":"function current"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_name","text":"1 static inline std :: string_view current_name ()","title":"function current_name"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_id","text":"1 static inline i32 current_id ()","title":"function current_id"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_stack_pos","text":"1 static inline Optional < usize > current_stack_pos ()","title":"function current_stack_pos"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_stack_pos_of","text":"1 2 3 static inline Optional < usize > current_stack_pos_of ( const volatile void * ptr )","title":"function current_stack_pos_of"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-backtrace_all","text":"1 2 3 static inline i32 backtrace_all ( bool force )","title":"function backtrace_all"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-yield","text":"1 static inline void yield ()","title":"function yield"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-sleep","text":"1 2 3 4 template < typename Duration = boost :: posix_time :: ptime > static inline ErrorCode sleep ( const Duration & duration )","title":"function sleep"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await","text":"1 2 3 4 5 template < typename R , typename Fn > static inline R await ( Fn && fn )","title":"function await"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_1","text":"1 2 3 4 5 6 template < typename R , typename Fn > static inline R await ( batt :: StaticType < R > , Fn && fn )","title":"function await"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_2","text":"1 2 3 4 template < typename T > static inline StatusOr < T > await ( const Future < T > & future_result )","title":"function await"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_read_some","text":"1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_read_some ( AsyncStream & s , BufferSequence && buffers )","title":"function await_read_some"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_read","text":"1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_read ( AsyncStream & s , BufferSequence && buffers )","title":"function await_read"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_write_some","text":"1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_write_some ( AsyncStream & s , BufferSequence && buffers )","title":"function await_write_some"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_write","text":"1 2 3 4 5 6 template < typename AsyncStream , typename BufferSequence > static inline IOResult < usize > await_write ( AsyncStream & s , BufferSequence && buffers )","title":"function await_write"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_connect","text":"1 2 3 4 5 6 template < typename AsyncStream , typename Endpoint > static inline ErrorCode await_connect ( AsyncStream & s , const Endpoint & endpoint )","title":"function await_connect"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_accept","text":"1 2 3 4 5 6 template < typename AsyncAcceptor , typename ProtocolT = typename AsyncAcceptor :: protocol_type , typename StreamT = typename ProtocolT :: socket > static inline IOResult < StreamT > await_accept ( AsyncAcceptor & a )","title":"function await_accept"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-default_name","text":"1 static inline std :: string default_name ()","title":"function default_name"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_priority","text":"1 static inline Priority current_priority ()","title":"function current_priority"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-inside_work_fn","text":"1 static inline bool & inside_work_fn ()","title":"function inside_work_fn"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kmaxnestingdepth","text":"1 static constexpr usize kMaxNestingDepth = 8 ;","title":"variable kMaxNestingDepth"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-khandlermemorybytes","text":"1 static constexpr usize kHandlerMemoryBytes = 128 ;","title":"variable kHandlerMemoryBytes"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kneedsignal","text":"1 static constexpr state_type kNeedSignal = state_type { 1 } << 0 ;","title":"variable kNeedSignal"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-khavesignal","text":"1 static constexpr state_type kHaveSignal = state_type { 1 } << 1 ;","title":"variable kHaveSignal"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-ksuspended","text":"1 static constexpr state_type kSuspended = state_type { 1 } << 2 ;","title":"variable kSuspended"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kterminated","text":"1 static constexpr state_type kTerminated = state_type { 1 } << 3 ;","title":"variable kTerminated"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kstacktrace","text":"1 static constexpr state_type kStackTrace = state_type { 1 } << 4 ;","title":"variable kStackTrace"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-ksleeptimerlock","text":"1 static constexpr state_type kSleepTimerLock = state_type { 1 } << 5 ;","title":"variable kSleepTimerLock"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kcompletionhandlerslock","text":"1 static constexpr state_type kCompletionHandlersLock = state_type { 1 } << 6 ;","title":"variable kCompletionHandlersLock"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-ksleeptimerlocksuspend","text":"1 static constexpr state_type kSleepTimerLockSuspend = state_type { 1 } << 7 ;","title":"variable kSleepTimerLockSuspend"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kcompletionhandlersclosed","text":"1 static constexpr state_type kCompletionHandlersClosed = state_type { 1 } << 8 ;","title":"variable kCompletionHandlersClosed"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-knumstateflags","text":"1 static constexpr usize kNumStateFlags = 9 ;","title":"variable kNumStateFlags"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-debug_info","text":"1 DebugInfoFrame * debug_info = nullptr ;","title":"variable debug_info"},{"location":"_autogen/Classes/classbatt_1_1Task/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1Task/#friend-debuginfoframe","text":"1 friend class DebugInfoFrame ;","title":"friend DebugInfoFrame"},{"location":"_autogen/Classes/classbatt_1_1Task/#friend-print_debug_info","text":"1 2 3 4 5 friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend print_debug_info"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/","text":"batt::TaskScheduler \ud83d\udd17 Inherited by batt::FakeTaskScheduler , batt::NullTaskScheduler , batt::Runtime::DefaultScheduler Public Functions \ud83d\udd17 Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default virtual boost::asio::any_io_executor schedule_task () =0 virtual void halt () =0 virtual void join () =0 Protected Functions \ud83d\udd17 Name TaskScheduler () =default Public Functions Documentation \ud83d\udd17 function TaskScheduler \ud83d\udd17 1 2 3 TaskScheduler ( const TaskScheduler & ) = deleted function operator= \ud83d\udd17 1 2 3 TaskScheduler & operator = ( const TaskScheduler & ) = deleted function ~TaskScheduler \ud83d\udd17 1 virtual ~ TaskScheduler () = default function schedule_task \ud83d\udd17 1 virtual boost :: asio :: any_io_executor schedule_task () = 0 Reimplemented by : batt::FakeTaskScheduler::schedule_task , batt::NullTaskScheduler::schedule_task , batt::Runtime::DefaultScheduler::schedule_task function halt \ud83d\udd17 1 virtual void halt () = 0 Reimplemented by : batt::FakeTaskScheduler::halt , batt::NullTaskScheduler::halt , batt::Runtime::DefaultScheduler::halt function join \ud83d\udd17 1 virtual void join () = 0 Reimplemented by : batt::FakeTaskScheduler::join , batt::NullTaskScheduler::join , batt::Runtime::DefaultScheduler::join Protected Functions Documentation \ud83d\udd17 function TaskScheduler \ud83d\udd17 1 TaskScheduler () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#public-functions","text":"Name TaskScheduler (const TaskScheduler & ) =deleted TaskScheduler & operator= (const TaskScheduler & ) =deleted virtual ~TaskScheduler () =default virtual boost::asio::any_io_executor schedule_task () =0 virtual void halt () =0 virtual void join () =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#protected-functions","text":"Name TaskScheduler () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-taskscheduler","text":"1 2 3 TaskScheduler ( const TaskScheduler & ) = deleted","title":"function TaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-operator","text":"1 2 3 TaskScheduler & operator = ( const TaskScheduler & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-taskscheduler_1","text":"1 virtual ~ TaskScheduler () = default","title":"function ~TaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-schedule_task","text":"1 virtual boost :: asio :: any_io_executor schedule_task () = 0 Reimplemented by : batt::FakeTaskScheduler::schedule_task , batt::NullTaskScheduler::schedule_task , batt::Runtime::DefaultScheduler::schedule_task","title":"function schedule_task"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-halt","text":"1 virtual void halt () = 0 Reimplemented by : batt::FakeTaskScheduler::halt , batt::NullTaskScheduler::halt , batt::Runtime::DefaultScheduler::halt","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-join","text":"1 virtual void join () = 0 Reimplemented by : batt::FakeTaskScheduler::join , batt::NullTaskScheduler::join , batt::Runtime::DefaultScheduler::join","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-taskscheduler_2","text":"1 TaskScheduler () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function TaskScheduler"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/","text":"batt::Task::SpinLockGuard \ud83d\udd17 Public Functions \ud83d\udd17 Name SpinLockGuard ( Task * task, state_type mask) SpinLockGuard (const SpinLockGuard & ) =deleted SpinLockGuard & operator= (const SpinLockGuard & ) =deleted ~SpinLockGuard () state_type prior_state () const Public Functions Documentation \ud83d\udd17 function SpinLockGuard \ud83d\udd17 1 2 3 4 inline explicit SpinLockGuard ( Task * task , state_type mask ) function SpinLockGuard \ud83d\udd17 1 2 3 SpinLockGuard ( const SpinLockGuard & ) = deleted function operator= \ud83d\udd17 1 2 3 SpinLockGuard & operator = ( const SpinLockGuard & ) = deleted function ~SpinLockGuard \ud83d\udd17 1 inline ~ SpinLockGuard () function prior_state \ud83d\udd17 1 inline state_type prior_state () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Task::SpinLockGuard"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#public-functions","text":"Name SpinLockGuard ( Task * task, state_type mask) SpinLockGuard (const SpinLockGuard & ) =deleted SpinLockGuard & operator= (const SpinLockGuard & ) =deleted ~SpinLockGuard () state_type prior_state () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-spinlockguard","text":"1 2 3 4 inline explicit SpinLockGuard ( Task * task , state_type mask )","title":"function SpinLockGuard"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-spinlockguard_1","text":"1 2 3 SpinLockGuard ( const SpinLockGuard & ) = deleted","title":"function SpinLockGuard"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-operator","text":"1 2 3 SpinLockGuard & operator = ( const SpinLockGuard & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-spinlockguard_2","text":"1 inline ~ SpinLockGuard ()","title":"function ~SpinLockGuard"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-prior_state","text":"1 inline state_type prior_state () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function prior_state"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/","text":"batt::Task::Trampoline \ud83d\udd17 Public Functions \ud83d\udd17 Name void activate_task ( Task * t) Task * get_current_task () Public Functions Documentation \ud83d\udd17 function activate_task \ud83d\udd17 1 2 3 static inline void activate_task ( Task * t ) function get_current_task \ud83d\udd17 1 static inline Task * get_current_task () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Task::Trampoline"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#public-functions","text":"Name void activate_task ( Task * t) Task * get_current_task ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#function-activate_task","text":"1 2 3 static inline void activate_task ( Task * t )","title":"function activate_task"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#function-get_current_task","text":"1 static inline Task * get_current_task () Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_current_task"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/","text":"batt::TypeErasedStorage \ud83d\udd17 More... Inherits from batt::TypeErasedStorageBase< AbstractType, TypedImpl > Public Functions \ud83d\udd17 Name TypeErasedStorage () template <typename T ,typename... Args> TypeErasedStorage ( StaticType < T > static_type, Args &&... args) TypeErasedStorage (const TypeErasedStorage & other) TypeErasedStorage ( TypeErasedStorage && other) ~TypeErasedStorage () TypeErasedStorage & operator= ( TypeErasedStorage && other) TypeErasedStorage & operator= (const TypeErasedStorage & other) template <typename T ,typename... Args> AbstractType * emplace ( StaticType < T > static_type, Args &&... args) template <typename T ,typename U ,typename =std::enable_if_t , std::reference_wrapper\\ >>> AbstractType * emplace ( StaticType < U > , const std::reference_wrapper< T > & ref) void clear () MutableBuffer memory () AbstractType * get () const AbstractValue < AbstractType > * get_abstract () bool is_valid () const operator bool () const AbstractType * operator-> () const AbstractType & operator* () const Public Attributes \ud83d\udd17 Name constexpr usize reserved_size Additional inherited members \ud83d\udd17 Public Functions inherited from batt::TypeErasedStorageBase< AbstractType, TypedImpl > Name template <typename T ,typename... Args> AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf, Args &&... args) Detailed Description \ud83d\udd17 1 2 3 4 5 template < typename AbstractType , template < typename > class TypedImpl , usize kReservedSize = kCpuCacheLineSize - sizeof ( void * ), usize kAlignment = kCpuCacheLineSize > class batt :: TypeErasedStorage ; Public Functions Documentation \ud83d\udd17 function TypeErasedStorage \ud83d\udd17 1 inline TypeErasedStorage () function TypeErasedStorage \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename ... Args > inline TypeErasedStorage ( StaticType < T > static_type , Args && ... args ) function TypeErasedStorage \ud83d\udd17 1 2 3 inline TypeErasedStorage ( const TypeErasedStorage & other ) function TypeErasedStorage \ud83d\udd17 1 2 3 inline TypeErasedStorage ( TypeErasedStorage && other ) function ~TypeErasedStorage \ud83d\udd17 1 inline ~ TypeErasedStorage () function operator= \ud83d\udd17 1 2 3 inline TypeErasedStorage & operator = ( TypeErasedStorage && other ) function operator= \ud83d\udd17 1 2 3 inline TypeErasedStorage & operator = ( const TypeErasedStorage & other ) function emplace \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename ... Args > inline AbstractType * emplace ( StaticType < T > static_type , Args && ... args ) function emplace \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename U , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < U > , std :: reference_wrapper < T >>>> inline AbstractType * emplace ( StaticType < U > , const std :: reference_wrapper < T > & ref ) function clear \ud83d\udd17 1 inline void clear () function memory \ud83d\udd17 1 inline MutableBuffer memory () function get \ud83d\udd17 1 inline AbstractType * get () const function get_abstract \ud83d\udd17 1 inline AbstractValue < AbstractType > * get_abstract () function is_valid \ud83d\udd17 1 inline bool is_valid () const function operator bool \ud83d\udd17 1 inline explicit operator bool () const function operator-> \ud83d\udd17 1 inline AbstractType * operator -> () const function operator* \ud83d\udd17 1 inline AbstractType & operator * () const Public Attributes Documentation \ud83d\udd17 variable reserved_size \ud83d\udd17 1 static constexpr usize reserved_size = kReservedSize ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TypeErasedStorage"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-functions","text":"Name TypeErasedStorage () template <typename T ,typename... Args> TypeErasedStorage ( StaticType < T > static_type, Args &&... args) TypeErasedStorage (const TypeErasedStorage & other) TypeErasedStorage ( TypeErasedStorage && other) ~TypeErasedStorage () TypeErasedStorage & operator= ( TypeErasedStorage && other) TypeErasedStorage & operator= (const TypeErasedStorage & other) template <typename T ,typename... Args> AbstractType * emplace ( StaticType < T > static_type, Args &&... args) template <typename T ,typename U ,typename =std::enable_if_t , std::reference_wrapper\\ >>> AbstractType * emplace ( StaticType < U > , const std::reference_wrapper< T > & ref) void clear () MutableBuffer memory () AbstractType * get () const AbstractValue < AbstractType > * get_abstract () bool is_valid () const operator bool () const AbstractType * operator-> () const AbstractType & operator* () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-attributes","text":"Name constexpr usize reserved_size","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#additional-inherited-members","text":"Public Functions inherited from batt::TypeErasedStorageBase< AbstractType, TypedImpl > Name template <typename T ,typename... Args> AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf, Args &&... args)","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#detailed-description","text":"1 2 3 4 5 template < typename AbstractType , template < typename > class TypedImpl , usize kReservedSize = kCpuCacheLineSize - sizeof ( void * ), usize kAlignment = kCpuCacheLineSize > class batt :: TypeErasedStorage ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage","text":"1 inline TypeErasedStorage ()","title":"function TypeErasedStorage"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_1","text":"1 2 3 4 5 6 template < typename T , typename ... Args > inline TypeErasedStorage ( StaticType < T > static_type , Args && ... args )","title":"function TypeErasedStorage"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_2","text":"1 2 3 inline TypeErasedStorage ( const TypeErasedStorage & other )","title":"function TypeErasedStorage"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_3","text":"1 2 3 inline TypeErasedStorage ( TypeErasedStorage && other )","title":"function TypeErasedStorage"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_4","text":"1 inline ~ TypeErasedStorage ()","title":"function ~TypeErasedStorage"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator","text":"1 2 3 inline TypeErasedStorage & operator = ( TypeErasedStorage && other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator_1","text":"1 2 3 inline TypeErasedStorage & operator = ( const TypeErasedStorage & other )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-emplace","text":"1 2 3 4 5 6 template < typename T , typename ... Args > inline AbstractType * emplace ( StaticType < T > static_type , Args && ... args )","title":"function emplace"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-emplace_1","text":"1 2 3 4 5 6 7 template < typename T , typename U , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < U > , std :: reference_wrapper < T >>>> inline AbstractType * emplace ( StaticType < U > , const std :: reference_wrapper < T > & ref )","title":"function emplace"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-clear","text":"1 inline void clear ()","title":"function clear"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-memory","text":"1 inline MutableBuffer memory ()","title":"function memory"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-get","text":"1 inline AbstractType * get () const","title":"function get"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-get_abstract","text":"1 inline AbstractValue < AbstractType > * get_abstract ()","title":"function get_abstract"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-is_valid","text":"1 inline bool is_valid () const","title":"function is_valid"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator-","text":"1 inline AbstractType * operator -> () const","title":"function operator-&gt;"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator_2","text":"1 inline AbstractType & operator * () const","title":"function operator*"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#variable-reserved_size","text":"1 static constexpr usize reserved_size = kReservedSize ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable reserved_size"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/","text":"batt::TypeErasedStorageBase \ud83d\udd17 More... Inherited by batt::TypeErasedStorage< AbstractType, TypedImpl, kReservedSize, kAlignment > Public Functions \ud83d\udd17 Name template <typename T ,typename... Args> AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf, Args &&... args) Detailed Description \ud83d\udd17 1 2 3 template < typename AbstractType , template < typename > class TypedImpl > class batt :: TypeErasedStorageBase ; Public Functions Documentation \ud83d\udd17 function construct_impl \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename ... Args > static inline AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf , Args && ... args ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TypeErasedStorageBase"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#public-functions","text":"Name template <typename T ,typename... Args> AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf, Args &&... args)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#detailed-description","text":"1 2 3 template < typename AbstractType , template < typename > class TypedImpl > class batt :: TypeErasedStorageBase ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#function-construct_impl","text":"1 2 3 4 5 6 7 template < typename T , typename ... Args > static inline AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf , Args && ... args ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function construct_impl"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/","text":"batt::UniqueHandler \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename Fn ,typename =EnableIfNoShadow ,typename =std::enable_if_t , Args...>::value>> UniqueHandler (Fn && fn) UniqueHandler () =default UniqueHandler (const UniqueHandler & ) =deleted UniqueHandler & operator= (const UniqueHandler & ) =deleted UniqueHandler ( UniqueHandler && ) =default UniqueHandler & operator= ( UniqueHandler && ) =default ~UniqueHandler () operator bool () const void operator() (Args... args) Friends \ud83d\udd17 Name std::ostream & operator<< (std::ostream & out, const UniqueHandler & t) Detailed Description \ud83d\udd17 1 2 template < typename ... Args > class batt :: UniqueHandler ; Public Functions Documentation \ud83d\udd17 function UniqueHandler \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename = EnableIfNoShadow < UniqueHandler , Fn > , typename = std :: enable_if_t < IsCallable < std :: decay_t < Fn > , Args ... >:: value >> inline explicit UniqueHandler ( Fn && fn ) function UniqueHandler \ud83d\udd17 1 UniqueHandler () = default function UniqueHandler \ud83d\udd17 1 2 3 UniqueHandler ( const UniqueHandler & ) = deleted function operator= \ud83d\udd17 1 2 3 UniqueHandler & operator = ( const UniqueHandler & ) = deleted function UniqueHandler \ud83d\udd17 1 2 3 UniqueHandler ( UniqueHandler && ) = default function operator= \ud83d\udd17 1 2 3 UniqueHandler & operator = ( UniqueHandler && ) = default function ~UniqueHandler \ud83d\udd17 1 inline ~ UniqueHandler () function operator bool \ud83d\udd17 1 inline explicit operator bool () const function operator() \ud83d\udd17 1 2 3 inline void operator ()( Args ... args ) Friends \ud83d\udd17 friend operator<< \ud83d\udd17 1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const UniqueHandler & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::UniqueHandler"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#public-functions","text":"Name template <typename Fn ,typename =EnableIfNoShadow ,typename =std::enable_if_t , Args...>::value>> UniqueHandler (Fn && fn) UniqueHandler () =default UniqueHandler (const UniqueHandler & ) =deleted UniqueHandler & operator= (const UniqueHandler & ) =deleted UniqueHandler ( UniqueHandler && ) =default UniqueHandler & operator= ( UniqueHandler && ) =default ~UniqueHandler () operator bool () const void operator() (Args... args)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#friends","text":"Name std::ostream & operator<< (std::ostream & out, const UniqueHandler & t)","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#detailed-description","text":"1 2 template < typename ... Args > class batt :: UniqueHandler ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler","text":"1 2 3 4 5 6 template < typename Fn , typename = EnableIfNoShadow < UniqueHandler , Fn > , typename = std :: enable_if_t < IsCallable < std :: decay_t < Fn > , Args ... >:: value >> inline explicit UniqueHandler ( Fn && fn )","title":"function UniqueHandler"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_1","text":"1 UniqueHandler () = default","title":"function UniqueHandler"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_2","text":"1 2 3 UniqueHandler ( const UniqueHandler & ) = deleted","title":"function UniqueHandler"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator","text":"1 2 3 UniqueHandler & operator = ( const UniqueHandler & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_3","text":"1 2 3 UniqueHandler ( UniqueHandler && ) = default","title":"function UniqueHandler"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator_1","text":"1 2 3 UniqueHandler & operator = ( UniqueHandler && ) = default","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_4","text":"1 inline ~ UniqueHandler ()","title":"function ~UniqueHandler"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator-bool","text":"1 inline explicit operator bool () const","title":"function operator bool"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator_2","text":"1 2 3 inline void operator ()( Args ... args )","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#friend-operator","text":"1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const UniqueHandler & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend operator&lt;&lt;"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/","text":"batt::VarSizeArray \ud83d\udd17 More... Public Types \ud83d\udd17 Name using usize size_type using T value_type using T & reference using const T & const_reference using T * iterator using const T * const_iterator Public Functions \ud83d\udd17 Name template <typename... Args> VarSizeArray (usize size, Args &&... args) ~VarSizeArray () VarSizeArray (const VarSizeArray & ) =deleted VarSizeArray & operator= (const VarSizeArray & ) =deleted usize size () const iterator begin () iterator end () const_iterator cbegin () const const_iterator cend () const const_iterator begin () const const_iterator end () const T * data () const T * data () const reference operator[] (isize i) const_reference operator[] (isize i) const bool is_dynamic () const Detailed Description \ud83d\udd17 1 2 3 template < typename T , usize kStaticAlloc = 1 > class batt :: VarSizeArray ; Public Types Documentation \ud83d\udd17 using size_type \ud83d\udd17 1 using batt :: VarSizeArray < T , kStaticAlloc >:: size_type = usize ; using value_type \ud83d\udd17 1 using batt :: VarSizeArray < T , kStaticAlloc >:: value_type = T ; using reference \ud83d\udd17 1 using batt :: VarSizeArray < T , kStaticAlloc >:: reference = T & ; using const_reference \ud83d\udd17 1 using batt :: VarSizeArray < T , kStaticAlloc >:: const_reference = const T & ; using iterator \ud83d\udd17 1 using batt :: VarSizeArray < T , kStaticAlloc >:: iterator = T * ; using const_iterator \ud83d\udd17 1 using batt :: VarSizeArray < T , kStaticAlloc >:: const_iterator = const T * ; Public Functions Documentation \ud83d\udd17 function VarSizeArray \ud83d\udd17 1 2 3 4 5 template < typename ... Args > inline VarSizeArray ( usize size , Args && ... args ) function ~VarSizeArray \ud83d\udd17 1 inline ~ VarSizeArray () function VarSizeArray \ud83d\udd17 1 2 3 VarSizeArray ( const VarSizeArray & ) = deleted function operator= \ud83d\udd17 1 2 3 VarSizeArray & operator = ( const VarSizeArray & ) = deleted function size \ud83d\udd17 1 inline usize size () const function begin \ud83d\udd17 1 inline iterator begin () function end \ud83d\udd17 1 inline iterator end () function cbegin \ud83d\udd17 1 inline const_iterator cbegin () const function cend \ud83d\udd17 1 inline const_iterator cend () const function begin \ud83d\udd17 1 inline const_iterator begin () const function end \ud83d\udd17 1 inline const_iterator end () const function data \ud83d\udd17 1 inline T * data () function data \ud83d\udd17 1 inline const T * data () const function operator[] \ud83d\udd17 1 2 3 inline reference operator []( isize i ) function operator[] \ud83d\udd17 1 2 3 inline const_reference operator []( isize i ) const function is_dynamic \ud83d\udd17 1 inline bool is_dynamic () const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::VarSizeArray"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#public-types","text":"Name using usize size_type using T value_type using T & reference using const T & const_reference using T * iterator using const T * const_iterator","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#public-functions","text":"Name template <typename... Args> VarSizeArray (usize size, Args &&... args) ~VarSizeArray () VarSizeArray (const VarSizeArray & ) =deleted VarSizeArray & operator= (const VarSizeArray & ) =deleted usize size () const iterator begin () iterator end () const_iterator cbegin () const const_iterator cend () const const_iterator begin () const const_iterator end () const T * data () const T * data () const reference operator[] (isize i) const_reference operator[] (isize i) const bool is_dynamic () const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#detailed-description","text":"1 2 3 template < typename T , usize kStaticAlloc = 1 > class batt :: VarSizeArray ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#using-size_type","text":"1 using batt :: VarSizeArray < T , kStaticAlloc >:: size_type = usize ;","title":"using size_type"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#using-value_type","text":"1 using batt :: VarSizeArray < T , kStaticAlloc >:: value_type = T ;","title":"using value_type"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#using-reference","text":"1 using batt :: VarSizeArray < T , kStaticAlloc >:: reference = T & ;","title":"using reference"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#using-const_reference","text":"1 using batt :: VarSizeArray < T , kStaticAlloc >:: const_reference = const T & ;","title":"using const_reference"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#using-iterator","text":"1 using batt :: VarSizeArray < T , kStaticAlloc >:: iterator = T * ;","title":"using iterator"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#using-const_iterator","text":"1 using batt :: VarSizeArray < T , kStaticAlloc >:: const_iterator = const T * ;","title":"using const_iterator"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-varsizearray","text":"1 2 3 4 5 template < typename ... Args > inline VarSizeArray ( usize size , Args && ... args )","title":"function VarSizeArray"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-varsizearray_1","text":"1 inline ~ VarSizeArray ()","title":"function ~VarSizeArray"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-varsizearray_2","text":"1 2 3 VarSizeArray ( const VarSizeArray & ) = deleted","title":"function VarSizeArray"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-operator","text":"1 2 3 VarSizeArray & operator = ( const VarSizeArray & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-begin","text":"1 inline iterator begin ()","title":"function begin"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-end","text":"1 inline iterator end ()","title":"function end"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-cbegin","text":"1 inline const_iterator cbegin () const","title":"function cbegin"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-cend","text":"1 inline const_iterator cend () const","title":"function cend"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-begin_1","text":"1 inline const_iterator begin () const","title":"function begin"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-end_1","text":"1 inline const_iterator end () const","title":"function end"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-data","text":"1 inline T * data ()","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-data_1","text":"1 inline const T * data () const","title":"function data"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-operator_1","text":"1 2 3 inline reference operator []( isize i )","title":"function operator[]"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-operator_2","text":"1 2 3 inline const_reference operator []( isize i ) const","title":"function operator[]"},{"location":"_autogen/Classes/classbatt_1_1VarSizeArray/#function-is_dynamic","text":"1 inline bool is_dynamic () const Updated on 26 August 2022 at 17:30:03 UTC","title":"function is_dynamic"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/","text":"batt::VariableExporter \ud83d\udd17 More... Inherits from batt::MetricExporter Public Functions \ud83d\udd17 Name VariableExporter (const std::string & name, const T & var) virtual Token get_name () const override virtual double get_value () const override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: VariableExporter ; Public Functions Documentation \ud83d\udd17 function VariableExporter \ud83d\udd17 1 2 3 4 inline explicit VariableExporter ( const std :: string & name , const T & var ) function get_name \ud83d\udd17 1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name function get_value \ud83d\udd17 1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::VariableExporter"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#public-functions","text":"Name VariableExporter (const std::string & name, const T & var) virtual Token get_name () const override virtual double get_value () const override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#additional-inherited-members","text":"Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#detailed-description","text":"1 2 template < typename T > class batt :: VariableExporter ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#function-variableexporter","text":"1 2 3 4 inline explicit VariableExporter ( const std :: string & name , const T & var )","title":"function VariableExporter"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#function-get_name","text":"1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name","title":"function get_name"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#function-get_value","text":"1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/","text":"batt::VecSeq \ud83d\udd17 More... Inherits from batt::VecSeqBase< T > , batt::SubRangeSeq< boost::iterator_range< const T * > > Public Functions \ud83d\udd17 Name VecSeq (std::vector< T > && v) Additional inherited members \ud83d\udd17 Public Functions inherited from batt::VecSeqBase< T > Name VecSeqBase (std::vector< T > && v) Public Attributes inherited from batt::VecSeqBase< T > Name std::vector< T > vec Public Types inherited from batt::SubRangeSeq< boost::iterator_range< const T * > > Name using decltype(std::declval< T >().front()) Item Public Functions inherited from batt::SubRangeSeq< boost::iterator_range< const T * > > Name SubRangeSeq (T && sub_range) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: VecSeq ; Public Functions Documentation \ud83d\udd17 function VecSeq \ud83d\udd17 1 2 3 inline explicit VecSeq ( std :: vector < T > && v ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::VecSeq"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#public-functions","text":"Name VecSeq (std::vector< T > && v)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#additional-inherited-members","text":"Public Functions inherited from batt::VecSeqBase< T > Name VecSeqBase (std::vector< T > && v) Public Attributes inherited from batt::VecSeqBase< T > Name std::vector< T > vec Public Types inherited from batt::SubRangeSeq< boost::iterator_range< const T * > > Name using decltype(std::declval< T >().front()) Item Public Functions inherited from batt::SubRangeSeq< boost::iterator_range< const T * > > Name SubRangeSeq (T && sub_range) Optional < Item > peek () Optional < Item > next ()","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#detailed-description","text":"1 2 template < typename T > class batt :: VecSeq ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#function-vecseq","text":"1 2 3 inline explicit VecSeq ( std :: vector < T > && v ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function VecSeq"},{"location":"_autogen/Classes/classbatt_1_1Watch/","text":"batt::Watch \ud83d\udd17 More... Public Functions \ud83d\udd17 Name Watch (const Watch & ) =deleted Watch & operator= (const Watch & ) =deleted Watch () =default template <typename Init ,typename =EnableIfNoShadow > Watch (Init && init_value) ~Watch () void close () bool is_closed () const void set_value (const T & new_value) T get_value () const template <typename Fn > T modify (Fn && fn) template <typename Handler > void async_wait (const T & last_seen, Handler && fn) StatusOr < T > await_not_equal (const T & last_seen) template <typename Pred > StatusOr < T > await_true (Pred && pred) Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: Watch ; Public Functions Documentation \ud83d\udd17 function Watch \ud83d\udd17 1 2 3 Watch ( const Watch & ) = deleted function operator= \ud83d\udd17 1 2 3 Watch & operator = ( const Watch & ) = deleted function Watch \ud83d\udd17 1 Watch () = default function Watch \ud83d\udd17 1 2 3 4 5 template < typename Init , typename = EnableIfNoShadow < Watch , Init >> inline explicit Watch ( Init && init_value ) function ~Watch \ud83d\udd17 1 inline ~ Watch () function close \ud83d\udd17 1 inline void close () function is_closed \ud83d\udd17 1 inline bool is_closed () const function set_value \ud83d\udd17 1 2 3 inline void set_value ( const T & new_value ) function get_value \ud83d\udd17 1 inline T get_value () const function modify \ud83d\udd17 1 2 3 4 template < typename Fn > inline T modify ( Fn && fn ) function async_wait \ud83d\udd17 1 2 3 4 5 template < typename Handler > inline void async_wait ( const T & last_seen , Handler && fn ) function await_not_equal \ud83d\udd17 1 2 3 inline StatusOr < T > await_not_equal ( const T & last_seen ) function await_true \ud83d\udd17 1 2 3 4 template < typename Pred > inline StatusOr < T > await_true ( Pred && pred ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch"},{"location":"_autogen/Classes/classbatt_1_1Watch/#public-functions","text":"Name Watch (const Watch & ) =deleted Watch & operator= (const Watch & ) =deleted Watch () =default template <typename Init ,typename =EnableIfNoShadow > Watch (Init && init_value) ~Watch () void close () bool is_closed () const void set_value (const T & new_value) T get_value () const template <typename Fn > T modify (Fn && fn) template <typename Handler > void async_wait (const T & last_seen, Handler && fn) StatusOr < T > await_not_equal (const T & last_seen) template <typename Pred > StatusOr < T > await_true (Pred && pred)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Watch/#detailed-description","text":"1 2 template < typename T > class batt :: Watch ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1Watch/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch","text":"1 2 3 Watch ( const Watch & ) = deleted","title":"function Watch"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-operator","text":"1 2 3 Watch & operator = ( const Watch & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch_1","text":"1 Watch () = default","title":"function Watch"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch_2","text":"1 2 3 4 5 template < typename Init , typename = EnableIfNoShadow < Watch , Init >> inline explicit Watch ( Init && init_value )","title":"function Watch"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch_3","text":"1 inline ~ Watch ()","title":"function ~Watch"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-close","text":"1 inline void close ()","title":"function close"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-is_closed","text":"1 inline bool is_closed () const","title":"function is_closed"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-set_value","text":"1 2 3 inline void set_value ( const T & new_value )","title":"function set_value"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-get_value","text":"1 inline T get_value () const","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-modify","text":"1 2 3 4 template < typename Fn > inline T modify ( Fn && fn )","title":"function modify"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-async_wait","text":"1 2 3 4 5 template < typename Handler > inline void async_wait ( const T & last_seen , Handler && fn )","title":"function async_wait"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-await_not_equal","text":"1 2 3 inline StatusOr < T > await_not_equal ( const T & last_seen )","title":"function await_not_equal"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-await_true","text":"1 2 3 4 template < typename Pred > inline StatusOr < T > await_true ( Pred && pred ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function await_true"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/","text":"batt::WatchAtomic \ud83d\udd17 More... Public Functions \ud83d\udd17 Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes \ud83d\udd17 Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: WatchAtomic ; Public Functions Documentation \ud83d\udd17 function WatchAtomic \ud83d\udd17 1 2 3 WatchAtomic ( const WatchAtomic & ) = deleted function operator= \ud83d\udd17 1 2 3 WatchAtomic & operator = ( const WatchAtomic & ) = deleted function WatchAtomic \ud83d\udd17 1 WatchAtomic () = default function WatchAtomic \ud83d\udd17 1 2 3 4 5 template < typename Init , typename = EnableIfNoShadow < WatchAtomic , Init >> inline explicit WatchAtomic ( Init && init_value ) function ~WatchAtomic \ud83d\udd17 1 inline ~ WatchAtomic () function close \ud83d\udd17 1 2 3 inline void close ( StatusCode final_status_code = StatusCode :: kClosed ) function is_closed \ud83d\udd17 1 inline bool is_closed () const function set_value \ud83d\udd17 1 2 3 inline T set_value ( T new_value ) function get_value \ud83d\udd17 1 inline T get_value () const function fetch_add \ud83d\udd17 1 2 3 inline T fetch_add ( T arg ) function fetch_or \ud83d\udd17 1 2 3 inline T fetch_or ( T arg ) function fetch_sub \ud83d\udd17 1 2 3 inline T fetch_sub ( T arg ) function fetch_and \ud83d\udd17 1 2 3 inline T fetch_and ( T arg ) function modify \ud83d\udd17 1 2 3 4 template < typename Fn = T ( T ) > inline T modify ( Fn && fn ) function await_modify \ud83d\udd17 1 2 3 4 template < typename Fn = Optional < T > ( T ) > inline StatusOr < T > await_modify ( Fn && fn ) function modify_if \ud83d\udd17 1 2 3 4 template < typename Fn = Optional < T > ( T ) > inline Optional < T > modify_if ( Fn && fn ) function async_wait \ud83d\udd17 1 2 3 4 5 template < typename Handler > inline void async_wait ( T last_seen , Handler && fn ) const function await_not_equal \ud83d\udd17 1 2 3 inline StatusOr < T > await_not_equal ( const T & last_seen ) const function await_true \ud83d\udd17 1 2 3 4 template < typename Pred > inline StatusOr < T > await_true ( Pred && pred ) const function await_equal \ud83d\udd17 1 2 3 inline Status await_equal ( T val ) const Public Attributes Documentation \ud83d\udd17 variable kLocked \ud83d\udd17 1 static constexpr u32 kLocked = 0x01 ; variable kOpen \ud83d\udd17 1 static constexpr u32 kOpen = 0x02 ; variable kWaiting \ud83d\udd17 1 static constexpr u32 kWaiting = 0x04 ; variable kClosedAtEnd \ud83d\udd17 1 static constexpr u32 kClosedAtEnd = 0x08 ; variable kClosedBeforeEnd \ud83d\udd17 1 static constexpr u32 kClosedBeforeEnd = 0x10 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::WatchAtomic"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-functions","text":"Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-attributes","text":"Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#detailed-description","text":"1 2 template < typename T > class batt :: WatchAtomic ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic","text":"1 2 3 WatchAtomic ( const WatchAtomic & ) = deleted","title":"function WatchAtomic"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-operator","text":"1 2 3 WatchAtomic & operator = ( const WatchAtomic & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic_1","text":"1 WatchAtomic () = default","title":"function WatchAtomic"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic_2","text":"1 2 3 4 5 template < typename Init , typename = EnableIfNoShadow < WatchAtomic , Init >> inline explicit WatchAtomic ( Init && init_value )","title":"function WatchAtomic"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic_3","text":"1 inline ~ WatchAtomic ()","title":"function ~WatchAtomic"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-close","text":"1 2 3 inline void close ( StatusCode final_status_code = StatusCode :: kClosed )","title":"function close"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-is_closed","text":"1 inline bool is_closed () const","title":"function is_closed"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-set_value","text":"1 2 3 inline T set_value ( T new_value )","title":"function set_value"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-get_value","text":"1 inline T get_value () const","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_add","text":"1 2 3 inline T fetch_add ( T arg )","title":"function fetch_add"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_or","text":"1 2 3 inline T fetch_or ( T arg )","title":"function fetch_or"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_sub","text":"1 2 3 inline T fetch_sub ( T arg )","title":"function fetch_sub"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_and","text":"1 2 3 inline T fetch_and ( T arg )","title":"function fetch_and"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-modify","text":"1 2 3 4 template < typename Fn = T ( T ) > inline T modify ( Fn && fn )","title":"function modify"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_modify","text":"1 2 3 4 template < typename Fn = Optional < T > ( T ) > inline StatusOr < T > await_modify ( Fn && fn )","title":"function await_modify"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-modify_if","text":"1 2 3 4 template < typename Fn = Optional < T > ( T ) > inline Optional < T > modify_if ( Fn && fn )","title":"function modify_if"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-async_wait","text":"1 2 3 4 5 template < typename Handler > inline void async_wait ( T last_seen , Handler && fn ) const","title":"function async_wait"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_not_equal","text":"1 2 3 inline StatusOr < T > await_not_equal ( const T & last_seen ) const","title":"function await_not_equal"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_true","text":"1 2 3 4 template < typename Pred > inline StatusOr < T > await_true ( Pred && pred ) const","title":"function await_true"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_equal","text":"1 2 3 inline Status await_equal ( T val ) const","title":"function await_equal"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-klocked","text":"1 static constexpr u32 kLocked = 0x01 ;","title":"variable kLocked"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kopen","text":"1 static constexpr u32 kOpen = 0x02 ;","title":"variable kOpen"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kwaiting","text":"1 static constexpr u32 kWaiting = 0x04 ;","title":"variable kWaiting"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kclosedatend","text":"1 static constexpr u32 kClosedAtEnd = 0x08 ;","title":"variable kClosedAtEnd"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kclosedbeforeend","text":"1 static constexpr u32 kClosedBeforeEnd = 0x10 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kClosedBeforeEnd"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/","text":"batt::WatchExporter \ud83d\udd17 More... Inherits from batt::MetricExporter Public Functions \ud83d\udd17 Name WatchExporter (const std::string & name, Watch < T > & watch) virtual Token get_name () const override virtual double get_value () const override Additional inherited members \ud83d\udd17 Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: WatchExporter ; Public Functions Documentation \ud83d\udd17 function WatchExporter \ud83d\udd17 1 2 3 4 inline explicit WatchExporter ( const std :: string & name , Watch < T > & watch ) function get_name \ud83d\udd17 1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name function get_value \ud83d\udd17 1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::WatchExporter"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#public-functions","text":"Name WatchExporter (const std::string & name, Watch < T > & watch) virtual Token get_name () const override virtual double get_value () const override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#additional-inherited-members","text":"Public Functions inherited from batt::MetricExporter Name MetricExporter (const MetricExporter & ) =deleted MetricExporter & operator= (const MetricExporter & ) =deleted virtual ~MetricExporter () =default virtual std::string_view get_description () const virtual std::string_view get_type () const virtual const MetricLabelSet & get_labels () const virtual void set_labels (MetricLabelSet && labels) Protected Functions inherited from batt::MetricExporter Name MetricExporter () =default","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#detailed-description","text":"1 2 template < typename T > class batt :: WatchExporter ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#function-watchexporter","text":"1 2 3 4 inline explicit WatchExporter ( const std :: string & name , Watch < T > & watch )","title":"function WatchExporter"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#function-get_name","text":"1 inline virtual Token get_name () const override Reimplements : batt::MetricExporter::get_name","title":"function get_name"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#function-get_value","text":"1 inline virtual double get_value () const override Reimplements : batt::MetricExporter::get_value Updated on 26 August 2022 at 17:30:03 UTC","title":"function get_value"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01bool_01_4/","text":"batt::Watch< bool > \ud83d\udd17 Inherits from batt::WatchAtomic< bool > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< bool > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< bool > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< bool >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01bool_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< bool > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< bool > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i16_01_4/","text":"batt::Watch< i16 > \ud83d\udd17 Inherits from batt::WatchAtomic< i16 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< i16 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i16 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< i16 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i16_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< i16 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i16 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i32_01_4/","text":"batt::Watch< i32 > \ud83d\udd17 Inherits from batt::WatchAtomic< i32 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< i32 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i32 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< i32 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i32_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< i32 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i32 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i64_01_4/","text":"batt::Watch< i64 > \ud83d\udd17 Inherits from batt::WatchAtomic< i64 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< i64 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i64 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< i64 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i64_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< i64 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i64 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i8_01_4/","text":"batt::Watch< i8 > \ud83d\udd17 Inherits from batt::WatchAtomic< i8 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< i8 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i8 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< i8 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i8_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< i8 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< i8 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u16_01_4/","text":"batt::Watch< u16 > \ud83d\udd17 Inherits from batt::WatchAtomic< u16 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< u16 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u16 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< u16 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u16_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< u16 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u16 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u32_01_4/","text":"batt::Watch< u32 > \ud83d\udd17 Inherits from batt::WatchAtomic< u32 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< u32 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u32 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< u32 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u32_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< u32 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u32 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u64_01_4/","text":"batt::Watch< u64 > \ud83d\udd17 Inherits from batt::WatchAtomic< u64 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< u64 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u64 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< u64 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u64_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< u64 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u64 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u8_01_4/","text":"batt::Watch< u8 > \ud83d\udd17 Inherits from batt::WatchAtomic< u8 > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< u8 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u8 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< u8 >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u8_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< u8 > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< u8 > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01void_01_5_01_4/","text":"batt::Watch< void * > \ud83d\udd17 Inherits from batt::WatchAtomic< void * > Additional inherited members \ud83d\udd17 Public Functions inherited from batt::WatchAtomic< void * > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< void * > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Watch< void * >"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01void_01_5_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::WatchAtomic< void * > Name WatchAtomic (const WatchAtomic & ) =deleted WatchAtomic & operator= (const WatchAtomic & ) =deleted WatchAtomic () =default template <typename Init ,typename =EnableIfNoShadow > WatchAtomic (Init && init_value) ~WatchAtomic () void close (StatusCode final_status_code =StatusCode::kClosed) bool is_closed () const T set_value (T new_value) T get_value () const T fetch_add (T arg) T fetch_or (T arg) T fetch_sub (T arg) T fetch_and (T arg) template <typename Fn =T(T)> T modify (Fn && fn) template <typename Fn =Optional (T)> StatusOr < T > await_modify (Fn && fn) template <typename Fn =Optional (T)> Optional < T > modify_if (Fn && fn) template <typename Handler > void async_wait (T last_seen, Handler && fn) const StatusOr < T > await_not_equal (const T & last_seen) const template <typename Pred > StatusOr < T > await_true (Pred && pred) const Status await_equal (T val) const Public Attributes inherited from batt::WatchAtomic< void * > Name constexpr u32 kLocked constexpr u32 kOpen constexpr u32 kWaiting constexpr u32 kClosedAtEnd constexpr u32 kClosedBeforeEnd Updated on 26 August 2022 at 17:30:03 UTC","title":"Additional inherited members"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/","text":"batt::WorkContext \ud83d\udd17 Inherited by batt::ScopedWorkContext Public Functions \ud83d\udd17 Name WorkContext (const WorkContext & ) =deleted WorkContext & operator= (const WorkContext & ) =deleted WorkContext ( WorkerPool & worker_pool) template <typename Fn > decltype(auto) async_run (Fn && work_fn) void on_work_started () void on_work_finished () void await_done () Public Functions Documentation \ud83d\udd17 function WorkContext \ud83d\udd17 1 2 3 WorkContext ( const WorkContext & ) = deleted function operator= \ud83d\udd17 1 2 3 WorkContext & operator = ( const WorkContext & ) = deleted function WorkContext \ud83d\udd17 1 2 3 inline explicit WorkContext ( WorkerPool & worker_pool ) function async_run \ud83d\udd17 1 2 3 4 template < typename Fn > inline decltype ( auto ) async_run ( Fn && work_fn ) function on_work_started \ud83d\udd17 1 inline void on_work_started () function on_work_finished \ud83d\udd17 1 inline void on_work_finished () function await_done \ud83d\udd17 1 inline void await_done () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::WorkContext"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#public-functions","text":"Name WorkContext (const WorkContext & ) =deleted WorkContext & operator= (const WorkContext & ) =deleted WorkContext ( WorkerPool & worker_pool) template <typename Fn > decltype(auto) async_run (Fn && work_fn) void on_work_started () void on_work_finished () void await_done ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-workcontext","text":"1 2 3 WorkContext ( const WorkContext & ) = deleted","title":"function WorkContext"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-operator","text":"1 2 3 WorkContext & operator = ( const WorkContext & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-workcontext_1","text":"1 2 3 inline explicit WorkContext ( WorkerPool & worker_pool )","title":"function WorkContext"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-async_run","text":"1 2 3 4 template < typename Fn > inline decltype ( auto ) async_run ( Fn && work_fn )","title":"function async_run"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-on_work_started","text":"1 inline void on_work_started ()","title":"function on_work_started"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-on_work_finished","text":"1 inline void on_work_finished ()","title":"function on_work_finished"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-await_done","text":"1 inline void await_done () Updated on 26 August 2022 at 17:30:03 UTC","title":"function await_done"},{"location":"_autogen/Classes/classbatt_1_1Worker/","text":"batt::Worker \ud83d\udd17 Public Types \ud83d\udd17 Name using batt::UniqueSmallFn < void(), 128 - 16 > WorkFn Public Functions \ud83d\udd17 Name Worker (boost::asio::any_io_executor ex, std::string && name =\"Worker::task\") Public Attributes \ud83d\udd17 Name batt::Queue < WorkFn > work_queue batt::Task task Public Types Documentation \ud83d\udd17 using WorkFn \ud83d\udd17 1 using batt :: Worker :: WorkFn = batt :: UniqueSmallFn < void (), 128 - 16 > ; Public Functions Documentation \ud83d\udd17 function Worker \ud83d\udd17 1 2 3 4 inline explicit Worker ( boost :: asio :: any_io_executor ex , std :: string && name = \"Worker::task\" ) Public Attributes Documentation \ud83d\udd17 variable work_queue \ud83d\udd17 1 batt :: Queue < WorkFn > work_queue ; variable task \ud83d\udd17 1 batt :: Task task ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Worker"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-types","text":"Name using batt::UniqueSmallFn < void(), 128 - 16 > WorkFn","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-functions","text":"Name Worker (boost::asio::any_io_executor ex, std::string && name =\"Worker::task\")","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-attributes","text":"Name batt::Queue < WorkFn > work_queue batt::Task task","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1Worker/#using-workfn","text":"1 using batt :: Worker :: WorkFn = batt :: UniqueSmallFn < void (), 128 - 16 > ;","title":"using WorkFn"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1Worker/#function-worker","text":"1 2 3 4 inline explicit Worker ( boost :: asio :: any_io_executor ex , std :: string && name = \"Worker::task\" )","title":"function Worker"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1Worker/#variable-work_queue","text":"1 batt :: Queue < WorkFn > work_queue ;","title":"variable work_queue"},{"location":"_autogen/Classes/classbatt_1_1Worker/#variable-task","text":"1 batt :: Task task ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable task"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/","text":"batt::WorkerPool \ud83d\udd17 Public Functions \ud83d\udd17 Name WorkerPool & default_pool () WorkerPool & null_pool () WorkerPool (usize size, TaskScheduler & scheduler) template <typename Fn > void async_run (Fn && fn) void reset (usize phase_shift =0) usize size () const void halt () void join () ~WorkerPool () Public Functions Documentation \ud83d\udd17 function default_pool \ud83d\udd17 1 static inline WorkerPool & default_pool () function null_pool \ud83d\udd17 1 static inline WorkerPool & null_pool () function WorkerPool \ud83d\udd17 1 2 3 4 inline explicit WorkerPool ( usize size , TaskScheduler & scheduler ) function async_run \ud83d\udd17 1 2 3 4 template < typename Fn > inline void async_run ( Fn && fn ) function reset \ud83d\udd17 1 2 3 inline void reset ( usize phase_shift = 0 ) function size \ud83d\udd17 1 inline usize size () const function halt \ud83d\udd17 1 inline void halt () function join \ud83d\udd17 1 inline void join () function ~WorkerPool \ud83d\udd17 1 inline ~ WorkerPool () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::WorkerPool"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#public-functions","text":"Name WorkerPool & default_pool () WorkerPool & null_pool () WorkerPool (usize size, TaskScheduler & scheduler) template <typename Fn > void async_run (Fn && fn) void reset (usize phase_shift =0) usize size () const void halt () void join () ~WorkerPool ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-default_pool","text":"1 static inline WorkerPool & default_pool ()","title":"function default_pool"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-null_pool","text":"1 static inline WorkerPool & null_pool ()","title":"function null_pool"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-workerpool","text":"1 2 3 4 inline explicit WorkerPool ( usize size , TaskScheduler & scheduler )","title":"function WorkerPool"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-async_run","text":"1 2 3 4 template < typename Fn > inline void async_run ( Fn && fn )","title":"function async_run"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-reset","text":"1 2 3 inline void reset ( usize phase_shift = 0 )","title":"function reset"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-halt","text":"1 inline void halt ()","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-workerpool_1","text":"1 inline ~ WorkerPool () Updated on 26 August 2022 at 17:30:03 UTC","title":"function ~WorkerPool"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/","text":"batt::detail::AbstractCopyFn \ud83d\udd17 More... Public Functions \ud83d\udd17 Name virtual auto copy (void * memory, usize size) const =0 virtual auto copy_to_move_only (void * memory, usize size) const =0 Detailed Description \ud83d\udd17 1 2 3 template < typename Result , typename ... Args > class batt :: detail :: AbstractCopyFn ; Public Functions Documentation \ud83d\udd17 function copy \ud83d\udd17 1 2 3 4 virtual auto copy ( void * memory , usize size ) const = 0 function copy_to_move_only \ud83d\udd17 1 2 3 4 virtual auto copy_to_move_only ( void * memory , usize size ) const = 0 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::AbstractCopyFn"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#public-functions","text":"Name virtual auto copy (void * memory, usize size) const =0 virtual auto copy_to_move_only (void * memory, usize size) const =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#detailed-description","text":"1 2 3 template < typename Result , typename ... Args > class batt :: detail :: AbstractCopyFn ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#function-copy","text":"1 2 3 4 virtual auto copy ( void * memory , usize size ) const = 0","title":"function copy"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#function-copy_to_move_only","text":"1 2 3 4 virtual auto copy_to_move_only ( void * memory , usize size ) const = 0 Updated on 26 August 2022 at 17:30:03 UTC","title":"function copy_to_move_only"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/","text":"batt::detail::AbstractMoveFn \ud83d\udd17 More... Public Functions \ud83d\udd17 Name AbstractMoveFn (const AbstractMoveFn & ) =deleted AbstractMoveFn & operator= (const AbstractMoveFn & ) =deleted virtual ~AbstractMoveFn () =default virtual auto invoke (Args... args) =0 virtual auto move (void * storage, usize size) =0 Protected Functions \ud83d\udd17 Name AbstractMoveFn () =default Detailed Description \ud83d\udd17 1 2 3 4 template < bool kMoveOnly , typename Result , typename ... Args > class batt :: detail :: AbstractMoveFn ; Public Functions Documentation \ud83d\udd17 function AbstractMoveFn \ud83d\udd17 1 2 3 AbstractMoveFn ( const AbstractMoveFn & ) = deleted function operator= \ud83d\udd17 1 2 3 AbstractMoveFn & operator = ( const AbstractMoveFn & ) = deleted function ~AbstractMoveFn \ud83d\udd17 1 virtual ~ AbstractMoveFn () = default function invoke \ud83d\udd17 1 2 3 virtual auto invoke ( Args ... args ) = 0 function move \ud83d\udd17 1 2 3 4 virtual auto move ( void * storage , usize size ) = 0 Protected Functions Documentation \ud83d\udd17 function AbstractMoveFn \ud83d\udd17 1 AbstractMoveFn () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::AbstractMoveFn"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#public-functions","text":"Name AbstractMoveFn (const AbstractMoveFn & ) =deleted AbstractMoveFn & operator= (const AbstractMoveFn & ) =deleted virtual ~AbstractMoveFn () =default virtual auto invoke (Args... args) =0 virtual auto move (void * storage, usize size) =0","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#protected-functions","text":"Name AbstractMoveFn () =default","title":"Protected Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#detailed-description","text":"1 2 3 4 template < bool kMoveOnly , typename Result , typename ... Args > class batt :: detail :: AbstractMoveFn ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-abstractmovefn","text":"1 2 3 AbstractMoveFn ( const AbstractMoveFn & ) = deleted","title":"function AbstractMoveFn"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-operator","text":"1 2 3 AbstractMoveFn & operator = ( const AbstractMoveFn & ) = deleted","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-abstractmovefn_1","text":"1 virtual ~ AbstractMoveFn () = default","title":"function ~AbstractMoveFn"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-invoke","text":"1 2 3 virtual auto invoke ( Args ... args ) = 0","title":"function invoke"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-move","text":"1 2 3 4 virtual auto move ( void * storage , usize size ) = 0","title":"function move"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-abstractmovefn_2","text":"1 AbstractMoveFn () = default Updated on 26 August 2022 at 17:30:03 UTC","title":"function AbstractMoveFn"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/","text":"batt::detail::CopyFnImpl \ud83d\udd17 More... Public Types \ud83d\udd17 Name using CopyFnImpl self_type Public Functions \ud83d\udd17 Name AbstractFn< false, Result, Args... > * copy (void * memory, usize size) const override AbstractFn< true, Result, Args... > * copy_to_move_only (void * memory, usize size) const override Detailed Description \ud83d\udd17 1 2 3 4 template < typename Fn , typename Result , typename ... Args > class batt :: detail :: CopyFnImpl ; Public Types Documentation \ud83d\udd17 using self_type \ud83d\udd17 1 using batt :: detail :: CopyFnImpl < Fn , Result , Args >:: self_type = CopyFnImpl ; Public Functions Documentation \ud83d\udd17 function copy \ud83d\udd17 1 2 3 4 inline AbstractFn < false , Result , Args ... > * copy ( void * memory , usize size ) const override function copy_to_move_only \ud83d\udd17 1 2 3 4 inline AbstractFn < true , Result , Args ... > * copy_to_move_only ( void * memory , usize size ) const override Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::CopyFnImpl"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-types","text":"Name using CopyFnImpl self_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-functions","text":"Name AbstractFn< false, Result, Args... > * copy (void * memory, usize size) const override AbstractFn< true, Result, Args... > * copy_to_move_only (void * memory, usize size) const override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#detailed-description","text":"1 2 3 4 template < typename Fn , typename Result , typename ... Args > class batt :: detail :: CopyFnImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#using-self_type","text":"1 using batt :: detail :: CopyFnImpl < Fn , Result , Args >:: self_type = CopyFnImpl ;","title":"using self_type"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#function-copy","text":"1 2 3 4 inline AbstractFn < false , Result , Args ... > * copy ( void * memory , usize size ) const override","title":"function copy"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#function-copy_to_move_only","text":"1 2 3 4 inline AbstractFn < true , Result , Args ... > * copy_to_move_only ( void * memory , usize size ) const override Updated on 26 August 2022 at 17:30:03 UTC","title":"function copy_to_move_only"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1FutureImpl/","text":"batt::detail::FutureImpl \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: detail :: FutureImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::FutureImpl"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1FutureImpl/#detailed-description","text":"1 2 template < typename T > class batt :: detail :: FutureImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/","text":"batt::detail::HttpClientRequestContext \ud83d\udd17 Public Functions \ud83d\udd17 Name HttpClientRequestContext () Status set_params () template <typename... Rest> Status set_params (const HttpHeader & hdr, Rest &&... rest) template <typename... Rest> Status set_params ( HttpData && data, Rest &&... rest) template <typename... Rest> Status set_params ( HttpClient & client, Rest &&... rest) template <typename... Rest> Status set_params ( HttpResponse * response, Rest &&... rest) template <typename... Rest> Status set_params (const HttpVersion & version, Rest &&... rest) Status set_version (const HttpVersion & version) Status set_method (std::string_view method) Status set_path (std::string_view path) Status set_url (const UrlParse & url) void set_header (const HttpHeader & hdr) void set_data ( HttpData && data) HttpResponse * get_response_object () const void set_response_object ( HttpResponse * response) const HttpRequest * get_request_object () const HttpRequest * get_request_object () Status submit () Public Functions Documentation \ud83d\udd17 function HttpClientRequestContext \ud83d\udd17 1 inline explicit HttpClientRequestContext () function set_params \ud83d\udd17 1 inline Status set_params () function set_params \ud83d\udd17 1 2 3 4 5 template < typename ... Rest > inline Status set_params ( const HttpHeader & hdr , Rest && ... rest ) function set_params \ud83d\udd17 1 2 3 4 5 template < typename ... Rest > inline Status set_params ( HttpData && data , Rest && ... rest ) function set_params \ud83d\udd17 1 2 3 4 5 template < typename ... Rest > inline Status set_params ( HttpClient & client , Rest && ... rest ) function set_params \ud83d\udd17 1 2 3 4 5 template < typename ... Rest > inline Status set_params ( HttpResponse * response , Rest && ... rest ) function set_params \ud83d\udd17 1 2 3 4 5 template < typename ... Rest > inline Status set_params ( const HttpVersion & version , Rest && ... rest ) function set_version \ud83d\udd17 1 2 3 inline Status set_version ( const HttpVersion & version ) function set_method \ud83d\udd17 1 2 3 inline Status set_method ( std :: string_view method ) function set_path \ud83d\udd17 1 2 3 inline Status set_path ( std :: string_view path ) function set_url \ud83d\udd17 1 2 3 inline Status set_url ( const UrlParse & url ) function set_header \ud83d\udd17 1 2 3 inline void set_header ( const HttpHeader & hdr ) function set_data \ud83d\udd17 1 2 3 inline void set_data ( HttpData && data ) function get_response_object \ud83d\udd17 1 inline HttpResponse * get_response_object () const function set_response_object \ud83d\udd17 1 2 3 inline void set_response_object ( HttpResponse * response ) function get_request_object \ud83d\udd17 1 inline const HttpRequest * get_request_object () const function get_request_object \ud83d\udd17 1 inline HttpRequest * get_request_object () function submit \ud83d\udd17 1 inline Status submit () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::HttpClientRequestContext"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#public-functions","text":"Name HttpClientRequestContext () Status set_params () template <typename... Rest> Status set_params (const HttpHeader & hdr, Rest &&... rest) template <typename... Rest> Status set_params ( HttpData && data, Rest &&... rest) template <typename... Rest> Status set_params ( HttpClient & client, Rest &&... rest) template <typename... Rest> Status set_params ( HttpResponse * response, Rest &&... rest) template <typename... Rest> Status set_params (const HttpVersion & version, Rest &&... rest) Status set_version (const HttpVersion & version) Status set_method (std::string_view method) Status set_path (std::string_view path) Status set_url (const UrlParse & url) void set_header (const HttpHeader & hdr) void set_data ( HttpData && data) HttpResponse * get_response_object () const void set_response_object ( HttpResponse * response) const HttpRequest * get_request_object () const HttpRequest * get_request_object () Status submit ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-httpclientrequestcontext","text":"1 inline explicit HttpClientRequestContext ()","title":"function HttpClientRequestContext"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params","text":"1 inline Status set_params ()","title":"function set_params"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_1","text":"1 2 3 4 5 template < typename ... Rest > inline Status set_params ( const HttpHeader & hdr , Rest && ... rest )","title":"function set_params"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_2","text":"1 2 3 4 5 template < typename ... Rest > inline Status set_params ( HttpData && data , Rest && ... rest )","title":"function set_params"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_3","text":"1 2 3 4 5 template < typename ... Rest > inline Status set_params ( HttpClient & client , Rest && ... rest )","title":"function set_params"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_4","text":"1 2 3 4 5 template < typename ... Rest > inline Status set_params ( HttpResponse * response , Rest && ... rest )","title":"function set_params"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_5","text":"1 2 3 4 5 template < typename ... Rest > inline Status set_params ( const HttpVersion & version , Rest && ... rest )","title":"function set_params"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_version","text":"1 2 3 inline Status set_version ( const HttpVersion & version )","title":"function set_version"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_method","text":"1 2 3 inline Status set_method ( std :: string_view method )","title":"function set_method"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_path","text":"1 2 3 inline Status set_path ( std :: string_view path )","title":"function set_path"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_url","text":"1 2 3 inline Status set_url ( const UrlParse & url )","title":"function set_url"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_header","text":"1 2 3 inline void set_header ( const HttpHeader & hdr )","title":"function set_header"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_data","text":"1 2 3 inline void set_data ( HttpData && data )","title":"function set_data"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-get_response_object","text":"1 inline HttpResponse * get_response_object () const","title":"function get_response_object"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_response_object","text":"1 2 3 inline void set_response_object ( HttpResponse * response )","title":"function set_response_object"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-get_request_object","text":"1 inline const HttpRequest * get_request_object () const","title":"function get_request_object"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-get_request_object_1","text":"1 inline HttpRequest * get_request_object ()","title":"function get_request_object"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-submit","text":"1 inline Status submit () Updated on 26 August 2022 at 17:30:03 UTC","title":"function submit"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/","text":"batt::detail::MoveFnImpl \ud83d\udd17 More... Public Types \ud83d\udd17 Name using MoveFnImpl self_type Public Functions \ud83d\udd17 Name template <typename FnRef > MoveFnImpl (FnRef && ref) Result invoke (Args... args) override AbstractFn< kMoveOnly , Result, Args... > * move (void * memory, usize size) override Protected Attributes \ud83d\udd17 Name Fn fn_ Detailed Description \ud83d\udd17 1 2 3 4 5 template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > class batt :: detail :: MoveFnImpl ; Public Types Documentation \ud83d\udd17 using self_type \ud83d\udd17 1 using batt :: detail :: MoveFnImpl < Fn , kMoveOnly , Result , Args >:: self_type = MoveFnImpl ; Public Functions Documentation \ud83d\udd17 function MoveFnImpl \ud83d\udd17 1 2 3 4 template < typename FnRef > inline explicit MoveFnImpl ( FnRef && ref ) function invoke \ud83d\udd17 1 2 3 inline Result invoke ( Args ... args ) override function move \ud83d\udd17 1 2 3 4 inline AbstractFn < kMoveOnly , Result , Args ... > * move ( void * memory , usize size ) override Protected Attributes Documentation \ud83d\udd17 variable fn_ \ud83d\udd17 1 Fn fn_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::MoveFnImpl"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-types","text":"Name using MoveFnImpl self_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-functions","text":"Name template <typename FnRef > MoveFnImpl (FnRef && ref) Result invoke (Args... args) override AbstractFn< kMoveOnly , Result, Args... > * move (void * memory, usize size) override","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#protected-attributes","text":"Name Fn fn_","title":"Protected Attributes"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#detailed-description","text":"1 2 3 4 5 template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > class batt :: detail :: MoveFnImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#using-self_type","text":"1 using batt :: detail :: MoveFnImpl < Fn , kMoveOnly , Result , Args >:: self_type = MoveFnImpl ;","title":"using self_type"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#function-movefnimpl","text":"1 2 3 4 template < typename FnRef > inline explicit MoveFnImpl ( FnRef && ref )","title":"function MoveFnImpl"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#function-invoke","text":"1 2 3 inline Result invoke ( Args ... args ) override","title":"function invoke"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#function-move","text":"1 2 3 4 inline AbstractFn < kMoveOnly , Result , Args ... > * move ( void * memory , usize size ) override","title":"function move"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#variable-fn_","text":"1 Fn fn_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable fn_"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/","text":"batt::detail::NotOkStatusWrapper \ud83d\udd17 Public Functions \ud83d\udd17 Name NotOkStatusWrapper (const char * file, int line, Status && status) NotOkStatusWrapper (const char * file, int line, const Status & status) ~NotOkStatusWrapper () operator Status () template <typename T > operator StatusOr< T > () NotOkStatusWrapper & operator<< (LogLevel new_level) template <typename T > NotOkStatusWrapper & operator<< (T && val) Public Functions Documentation \ud83d\udd17 function NotOkStatusWrapper \ud83d\udd17 1 2 3 4 5 inline explicit NotOkStatusWrapper ( const char * file , int line , Status && status ) function NotOkStatusWrapper \ud83d\udd17 1 2 3 4 5 inline explicit NotOkStatusWrapper ( const char * file , int line , const Status & status ) function ~NotOkStatusWrapper \ud83d\udd17 1 inline ~ NotOkStatusWrapper () function operator Status \ud83d\udd17 1 inline operator Status () function operator StatusOr< T > \ud83d\udd17 1 2 template < typename T > inline operator StatusOr < T > () function operator<< \ud83d\udd17 1 2 3 inline NotOkStatusWrapper & operator << ( LogLevel new_level ) function operator<< \ud83d\udd17 1 2 3 4 template < typename T > inline NotOkStatusWrapper & operator << ( T && val ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::NotOkStatusWrapper"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#public-functions","text":"Name NotOkStatusWrapper (const char * file, int line, Status && status) NotOkStatusWrapper (const char * file, int line, const Status & status) ~NotOkStatusWrapper () operator Status () template <typename T > operator StatusOr< T > () NotOkStatusWrapper & operator<< (LogLevel new_level) template <typename T > NotOkStatusWrapper & operator<< (T && val)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-notokstatuswrapper","text":"1 2 3 4 5 inline explicit NotOkStatusWrapper ( const char * file , int line , Status && status )","title":"function NotOkStatusWrapper"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-notokstatuswrapper_1","text":"1 2 3 4 5 inline explicit NotOkStatusWrapper ( const char * file , int line , const Status & status )","title":"function NotOkStatusWrapper"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-notokstatuswrapper_2","text":"1 inline ~ NotOkStatusWrapper ()","title":"function ~NotOkStatusWrapper"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator-status","text":"1 inline operator Status ()","title":"function operator Status"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator-statusor-t","text":"1 2 template < typename T > inline operator StatusOr < T > ()","title":"function operator StatusOr&lt; T &gt;"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator","text":"1 2 3 inline NotOkStatusWrapper & operator << ( LogLevel new_level )","title":"function operator&lt;&lt;"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator_1","text":"1 2 3 4 template < typename T > inline NotOkStatusWrapper & operator << ( T && val ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator&lt;&lt;"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/","text":"batt::detail::ParallelModelCheckState \ud83d\udd17 More... Public Types \ud83d\udd17 Name using ModelCheckShardMetrics ShardMetrics Public Functions \ud83d\udd17 Name ParallelModelCheckState (usize n_shards) usize find_shard (const Branch & branch) const void send (usize src_i, usize dst_i, Branch && branch) void flush_all (usize src_i) void queue_push (usize dst_i, std::vector< Branch > * branch) StatusOr < usize > recv (usize shard_i, std::deque< Branch > & local_queue) void close_all (usize shard_i, bool allow_pending =false) void finished (usize shard_i) ShardMetrics & metrics (usize shard_i) Status wait_for_other_shards () Public Attributes \ud83d\udd17 Name constexpr u64 kStallEpochUnit constexpr u64 kStallCountMask constexpr u64 kStallEpochMask const usize shard_count const usize hash_space_per_shard Watch < usize > barrier_ std::atomic< i64 > queue_push_count std::atomic< i64 > queue_pop_count std::vector< std::unique_ptr< std::atomic< bool >[]> > stalled std::vector< std::unique_ptr< Queue < std::vector< Branch > > > > recv_queues std::vector< CpuCacheLineIsolated < std::vector< std::vector< Branch > > > > send_queues std::vector< CpuCacheLineIsolated < ShardMetrics > > shard_metrics CpuCacheLineIsolated < std::atomic< i64 > > total_pending_count std::vector< CpuCacheLineIsolated < i64 > > local_consume_count Detailed Description \ud83d\udd17 1 2 template < typename Branch > class batt :: detail :: ParallelModelCheckState ; Public Types Documentation \ud83d\udd17 using ShardMetrics \ud83d\udd17 1 using batt :: detail :: ParallelModelCheckState < Branch >:: ShardMetrics = ModelCheckShardMetrics ; Public Functions Documentation \ud83d\udd17 function ParallelModelCheckState \ud83d\udd17 1 2 3 inline explicit ParallelModelCheckState ( usize n_shards ) function find_shard \ud83d\udd17 1 2 3 inline usize find_shard ( const Branch & branch ) const function send \ud83d\udd17 1 2 3 4 5 inline void send ( usize src_i , usize dst_i , Branch && branch ) function flush_all \ud83d\udd17 1 2 3 inline void flush_all ( usize src_i ) function queue_push \ud83d\udd17 1 2 3 4 inline void queue_push ( usize dst_i , std :: vector < Branch > * branch ) function recv \ud83d\udd17 1 2 3 4 inline StatusOr < usize > recv ( usize shard_i , std :: deque < Branch > & local_queue ) function close_all \ud83d\udd17 1 2 3 4 inline void close_all ( usize shard_i , bool allow_pending = false ) function finished \ud83d\udd17 1 2 3 inline void finished ( usize shard_i ) function metrics \ud83d\udd17 1 2 3 inline ShardMetrics & metrics ( usize shard_i ) function wait_for_other_shards \ud83d\udd17 1 inline Status wait_for_other_shards () Public Attributes Documentation \ud83d\udd17 variable kStallEpochUnit \ud83d\udd17 1 static constexpr u64 kStallEpochUnit = u64 { 1 } << 32 ; variable kStallCountMask \ud83d\udd17 1 static constexpr u64 kStallCountMask = kStallEpochUnit - 1 ; variable kStallEpochMask \ud83d\udd17 1 static constexpr u64 kStallEpochMask = ~ kStallCountMask ; variable shard_count \ud83d\udd17 1 const usize shard_count ; variable hash_space_per_shard \ud83d\udd17 1 const usize hash_space_per_shard = std :: numeric_limits < usize >:: max () / this -> shard_count ; variable barrier_ \ud83d\udd17 1 Watch < usize > barrier_ { this -> shard_count }; variable queue_push_count \ud83d\udd17 1 std :: atomic < i64 > queue_push_count { 0 }; variable queue_pop_count \ud83d\udd17 1 std :: atomic < i64 > queue_pop_count { 0 }; variable stalled \ud83d\udd17 1 std :: vector < std :: unique_ptr < std :: atomic < bool > [] > > stalled ; variable recv_queues \ud83d\udd17 1 std :: vector < std :: unique_ptr < Queue < std :: vector < Branch > > > > recv_queues ; variable send_queues \ud83d\udd17 1 std :: vector < CpuCacheLineIsolated < std :: vector < std :: vector < Branch > > > > send_queues ; variable shard_metrics \ud83d\udd17 1 std :: vector < CpuCacheLineIsolated < ShardMetrics > > shard_metrics ; variable total_pending_count \ud83d\udd17 1 CpuCacheLineIsolated < std :: atomic < i64 > > total_pending_count { 0 }; variable local_consume_count \ud83d\udd17 1 std :: vector < CpuCacheLineIsolated < i64 > > local_consume_count ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::ParallelModelCheckState"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-types","text":"Name using ModelCheckShardMetrics ShardMetrics","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-functions","text":"Name ParallelModelCheckState (usize n_shards) usize find_shard (const Branch & branch) const void send (usize src_i, usize dst_i, Branch && branch) void flush_all (usize src_i) void queue_push (usize dst_i, std::vector< Branch > * branch) StatusOr < usize > recv (usize shard_i, std::deque< Branch > & local_queue) void close_all (usize shard_i, bool allow_pending =false) void finished (usize shard_i) ShardMetrics & metrics (usize shard_i) Status wait_for_other_shards ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-attributes","text":"Name constexpr u64 kStallEpochUnit constexpr u64 kStallCountMask constexpr u64 kStallEpochMask const usize shard_count const usize hash_space_per_shard Watch < usize > barrier_ std::atomic< i64 > queue_push_count std::atomic< i64 > queue_pop_count std::vector< std::unique_ptr< std::atomic< bool >[]> > stalled std::vector< std::unique_ptr< Queue < std::vector< Branch > > > > recv_queues std::vector< CpuCacheLineIsolated < std::vector< std::vector< Branch > > > > send_queues std::vector< CpuCacheLineIsolated < ShardMetrics > > shard_metrics CpuCacheLineIsolated < std::atomic< i64 > > total_pending_count std::vector< CpuCacheLineIsolated < i64 > > local_consume_count","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#detailed-description","text":"1 2 template < typename Branch > class batt :: detail :: ParallelModelCheckState ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#using-shardmetrics","text":"1 using batt :: detail :: ParallelModelCheckState < Branch >:: ShardMetrics = ModelCheckShardMetrics ;","title":"using ShardMetrics"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-parallelmodelcheckstate","text":"1 2 3 inline explicit ParallelModelCheckState ( usize n_shards )","title":"function ParallelModelCheckState"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-find_shard","text":"1 2 3 inline usize find_shard ( const Branch & branch ) const","title":"function find_shard"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-send","text":"1 2 3 4 5 inline void send ( usize src_i , usize dst_i , Branch && branch )","title":"function send"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-flush_all","text":"1 2 3 inline void flush_all ( usize src_i )","title":"function flush_all"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-queue_push","text":"1 2 3 4 inline void queue_push ( usize dst_i , std :: vector < Branch > * branch )","title":"function queue_push"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-recv","text":"1 2 3 4 inline StatusOr < usize > recv ( usize shard_i , std :: deque < Branch > & local_queue )","title":"function recv"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-close_all","text":"1 2 3 4 inline void close_all ( usize shard_i , bool allow_pending = false )","title":"function close_all"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-finished","text":"1 2 3 inline void finished ( usize shard_i )","title":"function finished"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-metrics","text":"1 2 3 inline ShardMetrics & metrics ( usize shard_i )","title":"function metrics"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-wait_for_other_shards","text":"1 inline Status wait_for_other_shards ()","title":"function wait_for_other_shards"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-kstallepochunit","text":"1 static constexpr u64 kStallEpochUnit = u64 { 1 } << 32 ;","title":"variable kStallEpochUnit"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-kstallcountmask","text":"1 static constexpr u64 kStallCountMask = kStallEpochUnit - 1 ;","title":"variable kStallCountMask"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-kstallepochmask","text":"1 static constexpr u64 kStallEpochMask = ~ kStallCountMask ;","title":"variable kStallEpochMask"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-shard_count","text":"1 const usize shard_count ;","title":"variable shard_count"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-hash_space_per_shard","text":"1 const usize hash_space_per_shard = std :: numeric_limits < usize >:: max () / this -> shard_count ;","title":"variable hash_space_per_shard"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-barrier_","text":"1 Watch < usize > barrier_ { this -> shard_count };","title":"variable barrier_"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-queue_push_count","text":"1 std :: atomic < i64 > queue_push_count { 0 };","title":"variable queue_push_count"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-queue_pop_count","text":"1 std :: atomic < i64 > queue_pop_count { 0 };","title":"variable queue_pop_count"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-stalled","text":"1 std :: vector < std :: unique_ptr < std :: atomic < bool > [] > > stalled ;","title":"variable stalled"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-recv_queues","text":"1 std :: vector < std :: unique_ptr < Queue < std :: vector < Branch > > > > recv_queues ;","title":"variable recv_queues"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-send_queues","text":"1 std :: vector < CpuCacheLineIsolated < std :: vector < std :: vector < Branch > > > > send_queues ;","title":"variable send_queues"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-shard_metrics","text":"1 std :: vector < CpuCacheLineIsolated < ShardMetrics > > shard_metrics ;","title":"variable shard_metrics"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-total_pending_count","text":"1 CpuCacheLineIsolated < std :: atomic < i64 > > total_pending_count { 0 };","title":"variable total_pending_count"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-local_consume_count","text":"1 std :: vector < CpuCacheLineIsolated < i64 > > local_consume_count ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable local_consume_count"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/","text":"batt::detail::SigInfoHandler \ud83d\udd17 Public Types \ud83d\udd17 Name using batt::Optional < boost::asio::executor_work_guard< boost::asio::io_context::executor_type > > WorkGuard Public Functions \ud83d\udd17 Name SigInfoHandler & instance () SigInfoHandler () void start () void halt () void join () void operator() (const boost::system::error_code & ec, int signal_n) Public Attributes \ud83d\udd17 Name constexpr int kSignalNum Public Types Documentation \ud83d\udd17 using WorkGuard \ud83d\udd17 1 using batt :: detail :: SigInfoHandler :: WorkGuard = batt :: Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type > > ; Public Functions Documentation \ud83d\udd17 function instance \ud83d\udd17 1 static inline SigInfoHandler & instance () function SigInfoHandler \ud83d\udd17 1 inline SigInfoHandler () function start \ud83d\udd17 1 inline void start () function halt \ud83d\udd17 1 inline void halt () function join \ud83d\udd17 1 inline void join () function operator() \ud83d\udd17 1 2 3 4 inline void operator ()( const boost :: system :: error_code & ec , int signal_n ) Public Attributes Documentation \ud83d\udd17 variable kSignalNum \ud83d\udd17 1 2 3 4 5 static constexpr int kSignalNum = SIGINFO ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::SigInfoHandler"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-types","text":"Name using batt::Optional < boost::asio::executor_work_guard< boost::asio::io_context::executor_type > > WorkGuard","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-functions","text":"Name SigInfoHandler & instance () SigInfoHandler () void start () void halt () void join () void operator() (const boost::system::error_code & ec, int signal_n)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-attributes","text":"Name constexpr int kSignalNum","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#using-workguard","text":"1 using batt :: detail :: SigInfoHandler :: WorkGuard = batt :: Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type > > ;","title":"using WorkGuard"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-instance","text":"1 static inline SigInfoHandler & instance ()","title":"function instance"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-siginfohandler","text":"1 inline SigInfoHandler ()","title":"function SigInfoHandler"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-start","text":"1 inline void start ()","title":"function start"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-halt","text":"1 inline void halt ()","title":"function halt"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-join","text":"1 inline void join ()","title":"function join"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-operator","text":"1 2 3 4 inline void operator ()( const boost :: system :: error_code & ec , int signal_n )","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#variable-ksignalnum","text":"1 2 3 4 5 static constexpr int kSignalNum = SIGINFO ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kSignalNum"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/","text":"batt::detail::StatusBase \ud83d\udd17 Inherited by batt::Status Public Functions \ud83d\udd17 Name StatusBase () Public Functions Documentation \ud83d\udd17 function StatusBase \ud83d\udd17 1 inline StatusBase () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::StatusBase"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/#public-functions","text":"Name StatusBase ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/#function-statusbase","text":"1 inline StatusBase () Updated on 26 August 2022 at 17:30:03 UTC","title":"function StatusBase"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/","text":"batt::detail::StatusOrValueContainer \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename... Args> void construct (Args &&... args) T * pointer () const T * pointer () const T & reference () const T & reference () const void destroy () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: detail :: StatusOrValueContainer ; Public Functions Documentation \ud83d\udd17 function construct \ud83d\udd17 1 2 3 4 template < typename ... Args > inline void construct ( Args && ... args ) function pointer \ud83d\udd17 1 inline T * pointer () function pointer \ud83d\udd17 1 inline const T * pointer () const function reference \ud83d\udd17 1 inline T & reference () function reference \ud83d\udd17 1 inline const T & reference () const function destroy \ud83d\udd17 1 inline void destroy () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::StatusOrValueContainer"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#public-functions","text":"Name template <typename... Args> void construct (Args &&... args) T * pointer () const T * pointer () const T & reference () const T & reference () const void destroy ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#detailed-description","text":"1 2 template < typename T > class batt :: detail :: StatusOrValueContainer ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-construct","text":"1 2 3 4 template < typename ... Args > inline void construct ( Args && ... args )","title":"function construct"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-pointer","text":"1 inline T * pointer ()","title":"function pointer"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-pointer_1","text":"1 inline const T * pointer () const","title":"function pointer"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-reference","text":"1 inline T & reference ()","title":"function reference"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-reference_1","text":"1 inline const T & reference () const","title":"function reference"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-destroy","text":"1 inline void destroy () Updated on 26 August 2022 at 17:30:03 UTC","title":"function destroy"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/","text":"batt::detail::StatusOrValueContainer< T & > \ud83d\udd17 More... Public Functions \ud83d\udd17 Name void construct (T & obj) T * pointer () const T & reference () const void destroy () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: detail :: StatusOrValueContainer < T & > ; Public Functions Documentation \ud83d\udd17 function construct \ud83d\udd17 1 2 3 inline void construct ( T & obj ) function pointer \ud83d\udd17 1 inline T * pointer () const function reference \ud83d\udd17 1 inline T & reference () const function destroy \ud83d\udd17 1 inline void destroy () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::StatusOrValueContainer< T & >"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#public-functions","text":"Name void construct (T & obj) T * pointer () const T & reference () const void destroy ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#detailed-description","text":"1 2 template < typename T > class batt :: detail :: StatusOrValueContainer < T & > ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-construct","text":"1 2 3 inline void construct ( T & obj )","title":"function construct"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-pointer","text":"1 inline T * pointer () const","title":"function pointer"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-reference","text":"1 inline T & reference () const","title":"function reference"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-destroy","text":"1 inline void destroy () Updated on 26 August 2022 at 17:30:03 UTC","title":"function destroy"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/","text":"batt::kMoveOnly \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SmallFn self_type using Result result_type Public Functions \ud83d\udd17 Name SmallFn () =default template <typename Fn ,typename =EnableIfNoShadow ,typename =std::enable_if_t {}>> SmallFn (Fn && fn) SmallFn ( self_type && that) SmallFn (const self_type & that) Public Attributes \ud83d\udd17 Name copy_to_move_only storage_ AbstractFn * impl_ Friends \ud83d\udd17 Name class SmallFn Detailed Description \ud83d\udd17 1 2 3 4 5 template < typename ... Args , typename Result , usize kMaxSize , bool kMoveOnly > class batt :: kMoveOnly ; Public Types Documentation \ud83d\udd17 using self_type \ud83d\udd17 1 using batt :: kMoveOnly < Args , Result , kMaxSize , kMoveOnly >:: self_type = SmallFn ; using result_type \ud83d\udd17 1 using batt :: kMoveOnly < Args , Result , kMaxSize , kMoveOnly >:: result_type = Result ; Public Functions Documentation \ud83d\udd17 function SmallFn \ud83d\udd17 1 SmallFn () = default function SmallFn \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename = EnableIfNoShadow < SmallFn , Fn > , typename = std :: enable_if_t < IsCallable < Fn , Args ... > {} >> inline SmallFn ( Fn && fn ) function SmallFn \ud83d\udd17 1 2 3 inline SmallFn ( self_type && that ) function SmallFn \ud83d\udd17 1 2 3 inline SmallFn ( const self_type & that ) Public Attributes Documentation \ud83d\udd17 variable storage_ \ud83d\udd17 1 copy_to_move_only storage_ ; variable impl_ \ud83d\udd17 1 AbstractFn * impl_ = nullptr ; Friends \ud83d\udd17 friend SmallFn \ud83d\udd17 1 friend class SmallFn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::kMoveOnly"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#public-types","text":"Name using SmallFn self_type using Result result_type","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#public-functions","text":"Name SmallFn () =default template <typename Fn ,typename =EnableIfNoShadow ,typename =std::enable_if_t {}>> SmallFn (Fn && fn) SmallFn ( self_type && that) SmallFn (const self_type & that)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#public-attributes","text":"Name copy_to_move_only storage_ AbstractFn * impl_","title":"Public Attributes"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#friends","text":"Name class SmallFn","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#detailed-description","text":"1 2 3 4 5 template < typename ... Args , typename Result , usize kMaxSize , bool kMoveOnly > class batt :: kMoveOnly ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#using-self_type","text":"1 using batt :: kMoveOnly < Args , Result , kMaxSize , kMoveOnly >:: self_type = SmallFn ;","title":"using self_type"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#using-result_type","text":"1 using batt :: kMoveOnly < Args , Result , kMaxSize , kMoveOnly >:: result_type = Result ;","title":"using result_type"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#function-smallfn","text":"1 SmallFn () = default","title":"function SmallFn"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#function-smallfn_1","text":"1 2 3 4 5 6 template < typename Fn , typename = EnableIfNoShadow < SmallFn , Fn > , typename = std :: enable_if_t < IsCallable < Fn , Args ... > {} >> inline SmallFn ( Fn && fn )","title":"function SmallFn"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#function-smallfn_2","text":"1 2 3 inline SmallFn ( self_type && that )","title":"function SmallFn"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#function-smallfn_3","text":"1 2 3 inline SmallFn ( const self_type & that )","title":"function SmallFn"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#variable-storage_","text":"1 copy_to_move_only storage_ ;","title":"variable storage_"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#variable-impl_","text":"1 AbstractFn * impl_ = nullptr ;","title":"variable impl_"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1kMoveOnly/#friend-smallfn","text":"1 friend class SmallFn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend SmallFn"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/","text":"batt::seq::Attach \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item using Data UserData Public Functions \ud83d\udd17 Name Attach (Seq && seq, Data && data) Data & user_data () const Data & user_data () const Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Data > class batt :: seq :: Attach ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: Attach < Seq , Data >:: Item = SeqItem < Seq > ; using UserData \ud83d\udd17 1 using batt :: seq :: Attach < Seq , Data >:: UserData = Data ; Public Functions Documentation \ud83d\udd17 function Attach \ud83d\udd17 1 2 3 4 inline explicit Attach ( Seq && seq , Data && data ) function user_data \ud83d\udd17 1 inline Data & user_data () function user_data \ud83d\udd17 1 inline const Data & user_data () const function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Attach"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-types","text":"Name using SeqItem< Seq > Item using Data UserData","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-functions","text":"Name Attach (Seq && seq, Data && data) Data & user_data () const Data & user_data () const Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#detailed-description","text":"1 2 3 template < typename Seq , typename Data > class batt :: seq :: Attach ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#using-item","text":"1 using batt :: seq :: Attach < Seq , Data >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#using-userdata","text":"1 using batt :: seq :: Attach < Seq , Data >:: UserData = Data ;","title":"using UserData"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-attach","text":"1 2 3 4 inline explicit Attach ( Seq && seq , Data && data )","title":"function Attach"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-user_data","text":"1 inline Data & user_data ()","title":"function user_data"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-user_data_1","text":"1 inline const Data & user_data () const","title":"function user_data"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/","text":"batt::seq::CacheNext \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name CacheNext (Seq && seq) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename Seq > class batt :: seq :: CacheNext ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: CacheNext < Seq >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function CacheNext \ud83d\udd17 1 2 3 inline explicit CacheNext ( Seq && seq ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::CacheNext"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-functions","text":"Name CacheNext (Seq && seq) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#detailed-description","text":"1 2 template < typename Seq > class batt :: seq :: CacheNext ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#using-item","text":"1 using batt :: seq :: CacheNext < Seq >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#function-cachenext","text":"1 2 3 inline explicit CacheNext ( Seq && seq )","title":"function CacheNext"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/","text":"batt::seq::Chain \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< SeqItem< Seq1 >, SeqItem< Seq2 > > Item Public Functions \ud83d\udd17 Name Chain (Seq1 && seq1, Seq2 && seq2) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq1 , typename Seq2 > class batt :: seq :: Chain ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: Chain < Seq1 , Seq2 >:: Item = std :: common_type_t < SeqItem < Seq1 > , SeqItem < Seq2 > > ; Public Functions Documentation \ud83d\udd17 function Chain \ud83d\udd17 1 2 3 4 inline explicit Chain ( Seq1 && seq1 , Seq2 && seq2 ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Chain"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-types","text":"Name using std::common_type_t< SeqItem< Seq1 >, SeqItem< Seq2 > > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-functions","text":"Name Chain (Seq1 && seq1, Seq2 && seq2) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#detailed-description","text":"1 2 3 template < typename Seq1 , typename Seq2 > class batt :: seq :: Chain ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#using-item","text":"1 using batt :: seq :: Chain < Seq1 , Seq2 >:: Item = std :: common_type_t < SeqItem < Seq1 > , SeqItem < Seq2 > > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#function-chain","text":"1 2 3 4 inline explicit Chain ( Seq1 && seq1 , Seq2 && seq2 )","title":"function Chain"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/","text":"batt::seq::Empty \ud83d\udd17 More... Public Types \ud83d\udd17 Name using T Item Public Functions \ud83d\udd17 Name Optional < T > peek () Optional < T > next () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: seq :: Empty ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: Empty < T >:: Item = T ; Public Functions Documentation \ud83d\udd17 function peek \ud83d\udd17 1 inline Optional < T > peek () function next \ud83d\udd17 1 inline Optional < T > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Empty"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-types","text":"Name using T Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-functions","text":"Name Optional < T > peek () Optional < T > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#detailed-description","text":"1 2 template < typename T > class batt :: seq :: Empty ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#using-item","text":"1 using batt :: seq :: Empty < T >:: Item = T ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#function-peek","text":"1 inline Optional < T > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#function-next","text":"1 inline Optional < T > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/","text":"batt::seq::Filter \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name Filter (Seq && seq, Predicate && predicate) Filter ( Filter && that) Filter & operator= ( Filter && that) Filter (const Filter & that) Filter & operator= (const Filter & that) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Predicate > class batt :: seq :: Filter ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: Filter < Seq , Predicate >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function Filter \ud83d\udd17 1 2 3 4 inline explicit Filter ( Seq && seq , Predicate && predicate ) function Filter \ud83d\udd17 1 2 3 inline Filter ( Filter && that ) function operator= \ud83d\udd17 1 2 3 inline Filter & operator = ( Filter && that ) function Filter \ud83d\udd17 1 2 3 inline Filter ( const Filter & that ) function operator= \ud83d\udd17 1 2 3 inline Filter & operator = ( const Filter & that ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Filter"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-functions","text":"Name Filter (Seq && seq, Predicate && predicate) Filter ( Filter && that) Filter & operator= ( Filter && that) Filter (const Filter & that) Filter & operator= (const Filter & that) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#detailed-description","text":"1 2 3 template < typename Seq , typename Predicate > class batt :: seq :: Filter ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#using-item","text":"1 using batt :: seq :: Filter < Seq , Predicate >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-filter","text":"1 2 3 4 inline explicit Filter ( Seq && seq , Predicate && predicate )","title":"function Filter"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-filter_1","text":"1 2 3 inline Filter ( Filter && that )","title":"function Filter"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-operator","text":"1 2 3 inline Filter & operator = ( Filter && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-filter_2","text":"1 2 3 inline Filter ( const Filter & that )","title":"function Filter"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-operator_1","text":"1 2 3 inline Filter & operator = ( const Filter & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/","text":"batt::seq::FilterMap \ud83d\udd17 More... Public Types \ud83d\udd17 Name using decltype(filter_map_impl< Seq, Fn >(std::declval< Seq >(), std::declval< Fn >())) impl_type using SeqItem< impl_type > Item Public Functions \ud83d\udd17 Name FilterMap (Seq && seq, Fn && fn) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Fn > class batt :: seq :: FilterMap ; Public Types Documentation \ud83d\udd17 using impl_type \ud83d\udd17 1 using batt :: seq :: FilterMap < Seq , Fn >:: impl_type = decltype ( filter_map_impl < Seq , Fn > ( std :: declval < Seq > (), std :: declval < Fn > ())); using Item \ud83d\udd17 1 using batt :: seq :: FilterMap < Seq , Fn >:: Item = SeqItem < impl_type > ; Public Functions Documentation \ud83d\udd17 function FilterMap \ud83d\udd17 1 2 3 4 inline explicit FilterMap ( Seq && seq , Fn && fn ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::FilterMap"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-types","text":"Name using decltype(filter_map_impl< Seq, Fn >(std::declval< Seq >(), std::declval< Fn >())) impl_type using SeqItem< impl_type > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-functions","text":"Name FilterMap (Seq && seq, Fn && fn) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#detailed-description","text":"1 2 3 template < typename Seq , typename Fn > class batt :: seq :: FilterMap ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#using-impl_type","text":"1 using batt :: seq :: FilterMap < Seq , Fn >:: impl_type = decltype ( filter_map_impl < Seq , Fn > ( std :: declval < Seq > (), std :: declval < Fn > ()));","title":"using impl_type"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#using-item","text":"1 using batt :: seq :: FilterMap < Seq , Fn >:: Item = SeqItem < impl_type > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#function-filtermap","text":"1 2 3 4 inline explicit FilterMap ( Seq && seq , Fn && fn )","title":"function FilterMap"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/","text":"batt::seq::Flatten \ud83d\udd17 More... Public Types \ud83d\udd17 Name using InnerSeqT InnerSeq using SeqItem< InnerSeq > Item Public Functions \ud83d\udd17 Name Flatten (OuterSeq && outer) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename OuterSeq , typename InnerSeqT = std :: decay_t < SeqItem < OuterSeq >>> class batt :: seq :: Flatten ; Public Types Documentation \ud83d\udd17 using InnerSeq \ud83d\udd17 1 using batt :: seq :: Flatten < OuterSeq , InnerSeqT >:: InnerSeq = InnerSeqT ; using Item \ud83d\udd17 1 using batt :: seq :: Flatten < OuterSeq , InnerSeqT >:: Item = SeqItem < InnerSeq > ; Public Functions Documentation \ud83d\udd17 function Flatten \ud83d\udd17 1 2 3 inline explicit Flatten ( OuterSeq && outer ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Flatten"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-types","text":"Name using InnerSeqT InnerSeq using SeqItem< InnerSeq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-functions","text":"Name Flatten (OuterSeq && outer) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#detailed-description","text":"1 2 3 template < typename OuterSeq , typename InnerSeqT = std :: decay_t < SeqItem < OuterSeq >>> class batt :: seq :: Flatten ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#using-innerseq","text":"1 using batt :: seq :: Flatten < OuterSeq , InnerSeqT >:: InnerSeq = InnerSeqT ;","title":"using InnerSeq"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#using-item","text":"1 using batt :: seq :: Flatten < OuterSeq , InnerSeqT >:: Item = SeqItem < InnerSeq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#function-flatten","text":"1 2 3 inline explicit Flatten ( OuterSeq && outer )","title":"function Flatten"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/","text":"batt::seq::Fuse \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > OptionalItem using typename std::decay_t< OptionalItem >::value_type Item Public Functions \ud83d\udd17 Name Fuse (Seq && seq) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename Seq > class batt :: seq :: Fuse ; Public Types Documentation \ud83d\udd17 using OptionalItem \ud83d\udd17 1 using batt :: seq :: Fuse < Seq >:: OptionalItem = SeqItem < Seq > ; using Item \ud83d\udd17 1 using batt :: seq :: Fuse < Seq >:: Item = typename std :: decay_t < OptionalItem >:: value_type ; Public Functions Documentation \ud83d\udd17 function Fuse \ud83d\udd17 1 2 3 inline explicit Fuse ( Seq && seq ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Fuse"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-types","text":"Name using SeqItem< Seq > OptionalItem using typename std::decay_t< OptionalItem >::value_type Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-functions","text":"Name Fuse (Seq && seq) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#detailed-description","text":"1 2 template < typename Seq > class batt :: seq :: Fuse ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#using-optionalitem","text":"1 using batt :: seq :: Fuse < Seq >:: OptionalItem = SeqItem < Seq > ;","title":"using OptionalItem"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#using-item","text":"1 using batt :: seq :: Fuse < Seq >:: Item = typename std :: decay_t < OptionalItem >:: value_type ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#function-fuse","text":"1 2 3 inline explicit Fuse ( Seq && seq )","title":"function Fuse"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/","text":"batt::seq::GroupBy \ud83d\udd17 More... Public Classes \ud83d\udd17 Name class SubGroup Public Types \ud83d\udd17 Name using SeqItem< Seq > SubGroupItem using SubGroup Item Public Functions \ud83d\udd17 Name void detach ( SubGroup * sub_group, bool skip_advance) GroupBy (Seq && seq, GroupEq && group_eq) GroupBy (Seq && seq, GroupEq && group_eq, Optional < SubGroupItem > && next_item) ~GroupBy () GroupBy ( GroupBy && that) GroupBy & operator= ( GroupBy && that) GroupBy (const GroupBy & that) GroupBy & operator= (const GroupBy & that) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename GroupEq > class batt :: seq :: GroupBy ; Public Types Documentation \ud83d\udd17 using SubGroupItem \ud83d\udd17 1 using batt :: seq :: GroupBy < Seq , GroupEq >:: SubGroupItem = SeqItem < Seq > ; using Item \ud83d\udd17 1 using batt :: seq :: GroupBy < Seq , GroupEq >:: Item = SubGroup ; Public Functions Documentation \ud83d\udd17 function detach \ud83d\udd17 1 2 3 4 static inline void detach ( SubGroup * sub_group , bool skip_advance ) function GroupBy \ud83d\udd17 1 2 3 4 inline explicit GroupBy ( Seq && seq , GroupEq && group_eq ) function GroupBy \ud83d\udd17 1 2 3 4 5 inline explicit GroupBy ( Seq && seq , GroupEq && group_eq , Optional < SubGroupItem > && next_item ) function ~GroupBy \ud83d\udd17 1 inline ~ GroupBy () function GroupBy \ud83d\udd17 1 2 3 inline GroupBy ( GroupBy && that ) function operator= \ud83d\udd17 1 2 3 inline GroupBy & operator = ( GroupBy && that ) function GroupBy \ud83d\udd17 1 2 3 inline GroupBy ( const GroupBy & that ) function operator= \ud83d\udd17 1 2 3 inline GroupBy & operator = ( const GroupBy & that ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::GroupBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-classes","text":"Name class SubGroup","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-types","text":"Name using SeqItem< Seq > SubGroupItem using SubGroup Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-functions","text":"Name void detach ( SubGroup * sub_group, bool skip_advance) GroupBy (Seq && seq, GroupEq && group_eq) GroupBy (Seq && seq, GroupEq && group_eq, Optional < SubGroupItem > && next_item) ~GroupBy () GroupBy ( GroupBy && that) GroupBy & operator= ( GroupBy && that) GroupBy (const GroupBy & that) GroupBy & operator= (const GroupBy & that) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#detailed-description","text":"1 2 3 template < typename Seq , typename GroupEq > class batt :: seq :: GroupBy ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#using-subgroupitem","text":"1 using batt :: seq :: GroupBy < Seq , GroupEq >:: SubGroupItem = SeqItem < Seq > ;","title":"using SubGroupItem"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#using-item","text":"1 using batt :: seq :: GroupBy < Seq , GroupEq >:: Item = SubGroup ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-detach","text":"1 2 3 4 static inline void detach ( SubGroup * sub_group , bool skip_advance )","title":"function detach"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby","text":"1 2 3 4 inline explicit GroupBy ( Seq && seq , GroupEq && group_eq )","title":"function GroupBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_1","text":"1 2 3 4 5 inline explicit GroupBy ( Seq && seq , GroupEq && group_eq , Optional < SubGroupItem > && next_item )","title":"function GroupBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_2","text":"1 inline ~ GroupBy ()","title":"function ~GroupBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_3","text":"1 2 3 inline GroupBy ( GroupBy && that )","title":"function GroupBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-operator","text":"1 2 3 inline GroupBy & operator = ( GroupBy && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_4","text":"1 2 3 inline GroupBy ( const GroupBy & that )","title":"function GroupBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-operator_1","text":"1 2 3 inline GroupBy & operator = ( const GroupBy & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/","text":"batt::seq::GroupBy::SubGroup \ud83d\udd17 Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name SubGroup ( SubGroup && that) SubGroup (const SubGroup & that) ~SubGroup () SubGroup & operator= ( SubGroup && that) SubGroup & operator= (const SubGroup & that) bool is_detached () const Optional < Item > peek () Optional < Item > next () Friends \ud83d\udd17 Name class GroupBy< Seq, GroupEq > Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: GroupBy < Seq , GroupEq >:: SubGroup :: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function SubGroup \ud83d\udd17 1 2 3 inline SubGroup ( SubGroup && that ) function SubGroup \ud83d\udd17 1 2 3 inline SubGroup ( const SubGroup & that ) function ~SubGroup \ud83d\udd17 1 inline ~ SubGroup () function operator= \ud83d\udd17 1 2 3 inline SubGroup & operator = ( SubGroup && that ) function operator= \ud83d\udd17 1 2 3 inline SubGroup & operator = ( const SubGroup & that ) function is_detached \ud83d\udd17 1 inline bool is_detached () const function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Friends \ud83d\udd17 friend GroupBy< Seq, GroupEq > \ud83d\udd17 1 friend class GroupBy < Seq , GroupEq > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::GroupBy::SubGroup"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-functions","text":"Name SubGroup ( SubGroup && that) SubGroup (const SubGroup & that) ~SubGroup () SubGroup & operator= ( SubGroup && that) SubGroup & operator= (const SubGroup & that) bool is_detached () const Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#friends","text":"Name class GroupBy< Seq, GroupEq >","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#using-item","text":"1 using batt :: seq :: GroupBy < Seq , GroupEq >:: SubGroup :: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-subgroup","text":"1 2 3 inline SubGroup ( SubGroup && that )","title":"function SubGroup"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-subgroup_1","text":"1 2 3 inline SubGroup ( const SubGroup & that )","title":"function SubGroup"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-subgroup_2","text":"1 inline ~ SubGroup ()","title":"function ~SubGroup"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-operator","text":"1 2 3 inline SubGroup & operator = ( SubGroup && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-operator_1","text":"1 2 3 inline SubGroup & operator = ( const SubGroup & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-is_detached","text":"1 inline bool is_detached () const","title":"function is_detached"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-next","text":"1 inline Optional < Item > next ()","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#friend-groupby-seq-groupeq","text":"1 friend class GroupBy < Seq , GroupEq > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"friend GroupBy&lt; Seq, GroupEq &gt;"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/","text":"batt::seq::InspectAdjacent \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name InspectAdjacent (Seq && seq, Fn && fn) InspectAdjacent ( InspectAdjacent && that) InspectAdjacent & operator= ( InspectAdjacent && that) InspectAdjacent (const InspectAdjacent & that) InspectAdjacent & operator= (const InspectAdjacent & that) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Fn > class batt :: seq :: InspectAdjacent ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: InspectAdjacent < Seq , Fn >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function InspectAdjacent \ud83d\udd17 1 2 3 4 inline explicit InspectAdjacent ( Seq && seq , Fn && fn ) function InspectAdjacent \ud83d\udd17 1 2 3 inline InspectAdjacent ( InspectAdjacent && that ) function operator= \ud83d\udd17 1 2 3 inline InspectAdjacent & operator = ( InspectAdjacent && that ) function InspectAdjacent \ud83d\udd17 1 2 3 inline InspectAdjacent ( const InspectAdjacent & that ) function operator= \ud83d\udd17 1 2 3 inline InspectAdjacent & operator = ( const InspectAdjacent & that ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::InspectAdjacent"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-functions","text":"Name InspectAdjacent (Seq && seq, Fn && fn) InspectAdjacent ( InspectAdjacent && that) InspectAdjacent & operator= ( InspectAdjacent && that) InspectAdjacent (const InspectAdjacent & that) InspectAdjacent & operator= (const InspectAdjacent & that) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#detailed-description","text":"1 2 3 template < typename Seq , typename Fn > class batt :: seq :: InspectAdjacent ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#using-item","text":"1 using batt :: seq :: InspectAdjacent < Seq , Fn >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-inspectadjacent","text":"1 2 3 4 inline explicit InspectAdjacent ( Seq && seq , Fn && fn )","title":"function InspectAdjacent"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-inspectadjacent_1","text":"1 2 3 inline InspectAdjacent ( InspectAdjacent && that )","title":"function InspectAdjacent"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-operator","text":"1 2 3 inline InspectAdjacent & operator = ( InspectAdjacent && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-inspectadjacent_2","text":"1 2 3 inline InspectAdjacent ( const InspectAdjacent & that )","title":"function InspectAdjacent"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-operator_1","text":"1 2 3 inline InspectAdjacent & operator = ( const InspectAdjacent & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/","text":"batt::seq::KMergeBy \ud83d\udd17 More... Public Classes \ud83d\udd17 Name struct HeapOrder Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name template <typename KSeqs > KMergeBy (KSeqs && k_seqs, Compare && compare) KMergeBy (const KMergeBy & that) KMergeBy & operator= (const KMergeBy & that) Optional < Item > next () Optional < Item > peek () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Compare > class batt :: seq :: KMergeBy ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: KMergeBy < Seq , Compare >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function KMergeBy \ud83d\udd17 1 2 3 4 5 template < typename KSeqs > inline explicit KMergeBy ( KSeqs && k_seqs , Compare && compare ) function KMergeBy \ud83d\udd17 1 2 3 inline KMergeBy ( const KMergeBy & that ) function operator= \ud83d\udd17 1 2 3 inline KMergeBy & operator = ( const KMergeBy & that ) function next \ud83d\udd17 1 inline Optional < Item > next () function peek \ud83d\udd17 1 inline Optional < Item > peek () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::KMergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-classes","text":"Name struct HeapOrder","title":"Public Classes"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-functions","text":"Name template <typename KSeqs > KMergeBy (KSeqs && k_seqs, Compare && compare) KMergeBy (const KMergeBy & that) KMergeBy & operator= (const KMergeBy & that) Optional < Item > next () Optional < Item > peek ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#detailed-description","text":"1 2 3 template < typename Seq , typename Compare > class batt :: seq :: KMergeBy ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#using-item","text":"1 using batt :: seq :: KMergeBy < Seq , Compare >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-kmergeby","text":"1 2 3 4 5 template < typename KSeqs > inline explicit KMergeBy ( KSeqs && k_seqs , Compare && compare )","title":"function KMergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-kmergeby_1","text":"1 2 3 inline KMergeBy ( const KMergeBy & that )","title":"function KMergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-operator","text":"1 2 3 inline KMergeBy & operator = ( const KMergeBy & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-next","text":"1 inline Optional < Item > next ()","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-peek","text":"1 inline Optional < Item > peek () Updated on 26 August 2022 at 17:30:03 UTC","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/","text":"batt::seq::Lazy \ud83d\udd17 More... Public Types \ud83d\udd17 Name using decltype(std::declval< Fn >()()) Seq using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name Lazy (Fn && fn) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename Fn > class batt :: seq :: Lazy ; Public Types Documentation \ud83d\udd17 using Seq \ud83d\udd17 1 using batt :: seq :: Lazy < Fn >:: Seq = decltype ( std :: declval < Fn > ()()); using Item \ud83d\udd17 1 using batt :: seq :: Lazy < Fn >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function Lazy \ud83d\udd17 1 2 3 inline explicit Lazy ( Fn && fn ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Lazy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-types","text":"Name using decltype(std::declval< Fn >()()) Seq using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-functions","text":"Name Lazy (Fn && fn) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#detailed-description","text":"1 2 template < typename Fn > class batt :: seq :: Lazy ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#using-seq","text":"1 using batt :: seq :: Lazy < Fn >:: Seq = decltype ( std :: declval < Fn > ()());","title":"using Seq"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#using-item","text":"1 using batt :: seq :: Lazy < Fn >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#function-lazy","text":"1 2 3 inline explicit Lazy ( Fn && fn )","title":"function Lazy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/","text":"batt::seq::Map \ud83d\udd17 More... Public Types \ud83d\udd17 Name using batt::DecayRValueRef< std::invoke_result_t< MapFn, SeqItem< Seq > >> Item Public Functions \ud83d\udd17 Name Map (Seq && seq, MapFn && map_fn) Map ( Map && that) Map (const Map & that) Map & operator= ( Map && that) Map & operator= (const Map & that) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename MapFn > class batt :: seq :: Map ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: Map < Seq , MapFn >:: Item = batt :: DecayRValueRef < std :: invoke_result_t < MapFn , SeqItem < Seq > >> ; Public Functions Documentation \ud83d\udd17 function Map \ud83d\udd17 1 2 3 4 inline explicit Map ( Seq && seq , MapFn && map_fn ) function Map \ud83d\udd17 1 2 3 inline Map ( Map && that ) function Map \ud83d\udd17 1 2 3 inline Map ( const Map & that ) function operator= \ud83d\udd17 1 2 3 inline Map & operator = ( Map && that ) function operator= \ud83d\udd17 1 2 3 inline Map & operator = ( const Map & that ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Map"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-types","text":"Name using batt::DecayRValueRef< std::invoke_result_t< MapFn, SeqItem< Seq > >> Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-functions","text":"Name Map (Seq && seq, MapFn && map_fn) Map ( Map && that) Map (const Map & that) Map & operator= ( Map && that) Map & operator= (const Map & that) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#detailed-description","text":"1 2 3 template < typename Seq , typename MapFn > class batt :: seq :: Map ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#using-item","text":"1 using batt :: seq :: Map < Seq , MapFn >:: Item = batt :: DecayRValueRef < std :: invoke_result_t < MapFn , SeqItem < Seq > >> ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-map","text":"1 2 3 4 inline explicit Map ( Seq && seq , MapFn && map_fn )","title":"function Map"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-map_1","text":"1 2 3 inline Map ( Map && that )","title":"function Map"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-map_2","text":"1 2 3 inline Map ( const Map & that )","title":"function Map"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-operator","text":"1 2 3 inline Map & operator = ( Map && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-operator_1","text":"1 2 3 inline Map & operator = ( const Map & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/","text":"batt::seq::MapAdjacent \ud83d\udd17 More... Public Types \ud83d\udd17 Name using decltype(std::declval< Fn & >()(std::declval< const SeqItem< Seq > & >(), std::declval< const SeqItem< Seq > & >())) Item Public Functions \ud83d\udd17 Name MapAdjacent (Seq && seq, Fn && fn) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Fn > class batt :: seq :: MapAdjacent ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: MapAdjacent < Seq , Fn >:: Item = decltype ( std :: declval < Fn &> ()( std :: declval < const SeqItem < Seq >&> (), std :: declval < const SeqItem < Seq >&> ())); Public Functions Documentation \ud83d\udd17 function MapAdjacent \ud83d\udd17 1 2 3 4 inline explicit MapAdjacent ( Seq && seq , Fn && fn ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapAdjacent"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-types","text":"Name using decltype(std::declval< Fn & >()(std::declval< const SeqItem< Seq > & >(), std::declval< const SeqItem< Seq > & >())) Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-functions","text":"Name MapAdjacent (Seq && seq, Fn && fn) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#detailed-description","text":"1 2 3 template < typename Seq , typename Fn > class batt :: seq :: MapAdjacent ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#using-item","text":"1 using batt :: seq :: MapAdjacent < Seq , Fn >:: Item = decltype ( std :: declval < Fn &> ()( std :: declval < const SeqItem < Seq >&> (), std :: declval < const SeqItem < Seq >&> ()));","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#function-mapadjacent","text":"1 2 3 4 inline explicit MapAdjacent ( Seq && seq , Fn && fn )","title":"function MapAdjacent"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/","text":"batt::seq::MapFold \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::tuple_element_t< 1, std::invoke_result_t< MapFn, State, SeqItem< Seq > >> Item Public Functions \ud83d\udd17 Name MapFold (Seq && seq, State && state, MapFn && map_fn) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 4 template < typename Seq , typename State , typename MapFn > class batt :: seq :: MapFold ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: MapFold < Seq , State , MapFn >:: Item = std :: tuple_element_t < 1 , std :: invoke_result_t < MapFn , State , SeqItem < Seq > >> ; Public Functions Documentation \ud83d\udd17 function MapFold \ud83d\udd17 1 2 3 4 5 inline explicit MapFold ( Seq && seq , State && state , MapFn && map_fn ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapFold"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-types","text":"Name using std::tuple_element_t< 1, std::invoke_result_t< MapFn, State, SeqItem< Seq > >> Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-functions","text":"Name MapFold (Seq && seq, State && state, MapFn && map_fn) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#detailed-description","text":"1 2 3 4 template < typename Seq , typename State , typename MapFn > class batt :: seq :: MapFold ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#using-item","text":"1 using batt :: seq :: MapFold < Seq , State , MapFn >:: Item = std :: tuple_element_t < 1 , std :: invoke_result_t < MapFn , State , SeqItem < Seq > >> ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#function-mapfold","text":"1 2 3 4 5 inline explicit MapFold ( Seq && seq , State && state , MapFn && map_fn )","title":"function MapFold"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/","text":"batt::seq::MapPairwise \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::invoke_result_t< MapFn, SeqItem< LeftSeq >, SeqItem< RightSeq > > Item Public Functions \ud83d\udd17 Name MapPairwise (LeftSeq && left, RightSeq && right, MapFn && map_fn) MapPairwise ( MapPairwise && that) MapPairwise (const MapPairwise & that) MapPairwise & operator= ( MapPairwise && that) MapPairwise & operator= (const MapPairwise & that) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 4 template < typename LeftSeq , typename RightSeq , typename MapFn > class batt :: seq :: MapPairwise ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: MapPairwise < LeftSeq , RightSeq , MapFn >:: Item = std :: invoke_result_t < MapFn , SeqItem < LeftSeq > , SeqItem < RightSeq > > ; Public Functions Documentation \ud83d\udd17 function MapPairwise \ud83d\udd17 1 2 3 4 5 inline explicit MapPairwise ( LeftSeq && left , RightSeq && right , MapFn && map_fn ) function MapPairwise \ud83d\udd17 1 2 3 inline MapPairwise ( MapPairwise && that ) function MapPairwise \ud83d\udd17 1 2 3 inline MapPairwise ( const MapPairwise & that ) function operator= \ud83d\udd17 1 2 3 inline MapPairwise & operator = ( MapPairwise && that ) function operator= \ud83d\udd17 1 2 3 inline MapPairwise & operator = ( const MapPairwise & that ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapPairwise"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-types","text":"Name using std::invoke_result_t< MapFn, SeqItem< LeftSeq >, SeqItem< RightSeq > > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-functions","text":"Name MapPairwise (LeftSeq && left, RightSeq && right, MapFn && map_fn) MapPairwise ( MapPairwise && that) MapPairwise (const MapPairwise & that) MapPairwise & operator= ( MapPairwise && that) MapPairwise & operator= (const MapPairwise & that) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#detailed-description","text":"1 2 3 4 template < typename LeftSeq , typename RightSeq , typename MapFn > class batt :: seq :: MapPairwise ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#using-item","text":"1 using batt :: seq :: MapPairwise < LeftSeq , RightSeq , MapFn >:: Item = std :: invoke_result_t < MapFn , SeqItem < LeftSeq > , SeqItem < RightSeq > > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-mappairwise","text":"1 2 3 4 5 inline explicit MapPairwise ( LeftSeq && left , RightSeq && right , MapFn && map_fn )","title":"function MapPairwise"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-mappairwise_1","text":"1 2 3 inline MapPairwise ( MapPairwise && that )","title":"function MapPairwise"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-mappairwise_2","text":"1 2 3 inline MapPairwise ( const MapPairwise & that )","title":"function MapPairwise"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-operator","text":"1 2 3 inline MapPairwise & operator = ( MapPairwise && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-operator_1","text":"1 2 3 inline MapPairwise & operator = ( const MapPairwise & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/","text":"batt::seq::MergeBy \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::conditional_t< std::is_same_v< SeqItem< LeftSeq >, SeqItem< RightSeq > >, SeqItem< LeftSeq >, std::conditional_t< std::is_same_v< std::decay_t< SeqItem< LeftSeq > >, std::decay_t< SeqItem< RightSeq > >>, std::decay_t< SeqItem< LeftSeq > >, std::variant< std::decay_t< SeqItem< LeftSeq > >, std::decay_t< SeqItem< RightSeq > >> >> Item Public Functions \ud83d\udd17 Name MergeBy (LeftSeq && left, RightSeq && right, Compare && compare) MergeBy ( MergeBy && that) MergeBy & operator= ( MergeBy && that) MergeBy (const MergeBy & that) MergeBy & operator= (const MergeBy & that) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 4 template < typename LeftSeq , typename RightSeq , typename Compare > class batt :: seq :: MergeBy ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: MergeBy < LeftSeq , RightSeq , Compare >:: Item = std :: conditional_t < std :: is_same_v < SeqItem < LeftSeq > , SeqItem < RightSeq > > , SeqItem < LeftSeq > , std :: conditional_t < std :: is_same_v < std :: decay_t < SeqItem < LeftSeq > > , std :: decay_t < SeqItem < RightSeq > >> , std :: decay_t < SeqItem < LeftSeq > > , std :: variant < std :: decay_t < SeqItem < LeftSeq > > , std :: decay_t < SeqItem < RightSeq > >> >> ; Public Functions Documentation \ud83d\udd17 function MergeBy \ud83d\udd17 1 2 3 4 5 inline explicit MergeBy ( LeftSeq && left , RightSeq && right , Compare && compare ) function MergeBy \ud83d\udd17 1 2 3 inline MergeBy ( MergeBy && that ) function operator= \ud83d\udd17 1 2 3 inline MergeBy & operator = ( MergeBy && that ) function MergeBy \ud83d\udd17 1 2 3 inline MergeBy ( const MergeBy & that ) function operator= \ud83d\udd17 1 2 3 inline MergeBy & operator = ( const MergeBy & that ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-types","text":"Name using std::conditional_t< std::is_same_v< SeqItem< LeftSeq >, SeqItem< RightSeq > >, SeqItem< LeftSeq >, std::conditional_t< std::is_same_v< std::decay_t< SeqItem< LeftSeq > >, std::decay_t< SeqItem< RightSeq > >>, std::decay_t< SeqItem< LeftSeq > >, std::variant< std::decay_t< SeqItem< LeftSeq > >, std::decay_t< SeqItem< RightSeq > >> >> Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-functions","text":"Name MergeBy (LeftSeq && left, RightSeq && right, Compare && compare) MergeBy ( MergeBy && that) MergeBy & operator= ( MergeBy && that) MergeBy (const MergeBy & that) MergeBy & operator= (const MergeBy & that) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#detailed-description","text":"1 2 3 4 template < typename LeftSeq , typename RightSeq , typename Compare > class batt :: seq :: MergeBy ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#using-item","text":"1 using batt :: seq :: MergeBy < LeftSeq , RightSeq , Compare >:: Item = std :: conditional_t < std :: is_same_v < SeqItem < LeftSeq > , SeqItem < RightSeq > > , SeqItem < LeftSeq > , std :: conditional_t < std :: is_same_v < std :: decay_t < SeqItem < LeftSeq > > , std :: decay_t < SeqItem < RightSeq > >> , std :: decay_t < SeqItem < LeftSeq > > , std :: variant < std :: decay_t < SeqItem < LeftSeq > > , std :: decay_t < SeqItem < RightSeq > >> >> ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-mergeby","text":"1 2 3 4 5 inline explicit MergeBy ( LeftSeq && left , RightSeq && right , Compare && compare )","title":"function MergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-mergeby_1","text":"1 2 3 inline MergeBy ( MergeBy && that )","title":"function MergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-operator","text":"1 2 3 inline MergeBy & operator = ( MergeBy && that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-mergeby_2","text":"1 2 3 inline MergeBy ( const MergeBy & that )","title":"function MergeBy"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-operator_1","text":"1 2 3 inline MergeBy & operator = ( const MergeBy & that )","title":"function operator="},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/","text":"batt::seq::Printable \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name Printable (Seq && seq) Optional < Item > peek () Optional < Item > next () void operator() (std::ostream & out) Detailed Description \ud83d\udd17 1 2 template < typename Seq > class batt :: seq :: Printable ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: Printable < Seq >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function Printable \ud83d\udd17 1 2 3 inline explicit Printable ( Seq && seq ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () function operator() \ud83d\udd17 1 2 3 inline void operator ()( std :: ostream & out ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Printable"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-functions","text":"Name Printable (Seq && seq) Optional < Item > peek () Optional < Item > next () void operator() (std::ostream & out)","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#detailed-description","text":"1 2 template < typename Seq > class batt :: seq :: Printable ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#using-item","text":"1 using batt :: seq :: Printable < Seq >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-printable","text":"1 2 3 inline explicit Printable ( Seq && seq )","title":"function Printable"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-next","text":"1 inline Optional < Item > next ()","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-operator","text":"1 2 3 inline void operator ()( std :: ostream & out ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/","text":"batt::seq::SingleItem \ud83d\udd17 More... Public Types \ud83d\udd17 Name using T Item Public Functions \ud83d\udd17 Name SingleItem (T && item) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename T > class batt :: seq :: SingleItem ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: SingleItem < T >:: Item = T ; Public Functions Documentation \ud83d\udd17 function SingleItem \ud83d\udd17 1 2 3 inline explicit SingleItem ( T && item ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::SingleItem"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-types","text":"Name using T Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-functions","text":"Name SingleItem (T && item) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#detailed-description","text":"1 2 template < typename T > class batt :: seq :: SingleItem ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#using-item","text":"1 using batt :: seq :: SingleItem < T >:: Item = T ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#function-singleitem","text":"1 2 3 inline explicit SingleItem ( T && item )","title":"function SingleItem"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/","text":"batt::seq::Splice \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::add_lvalue_reference_t< OuterSeq > OuterSeqRef using Chain < TakeN < OuterSeqRef >, Chain < InnerSeq, OuterSeqRef > > Impl using SeqItem< Impl > Item Public Functions \ud83d\udd17 Name Splice (OuterSeq && outer_seq, std::size_t n, InnerSeq && inner_seq) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename OuterSeq , typename InnerSeq > class batt :: seq :: Splice ; Public Types Documentation \ud83d\udd17 using OuterSeqRef \ud83d\udd17 1 using batt :: seq :: Splice < OuterSeq , InnerSeq >:: OuterSeqRef = std :: add_lvalue_reference_t < OuterSeq > ; using Impl \ud83d\udd17 1 using batt :: seq :: Splice < OuterSeq , InnerSeq >:: Impl = Chain < TakeN < OuterSeqRef > , Chain < InnerSeq , OuterSeqRef > > ; using Item \ud83d\udd17 1 using batt :: seq :: Splice < OuterSeq , InnerSeq >:: Item = SeqItem < Impl > ; Public Functions Documentation \ud83d\udd17 function Splice \ud83d\udd17 1 2 3 4 5 inline explicit Splice ( OuterSeq && outer_seq , std :: size_t n , InnerSeq && inner_seq ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Splice"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-types","text":"Name using std::add_lvalue_reference_t< OuterSeq > OuterSeqRef using Chain < TakeN < OuterSeqRef >, Chain < InnerSeq, OuterSeqRef > > Impl using SeqItem< Impl > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-functions","text":"Name Splice (OuterSeq && outer_seq, std::size_t n, InnerSeq && inner_seq) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#detailed-description","text":"1 2 3 template < typename OuterSeq , typename InnerSeq > class batt :: seq :: Splice ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#using-outerseqref","text":"1 using batt :: seq :: Splice < OuterSeq , InnerSeq >:: OuterSeqRef = std :: add_lvalue_reference_t < OuterSeq > ;","title":"using OuterSeqRef"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#using-impl","text":"1 using batt :: seq :: Splice < OuterSeq , InnerSeq >:: Impl = Chain < TakeN < OuterSeqRef > , Chain < InnerSeq , OuterSeqRef > > ;","title":"using Impl"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#using-item","text":"1 using batt :: seq :: Splice < OuterSeq , InnerSeq >:: Item = SeqItem < Impl > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#function-splice","text":"1 2 3 4 5 inline explicit Splice ( OuterSeq && outer_seq , std :: size_t n , InnerSeq && inner_seq )","title":"function Splice"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/","text":"batt::seq::StatusOk \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::decay_t< RemoveStatusOr< SeqItem< SeqT > >> Item Public Functions \ud83d\udd17 Name template <typename... Args,typename =batt::EnableIfNoShadow > StatusOk (Args &&... args) bool ok () const const Status & status () const Status status () Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename SeqT > class batt :: seq :: StatusOk ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: StatusOk < SeqT >:: Item = std :: decay_t < RemoveStatusOr < SeqItem < SeqT > >> ; Public Functions Documentation \ud83d\udd17 function StatusOk \ud83d\udd17 1 2 3 4 5 template < typename ... Args , typename = batt :: EnableIfNoShadow < StatusOk , Args ... >> inline explicit StatusOk ( Args && ... args ) function ok \ud83d\udd17 1 inline bool ok () const function status \ud83d\udd17 1 inline const Status & status () const function status \ud83d\udd17 1 inline Status status () function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::StatusOk"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-types","text":"Name using std::decay_t< RemoveStatusOr< SeqItem< SeqT > >> Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-functions","text":"Name template <typename... Args,typename =batt::EnableIfNoShadow > StatusOk (Args &&... args) bool ok () const const Status & status () const Status status () Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#detailed-description","text":"1 2 template < typename SeqT > class batt :: seq :: StatusOk ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#using-item","text":"1 using batt :: seq :: StatusOk < SeqT >:: Item = std :: decay_t < RemoveStatusOr < SeqItem < SeqT > >> ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-statusok","text":"1 2 3 4 5 template < typename ... Args , typename = batt :: EnableIfNoShadow < StatusOk , Args ... >> inline explicit StatusOk ( Args && ... args )","title":"function StatusOk"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-ok","text":"1 inline bool ok () const","title":"function ok"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-status","text":"1 inline const Status & status () const","title":"function status"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-status_1","text":"1 inline Status status ()","title":"function status"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/","text":"batt::seq::TakeN \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name TakeN (Seq && seq, usize n) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 template < typename Seq > class batt :: seq :: TakeN ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: TakeN < Seq >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function TakeN \ud83d\udd17 1 2 3 4 inline explicit TakeN ( Seq && seq , usize n ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::TakeN"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-functions","text":"Name TakeN (Seq && seq, usize n) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#detailed-description","text":"1 2 template < typename Seq > class batt :: seq :: TakeN ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#using-item","text":"1 using batt :: seq :: TakeN < Seq >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#function-taken","text":"1 2 3 4 inline explicit TakeN ( Seq && seq , usize n )","title":"function TakeN"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/","text":"batt::seq::TakeWhile \ud83d\udd17 More... Public Types \ud83d\udd17 Name using SeqItem< Seq > Item Public Functions \ud83d\udd17 Name TakeWhile (Seq && seq, Predicate && predicate) Optional < Item > peek () Optional < Item > next () Detailed Description \ud83d\udd17 1 2 3 template < typename Seq , typename Predicate > class batt :: seq :: TakeWhile ; Public Types Documentation \ud83d\udd17 using Item \ud83d\udd17 1 using batt :: seq :: TakeWhile < Seq , Predicate >:: Item = SeqItem < Seq > ; Public Functions Documentation \ud83d\udd17 function TakeWhile \ud83d\udd17 1 2 3 4 inline explicit TakeWhile ( Seq && seq , Predicate && predicate ) function peek \ud83d\udd17 1 inline Optional < Item > peek () function next \ud83d\udd17 1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::TakeWhile"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-types","text":"Name using SeqItem< Seq > Item","title":"Public Types"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-functions","text":"Name TakeWhile (Seq && seq, Predicate && predicate) Optional < Item > peek () Optional < Item > next ()","title":"Public Functions"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#detailed-description","text":"1 2 3 template < typename Seq , typename Predicate > class batt :: seq :: TakeWhile ;","title":"Detailed Description"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#using-item","text":"1 using batt :: seq :: TakeWhile < Seq , Predicate >:: Item = SeqItem < Seq > ;","title":"using Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#function-takewhile","text":"1 2 3 4 inline explicit TakeWhile ( Seq && seq , Predicate && predicate )","title":"function TakeWhile"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#function-peek","text":"1 inline Optional < Item > peek ()","title":"function peek"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#function-next","text":"1 inline Optional < Item > next () Updated on 26 August 2022 at 17:30:03 UTC","title":"function next"},{"location":"_autogen/Classes/structbatt_1_1AbstractHandler_1_1Deleter/","text":"batt::AbstractHandler::Deleter \ud83d\udd17 Public Functions \ud83d\udd17 Name void operator() ( AbstractHandler * handler) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 inline void operator ()( AbstractHandler * handler ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::AbstractHandler::Deleter"},{"location":"_autogen/Classes/structbatt_1_1AbstractHandler_1_1Deleter/#public-functions","text":"Name void operator() ( AbstractHandler * handler) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1AbstractHandler_1_1Deleter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1AbstractHandler_1_1Deleter/#function-operator","text":"1 2 3 inline void operator ()( AbstractHandler * handler ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/","text":"batt::BasicInterval \ud83d\udd17 More... Public Classes \ud83d\udd17 Name struct LexicographicalOrder struct LinearOrder Public Types \ud83d\udd17 Name using Traits traits_type using seq::Reverse < LinearOrder > ReverseLinearOrder using seq::Reverse < LexicographicalOrder > ReverseLexicographicalOrder Public Functions \ud83d\udd17 Name auto size () const bool empty () const template <typename V > bool contains (const V & item) const template <typename ThatTraits > bool adjacent_to (const BasicInterval < ThatTraits > & that) const template <typename ThatTraits > BasicInterval union_with (const BasicInterval < ThatTraits > & that) const template <typename ThatTraits > bool overlaps (const BasicInterval < ThatTraits > & that) const template <typename ThatTraits > BasicInterval intersection_with (const BasicInterval < ThatTraits > & that) const SmallVec< BasicInterval , 2 > without (const BasicInterval & that) const Public Attributes \ud83d\udd17 Name Traits::lower_bound_type lower_bound Traits::upper_bound_type upper_bound Friends \ud83d\udd17 Name bool operator== (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) bool operator!= (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) std::ostream & operator<< (std::ostream & out, const BasicInterval < TraitsT > & t) Detailed Description \ud83d\udd17 1 2 template < typename Traits > struct batt :: BasicInterval ; Public Types Documentation \ud83d\udd17 using traits_type \ud83d\udd17 1 using batt :: BasicInterval < Traits >:: traits_type = Traits ; using ReverseLinearOrder \ud83d\udd17 1 using batt :: BasicInterval < Traits >:: ReverseLinearOrder = seq :: Reverse < LinearOrder > ; using ReverseLexicographicalOrder \ud83d\udd17 1 using batt :: BasicInterval < Traits >:: ReverseLexicographicalOrder = seq :: Reverse < LexicographicalOrder > ; Public Functions Documentation \ud83d\udd17 function size \ud83d\udd17 1 inline auto size () const function empty \ud83d\udd17 1 inline bool empty () const function contains \ud83d\udd17 1 2 3 4 template < typename V > inline bool contains ( const V & item ) const function adjacent_to \ud83d\udd17 1 2 3 4 template < typename ThatTraits > inline bool adjacent_to ( const BasicInterval < ThatTraits > & that ) const function union_with \ud83d\udd17 1 2 3 4 template < typename ThatTraits > inline BasicInterval union_with ( const BasicInterval < ThatTraits > & that ) const function overlaps \ud83d\udd17 1 2 3 4 template < typename ThatTraits > inline bool overlaps ( const BasicInterval < ThatTraits > & that ) const function intersection_with \ud83d\udd17 1 2 3 4 template < typename ThatTraits > inline BasicInterval intersection_with ( const BasicInterval < ThatTraits > & that ) const function without \ud83d\udd17 1 2 3 inline SmallVec < BasicInterval , 2 > without ( const BasicInterval & that ) const Public Attributes Documentation \ud83d\udd17 variable lower_bound \ud83d\udd17 1 Traits :: lower_bound_type lower_bound ; variable upper_bound \ud83d\udd17 1 Traits :: upper_bound_type upper_bound ; Friends \ud83d\udd17 friend operator== \ud83d\udd17 1 2 3 4 5 friend bool operator == ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ); friend operator!= \ud83d\udd17 1 2 3 4 5 friend bool operator != ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ); friend operator<< \ud83d\udd17 1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const BasicInterval < TraitsT > & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BasicInterval"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-classes","text":"Name struct LexicographicalOrder struct LinearOrder","title":"Public Classes"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-types","text":"Name using Traits traits_type using seq::Reverse < LinearOrder > ReverseLinearOrder using seq::Reverse < LexicographicalOrder > ReverseLexicographicalOrder","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-functions","text":"Name auto size () const bool empty () const template <typename V > bool contains (const V & item) const template <typename ThatTraits > bool adjacent_to (const BasicInterval < ThatTraits > & that) const template <typename ThatTraits > BasicInterval union_with (const BasicInterval < ThatTraits > & that) const template <typename ThatTraits > bool overlaps (const BasicInterval < ThatTraits > & that) const template <typename ThatTraits > BasicInterval intersection_with (const BasicInterval < ThatTraits > & that) const SmallVec< BasicInterval , 2 > without (const BasicInterval & that) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-attributes","text":"Name Traits::lower_bound_type lower_bound Traits::upper_bound_type upper_bound","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friends","text":"Name bool operator== (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) bool operator!= (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) std::ostream & operator<< (std::ostream & out, const BasicInterval < TraitsT > & t)","title":"Friends"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#detailed-description","text":"1 2 template < typename Traits > struct batt :: BasicInterval ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#using-traits_type","text":"1 using batt :: BasicInterval < Traits >:: traits_type = Traits ;","title":"using traits_type"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#using-reverselinearorder","text":"1 using batt :: BasicInterval < Traits >:: ReverseLinearOrder = seq :: Reverse < LinearOrder > ;","title":"using ReverseLinearOrder"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#using-reverselexicographicalorder","text":"1 using batt :: BasicInterval < Traits >:: ReverseLexicographicalOrder = seq :: Reverse < LexicographicalOrder > ;","title":"using ReverseLexicographicalOrder"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-size","text":"1 inline auto size () const","title":"function size"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-empty","text":"1 inline bool empty () const","title":"function empty"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-contains","text":"1 2 3 4 template < typename V > inline bool contains ( const V & item ) const","title":"function contains"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-adjacent_to","text":"1 2 3 4 template < typename ThatTraits > inline bool adjacent_to ( const BasicInterval < ThatTraits > & that ) const","title":"function adjacent_to"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-union_with","text":"1 2 3 4 template < typename ThatTraits > inline BasicInterval union_with ( const BasicInterval < ThatTraits > & that ) const","title":"function union_with"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-overlaps","text":"1 2 3 4 template < typename ThatTraits > inline bool overlaps ( const BasicInterval < ThatTraits > & that ) const","title":"function overlaps"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-intersection_with","text":"1 2 3 4 template < typename ThatTraits > inline BasicInterval intersection_with ( const BasicInterval < ThatTraits > & that ) const","title":"function intersection_with"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-without","text":"1 2 3 inline SmallVec < BasicInterval , 2 > without ( const BasicInterval & that ) const","title":"function without"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#variable-lower_bound","text":"1 Traits :: lower_bound_type lower_bound ;","title":"variable lower_bound"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#variable-upper_bound","text":"1 Traits :: upper_bound_type upper_bound ;","title":"variable upper_bound"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friend-operator","text":"1 2 3 4 5 friend bool operator == ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r );","title":"friend operator=="},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friend-operator_1","text":"1 2 3 4 5 friend bool operator != ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r );","title":"friend operator!="},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friend-operator_2","text":"1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const BasicInterval < TraitsT > & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend operator&lt;&lt;"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/","text":"batt::BasicInterval::LexicographicalOrder \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename TraitsL ,typename TraitsR > bool operator() (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator ()( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BasicInterval::LexicographicalOrder"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/#public-functions","text":"Name template <typename TraitsL ,typename TraitsR > bool operator() (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/#function-operator","text":"1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator ()( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/","text":"batt::BasicInterval::LinearOrder \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename TraitsL ,typename TraitsR > bool operator() (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) const template <typename L ,typename TraitsR > bool operator() (const L & l, const BasicInterval < TraitsR > & r) const template <typename TraitsL ,typename R > bool operator() (const BasicInterval < TraitsL > & l, const R & r) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator ()( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ) const function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename TraitsR > inline bool operator ()( const L & l , const BasicInterval < TraitsR > & r ) const function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsL , typename R > inline bool operator ()( const BasicInterval < TraitsL > & l , const R & r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::BasicInterval::LinearOrder"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#public-functions","text":"Name template <typename TraitsL ,typename TraitsR > bool operator() (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) const template <typename L ,typename TraitsR > bool operator() (const L & l, const BasicInterval < TraitsR > & r) const template <typename TraitsL ,typename R > bool operator() (const BasicInterval < TraitsL > & l, const R & r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#function-operator","text":"1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator ()( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ) const","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#function-operator_1","text":"1 2 3 4 5 6 template < typename L , typename TraitsR > inline bool operator ()( const L & l , const BasicInterval < TraitsR > & r ) const","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#function-operator_2","text":"1 2 3 4 5 6 template < typename TraitsL , typename R > inline bool operator ()( const BasicInterval < TraitsL > & l , const R & r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1DecayRValueRefImpl/","text":"batt::DecayRValueRefImpl \ud83d\udd17 More... Inherits from std::conditional_t< std::is_rvalue_reference_v< T >, std::decay< T >, batt::StaticType< T > > Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: DecayRValueRefImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::DecayRValueRefImpl"},{"location":"_autogen/Classes/structbatt_1_1DecayRValueRefImpl/#detailed-description","text":"1 2 template < typename T > struct batt :: DecayRValueRefImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/","text":"batt::DoNothing \ud83d\udd17 Public Types \ud83d\udd17 Name using void result_type Public Functions \ud83d\udd17 Name template <typename... Args> void operator() (Args && ...) const Public Types Documentation \ud83d\udd17 using result_type \ud83d\udd17 1 using batt :: DoNothing :: result_type = void ; Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 template < typename ... Args > inline void operator ()( Args && ... ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::DoNothing"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-types","text":"Name using void result_type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-functions","text":"Name template <typename... Args> void operator() (Args && ...) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#using-result_type","text":"1 using batt :: DoNothing :: result_type = void ;","title":"using result_type"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#function-operator","text":"1 2 3 4 template < typename ... Args > inline void operator ()( Args && ... ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/","text":"batt::EscapedStringLiteral \ud83d\udd17 Public Functions \ud83d\udd17 Name std::atomic< usize > & max_show_length () Public Attributes \ud83d\udd17 Name std::string_view str Public Functions Documentation \ud83d\udd17 function max_show_length \ud83d\udd17 1 static inline std :: atomic < usize > & max_show_length () Public Attributes Documentation \ud83d\udd17 variable str \ud83d\udd17 1 std :: string_view str ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::EscapedStringLiteral"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-functions","text":"Name std::atomic< usize > & max_show_length ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-attributes","text":"Name std::string_view str","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#function-max_show_length","text":"1 static inline std :: atomic < usize > & max_show_length ()","title":"function max_show_length"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#variable-str","text":"1 std :: string_view str ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable str"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/","text":"batt::ExponentialBackoff \ud83d\udd17 Public Functions \ud83d\udd17 Name ExponentialBackoff with_default_params () Public Attributes \ud83d\udd17 Name u64 max_attempts u64 initial_delay_usec u64 backoff_factor u64 backoff_divisor u64 max_delay_usec Public Functions Documentation \ud83d\udd17 function with_default_params \ud83d\udd17 1 static inline ExponentialBackoff with_default_params () Public Attributes Documentation \ud83d\udd17 variable max_attempts \ud83d\udd17 1 u64 max_attempts ; variable initial_delay_usec \ud83d\udd17 1 u64 initial_delay_usec ; variable backoff_factor \ud83d\udd17 1 u64 backoff_factor ; variable backoff_divisor \ud83d\udd17 1 u64 backoff_divisor ; variable max_delay_usec \ud83d\udd17 1 u64 max_delay_usec ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::ExponentialBackoff"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-functions","text":"Name ExponentialBackoff with_default_params ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-attributes","text":"Name u64 max_attempts u64 initial_delay_usec u64 backoff_factor u64 backoff_divisor u64 max_delay_usec","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#function-with_default_params","text":"1 static inline ExponentialBackoff with_default_params ()","title":"function with_default_params"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-max_attempts","text":"1 u64 max_attempts ;","title":"variable max_attempts"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-initial_delay_usec","text":"1 u64 initial_delay_usec ;","title":"variable initial_delay_usec"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-backoff_factor","text":"1 u64 backoff_factor ;","title":"variable backoff_factor"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-backoff_divisor","text":"1 u64 backoff_divisor ;","title":"variable backoff_divisor"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-max_delay_usec","text":"1 u64 max_delay_usec ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable max_delay_usec"},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/","text":"batt::FakeExecutionContext::AlwaysReturnZero \ud83d\udd17 Public Functions \ud83d\udd17 Name usize operator() (usize ) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 inline usize operator ()( usize ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeExecutionContext::AlwaysReturnZero"},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/#public-functions","text":"Name usize operator() (usize ) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/#function-operator","text":"1 2 3 inline usize operator ()( usize ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/","text":"batt::FakeTimeService::TimerInstance \ud83d\udd17 Public Classes \ud83d\udd17 Name struct Impl Public Attributes \ud83d\udd17 Name std::shared_ptr< Impl > impl Public Attributes Documentation \ud83d\udd17 variable impl \ud83d\udd17 1 std :: shared_ptr < Impl > impl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeTimeService::TimerInstance"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#public-classes","text":"Name struct Impl","title":"Public Classes"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#public-attributes","text":"Name std::shared_ptr< Impl > impl","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#variable-impl","text":"1 std :: shared_ptr < Impl > impl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable impl"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/","text":"batt::FakeTimeService::TimerInstance::Impl \ud83d\udd17 Public Functions \ud83d\udd17 Name Impl ( FakeTimeService * service, boost::asio::any_io_executor ex, TimePoint expire, UniqueHandler < ErrorCode > h) Public Attributes \ud83d\udd17 Name FakeTimeService * service_instance boost::asio::any_io_executor executor TimePoint expires_at UniqueHandler < ErrorCode > handler Public Functions Documentation \ud83d\udd17 function Impl \ud83d\udd17 1 2 3 4 5 6 inline explicit Impl ( FakeTimeService * service , boost :: asio :: any_io_executor ex , TimePoint expire , UniqueHandler < ErrorCode > h ) Public Attributes Documentation \ud83d\udd17 variable service_instance \ud83d\udd17 1 FakeTimeService * service_instance ; variable executor \ud83d\udd17 1 boost :: asio :: any_io_executor executor ; variable expires_at \ud83d\udd17 1 TimePoint expires_at ; variable handler \ud83d\udd17 1 UniqueHandler < ErrorCode > handler ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::FakeTimeService::TimerInstance::Impl"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-functions","text":"Name Impl ( FakeTimeService * service, boost::asio::any_io_executor ex, TimePoint expire, UniqueHandler < ErrorCode > h)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-attributes","text":"Name FakeTimeService * service_instance boost::asio::any_io_executor executor TimePoint expires_at UniqueHandler < ErrorCode > handler","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#function-impl","text":"1 2 3 4 5 6 inline explicit Impl ( FakeTimeService * service , boost :: asio :: any_io_executor ex , TimePoint expire , UniqueHandler < ErrorCode > h )","title":"function Impl"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-service_instance","text":"1 FakeTimeService * service_instance ;","title":"variable service_instance"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-executor","text":"1 boost :: asio :: any_io_executor executor ;","title":"variable executor"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-expires_at","text":"1 TimePoint expires_at ;","title":"variable expires_at"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-handler","text":"1 UniqueHandler < ErrorCode > handler ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable handler"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/","text":"batt::GreatestLowerBound \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name T value Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: GreatestLowerBound ; Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 1 T value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::GreatestLowerBound"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#public-attributes","text":"Name T value","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#detailed-description","text":"1 2 template < typename T > struct batt :: GreatestLowerBound ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#variable-value","text":"1 T value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable value"},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/","text":"batt::HexByteDumper \ud83d\udd17 Public Attributes \ud83d\udd17 Name std::string_view bytes Public Attributes Documentation \ud83d\udd17 variable bytes \ud83d\udd17 1 std :: string_view bytes ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HexByteDumper"},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/#public-attributes","text":"Name std::string_view bytes","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/#variable-bytes","text":"1 std :: string_view bytes ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable bytes"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/","text":"batt::HostAddress \ud83d\udd17 Public Attributes \ud83d\udd17 Name std::string scheme std::string hostname Optional < i64 > port Friends \ud83d\udd17 Name usize hash_value (const HostAddress & host_key) Public Attributes Documentation \ud83d\udd17 variable scheme \ud83d\udd17 1 std :: string scheme ; variable hostname \ud83d\udd17 1 std :: string hostname ; variable port \ud83d\udd17 1 Optional < i64 > port ; Friends \ud83d\udd17 friend hash_value \ud83d\udd17 1 2 3 friend usize hash_value ( const HostAddress & host_key ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HostAddress"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#public-attributes","text":"Name std::string scheme std::string hostname Optional < i64 > port","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#friends","text":"Name usize hash_value (const HostAddress & host_key)","title":"Friends"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#variable-scheme","text":"1 std :: string scheme ;","title":"variable scheme"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#variable-hostname","text":"1 std :: string hostname ;","title":"variable hostname"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#variable-port","text":"1 Optional < i64 > port ;","title":"variable port"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#friend-hash_value","text":"1 2 3 friend usize hash_value ( const HostAddress & host_key ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend hash_value"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/","text":"batt::HttpClientConnection::ResponseInfo \ud83d\udd17 Public Functions \ud83d\udd17 Name ResponseInfo (const pico_http::Response & response) bool is_valid () const HttpData get_data ( StreamBuffer & input_buffer) Public Attributes \ud83d\udd17 Name Optional < usize > content_length bool keep_alive bool chunked_encoding Public Functions Documentation \ud83d\udd17 function ResponseInfo \ud83d\udd17 1 2 3 explicit ResponseInfo ( const pico_http :: Response & response ) function is_valid \ud83d\udd17 1 inline bool is_valid () const function get_data \ud83d\udd17 1 2 3 HttpData get_data ( StreamBuffer & input_buffer ) Public Attributes Documentation \ud83d\udd17 variable content_length \ud83d\udd17 1 Optional < usize > content_length ; variable keep_alive \ud83d\udd17 1 bool keep_alive ; variable chunked_encoding \ud83d\udd17 1 bool chunked_encoding ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpClientConnection::ResponseInfo"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#public-functions","text":"Name ResponseInfo (const pico_http::Response & response) bool is_valid () const HttpData get_data ( StreamBuffer & input_buffer)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#public-attributes","text":"Name Optional < usize > content_length bool keep_alive bool chunked_encoding","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#function-responseinfo","text":"1 2 3 explicit ResponseInfo ( const pico_http :: Response & response )","title":"function ResponseInfo"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#function-is_valid","text":"1 inline bool is_valid () const","title":"function is_valid"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#function-get_data","text":"1 2 3 HttpData get_data ( StreamBuffer & input_buffer )","title":"function get_data"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#variable-content_length","text":"1 Optional < usize > content_length ;","title":"variable content_length"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#variable-keep_alive","text":"1 bool keep_alive ;","title":"variable keep_alive"},{"location":"_autogen/Classes/structbatt_1_1HttpClientConnection_1_1ResponseInfo/#variable-chunked_encoding","text":"1 bool chunked_encoding ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable chunked_encoding"},{"location":"_autogen/Classes/structbatt_1_1HttpData/","text":"batt::HttpData \ud83d\udd17 Public Functions \ud83d\udd17 Name bool empty () const usize size () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) void close_for_read () Public Attributes \ud83d\udd17 Name BufferSource source Public Functions Documentation \ud83d\udd17 function empty \ud83d\udd17 1 inline bool empty () const function size \ud83d\udd17 1 inline usize size () const function fetch_at_least \ud83d\udd17 1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count ) function consume \ud83d\udd17 1 2 3 inline void consume ( i64 count ) function close_for_read \ud83d\udd17 1 inline void close_for_read () Public Attributes Documentation \ud83d\udd17 variable source \ud83d\udd17 1 BufferSource source ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpData"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-functions","text":"Name bool empty () const usize size () const StatusOr < SmallVec< ConstBuffer, 2 > > fetch_at_least (i64 min_count) void consume (i64 count) void close_for_read ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-attributes","text":"Name BufferSource source","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-empty","text":"1 inline bool empty () const","title":"function empty"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-size","text":"1 inline usize size () const","title":"function size"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-fetch_at_least","text":"1 2 3 inline StatusOr < SmallVec < ConstBuffer , 2 > > fetch_at_least ( i64 min_count )","title":"function fetch_at_least"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-consume","text":"1 2 3 inline void consume ( i64 count )","title":"function consume"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-close_for_read","text":"1 inline void close_for_read ()","title":"function close_for_read"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#variable-source","text":"1 BufferSource source ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable source"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/","text":"batt::HttpVersion \ud83d\udd17 Public Attributes \ud83d\udd17 Name i32 major_version i32 minor_version Public Attributes Documentation \ud83d\udd17 variable major_version \ud83d\udd17 1 i32 major_version ; variable minor_version \ud83d\udd17 1 i32 minor_version ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::HttpVersion"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#public-attributes","text":"Name i32 major_version i32 minor_version","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#variable-major_version","text":"1 i32 major_version ;","title":"variable major_version"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#variable-minor_version","text":"1 i32 minor_version ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable minor_version"},{"location":"_autogen/Classes/structbatt_1_1IClosed/","text":"batt::IClosed \ud83d\udd17 More... Inherits from batt::IntervalTraits< T, T, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, seq::NaturalOrder, seq::NaturalEquals > Detailed Description \ud83d\udd17 1 2 3 template < typename T , typename U = T > struct batt :: IClosed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IClosed"},{"location":"_autogen/Classes/structbatt_1_1IClosed/#detailed-description","text":"1 2 3 template < typename T , typename U = T > struct batt :: IClosed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IClosedOpen/","text":"batt::IClosedOpen \ud83d\udd17 More... Inherits from batt::IntervalTraits< T, T, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, seq::NaturalOrder, seq::NaturalEquals > Detailed Description \ud83d\udd17 1 2 3 template < typename T , typename U = T > struct batt :: IClosedOpen ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IClosedOpen"},{"location":"_autogen/Classes/structbatt_1_1IClosedOpen/#detailed-description","text":"1 2 3 template < typename T , typename U = T > struct batt :: IClosedOpen ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1InPlaceInitType/","text":"batt::InPlaceInitType \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::InPlaceInitType"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits/","text":"batt::IntervalTraits \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename U , InclusiveLowerBound kLowerInclusive , InclusiveUpperBound kUpperInclusive , typename OrderFn , typename EqualFn > struct batt :: IntervalTraits ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IntervalTraits"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits/#detailed-description","text":"1 2 3 4 5 6 7 template < typename T , typename U , InclusiveLowerBound kLowerInclusive , InclusiveUpperBound kUpperInclusive , typename OrderFn , typename EqualFn > struct batt :: IntervalTraits ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/","text":"batt::IntervalTraitsBase \ud83d\udd17 More... Public Types \ud83d\udd17 Name using IntervalTraitsBase Base Public Functions \ud83d\udd17 Name template <typename T0 ,typename T1 > bool less_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > min (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > max (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool not_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool less_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool x_included_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_includes_x (const T0 & upper, const T1 & x) template <typename T0 ,typename T1 > bool lower_excludes_x (const T0 & lower, const T0 & x) template <typename T0 ,typename T1 > bool x_excluded_by_upper (const T0 & x, const T1 & upper) template <typename T0 ,typename T1 > bool x_excluded_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_excludes_x (const T0 & upper, const T1 & x) Detailed Description \ud83d\udd17 1 2 3 4 template < typename Derived , typename OrderFn , typename EqualFn > struct batt :: IntervalTraitsBase ; Public Types Documentation \ud83d\udd17 using Base \ud83d\udd17 1 using batt :: IntervalTraitsBase < Derived , OrderFn , EqualFn >:: Base = IntervalTraitsBase ; Public Functions Documentation \ud83d\udd17 function less_than \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool less_than ( const T0 & left , const T1 & right ) function min \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline std :: common_type_t < T0 , T1 > min ( const T0 & left , const T1 & right ) function max \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline std :: common_type_t < T0 , T1 > max ( const T0 & left , const T1 & right ) function equal \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool equal ( const T0 & left , const T1 & right ) function not_equal \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool not_equal ( const T0 & left , const T1 & right ) function greater_than \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool greater_than ( const T0 & left , const T1 & right ) function less_or_equal \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool less_or_equal ( const T0 & left , const T1 & right ) function greater_or_equal \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool greater_or_equal ( const T0 & left , const T1 & right ) function x_included_by_lower \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool x_included_by_lower ( const T0 & x , const T1 & lower ) function upper_includes_x \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool upper_includes_x ( const T0 & upper , const T1 & x ) function lower_excludes_x \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool lower_excludes_x ( const T0 & lower , const T0 & x ) function x_excluded_by_upper \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool x_excluded_by_upper ( const T0 & x , const T1 & upper ) function x_excluded_by_lower \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool x_excluded_by_lower ( const T0 & x , const T1 & lower ) function upper_excludes_x \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool upper_excludes_x ( const T0 & upper , const T1 & x ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IntervalTraitsBase"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-types","text":"Name using IntervalTraitsBase Base","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-functions","text":"Name template <typename T0 ,typename T1 > bool less_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > min (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > max (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool not_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool less_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool x_included_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_includes_x (const T0 & upper, const T1 & x) template <typename T0 ,typename T1 > bool lower_excludes_x (const T0 & lower, const T0 & x) template <typename T0 ,typename T1 > bool x_excluded_by_upper (const T0 & x, const T1 & upper) template <typename T0 ,typename T1 > bool x_excluded_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_excludes_x (const T0 & upper, const T1 & x)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#detailed-description","text":"1 2 3 4 template < typename Derived , typename OrderFn , typename EqualFn > struct batt :: IntervalTraitsBase ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#using-base","text":"1 using batt :: IntervalTraitsBase < Derived , OrderFn , EqualFn >:: Base = IntervalTraitsBase ;","title":"using Base"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-less_than","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool less_than ( const T0 & left , const T1 & right )","title":"function less_than"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-min","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline std :: common_type_t < T0 , T1 > min ( const T0 & left , const T1 & right )","title":"function min"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-max","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline std :: common_type_t < T0 , T1 > max ( const T0 & left , const T1 & right )","title":"function max"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-equal","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool equal ( const T0 & left , const T1 & right )","title":"function equal"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-not_equal","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool not_equal ( const T0 & left , const T1 & right )","title":"function not_equal"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-greater_than","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool greater_than ( const T0 & left , const T1 & right )","title":"function greater_than"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-less_or_equal","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool less_or_equal ( const T0 & left , const T1 & right )","title":"function less_or_equal"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-greater_or_equal","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool greater_or_equal ( const T0 & left , const T1 & right )","title":"function greater_or_equal"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-x_included_by_lower","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool x_included_by_lower ( const T0 & x , const T1 & lower )","title":"function x_included_by_lower"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-upper_includes_x","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool upper_includes_x ( const T0 & upper , const T1 & x )","title":"function upper_includes_x"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-lower_excludes_x","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool lower_excludes_x ( const T0 & lower , const T0 & x )","title":"function lower_excludes_x"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-x_excluded_by_upper","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool x_excluded_by_upper ( const T0 & x , const T1 & upper )","title":"function x_excluded_by_upper"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-x_excluded_by_lower","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool x_excluded_by_lower ( const T0 & x , const T1 & lower )","title":"function x_excluded_by_lower"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-upper_excludes_x","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > static inline bool upper_excludes_x ( const T0 & upper , const T1 & x ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function upper_excludes_x"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/","text":"batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn > \ud83d\udd17 More... Inherits from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >, OrderFn, EqualFn > Public Types \ud83d\udd17 Name using T lower_bound_type using U upper_bound_type using IntervalTraits Self Public Functions \ud83d\udd17 Name std::ptrdiff_t size (const T & lower, const U & upper) bool empty (const T & lower, const U & upper) template <typename V > bool lower_includes_x (const T & lower, const V & x) template <typename V > bool x_included_by_upper (const V & x, const U & upper) template <typename T1 ,typename U1 > bool adjacent (const T & a_lower, const U & a_upper, const T1 & b_lower, const U1 & b_upper) char left_bracket () char right_bracket () Public Attributes \ud83d\udd17 Name constexpr InclusiveLowerBound inclusive_lower_bound constexpr InclusiveUpperBound inclusive_upper_bound Additional inherited members \ud83d\udd17 Public Types inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >, OrderFn, EqualFn > Name using IntervalTraitsBase Base Public Functions inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >, OrderFn, EqualFn > Name template <typename T0 ,typename T1 > bool less_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > min (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > max (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool not_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool less_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool x_included_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_includes_x (const T0 & upper, const T1 & x) template <typename T0 ,typename T1 > bool lower_excludes_x (const T0 & lower, const T0 & x) template <typename T0 ,typename T1 > bool x_excluded_by_upper (const T0 & x, const T1 & upper) template <typename T0 ,typename T1 > bool x_excluded_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_excludes_x (const T0 & upper, const T1 & x) Detailed Description \ud83d\udd17 1 2 3 4 5 template < typename T , typename U , typename OrderFn , typename EqualFn > struct batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn > ; Public Types Documentation \ud83d\udd17 using lower_bound_type \ud83d\udd17 1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn >:: lower_bound_type = T ; using upper_bound_type \ud83d\udd17 1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn >:: upper_bound_type = U ; using Self \ud83d\udd17 1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn >:: Self = IntervalTraits ; Public Functions Documentation \ud83d\udd17 function size \ud83d\udd17 1 2 3 4 static inline std :: ptrdiff_t size ( const T & lower , const U & upper ) function empty \ud83d\udd17 1 2 3 4 static inline bool empty ( const T & lower , const U & upper ) function lower_includes_x \ud83d\udd17 1 2 3 4 5 template < typename V > static inline bool lower_includes_x ( const T & lower , const V & x ) function x_included_by_upper \ud83d\udd17 1 2 3 4 5 template < typename V > static inline bool x_included_by_upper ( const V & x , const U & upper ) function adjacent \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename T1 , typename U1 > static inline bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper ) function left_bracket \ud83d\udd17 1 static inline char left_bracket () function right_bracket \ud83d\udd17 1 static inline char right_bracket () Public Attributes Documentation \ud83d\udd17 variable inclusive_lower_bound \ud83d\udd17 1 static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ; variable inclusive_upper_bound \ud83d\udd17 1 static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kTrue ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-types","text":"Name using T lower_bound_type using U upper_bound_type using IntervalTraits Self","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-functions","text":"Name std::ptrdiff_t size (const T & lower, const U & upper) bool empty (const T & lower, const U & upper) template <typename V > bool lower_includes_x (const T & lower, const V & x) template <typename V > bool x_included_by_upper (const V & x, const U & upper) template <typename T1 ,typename U1 > bool adjacent (const T & a_lower, const U & a_upper, const T1 & b_lower, const U1 & b_upper) char left_bracket () char right_bracket ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-attributes","text":"Name constexpr InclusiveLowerBound inclusive_lower_bound constexpr InclusiveUpperBound inclusive_upper_bound","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#additional-inherited-members","text":"Public Types inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >, OrderFn, EqualFn > Name using IntervalTraitsBase Base Public Functions inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >, OrderFn, EqualFn > Name template <typename T0 ,typename T1 > bool less_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > min (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > max (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool not_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool less_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool x_included_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_includes_x (const T0 & upper, const T1 & x) template <typename T0 ,typename T1 > bool lower_excludes_x (const T0 & lower, const T0 & x) template <typename T0 ,typename T1 > bool x_excluded_by_upper (const T0 & x, const T1 & upper) template <typename T0 ,typename T1 > bool x_excluded_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_excludes_x (const T0 & upper, const T1 & x)","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#detailed-description","text":"1 2 3 4 5 template < typename T , typename U , typename OrderFn , typename EqualFn > struct batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#using-lower_bound_type","text":"1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn >:: lower_bound_type = T ;","title":"using lower_bound_type"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#using-upper_bound_type","text":"1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn >:: upper_bound_type = U ;","title":"using upper_bound_type"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#using-self","text":"1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn >:: Self = IntervalTraits ;","title":"using Self"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-size","text":"1 2 3 4 static inline std :: ptrdiff_t size ( const T & lower , const U & upper )","title":"function size"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-empty","text":"1 2 3 4 static inline bool empty ( const T & lower , const U & upper )","title":"function empty"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-lower_includes_x","text":"1 2 3 4 5 template < typename V > static inline bool lower_includes_x ( const T & lower , const V & x )","title":"function lower_includes_x"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-x_included_by_upper","text":"1 2 3 4 5 template < typename V > static inline bool x_included_by_upper ( const V & x , const U & upper )","title":"function x_included_by_upper"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-adjacent","text":"1 2 3 4 5 6 7 8 template < typename T1 , typename U1 > static inline bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper )","title":"function adjacent"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-left_bracket","text":"1 static inline char left_bracket ()","title":"function left_bracket"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-right_bracket","text":"1 static inline char right_bracket ()","title":"function right_bracket"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#variable-inclusive_lower_bound","text":"1 static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ;","title":"variable inclusive_lower_bound"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#variable-inclusive_upper_bound","text":"1 static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kTrue ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable inclusive_upper_bound"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/","text":"batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn > \ud83d\udd17 More... Inherits from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn >, OrderFn, EqualFn > Public Types \ud83d\udd17 Name using T lower_bound_type using U upper_bound_type using IntervalTraits Self Public Functions \ud83d\udd17 Name std::ptrdiff_t size (const T & lower, const U & upper) bool empty (const T & lower, const U & upper) template <typename V > bool lower_includes_x (const T & lower, const V & x) template <typename V > bool x_included_by_upper (const V & x, const U & upper) template <typename T1 ,typename U1 > bool adjacent (const T & a_lower, const U & a_upper, const T1 & b_lower, const U1 & b_upper) char left_bracket () char right_bracket () Public Attributes \ud83d\udd17 Name constexpr InclusiveLowerBound inclusive_lower_bound constexpr InclusiveUpperBound inclusive_upper_bound Additional inherited members \ud83d\udd17 Public Types inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn >, OrderFn, EqualFn > Name using IntervalTraitsBase Base Public Functions inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn >, OrderFn, EqualFn > Name template <typename T0 ,typename T1 > bool less_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > min (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > max (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool not_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool less_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool x_included_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_includes_x (const T0 & upper, const T1 & x) template <typename T0 ,typename T1 > bool lower_excludes_x (const T0 & lower, const T0 & x) template <typename T0 ,typename T1 > bool x_excluded_by_upper (const T0 & x, const T1 & upper) template <typename T0 ,typename T1 > bool x_excluded_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_excludes_x (const T0 & upper, const T1 & x) Detailed Description \ud83d\udd17 1 2 3 4 5 template < typename T , typename U , typename OrderFn , typename EqualFn > struct batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn > ; Public Types Documentation \ud83d\udd17 using lower_bound_type \ud83d\udd17 1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn >:: lower_bound_type = T ; using upper_bound_type \ud83d\udd17 1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn >:: upper_bound_type = U ; using Self \ud83d\udd17 1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn >:: Self = IntervalTraits ; Public Functions Documentation \ud83d\udd17 function size \ud83d\udd17 1 2 3 4 static inline std :: ptrdiff_t size ( const T & lower , const U & upper ) function empty \ud83d\udd17 1 2 3 4 static inline bool empty ( const T & lower , const U & upper ) function lower_includes_x \ud83d\udd17 1 2 3 4 5 template < typename V > static inline bool lower_includes_x ( const T & lower , const V & x ) function x_included_by_upper \ud83d\udd17 1 2 3 4 5 template < typename V > static inline bool x_included_by_upper ( const V & x , const U & upper ) function adjacent \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename T1 , typename U1 > static inline bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper ) function left_bracket \ud83d\udd17 1 static inline char left_bracket () function right_bracket \ud83d\udd17 1 static inline char right_bracket () Public Attributes Documentation \ud83d\udd17 variable inclusive_lower_bound \ud83d\udd17 1 static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ; variable inclusive_upper_bound \ud83d\udd17 1 static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kFalse ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn >"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-types","text":"Name using T lower_bound_type using U upper_bound_type using IntervalTraits Self","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-functions","text":"Name std::ptrdiff_t size (const T & lower, const U & upper) bool empty (const T & lower, const U & upper) template <typename V > bool lower_includes_x (const T & lower, const V & x) template <typename V > bool x_included_by_upper (const V & x, const U & upper) template <typename T1 ,typename U1 > bool adjacent (const T & a_lower, const U & a_upper, const T1 & b_lower, const U1 & b_upper) char left_bracket () char right_bracket ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-attributes","text":"Name constexpr InclusiveLowerBound inclusive_lower_bound constexpr InclusiveUpperBound inclusive_upper_bound","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#additional-inherited-members","text":"Public Types inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn >, OrderFn, EqualFn > Name using IntervalTraitsBase Base Public Functions inherited from batt::IntervalTraitsBase< IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn >, OrderFn, EqualFn > Name template <typename T0 ,typename T1 > bool less_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > min (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > std::common_type_t< T0, T1 > max (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool not_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_than (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool less_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool greater_or_equal (const T0 & left, const T1 & right) template <typename T0 ,typename T1 > bool x_included_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_includes_x (const T0 & upper, const T1 & x) template <typename T0 ,typename T1 > bool lower_excludes_x (const T0 & lower, const T0 & x) template <typename T0 ,typename T1 > bool x_excluded_by_upper (const T0 & x, const T1 & upper) template <typename T0 ,typename T1 > bool x_excluded_by_lower (const T0 & x, const T1 & lower) template <typename T0 ,typename T1 > bool upper_excludes_x (const T0 & upper, const T1 & x)","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#detailed-description","text":"1 2 3 4 5 template < typename T , typename U , typename OrderFn , typename EqualFn > struct batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#using-lower_bound_type","text":"1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn >:: lower_bound_type = T ;","title":"using lower_bound_type"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#using-upper_bound_type","text":"1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn >:: upper_bound_type = U ;","title":"using upper_bound_type"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#using-self","text":"1 using batt :: IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn >:: Self = IntervalTraits ;","title":"using Self"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-size","text":"1 2 3 4 static inline std :: ptrdiff_t size ( const T & lower , const U & upper )","title":"function size"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-empty","text":"1 2 3 4 static inline bool empty ( const T & lower , const U & upper )","title":"function empty"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-lower_includes_x","text":"1 2 3 4 5 template < typename V > static inline bool lower_includes_x ( const T & lower , const V & x )","title":"function lower_includes_x"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-x_included_by_upper","text":"1 2 3 4 5 template < typename V > static inline bool x_included_by_upper ( const V & x , const U & upper )","title":"function x_included_by_upper"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-adjacent","text":"1 2 3 4 5 6 7 8 template < typename T1 , typename U1 > static inline bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper )","title":"function adjacent"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-left_bracket","text":"1 static inline char left_bracket ()","title":"function left_bracket"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-right_bracket","text":"1 static inline char right_bracket ()","title":"function right_bracket"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#variable-inclusive_lower_bound","text":"1 static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ;","title":"variable inclusive_lower_bound"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#variable-inclusive_upper_bound","text":"1 static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kFalse ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable inclusive_upper_bound"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq/","text":"batt::IsBoxedSeq \ud83d\udd17 More... Inherits from false_type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: IsBoxedSeq ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IsBoxedSeq"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq/#detailed-description","text":"1 2 template < typename T > struct batt :: IsBoxedSeq ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq_3_01BoxedSeq_3_01T_01_4_01_4/","text":"batt::IsBoxedSeq< BoxedSeq< T > > \ud83d\udd17 More... Inherits from true_type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: IsBoxedSeq < BoxedSeq < T > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IsBoxedSeq< BoxedSeq< T > >"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq_3_01BoxedSeq_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: IsBoxedSeq < BoxedSeq < T > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IsTuple/","text":"batt::IsTuple \ud83d\udd17 More... Inherits from false_type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: IsTuple ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IsTuple"},{"location":"_autogen/Classes/structbatt_1_1IsTuple/#detailed-description","text":"1 2 template < typename T > struct batt :: IsTuple ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IsTuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","text":"batt::IsTuple< std::tuple< Ts... > > \ud83d\udd17 More... Inherits from true_type Detailed Description \ud83d\udd17 1 2 template < typename ... Ts > struct batt :: IsTuple < std :: tuple < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IsTuple< std::tuple< Ts... > >"},{"location":"_autogen/Classes/structbatt_1_1IsTuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","text":"1 2 template < typename ... Ts > struct batt :: IsTuple < std :: tuple < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IsVariant/","text":"batt::IsVariant \ud83d\udd17 More... Inherits from false_type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: IsVariant ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IsVariant"},{"location":"_autogen/Classes/structbatt_1_1IsVariant/#detailed-description","text":"1 2 template < typename T > struct batt :: IsVariant ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1IsVariant_3_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/","text":"batt::IsVariant< std::variant< Ts... > > \ud83d\udd17 More... Inherits from true_type Detailed Description \ud83d\udd17 1 2 template < typename ... Ts > struct batt :: IsVariant < std :: variant < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::IsVariant< std::variant< Ts... > >"},{"location":"_autogen/Classes/structbatt_1_1IsVariant_3_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#detailed-description","text":"1 2 template < typename ... Ts > struct batt :: IsVariant < std :: variant < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/","text":"batt::LeastUpperBound \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name T value Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: LeastUpperBound ; Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 1 T value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::LeastUpperBound"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#public-attributes","text":"Name T value","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#detailed-description","text":"1 2 template < typename T > struct batt :: LeastUpperBound ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#variable-value","text":"1 T value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable value"},{"location":"_autogen/Classes/structbatt_1_1MapTuple/","text":"batt::MapTuple \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < template < typename > class PerTypeT , typename TupleT > struct batt :: MapTuple ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MapTuple"},{"location":"_autogen/Classes/structbatt_1_1MapTuple/#detailed-description","text":"1 2 3 template < template < typename > class PerTypeT , typename TupleT > struct batt :: MapTuple ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1MapTuple_3_01PerTypeT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","text":"batt::MapTuple< PerTypeT, std::tuple< Ts... > > \ud83d\udd17 More... Inherits from batt::StaticType< std::tuple< PerTypeT< Ts >... > > Additional inherited members \ud83d\udd17 Public Types inherited from batt::StaticType< std::tuple< PerTypeT< Ts >... > > Name using T type Detailed Description \ud83d\udd17 1 2 3 template < template < typename > class PerTypeT , typename ... Ts > struct batt :: MapTuple < PerTypeT , std :: tuple < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MapTuple< PerTypeT, std::tuple< Ts... > >"},{"location":"_autogen/Classes/structbatt_1_1MapTuple_3_01PerTypeT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#additional-inherited-members","text":"Public Types inherited from batt::StaticType< std::tuple< PerTypeT< Ts >... > > Name using T type","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1MapTuple_3_01PerTypeT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","text":"1 2 3 template < template < typename > class PerTypeT , typename ... Ts > struct batt :: MapTuple < PerTypeT , std :: tuple < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/","text":"batt::MetricLabel \ud83d\udd17 Public Attributes \ud83d\udd17 Name Token key Token value Public Attributes Documentation \ud83d\udd17 variable key \ud83d\udd17 1 Token key ; variable value \ud83d\udd17 1 Token value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MetricLabel"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#public-attributes","text":"Name Token key Token value","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#variable-key","text":"1 Token key ;","title":"variable key"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#variable-value","text":"1 Token value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable value"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple/","text":"batt::MorphTuple \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < template < typename ... > class TemplateT , typename TupleT > struct batt :: MorphTuple ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MorphTuple"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple/#detailed-description","text":"1 2 3 template < template < typename ... > class TemplateT , typename TupleT > struct batt :: MorphTuple ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple_3_01TemplateT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","text":"batt::MorphTuple< TemplateT, std::tuple< Ts... > > \ud83d\udd17 More... Inherits from batt::StaticType< TemplateT< Ts... > > Additional inherited members \ud83d\udd17 Public Types inherited from batt::StaticType< TemplateT< Ts... > > Name using T type Detailed Description \ud83d\udd17 1 2 3 template < template < typename ... > class TemplateT , typename ... Ts > struct batt :: MorphTuple < TemplateT , std :: tuple < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::MorphTuple< TemplateT, std::tuple< Ts... > >"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple_3_01TemplateT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#additional-inherited-members","text":"Public Types inherited from batt::StaticType< TemplateT< Ts... > > Name using T type","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple_3_01TemplateT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","text":"1 2 3 template < template < typename ... > class TemplateT , typename ... Ts > struct batt :: MorphTuple < TemplateT , std :: tuple < Ts ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1Mutex_1_1ThreadSafeBaseIsNotSupportedByType/","text":"batt::Mutex::ThreadSafeBaseIsNotSupportedByType \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 template < typename > struct batt :: Mutex :: ThreadSafeBaseIsNotSupportedByType ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Mutex::ThreadSafeBaseIsNotSupportedByType"},{"location":"_autogen/Classes/structbatt_1_1Mutex_1_1ThreadSafeBaseIsNotSupportedByType/#detailed-description","text":"1 2 template < typename > struct batt :: Mutex :: ThreadSafeBaseIsNotSupportedByType ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1NoneType/","text":"batt::NoneType \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::NoneType"},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/","text":"batt::NoopDeleter \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename T > void operator() (T * ) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 template < typename T > inline void operator ()( T * ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::NoopDeleter"},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/#public-functions","text":"Name template <typename T > void operator() (T * ) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/#function-operator","text":"1 2 3 4 template < typename T > inline void operator ()( T * ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/","text":"batt::RadixQueue::Hash \ud83d\udd17 Public Types \ud83d\udd17 Name using usize value_type Public Functions \ud83d\udd17 Name usize operator() (const RadixQueue & r) const Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 1 using batt :: RadixQueue < kCapacityInBits >:: Hash :: value_type = usize ; Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 inline usize operator ()( const RadixQueue & r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RadixQueue::Hash"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-types","text":"Name using usize value_type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-functions","text":"Name usize operator() (const RadixQueue & r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#using-value_type","text":"1 using batt :: RadixQueue < kCapacityInBits >:: Hash :: value_type = usize ;","title":"using value_type"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#function-operator","text":"1 2 3 inline usize operator ()( const RadixQueue & r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/","text":"batt::RadixQueue::Segment \ud83d\udd17 Public Attributes \ud83d\udd17 Name u64 radix u64 value Friends \ud83d\udd17 Name std::ostream & operator<< (std::ostream & out, const Segment & t) Public Attributes Documentation \ud83d\udd17 variable radix \ud83d\udd17 1 u64 radix = 1 ; variable value \ud83d\udd17 1 u64 value = 0 ; Friends \ud83d\udd17 friend operator<< \ud83d\udd17 1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const Segment & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RadixQueue::Segment"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#public-attributes","text":"Name u64 radix u64 value","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#friends","text":"Name std::ostream & operator<< (std::ostream & out, const Segment & t)","title":"Friends"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#variable-radix","text":"1 u64 radix = 1 ;","title":"variable radix"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#variable-value","text":"1 u64 value = 0 ;","title":"variable value"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#friends_1","text":"","title":"Friends"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#friend-operator","text":"1 2 3 4 5 friend std :: ostream & operator << ( std :: ostream & out , const Segment & t ); Updated on 26 August 2022 at 17:30:03 UTC","title":"friend operator&lt;&lt;"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl/","text":"batt::RemoveStatusOrImpl \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: RemoveStatusOrImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RemoveStatusOrImpl"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl/#detailed-description","text":"1 2 template < typename T > struct batt :: RemoveStatusOrImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/","text":"batt::RemoveStatusOrImpl< StatusOr< T > > \ud83d\udd17 More... Inherits from batt::StaticType< T > Additional inherited members \ud83d\udd17 Public Types inherited from batt::StaticType< T > Name using T type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: RemoveStatusOrImpl < StatusOr < T > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RemoveStatusOrImpl< StatusOr< T > >"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/#additional-inherited-members","text":"Public Types inherited from batt::StaticType< T > Name using T type","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: RemoveStatusOrImpl < StatusOr < T > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1RetryState/","text":"batt::RetryState \ud83d\udd17 Public Attributes \ud83d\udd17 Name bool should_retry u64 n_attempts u64 prev_delay_usec u64 next_delay_usec Public Attributes Documentation \ud83d\udd17 variable should_retry \ud83d\udd17 1 bool should_retry = false ; variable n_attempts \ud83d\udd17 1 u64 n_attempts = 0 ; variable prev_delay_usec \ud83d\udd17 1 u64 prev_delay_usec = 0 ; variable next_delay_usec \ud83d\udd17 1 u64 next_delay_usec = 0 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::RetryState"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#public-attributes","text":"Name bool should_retry u64 n_attempts u64 prev_delay_usec u64 next_delay_usec","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-should_retry","text":"1 bool should_retry = false ;","title":"variable should_retry"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-n_attempts","text":"1 u64 n_attempts = 0 ;","title":"variable n_attempts"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-prev_delay_usec","text":"1 u64 prev_delay_usec = 0 ;","title":"variable prev_delay_usec"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-next_delay_usec","text":"1 u64 next_delay_usec = 0 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable next_delay_usec"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/","text":"batt::SeqItem_Impl \ud83d\udd17 More... Public Types \ud83d\udd17 Name using typename std::decay_t< T >::Item type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: SeqItem_Impl ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: SeqItem_Impl < T >:: type = typename std :: decay_t < T >:: Item ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SeqItem_Impl"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#public-types","text":"Name using typename std::decay_t< T >::Item type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#detailed-description","text":"1 2 template < typename T > struct batt :: SeqItem_Impl ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#using-type","text":"1 using batt :: SeqItem_Impl < T >:: type = typename std :: decay_t < T >:: Item ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1SharedPtrImpl/","text":"batt::SharedPtrImpl \ud83d\udd17 More... Inherits from std::conditional< IsRefCounted< T >{}, boost::intrusive_ptr< std::remove_reference_t< T > >, std::shared_ptr< std::remove_reference_t< T > > > Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: SharedPtrImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SharedPtrImpl"},{"location":"_autogen/Classes/structbatt_1_1SharedPtrImpl/#detailed-description","text":"1 2 template < typename T > struct batt :: SharedPtrImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/","text":"batt::SkipNBinder \ud83d\udd17 Public Attributes \ud83d\udd17 Name usize n Public Attributes Documentation \ud83d\udd17 variable n \ud83d\udd17 1 usize n ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::SkipNBinder"},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/#public-attributes","text":"Name usize n","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/#variable-n","text":"1 usize n ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable n"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/","text":"batt::StateMachineBranch \ud83d\udd17 More... Public Types \ud83d\udd17 Name using StateT state_type using StateHash state_hash_type using StateEqual state_equal_type using RadixQueue < StateMachineTraits < StateT >::kRadixQueueSize > delta_type Public Attributes \ud83d\udd17 Name state_type snapshot delta_type delta Detailed Description \ud83d\udd17 1 2 3 4 template < typename StateT , typename StateHash , typename StateEqual > struct batt :: StateMachineBranch ; Public Types Documentation \ud83d\udd17 using state_type \ud83d\udd17 1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: state_type = StateT ; using state_hash_type \ud83d\udd17 1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: state_hash_type = StateHash ; using state_equal_type \ud83d\udd17 1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: state_equal_type = StateEqual ; using delta_type \ud83d\udd17 1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: delta_type = RadixQueue < StateMachineTraits < StateT >:: kRadixQueueSize > ; Public Attributes Documentation \ud83d\udd17 variable snapshot \ud83d\udd17 1 state_type snapshot ; variable delta \ud83d\udd17 1 delta_type delta ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StateMachineBranch"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-types","text":"Name using StateT state_type using StateHash state_hash_type using StateEqual state_equal_type using RadixQueue < StateMachineTraits < StateT >::kRadixQueueSize > delta_type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-attributes","text":"Name state_type snapshot delta_type delta","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#detailed-description","text":"1 2 3 4 template < typename StateT , typename StateHash , typename StateEqual > struct batt :: StateMachineBranch ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-state_type","text":"1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: state_type = StateT ;","title":"using state_type"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-state_hash_type","text":"1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: state_hash_type = StateHash ;","title":"using state_hash_type"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-state_equal_type","text":"1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: state_equal_type = StateEqual ;","title":"using state_equal_type"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-delta_type","text":"1 using batt :: StateMachineBranch < StateT , StateHash , StateEqual >:: delta_type = RadixQueue < StateMachineTraits < StateT >:: kRadixQueueSize > ;","title":"using delta_type"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#variable-snapshot","text":"1 state_type snapshot ;","title":"variable snapshot"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#variable-delta","text":"1 delta_type delta ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable delta"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/","text":"batt::StateMachineModelCheckAdvancedOptions \ud83d\udd17 Public Types \ud83d\udd17 Name using StateMachineModelCheckAdvancedOptions Self Public Functions \ud83d\udd17 Name Self with_default_values () Public Attributes \ud83d\udd17 Name bool pin_shard_to_cpu usize max_loop_iterations_between_flush usize max_loop_iterations_between_update i64 min_running_time_ms Optional < usize > starting_seed Public Types Documentation \ud83d\udd17 using Self \ud83d\udd17 1 using batt :: StateMachineModelCheckAdvancedOptions :: Self = StateMachineModelCheckAdvancedOptions ; Public Functions Documentation \ud83d\udd17 function with_default_values \ud83d\udd17 1 static inline Self with_default_values () Public Attributes Documentation \ud83d\udd17 variable pin_shard_to_cpu \ud83d\udd17 1 bool pin_shard_to_cpu ; variable max_loop_iterations_between_flush \ud83d\udd17 1 usize max_loop_iterations_between_flush ; variable max_loop_iterations_between_update \ud83d\udd17 1 usize max_loop_iterations_between_update ; variable min_running_time_ms \ud83d\udd17 1 i64 min_running_time_ms ; variable starting_seed \ud83d\udd17 1 Optional < usize > starting_seed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StateMachineModelCheckAdvancedOptions"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-types","text":"Name using StateMachineModelCheckAdvancedOptions Self","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-functions","text":"Name Self with_default_values ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-attributes","text":"Name bool pin_shard_to_cpu usize max_loop_iterations_between_flush usize max_loop_iterations_between_update i64 min_running_time_ms Optional < usize > starting_seed","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#using-self","text":"1 using batt :: StateMachineModelCheckAdvancedOptions :: Self = StateMachineModelCheckAdvancedOptions ;","title":"using Self"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#function-with_default_values","text":"1 static inline Self with_default_values ()","title":"function with_default_values"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-pin_shard_to_cpu","text":"1 bool pin_shard_to_cpu ;","title":"variable pin_shard_to_cpu"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-max_loop_iterations_between_flush","text":"1 usize max_loop_iterations_between_flush ;","title":"variable max_loop_iterations_between_flush"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-max_loop_iterations_between_update","text":"1 usize max_loop_iterations_between_update ;","title":"variable max_loop_iterations_between_update"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-min_running_time_ms","text":"1 i64 min_running_time_ms ;","title":"variable min_running_time_ms"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-starting_seed","text":"1 Optional < usize > starting_seed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable starting_seed"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/","text":"batt::StateMachineResult \ud83d\udd17 Public Functions \ud83d\udd17 Name void update_elapsed_time () double compute_rate (usize count) const void update_rates () Public Attributes \ud83d\udd17 Name bool ok usize branch_push_count usize branch_pop_count usize branch_miss_count usize state_count usize self_branch_count std::chrono::steady_clock::time_point start_time usize elapsed_ms double states_per_second double branch_pop_per_second double branch_push_per_second std::bitset< 64 > shards Optional < usize > seed Public Functions Documentation \ud83d\udd17 function update_elapsed_time \ud83d\udd17 1 inline void update_elapsed_time () function compute_rate \ud83d\udd17 1 2 3 inline double compute_rate ( usize count ) const function update_rates \ud83d\udd17 1 inline void update_rates () Public Attributes Documentation \ud83d\udd17 variable ok \ud83d\udd17 1 bool ok = false ; variable branch_push_count \ud83d\udd17 1 usize branch_push_count = 0 ; variable branch_pop_count \ud83d\udd17 1 usize branch_pop_count = 0 ; variable branch_miss_count \ud83d\udd17 1 usize branch_miss_count = 0 ; variable state_count \ud83d\udd17 1 usize state_count = 0 ; variable self_branch_count \ud83d\udd17 1 usize self_branch_count = 0 ; variable start_time \ud83d\udd17 1 std :: chrono :: steady_clock :: time_point start_time ; variable elapsed_ms \ud83d\udd17 1 usize elapsed_ms = 0 ; variable states_per_second \ud83d\udd17 1 double states_per_second = 0.0 ; variable branch_pop_per_second \ud83d\udd17 1 double branch_pop_per_second = 0.0 ; variable branch_push_per_second \ud83d\udd17 1 double branch_push_per_second = 0.0 ; variable shards \ud83d\udd17 1 std :: bitset < 64 > shards { 0 }; variable seed \ud83d\udd17 1 Optional < usize > seed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StateMachineResult"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-functions","text":"Name void update_elapsed_time () double compute_rate (usize count) const void update_rates ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-attributes","text":"Name bool ok usize branch_push_count usize branch_pop_count usize branch_miss_count usize state_count usize self_branch_count std::chrono::steady_clock::time_point start_time usize elapsed_ms double states_per_second double branch_pop_per_second double branch_push_per_second std::bitset< 64 > shards Optional < usize > seed","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#function-update_elapsed_time","text":"1 inline void update_elapsed_time ()","title":"function update_elapsed_time"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#function-compute_rate","text":"1 2 3 inline double compute_rate ( usize count ) const","title":"function compute_rate"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#function-update_rates","text":"1 inline void update_rates ()","title":"function update_rates"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-ok","text":"1 bool ok = false ;","title":"variable ok"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_push_count","text":"1 usize branch_push_count = 0 ;","title":"variable branch_push_count"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_pop_count","text":"1 usize branch_pop_count = 0 ;","title":"variable branch_pop_count"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_miss_count","text":"1 usize branch_miss_count = 0 ;","title":"variable branch_miss_count"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-state_count","text":"1 usize state_count = 0 ;","title":"variable state_count"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-self_branch_count","text":"1 usize self_branch_count = 0 ;","title":"variable self_branch_count"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-start_time","text":"1 std :: chrono :: steady_clock :: time_point start_time ;","title":"variable start_time"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-elapsed_ms","text":"1 usize elapsed_ms = 0 ;","title":"variable elapsed_ms"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-states_per_second","text":"1 double states_per_second = 0.0 ;","title":"variable states_per_second"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_pop_per_second","text":"1 double branch_pop_per_second = 0.0 ;","title":"variable branch_pop_per_second"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_push_per_second","text":"1 double branch_push_per_second = 0.0 ;","title":"variable branch_push_per_second"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-shards","text":"1 std :: bitset < 64 > shards { 0 };","title":"variable shards"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-seed","text":"1 Optional < usize > seed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable seed"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/","text":"batt::StateMachineTraits \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name constexpr usize kRadixQueueSize Detailed Description \ud83d\udd17 1 2 template < typename StateT > struct batt :: StateMachineTraits ; Public Attributes Documentation \ud83d\udd17 variable kRadixQueueSize \ud83d\udd17 1 static constexpr usize kRadixQueueSize = 256 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StateMachineTraits"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#public-attributes","text":"Name constexpr usize kRadixQueueSize","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#detailed-description","text":"1 2 template < typename StateT > struct batt :: StateMachineTraits ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#variable-kradixqueuesize","text":"1 static constexpr usize kRadixQueueSize = 256 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kRadixQueueSize"},{"location":"_autogen/Classes/structbatt_1_1StaticBinaryAssertion/","text":"batt::StaticBinaryAssertion \ud83d\udd17 More... Inherits from std::integral_constant< bool, kCondition > Detailed Description \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename U , T left , typename Op , U right , bool kCondition > struct batt :: StaticBinaryAssertion ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StaticBinaryAssertion"},{"location":"_autogen/Classes/structbatt_1_1StaticBinaryAssertion/#detailed-description","text":"1 2 3 4 5 6 7 template < typename T , typename U , T left , typename Op , U right , bool kCondition > struct batt :: StaticBinaryAssertion ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1StaticSameTypeAssertion/","text":"batt::StaticSameTypeAssertion \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < typename T , typename U > struct batt :: StaticSameTypeAssertion ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StaticSameTypeAssertion"},{"location":"_autogen/Classes/structbatt_1_1StaticSameTypeAssertion/#detailed-description","text":"1 2 3 template < typename T , typename U > struct batt :: StaticSameTypeAssertion ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1StaticType/","text":"batt::StaticType \ud83d\udd17 More... Inherited by batt::RemoveStatusOrImpl< StatusOr< T > > Public Types \ud83d\udd17 Name using T type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: StaticType ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: StaticType < T >:: type = T ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StaticType"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#public-types","text":"Name using T type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#detailed-description","text":"1 2 template < typename T > struct batt :: StaticType ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#using-type","text":"1 using batt :: StaticType < T >:: type = T ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/","text":"batt::StaticValue \ud83d\udd17 More... Public Functions \ud83d\udd17 Name constexpr StaticValue () =default constexpr operator T () const Public Attributes \ud83d\udd17 Name constexpr T value Detailed Description \ud83d\udd17 1 2 3 template < typename T , T kValue > struct batt :: StaticValue ; Public Functions Documentation \ud83d\udd17 function StaticValue \ud83d\udd17 1 constexpr StaticValue () = default function operator T \ud83d\udd17 1 inline constexpr operator T () const Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 1 static constexpr T value = kValue ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StaticValue"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-functions","text":"Name constexpr StaticValue () =default constexpr operator T () const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-attributes","text":"Name constexpr T value","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#detailed-description","text":"1 2 3 template < typename T , T kValue > struct batt :: StaticValue ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#function-staticvalue","text":"1 constexpr StaticValue () = default","title":"function StaticValue"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#function-operator-t","text":"1 inline constexpr operator T () const","title":"function operator T"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#variable-value","text":"1 static constexpr T value = kValue ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable value"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/","text":"batt::Status::CodeEntry \ud83d\udd17 Public Attributes \ud83d\udd17 Name value_type code int enum_value std::string message Public Attributes Documentation \ud83d\udd17 variable code \ud83d\udd17 1 value_type code ; variable enum_value \ud83d\udd17 1 int enum_value ; variable message \ud83d\udd17 1 std :: string message ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Status::CodeEntry"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#public-attributes","text":"Name value_type code int enum_value std::string message","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#variable-code","text":"1 value_type code ;","title":"variable code"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#variable-enum_value","text":"1 int enum_value ;","title":"variable enum_value"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#variable-message","text":"1 std :: string message ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable message"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/","text":"batt::Status::CodeGroup \ud83d\udd17 Public Attributes \ud83d\udd17 Name std::type_index enum_type_index usize index int min_enum_value std::vector< usize > enum_value_to_code std::vector< CodeEntry > entries Public Attributes Documentation \ud83d\udd17 variable enum_type_index \ud83d\udd17 1 std :: type_index enum_type_index { typeid ( int )}; variable index \ud83d\udd17 1 usize index ; variable min_enum_value \ud83d\udd17 1 int min_enum_value ; variable enum_value_to_code \ud83d\udd17 1 std :: vector < usize > enum_value_to_code ; variable entries \ud83d\udd17 1 std :: vector < CodeEntry > entries ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Status::CodeGroup"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#public-attributes","text":"Name std::type_index enum_type_index usize index int min_enum_value std::vector< usize > enum_value_to_code std::vector< CodeEntry > entries","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-enum_type_index","text":"1 std :: type_index enum_type_index { typeid ( int )};","title":"variable enum_type_index"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-index","text":"1 usize index ;","title":"variable index"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-min_enum_value","text":"1 int min_enum_value ;","title":"variable min_enum_value"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-enum_value_to_code","text":"1 std :: vector < usize > enum_value_to_code ;","title":"variable enum_value_to_code"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-entries","text":"1 std :: vector < CodeEntry > entries ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable entries"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/","text":"batt::StrongType::Delta \ud83d\udd17 Inherits from batt::StrongType< T, Tag > Public Functions \ud83d\udd17 Name Delta ( StrongType value) constexpr StrongType () constexpr StrongType (T init_value) Additional inherited members \ud83d\udd17 Public Classes inherited from batt::StrongType< T, Tag > Name struct Delta struct Hash Public Types inherited from batt::StrongType< T, Tag > Name using T value_type using Tag tag_type Public Functions inherited from batt::StrongType< T, Tag > Name constexpr T value () const constexpr operator T () const StrongType & operator+= ( Delta d) StrongType & operator-= ( Delta d) Public Functions Documentation \ud83d\udd17 function Delta \ud83d\udd17 1 2 3 inline Delta ( StrongType value ) function StrongType \ud83d\udd17 1 inline constexpr StrongType () function StrongType \ud83d\udd17 1 2 3 inline explicit constexpr StrongType ( T init_value ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StrongType::Delta"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#public-functions","text":"Name Delta ( StrongType value) constexpr StrongType () constexpr StrongType (T init_value)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#additional-inherited-members","text":"Public Classes inherited from batt::StrongType< T, Tag > Name struct Delta struct Hash Public Types inherited from batt::StrongType< T, Tag > Name using T value_type using Tag tag_type Public Functions inherited from batt::StrongType< T, Tag > Name constexpr T value () const constexpr operator T () const StrongType & operator+= ( Delta d) StrongType & operator-= ( Delta d)","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#function-delta","text":"1 2 3 inline Delta ( StrongType value )","title":"function Delta"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#function-strongtype","text":"1 inline constexpr StrongType ()","title":"function StrongType"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#function-strongtype_1","text":"1 2 3 inline explicit constexpr StrongType ( T init_value ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function StrongType"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/","text":"batt::StrongType::Hash \ud83d\udd17 Public Types \ud83d\udd17 Name using typename std::hash< T >::result_type result_type Public Functions \ud83d\udd17 Name result_type operator() (const StrongType & obj) const Public Types Documentation \ud83d\udd17 using result_type \ud83d\udd17 1 using batt :: StrongType < T , Tag >:: Hash :: result_type = typename std :: hash < T >:: result_type ; Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 inline result_type operator ()( const StrongType & obj ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::StrongType::Hash"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-types","text":"Name using typename std::hash< T >::result_type result_type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-functions","text":"Name result_type operator() (const StrongType & obj) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#using-result_type","text":"1 using batt :: StrongType < T , Tag >:: Hash :: result_type = typename std :: hash < T >:: result_type ;","title":"using result_type"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#function-operator","text":"1 2 3 inline result_type operator ()( const StrongType & obj ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/","text":"batt::TaskSleepImpl \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename DurationT > void operator() (DurationT && duration) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 template < typename DurationT > inline void operator ()( DurationT && duration ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TaskSleepImpl"},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/#public-functions","text":"Name template <typename DurationT > void operator() (DurationT && duration) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/#function-operator","text":"1 2 3 4 template < typename DurationT > inline void operator ()( DurationT && duration ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/","text":"batt::Task::DebugTrace \ud83d\udd17 Public Attributes \ud83d\udd17 Name boost::stacktrace::stacktrace stack_trace std::string debug_info StateBitset state_bits isize stack_growth_bytes Public Attributes Documentation \ud83d\udd17 variable stack_trace \ud83d\udd17 1 boost :: stacktrace :: stacktrace stack_trace ; variable debug_info \ud83d\udd17 1 std :: string debug_info ; variable state_bits \ud83d\udd17 1 StateBitset state_bits ; variable stack_growth_bytes \ud83d\udd17 1 isize stack_growth_bytes ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::Task::DebugTrace"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#public-attributes","text":"Name boost::stacktrace::stacktrace stack_trace std::string debug_info StateBitset state_bits isize stack_growth_bytes","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-stack_trace","text":"1 boost :: stacktrace :: stacktrace stack_trace ;","title":"variable stack_trace"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-debug_info","text":"1 std :: string debug_info ;","title":"variable debug_info"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-state_bits","text":"1 StateBitset state_bits ;","title":"variable state_bits"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-stack_growth_bytes","text":"1 isize stack_growth_bytes ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable stack_growth_bytes"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf/","text":"batt::TupleIndexOf \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < typename TupleT , typename T > struct batt :: TupleIndexOf ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TupleIndexOf"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf/#detailed-description","text":"1 2 3 template < typename TupleT , typename T > struct batt :: TupleIndexOf ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01First_00_01Rest_8_8_8_01_4_00_01T_01_4/","text":"batt::TupleIndexOf< std::tuple< First, Rest... >, T > \ud83d\udd17 More... Inherits from batt::StaticValue< decltype((1u+TupleIndexOf< std::tuple< Rest... >, T >::value)),((1u+TupleIndexOf< std::tuple< Rest... >, T >::value))> Additional inherited members \ud83d\udd17 Public Functions inherited from batt::StaticValue< decltype((1u+TupleIndexOf< std::tuple< Rest... >, T >::value)),((1u+TupleIndexOf< std::tuple< Rest... >, T >::value))> Name constexpr StaticValue () =default constexpr operator T () const Public Attributes inherited from batt::StaticValue< decltype((1u+TupleIndexOf< std::tuple< Rest... >, T >::value)),((1u+TupleIndexOf< std::tuple< Rest... >, T >::value))> Name constexpr T value Detailed Description \ud83d\udd17 1 2 3 4 template < typename T , typename First , typename ... Rest > struct batt :: TupleIndexOf < std :: tuple < First , Rest ... > , T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TupleIndexOf< std::tuple< First, Rest... >, T >"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01First_00_01Rest_8_8_8_01_4_00_01T_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::StaticValue< decltype((1u+TupleIndexOf< std::tuple< Rest... >, T >::value)),((1u+TupleIndexOf< std::tuple< Rest... >, T >::value))> Name constexpr StaticValue () =default constexpr operator T () const Public Attributes inherited from batt::StaticValue< decltype((1u+TupleIndexOf< std::tuple< Rest... >, T >::value)),((1u+TupleIndexOf< std::tuple< Rest... >, T >::value))> Name constexpr T value","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01First_00_01Rest_8_8_8_01_4_00_01T_01_4/#detailed-description","text":"1 2 3 4 template < typename T , typename First , typename ... Rest > struct batt :: TupleIndexOf < std :: tuple < First , Rest ... > , T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01T_00_01Rest_8_8_8_01_4_00_01T_01_4/","text":"batt::TupleIndexOf< std::tuple< T, Rest... >, T > \ud83d\udd17 More... Inherits from batt::StaticValue< decltype(0u),(0u)> Additional inherited members \ud83d\udd17 Public Functions inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr StaticValue () =default constexpr operator T () const Public Attributes inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr T value Detailed Description \ud83d\udd17 1 2 3 template < typename T , typename ... Rest > struct batt :: TupleIndexOf < std :: tuple < T , Rest ... > , T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TupleIndexOf< std::tuple< T, Rest... >, T >"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01T_00_01Rest_8_8_8_01_4_00_01T_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr StaticValue () =default constexpr operator T () const Public Attributes inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr T value","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01T_00_01Rest_8_8_8_01_4_00_01T_01_4/#detailed-description","text":"1 2 3 template < typename T , typename ... Rest > struct batt :: TupleIndexOf < std :: tuple < T , Rest ... > , T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_4_00_01T_01_4/","text":"batt::TupleIndexOf< std::tuple<>, T > \ud83d\udd17 More... Inherits from batt::StaticValue< decltype(0u),(0u)> Additional inherited members \ud83d\udd17 Public Functions inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr StaticValue () =default constexpr operator T () const Public Attributes inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr T value Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: TupleIndexOf < std :: tuple <> , T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::TupleIndexOf< std::tuple<>, T >"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_4_00_01T_01_4/#additional-inherited-members","text":"Public Functions inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr StaticValue () =default constexpr operator T () const Public Attributes inherited from batt::StaticValue< decltype(0u),(0u)> Name constexpr T value","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_4_00_01T_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: TupleIndexOf < std :: tuple <> , T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/","text":"batt::UrlParse \ud83d\udd17 Public Attributes \ud83d\udd17 Name std::string_view scheme std::string_view user std::string_view host Optional < i64 > port std::string_view path std::string_view query std::string_view fragment Public Attributes Documentation \ud83d\udd17 variable scheme \ud83d\udd17 1 std :: string_view scheme ; variable user \ud83d\udd17 1 std :: string_view user ; variable host \ud83d\udd17 1 std :: string_view host ; variable port \ud83d\udd17 1 Optional < i64 > port ; variable path \ud83d\udd17 1 std :: string_view path ; variable query \ud83d\udd17 1 std :: string_view query ; variable fragment \ud83d\udd17 1 std :: string_view fragment ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::UrlParse"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#public-attributes","text":"Name std::string_view scheme std::string_view user std::string_view host Optional < i64 > port std::string_view path std::string_view query std::string_view fragment","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-scheme","text":"1 std :: string_view scheme ;","title":"variable scheme"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-user","text":"1 std :: string_view user ;","title":"variable user"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-host","text":"1 std :: string_view host ;","title":"variable host"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-port","text":"1 Optional < i64 > port ;","title":"variable port"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-path","text":"1 std :: string_view path ;","title":"variable path"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-query","text":"1 std :: string_view query ;","title":"variable query"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-fragment","text":"1 std :: string_view fragment ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable fragment"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/","text":"batt::VecSeqBase \ud83d\udd17 More... Inherited by batt::VecSeq< T > Public Functions \ud83d\udd17 Name VecSeqBase (std::vector< T > && v) Public Attributes \ud83d\udd17 Name std::vector< T > vec Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: VecSeqBase ; Public Functions Documentation \ud83d\udd17 function VecSeqBase \ud83d\udd17 1 2 3 inline explicit VecSeqBase ( std :: vector < T > && v ) Public Attributes Documentation \ud83d\udd17 variable vec \ud83d\udd17 1 std :: vector < T > vec ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::VecSeqBase"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-functions","text":"Name VecSeqBase (std::vector< T > && v)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-attributes","text":"Name std::vector< T > vec","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#detailed-description","text":"1 2 template < typename T > struct batt :: VecSeqBase ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#function-vecseqbase","text":"1 2 3 inline explicit VecSeqBase ( std :: vector < T > && v )","title":"function VecSeqBase"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#variable-vec","text":"1 std :: vector < T > vec ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable vec"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/","text":"batt::WorkSliceParams \ud83d\udd17 Public Functions \ud83d\udd17 Name WorkSliceParams from_worker_pool ( WorkerPool & worker_pool) Public Attributes \ud83d\udd17 Name constexpr TaskSize kDefaultMinTaskSize TaskSize min_task_size TaskCount max_tasks Public Functions Documentation \ud83d\udd17 function from_worker_pool \ud83d\udd17 1 2 3 static inline WorkSliceParams from_worker_pool ( WorkerPool & worker_pool ) Public Attributes Documentation \ud83d\udd17 variable kDefaultMinTaskSize \ud83d\udd17 1 static constexpr TaskSize kDefaultMinTaskSize { 512 }; variable min_task_size \ud83d\udd17 1 TaskSize min_task_size ; variable max_tasks \ud83d\udd17 1 TaskCount max_tasks ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::WorkSliceParams"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-functions","text":"Name WorkSliceParams from_worker_pool ( WorkerPool & worker_pool)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-attributes","text":"Name constexpr TaskSize kDefaultMinTaskSize TaskSize min_task_size TaskCount max_tasks","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#function-from_worker_pool","text":"1 2 3 static inline WorkSliceParams from_worker_pool ( WorkerPool & worker_pool )","title":"function from_worker_pool"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#variable-kdefaultmintasksize","text":"1 static constexpr TaskSize kDefaultMinTaskSize { 512 };","title":"variable kDefaultMinTaskSize"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#variable-min_task_size","text":"1 TaskSize min_task_size ;","title":"variable min_task_size"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#variable-max_tasks","text":"1 TaskCount max_tasks ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable max_tasks"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/","text":"batt::WorkSlicePlan \ud83d\udd17 Public Functions \ud83d\udd17 Name WorkSlicePlan (const WorkSliceParams & params, InputSize input_size) template <typename Iter > WorkSlicePlan (const WorkSliceParams & params, const Iter & first, const Iter & last) Public Attributes \ud83d\udd17 Name InputSize input_size TaskSize task_size TaskCount n_tasks Public Functions Documentation \ud83d\udd17 function WorkSlicePlan \ud83d\udd17 1 2 3 4 inline explicit WorkSlicePlan ( const WorkSliceParams & params , InputSize input_size ) function WorkSlicePlan \ud83d\udd17 1 2 3 4 5 6 template < typename Iter > inline explicit WorkSlicePlan ( const WorkSliceParams & params , const Iter & first , const Iter & last ) Public Attributes Documentation \ud83d\udd17 variable input_size \ud83d\udd17 1 InputSize input_size ; variable task_size \ud83d\udd17 1 TaskSize task_size ; variable n_tasks \ud83d\udd17 1 TaskCount n_tasks ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::WorkSlicePlan"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-functions","text":"Name WorkSlicePlan (const WorkSliceParams & params, InputSize input_size) template <typename Iter > WorkSlicePlan (const WorkSliceParams & params, const Iter & first, const Iter & last)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-attributes","text":"Name InputSize input_size TaskSize task_size TaskCount n_tasks","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#function-worksliceplan","text":"1 2 3 4 inline explicit WorkSlicePlan ( const WorkSliceParams & params , InputSize input_size )","title":"function WorkSlicePlan"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#function-worksliceplan_1","text":"1 2 3 4 5 6 template < typename Iter > inline explicit WorkSlicePlan ( const WorkSliceParams & params , const Iter & first , const Iter & last )","title":"function WorkSlicePlan"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#variable-input_size","text":"1 InputSize input_size ;","title":"variable input_size"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#variable-task_size","text":"1 TaskSize task_size ;","title":"variable task_size"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#variable-n_tasks","text":"1 TaskCount n_tasks ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable n_tasks"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl/","text":"batt::detail::FirstMatchImpl \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < typename CaseTuple , typename ArgsTuple > struct batt :: detail :: FirstMatchImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::FirstMatchImpl"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl/#detailed-description","text":"1 2 3 template < typename CaseTuple , typename ArgsTuple > struct batt :: detail :: FirstMatchImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/","text":"batt::detail::FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > > \ud83d\udd17 More... Inherits from std::conditional_t< IsCallable< CaseFirst, Args &&... >{}, std::integral_constant< usize, 0 >, std::integral_constant< usize, 1+FirstMatchImpl< std::tuple< CaseRest... >, std::tuple< Args... > >{}> > Public Functions \ud83d\udd17 Name template <typename Cases > decltype(auto) operator() (Cases && cases, Args &&... args) const Detailed Description \ud83d\udd17 1 2 3 4 template < typename CaseFirst , typename ... CaseRest , typename ... Args > struct batt :: detail :: FirstMatchImpl < std :: tuple < CaseFirst , CaseRest ... > , std :: tuple < Args ... > > ; Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 template < typename Cases > inline decltype ( auto ) operator ()( Cases && cases , Args && ... args ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#public-functions","text":"Name template <typename Cases > decltype(auto) operator() (Cases && cases, Args &&... args) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#detailed-description","text":"1 2 3 4 template < typename CaseFirst , typename ... CaseRest , typename ... Args > struct batt :: detail :: FirstMatchImpl < std :: tuple < CaseFirst , CaseRest ... > , std :: tuple < Args ... > > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#function-operator","text":"1 2 3 4 5 template < typename Cases > inline decltype ( auto ) operator ()( Cases && cases , Args && ... args ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_4_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4/","text":"batt::detail::FirstMatchImpl< std::tuple<>, std::tuple< Args... > > \ud83d\udd17 More... Inherits from std::integral_constant< usize, 0 > Detailed Description \ud83d\udd17 1 2 template < typename ... Args > struct batt :: detail :: FirstMatchImpl < std :: tuple <> , std :: tuple < Args ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::FirstMatchImpl< std::tuple<>, std::tuple< Args... > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_4_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4/#detailed-description","text":"1 2 template < typename ... Args > struct batt :: detail :: FirstMatchImpl < std :: tuple <> , std :: tuple < Args ... > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/","text":"batt::detail::FirstPhase \ud83d\udd17 Public Types \ud83d\udd17 Name using SecondPhase NextPhase Public Functions \ud83d\udd17 Name const char * name () template <typename Src0 ,typename Src1 > const Src0 & fixed_iter (const Src0 & src_0, const Src1 & ) template <typename Src0 ,typename Src1 > const Src1 & search_iter (const Src0 & , const Src1 & src_1) template <typename Fixed ,typename Search > const Fixed & src_0_iter (const Fixed & fixed, const Search & ) template <typename Fixed ,typename Search > const Search & src_1_iter (const Fixed & , const Search & search) Public Types Documentation \ud83d\udd17 using NextPhase \ud83d\udd17 1 using batt :: detail :: FirstPhase :: NextPhase = SecondPhase ; Public Functions Documentation \ud83d\udd17 function name \ud83d\udd17 1 static inline const char * name () function fixed_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src0 & fixed_iter ( const Src0 & src_0 , const Src1 & ) function search_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src1 & search_iter ( const Src0 & , const Src1 & src_1 ) function src_0_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Fixed & src_0_iter ( const Fixed & fixed , const Search & ) function src_1_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Search & src_1_iter ( const Fixed & , const Search & search ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::FirstPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-types","text":"Name using SecondPhase NextPhase","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-functions","text":"Name const char * name () template <typename Src0 ,typename Src1 > const Src0 & fixed_iter (const Src0 & src_0, const Src1 & ) template <typename Src0 ,typename Src1 > const Src1 & search_iter (const Src0 & , const Src1 & src_1) template <typename Fixed ,typename Search > const Fixed & src_0_iter (const Fixed & fixed, const Search & ) template <typename Fixed ,typename Search > const Search & src_1_iter (const Fixed & , const Search & search)","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#using-nextphase","text":"1 using batt :: detail :: FirstPhase :: NextPhase = SecondPhase ;","title":"using NextPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-name","text":"1 static inline const char * name ()","title":"function name"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-fixed_iter","text":"1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src0 & fixed_iter ( const Src0 & src_0 , const Src1 & )","title":"function fixed_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-search_iter","text":"1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src1 & search_iter ( const Src0 & , const Src1 & src_1 )","title":"function search_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-src_0_iter","text":"1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Fixed & src_0_iter ( const Fixed & fixed , const Search & )","title":"function src_0_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-src_1_iter","text":"1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Search & src_1_iter ( const Fixed & , const Search & search ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function src_1_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl/","text":"batt::detail::IsStatusOrImpl \ud83d\udd17 More... Inherits from false_type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: IsStatusOrImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::IsStatusOrImpl"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: IsStatusOrImpl ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/","text":"batt::detail::IsStatusOrImpl< StatusOr< T > > \ud83d\udd17 More... Inherits from true_type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: IsStatusOrImpl < StatusOr < T > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::IsStatusOrImpl< StatusOr< T > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: IsStatusOrImpl < StatusOr < T > > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/","text":"batt::detail::ModelCheckShardMetrics \ud83d\udd17 Public Attributes \ud83d\udd17 Name i64 stall_count i64 flush_count i64 send_count i64 recv_count Public Attributes Documentation \ud83d\udd17 variable stall_count \ud83d\udd17 1 i64 stall_count = 0 ; variable flush_count \ud83d\udd17 1 i64 flush_count = 0 ; variable send_count \ud83d\udd17 1 i64 send_count = 0 ; variable recv_count \ud83d\udd17 1 i64 recv_count = 0 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::ModelCheckShardMetrics"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#public-attributes","text":"Name i64 stall_count i64 flush_count i64 send_count i64 recv_count","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-stall_count","text":"1 i64 stall_count = 0 ;","title":"variable stall_count"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-flush_count","text":"1 i64 flush_count = 0 ;","title":"variable flush_count"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-send_count","text":"1 i64 send_count = 0 ;","title":"variable send_count"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-recv_count","text":"1 i64 recv_count = 0 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable recv_count"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/","text":"batt::detail::NullableImpl \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::optional< T > type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: NullableImpl ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: NullableImpl < T >:: type = std :: optional < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::NullableImpl"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#public-types","text":"Name using std::optional< T > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: NullableImpl ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#using-type","text":"1 using batt :: detail :: NullableImpl < T >:: type = std :: optional < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/","text":"batt::detail::NullableImpl< T * > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using T * type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: NullableImpl < T * > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: NullableImpl < T * >:: type = T * ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::NullableImpl< T * >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#public-types","text":"Name using T * type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: NullableImpl < T * > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#using-type","text":"1 using batt :: detail :: NullableImpl < T * >:: type = T * ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/","text":"batt::detail::NullableImpl< std::optional< T > > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::optional< T > type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: NullableImpl < std :: optional < T > > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: NullableImpl < std :: optional < T > >:: type = std :: optional < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::NullableImpl< std::optional< T > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#public-types","text":"Name using std::optional< T > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: NullableImpl < std :: optional < T > > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#using-type","text":"1 using batt :: detail :: NullableImpl < std :: optional < T > >:: type = std :: optional < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/","text":"batt::detail::NullableImpl< std::shared_ptr< T > > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::shared_ptr< T > type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: NullableImpl < std :: shared_ptr < T > > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: NullableImpl < std :: shared_ptr < T > >:: type = std :: shared_ptr < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::NullableImpl< std::shared_ptr< T > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#public-types","text":"Name using std::shared_ptr< T > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: NullableImpl < std :: shared_ptr < T > > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#using-type","text":"1 using batt :: detail :: NullableImpl < std :: shared_ptr < T > >:: type = std :: shared_ptr < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/","text":"batt::detail::NullableImpl< std::unique_ptr< T > > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::unique_ptr< T > type Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: detail :: NullableImpl < std :: unique_ptr < T > > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: NullableImpl < std :: unique_ptr < T > >:: type = std :: unique_ptr < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::NullableImpl< std::unique_ptr< T > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#public-types","text":"Name using std::unique_ptr< T > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#detailed-description","text":"1 2 template < typename T > struct batt :: detail :: NullableImpl < std :: unique_ptr < T > > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#using-type","text":"1 using batt :: detail :: NullableImpl < std :: unique_ptr < T > >:: type = std :: unique_ptr < T > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/","text":"batt::detail::SecondPhase \ud83d\udd17 Inherited by batt::detail::ThirdPhase Public Types \ud83d\udd17 Name using ThirdPhase NextPhase Public Functions \ud83d\udd17 Name const char * name () template <typename Src0 ,typename Src1 > const Src1 & fixed_iter (const Src0 & , const Src1 & src_1) template <typename Src0 ,typename Src1 > const Src0 & search_iter (const Src0 & src_0, const Src1 & ) template <typename Fixed ,typename Search > const Search & src_0_iter (const Fixed & , const Search & search) template <typename Fixed ,typename Search > const Fixed & src_1_iter (const Fixed & fixed, const Search & ) Public Types Documentation \ud83d\udd17 using NextPhase \ud83d\udd17 1 using batt :: detail :: SecondPhase :: NextPhase = ThirdPhase ; Public Functions Documentation \ud83d\udd17 function name \ud83d\udd17 1 static inline const char * name () function fixed_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src1 & fixed_iter ( const Src0 & , const Src1 & src_1 ) function search_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src0 & search_iter ( const Src0 & src_0 , const Src1 & ) function src_0_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Search & src_0_iter ( const Fixed & , const Search & search ) function src_1_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Fixed & src_1_iter ( const Fixed & fixed , const Search & ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::SecondPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-types","text":"Name using ThirdPhase NextPhase","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-functions","text":"Name const char * name () template <typename Src0 ,typename Src1 > const Src1 & fixed_iter (const Src0 & , const Src1 & src_1) template <typename Src0 ,typename Src1 > const Src0 & search_iter (const Src0 & src_0, const Src1 & ) template <typename Fixed ,typename Search > const Search & src_0_iter (const Fixed & , const Search & search) template <typename Fixed ,typename Search > const Fixed & src_1_iter (const Fixed & fixed, const Search & )","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#using-nextphase","text":"1 using batt :: detail :: SecondPhase :: NextPhase = ThirdPhase ;","title":"using NextPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-name","text":"1 static inline const char * name ()","title":"function name"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-fixed_iter","text":"1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src1 & fixed_iter ( const Src0 & , const Src1 & src_1 )","title":"function fixed_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-search_iter","text":"1 2 3 4 5 6 template < typename Src0 , typename Src1 > static inline const Src0 & search_iter ( const Src0 & src_0 , const Src1 & )","title":"function search_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-src_0_iter","text":"1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Search & src_0_iter ( const Fixed & , const Search & search )","title":"function src_0_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-src_1_iter","text":"1 2 3 4 5 6 template < typename Fixed , typename Search > static inline const Fixed & src_1_iter ( const Fixed & fixed , const Search & ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function src_1_iter"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/","text":"batt::detail::ThirdPhase \ud83d\udd17 Inherits from batt::detail::SecondPhase Public Functions \ud83d\udd17 Name const char * name () Additional inherited members \ud83d\udd17 Public Types inherited from batt::detail::SecondPhase Name using ThirdPhase NextPhase Public Functions inherited from batt::detail::SecondPhase Name template <typename Src0 ,typename Src1 > const Src1 & fixed_iter (const Src0 & , const Src1 & src_1) template <typename Src0 ,typename Src1 > const Src0 & search_iter (const Src0 & src_0, const Src1 & ) template <typename Fixed ,typename Search > const Search & src_0_iter (const Fixed & , const Search & search) template <typename Fixed ,typename Search > const Fixed & src_1_iter (const Fixed & fixed, const Search & ) Public Functions Documentation \ud83d\udd17 function name \ud83d\udd17 1 static inline const char * name () Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::ThirdPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#public-functions","text":"Name const char * name ()","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#additional-inherited-members","text":"Public Types inherited from batt::detail::SecondPhase Name using ThirdPhase NextPhase Public Functions inherited from batt::detail::SecondPhase Name template <typename Src0 ,typename Src1 > const Src1 & fixed_iter (const Src0 & , const Src1 & src_1) template <typename Src0 ,typename Src1 > const Src0 & search_iter (const Src0 & src_0, const Src1 & ) template <typename Fixed ,typename Search > const Search & src_0_iter (const Fixed & , const Search & search) template <typename Fixed ,typename Search > const Fixed & src_1_iter (const Fixed & fixed, const Search & )","title":"Additional inherited members"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#function-name","text":"1 static inline const char * name () Updated on 26 August 2022 at 17:30:03 UTC","title":"function name"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult/","text":"batt::detail::VisitorResult \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename Variant > struct batt :: detail :: VisitorResult ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult/#detailed-description","text":"1 2 3 template < typename Visitor , typename Variant > struct batt :: detail :: VisitorResult ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/","text":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts >()))... > type Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#public-types","text":"Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts >()))... > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#detailed-description","text":"1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#using-type","text":"1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/","text":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > & > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts & >()))... > type Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > & > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > & >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts & > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > & >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#public-types","text":"Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts & >()))... > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#detailed-description","text":"1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > & > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#using-type","text":"1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > & >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts & > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/","text":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > && > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts && >()))... > type Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > && > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > && >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts && > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > && >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#public-types","text":"Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts && >()))... > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#detailed-description","text":"1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > && > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#using-type","text":"1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > && >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts && > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/","text":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > const > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts const >()))... > type Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts const > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > const >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#public-types","text":"Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts const >()))... > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#detailed-description","text":"1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#using-type","text":"1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts const > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/","text":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > const & > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts const & >()))... > type Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const & > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const & >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts const & > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > const & >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#public-types","text":"Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts const & >()))... > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#detailed-description","text":"1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const & > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#using-type","text":"1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const & >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts const & > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/","text":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > const && > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts const && >()))... > type Detailed Description \ud83d\udd17 1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const && > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const && >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts const && > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail::VisitorResult< Visitor, std::variant< Ts... > const && >"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#public-types","text":"Name using std::common_type_t< decltype(std::declval< Visitor >()(std::declval< Ts const && >()))... > type","title":"Public Types"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#detailed-description","text":"1 2 3 template < typename Visitor , typename ... Ts > struct batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const && > ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#using-type","text":"1 using batt :: detail :: VisitorResult < Visitor , std :: variant < Ts ... > const && >:: type = std :: common_type_t < decltype ( std :: declval < Visitor > ()( std :: declval < Ts const && > ()))... > ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using type"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/","text":"batt::seq::Addition \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename L ,typename R > decltype(auto) operator() (L && l, R && r) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename R > inline decltype ( auto ) operator ()( L && l , R && r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Addition"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/#public-functions","text":"Name template <typename L ,typename R > decltype(auto) operator() (L && l, R && r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/#function-operator","text":"1 2 3 4 5 6 template < typename L , typename R > inline decltype ( auto ) operator ()( L && l , R && r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AllBinder/","text":"batt::seq::AllBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::AllBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AnyBinder/","text":"batt::seq::AnyBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::AnyBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/","text":"batt::seq::ApplyBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name SeqFn seq_fn Detailed Description \ud83d\udd17 1 2 template < typename SeqFn > struct batt :: seq :: ApplyBinder ; Public Attributes Documentation \ud83d\udd17 variable seq_fn \ud83d\udd17 1 SeqFn seq_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::ApplyBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#public-attributes","text":"Name SeqFn seq_fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#detailed-description","text":"1 2 template < typename SeqFn > struct batt :: seq :: ApplyBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#variable-seq_fn","text":"1 SeqFn seq_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable seq_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/","text":"batt::seq::AttachBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name D data Detailed Description \ud83d\udd17 1 2 template < typename D > struct batt :: seq :: AttachBinder ; Public Attributes Documentation \ud83d\udd17 variable data \ud83d\udd17 1 D data ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::AttachBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#public-attributes","text":"Name D data","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#detailed-description","text":"1 2 template < typename D > struct batt :: seq :: AttachBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#variable-data","text":"1 D data ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable data"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1BoxedBinder/","text":"batt::seq::BoxedBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::BoxedBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1CacheNextBinder/","text":"batt::seq::CacheNextBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::CacheNextBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/","text":"batt::seq::ChainBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Seq2 seq2 Detailed Description \ud83d\udd17 1 2 template < typename Seq2 > struct batt :: seq :: ChainBinder ; Public Attributes Documentation \ud83d\udd17 variable seq2 \ud83d\udd17 1 Seq2 seq2 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::ChainBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#public-attributes","text":"Name Seq2 seq2","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#detailed-description","text":"1 2 template < typename Seq2 > struct batt :: seq :: ChainBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#variable-seq2","text":"1 Seq2 seq2 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable seq2"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Collect/","text":"batt::seq::Collect \ud83d\udd17 More... Detailed Description \ud83d\udd17 1 2 template < typename T > struct batt :: seq :: Collect ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Collect"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Collect/#detailed-description","text":"1 2 template < typename T > struct batt :: seq :: Collect ; Updated on 26 August 2022 at 17:30:03 UTC","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1CollectVec/","text":"batt::seq::CollectVec \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::CollectVec"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Consume/","text":"batt::seq::Consume \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Consume"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1CountBinder/","text":"batt::seq::CountBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::CountBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/","text":"batt::seq::DecayItem \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename T > std::decay_t< T > operator() (T && val) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 template < typename T > inline std :: decay_t < T > operator ()( T && val ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::DecayItem"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/#public-functions","text":"Name template <typename T > std::decay_t< T > operator() (T && val) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/#function-operator","text":"1 2 3 4 template < typename T > inline std :: decay_t < T > operator ()( T && val ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/","text":"batt::seq::Deref \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename T > auto operator() (T && val) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 template < typename T > inline auto operator ()( T && val ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Deref"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/#public-functions","text":"Name template <typename T > auto operator() (T && val) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/#function-operator","text":"1 2 3 4 template < typename T > inline auto operator ()( T && val ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/","text":"batt::seq::FilterBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Predicate predicate Detailed Description \ud83d\udd17 1 2 template < typename Predicate > struct batt :: seq :: FilterBinder ; Public Attributes Documentation \ud83d\udd17 variable predicate \ud83d\udd17 1 Predicate predicate ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::FilterBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#public-attributes","text":"Name Predicate predicate","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#detailed-description","text":"1 2 template < typename Predicate > struct batt :: seq :: FilterBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#variable-predicate","text":"1 Predicate predicate ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable predicate"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/","text":"batt::seq::FilterMapBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Fn fn Detailed Description \ud83d\udd17 1 2 template < typename Fn > struct batt :: seq :: FilterMapBinder ; Public Attributes Documentation \ud83d\udd17 variable fn \ud83d\udd17 1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::FilterMapBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#public-attributes","text":"Name Fn fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#detailed-description","text":"1 2 template < typename Fn > struct batt :: seq :: FilterMapBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#variable-fn","text":"1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FirstBinder/","text":"batt::seq::FirstBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::FirstBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FlattenBinder/","text":"batt::seq::FlattenBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::FlattenBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/","text":"batt::seq::ForEachBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Fn fn Detailed Description \ud83d\udd17 1 2 template < typename Fn > struct batt :: seq :: ForEachBinder ; Public Attributes Documentation \ud83d\udd17 variable fn \ud83d\udd17 1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::ForEachBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#public-attributes","text":"Name Fn fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#detailed-description","text":"1 2 template < typename Fn > struct batt :: seq :: ForEachBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#variable-fn","text":"1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FuseBinder/","text":"batt::seq::FuseBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::FuseBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/","text":"batt::seq::GroupByBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name GroupEq group_eq Detailed Description \ud83d\udd17 1 2 template < typename GroupEq > struct batt :: seq :: GroupByBinder ; Public Attributes Documentation \ud83d\udd17 variable group_eq \ud83d\udd17 1 GroupEq group_eq ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::GroupByBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#public-attributes","text":"Name GroupEq group_eq","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#detailed-description","text":"1 2 template < typename GroupEq > struct batt :: seq :: GroupByBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#variable-group_eq","text":"1 GroupEq group_eq ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable group_eq"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/","text":"batt::seq::InnerReduceBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name ReduceFn reduce_fn Detailed Description \ud83d\udd17 1 2 template < typename ReduceFn > struct batt :: seq :: InnerReduceBinder ; Public Attributes Documentation \ud83d\udd17 variable reduce_fn \ud83d\udd17 1 ReduceFn reduce_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::InnerReduceBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#public-attributes","text":"Name ReduceFn reduce_fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#detailed-description","text":"1 2 template < typename ReduceFn > struct batt :: seq :: InnerReduceBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#variable-reduce_fn","text":"1 ReduceFn reduce_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable reduce_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/","text":"batt::seq::InspectAdjacentBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Fn fn Detailed Description \ud83d\udd17 1 2 template < typename Fn > struct batt :: seq :: InspectAdjacentBinder ; Public Attributes Documentation \ud83d\udd17 variable fn \ud83d\udd17 1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::InspectAdjacentBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#public-attributes","text":"Name Fn fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#detailed-description","text":"1 2 template < typename Fn > struct batt :: seq :: InspectAdjacentBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#variable-fn","text":"1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/","text":"batt::seq::IsNotFalse \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename T > bool operator() (T && val) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 template < typename T > inline bool operator ()( T && val ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::IsNotFalse"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/#public-functions","text":"Name template <typename T > bool operator() (T && val) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/#function-operator","text":"1 2 3 4 template < typename T > inline bool operator ()( T && val ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/","text":"batt::seq::IsSortedBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Compare compare Detailed Description \ud83d\udd17 1 2 template < typename Compare > struct batt :: seq :: IsSortedBinder ; Public Attributes Documentation \ud83d\udd17 variable compare \ud83d\udd17 1 Compare compare ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::IsSortedBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#public-attributes","text":"Name Compare compare","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#detailed-description","text":"1 2 template < typename Compare > struct batt :: seq :: IsSortedBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#variable-compare","text":"1 Compare compare ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable compare"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/","text":"batt::seq::KMergeByBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Compare compare Detailed Description \ud83d\udd17 1 2 template < typename Compare > struct batt :: seq :: KMergeByBinder ; Public Attributes Documentation \ud83d\udd17 variable compare \ud83d\udd17 1 Compare compare ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::KMergeByBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#public-attributes","text":"Name Compare compare","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#detailed-description","text":"1 2 template < typename Compare > struct batt :: seq :: KMergeByBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#variable-compare","text":"1 Compare compare ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable compare"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/","text":"batt::seq::KMergeBy::HeapOrder \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename L ,typename R > bool operator() (L * l, R * r) const Public Attributes \ud83d\udd17 Name Compare compare_ Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename R > inline bool operator ()( L * l , R * r ) const Public Attributes Documentation \ud83d\udd17 variable compare_ \ud83d\udd17 1 Compare compare_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::KMergeBy::HeapOrder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/#public-functions","text":"Name template <typename L ,typename R > bool operator() (L * l, R * r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/#public-attributes","text":"Name Compare compare_","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/#function-operator","text":"1 2 3 4 5 6 template < typename L , typename R > inline bool operator ()( L * l , R * r ) const","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/#variable-compare_","text":"1 Compare compare_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable compare_"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1LastBinder/","text":"batt::seq::LastBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::LastBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/","text":"batt::seq::MapAdjacentBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Fn fn Detailed Description \ud83d\udd17 1 2 template < typename Fn > struct batt :: seq :: MapAdjacentBinder ; Public Attributes Documentation \ud83d\udd17 variable fn \ud83d\udd17 1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapAdjacentBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#public-attributes","text":"Name Fn fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#detailed-description","text":"1 2 template < typename Fn > struct batt :: seq :: MapAdjacentBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#variable-fn","text":"1 Fn fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/","text":"batt::seq::MapBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name MapFn map_fn Detailed Description \ud83d\udd17 1 2 template < typename MapFn > struct batt :: seq :: MapBinder ; Public Attributes Documentation \ud83d\udd17 variable map_fn \ud83d\udd17 1 MapFn map_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#public-attributes","text":"Name MapFn map_fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#detailed-description","text":"1 2 template < typename MapFn > struct batt :: seq :: MapBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#variable-map_fn","text":"1 MapFn map_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable map_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/","text":"batt::seq::MapFoldBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name State state MapFn map_fn Detailed Description \ud83d\udd17 1 2 3 template < typename State , typename MapFn > struct batt :: seq :: MapFoldBinder ; Public Attributes Documentation \ud83d\udd17 variable state \ud83d\udd17 1 State state ; variable map_fn \ud83d\udd17 1 MapFn map_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapFoldBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#public-attributes","text":"Name State state MapFn map_fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#detailed-description","text":"1 2 3 template < typename State , typename MapFn > struct batt :: seq :: MapFoldBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#variable-state","text":"1 State state ;","title":"variable state"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#variable-map_fn","text":"1 MapFn map_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable map_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/","text":"batt::seq::MapPairwiseBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name RightSeq right MapFn map_fn Detailed Description \ud83d\udd17 1 2 3 template < typename RightSeq , typename MapFn > struct batt :: seq :: MapPairwiseBinder ; Public Attributes Documentation \ud83d\udd17 variable right \ud83d\udd17 1 RightSeq right ; variable map_fn \ud83d\udd17 1 MapFn map_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MapPairwiseBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#public-attributes","text":"Name RightSeq right MapFn map_fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#detailed-description","text":"1 2 3 template < typename RightSeq , typename MapFn > struct batt :: seq :: MapPairwiseBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#variable-right","text":"1 RightSeq right ;","title":"variable right"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#variable-map_fn","text":"1 MapFn map_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable map_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/","text":"batt::seq::MergeByBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name RightSeq right Compare compare Detailed Description \ud83d\udd17 1 2 3 template < typename RightSeq , typename Compare > struct batt :: seq :: MergeByBinder ; Public Attributes Documentation \ud83d\udd17 variable right \ud83d\udd17 1 RightSeq right ; variable compare \ud83d\udd17 1 Compare compare ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MergeByBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#public-attributes","text":"Name RightSeq right Compare compare","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#detailed-description","text":"1 2 3 template < typename RightSeq , typename Compare > struct batt :: seq :: MergeByBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#variable-right","text":"1 RightSeq right ;","title":"variable right"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#variable-compare","text":"1 Compare compare ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable compare"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/","text":"batt::seq::MergeBy::ToItem \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename T ,typename =std::enable_if_t<!std::is_same_v >> Item operator() (T && item) const template <typename T ,typename =std::enable_if_t >,typename =void> Item operator() (T && item) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 template < typename T , typename = std :: enable_if_t <! std :: is_same_v < Item , T &&>>> inline Item operator ()( T && item ) const function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < std :: is_same_v < Item , T &&>> , typename = void > inline Item operator ()( T && item ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::MergeBy::ToItem"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#public-functions","text":"Name template <typename T ,typename =std::enable_if_t<!std::is_same_v >> Item operator() (T && item) const template <typename T ,typename =std::enable_if_t >,typename =void> Item operator() (T && item) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#function-operator","text":"1 2 3 4 5 template < typename T , typename = std :: enable_if_t <! std :: is_same_v < Item , T &&>>> inline Item operator ()( T && item ) const","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#function-operator_1","text":"1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < std :: is_same_v < Item , T &&>> , typename = void > inline Item operator ()( T && item ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/","text":"batt::seq::NaturalEquals \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename L ,typename R > bool operator() (L && l, R && r) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename R > inline bool operator ()( L && l , R && r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::NaturalEquals"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/#public-functions","text":"Name template <typename L ,typename R > bool operator() (L && l, R && r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/#function-operator","text":"1 2 3 4 5 6 template < typename L , typename R > inline bool operator ()( L && l , R && r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/","text":"batt::seq::NaturalOrder \ud83d\udd17 Public Functions \ud83d\udd17 Name template <typename L ,typename R > bool operator() (L && l, R && r) const Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename R > inline bool operator ()( L && l , R && r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::NaturalOrder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/#public-functions","text":"Name template <typename L ,typename R > bool operator() (L && l, R && r) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/#function-operator","text":"1 2 3 4 5 6 template < typename L , typename R > inline bool operator ()( L && l , R && r ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/","text":"batt::seq::PrependBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Item item Detailed Description \ud83d\udd17 1 2 template < typename Item > struct batt :: seq :: PrependBinder ; Public Attributes Documentation \ud83d\udd17 variable item \ud83d\udd17 1 Item item ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::PrependBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#public-attributes","text":"Name Item item","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#detailed-description","text":"1 2 template < typename Item > struct batt :: seq :: PrependBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#variable-item","text":"1 Item item ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable item"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/","text":"batt::seq::PrintOut \ud83d\udd17 Public Attributes \ud83d\udd17 Name std::ostream & out std::string_view sep Public Attributes Documentation \ud83d\udd17 variable out \ud83d\udd17 1 std :: ostream & out ; variable sep \ud83d\udd17 1 std :: string_view sep ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::PrintOut"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#public-attributes","text":"Name std::ostream & out std::string_view sep","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#variable-out","text":"1 std :: ostream & out ;","title":"variable out"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#variable-sep","text":"1 std :: string_view sep ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable sep"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintableBinder/","text":"batt::seq::PrintableBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::PrintableBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ProductBinder/","text":"batt::seq::ProductBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::ProductBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/","text":"batt::seq::ReduceBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name State state ReduceFn reduce_fn Detailed Description \ud83d\udd17 1 2 3 template < typename State , typename ReduceFn > struct batt :: seq :: ReduceBinder ; Public Attributes Documentation \ud83d\udd17 variable state \ud83d\udd17 1 State state ; variable reduce_fn \ud83d\udd17 1 ReduceFn reduce_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::ReduceBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#public-attributes","text":"Name State state ReduceFn reduce_fn","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#detailed-description","text":"1 2 3 template < typename State , typename ReduceFn > struct batt :: seq :: ReduceBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#variable-state","text":"1 State state ;","title":"variable state"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#variable-reduce_fn","text":"1 ReduceFn reduce_fn ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable reduce_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/","text":"batt::seq::Reverse \ud83d\udd17 More... Inherits from Fn Public Functions \ud83d\udd17 Name template <typename Left ,typename Right > decltype(auto) operator() (Left && left, Right && right) const Detailed Description \ud83d\udd17 1 2 template < typename Fn > struct batt :: seq :: Reverse ; Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 1 2 3 4 5 6 template < typename Left , typename Right > inline decltype ( auto ) operator ()( Left && left , Right && right ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::Reverse"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#public-functions","text":"Name template <typename Left ,typename Right > decltype(auto) operator() (Left && left, Right && right) const","title":"Public Functions"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#detailed-description","text":"1 2 template < typename Fn > struct batt :: seq :: Reverse ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#function-operator","text":"1 2 3 4 5 6 template < typename Left , typename Right > inline decltype ( auto ) operator ()( Left && left , Right && right ) const Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator()"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/","text":"batt::seq::RollingBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name BinaryFn binary_fn T initial Detailed Description \ud83d\udd17 1 2 3 template < typename T , typename BinaryFn > struct batt :: seq :: RollingBinder ; Public Attributes Documentation \ud83d\udd17 variable binary_fn \ud83d\udd17 1 BinaryFn binary_fn ; variable initial \ud83d\udd17 1 T initial ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::RollingBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#public-attributes","text":"Name BinaryFn binary_fn T initial","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#detailed-description","text":"1 2 3 template < typename T , typename BinaryFn > struct batt :: seq :: RollingBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#variable-binary_fn","text":"1 BinaryFn binary_fn ;","title":"variable binary_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#variable-initial","text":"1 T initial ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable initial"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RunningTotalBinder/","text":"batt::seq::RunningTotalBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::RunningTotalBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/","text":"batt::seq::SpliceBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name std::size_t n InnerSeq inner_seq Detailed Description \ud83d\udd17 1 2 template < typename InnerSeq > struct batt :: seq :: SpliceBinder ; Public Attributes Documentation \ud83d\udd17 variable n \ud83d\udd17 1 std :: size_t n ; variable inner_seq \ud83d\udd17 1 InnerSeq inner_seq ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::SpliceBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#public-attributes","text":"Name std::size_t n InnerSeq inner_seq","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#detailed-description","text":"1 2 template < typename InnerSeq > struct batt :: seq :: SpliceBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#variable-n","text":"1 std :: size_t n ;","title":"variable n"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#variable-inner_seq","text":"1 InnerSeq inner_seq ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable inner_seq"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1StatusOkBinder/","text":"batt::seq::StatusOkBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::StatusOkBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SumBinder/","text":"batt::seq::SumBinder \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::SumBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/","text":"batt::seq::TakeNBinder \ud83d\udd17 Public Attributes \ud83d\udd17 Name usize n Public Attributes Documentation \ud83d\udd17 variable n \ud83d\udd17 1 usize n ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::TakeNBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/#public-attributes","text":"Name usize n","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/#variable-n","text":"1 usize n ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable n"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/","text":"batt::seq::TakeWhileBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name Predicate predicate Detailed Description \ud83d\udd17 1 2 template < typename Predicate > struct batt :: seq :: TakeWhileBinder ; Public Attributes Documentation \ud83d\udd17 variable predicate \ud83d\udd17 1 Predicate predicate ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::TakeWhileBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#public-attributes","text":"Name Predicate predicate","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#detailed-description","text":"1 2 template < typename Predicate > struct batt :: seq :: TakeWhileBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#variable-predicate","text":"1 Predicate predicate ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable predicate"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/","text":"batt::seq::WriteToBinder \ud83d\udd17 More... Public Attributes \ud83d\udd17 Name AsyncWriteStream dst Detailed Description \ud83d\udd17 1 2 template < typename AsyncWriteStream > struct batt :: seq :: WriteToBinder ; Public Attributes Documentation \ud83d\udd17 variable dst \ud83d\udd17 1 AsyncWriteStream dst ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq::WriteToBinder"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#public-attributes","text":"Name AsyncWriteStream dst","title":"Public Attributes"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#detailed-description","text":"1 2 template < typename AsyncWriteStream > struct batt :: seq :: WriteToBinder ;","title":"Detailed Description"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#variable-dst","text":"1 AsyncWriteStream dst ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable dst"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/","text":"pico_http::ChunkedDecoder \ud83d\udd17 Public Attributes \ud83d\udd17 Name usize bytes_left_in_chunk bool consume_trailer i8 hex_count_ i8 state_ Public Attributes Documentation \ud83d\udd17 variable bytes_left_in_chunk \ud83d\udd17 1 usize bytes_left_in_chunk ; variable consume_trailer \ud83d\udd17 1 bool consume_trailer ; variable hex_count_ \ud83d\udd17 1 i8 hex_count_ ; variable state_ \ud83d\udd17 1 i8 state_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::ChunkedDecoder"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#public-attributes","text":"Name usize bytes_left_in_chunk bool consume_trailer i8 hex_count_ i8 state_","title":"Public Attributes"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-bytes_left_in_chunk","text":"1 usize bytes_left_in_chunk ;","title":"variable bytes_left_in_chunk"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-consume_trailer","text":"1 bool consume_trailer ;","title":"variable consume_trailer"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-hex_count_","text":"1 i8 hex_count_ ;","title":"variable hex_count_"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-state_","text":"1 i8 state_ ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable state_"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/","text":"pico_http::DecodeResult \ud83d\udd17 Public Attributes \ud83d\udd17 Name bool done usize bytes_consumed Public Attributes Documentation \ud83d\udd17 variable done \ud83d\udd17 1 bool done ; variable bytes_consumed \ud83d\udd17 1 usize bytes_consumed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::DecodeResult"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#public-attributes","text":"Name bool done usize bytes_consumed","title":"Public Attributes"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#variable-done","text":"1 bool done ;","title":"variable done"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#variable-bytes_consumed","text":"1 usize bytes_consumed ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable bytes_consumed"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/","text":"pico_http::MessageHeader \ud83d\udd17 Public Attributes \ud83d\udd17 Name std::string_view name std::string_view value Public Attributes Documentation \ud83d\udd17 variable name \ud83d\udd17 1 std :: string_view name ; variable value \ud83d\udd17 1 std :: string_view value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::MessageHeader"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#public-attributes","text":"Name std::string_view name std::string_view value","title":"Public Attributes"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#variable-name","text":"1 std :: string_view name ;","title":"variable name"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#variable-value","text":"1 std :: string_view value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable value"},{"location":"_autogen/Classes/structpico__http_1_1Request/","text":"pico_http::Request \ud83d\udd17 Public Functions \ud83d\udd17 Name int parse (const char * buf, usize len, usize last_len =0) int parse (const batt::ConstBuffer & buf) Public Attributes \ud83d\udd17 Name std::string_view method std::string_view path int major_version int minor_version batt::SmallVec< MessageHeader , kDefaultNumHeaders > headers Public Functions Documentation \ud83d\udd17 function parse \ud83d\udd17 1 2 3 4 5 inline int parse ( const char * buf , usize len , usize last_len = 0 ) function parse \ud83d\udd17 1 2 3 inline int parse ( const batt :: ConstBuffer & buf ) Public Attributes Documentation \ud83d\udd17 variable method \ud83d\udd17 1 std :: string_view method ; variable path \ud83d\udd17 1 std :: string_view path ; variable major_version \ud83d\udd17 1 int major_version ; variable minor_version \ud83d\udd17 1 int minor_version ; variable headers \ud83d\udd17 1 batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::Request"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-functions","text":"Name int parse (const char * buf, usize len, usize last_len =0) int parse (const batt::ConstBuffer & buf)","title":"Public Functions"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-attributes","text":"Name std::string_view method std::string_view path int major_version int minor_version batt::SmallVec< MessageHeader , kDefaultNumHeaders > headers","title":"Public Attributes"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structpico__http_1_1Request/#function-parse","text":"1 2 3 4 5 inline int parse ( const char * buf , usize len , usize last_len = 0 )","title":"function parse"},{"location":"_autogen/Classes/structpico__http_1_1Request/#function-parse_1","text":"1 2 3 inline int parse ( const batt :: ConstBuffer & buf )","title":"function parse"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-method","text":"1 std :: string_view method ;","title":"variable method"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-path","text":"1 std :: string_view path ;","title":"variable path"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-major_version","text":"1 int major_version ;","title":"variable major_version"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-minor_version","text":"1 int minor_version ;","title":"variable minor_version"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-headers","text":"1 batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable headers"},{"location":"_autogen/Classes/structpico__http_1_1Response/","text":"pico_http::Response \ud83d\udd17 Public Functions \ud83d\udd17 Name int parse (const char * buf, usize len, usize last_len =0) int parse (const batt::ConstBuffer & buf) Public Attributes \ud83d\udd17 Name int major_version int minor_version int status std::string_view message batt::SmallVec< MessageHeader , kDefaultNumHeaders > headers Public Functions Documentation \ud83d\udd17 function parse \ud83d\udd17 1 2 3 4 5 inline int parse ( const char * buf , usize len , usize last_len = 0 ) function parse \ud83d\udd17 1 2 3 inline int parse ( const batt :: ConstBuffer & buf ) Public Attributes Documentation \ud83d\udd17 variable major_version \ud83d\udd17 1 int major_version ; variable minor_version \ud83d\udd17 1 int minor_version ; variable status \ud83d\udd17 1 int status ; variable message \ud83d\udd17 1 std :: string_view message ; variable headers \ud83d\udd17 1 batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::Response"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-functions","text":"Name int parse (const char * buf, usize len, usize last_len =0) int parse (const batt::ConstBuffer & buf)","title":"Public Functions"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-attributes","text":"Name int major_version int minor_version int status std::string_view message batt::SmallVec< MessageHeader , kDefaultNumHeaders > headers","title":"Public Attributes"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"_autogen/Classes/structpico__http_1_1Response/#function-parse","text":"1 2 3 4 5 inline int parse ( const char * buf , usize len , usize last_len = 0 )","title":"function parse"},{"location":"_autogen/Classes/structpico__http_1_1Response/#function-parse_1","text":"1 2 3 inline int parse ( const batt :: ConstBuffer & buf )","title":"function parse"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-major_version","text":"1 int major_version ;","title":"variable major_version"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-minor_version","text":"1 int minor_version ;","title":"variable minor_version"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-status","text":"1 int status ;","title":"variable status"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-message","text":"1 std :: string_view message ;","title":"variable message"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-headers","text":"1 batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable headers"},{"location":"_autogen/Examples/","text":"Examples \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"Examples"},{"location":"_autogen/Files/","text":"Files \ud83d\udd17 file README.md dir batteries file batteries/assert.hpp dir batteries/algo file batteries/algo/parallel_accumulate.hpp file batteries/algo/parallel_copy.hpp file batteries/algo/parallel_merge.hpp file batteries/algo/parallel_running_total.hpp file batteries/algo/parallel_transform.hpp file batteries/algo/running_total.hpp dir batteries/async file batteries/async/backoff.hpp file batteries/async/buffer_source.hpp file batteries/async/buffer_source_impl.hpp file batteries/async/channel.hpp file batteries/async/continuation.hpp file batteries/async/debug_info.hpp file batteries/async/debug_info_decl.hpp file batteries/async/debug_info_impl.hpp file batteries/async/dump_tasks.hpp file batteries/async/fake_execution_context.hpp file batteries/async/fake_execution_context_decl.hpp file batteries/async/fake_execution_context_impl.hpp file batteries/async/fake_executor.hpp file batteries/async/fake_executor_decl.hpp file batteries/async/fake_executor_impl.hpp file batteries/async/fake_task_scheduler.hpp file batteries/async/fake_time_service.hpp file batteries/async/fake_time_service_decl.hpp file batteries/async/fake_time_service_impl.hpp file batteries/async/future.hpp file batteries/async/future_decl.hpp file batteries/async/future_impl.hpp file batteries/async/grant.hpp file batteries/async/grant_decl.hpp file batteries/async/grant_impl.hpp file batteries/async/handler.hpp file batteries/async/io_result.hpp file batteries/async/latch.hpp file batteries/async/mutex.hpp file batteries/async/pin.hpp file batteries/async/queue.hpp file batteries/async/rate_limiter.hpp file batteries/async/runtime.hpp file batteries/async/single_thread_executor.hpp file batteries/async/slice_work.hpp file batteries/async/slice_work_impl.hpp file batteries/async/stream_buffer.hpp file batteries/async/stream_buffer_impl.hpp file batteries/async/task.hpp file batteries/async/task_decl.hpp file batteries/async/task_impl.hpp file batteries/async/task_scheduler.hpp file batteries/async/types.hpp file batteries/async/watch.hpp file batteries/async/watch_decl.hpp file batteries/async/watch_impl.hpp file batteries/async/work_context.hpp file batteries/async/worker.hpp file batteries/async/worker_pool.hpp file batteries/async/worker_pool_impl.hpp dir batteries/http file batteries/http/host_address.hpp file batteries/http/http_chunk_decoder.hpp file batteries/http/http_chunk_encoder.hpp file batteries/http/http_client.hpp file batteries/http/http_client_connection.hpp file batteries/http/http_client_connection_decl.hpp file batteries/http/http_client_connection_impl.hpp file batteries/http/http_client_host_context.hpp file batteries/http/http_client_host_context_decl.hpp file batteries/http/http_client_host_context_impl.hpp file batteries/http/http_client_impl.hpp file batteries/http/http_data.hpp file batteries/http/http_header.hpp file batteries/http/http_message_base.hpp file batteries/http/http_request.hpp file batteries/http/http_response.hpp file batteries/http/http_server.hpp file batteries/http/http_server_impl.hpp file batteries/http/http_version.hpp dir batteries/metrics file batteries/metrics/metric_collectors.hpp file batteries/metrics/metric_collectors_impl.hpp file batteries/metrics/metric_csv_formatter.hpp file batteries/metrics/metric_csv_formatter_impl.hpp file batteries/metrics/metric_dumper.hpp file batteries/metrics/metric_dumper_impl.hpp file batteries/metrics/metric_formatter.hpp file batteries/metrics/metric_formatter_impl.hpp file batteries/metrics/metric_registry.hpp file batteries/metrics/metric_registry_impl.hpp dir batteries/pico_http file batteries/pico_http/parser.hpp file batteries/pico_http/parser_decl.hpp file batteries/pico_http/parser_impl.hpp dir batteries/protobuf file batteries/protobuf/stream_buffer_input_stream.hpp file batteries/protobuf/stream_buffer_output_stream.hpp dir batteries/seq file batteries/seq/boxed.hpp file batteries/seq/cache_next.hpp file batteries/seq/chain.hpp file batteries/seq/collect_vec.hpp file batteries/seq/consume.hpp file batteries/seq/count.hpp file batteries/seq/deref.hpp file batteries/seq/emplace_back.hpp file batteries/seq/empty.hpp file batteries/seq/filter.hpp file batteries/seq/filter_map.hpp file batteries/seq/first.hpp file batteries/seq/flatten.hpp file batteries/seq/for_each.hpp file batteries/seq/group_by.hpp file batteries/seq/lazy.hpp file batteries/seq/loop_control.hpp file batteries/seq/map.hpp file batteries/seq/merge_by.hpp file batteries/seq/natural_equals.hpp file batteries/seq/natural_order.hpp file batteries/seq/prepend.hpp file batteries/seq/print_out.hpp file batteries/seq/printable.hpp file batteries/seq/reduce.hpp file batteries/seq/requirements.hpp file batteries/seq/reverse.hpp file batteries/seq/seq_item.hpp file batteries/seq/skip_n.hpp file batteries/seq/status_ok.hpp file batteries/seq/sub_range_seq.hpp file batteries/seq/take_n.hpp file batteries/seq/take_while.hpp dir batteries/state_machine_model file batteries/state_machine_model/advanced_options.hpp file batteries/state_machine_model/entropy_source.hpp file batteries/state_machine_model/exhaustive_model_checker.hpp file batteries/state_machine_model/parallel_model_check_state.hpp file batteries/state_machine_model/state_machine_result.hpp file batteries/state_machine_model/state_machine_traits.hpp file batteries/state_machine_model/stochastic_model_checker.hpp file batteries/state_machine_model/verbose.hpp file batteries/bounds.hpp file batteries/buffer.hpp file batteries/case_of.hpp file batteries/checked_cast.hpp file batteries/config.hpp file batteries/constants.hpp file batteries/cpu_align.hpp file batteries/do_nothing.hpp file batteries/env.hpp file batteries/finally.hpp file batteries/hash.hpp file batteries/hint.hpp file batteries/int_types.hpp file batteries/interval.hpp file batteries/interval_traits.hpp file batteries/logging.hpp file batteries/math.hpp file batteries/nullable.hpp file batteries/optional.hpp file batteries/pointers.hpp file batteries/radix_queue.hpp file batteries/ref.hpp file batteries/require.hpp file batteries/segv.hpp file batteries/seq.hpp file batteries/shared_ptr.hpp file batteries/slice.hpp file batteries/small_fn.hpp file batteries/small_vec.hpp file batteries/state_machine_model.hpp file batteries/static_assert.hpp file batteries/static_dispatch.hpp file batteries/status.hpp file batteries/status_impl.hpp file batteries/stream_util.hpp file batteries/strict.hpp file batteries/strong_typedef.hpp file batteries/suppress.hpp file batteries/syscall_retry.hpp file batteries/token.hpp file batteries/tuples.hpp file batteries/type_erasure.hpp file batteries/type_traits.hpp file batteries/url_parse.hpp file batteries/utility.hpp file batteries/var_size_array.hpp file batteries.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/README_8md/","text":"README.md \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 # NOTICE The contents of this directory were copied and modified from the [ Pico HTTP Parser ]( https : //github.com/h2o/picohttpparser) project under the terms of the MIT License. The original copyright notice is preserved in the source files , and also quoted here : / * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. / 1 2 3 DO NOT remove this notice from the files in this directory! The Pico HTTP Parser and H2O projects are amazing and awesome; you should definitely support the authors and the project!!! Updated on 26 August 2022 at 17:30:03 UTC","title":"README.md"},{"location":"_autogen/Files/README_8md/#source-code","text":"1 2 3 4 5 # NOTICE The contents of this directory were copied and modified from the [ Pico HTTP Parser ]( https : //github.com/h2o/picohttpparser) project under the terms of the MIT License. The original copyright notice is preserved in the source files , and also quoted here : / * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. / 1 2 3 DO NOT remove this notice from the files in this directory! The Pico HTTP Parser and H2O projects are amazing and awesome; you should definitely support the authors and the project!!! Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/advanced__options_8hpp/","text":"batteries/state_machine_model/advanced_options.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::StateMachineModelCheckAdvancedOptions Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP #define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/optional.hpp> namespace batt { struct StateMachineModelCheckAdvancedOptions { using Self = StateMachineModelCheckAdvancedOptions ; bool pin_shard_to_cpu ; usize max_loop_iterations_between_flush ; usize max_loop_iterations_between_update ; i64 min_running_time_ms ; Optional < usize > starting_seed ; static Self with_default_values () { return Self { . pin_shard_to_cpu = true , . max_loop_iterations_between_flush = 16 , . max_loop_iterations_between_update = 4096 , . min_running_time_ms = 1000 , . starting_seed = None , }; } }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/advanced_options.hpp"},{"location":"_autogen/Files/advanced__options_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/advanced__options_8hpp/#classes","text":"Name struct batt::StateMachineModelCheckAdvancedOptions","title":"Classes"},{"location":"_autogen/Files/advanced__options_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP","title":"Defines"},{"location":"_autogen/Files/advanced__options_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/advanced__options_8hpp/#batteries_state_machine_model_advanced_options_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP"},{"location":"_autogen/Files/advanced__options_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP #define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/optional.hpp> namespace batt { struct StateMachineModelCheckAdvancedOptions { using Self = StateMachineModelCheckAdvancedOptions ; bool pin_shard_to_cpu ; usize max_loop_iterations_between_flush ; usize max_loop_iterations_between_update ; i64 min_running_time_ms ; Optional < usize > starting_seed ; static Self with_default_values () { return Self { . pin_shard_to_cpu = true , . max_loop_iterations_between_flush = 16 , . max_loop_iterations_between_update = 4096 , . min_running_time_ms = 1000 , . starting_seed = None , }; } }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/assert_8hpp/","text":"batteries/assert.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATT_FAIL_CHECK_OUT BATT_FAIL_CHECK_MESSAGE (left_str, left_val, op_str, right_str, right_val, file, line, fn_name) BATT_NORETURN BATT_UNREACHABLE () BATT_CHECK_RELATION (left, op, right) BATT_CHECK_IMPLIES (p, q) BATT_CHECK (x) This is only a test... BATT_CHECK_EQ (x, y) BATT_CHECK_NE (x, y) BATT_CHECK_GE (x, y) BATT_CHECK_GT (x, y) BATT_CHECK_LE (x, y) BATT_CHECK_LT (x, y) BATT_CHECK_FAIL () BATT_CHECK_IN_RANGE (low, x, high) BATT_ASSERT_DISABLED (ignored_inputs) BATT_ASSERT (x) BATT_ASSERT_EQ (x, y) BATT_ASSERT_NE (x, y) BATT_ASSERT_GE (x, y) BATT_ASSERT_GT (x, y) BATT_ASSERT_LE (x, y) BATT_ASSERT_LT (x, y) BATT_ASSERT_IMPLIES (p, q) BATT_ASSERT_IN_RANGE (low, x, high) BATT_ASSERT_NOT_NULLPTR (x) BATT_CHECK_NOT_NULLPTR (x) BATT_PANIC () BATT_INSPECT (expr) BATT_UNTESTED_LINE () BATT_UNTESTED_COND (x) Macro Documentation \ud83d\udd17 BATT_FAIL_CHECK_OUT \ud83d\udd17 1 #define BATT_FAIL_CHECK_OUT() BATT_FAIL_CHECK_MESSAGE \ud83d\udd17 1 #define BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name) BATT_NORETURN \ud83d\udd17 1 #define BATT_NORETURN() BATT_UNREACHABLE \ud83d\udd17 1 #define BATT_UNREACHABLE() BATT_CHECK_RELATION \ud83d\udd17 1 #define BATT_CHECK_RELATION(left, op, right) BATT_CHECK_IMPLIES \ud83d\udd17 1 #define BATT_CHECK_IMPLIES(p, q) BATT_CHECK \ud83d\udd17 1 #define BATT_CHECK(x) This is only a test... Parameters : x The expression to test. BATT_CHECK_EQ \ud83d\udd17 1 #define BATT_CHECK_EQ(x, y) BATT_CHECK_NE \ud83d\udd17 1 #define BATT_CHECK_NE(x, y) BATT_CHECK_GE \ud83d\udd17 1 #define BATT_CHECK_GE(x, y) BATT_CHECK_GT \ud83d\udd17 1 #define BATT_CHECK_GT(x, y) BATT_CHECK_LE \ud83d\udd17 1 #define BATT_CHECK_LE(x, y) BATT_CHECK_LT \ud83d\udd17 1 #define BATT_CHECK_LT(x, y) BATT_CHECK_FAIL \ud83d\udd17 1 #define BATT_CHECK_FAIL() BATT_CHECK_IN_RANGE \ud83d\udd17 1 #define BATT_CHECK_IN_RANGE(low, x, high) BATT_ASSERT_DISABLED \ud83d\udd17 1 #define BATT_ASSERT_DISABLED(ignored_inputs) BATT_ASSERT \ud83d\udd17 1 #define BATT_ASSERT(x) BATT_ASSERT_EQ \ud83d\udd17 1 #define BATT_ASSERT_EQ(x, y) BATT_ASSERT_NE \ud83d\udd17 1 #define BATT_ASSERT_NE(x, y) BATT_ASSERT_GE \ud83d\udd17 1 #define BATT_ASSERT_GE(x, y) BATT_ASSERT_GT \ud83d\udd17 1 #define BATT_ASSERT_GT(x, y) BATT_ASSERT_LE \ud83d\udd17 1 #define BATT_ASSERT_LE(x, y) BATT_ASSERT_LT \ud83d\udd17 1 #define BATT_ASSERT_LT(x, y) BATT_ASSERT_IMPLIES \ud83d\udd17 1 #define BATT_ASSERT_IMPLIES(p, q) BATT_ASSERT_IN_RANGE \ud83d\udd17 1 #define BATT_ASSERT_IN_RANGE(low, x, high) BATT_ASSERT_NOT_NULLPTR \ud83d\udd17 1 #define BATT_ASSERT_NOT_NULLPTR(x) BATT_CHECK_NOT_NULLPTR \ud83d\udd17 1 #define BATT_CHECK_NOT_NULLPTR(x) BATT_PANIC \ud83d\udd17 1 #define BATT_PANIC() BATT_INSPECT \ud83d\udd17 1 #define BATT_INSPECT(expr) BATT_UNTESTED_LINE \ud83d\udd17 1 #define BATT_UNTESTED_LINE() BATT_UNTESTED_COND \ud83d\udd17 1 #define BATT_UNTESTED_COND(x) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifdef BOOST_STACKTRACE_USE_NOOP #undef BOOST_STACKTRACE_USE_NOOP #endif // BOOST_STACKTRACE_USE_NOOP #include <batteries/config.hpp> // #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/stacktrace.hpp> #include <iomanip> #include <iostream> #include <mutex> #include <sstream> #ifdef BATT_FAIL_CHECK_OUT #error This macro is deprecated; use BATT_GLOG_AVAILABLE #endif #ifdef BATT_GLOG_AVAILABLE #include <glog/logging.h> #define BATT_FAIL_CHECK_OUT LOG(ERROR) #else #define BATT_FAIL_CHECK_OUT std::cerr #endif namespace batt { template < typename T , typename = std :: enable_if_t < IsPrintable < T > {} >> decltype ( auto ) make_printable ( T && obj ) { return BATT_FORWARD ( obj ); } template < typename T , typename = std :: enable_if_t <! IsPrintable < T > {} > , typename = void > std :: string make_printable ( T && obj ) { std :: ostringstream oss ; oss << \"(\" << name_of < T > () << \") \" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ); for ( const u8 * bytes = ( const u8 * ) & obj ; bytes != ( const u8 * )(( & obj ) + 1 ); ++ bytes ) { oss << ( int ) * bytes ; } return oss . str (); } // ============================================================================= // ASSERT and CHECK macros with ostream-style message appending, stack trace on // failure, branch prediction hinting, and human-friendly messages. // // BATT_ASSERT* statements are only enabled when NDEBUG is not defined. // BATT_CHECK* statements are always enabled. // #define BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name) \\ BATT_FAIL_CHECK_OUT << \"FATAL: \" << file << \":\" << line << \": Assertion failed: \" << left_str << \" \" \\ << op_str << \" \" << right_str << \"\\n (in `\" << fn_name << \"`)\\n\\n\" \\ << \" \" << left_str << \" == \" << ::batt::make_printable(left_val) << ::std::endl \\ << ::std::endl \\ << \" \" << right_str << \" == \" << ::batt::make_printable(right_val) << ::std::endl \\ << ::std::endl //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #if defined(__GNUC__) #define BATT_NORETURN __attribute__((noreturn)) #define BATT_UNREACHABLE __builtin_unreachable #elif defined(__clang__) #define BATT_NORETURN _Noreturn #define BATT_UNREACHABLE __builtin_unreachable #else #define BATT_NORETURN #define BATT_UNREACHABLE() (void) #endif //+++++++++++-+-+--+----- --- -- - - - - BATT_NORETURN inline void fail_check_exit () { BATT_FAIL_CHECK_OUT << std :: endl << std :: endl ; std :: abort (); BATT_UNREACHABLE (); } template < typename ... Ts > inline bool ignore ( Ts && ...) { return false ; } inline bool lock_fail_check_mutex () { static std :: aligned_storage_t < sizeof ( std :: mutex ), alignof ( std :: mutex ) > storage_ ; static std :: mutex * m = new ( & storage_ ) std :: mutex {}; m -> lock (); return true ; } #define BATT_CHECK_RELATION(left, op, right) \\ for (; !BATT_HINT_TRUE((left)op(right)) && BATT_HINT_TRUE(::batt::lock_fail_check_mutex()); \\ ::batt::fail_check_exit()) \\ BATT_FAIL_CHECK_MESSAGE(#left, (left), #op, #right, (right), __FILE__, __LINE__, __PRETTY_FUNCTION__) #define BATT_CHECK_IMPLIES(p, q) \\ for (; !BATT_HINT_TRUE(!(p) || (q)) && BATT_HINT_TRUE(::batt::lock_fail_check_mutex()); \\ ::batt::fail_check_exit()) \\ BATT_FAIL_CHECK_MESSAGE(#p, (p), \"implies\", #q, (q), __FILE__, __LINE__, __PRETTY_FUNCTION__) #define BATT_CHECK(x) BATT_CHECK_RELATION(bool{x}, ==, true) #define BATT_CHECK_EQ(x, y) BATT_CHECK_RELATION(x, ==, y) #define BATT_CHECK_NE(x, y) BATT_CHECK_RELATION(x, !=, y) #define BATT_CHECK_GE(x, y) BATT_CHECK_RELATION(x, >=, y) #define BATT_CHECK_GT(x, y) BATT_CHECK_RELATION(x, >, y) #define BATT_CHECK_LE(x, y) BATT_CHECK_RELATION(x, <=, y) #define BATT_CHECK_LT(x, y) BATT_CHECK_RELATION(x, <, y) #define BATT_CHECK_FAIL() BATT_CHECK(false) #define BATT_CHECK_IN_RANGE(low, x, high) \\ [&](auto&& Actual_Value) { \\ BATT_CHECK_LE(low, Actual_Value) \\ << \"Expression \" << #x << \" == \" << Actual_Value << \" is out-of-range\"; \\ BATT_CHECK_LT(Actual_Value, high) \\ << \"Expression \" << #x << \" == \" << Actual_Value << \" is out-of-range\"; \\ }(x) #define BATT_ASSERT_DISABLED(ignored_inputs) \\ if (false && ignored_inputs) \\ BATT_FAIL_CHECK_OUT << \"\" #ifndef NDEBUG //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_ASSERT(x) BATT_CHECK(x) #define BATT_ASSERT_EQ(x, y) BATT_CHECK_EQ(x, y) #define BATT_ASSERT_NE(x, y) BATT_CHECK_NE(x, y) #define BATT_ASSERT_GE(x, y) BATT_CHECK_GE(x, y) #define BATT_ASSERT_GT(x, y) BATT_CHECK_GT(x, y) #define BATT_ASSERT_LE(x, y) BATT_CHECK_LE(x, y) #define BATT_ASSERT_LT(x, y) BATT_CHECK_LT(x, y) #define BATT_ASSERT_IMPLIES(p, q) BATT_CHECK_IMPLIES(p, q) #define BATT_ASSERT_IN_RANGE(low, x, high) BATT_CHECK_IN_RANGE(low, x, high) #else // NDEBUG ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_ASSERT(x) BATT_ASSERT_DISABLED(::batt::ignore((x))) #define BATT_ASSERT_EQ(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) == (y))) #define BATT_ASSERT_NE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) != (y))) #define BATT_ASSERT_GE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) >= (y))) #define BATT_ASSERT_GT(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) > (y))) #define BATT_ASSERT_LE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) <= (y))) #define BATT_ASSERT_LT(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) < (y))) #define BATT_ASSERT_IMPLIES(p, q) BATT_ASSERT_DISABLED(::batt::ignore((p), (q), !(p), bool(q))) #define BATT_ASSERT_IN_RANGE(low, x, high) \\ BATT_ASSERT_DISABLED(::batt::ignore((low), (x), (high), (low) <= (x), (x) < (high))) #endif // NDEBUG ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_ASSERT_NOT_NULLPTR(x) BATT_ASSERT(x != nullptr) #define BATT_CHECK_NOT_NULLPTR(x) BATT_CHECK(x != nullptr) #define BATT_PANIC() \\ for (bool one_time = true; one_time; one_time = false, ::batt::fail_check_exit(), BATT_UNREACHABLE()) \\ BATT_FAIL_CHECK_OUT << \"*** PANIC *** At:\" << __FILE__ << \":\" << __LINE__ << \":\" << std::endl //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BATT_INSPECT(expr) : expand to debug-friendly stream insertion expression. // TODO [tastolfi 2021-10-20] Update docs for assert.hpp to include BATT_INSPECT // #define BATT_INSPECT(expr) \" \" << #expr << \" == \" << (expr) #define BATT_UNTESTED_LINE() BATT_PANIC() << \"Add test point!\" #define BATT_UNTESTED_COND(x) BATT_CHECK(!(x)) << \"Add test point!\" } // namespace batt #include <batteries/segv.hpp> Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/assert.hpp"},{"location":"_autogen/Files/assert_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/assert_8hpp/#defines","text":"Name BATT_FAIL_CHECK_OUT BATT_FAIL_CHECK_MESSAGE (left_str, left_val, op_str, right_str, right_val, file, line, fn_name) BATT_NORETURN BATT_UNREACHABLE () BATT_CHECK_RELATION (left, op, right) BATT_CHECK_IMPLIES (p, q) BATT_CHECK (x) This is only a test... BATT_CHECK_EQ (x, y) BATT_CHECK_NE (x, y) BATT_CHECK_GE (x, y) BATT_CHECK_GT (x, y) BATT_CHECK_LE (x, y) BATT_CHECK_LT (x, y) BATT_CHECK_FAIL () BATT_CHECK_IN_RANGE (low, x, high) BATT_ASSERT_DISABLED (ignored_inputs) BATT_ASSERT (x) BATT_ASSERT_EQ (x, y) BATT_ASSERT_NE (x, y) BATT_ASSERT_GE (x, y) BATT_ASSERT_GT (x, y) BATT_ASSERT_LE (x, y) BATT_ASSERT_LT (x, y) BATT_ASSERT_IMPLIES (p, q) BATT_ASSERT_IN_RANGE (low, x, high) BATT_ASSERT_NOT_NULLPTR (x) BATT_CHECK_NOT_NULLPTR (x) BATT_PANIC () BATT_INSPECT (expr) BATT_UNTESTED_LINE () BATT_UNTESTED_COND (x)","title":"Defines"},{"location":"_autogen/Files/assert_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/assert_8hpp/#batt_fail_check_out","text":"1 #define BATT_FAIL_CHECK_OUT()","title":"BATT_FAIL_CHECK_OUT"},{"location":"_autogen/Files/assert_8hpp/#batt_fail_check_message","text":"1 #define BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name)","title":"BATT_FAIL_CHECK_MESSAGE"},{"location":"_autogen/Files/assert_8hpp/#batt_noreturn","text":"1 #define BATT_NORETURN()","title":"BATT_NORETURN"},{"location":"_autogen/Files/assert_8hpp/#batt_unreachable","text":"1 #define BATT_UNREACHABLE()","title":"BATT_UNREACHABLE"},{"location":"_autogen/Files/assert_8hpp/#batt_check_relation","text":"1 #define BATT_CHECK_RELATION(left, op, right)","title":"BATT_CHECK_RELATION"},{"location":"_autogen/Files/assert_8hpp/#batt_check_implies","text":"1 #define BATT_CHECK_IMPLIES(p, q)","title":"BATT_CHECK_IMPLIES"},{"location":"_autogen/Files/assert_8hpp/#batt_check","text":"1 #define BATT_CHECK(x) This is only a test... Parameters : x The expression to test.","title":"BATT_CHECK"},{"location":"_autogen/Files/assert_8hpp/#batt_check_eq","text":"1 #define BATT_CHECK_EQ(x, y)","title":"BATT_CHECK_EQ"},{"location":"_autogen/Files/assert_8hpp/#batt_check_ne","text":"1 #define BATT_CHECK_NE(x, y)","title":"BATT_CHECK_NE"},{"location":"_autogen/Files/assert_8hpp/#batt_check_ge","text":"1 #define BATT_CHECK_GE(x, y)","title":"BATT_CHECK_GE"},{"location":"_autogen/Files/assert_8hpp/#batt_check_gt","text":"1 #define BATT_CHECK_GT(x, y)","title":"BATT_CHECK_GT"},{"location":"_autogen/Files/assert_8hpp/#batt_check_le","text":"1 #define BATT_CHECK_LE(x, y)","title":"BATT_CHECK_LE"},{"location":"_autogen/Files/assert_8hpp/#batt_check_lt","text":"1 #define BATT_CHECK_LT(x, y)","title":"BATT_CHECK_LT"},{"location":"_autogen/Files/assert_8hpp/#batt_check_fail","text":"1 #define BATT_CHECK_FAIL()","title":"BATT_CHECK_FAIL"},{"location":"_autogen/Files/assert_8hpp/#batt_check_in_range","text":"1 #define BATT_CHECK_IN_RANGE(low, x, high)","title":"BATT_CHECK_IN_RANGE"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_disabled","text":"1 #define BATT_ASSERT_DISABLED(ignored_inputs)","title":"BATT_ASSERT_DISABLED"},{"location":"_autogen/Files/assert_8hpp/#batt_assert","text":"1 #define BATT_ASSERT(x)","title":"BATT_ASSERT"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_eq","text":"1 #define BATT_ASSERT_EQ(x, y)","title":"BATT_ASSERT_EQ"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_ne","text":"1 #define BATT_ASSERT_NE(x, y)","title":"BATT_ASSERT_NE"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_ge","text":"1 #define BATT_ASSERT_GE(x, y)","title":"BATT_ASSERT_GE"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_gt","text":"1 #define BATT_ASSERT_GT(x, y)","title":"BATT_ASSERT_GT"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_le","text":"1 #define BATT_ASSERT_LE(x, y)","title":"BATT_ASSERT_LE"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_lt","text":"1 #define BATT_ASSERT_LT(x, y)","title":"BATT_ASSERT_LT"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_implies","text":"1 #define BATT_ASSERT_IMPLIES(p, q)","title":"BATT_ASSERT_IMPLIES"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_in_range","text":"1 #define BATT_ASSERT_IN_RANGE(low, x, high)","title":"BATT_ASSERT_IN_RANGE"},{"location":"_autogen/Files/assert_8hpp/#batt_assert_not_nullptr","text":"1 #define BATT_ASSERT_NOT_NULLPTR(x)","title":"BATT_ASSERT_NOT_NULLPTR"},{"location":"_autogen/Files/assert_8hpp/#batt_check_not_nullptr","text":"1 #define BATT_CHECK_NOT_NULLPTR(x)","title":"BATT_CHECK_NOT_NULLPTR"},{"location":"_autogen/Files/assert_8hpp/#batt_panic","text":"1 #define BATT_PANIC()","title":"BATT_PANIC"},{"location":"_autogen/Files/assert_8hpp/#batt_inspect","text":"1 #define BATT_INSPECT(expr)","title":"BATT_INSPECT"},{"location":"_autogen/Files/assert_8hpp/#batt_untested_line","text":"1 #define BATT_UNTESTED_LINE()","title":"BATT_UNTESTED_LINE"},{"location":"_autogen/Files/assert_8hpp/#batt_untested_cond","text":"1 #define BATT_UNTESTED_COND(x)","title":"BATT_UNTESTED_COND"},{"location":"_autogen/Files/assert_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifdef BOOST_STACKTRACE_USE_NOOP #undef BOOST_STACKTRACE_USE_NOOP #endif // BOOST_STACKTRACE_USE_NOOP #include <batteries/config.hpp> // #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/stacktrace.hpp> #include <iomanip> #include <iostream> #include <mutex> #include <sstream> #ifdef BATT_FAIL_CHECK_OUT #error This macro is deprecated; use BATT_GLOG_AVAILABLE #endif #ifdef BATT_GLOG_AVAILABLE #include <glog/logging.h> #define BATT_FAIL_CHECK_OUT LOG(ERROR) #else #define BATT_FAIL_CHECK_OUT std::cerr #endif namespace batt { template < typename T , typename = std :: enable_if_t < IsPrintable < T > {} >> decltype ( auto ) make_printable ( T && obj ) { return BATT_FORWARD ( obj ); } template < typename T , typename = std :: enable_if_t <! IsPrintable < T > {} > , typename = void > std :: string make_printable ( T && obj ) { std :: ostringstream oss ; oss << \"(\" << name_of < T > () << \") \" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ); for ( const u8 * bytes = ( const u8 * ) & obj ; bytes != ( const u8 * )(( & obj ) + 1 ); ++ bytes ) { oss << ( int ) * bytes ; } return oss . str (); } // ============================================================================= // ASSERT and CHECK macros with ostream-style message appending, stack trace on // failure, branch prediction hinting, and human-friendly messages. // // BATT_ASSERT* statements are only enabled when NDEBUG is not defined. // BATT_CHECK* statements are always enabled. // #define BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name) \\ BATT_FAIL_CHECK_OUT << \"FATAL: \" << file << \":\" << line << \": Assertion failed: \" << left_str << \" \" \\ << op_str << \" \" << right_str << \"\\n (in `\" << fn_name << \"`)\\n\\n\" \\ << \" \" << left_str << \" == \" << ::batt::make_printable(left_val) << ::std::endl \\ << ::std::endl \\ << \" \" << right_str << \" == \" << ::batt::make_printable(right_val) << ::std::endl \\ << ::std::endl //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #if defined(__GNUC__) #define BATT_NORETURN __attribute__((noreturn)) #define BATT_UNREACHABLE __builtin_unreachable #elif defined(__clang__) #define BATT_NORETURN _Noreturn #define BATT_UNREACHABLE __builtin_unreachable #else #define BATT_NORETURN #define BATT_UNREACHABLE() (void) #endif //+++++++++++-+-+--+----- --- -- - - - - BATT_NORETURN inline void fail_check_exit () { BATT_FAIL_CHECK_OUT << std :: endl << std :: endl ; std :: abort (); BATT_UNREACHABLE (); } template < typename ... Ts > inline bool ignore ( Ts && ...) { return false ; } inline bool lock_fail_check_mutex () { static std :: aligned_storage_t < sizeof ( std :: mutex ), alignof ( std :: mutex ) > storage_ ; static std :: mutex * m = new ( & storage_ ) std :: mutex {}; m -> lock (); return true ; } #define BATT_CHECK_RELATION(left, op, right) \\ for (; !BATT_HINT_TRUE((left)op(right)) && BATT_HINT_TRUE(::batt::lock_fail_check_mutex()); \\ ::batt::fail_check_exit()) \\ BATT_FAIL_CHECK_MESSAGE(#left, (left), #op, #right, (right), __FILE__, __LINE__, __PRETTY_FUNCTION__) #define BATT_CHECK_IMPLIES(p, q) \\ for (; !BATT_HINT_TRUE(!(p) || (q)) && BATT_HINT_TRUE(::batt::lock_fail_check_mutex()); \\ ::batt::fail_check_exit()) \\ BATT_FAIL_CHECK_MESSAGE(#p, (p), \"implies\", #q, (q), __FILE__, __LINE__, __PRETTY_FUNCTION__) #define BATT_CHECK(x) BATT_CHECK_RELATION(bool{x}, ==, true) #define BATT_CHECK_EQ(x, y) BATT_CHECK_RELATION(x, ==, y) #define BATT_CHECK_NE(x, y) BATT_CHECK_RELATION(x, !=, y) #define BATT_CHECK_GE(x, y) BATT_CHECK_RELATION(x, >=, y) #define BATT_CHECK_GT(x, y) BATT_CHECK_RELATION(x, >, y) #define BATT_CHECK_LE(x, y) BATT_CHECK_RELATION(x, <=, y) #define BATT_CHECK_LT(x, y) BATT_CHECK_RELATION(x, <, y) #define BATT_CHECK_FAIL() BATT_CHECK(false) #define BATT_CHECK_IN_RANGE(low, x, high) \\ [&](auto&& Actual_Value) { \\ BATT_CHECK_LE(low, Actual_Value) \\ << \"Expression \" << #x << \" == \" << Actual_Value << \" is out-of-range\"; \\ BATT_CHECK_LT(Actual_Value, high) \\ << \"Expression \" << #x << \" == \" << Actual_Value << \" is out-of-range\"; \\ }(x) #define BATT_ASSERT_DISABLED(ignored_inputs) \\ if (false && ignored_inputs) \\ BATT_FAIL_CHECK_OUT << \"\" #ifndef NDEBUG //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_ASSERT(x) BATT_CHECK(x) #define BATT_ASSERT_EQ(x, y) BATT_CHECK_EQ(x, y) #define BATT_ASSERT_NE(x, y) BATT_CHECK_NE(x, y) #define BATT_ASSERT_GE(x, y) BATT_CHECK_GE(x, y) #define BATT_ASSERT_GT(x, y) BATT_CHECK_GT(x, y) #define BATT_ASSERT_LE(x, y) BATT_CHECK_LE(x, y) #define BATT_ASSERT_LT(x, y) BATT_CHECK_LT(x, y) #define BATT_ASSERT_IMPLIES(p, q) BATT_CHECK_IMPLIES(p, q) #define BATT_ASSERT_IN_RANGE(low, x, high) BATT_CHECK_IN_RANGE(low, x, high) #else // NDEBUG ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_ASSERT(x) BATT_ASSERT_DISABLED(::batt::ignore((x))) #define BATT_ASSERT_EQ(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) == (y))) #define BATT_ASSERT_NE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) != (y))) #define BATT_ASSERT_GE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) >= (y))) #define BATT_ASSERT_GT(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) > (y))) #define BATT_ASSERT_LE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) <= (y))) #define BATT_ASSERT_LT(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) < (y))) #define BATT_ASSERT_IMPLIES(p, q) BATT_ASSERT_DISABLED(::batt::ignore((p), (q), !(p), bool(q))) #define BATT_ASSERT_IN_RANGE(low, x, high) \\ BATT_ASSERT_DISABLED(::batt::ignore((low), (x), (high), (low) <= (x), (x) < (high))) #endif // NDEBUG ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_ASSERT_NOT_NULLPTR(x) BATT_ASSERT(x != nullptr) #define BATT_CHECK_NOT_NULLPTR(x) BATT_CHECK(x != nullptr) #define BATT_PANIC() \\ for (bool one_time = true; one_time; one_time = false, ::batt::fail_check_exit(), BATT_UNREACHABLE()) \\ BATT_FAIL_CHECK_OUT << \"*** PANIC *** At:\" << __FILE__ << \":\" << __LINE__ << \":\" << std::endl //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BATT_INSPECT(expr) : expand to debug-friendly stream insertion expression. // TODO [tastolfi 2021-10-20] Update docs for assert.hpp to include BATT_INSPECT // #define BATT_INSPECT(expr) \" \" << #expr << \" == \" << (expr) #define BATT_UNTESTED_LINE() BATT_PANIC() << \"Add test point!\" #define BATT_UNTESTED_COND(x) BATT_CHECK(!(x)) << \"Add test point!\" } // namespace batt #include <batteries/segv.hpp> Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/backoff_8hpp/","text":"batteries/async/backoff.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::RetryState struct batt::ExponentialBackoff struct batt::TaskSleepImpl Defines \ud83d\udd17 Name BATTERIES_ASYNC_BACKOFF_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_BACKOFF_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_BACKOFF_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_BACKOFF_HPP #define BATTERIES_ASYNC_BACKOFF_HPP #include <batteries/config.hpp> #include <batteries/async/task_decl.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/suppress.hpp> BATT_SUPPRESS_IF_GCC ( \"-Wswitch-enum\" ) #include <boost/date_time/posix_time/posix_time.hpp> BATT_UNSUPPRESS_IF_GCC () #include <type_traits> namespace batt { struct TaskSleepImpl ; // Try an action until it succeeds, according to the specified RetryPolicy, which controls the maximum number // of retries and the delay (if any) between retries. // // A RetryPolicy type must be passable via ADL to some overload of the free function `update_retry_state`, // which takes a (mutable) reference to an instance of `RetryState` and the policy object as its two // arguments. // // `action_fn` should return `batt::Status` or some type that is convertible to `batt::Status` via // `batt::to_status`. For example, batt::StatusOr<T>, batt::Status, and boost::system::error_code are all // allowable return types. // template < typename RetryPolicy , typename ActionFn , typename Result = std :: invoke_result_t < ActionFn > , typename SleepImpl = TaskSleepImpl > Result with_retry_policy ( RetryPolicy && policy , std :: string_view action_name , ActionFn && action_fn , SleepImpl && sleep_impl = {}); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // State variables passed into `update_retry_state` along with a RetryPolicy object in order to update the // backoff delay. // struct RetryState { bool should_retry = false ; u64 n_attempts = 0 ; u64 prev_delay_usec = 0 ; u64 next_delay_usec = 0 ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A retry policy that implements simple exponential backoff and retry with no jitter. // struct ExponentialBackoff { // 0 means no maximum. // u64 max_attempts ; // How long to wait after the first failed attempt. // u64 initial_delay_usec ; // How much to increase after each failed attempt: // next_delay = prev_delay * backoff_factor / backoff_divisor. // u64 backoff_factor ; u64 backoff_divisor ; // The maximum delay. // u64 max_delay_usec ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - static ExponentialBackoff with_default_params () { ExponentialBackoff p ; p . max_attempts = 40 ; p . initial_delay_usec = 10 ; p . backoff_factor = 2 ; p . backoff_divisor = 1 ; p . max_delay_usec = 250 * 1000 ; // 250ms return p ; } }; // Increase the delay interval by the constant factor specified in `policy`; `RetryState::should_retry` will // be true until `RetryState::n_attempts` exceeds `ExponentialBackoff::max_attempts`. // inline void update_retry_state ( RetryState & state , const ExponentialBackoff & policy ) { if ( state . n_attempts >= policy . max_attempts ) { state . should_retry = false ; return ; } state . should_retry = true ; state . n_attempts += 1 ; state . prev_delay_usec = state . next_delay_usec ; if ( state . n_attempts == 1 ) { state . next_delay_usec = policy . initial_delay_usec ; } else { state . next_delay_usec = std :: min ( policy . max_delay_usec , state . prev_delay_usec * policy . backoff_factor / policy . backoff_divisor ); } } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // The default sleep implementation for `with_retry_policy`. // struct TaskSleepImpl { template < typename DurationT > void operator ()( DurationT && duration ) const { Task :: sleep ( BATT_FORWARD ( duration )); } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename RetryPolicy , typename ActionFn , typename Result , typename SleepImpl > inline Result with_retry_policy ( RetryPolicy && policy , std :: string_view action_name , ActionFn && action_fn , SleepImpl && sleep_impl ) { RetryState state ; for (;;) { Result result = action_fn (); if ( ! is_ok_status ( result )) { auto status = to_status ( result ); if ( status_is_retryable ( status )) { update_retry_state ( state , policy ); if ( state . should_retry ) { BATT_VLOG ( 1 ) << \"operation '\" << action_name << \"' failed with status=\" << status << \"; retrying after \" << state . next_delay_usec << \"us (\" << state . n_attempts << \" of \" << policy . max_attempts << \")\" ; sleep_impl ( boost :: posix_time :: microseconds ( state . next_delay_usec )); continue ; } // else - } // fall through } // to return return result ; } } } // namespace batt #endif // BATTERIES_ASYNC_BACKOFF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/backoff.hpp"},{"location":"_autogen/Files/backoff_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/backoff_8hpp/#classes","text":"Name struct batt::RetryState struct batt::ExponentialBackoff struct batt::TaskSleepImpl","title":"Classes"},{"location":"_autogen/Files/backoff_8hpp/#defines","text":"Name BATTERIES_ASYNC_BACKOFF_HPP","title":"Defines"},{"location":"_autogen/Files/backoff_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/backoff_8hpp/#batteries_async_backoff_hpp","text":"1 #define BATTERIES_ASYNC_BACKOFF_HPP()","title":"BATTERIES_ASYNC_BACKOFF_HPP"},{"location":"_autogen/Files/backoff_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_BACKOFF_HPP #define BATTERIES_ASYNC_BACKOFF_HPP #include <batteries/config.hpp> #include <batteries/async/task_decl.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/suppress.hpp> BATT_SUPPRESS_IF_GCC ( \"-Wswitch-enum\" ) #include <boost/date_time/posix_time/posix_time.hpp> BATT_UNSUPPRESS_IF_GCC () #include <type_traits> namespace batt { struct TaskSleepImpl ; // Try an action until it succeeds, according to the specified RetryPolicy, which controls the maximum number // of retries and the delay (if any) between retries. // // A RetryPolicy type must be passable via ADL to some overload of the free function `update_retry_state`, // which takes a (mutable) reference to an instance of `RetryState` and the policy object as its two // arguments. // // `action_fn` should return `batt::Status` or some type that is convertible to `batt::Status` via // `batt::to_status`. For example, batt::StatusOr<T>, batt::Status, and boost::system::error_code are all // allowable return types. // template < typename RetryPolicy , typename ActionFn , typename Result = std :: invoke_result_t < ActionFn > , typename SleepImpl = TaskSleepImpl > Result with_retry_policy ( RetryPolicy && policy , std :: string_view action_name , ActionFn && action_fn , SleepImpl && sleep_impl = {}); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // State variables passed into `update_retry_state` along with a RetryPolicy object in order to update the // backoff delay. // struct RetryState { bool should_retry = false ; u64 n_attempts = 0 ; u64 prev_delay_usec = 0 ; u64 next_delay_usec = 0 ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A retry policy that implements simple exponential backoff and retry with no jitter. // struct ExponentialBackoff { // 0 means no maximum. // u64 max_attempts ; // How long to wait after the first failed attempt. // u64 initial_delay_usec ; // How much to increase after each failed attempt: // next_delay = prev_delay * backoff_factor / backoff_divisor. // u64 backoff_factor ; u64 backoff_divisor ; // The maximum delay. // u64 max_delay_usec ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - static ExponentialBackoff with_default_params () { ExponentialBackoff p ; p . max_attempts = 40 ; p . initial_delay_usec = 10 ; p . backoff_factor = 2 ; p . backoff_divisor = 1 ; p . max_delay_usec = 250 * 1000 ; // 250ms return p ; } }; // Increase the delay interval by the constant factor specified in `policy`; `RetryState::should_retry` will // be true until `RetryState::n_attempts` exceeds `ExponentialBackoff::max_attempts`. // inline void update_retry_state ( RetryState & state , const ExponentialBackoff & policy ) { if ( state . n_attempts >= policy . max_attempts ) { state . should_retry = false ; return ; } state . should_retry = true ; state . n_attempts += 1 ; state . prev_delay_usec = state . next_delay_usec ; if ( state . n_attempts == 1 ) { state . next_delay_usec = policy . initial_delay_usec ; } else { state . next_delay_usec = std :: min ( policy . max_delay_usec , state . prev_delay_usec * policy . backoff_factor / policy . backoff_divisor ); } } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // The default sleep implementation for `with_retry_policy`. // struct TaskSleepImpl { template < typename DurationT > void operator ()( DurationT && duration ) const { Task :: sleep ( BATT_FORWARD ( duration )); } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename RetryPolicy , typename ActionFn , typename Result , typename SleepImpl > inline Result with_retry_policy ( RetryPolicy && policy , std :: string_view action_name , ActionFn && action_fn , SleepImpl && sleep_impl ) { RetryState state ; for (;;) { Result result = action_fn (); if ( ! is_ok_status ( result )) { auto status = to_status ( result ); if ( status_is_retryable ( status )) { update_retry_state ( state , policy ); if ( state . should_retry ) { BATT_VLOG ( 1 ) << \"operation '\" << action_name << \"' failed with status=\" << status << \"; retrying after \" << state . next_delay_usec << \"us (\" << state . n_attempts << \" of \" << policy . max_attempts << \")\" ; sleep_impl ( boost :: posix_time :: microseconds ( state . next_delay_usec )); continue ; } // else - } // fall through } // to return return result ; } } } // namespace batt #endif // BATTERIES_ASYNC_BACKOFF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/batteries_8hpp/","text":"batteries.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Convenience header to include all of the Batteries library. // #pragma once #include <batteries/config.hpp> #include \"batteries/assert.hpp\" #include \"batteries/case_of.hpp\" #include \"batteries/checked_cast.hpp\" #include \"batteries/cpu_align.hpp\" #include \"batteries/finally.hpp\" #include \"batteries/hint.hpp\" #include \"batteries/int_types.hpp\" #include \"batteries/nullable.hpp\" #include \"batteries/radix_queue.hpp\" #include \"batteries/segv.hpp\" #include \"batteries/small_fn.hpp\" #include \"batteries/state_machine_model.hpp\" #include \"batteries/static_assert.hpp\" #include \"batteries/static_dispatch.hpp\" #include \"batteries/stream_util.hpp\" #include \"batteries/strict.hpp\" #include \"batteries/strong_typedef.hpp\" #include \"batteries/suppress.hpp\" #include \"batteries/tuples.hpp\" #include \"batteries/type_traits.hpp\" #include \"batteries/utility.hpp\" #include \"batteries/var_size_array.hpp\" Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries.hpp"},{"location":"_autogen/Files/batteries_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Convenience header to include all of the Batteries library. // #pragma once #include <batteries/config.hpp> #include \"batteries/assert.hpp\" #include \"batteries/case_of.hpp\" #include \"batteries/checked_cast.hpp\" #include \"batteries/cpu_align.hpp\" #include \"batteries/finally.hpp\" #include \"batteries/hint.hpp\" #include \"batteries/int_types.hpp\" #include \"batteries/nullable.hpp\" #include \"batteries/radix_queue.hpp\" #include \"batteries/segv.hpp\" #include \"batteries/small_fn.hpp\" #include \"batteries/state_machine_model.hpp\" #include \"batteries/static_assert.hpp\" #include \"batteries/static_dispatch.hpp\" #include \"batteries/stream_util.hpp\" #include \"batteries/strict.hpp\" #include \"batteries/strong_typedef.hpp\" #include \"batteries/suppress.hpp\" #include \"batteries/tuples.hpp\" #include \"batteries/type_traits.hpp\" #include \"batteries/utility.hpp\" #include \"batteries/var_size_array.hpp\" Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/bounds_8hpp/","text":"batteries/bounds.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::LeastUpperBound struct batt::GreatestLowerBound Defines \ud83d\udd17 Name BATTERIES_BOUNDS_HPP BATT_UNWRAP (...) BATT_TOTALLY_ORDERED (inline_decl, left_type, right_type) BATT_EQUALITY_COMPARABLE (inline_decl, left_type, right_type) BATT_DEFINE_INT_BOUNDS (type) Macro Documentation \ud83d\udd17 BATTERIES_BOUNDS_HPP \ud83d\udd17 1 #define BATTERIES_BOUNDS_HPP() BATT_UNWRAP \ud83d\udd17 1 #define BATT_UNWRAP(...) BATT_TOTALLY_ORDERED \ud83d\udd17 1 #define BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type) BATT_EQUALITY_COMPARABLE \ud83d\udd17 1 #define BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type) BATT_DEFINE_INT_BOUNDS \ud83d\udd17 1 #define BATT_DEFINE_INT_BOUNDS(type) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_BOUNDS_HPP #define BATTERIES_BOUNDS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/utility.hpp> namespace batt { enum struct InclusiveLowerBound : bool { kFalse = false , kTrue = true }; enum struct InclusiveUpperBound : bool { kFalse = false , kTrue = true }; #define BATT_UNWRAP(...) __VA_ARGS__ #define BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type) \\ BATT_UNWRAP inline_decl bool operator>(const left_type& l, const right_type& r) \\ { \\ return r < l; \\ } \\ BATT_UNWRAP inline_decl bool operator<=(const left_type& l, const right_type& r) \\ { \\ return !(l > r); \\ } \\ BATT_UNWRAP inline_decl bool operator>=(const left_type& l, const right_type& r) \\ { \\ return !(l < r); \\ } #define BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type) \\ BATT_UNWRAP inline_decl bool operator!=(const left_type& l, const right_type& r) \\ { \\ return !(l == r); \\ } #define BATT_DEFINE_INT_BOUNDS(type) \\ inline type least_upper_bound(type n) \\ { \\ return n + 1; \\ } \\ inline type greatest_lower_bound(type n) \\ { \\ return n - 1; \\ } BATT_DEFINE_INT_BOUNDS ( i8 ) BATT_DEFINE_INT_BOUNDS ( i16 ) BATT_DEFINE_INT_BOUNDS ( i32 ) BATT_DEFINE_INT_BOUNDS ( i64 ) BATT_DEFINE_INT_BOUNDS ( u8 ) BATT_DEFINE_INT_BOUNDS ( u16 ) BATT_DEFINE_INT_BOUNDS ( u32 ) BATT_DEFINE_INT_BOUNDS ( u64 ) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > struct LeastUpperBound { T value ; }; template < typename T > LeastUpperBound < std :: decay_t < T >> least_upper_bound ( T && value ) { return { BATT_FORWARD ( value )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator < ( const T & left , const LeastUpperBound < U >& right ) { // left <= right // return ! ( right . value < left ); } template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T >& left , const U & right ) { return left . value < right ; } template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T >& left , const LeastUpperBound < U >& right ) { return left . value < right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator == ( const T & , const LeastUpperBound < U >& ) { return false ; } template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T >& , const U & ) { return false ; } template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T >& left , const LeastUpperBound < U >& right ) { return left . value == right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), T , LeastUpperBound < U > ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), LeastUpperBound < T > , U ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), LeastUpperBound < T > , LeastUpperBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), T , LeastUpperBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), LeastUpperBound < T > , U ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), LeastUpperBound < T > , LeastUpperBound < U > ) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > struct GreatestLowerBound { T value ; }; template < typename T , typename U > GreatestLowerBound < std :: decay_t < T >> greatest_lower_bound ( T && value ) { return { BATT_FORWARD ( value )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator < ( const T & left , const GreatestLowerBound < U >& right ) { return left < right . value ; } template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T >& left , const U & right ) { // left <= right // return ! ( right . value < left ); } template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T >& left , const GreatestLowerBound < U >& right ) { return left . value < right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator == ( const T & , const GreatestLowerBound < U >& ) { return false ; } template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T >& , const U & ) { return false ; } template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T >& left , const GreatestLowerBound < U >& right ) { return left . value == right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), T , GreatestLowerBound < U > ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), GreatestLowerBound < T > , U ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), GreatestLowerBound < T > , GreatestLowerBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), T , GreatestLowerBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), GreatestLowerBound < T > , U ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), GreatestLowerBound < T > , GreatestLowerBound < U > ) } // namespace batt #endif // BATTERIES_BOUNDS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/bounds.hpp"},{"location":"_autogen/Files/bounds_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/bounds_8hpp/#classes","text":"Name struct batt::LeastUpperBound struct batt::GreatestLowerBound","title":"Classes"},{"location":"_autogen/Files/bounds_8hpp/#defines","text":"Name BATTERIES_BOUNDS_HPP BATT_UNWRAP (...) BATT_TOTALLY_ORDERED (inline_decl, left_type, right_type) BATT_EQUALITY_COMPARABLE (inline_decl, left_type, right_type) BATT_DEFINE_INT_BOUNDS (type)","title":"Defines"},{"location":"_autogen/Files/bounds_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/bounds_8hpp/#batteries_bounds_hpp","text":"1 #define BATTERIES_BOUNDS_HPP()","title":"BATTERIES_BOUNDS_HPP"},{"location":"_autogen/Files/bounds_8hpp/#batt_unwrap","text":"1 #define BATT_UNWRAP(...)","title":"BATT_UNWRAP"},{"location":"_autogen/Files/bounds_8hpp/#batt_totally_ordered","text":"1 #define BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type)","title":"BATT_TOTALLY_ORDERED"},{"location":"_autogen/Files/bounds_8hpp/#batt_equality_comparable","text":"1 #define BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type)","title":"BATT_EQUALITY_COMPARABLE"},{"location":"_autogen/Files/bounds_8hpp/#batt_define_int_bounds","text":"1 #define BATT_DEFINE_INT_BOUNDS(type)","title":"BATT_DEFINE_INT_BOUNDS"},{"location":"_autogen/Files/bounds_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_BOUNDS_HPP #define BATTERIES_BOUNDS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/utility.hpp> namespace batt { enum struct InclusiveLowerBound : bool { kFalse = false , kTrue = true }; enum struct InclusiveUpperBound : bool { kFalse = false , kTrue = true }; #define BATT_UNWRAP(...) __VA_ARGS__ #define BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type) \\ BATT_UNWRAP inline_decl bool operator>(const left_type& l, const right_type& r) \\ { \\ return r < l; \\ } \\ BATT_UNWRAP inline_decl bool operator<=(const left_type& l, const right_type& r) \\ { \\ return !(l > r); \\ } \\ BATT_UNWRAP inline_decl bool operator>=(const left_type& l, const right_type& r) \\ { \\ return !(l < r); \\ } #define BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type) \\ BATT_UNWRAP inline_decl bool operator!=(const left_type& l, const right_type& r) \\ { \\ return !(l == r); \\ } #define BATT_DEFINE_INT_BOUNDS(type) \\ inline type least_upper_bound(type n) \\ { \\ return n + 1; \\ } \\ inline type greatest_lower_bound(type n) \\ { \\ return n - 1; \\ } BATT_DEFINE_INT_BOUNDS ( i8 ) BATT_DEFINE_INT_BOUNDS ( i16 ) BATT_DEFINE_INT_BOUNDS ( i32 ) BATT_DEFINE_INT_BOUNDS ( i64 ) BATT_DEFINE_INT_BOUNDS ( u8 ) BATT_DEFINE_INT_BOUNDS ( u16 ) BATT_DEFINE_INT_BOUNDS ( u32 ) BATT_DEFINE_INT_BOUNDS ( u64 ) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > struct LeastUpperBound { T value ; }; template < typename T > LeastUpperBound < std :: decay_t < T >> least_upper_bound ( T && value ) { return { BATT_FORWARD ( value )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator < ( const T & left , const LeastUpperBound < U >& right ) { // left <= right // return ! ( right . value < left ); } template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T >& left , const U & right ) { return left . value < right ; } template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T >& left , const LeastUpperBound < U >& right ) { return left . value < right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator == ( const T & , const LeastUpperBound < U >& ) { return false ; } template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T >& , const U & ) { return false ; } template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T >& left , const LeastUpperBound < U >& right ) { return left . value == right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), T , LeastUpperBound < U > ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), LeastUpperBound < T > , U ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), LeastUpperBound < T > , LeastUpperBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), T , LeastUpperBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), LeastUpperBound < T > , U ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), LeastUpperBound < T > , LeastUpperBound < U > ) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > struct GreatestLowerBound { T value ; }; template < typename T , typename U > GreatestLowerBound < std :: decay_t < T >> greatest_lower_bound ( T && value ) { return { BATT_FORWARD ( value )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator < ( const T & left , const GreatestLowerBound < U >& right ) { return left < right . value ; } template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T >& left , const U & right ) { // left <= right // return ! ( right . value < left ); } template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T >& left , const GreatestLowerBound < U >& right ) { return left . value < right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > inline bool operator == ( const T & , const GreatestLowerBound < U >& ) { return false ; } template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T >& , const U & ) { return false ; } template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T >& left , const GreatestLowerBound < U >& right ) { return left . value == right . value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), T , GreatestLowerBound < U > ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), GreatestLowerBound < T > , U ) BATT_TOTALLY_ORDERED (( template < typename T , typename U > inline ), GreatestLowerBound < T > , GreatestLowerBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), T , GreatestLowerBound < U > ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), GreatestLowerBound < T > , U ) BATT_EQUALITY_COMPARABLE (( template < typename T , typename U > inline ), GreatestLowerBound < T > , GreatestLowerBound < U > ) } // namespace batt #endif // BATTERIES_BOUNDS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/boxed_8hpp/","text":"batteries/seq/boxed.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::BoxedSeq class batt::BoxedSeq::SeqImpl class batt::BoxedSeq::AbstractSeq class batt::BoxedSeq::SeqImpl struct batt::IsBoxedSeq struct batt::IsBoxedSeq< BoxedSeq< T > > struct batt::seq::BoxedBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_BOXED_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_BOXED_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_BOXED_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_BOXED_HPP #define BATTERIES_SEQ_BOXED_HPP #include <batteries/config.hpp> // #include <batteries/hint.hpp> #include <batteries/optional.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/type_erasure.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <memory> #include <type_traits> namespace batt { class Status ; enum struct StatusCode ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BoxedSeq<ItemT> // template < typename ItemT > class BoxedSeq { public : class AbstractSeq ; template < typename T > class SeqImpl ; using storage_type = TypeErasedStorage < AbstractSeq , SeqImpl > ; class AbstractSeq : public AbstractValue < AbstractSeq > { public : AbstractSeq () = default ; AbstractSeq ( const AbstractSeq & ) = delete ; AbstractSeq & operator = ( const AbstractSeq & ) = delete ; virtual ~ AbstractSeq () = default ; virtual Optional < ItemT > peek () = 0 ; virtual Optional < ItemT > next () = 0 ; }; template < typename T > class SeqImpl : public AbstractValueImpl < AbstractSeq , SeqImpl , T > { public : using Super = AbstractValueImpl < AbstractSeq , SeqImpl , T > ; static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"BoxedSeq<T&> is not supported\" ); explicit SeqImpl ( T && seq ) noexcept : Super { BATT_FORWARD ( seq )} { } Optional < ItemT > peek () override { return this -> obj_ . peek (); } Optional < ItemT > next () override { return this -> obj_ . next (); } }; using Item = ItemT ; BoxedSeq () = default ; template < typename T , // typename = EnableIfNoShadow < BoxedSeq , T &&> , // typename = EnableIfSeq < T > , // typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < T > , Status > && ! std :: is_same_v < std :: decay_t < T > , StatusCode >>> explicit BoxedSeq ( T && seq ) : storage_ { StaticType < T > {}, BATT_FORWARD ( seq )} { static_assert ( std :: is_same < T , std :: decay_t < T >> {}, \"BoxedSeq may not be used to capture a reference\" ); } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( const BoxedSeq < U >& other_seq ) = delete ; template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( BoxedSeq < U >&& other_seq ) = delete ; // Copyable. // BoxedSeq ( BoxedSeq && ) = default ; BoxedSeq ( const BoxedSeq & that ) = default ; BoxedSeq & operator = ( BoxedSeq && ) = default ; BoxedSeq & operator = ( const BoxedSeq & that ) = default ; Optional < Item > peek () { return this -> storage_ -> peek (); } Optional < Item > next () { return this -> storage_ -> next (); } private : storage_type storage_ ; }; template < typename T > struct IsBoxedSeq : std :: false_type { }; template < typename T > struct IsBoxedSeq < BoxedSeq < T >> : std :: true_type { }; namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // boxed // struct BoxedBinder { }; inline BoxedBinder boxed () { return {}; } template < typename Seq , typename = EnableIfSeq < Seq > , typename Item = typename std :: conditional_t < has_seq_requirements < Seq > (), // /*then*/ SeqItem_Impl < Seq > , /*else*/ StaticType < void >>:: type > [[ nodiscard ]] inline BoxedSeq < Item > operator | ( Seq && seq , BoxedBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Boxed sequences may not be captured implicitly by reference.\" ); return BoxedSeq < Item > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_BOXED_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/boxed.hpp"},{"location":"_autogen/Files/boxed_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/boxed_8hpp/#classes","text":"Name class batt::BoxedSeq class batt::BoxedSeq::SeqImpl class batt::BoxedSeq::AbstractSeq class batt::BoxedSeq::SeqImpl struct batt::IsBoxedSeq struct batt::IsBoxedSeq< BoxedSeq< T > > struct batt::seq::BoxedBinder","title":"Classes"},{"location":"_autogen/Files/boxed_8hpp/#defines","text":"Name BATTERIES_SEQ_BOXED_HPP","title":"Defines"},{"location":"_autogen/Files/boxed_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/boxed_8hpp/#batteries_seq_boxed_hpp","text":"1 #define BATTERIES_SEQ_BOXED_HPP()","title":"BATTERIES_SEQ_BOXED_HPP"},{"location":"_autogen/Files/boxed_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_BOXED_HPP #define BATTERIES_SEQ_BOXED_HPP #include <batteries/config.hpp> // #include <batteries/hint.hpp> #include <batteries/optional.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/type_erasure.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <memory> #include <type_traits> namespace batt { class Status ; enum struct StatusCode ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BoxedSeq<ItemT> // template < typename ItemT > class BoxedSeq { public : class AbstractSeq ; template < typename T > class SeqImpl ; using storage_type = TypeErasedStorage < AbstractSeq , SeqImpl > ; class AbstractSeq : public AbstractValue < AbstractSeq > { public : AbstractSeq () = default ; AbstractSeq ( const AbstractSeq & ) = delete ; AbstractSeq & operator = ( const AbstractSeq & ) = delete ; virtual ~ AbstractSeq () = default ; virtual Optional < ItemT > peek () = 0 ; virtual Optional < ItemT > next () = 0 ; }; template < typename T > class SeqImpl : public AbstractValueImpl < AbstractSeq , SeqImpl , T > { public : using Super = AbstractValueImpl < AbstractSeq , SeqImpl , T > ; static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"BoxedSeq<T&> is not supported\" ); explicit SeqImpl ( T && seq ) noexcept : Super { BATT_FORWARD ( seq )} { } Optional < ItemT > peek () override { return this -> obj_ . peek (); } Optional < ItemT > next () override { return this -> obj_ . next (); } }; using Item = ItemT ; BoxedSeq () = default ; template < typename T , // typename = EnableIfNoShadow < BoxedSeq , T &&> , // typename = EnableIfSeq < T > , // typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < T > , Status > && ! std :: is_same_v < std :: decay_t < T > , StatusCode >>> explicit BoxedSeq ( T && seq ) : storage_ { StaticType < T > {}, BATT_FORWARD ( seq )} { static_assert ( std :: is_same < T , std :: decay_t < T >> {}, \"BoxedSeq may not be used to capture a reference\" ); } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( const BoxedSeq < U >& other_seq ) = delete ; template < typename U , typename = std :: enable_if_t <! std :: is_same_v < ItemT , U >>> BoxedSeq ( BoxedSeq < U >&& other_seq ) = delete ; // Copyable. // BoxedSeq ( BoxedSeq && ) = default ; BoxedSeq ( const BoxedSeq & that ) = default ; BoxedSeq & operator = ( BoxedSeq && ) = default ; BoxedSeq & operator = ( const BoxedSeq & that ) = default ; Optional < Item > peek () { return this -> storage_ -> peek (); } Optional < Item > next () { return this -> storage_ -> next (); } private : storage_type storage_ ; }; template < typename T > struct IsBoxedSeq : std :: false_type { }; template < typename T > struct IsBoxedSeq < BoxedSeq < T >> : std :: true_type { }; namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // boxed // struct BoxedBinder { }; inline BoxedBinder boxed () { return {}; } template < typename Seq , typename = EnableIfSeq < Seq > , typename Item = typename std :: conditional_t < has_seq_requirements < Seq > (), // /*then*/ SeqItem_Impl < Seq > , /*else*/ StaticType < void >>:: type > [[ nodiscard ]] inline BoxedSeq < Item > operator | ( Seq && seq , BoxedBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Boxed sequences may not be captured implicitly by reference.\" ); return BoxedSeq < Item > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_BOXED_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/buffer_8hpp/","text":"batteries/buffer.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::ManagedBuffer class batt::BufferViewImpl class batt::ConstBufferView class batt::MutableBufferView Defines \ud83d\udd17 Name BATTERIES_BUFFER_HPP Macro Documentation \ud83d\udd17 BATTERIES_BUFFER_HPP \ud83d\udd17 1 #define BATTERIES_BUFFER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_BUFFER_HPP #define BATTERIES_BUFFER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/utility.hpp> #include <boost/asio/buffer.hpp> namespace batt { using ConstBuffer = boost :: asio :: const_buffer ; using MutableBuffer = boost :: asio :: mutable_buffer ; template < typename ... Args > decltype ( auto ) make_buffer ( Args && ... args ) { return boost :: asio :: buffer ( BATT_FORWARD ( args )...); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > inline ConstBuffer buffer_from_struct ( const T & val ) { return ConstBuffer { & val , sizeof ( T )}; } template < typename T > inline MutableBuffer mutable_buffer_from_struct ( T & val ) { return MutableBuffer { & val , sizeof ( T )}; } inline ConstBuffer resize_buffer ( const ConstBuffer & b , usize s ) { return ConstBuffer { b . data (), std :: min ( s , b . size ())}; } inline MutableBuffer resize_buffer ( const MutableBuffer & b , usize s ) { return MutableBuffer { b . data (), std :: min ( s , b . size ())}; } template < typename VecT > inline void consume_buffers ( VecT & buffers , usize count ) { while ( count > 0 ) { BATT_CHECK ( ! buffers . empty ()); if ( buffers . front (). size () > count ) { buffers . front () += count ; break ; } count -= buffers . front (). size (); buffers . erase ( buffers . begin ()); } } template < typename Iter > inline std :: pair < Iter , usize /*offset*/ > consume_buffers_iter ( const std :: pair < Iter , usize /*offset*/ >& pos , const Iter & last , usize count ) { Iter first = pos . first ; usize offset = pos . second ; while ( count > 0 && first != last ) { ConstBuffer front { * first }; front += offset ; offset = 0 ; if ( front . size () > count ) { return std :: make_pair ( first , count ); } count -= front . size (); ++ first ; } return std :: make_pair ( first , 0 ); } template < typename VecT > inline VecT consume_buffers_copy ( const VecT & buffers , usize count ) { VecT copy = buffers ; consume_buffers ( copy , count ); return copy ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - class MutableBufferView ; class ConstBufferView ; class ManagedBuffer : public RefCounted < ManagedBuffer > { public : static constexpr usize kCapacity = 4096 ; char * data () { return this -> storage_ . data (); } const char * data () const { return this -> storage_ . data (); } usize size () const { return this -> storage_ . size (); } private : std :: array < char , ManagedBuffer :: kCapacity > storage_ ; }; class BufferViewImpl { public : using Self = BufferViewImpl ; explicit BufferViewImpl ( SharedPtr < ManagedBuffer >&& buffer , usize offset = 0 ) noexcept : buffer_ { std :: move ( buffer )} , offset_ { offset } , length_ { this -> buffer_ -> size () - this -> offset_ } { } explicit BufferViewImpl ( SharedPtr < ManagedBuffer >&& buffer , usize offset , usize length ) noexcept : buffer_ { std :: move ( buffer )} , offset_ { offset } , length_ { length } { } void * data () const { return this -> buffer_ -> data () + this -> offset_ ; } usize size () const { return this -> length_ ; } Self & operator += ( usize delta ) { delta = std :: min ( delta , this -> length_ ); this -> offset_ += delta ; this -> length_ -= delta ; return * this ; } bool append ( Self && next ) { if ( this -> buffer_ == next . buffer_ && this -> offset_ + this -> length_ == next . offset_ ) { this -> length_ += next . length_ ; return true ; } return false ; } private : SharedPtr < ManagedBuffer > buffer_ ; usize offset_ ; usize length_ ; }; class ConstBufferView { public : friend class MutableBufferView ; ConstBufferView ( const ConstBufferView & ) = default ; ConstBufferView & operator = ( const ConstBufferView & ) = default ; explicit ConstBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset = 0 ) noexcept : impl_ { std :: move ( buffer ), offset } { } explicit ConstBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset , usize length ) noexcept : impl_ { std :: move ( buffer ), offset , length } { } //+++++++++++-+-+--+----- --- -- - - - - ConstBufferView ( const MutableBufferView & other ) noexcept ; ConstBufferView ( MutableBufferView && other ) noexcept ; ConstBufferView & operator = ( const MutableBufferView & other ); ConstBufferView & operator = ( MutableBufferView && other ); //+++++++++++-+-+--+----- --- -- - - - - operator ConstBuffer () const { return ConstBuffer { this -> data (), this -> size ()}; } ConstBufferView & operator += ( usize delta ) { this -> impl_ += delta ; return * this ; } const void * data () const { return this -> impl_ . data (); } usize size () const { return this -> impl_ . size (); } bool append ( ConstBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } bool append ( MutableBufferView && next ); private : BufferViewImpl impl_ ; }; class MutableBufferView { public : friend class ConstBufferView ; MutableBufferView ( const MutableBufferView & ) = default ; MutableBufferView & operator = ( const MutableBufferView & ) = default ; explicit MutableBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset = 0 ) noexcept : impl_ { std :: move ( buffer ), offset } { } explicit MutableBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset , usize length ) noexcept : impl_ { std :: move ( buffer ), offset , length } { } operator MutableBuffer () const { return MutableBuffer { this -> data (), this -> size ()}; } operator ConstBuffer () const { return ConstBuffer { this -> data (), this -> size ()}; } MutableBufferView & operator += ( usize delta ) { this -> impl_ += delta ; return * this ; } void * data () const { return this -> impl_ . data (); } usize size () const { return this -> impl_ . size (); } bool append ( ConstBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } bool append ( MutableBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } private : BufferViewImpl impl_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView :: ConstBufferView ( const MutableBufferView & other ) noexcept : impl_ { other . impl_ } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView :: ConstBufferView ( MutableBufferView && other ) noexcept : impl_ { std :: move ( other . impl_ )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView & ConstBufferView :: operator = ( const MutableBufferView & other ) { this -> impl_ = other . impl_ ; return * this ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView & ConstBufferView :: operator = ( MutableBufferView && other ) { this -> impl_ = std :: move ( other . impl_ ); return * this ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool ConstBufferView :: append ( MutableBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } } // namespace batt #endif // BATTERIES_BUFFER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/buffer.hpp"},{"location":"_autogen/Files/buffer_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/buffer_8hpp/#classes","text":"Name class batt::ManagedBuffer class batt::BufferViewImpl class batt::ConstBufferView class batt::MutableBufferView","title":"Classes"},{"location":"_autogen/Files/buffer_8hpp/#defines","text":"Name BATTERIES_BUFFER_HPP","title":"Defines"},{"location":"_autogen/Files/buffer_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/buffer_8hpp/#batteries_buffer_hpp","text":"1 #define BATTERIES_BUFFER_HPP()","title":"BATTERIES_BUFFER_HPP"},{"location":"_autogen/Files/buffer_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_BUFFER_HPP #define BATTERIES_BUFFER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/utility.hpp> #include <boost/asio/buffer.hpp> namespace batt { using ConstBuffer = boost :: asio :: const_buffer ; using MutableBuffer = boost :: asio :: mutable_buffer ; template < typename ... Args > decltype ( auto ) make_buffer ( Args && ... args ) { return boost :: asio :: buffer ( BATT_FORWARD ( args )...); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > inline ConstBuffer buffer_from_struct ( const T & val ) { return ConstBuffer { & val , sizeof ( T )}; } template < typename T > inline MutableBuffer mutable_buffer_from_struct ( T & val ) { return MutableBuffer { & val , sizeof ( T )}; } inline ConstBuffer resize_buffer ( const ConstBuffer & b , usize s ) { return ConstBuffer { b . data (), std :: min ( s , b . size ())}; } inline MutableBuffer resize_buffer ( const MutableBuffer & b , usize s ) { return MutableBuffer { b . data (), std :: min ( s , b . size ())}; } template < typename VecT > inline void consume_buffers ( VecT & buffers , usize count ) { while ( count > 0 ) { BATT_CHECK ( ! buffers . empty ()); if ( buffers . front (). size () > count ) { buffers . front () += count ; break ; } count -= buffers . front (). size (); buffers . erase ( buffers . begin ()); } } template < typename Iter > inline std :: pair < Iter , usize /*offset*/ > consume_buffers_iter ( const std :: pair < Iter , usize /*offset*/ >& pos , const Iter & last , usize count ) { Iter first = pos . first ; usize offset = pos . second ; while ( count > 0 && first != last ) { ConstBuffer front { * first }; front += offset ; offset = 0 ; if ( front . size () > count ) { return std :: make_pair ( first , count ); } count -= front . size (); ++ first ; } return std :: make_pair ( first , 0 ); } template < typename VecT > inline VecT consume_buffers_copy ( const VecT & buffers , usize count ) { VecT copy = buffers ; consume_buffers ( copy , count ); return copy ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - class MutableBufferView ; class ConstBufferView ; class ManagedBuffer : public RefCounted < ManagedBuffer > { public : static constexpr usize kCapacity = 4096 ; char * data () { return this -> storage_ . data (); } const char * data () const { return this -> storage_ . data (); } usize size () const { return this -> storage_ . size (); } private : std :: array < char , ManagedBuffer :: kCapacity > storage_ ; }; class BufferViewImpl { public : using Self = BufferViewImpl ; explicit BufferViewImpl ( SharedPtr < ManagedBuffer >&& buffer , usize offset = 0 ) noexcept : buffer_ { std :: move ( buffer )} , offset_ { offset } , length_ { this -> buffer_ -> size () - this -> offset_ } { } explicit BufferViewImpl ( SharedPtr < ManagedBuffer >&& buffer , usize offset , usize length ) noexcept : buffer_ { std :: move ( buffer )} , offset_ { offset } , length_ { length } { } void * data () const { return this -> buffer_ -> data () + this -> offset_ ; } usize size () const { return this -> length_ ; } Self & operator += ( usize delta ) { delta = std :: min ( delta , this -> length_ ); this -> offset_ += delta ; this -> length_ -= delta ; return * this ; } bool append ( Self && next ) { if ( this -> buffer_ == next . buffer_ && this -> offset_ + this -> length_ == next . offset_ ) { this -> length_ += next . length_ ; return true ; } return false ; } private : SharedPtr < ManagedBuffer > buffer_ ; usize offset_ ; usize length_ ; }; class ConstBufferView { public : friend class MutableBufferView ; ConstBufferView ( const ConstBufferView & ) = default ; ConstBufferView & operator = ( const ConstBufferView & ) = default ; explicit ConstBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset = 0 ) noexcept : impl_ { std :: move ( buffer ), offset } { } explicit ConstBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset , usize length ) noexcept : impl_ { std :: move ( buffer ), offset , length } { } //+++++++++++-+-+--+----- --- -- - - - - ConstBufferView ( const MutableBufferView & other ) noexcept ; ConstBufferView ( MutableBufferView && other ) noexcept ; ConstBufferView & operator = ( const MutableBufferView & other ); ConstBufferView & operator = ( MutableBufferView && other ); //+++++++++++-+-+--+----- --- -- - - - - operator ConstBuffer () const { return ConstBuffer { this -> data (), this -> size ()}; } ConstBufferView & operator += ( usize delta ) { this -> impl_ += delta ; return * this ; } const void * data () const { return this -> impl_ . data (); } usize size () const { return this -> impl_ . size (); } bool append ( ConstBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } bool append ( MutableBufferView && next ); private : BufferViewImpl impl_ ; }; class MutableBufferView { public : friend class ConstBufferView ; MutableBufferView ( const MutableBufferView & ) = default ; MutableBufferView & operator = ( const MutableBufferView & ) = default ; explicit MutableBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset = 0 ) noexcept : impl_ { std :: move ( buffer ), offset } { } explicit MutableBufferView ( SharedPtr < ManagedBuffer >&& buffer , usize offset , usize length ) noexcept : impl_ { std :: move ( buffer ), offset , length } { } operator MutableBuffer () const { return MutableBuffer { this -> data (), this -> size ()}; } operator ConstBuffer () const { return ConstBuffer { this -> data (), this -> size ()}; } MutableBufferView & operator += ( usize delta ) { this -> impl_ += delta ; return * this ; } void * data () const { return this -> impl_ . data (); } usize size () const { return this -> impl_ . size (); } bool append ( ConstBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } bool append ( MutableBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } private : BufferViewImpl impl_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView :: ConstBufferView ( const MutableBufferView & other ) noexcept : impl_ { other . impl_ } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView :: ConstBufferView ( MutableBufferView && other ) noexcept : impl_ { std :: move ( other . impl_ )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView & ConstBufferView :: operator = ( const MutableBufferView & other ) { this -> impl_ = other . impl_ ; return * this ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline ConstBufferView & ConstBufferView :: operator = ( MutableBufferView && other ) { this -> impl_ = std :: move ( other . impl_ ); return * this ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool ConstBufferView :: append ( MutableBufferView && next ) { return this -> impl_ . append ( std :: move ( next . impl_ )); } } // namespace batt #endif // BATTERIES_BUFFER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/buffer__source_8hpp/","text":"batteries/async/buffer_source.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail batt::seq Classes \ud83d\udd17 Name class batt::BufferSource class batt::SeqBufferSource class batt::TakeNSource class batt::FilterBufferSource class batt::MapBufferSource struct batt::seq::WriteToBinder class batt::PrependBufferSource Defines \ud83d\udd17 Name BATTERIES_ASYNC_BUFFER_SOURCE_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_BUFFER_SOURCE_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_BUFFER_SOURCE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_BUFFER_SOURCE_HPP #define BATTERIES_ASYNC_BUFFER_SOURCE_HPP #include <batteries/config.hpp> // #include <batteries/async/io_result.hpp> #include <batteries/async/task_decl.hpp> #include <batteries/seq/collect_vec.hpp> #include <batteries/seq/consume.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/prepend.hpp> #include <batteries/seq/print_out.hpp> #include <batteries/seq/skip_n.hpp> #include <batteries/seq/take_n.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/cpu_align.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <batteries/type_erasure.hpp> #include <batteries/utility.hpp> #include <boost/asio/buffer.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - namespace detail { template < typename T > inline std :: false_type has_const_buffer_sequence_requirements_impl (...) { return {}; } template < typename T , typename ElementT = decltype ( * boost :: asio :: buffer_sequence_begin ( std :: declval < T > ())), // typename = std :: enable_if_t < // std :: is_same_v < decltype ( boost :: asio :: buffer_sequence_begin ( std :: declval < T > ())), // decltype ( boost :: asio :: buffer_sequence_end ( std :: declval < T > ())) > && // std :: is_convertible_v < ElementT , boost :: asio :: const_buffer >>> inline std :: true_type has_const_buffer_sequence_requirements_impl ( std :: decay_t < T >* ) { return {}; } } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > using HasConstBufferSequenceRequirements = decltype ( detail :: has_const_buffer_sequence_requirements_impl < T > ( nullptr )); template < typename T > inline constexpr bool has_const_buffer_sequence_requirements ( StaticType < T > = {}) { return HasConstBufferSequenceRequirements < T > {}; } template < typename T > using EnableIfConstBufferSequence = std :: enable_if_t < has_const_buffer_sequence_requirements < T > () > ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - namespace detail { template < typename T > inline std :: false_type has_buffer_source_requirements_impl (...) { return {}; } template < typename T , typename = std :: enable_if_t < // std :: is_same_v < decltype ( std :: declval < T > (). size ()), usize > && // std :: is_same_v < decltype ( std :: declval < T > (). consume ( std :: declval < i64 > ())), void > && // std :: is_same_v < decltype ( std :: declval < T > (). close_for_read ()), void > && HasConstBufferSequenceRequirements < decltype ( * ( std :: declval < T > (). fetch_at_least ( std :: declval < i64 > ()))) > {} >> inline std :: true_type has_buffer_source_requirements_impl ( std :: decay_t < T >* ) { return {}; } } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > using HasBufferSourceRequirements = decltype ( detail :: has_buffer_source_requirements_impl < T > ( nullptr )); template < typename T > inline constexpr bool has_buffer_source_requirements ( StaticType < T > = {}) { return HasBufferSourceRequirements < T > {}; } template < typename T > using EnableIfBufferSource = std :: enable_if_t < has_buffer_source_requirements < T > () > ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A type-erased no-copy input stream. // // Instead of a traditional (copying) input stream, which copies data into caller-supplied buffers, // BufferSource provides the `fetch_at_least` operation, which returns one or more pre-populated data buffers // owned by the BufferSource. The caller is guaranteed that these buffers remain valid until the next // non-const member function is invoked on the BufferSource. // // To make dealing with byte streams easier, BufferSource values can be modified/transformed via a select // subset of `batt::seq` operators: // // - seq::take_n(byte_count) // - seq::skip_n(byte_count) // - seq::prepend(const_buffer_sequence) // - seq::for_each(fn) (fn takes ConstBuffer) // - seq::collect_vec() => std::vector<char> // - seq::print_out(std::ostream) // - seq::consume() // // In addition, a new operator is defined for BufferSource, seq::write_to(AsyncWriteStream): // // ```c++ // batt::BufferSource data_to_send; // boost::asio::ip::tcp::socket dst_stream; // // // Write all the data to the stream. // // // StatusOr<usize> result = data_to_send | batt::seq::write_to(dst_stream); // ``` // class BufferSource { public : BufferSource () = default ; template < typename T , typename = EnableIfNoShadow < BufferSource , T &&> , typename = EnableIfBufferSource < UnwrapRefType < T >> , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , T >>> /*implicit*/ BufferSource ( T && obj ) noexcept ; // Returns true iff this object contains a valid BufferSource impl. // explicit operator bool () const ; // Release the type-erased impl object; post-condition: `bool{*this} == false`. // void clear (); // The current number of bytes available as consumable data. This should be used as an optimization hint // only; the next call to `fetch_*` may return more bytes than the last returned value of size. // Specifically, callers should not count on `size()` returning 0 being an indication that the next call // to `fetch_at_least` will block. // usize size () const ; // Returns a ConstBufferSequence containing at least `min_count` bytes of data. // // This method may block the current task if there isn't enough data available to satisfy // the request (i.e., if `this->size() < min_count`). // StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ); // Consume the specified number of bytes from the front of the stream so that future calls to // `fetch_at_least` will not return the same data. // void consume ( i64 count ); // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be read/consumed. // void close_for_read (); private : class AbstractBufferSource ; template < typename T > class BufferSourceImpl ; //+++++++++++-+-+--+----- --- -- - - - - TypeErasedStorage < AbstractBufferSource , BufferSourceImpl > impl_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Adapts a Seq of Item = ConstBuffer to a BufferSource impl, allowing it to be wrapped via the BufferSource // class. // template < typename Seq > class SeqBufferSource { public : using Item = ConstBuffer ; static_assert ( std :: is_convertible_v < SeqItem < Seq > , ConstBuffer > , \"\" ); StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) { usize active_size = boost :: asio :: buffer_size ( this -> active_buffers_ ); while ( active_size < min_count ) { Optional < ConstBuffer > next_buffer = this -> seq_ . next (); if ( next_buffer == None ) { return { StatusCode :: kInvalidArgument }; } active_size += next_buffer -> size (); this -> active_buffers_ . emplace_back ( std :: move ( * next_buffer )); } return this -> active_buffers_ ; } void consume ( i64 count ) { consume_buffers ( this -> active_buffers_ , count ); } private : Seq seq_ ; SmallVec < ConstBuffer , 2 > active_buffers_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::take_n(byte_count) // template < typename Src > class TakeNSource { public : explicit TakeNSource ( Src && src , usize limit ) noexcept : limit_ { limit }, src_ { BATT_FORWARD ( src )} { } usize size () const { return std :: min ( this -> limit_ , this -> src_ . size ()); } StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) { StatusOr < SmallVec < ConstBuffer , 2 >> buffers = this -> src_ . fetch_at_least ( min_count ); BATT_REQUIRE_OK ( buffers ); usize n_fetched = boost :: asio :: buffer_size ( * buffers ); // Trim data from the end of the fetched range until we are under our limit. // while ( n_fetched > this -> limit_ && ! buffers -> empty ()) { ConstBuffer & last_buffer = buffers -> back (); const usize extra_bytes = n_fetched - this -> limit_ ; if ( last_buffer . size () <= extra_bytes ) { n_fetched -= last_buffer . size (); buffers -> pop_back (); } else { n_fetched -= extra_bytes ; last_buffer = ConstBuffer { last_buffer . data (), last_buffer . size () - extra_bytes }; } } return buffers ; } void consume ( i64 count ) { const usize n_to_consume = std :: min ( BATT_CHECKED_CAST ( usize , count ), this -> limit_ ); this -> src_ . consume ( BATT_CHECKED_CAST ( usize , n_to_consume )); this -> limit_ -= n_to_consume ; } void close_for_read () { this -> limit_ = 0 ; } private : usize limit_ ; Src src_ ; }; template < typename Src , typename = EnableIfBufferSource < Src >> TakeNSource < Src > operator | ( Src && src , seq :: TakeNBinder binder ) { return TakeNSource < Src > { BATT_FORWARD ( src ), binder . n }; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::skip_n(byte_count) // template < typename Src , typename = EnableIfBufferSource < Src >> void operator | ( Src && src , SkipNBinder binder ) { // TODO [tastolfi 2022-03-23] BATT_PANIC () << \"TODO [tastolfi 2022-03-28] implement me!\" ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::filter(StatusOr<ConstBufferSequence>(ConstBufferSequence)) // template < typename Src , typename MapFn > class FilterBufferSource { public : // TODO [tastolfi 2022-06-22] private : }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::map(void(BufferSource& src, BufferSink& dst)) // template < typename Src , typename MapFn > class MapBufferSource { public : // TODO [tastolfi 2022-06-22] private : }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::for_each() // template < typename Src , typename Fn , typename = EnableIfBufferSource < Src >> inline StatusOr < seq :: LoopControl > operator | ( Src && src , seq :: ForEachBinder < Fn >&& binder ) { for (;;) { auto fetched = src . fetch_at_least ( 1 ); if ( fetched . status () == StatusCode :: kEndOfStream ) { break ; } BATT_REQUIRE_OK ( fetched ); usize n_to_consume = 0 ; for ( const ConstBuffer & buffer : * fetched ) { n_to_consume += buffer . size (); if ( BATT_HINT_FALSE ( seq :: run_loop_fn ( binder . fn , buffer ) == seq :: kBreak )) { return seq :: kBreak ; } } if ( n_to_consume == 0 ) { break ; } src . consume ( n_to_consume ); } return seq :: kContinue ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::collect_vec() // template < typename Src , typename = EnableIfBufferSource < Src >> inline StatusOr < std :: vector < char >> operator | ( Src && src , seq :: CollectVec ) { std :: vector < char > bytes ; StatusOr < seq :: LoopControl > result = BATT_FORWARD ( src ) | seq :: for_each ([ & bytes ]( const ConstBuffer & buffer ) { const char * data_begin = static_cast < const char *> ( buffer . data ()); const char * data_end = data_begin + buffer . size (); bytes . insert ( bytes . end (), data_begin , data_end ); }); BATT_REQUIRE_OK ( result ); return bytes ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::print_out(out) // template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: PrintOut p ) { return ( BATT_FORWARD ( src ) | seq :: for_each ([ & ]( const ConstBuffer & buffer ) { p . out . write ( static_cast < const char *> ( buffer . data ()), buffer . size ()); })) . status (); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::consume() template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: Consume ) { StatusOr < seq :: LoopControl > result = BATT_FORWARD ( src ) | seq :: for_each ([]( auto && ...) noexcept { // nom, nom, nom... }); BATT_REQUIRE_OK ( result ); BATT_CHECK_EQ ( * result , seq :: kContinue ); return OkStatus (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // namespace seq { template < typename AsyncWriteStream > struct WriteToBinder { AsyncWriteStream dst ; }; template < typename AsyncWriteStream > inline auto write_to ( AsyncWriteStream && dst ) { return WriteToBinder < AsyncWriteStream > { BATT_FORWARD ( dst )}; } } // namespace seq //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::write_to(async_write_stream) // template < typename Src , typename AsyncWriteStream , typename = EnableIfBufferSource < Src >> StatusOr < usize > operator | ( Src && src , seq :: WriteToBinder < AsyncWriteStream >&& binder ) { usize bytes_transferred = 0 ; for (;;) { auto fetched = src . fetch_at_least ( 1 ); if ( fetched . status () == StatusCode :: kEndOfStream ) { break ; } BATT_REQUIRE_OK ( fetched ); IOResult < usize > bytes_written = Task :: await_write_some ( binder . dst , * fetched ); BATT_REQUIRE_OK ( bytes_written ); bytes_transferred += * bytes_written ; src . consume ( * bytes_written ); } return bytes_transferred ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::prepend(buffers) // template < typename Src , typename ConstBufferSequence > class PrependBufferSource { public : using BufferIter = std :: decay_t < decltype ( boost :: asio :: buffer_sequence_begin ( std :: declval < ConstBufferSequence > ())) > ; explicit PrependBufferSource ( ConstBufferSequence && buffers , Src && rest ) noexcept : first_ { BATT_FORWARD ( buffers )} , first_begin_ { boost :: asio :: buffer_sequence_begin ( this -> first_ )} , first_end_ { boost :: asio :: buffer_sequence_end ( this -> first_ )} , first_offset_ { 0 } , first_size_ { boost :: asio :: buffer_size ( this -> first_ )} , rest_ { BATT_FORWARD ( rest )} { if ( this -> first_size_ == 0 ) { this -> first_begin_ = this -> first_end_ ; } } usize size () const { return this -> first_size_ + this -> rest_ . size (); } StatusOr < SmallVec < ConstBuffer , 3 >> fetch_at_least ( i64 min_count_i ) { const usize min_count_z = BATT_CHECKED_CAST ( usize , min_count_i ); SmallVec < ConstBuffer , 3 > buffer ( this -> first_begin_ , this -> first_end_ ); if ( ! buffer . empty ()) { buffer . front () += first_offset_ ; } const usize rest_min_count = min_count_z - std :: min ( this -> first_size_ , min_count_z ); auto fetched_from_rest = this -> rest_ . fetch_at_least ( rest_min_count ); if ( buffer . empty () || fetched_from_rest . status () != StatusCode :: kEndOfStream ) { BATT_REQUIRE_OK ( fetched_from_rest ); } if ( fetched_from_rest . ok ()) { buffer . insert ( buffer . end (), // boost :: asio :: buffer_sequence_begin ( * fetched_from_rest ), boost :: asio :: buffer_sequence_end ( * fetched_from_rest )); } return buffer ; } void consume ( i64 count_i ) { const usize count_z = BATT_CHECKED_CAST ( usize , count_i ); const usize consume_from_first = std :: min ( this -> first_size_ , count_z ); const usize consume_from_rest = count_z - consume_from_first ; std :: tie ( this -> first_begin_ , this -> first_offset_ ) = consume_buffers_iter ( std :: make_pair ( this -> first_begin_ , this -> first_offset_ ), this -> first_end_ , consume_from_first ); this -> first_size_ -= consume_from_first ; if ( consume_from_rest > 0 ) { this -> rest_ . consume ( consume_from_rest ); } } void close_for_read () { this -> first_begin_ = this -> first_end_ ; this -> first_size_ = 0 ; this -> rest_ . close_for_read (); } private : ConstBufferSequence first_ ; BufferIter first_begin_ ; BufferIter first_end_ ; usize first_offset_ ; usize first_size_ ; Src rest_ ; }; template < typename Src , typename ConstBufferSequence , // typename = EnableIfBufferSource < Src > , // typename = EnableIfConstBufferSequence < ConstBufferSequence >> inline auto operator | ( Src && src , seq :: PrependBinder < ConstBufferSequence >&& binder ) { return PrependBufferSource < Src , ConstBufferSequence > { BATT_FORWARD ( binder . item ), BATT_FORWARD ( src )}; } } // namespace batt #endif // BATTERIES_ASYNC_BUFFER_SOURCE_HPP #include <batteries/config.hpp> #if BATT_HEADER_ONLY #include <batteries/async/buffer_source_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/buffer_source.hpp"},{"location":"_autogen/Files/buffer__source_8hpp/#namespaces","text":"Name batt batt::detail batt::seq","title":"Namespaces"},{"location":"_autogen/Files/buffer__source_8hpp/#classes","text":"Name class batt::BufferSource class batt::SeqBufferSource class batt::TakeNSource class batt::FilterBufferSource class batt::MapBufferSource struct batt::seq::WriteToBinder class batt::PrependBufferSource","title":"Classes"},{"location":"_autogen/Files/buffer__source_8hpp/#defines","text":"Name BATTERIES_ASYNC_BUFFER_SOURCE_HPP","title":"Defines"},{"location":"_autogen/Files/buffer__source_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/buffer__source_8hpp/#batteries_async_buffer_source_hpp","text":"1 #define BATTERIES_ASYNC_BUFFER_SOURCE_HPP()","title":"BATTERIES_ASYNC_BUFFER_SOURCE_HPP"},{"location":"_autogen/Files/buffer__source_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_BUFFER_SOURCE_HPP #define BATTERIES_ASYNC_BUFFER_SOURCE_HPP #include <batteries/config.hpp> // #include <batteries/async/io_result.hpp> #include <batteries/async/task_decl.hpp> #include <batteries/seq/collect_vec.hpp> #include <batteries/seq/consume.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/prepend.hpp> #include <batteries/seq/print_out.hpp> #include <batteries/seq/skip_n.hpp> #include <batteries/seq/take_n.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/cpu_align.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <batteries/type_erasure.hpp> #include <batteries/utility.hpp> #include <boost/asio/buffer.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - namespace detail { template < typename T > inline std :: false_type has_const_buffer_sequence_requirements_impl (...) { return {}; } template < typename T , typename ElementT = decltype ( * boost :: asio :: buffer_sequence_begin ( std :: declval < T > ())), // typename = std :: enable_if_t < // std :: is_same_v < decltype ( boost :: asio :: buffer_sequence_begin ( std :: declval < T > ())), // decltype ( boost :: asio :: buffer_sequence_end ( std :: declval < T > ())) > && // std :: is_convertible_v < ElementT , boost :: asio :: const_buffer >>> inline std :: true_type has_const_buffer_sequence_requirements_impl ( std :: decay_t < T >* ) { return {}; } } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > using HasConstBufferSequenceRequirements = decltype ( detail :: has_const_buffer_sequence_requirements_impl < T > ( nullptr )); template < typename T > inline constexpr bool has_const_buffer_sequence_requirements ( StaticType < T > = {}) { return HasConstBufferSequenceRequirements < T > {}; } template < typename T > using EnableIfConstBufferSequence = std :: enable_if_t < has_const_buffer_sequence_requirements < T > () > ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - namespace detail { template < typename T > inline std :: false_type has_buffer_source_requirements_impl (...) { return {}; } template < typename T , typename = std :: enable_if_t < // std :: is_same_v < decltype ( std :: declval < T > (). size ()), usize > && // std :: is_same_v < decltype ( std :: declval < T > (). consume ( std :: declval < i64 > ())), void > && // std :: is_same_v < decltype ( std :: declval < T > (). close_for_read ()), void > && HasConstBufferSequenceRequirements < decltype ( * ( std :: declval < T > (). fetch_at_least ( std :: declval < i64 > ()))) > {} >> inline std :: true_type has_buffer_source_requirements_impl ( std :: decay_t < T >* ) { return {}; } } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > using HasBufferSourceRequirements = decltype ( detail :: has_buffer_source_requirements_impl < T > ( nullptr )); template < typename T > inline constexpr bool has_buffer_source_requirements ( StaticType < T > = {}) { return HasBufferSourceRequirements < T > {}; } template < typename T > using EnableIfBufferSource = std :: enable_if_t < has_buffer_source_requirements < T > () > ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A type-erased no-copy input stream. // // Instead of a traditional (copying) input stream, which copies data into caller-supplied buffers, // BufferSource provides the `fetch_at_least` operation, which returns one or more pre-populated data buffers // owned by the BufferSource. The caller is guaranteed that these buffers remain valid until the next // non-const member function is invoked on the BufferSource. // // To make dealing with byte streams easier, BufferSource values can be modified/transformed via a select // subset of `batt::seq` operators: // // - seq::take_n(byte_count) // - seq::skip_n(byte_count) // - seq::prepend(const_buffer_sequence) // - seq::for_each(fn) (fn takes ConstBuffer) // - seq::collect_vec() => std::vector<char> // - seq::print_out(std::ostream) // - seq::consume() // // In addition, a new operator is defined for BufferSource, seq::write_to(AsyncWriteStream): // // ```c++ // batt::BufferSource data_to_send; // boost::asio::ip::tcp::socket dst_stream; // // // Write all the data to the stream. // // // StatusOr<usize> result = data_to_send | batt::seq::write_to(dst_stream); // ``` // class BufferSource { public : BufferSource () = default ; template < typename T , typename = EnableIfNoShadow < BufferSource , T &&> , typename = EnableIfBufferSource < UnwrapRefType < T >> , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , T >>> /*implicit*/ BufferSource ( T && obj ) noexcept ; // Returns true iff this object contains a valid BufferSource impl. // explicit operator bool () const ; // Release the type-erased impl object; post-condition: `bool{*this} == false`. // void clear (); // The current number of bytes available as consumable data. This should be used as an optimization hint // only; the next call to `fetch_*` may return more bytes than the last returned value of size. // Specifically, callers should not count on `size()` returning 0 being an indication that the next call // to `fetch_at_least` will block. // usize size () const ; // Returns a ConstBufferSequence containing at least `min_count` bytes of data. // // This method may block the current task if there isn't enough data available to satisfy // the request (i.e., if `this->size() < min_count`). // StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ); // Consume the specified number of bytes from the front of the stream so that future calls to // `fetch_at_least` will not return the same data. // void consume ( i64 count ); // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be read/consumed. // void close_for_read (); private : class AbstractBufferSource ; template < typename T > class BufferSourceImpl ; //+++++++++++-+-+--+----- --- -- - - - - TypeErasedStorage < AbstractBufferSource , BufferSourceImpl > impl_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Adapts a Seq of Item = ConstBuffer to a BufferSource impl, allowing it to be wrapped via the BufferSource // class. // template < typename Seq > class SeqBufferSource { public : using Item = ConstBuffer ; static_assert ( std :: is_convertible_v < SeqItem < Seq > , ConstBuffer > , \"\" ); StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) { usize active_size = boost :: asio :: buffer_size ( this -> active_buffers_ ); while ( active_size < min_count ) { Optional < ConstBuffer > next_buffer = this -> seq_ . next (); if ( next_buffer == None ) { return { StatusCode :: kInvalidArgument }; } active_size += next_buffer -> size (); this -> active_buffers_ . emplace_back ( std :: move ( * next_buffer )); } return this -> active_buffers_ ; } void consume ( i64 count ) { consume_buffers ( this -> active_buffers_ , count ); } private : Seq seq_ ; SmallVec < ConstBuffer , 2 > active_buffers_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::take_n(byte_count) // template < typename Src > class TakeNSource { public : explicit TakeNSource ( Src && src , usize limit ) noexcept : limit_ { limit }, src_ { BATT_FORWARD ( src )} { } usize size () const { return std :: min ( this -> limit_ , this -> src_ . size ()); } StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) { StatusOr < SmallVec < ConstBuffer , 2 >> buffers = this -> src_ . fetch_at_least ( min_count ); BATT_REQUIRE_OK ( buffers ); usize n_fetched = boost :: asio :: buffer_size ( * buffers ); // Trim data from the end of the fetched range until we are under our limit. // while ( n_fetched > this -> limit_ && ! buffers -> empty ()) { ConstBuffer & last_buffer = buffers -> back (); const usize extra_bytes = n_fetched - this -> limit_ ; if ( last_buffer . size () <= extra_bytes ) { n_fetched -= last_buffer . size (); buffers -> pop_back (); } else { n_fetched -= extra_bytes ; last_buffer = ConstBuffer { last_buffer . data (), last_buffer . size () - extra_bytes }; } } return buffers ; } void consume ( i64 count ) { const usize n_to_consume = std :: min ( BATT_CHECKED_CAST ( usize , count ), this -> limit_ ); this -> src_ . consume ( BATT_CHECKED_CAST ( usize , n_to_consume )); this -> limit_ -= n_to_consume ; } void close_for_read () { this -> limit_ = 0 ; } private : usize limit_ ; Src src_ ; }; template < typename Src , typename = EnableIfBufferSource < Src >> TakeNSource < Src > operator | ( Src && src , seq :: TakeNBinder binder ) { return TakeNSource < Src > { BATT_FORWARD ( src ), binder . n }; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::skip_n(byte_count) // template < typename Src , typename = EnableIfBufferSource < Src >> void operator | ( Src && src , SkipNBinder binder ) { // TODO [tastolfi 2022-03-23] BATT_PANIC () << \"TODO [tastolfi 2022-03-28] implement me!\" ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::filter(StatusOr<ConstBufferSequence>(ConstBufferSequence)) // template < typename Src , typename MapFn > class FilterBufferSource { public : // TODO [tastolfi 2022-06-22] private : }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::map(void(BufferSource& src, BufferSink& dst)) // template < typename Src , typename MapFn > class MapBufferSource { public : // TODO [tastolfi 2022-06-22] private : }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::for_each() // template < typename Src , typename Fn , typename = EnableIfBufferSource < Src >> inline StatusOr < seq :: LoopControl > operator | ( Src && src , seq :: ForEachBinder < Fn >&& binder ) { for (;;) { auto fetched = src . fetch_at_least ( 1 ); if ( fetched . status () == StatusCode :: kEndOfStream ) { break ; } BATT_REQUIRE_OK ( fetched ); usize n_to_consume = 0 ; for ( const ConstBuffer & buffer : * fetched ) { n_to_consume += buffer . size (); if ( BATT_HINT_FALSE ( seq :: run_loop_fn ( binder . fn , buffer ) == seq :: kBreak )) { return seq :: kBreak ; } } if ( n_to_consume == 0 ) { break ; } src . consume ( n_to_consume ); } return seq :: kContinue ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::collect_vec() // template < typename Src , typename = EnableIfBufferSource < Src >> inline StatusOr < std :: vector < char >> operator | ( Src && src , seq :: CollectVec ) { std :: vector < char > bytes ; StatusOr < seq :: LoopControl > result = BATT_FORWARD ( src ) | seq :: for_each ([ & bytes ]( const ConstBuffer & buffer ) { const char * data_begin = static_cast < const char *> ( buffer . data ()); const char * data_end = data_begin + buffer . size (); bytes . insert ( bytes . end (), data_begin , data_end ); }); BATT_REQUIRE_OK ( result ); return bytes ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::print_out(out) // template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: PrintOut p ) { return ( BATT_FORWARD ( src ) | seq :: for_each ([ & ]( const ConstBuffer & buffer ) { p . out . write ( static_cast < const char *> ( buffer . data ()), buffer . size ()); })) . status (); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::consume() template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: Consume ) { StatusOr < seq :: LoopControl > result = BATT_FORWARD ( src ) | seq :: for_each ([]( auto && ...) noexcept { // nom, nom, nom... }); BATT_REQUIRE_OK ( result ); BATT_CHECK_EQ ( * result , seq :: kContinue ); return OkStatus (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // namespace seq { template < typename AsyncWriteStream > struct WriteToBinder { AsyncWriteStream dst ; }; template < typename AsyncWriteStream > inline auto write_to ( AsyncWriteStream && dst ) { return WriteToBinder < AsyncWriteStream > { BATT_FORWARD ( dst )}; } } // namespace seq //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::write_to(async_write_stream) // template < typename Src , typename AsyncWriteStream , typename = EnableIfBufferSource < Src >> StatusOr < usize > operator | ( Src && src , seq :: WriteToBinder < AsyncWriteStream >&& binder ) { usize bytes_transferred = 0 ; for (;;) { auto fetched = src . fetch_at_least ( 1 ); if ( fetched . status () == StatusCode :: kEndOfStream ) { break ; } BATT_REQUIRE_OK ( fetched ); IOResult < usize > bytes_written = Task :: await_write_some ( binder . dst , * fetched ); BATT_REQUIRE_OK ( bytes_written ); bytes_transferred += * bytes_written ; src . consume ( * bytes_written ); } return bytes_transferred ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // BufferSource | seq::prepend(buffers) // template < typename Src , typename ConstBufferSequence > class PrependBufferSource { public : using BufferIter = std :: decay_t < decltype ( boost :: asio :: buffer_sequence_begin ( std :: declval < ConstBufferSequence > ())) > ; explicit PrependBufferSource ( ConstBufferSequence && buffers , Src && rest ) noexcept : first_ { BATT_FORWARD ( buffers )} , first_begin_ { boost :: asio :: buffer_sequence_begin ( this -> first_ )} , first_end_ { boost :: asio :: buffer_sequence_end ( this -> first_ )} , first_offset_ { 0 } , first_size_ { boost :: asio :: buffer_size ( this -> first_ )} , rest_ { BATT_FORWARD ( rest )} { if ( this -> first_size_ == 0 ) { this -> first_begin_ = this -> first_end_ ; } } usize size () const { return this -> first_size_ + this -> rest_ . size (); } StatusOr < SmallVec < ConstBuffer , 3 >> fetch_at_least ( i64 min_count_i ) { const usize min_count_z = BATT_CHECKED_CAST ( usize , min_count_i ); SmallVec < ConstBuffer , 3 > buffer ( this -> first_begin_ , this -> first_end_ ); if ( ! buffer . empty ()) { buffer . front () += first_offset_ ; } const usize rest_min_count = min_count_z - std :: min ( this -> first_size_ , min_count_z ); auto fetched_from_rest = this -> rest_ . fetch_at_least ( rest_min_count ); if ( buffer . empty () || fetched_from_rest . status () != StatusCode :: kEndOfStream ) { BATT_REQUIRE_OK ( fetched_from_rest ); } if ( fetched_from_rest . ok ()) { buffer . insert ( buffer . end (), // boost :: asio :: buffer_sequence_begin ( * fetched_from_rest ), boost :: asio :: buffer_sequence_end ( * fetched_from_rest )); } return buffer ; } void consume ( i64 count_i ) { const usize count_z = BATT_CHECKED_CAST ( usize , count_i ); const usize consume_from_first = std :: min ( this -> first_size_ , count_z ); const usize consume_from_rest = count_z - consume_from_first ; std :: tie ( this -> first_begin_ , this -> first_offset_ ) = consume_buffers_iter ( std :: make_pair ( this -> first_begin_ , this -> first_offset_ ), this -> first_end_ , consume_from_first ); this -> first_size_ -= consume_from_first ; if ( consume_from_rest > 0 ) { this -> rest_ . consume ( consume_from_rest ); } } void close_for_read () { this -> first_begin_ = this -> first_end_ ; this -> first_size_ = 0 ; this -> rest_ . close_for_read (); } private : ConstBufferSequence first_ ; BufferIter first_begin_ ; BufferIter first_end_ ; usize first_offset_ ; usize first_size_ ; Src rest_ ; }; template < typename Src , typename ConstBufferSequence , // typename = EnableIfBufferSource < Src > , // typename = EnableIfConstBufferSequence < ConstBufferSequence >> inline auto operator | ( Src && src , seq :: PrependBinder < ConstBufferSequence >&& binder ) { return PrependBufferSource < Src , ConstBufferSequence > { BATT_FORWARD ( binder . item ), BATT_FORWARD ( src )}; } } // namespace batt #endif // BATTERIES_ASYNC_BUFFER_SOURCE_HPP #include <batteries/config.hpp> #if BATT_HEADER_ONLY #include <batteries/async/buffer_source_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/buffer__source__impl_8hpp/","text":"batteries/async/buffer_source_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::BufferSource::AbstractBufferSource Defines \ud83d\udd17 Name BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP #define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/utility.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class BufferSource :: AbstractBufferSource : public AbstractValue < AbstractBufferSource > { public : virtual usize size () const = 0 ; virtual StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) = 0 ; virtual void consume ( i64 count ) = 0 ; virtual void close_for_read () = 0 ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > class BufferSource :: BufferSourceImpl : public AbstractValueImpl < BufferSource :: AbstractBufferSource , BufferSource :: BufferSourceImpl , T > { public : using AbstractValueImpl < BufferSource :: AbstractBufferSource , BufferSource :: BufferSourceImpl , T >:: AbstractValueImpl ; //+++++++++++-+-+--+----- --- -- - - - - // AbstractBufferSource interface usize size () const override { return unwrap_ref ( this -> obj_ ). size (); } StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) override { return unwrap_ref ( this -> obj_ ). fetch_at_least ( min_count ); } void consume ( i64 count ) override { unwrap_ref ( this -> obj_ ). consume ( count ); } void close_for_read () override { unwrap_ref ( this -> obj_ ). close_for_read (); } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T , typename /*= EnableIfNoShadow<BufferSource, T&&>*/ , typename /*= EnableIfBufferSource<UnwrapRefType<T>>*/ , typename /*= std::enable_if_t<std::is_same_v<std::decay_t<T>, T>>*/ > BATT_INLINE_IMPL /*implicit*/ BufferSource :: BufferSource ( T && obj ) noexcept : impl_ { StaticType < T > {}, BATT_FORWARD ( obj )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL BufferSource :: operator bool () const { return bool { this -> impl_ }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize BufferSource :: size () const { return this -> impl_ -> size (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < ConstBuffer , 2 >> BufferSource :: fetch_at_least ( i64 min_count ) { return this -> impl_ -> fetch_at_least ( min_count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void BufferSource :: consume ( i64 count ) { return this -> impl_ -> consume ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void BufferSource :: close_for_read () { return this -> impl_ -> close_for_read (); } } // namespace batt #endif // BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/buffer_source_impl.hpp"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#classes","text":"Name class batt::BufferSource::AbstractBufferSource","title":"Classes"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#batteries_async_buffer_source_impl_hpp","text":"1 #define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP()","title":"BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP #define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/utility.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class BufferSource :: AbstractBufferSource : public AbstractValue < AbstractBufferSource > { public : virtual usize size () const = 0 ; virtual StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) = 0 ; virtual void consume ( i64 count ) = 0 ; virtual void close_for_read () = 0 ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > class BufferSource :: BufferSourceImpl : public AbstractValueImpl < BufferSource :: AbstractBufferSource , BufferSource :: BufferSourceImpl , T > { public : using AbstractValueImpl < BufferSource :: AbstractBufferSource , BufferSource :: BufferSourceImpl , T >:: AbstractValueImpl ; //+++++++++++-+-+--+----- --- -- - - - - // AbstractBufferSource interface usize size () const override { return unwrap_ref ( this -> obj_ ). size (); } StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) override { return unwrap_ref ( this -> obj_ ). fetch_at_least ( min_count ); } void consume ( i64 count ) override { unwrap_ref ( this -> obj_ ). consume ( count ); } void close_for_read () override { unwrap_ref ( this -> obj_ ). close_for_read (); } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T , typename /*= EnableIfNoShadow<BufferSource, T&&>*/ , typename /*= EnableIfBufferSource<UnwrapRefType<T>>*/ , typename /*= std::enable_if_t<std::is_same_v<std::decay_t<T>, T>>*/ > BATT_INLINE_IMPL /*implicit*/ BufferSource :: BufferSource ( T && obj ) noexcept : impl_ { StaticType < T > {}, BATT_FORWARD ( obj )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL BufferSource :: operator bool () const { return bool { this -> impl_ }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize BufferSource :: size () const { return this -> impl_ -> size (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < ConstBuffer , 2 >> BufferSource :: fetch_at_least ( i64 min_count ) { return this -> impl_ -> fetch_at_least ( min_count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void BufferSource :: consume ( i64 count ) { return this -> impl_ -> consume ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void BufferSource :: close_for_read () { return this -> impl_ -> close_for_read (); } } // namespace batt #endif // BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/cache__next_8hpp/","text":"batteries/seq/cache_next.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::CacheNext struct batt::seq::CacheNextBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_CACHE_NEXT_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_CACHE_NEXT_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_CACHE_NEXT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_CACHE_NEXT_HPP #define BATTERIES_SEQ_CACHE_NEXT_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <utility> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // cache_next() - Adapts any sequence to cache the next item so that repeated // calls to peek will be fast. // template < typename Seq > class CacheNext { public : using Item = SeqItem < Seq > ; explicit CacheNext ( Seq && seq ) noexcept : seq_ ( BATT_FORWARD ( seq )) { } Optional < Item > peek () { if ( ! cached_ ) { cached_ = seq_ . next (); } return * cached_ ; } Optional < Item > next () { Optional < Item > item = [ & ] { if ( cached_ ) { return std :: move ( * cached_ ); } return seq_ . next (); }(); cached_ = None ; return item ; } private : Seq seq_ ; Optional < Optional < Item >> cached_ ; }; struct CacheNextBinder { }; inline CacheNextBinder cache_next () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , CacheNextBinder ) { return CacheNext < Seq > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_CACHE_NEXT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/cache_next.hpp"},{"location":"_autogen/Files/cache__next_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/cache__next_8hpp/#classes","text":"Name class batt::seq::CacheNext struct batt::seq::CacheNextBinder","title":"Classes"},{"location":"_autogen/Files/cache__next_8hpp/#defines","text":"Name BATTERIES_SEQ_CACHE_NEXT_HPP","title":"Defines"},{"location":"_autogen/Files/cache__next_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/cache__next_8hpp/#batteries_seq_cache_next_hpp","text":"1 #define BATTERIES_SEQ_CACHE_NEXT_HPP()","title":"BATTERIES_SEQ_CACHE_NEXT_HPP"},{"location":"_autogen/Files/cache__next_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_CACHE_NEXT_HPP #define BATTERIES_SEQ_CACHE_NEXT_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <utility> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // cache_next() - Adapts any sequence to cache the next item so that repeated // calls to peek will be fast. // template < typename Seq > class CacheNext { public : using Item = SeqItem < Seq > ; explicit CacheNext ( Seq && seq ) noexcept : seq_ ( BATT_FORWARD ( seq )) { } Optional < Item > peek () { if ( ! cached_ ) { cached_ = seq_ . next (); } return * cached_ ; } Optional < Item > next () { Optional < Item > item = [ & ] { if ( cached_ ) { return std :: move ( * cached_ ); } return seq_ . next (); }(); cached_ = None ; return item ; } private : Seq seq_ ; Optional < Optional < Item >> cached_ ; }; struct CacheNextBinder { }; inline CacheNextBinder cache_next () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , CacheNextBinder ) { return CacheNext < Seq > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_CACHE_NEXT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/case__of_8hpp/","text":"batteries/case_of.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::detail::FirstMatchImpl struct batt::detail::FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > > struct batt::detail::FirstMatchImpl< std::tuple<>, std::tuple< Args... > > struct batt::detail::VisitorResult struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > && > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const && > class batt::CaseOfVisitor Defines \ud83d\udd17 Name BATT_SPECIALIZE_VISITOR_RESULT (ref_qualifier) BATT_CASE_OF_VISITOR_INVOKE (qualifier) Macro Documentation \ud83d\udd17 BATT_SPECIALIZE_VISITOR_RESULT \ud83d\udd17 1 #define BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier) BATT_CASE_OF_VISITOR_INVOKE \ud83d\udd17 1 #define BATT_CASE_OF_VISITOR_INVOKE(qualifier) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <tuple> #include <type_traits> #include <variant> namespace batt { // ============================================================================= namespace detail { template < typename CaseTuple , typename ArgsTuple > struct FirstMatchImpl ; template < typename CaseFirst , typename ... CaseRest , typename ... Args > struct FirstMatchImpl < std :: tuple < CaseFirst , CaseRest ... > , std :: tuple < Args ... >> : std :: conditional_t < IsCallable < CaseFirst , Args && ... > {}, // std :: integral_constant < usize , 0 > , // std :: integral_constant < usize , 1 + FirstMatchImpl < std :: tuple < CaseRest ... > , std :: tuple < Args ... >> {} > // > { template < typename Cases > decltype ( auto ) operator ()( Cases && cases , Args && ... args ) const { static_assert ( FirstMatchImpl :: value < std :: tuple_size_v < std :: decay_t < decltype ( cases ) >> , \"Unhandled case in case_of\" ); return std :: get < FirstMatchImpl :: value > ( BATT_FORWARD ( cases ))( BATT_FORWARD ( args )...); } }; template < typename ... Args > struct FirstMatchImpl < std :: tuple <> , std :: tuple < Args ... >> : std :: integral_constant < usize , 0 > { }; // The result type of a visitor is defined to be the std::common_type_t<...> // over the individual results of applying the visitor to a given variant // reference expression. We must propagate const-ness and value category // from the variant to the case expression while computing this type. // template < typename Visitor , typename Variant > struct VisitorResult ; // This must be instantiated for each possible value category: // std::variant<Ts...>& // std::variant<Ts...> const& // std::variant<Ts...>&& // std::variant<Ts...> const&& // #define BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier) \\ template <typename Visitor, typename... Ts> \\ struct VisitorResult<Visitor, std::variant<Ts...> ref_qualifier> { \\ using type = \\ std::common_type_t<decltype(std::declval<Visitor>()(std::declval<Ts ref_qualifier>()))...>; \\ } BATT_SPECIALIZE_VISITOR_RESULT (); BATT_SPECIALIZE_VISITOR_RESULT ( const ); BATT_SPECIALIZE_VISITOR_RESULT ( & ); BATT_SPECIALIZE_VISITOR_RESULT ( const & ); BATT_SPECIALIZE_VISITOR_RESULT ( && ); BATT_SPECIALIZE_VISITOR_RESULT ( const && ); template < typename Visitor , typename VariantArg > using VisitorResultT = typename VisitorResult < Visitor , VariantArg >:: type ; #undef BATT_SPECIALIZE_VISITOR_RESULT } // namespace detail template < typename ... Cases > class CaseOfVisitor { public : using CaseTuple = std :: tuple < Cases ... > ; template < typename ... CaseArgs > explicit CaseOfVisitor ( CaseArgs && ... case_args ) noexcept : cases_ { BATT_FORWARD ( case_args )...} { } template < typename ... Args > using FirstMatch = detail :: FirstMatchImpl < CaseTuple , std :: tuple < Args ... >> ; #define BATT_CASE_OF_VISITOR_INVOKE(qualifier) \\ template <typename... Args> \\ decltype(auto) operator()(Args&&... args) qualifier \\ { \\ return FirstMatch<Args...>{}(cases_, BATT_FORWARD(args)...); \\ } BATT_CASE_OF_VISITOR_INVOKE ( & ) BATT_CASE_OF_VISITOR_INVOKE ( && ) BATT_CASE_OF_VISITOR_INVOKE ( const & ) BATT_CASE_OF_VISITOR_INVOKE ( const && ) #undef BATT_CASE_OF_VISITOR_INVOKE private : CaseTuple cases_ ; }; template < typename ... Cases > CaseOfVisitor < Cases && ... > make_case_of_visitor ( Cases && ... cases ) { return CaseOfVisitor < Cases && ... > { BATT_FORWARD ( cases )...}; } // ============================================================================= template < typename VarType , typename ... Cases > decltype ( auto ) case_of ( VarType && v , Cases && ... cases ) { static_assert ( IsVariant < std :: decay_t < VarType >> {}, \"case_of must be applied to a variant.\" ); using Visitor = CaseOfVisitor < Cases && ... > ; using Result = detail :: VisitorResultT < Visitor , VarType > ; return std :: visit ( [ & ]( auto && val ) -> Result { return Visitor { BATT_FORWARD ( cases )...}( BATT_FORWARD ( val )); }, BATT_FORWARD ( v )); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Returns true iff the current case of the passed variant is equal to the template parameter `T`. // template < typename T , typename Var > bool is_case ( Var && v ) { return case_of ( std :: forward < Var > ( v ), // []( const std :: decay_t < T >& ) { return true ; }, []( const auto & ) { return false ; }); } } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/case_of.hpp"},{"location":"_autogen/Files/case__of_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/case__of_8hpp/#classes","text":"Name struct batt::detail::FirstMatchImpl struct batt::detail::FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > > struct batt::detail::FirstMatchImpl< std::tuple<>, std::tuple< Args... > > struct batt::detail::VisitorResult struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > && > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const && > class batt::CaseOfVisitor","title":"Classes"},{"location":"_autogen/Files/case__of_8hpp/#defines","text":"Name BATT_SPECIALIZE_VISITOR_RESULT (ref_qualifier) BATT_CASE_OF_VISITOR_INVOKE (qualifier)","title":"Defines"},{"location":"_autogen/Files/case__of_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/case__of_8hpp/#batt_specialize_visitor_result","text":"1 #define BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier)","title":"BATT_SPECIALIZE_VISITOR_RESULT"},{"location":"_autogen/Files/case__of_8hpp/#batt_case_of_visitor_invoke","text":"1 #define BATT_CASE_OF_VISITOR_INVOKE(qualifier)","title":"BATT_CASE_OF_VISITOR_INVOKE"},{"location":"_autogen/Files/case__of_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <tuple> #include <type_traits> #include <variant> namespace batt { // ============================================================================= namespace detail { template < typename CaseTuple , typename ArgsTuple > struct FirstMatchImpl ; template < typename CaseFirst , typename ... CaseRest , typename ... Args > struct FirstMatchImpl < std :: tuple < CaseFirst , CaseRest ... > , std :: tuple < Args ... >> : std :: conditional_t < IsCallable < CaseFirst , Args && ... > {}, // std :: integral_constant < usize , 0 > , // std :: integral_constant < usize , 1 + FirstMatchImpl < std :: tuple < CaseRest ... > , std :: tuple < Args ... >> {} > // > { template < typename Cases > decltype ( auto ) operator ()( Cases && cases , Args && ... args ) const { static_assert ( FirstMatchImpl :: value < std :: tuple_size_v < std :: decay_t < decltype ( cases ) >> , \"Unhandled case in case_of\" ); return std :: get < FirstMatchImpl :: value > ( BATT_FORWARD ( cases ))( BATT_FORWARD ( args )...); } }; template < typename ... Args > struct FirstMatchImpl < std :: tuple <> , std :: tuple < Args ... >> : std :: integral_constant < usize , 0 > { }; // The result type of a visitor is defined to be the std::common_type_t<...> // over the individual results of applying the visitor to a given variant // reference expression. We must propagate const-ness and value category // from the variant to the case expression while computing this type. // template < typename Visitor , typename Variant > struct VisitorResult ; // This must be instantiated for each possible value category: // std::variant<Ts...>& // std::variant<Ts...> const& // std::variant<Ts...>&& // std::variant<Ts...> const&& // #define BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier) \\ template <typename Visitor, typename... Ts> \\ struct VisitorResult<Visitor, std::variant<Ts...> ref_qualifier> { \\ using type = \\ std::common_type_t<decltype(std::declval<Visitor>()(std::declval<Ts ref_qualifier>()))...>; \\ } BATT_SPECIALIZE_VISITOR_RESULT (); BATT_SPECIALIZE_VISITOR_RESULT ( const ); BATT_SPECIALIZE_VISITOR_RESULT ( & ); BATT_SPECIALIZE_VISITOR_RESULT ( const & ); BATT_SPECIALIZE_VISITOR_RESULT ( && ); BATT_SPECIALIZE_VISITOR_RESULT ( const && ); template < typename Visitor , typename VariantArg > using VisitorResultT = typename VisitorResult < Visitor , VariantArg >:: type ; #undef BATT_SPECIALIZE_VISITOR_RESULT } // namespace detail template < typename ... Cases > class CaseOfVisitor { public : using CaseTuple = std :: tuple < Cases ... > ; template < typename ... CaseArgs > explicit CaseOfVisitor ( CaseArgs && ... case_args ) noexcept : cases_ { BATT_FORWARD ( case_args )...} { } template < typename ... Args > using FirstMatch = detail :: FirstMatchImpl < CaseTuple , std :: tuple < Args ... >> ; #define BATT_CASE_OF_VISITOR_INVOKE(qualifier) \\ template <typename... Args> \\ decltype(auto) operator()(Args&&... args) qualifier \\ { \\ return FirstMatch<Args...>{}(cases_, BATT_FORWARD(args)...); \\ } BATT_CASE_OF_VISITOR_INVOKE ( & ) BATT_CASE_OF_VISITOR_INVOKE ( && ) BATT_CASE_OF_VISITOR_INVOKE ( const & ) BATT_CASE_OF_VISITOR_INVOKE ( const && ) #undef BATT_CASE_OF_VISITOR_INVOKE private : CaseTuple cases_ ; }; template < typename ... Cases > CaseOfVisitor < Cases && ... > make_case_of_visitor ( Cases && ... cases ) { return CaseOfVisitor < Cases && ... > { BATT_FORWARD ( cases )...}; } // ============================================================================= template < typename VarType , typename ... Cases > decltype ( auto ) case_of ( VarType && v , Cases && ... cases ) { static_assert ( IsVariant < std :: decay_t < VarType >> {}, \"case_of must be applied to a variant.\" ); using Visitor = CaseOfVisitor < Cases && ... > ; using Result = detail :: VisitorResultT < Visitor , VarType > ; return std :: visit ( [ & ]( auto && val ) -> Result { return Visitor { BATT_FORWARD ( cases )...}( BATT_FORWARD ( val )); }, BATT_FORWARD ( v )); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Returns true iff the current case of the passed variant is equal to the template parameter `T`. // template < typename T , typename Var > bool is_case ( Var && v ) { return case_of ( std :: forward < Var > ( v ), // []( const std :: decay_t < T >& ) { return true ; }, []( const auto & ) { return false ; }); } } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/chain_8hpp/","text":"batteries/seq/chain.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Chain struct batt::seq::ChainBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_CHAIN_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_CHAIN_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_CHAIN_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_CHAIN_HPP #define BATTERIES_SEQ_CHAIN_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // chain // template < typename Seq1 , typename Seq2 > class Chain { public : using Item = std :: common_type_t < SeqItem < Seq1 > , SeqItem < Seq2 >> ; explicit Chain ( Seq1 && seq1 , Seq2 && seq2 ) noexcept : seq1_ ( BATT_FORWARD ( seq1 )), seq2_ ( BATT_FORWARD ( seq2 )) { } Optional < Item > peek () { if ( seq1_ ) { return seq1_ -> peek (); } return seq2_ . peek (); } Optional < Item > next () { if ( seq1_ ) { auto item = seq1_ -> next (); if ( item ) { return item ; } seq1_ = None ; } return seq2_ . next (); } private : Optional < Seq1 > seq1_ ; Seq2 seq2_ ; }; template < typename Seq2 > struct ChainBinder { Seq2 seq2 ; }; template < typename Seq2 > ChainBinder < Seq2 > chain ( Seq2 && seq2 ) { return { BATT_FORWARD ( seq2 )}; } template < typename Seq1 , typename Seq2 > [[ nodiscard ]] Chain < Seq1 , Seq2 > operator | ( Seq1 && seq1 , ChainBinder < Seq2 >&& binder ) { static_assert ( std :: is_same_v < Seq1 , std :: decay_t < Seq1 >> , \"Concatenated sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Seq2 , std :: decay_t < Seq2 >> , \"Concatenated sequences may not be captured implicitly by reference.\" ); return Chain < Seq1 , Seq2 > { BATT_FORWARD ( seq1 ), BATT_FORWARD ( binder . seq2 )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_CHAIN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/chain.hpp"},{"location":"_autogen/Files/chain_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/chain_8hpp/#classes","text":"Name class batt::seq::Chain struct batt::seq::ChainBinder","title":"Classes"},{"location":"_autogen/Files/chain_8hpp/#defines","text":"Name BATTERIES_SEQ_CHAIN_HPP","title":"Defines"},{"location":"_autogen/Files/chain_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/chain_8hpp/#batteries_seq_chain_hpp","text":"1 #define BATTERIES_SEQ_CHAIN_HPP()","title":"BATTERIES_SEQ_CHAIN_HPP"},{"location":"_autogen/Files/chain_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_CHAIN_HPP #define BATTERIES_SEQ_CHAIN_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // chain // template < typename Seq1 , typename Seq2 > class Chain { public : using Item = std :: common_type_t < SeqItem < Seq1 > , SeqItem < Seq2 >> ; explicit Chain ( Seq1 && seq1 , Seq2 && seq2 ) noexcept : seq1_ ( BATT_FORWARD ( seq1 )), seq2_ ( BATT_FORWARD ( seq2 )) { } Optional < Item > peek () { if ( seq1_ ) { return seq1_ -> peek (); } return seq2_ . peek (); } Optional < Item > next () { if ( seq1_ ) { auto item = seq1_ -> next (); if ( item ) { return item ; } seq1_ = None ; } return seq2_ . next (); } private : Optional < Seq1 > seq1_ ; Seq2 seq2_ ; }; template < typename Seq2 > struct ChainBinder { Seq2 seq2 ; }; template < typename Seq2 > ChainBinder < Seq2 > chain ( Seq2 && seq2 ) { return { BATT_FORWARD ( seq2 )}; } template < typename Seq1 , typename Seq2 > [[ nodiscard ]] Chain < Seq1 , Seq2 > operator | ( Seq1 && seq1 , ChainBinder < Seq2 >&& binder ) { static_assert ( std :: is_same_v < Seq1 , std :: decay_t < Seq1 >> , \"Concatenated sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Seq2 , std :: decay_t < Seq2 >> , \"Concatenated sequences may not be captured implicitly by reference.\" ); return Chain < Seq1 , Seq2 > { BATT_FORWARD ( seq1 ), BATT_FORWARD ( binder . seq2 )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_CHAIN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/channel_8hpp/","text":"batteries/async/channel.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Channel Defines \ud83d\udd17 Name BATTERIES_ASYNC_CHANNEL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_CHANNEL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_CHANNEL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_CHANNEL_HPP #define BATTERIES_ASYNC_CHANNEL_HPP #include <batteries/config.hpp> // #include <batteries/async/watch.hpp> #include <batteries/optional.hpp> #include <batteries/status.hpp> namespace batt { // A Channel<T> is a one-way, unbuffered, SPSC (single-producer, single consumer) // communication/synchronization primitive. // template < typename T > class Channel { public : Channel () { } Channel ( const Channel & ) = delete ; Channel & operator = ( const Channel & ) = delete ; ~ Channel () { this -> close_for_write (); this -> read_count_ . await_equal ( this -> write_count_ . get_value ()). IgnoreError (); } //+++++++++++-+-+--+----- --- -- - - - - // Returns true iff there is currently an object available on the channel. // bool is_active () const ; //+++++++++++-+-+--+----- --- -- - - - - // Wait for an object to be written to the Channel, then return a reference to that object. The referred // object will stay valid until `consume()` is called. // StatusOr < T &> read (); // Release the last value read on the Channel. Panic if `consume()` is called without a prior successful // call to `read()` (indicating that `this->is_active()` is true). // void consume (); // Unblock all ongoing calls to write/async_write and cause all future calls to fail with closed error // status. // void close_for_read (); //+++++++++++-+-+--+----- --- -- - - - - // Write a value to the Channel. Panic if there is currently an ongoing write (single-producer). // // The passed handler is invoked once the value is consumed via `read`/`consume`. // template < typename Handler = void ( Status ) > void async_write ( T & value , Handler && handler ); // Blocking (Task::await) version of `async_write`. This function will not return until the passed value // has been consumed. The value is guaranteed not to be copied; the consumer will see the same exact // object passed into write. // Status write ( T & value ); // Unblock all ongoing calls to read and cause all future calls to fail with closed error status. // void close_for_write (); private : //+++++++++++-+-+--+----- --- -- - - - - Watch < i32 > read_count_ { 0 }; Watch < i32 > write_count_ { 0 }; T * value_ = nullptr ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Handler > void Channel < T >:: async_write ( T & value , Handler && handler ) { BATT_CHECK ( ! this -> is_active ()); if ( this -> write_count_ . is_closed ()) { handler ({ StatusCode :: kClosed }); return ; } this -> value_ = & value ; const i32 last_seen = this -> read_count_ . get_value (); const i32 target = this -> write_count_ . fetch_add ( 1 ) + 1 ; BATT_CHECK_EQ ( last_seen + 1 , target ); this -> read_count_ . async_wait ( last_seen , bind_handler ( BATT_FORWARD ( handler ), [ this , target ]( auto && handler , StatusOr < i32 > observed ) { if ( observed . ok ()) { BATT_CHECK_EQ ( target , * observed ); } this -> value_ = nullptr ; handler ( observed . status ()); })); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline bool Channel < T >:: is_active () const { return ( this -> write_count_ . get_value () - this -> read_count_ . get_value ()) > 0 ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline StatusOr < T &> Channel < T >:: read () { StatusOr < i64 > result = this -> write_count_ . await_not_equal ( this -> read_count_ . get_value ()); BATT_REQUIRE_OK ( result ); return * this -> value_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline void Channel < T >:: consume () { BATT_CHECK ( this -> is_active ()); this -> value_ = nullptr ; this -> read_count_ . fetch_add ( 1 ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline Status Channel < T >:: write ( T & value ) { BATT_CHECK ( ! this -> is_active ()); if ( this -> write_count_ . is_closed ()) { return { StatusCode :: kClosed }; } this -> value_ = & value ; const i32 target = this -> write_count_ . fetch_add ( 1 ) + 1 ; Status consumed = this -> read_count_ . await_equal ( target ); BATT_REQUIRE_OK ( consumed ); return OkStatus (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline void Channel < T >:: close_for_read () { this -> read_count_ . close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline void Channel < T >:: close_for_write () { this -> write_count_ . close (); } } // namespace batt #endif // BATTERIES_ASYNC_CHANNEL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/channel.hpp"},{"location":"_autogen/Files/channel_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/channel_8hpp/#classes","text":"Name class batt::Channel","title":"Classes"},{"location":"_autogen/Files/channel_8hpp/#defines","text":"Name BATTERIES_ASYNC_CHANNEL_HPP","title":"Defines"},{"location":"_autogen/Files/channel_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/channel_8hpp/#batteries_async_channel_hpp","text":"1 #define BATTERIES_ASYNC_CHANNEL_HPP()","title":"BATTERIES_ASYNC_CHANNEL_HPP"},{"location":"_autogen/Files/channel_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_CHANNEL_HPP #define BATTERIES_ASYNC_CHANNEL_HPP #include <batteries/config.hpp> // #include <batteries/async/watch.hpp> #include <batteries/optional.hpp> #include <batteries/status.hpp> namespace batt { // A Channel<T> is a one-way, unbuffered, SPSC (single-producer, single consumer) // communication/synchronization primitive. // template < typename T > class Channel { public : Channel () { } Channel ( const Channel & ) = delete ; Channel & operator = ( const Channel & ) = delete ; ~ Channel () { this -> close_for_write (); this -> read_count_ . await_equal ( this -> write_count_ . get_value ()). IgnoreError (); } //+++++++++++-+-+--+----- --- -- - - - - // Returns true iff there is currently an object available on the channel. // bool is_active () const ; //+++++++++++-+-+--+----- --- -- - - - - // Wait for an object to be written to the Channel, then return a reference to that object. The referred // object will stay valid until `consume()` is called. // StatusOr < T &> read (); // Release the last value read on the Channel. Panic if `consume()` is called without a prior successful // call to `read()` (indicating that `this->is_active()` is true). // void consume (); // Unblock all ongoing calls to write/async_write and cause all future calls to fail with closed error // status. // void close_for_read (); //+++++++++++-+-+--+----- --- -- - - - - // Write a value to the Channel. Panic if there is currently an ongoing write (single-producer). // // The passed handler is invoked once the value is consumed via `read`/`consume`. // template < typename Handler = void ( Status ) > void async_write ( T & value , Handler && handler ); // Blocking (Task::await) version of `async_write`. This function will not return until the passed value // has been consumed. The value is guaranteed not to be copied; the consumer will see the same exact // object passed into write. // Status write ( T & value ); // Unblock all ongoing calls to read and cause all future calls to fail with closed error status. // void close_for_write (); private : //+++++++++++-+-+--+----- --- -- - - - - Watch < i32 > read_count_ { 0 }; Watch < i32 > write_count_ { 0 }; T * value_ = nullptr ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Handler > void Channel < T >:: async_write ( T & value , Handler && handler ) { BATT_CHECK ( ! this -> is_active ()); if ( this -> write_count_ . is_closed ()) { handler ({ StatusCode :: kClosed }); return ; } this -> value_ = & value ; const i32 last_seen = this -> read_count_ . get_value (); const i32 target = this -> write_count_ . fetch_add ( 1 ) + 1 ; BATT_CHECK_EQ ( last_seen + 1 , target ); this -> read_count_ . async_wait ( last_seen , bind_handler ( BATT_FORWARD ( handler ), [ this , target ]( auto && handler , StatusOr < i32 > observed ) { if ( observed . ok ()) { BATT_CHECK_EQ ( target , * observed ); } this -> value_ = nullptr ; handler ( observed . status ()); })); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline bool Channel < T >:: is_active () const { return ( this -> write_count_ . get_value () - this -> read_count_ . get_value ()) > 0 ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline StatusOr < T &> Channel < T >:: read () { StatusOr < i64 > result = this -> write_count_ . await_not_equal ( this -> read_count_ . get_value ()); BATT_REQUIRE_OK ( result ); return * this -> value_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline void Channel < T >:: consume () { BATT_CHECK ( this -> is_active ()); this -> value_ = nullptr ; this -> read_count_ . fetch_add ( 1 ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline Status Channel < T >:: write ( T & value ) { BATT_CHECK ( ! this -> is_active ()); if ( this -> write_count_ . is_closed ()) { return { StatusCode :: kClosed }; } this -> value_ = & value ; const i32 target = this -> write_count_ . fetch_add ( 1 ) + 1 ; Status consumed = this -> read_count_ . await_equal ( target ); BATT_REQUIRE_OK ( consumed ); return OkStatus (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline void Channel < T >:: close_for_read () { this -> read_count_ . close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > inline void Channel < T >:: close_for_write () { this -> write_count_ . close (); } } // namespace batt #endif // BATTERIES_ASYNC_CHANNEL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/checked__cast_8hpp/","text":"batteries/checked_cast.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_CHECKED_CAST_HPP BATT_CHECKED_CAST (dst_type, src_val) Macro Documentation \ud83d\udd17 BATTERIES_CHECKED_CAST_HPP \ud83d\udd17 1 #define BATTERIES_CHECKED_CAST_HPP() BATT_CHECKED_CAST \ud83d\udd17 1 #define BATT_CHECKED_CAST(dst_type, src_val) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_CHECKED_CAST_HPP #define BATTERIES_CHECKED_CAST_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <type_traits> namespace batt { // Coerce between integral types, panicking if there is a loss of precision. // template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > == std :: is_signed_v < FromType >>> ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) { static_assert ( std :: is_integral_v < ToType > && std :: is_integral_v < FromType > , \"checked_cast can only be used with builtin integer types\" ); static_assert ( std :: is_signed_v < ToType > == std :: is_signed_v < FromType > , \"checked_cast can not add or remove signed-ness to a type\" ); if ( sizeof ( ToType ) < sizeof ( FromType )) { BATT_CHECK_EQ ( static_cast < FromType > ( static_cast < ToType > ( val )), val ) << \" from \" << file << \":\" << line ; } return static_cast < ToType > ( val ); } // Go from unsigned to signed. // template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > && ! std :: is_signed_v < FromType >> , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) { static_assert ( std :: is_integral_v < ToType > && std :: is_integral_v < FromType > , \"checked_cast can only be used with builtin integer types\" ); // If going from an unsigned to a larger signed, just coerce. // if ( sizeof ( FromType ) < sizeof ( ToType )) { return static_cast < ToType > ( val ); } static constexpr isize kToBits = sizeof ( ToType ) * 8 ; static constexpr FromType kRetainedMask = ( FromType { 1 } << ( kToBits - 1 )) - 1 ; BATT_CHECK_EQ (( val & kRetainedMask ), val ) << \" from \" << file << \":\" << line ; return static_cast < ToType > ( val ); } // Go from signed to unsigned // template < typename ToType , typename FromType , typename = std :: enable_if_t <! std :: is_signed_v < ToType > && std :: is_signed_v < FromType >> , typename = void , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) { static_assert ( std :: is_integral_v < ToType > && std :: is_integral_v < FromType > , \"checked_cast can only be used with builtin integer types\" ); // Panic if val is negative; otherwise, coerce to the same-sized unsigned type (which is always safe) and // do an unsigned-to-unsigned checked_cast. // BATT_CHECK_GE ( val , 0 ) << \" from \" << file << \":\" << line ; return checked_cast < ToType > ( static_cast < std :: make_unsigned_t < FromType >> ( val ), file , line ); } #define BATT_CHECKED_CAST(dst_type, src_val) ::batt::checked_cast<dst_type>(src_val, __FILE__, __LINE__) } // namespace batt #endif // BATTERIES_CHECKED_CAST_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/checked_cast.hpp"},{"location":"_autogen/Files/checked__cast_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/checked__cast_8hpp/#defines","text":"Name BATTERIES_CHECKED_CAST_HPP BATT_CHECKED_CAST (dst_type, src_val)","title":"Defines"},{"location":"_autogen/Files/checked__cast_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/checked__cast_8hpp/#batteries_checked_cast_hpp","text":"1 #define BATTERIES_CHECKED_CAST_HPP()","title":"BATTERIES_CHECKED_CAST_HPP"},{"location":"_autogen/Files/checked__cast_8hpp/#batt_checked_cast","text":"1 #define BATT_CHECKED_CAST(dst_type, src_val)","title":"BATT_CHECKED_CAST"},{"location":"_autogen/Files/checked__cast_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_CHECKED_CAST_HPP #define BATTERIES_CHECKED_CAST_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <type_traits> namespace batt { // Coerce between integral types, panicking if there is a loss of precision. // template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > == std :: is_signed_v < FromType >>> ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) { static_assert ( std :: is_integral_v < ToType > && std :: is_integral_v < FromType > , \"checked_cast can only be used with builtin integer types\" ); static_assert ( std :: is_signed_v < ToType > == std :: is_signed_v < FromType > , \"checked_cast can not add or remove signed-ness to a type\" ); if ( sizeof ( ToType ) < sizeof ( FromType )) { BATT_CHECK_EQ ( static_cast < FromType > ( static_cast < ToType > ( val )), val ) << \" from \" << file << \":\" << line ; } return static_cast < ToType > ( val ); } // Go from unsigned to signed. // template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > && ! std :: is_signed_v < FromType >> , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) { static_assert ( std :: is_integral_v < ToType > && std :: is_integral_v < FromType > , \"checked_cast can only be used with builtin integer types\" ); // If going from an unsigned to a larger signed, just coerce. // if ( sizeof ( FromType ) < sizeof ( ToType )) { return static_cast < ToType > ( val ); } static constexpr isize kToBits = sizeof ( ToType ) * 8 ; static constexpr FromType kRetainedMask = ( FromType { 1 } << ( kToBits - 1 )) - 1 ; BATT_CHECK_EQ (( val & kRetainedMask ), val ) << \" from \" << file << \":\" << line ; return static_cast < ToType > ( val ); } // Go from signed to unsigned // template < typename ToType , typename FromType , typename = std :: enable_if_t <! std :: is_signed_v < ToType > && std :: is_signed_v < FromType >> , typename = void , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) { static_assert ( std :: is_integral_v < ToType > && std :: is_integral_v < FromType > , \"checked_cast can only be used with builtin integer types\" ); // Panic if val is negative; otherwise, coerce to the same-sized unsigned type (which is always safe) and // do an unsigned-to-unsigned checked_cast. // BATT_CHECK_GE ( val , 0 ) << \" from \" << file << \":\" << line ; return checked_cast < ToType > ( static_cast < std :: make_unsigned_t < FromType >> ( val ), file , line ); } #define BATT_CHECKED_CAST(dst_type, src_val) ::batt::checked_cast<dst_type>(src_val, __FILE__, __LINE__) } // namespace batt #endif // BATTERIES_CHECKED_CAST_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/collect__vec_8hpp/","text":"batteries/seq/collect_vec.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::CollectVec Defines \ud83d\udd17 Name BATTERIES_SEQ_COLLECT_VEC_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_COLLECT_VEC_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_COLLECT_VEC_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_COLLECT_VEC_HPP #define BATTERIES_SEQ_COLLECT_VEC_HPP #include <batteries/config.hpp> // #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <type_traits> #include <vector> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // collect_vec // struct CollectVec { }; inline CollectVec collect_vec () { return {}; } template < typename Seq , typename = EnableIfSeq < Seq >> [[ nodiscard ]] auto operator | ( Seq && seq , CollectVec ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::collect_vec) Sequences may not be captured implicitly by reference.\" ); std :: vector < SeqItem < Seq >> v ; BATT_FORWARD ( seq ) | for_each ([ & v ]( auto && item ) { v . emplace_back ( BATT_FORWARD ( item )); }); return v ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_COLLECT_VEC_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/collect_vec.hpp"},{"location":"_autogen/Files/collect__vec_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/collect__vec_8hpp/#classes","text":"Name struct batt::seq::CollectVec","title":"Classes"},{"location":"_autogen/Files/collect__vec_8hpp/#defines","text":"Name BATTERIES_SEQ_COLLECT_VEC_HPP","title":"Defines"},{"location":"_autogen/Files/collect__vec_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/collect__vec_8hpp/#batteries_seq_collect_vec_hpp","text":"1 #define BATTERIES_SEQ_COLLECT_VEC_HPP()","title":"BATTERIES_SEQ_COLLECT_VEC_HPP"},{"location":"_autogen/Files/collect__vec_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_COLLECT_VEC_HPP #define BATTERIES_SEQ_COLLECT_VEC_HPP #include <batteries/config.hpp> // #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <type_traits> #include <vector> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // collect_vec // struct CollectVec { }; inline CollectVec collect_vec () { return {}; } template < typename Seq , typename = EnableIfSeq < Seq >> [[ nodiscard ]] auto operator | ( Seq && seq , CollectVec ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::collect_vec) Sequences may not be captured implicitly by reference.\" ); std :: vector < SeqItem < Seq >> v ; BATT_FORWARD ( seq ) | for_each ([ & v ]( auto && item ) { v . emplace_back ( BATT_FORWARD ( item )); }); return v ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_COLLECT_VEC_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/config_8hpp/","text":"batteries/config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_CONFIG_HPP BATT_HEADER_ONLY BATT_SEQ_SPECIALIZE_ALGORITHMS BATT_INLINE_IMPL BATT_COMPILER_IS_GCC BATT_IF_GCC (expr) BATT_COMPILER_IS_CLANG BATT_IF_CLANG (expr) Macro Documentation \ud83d\udd17 BATTERIES_CONFIG_HPP \ud83d\udd17 1 #define BATTERIES_CONFIG_HPP() BATT_HEADER_ONLY \ud83d\udd17 1 #define BATT_HEADER_ONLY() BATT_SEQ_SPECIALIZE_ALGORITHMS \ud83d\udd17 1 #define BATT_SEQ_SPECIALIZE_ALGORITHMS() BATT_INLINE_IMPL \ud83d\udd17 1 #define BATT_INLINE_IMPL() BATT_COMPILER_IS_GCC \ud83d\udd17 1 #define BATT_COMPILER_IS_GCC() BATT_IF_GCC \ud83d\udd17 1 #define BATT_IF_GCC(expr) BATT_COMPILER_IS_CLANG \ud83d\udd17 1 #define BATT_COMPILER_IS_CLANG() BATT_IF_CLANG \ud83d\udd17 1 #define BATT_IF_CLANG(expr) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_CONFIG_HPP #define BATTERIES_CONFIG_HPP #if __cplusplus < 201703L #error Batteries requires C++17 or later! #endif namespace batt { #ifndef BATT_HEADER_ONLY #define BATT_HEADER_ONLY 1 #endif #define BATT_SEQ_SPECIALIZE_ALGORITHMS 0 #if BATT_HEADER_ONLY #define BATT_INLINE_IMPL inline #else #define BATT_INLINE_IMPL #endif // Define this preprocessor symbol to enable optional support for Google Log (GLOG). // //#define BATT_GLOG_AVAILABLE // Define this preprocessor symbol to enable optional support for Google Protocol Buffers (protobuf). // //#define BATT_PROTOBUF_AVAILABLE } // namespace batt #if defined(__GNUC__) && !defined(__clang__) #define BATT_COMPILER_IS_GCC 1 #define BATT_IF_GCC(expr) expr #else #define BATT_COMPILER_IS_GCC 0 #define BATT_IF_GCC(expr) #endif #if defined(__clang__) #define BATT_COMPILER_IS_CLANG 1 #define BATT_IF_CLANG(expr) expr #else #define BATT_COMPILER_IS_CLANG 0 #define BATT_IF_CLANG(expr) #endif #endif // BATTERIES_CONFIG_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/config.hpp"},{"location":"_autogen/Files/config_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/config_8hpp/#defines","text":"Name BATTERIES_CONFIG_HPP BATT_HEADER_ONLY BATT_SEQ_SPECIALIZE_ALGORITHMS BATT_INLINE_IMPL BATT_COMPILER_IS_GCC BATT_IF_GCC (expr) BATT_COMPILER_IS_CLANG BATT_IF_CLANG (expr)","title":"Defines"},{"location":"_autogen/Files/config_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/config_8hpp/#batteries_config_hpp","text":"1 #define BATTERIES_CONFIG_HPP()","title":"BATTERIES_CONFIG_HPP"},{"location":"_autogen/Files/config_8hpp/#batt_header_only","text":"1 #define BATT_HEADER_ONLY()","title":"BATT_HEADER_ONLY"},{"location":"_autogen/Files/config_8hpp/#batt_seq_specialize_algorithms","text":"1 #define BATT_SEQ_SPECIALIZE_ALGORITHMS()","title":"BATT_SEQ_SPECIALIZE_ALGORITHMS"},{"location":"_autogen/Files/config_8hpp/#batt_inline_impl","text":"1 #define BATT_INLINE_IMPL()","title":"BATT_INLINE_IMPL"},{"location":"_autogen/Files/config_8hpp/#batt_compiler_is_gcc","text":"1 #define BATT_COMPILER_IS_GCC()","title":"BATT_COMPILER_IS_GCC"},{"location":"_autogen/Files/config_8hpp/#batt_if_gcc","text":"1 #define BATT_IF_GCC(expr)","title":"BATT_IF_GCC"},{"location":"_autogen/Files/config_8hpp/#batt_compiler_is_clang","text":"1 #define BATT_COMPILER_IS_CLANG()","title":"BATT_COMPILER_IS_CLANG"},{"location":"_autogen/Files/config_8hpp/#batt_if_clang","text":"1 #define BATT_IF_CLANG(expr)","title":"BATT_IF_CLANG"},{"location":"_autogen/Files/config_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_CONFIG_HPP #define BATTERIES_CONFIG_HPP #if __cplusplus < 201703L #error Batteries requires C++17 or later! #endif namespace batt { #ifndef BATT_HEADER_ONLY #define BATT_HEADER_ONLY 1 #endif #define BATT_SEQ_SPECIALIZE_ALGORITHMS 0 #if BATT_HEADER_ONLY #define BATT_INLINE_IMPL inline #else #define BATT_INLINE_IMPL #endif // Define this preprocessor symbol to enable optional support for Google Log (GLOG). // //#define BATT_GLOG_AVAILABLE // Define this preprocessor symbol to enable optional support for Google Protocol Buffers (protobuf). // //#define BATT_PROTOBUF_AVAILABLE } // namespace batt #if defined(__GNUC__) && !defined(__clang__) #define BATT_COMPILER_IS_GCC 1 #define BATT_IF_GCC(expr) expr #else #define BATT_COMPILER_IS_GCC 0 #define BATT_IF_GCC(expr) #endif #if defined(__clang__) #define BATT_COMPILER_IS_CLANG 1 #define BATT_IF_CLANG(expr) expr #else #define BATT_COMPILER_IS_CLANG 0 #define BATT_IF_CLANG(expr) #endif #endif // BATTERIES_CONFIG_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/constants_8hpp/","text":"batteries/constants.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::constants Defines \ud83d\udd17 Name BATTERIES_CONSTANTS_HPP Macro Documentation \ud83d\udd17 BATTERIES_CONSTANTS_HPP \ud83d\udd17 1 #define BATTERIES_CONSTANTS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_CONSTANTS_HPP #define BATTERIES_CONSTANTS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> namespace batt { namespace constants { constexpr u64 kKB = 1000ull ; constexpr u64 kMB = 1000ull * kKB ; constexpr u64 kGB = 1000ull * kMB ; constexpr u64 kTB = 1000ull * kGB ; constexpr u64 kPB = 1000ull * kTB ; constexpr u64 kEB = 1000ull * kPB ; constexpr u64 kKiB = 1024ull ; constexpr u64 kMiB = 1024ull * kKiB ; constexpr u64 kGiB = 1024ull * kMiB ; constexpr u64 kTiB = 1024ull * kGiB ; constexpr u64 kPiB = 1024ull * kTiB ; constexpr u64 kEiB = 1024ull * kPiB ; } // namespace constants using namespace constants ; } // namespace batt #endif // BATTERIES_CONSTANTS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/constants.hpp"},{"location":"_autogen/Files/constants_8hpp/#namespaces","text":"Name batt batt::constants","title":"Namespaces"},{"location":"_autogen/Files/constants_8hpp/#defines","text":"Name BATTERIES_CONSTANTS_HPP","title":"Defines"},{"location":"_autogen/Files/constants_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/constants_8hpp/#batteries_constants_hpp","text":"1 #define BATTERIES_CONSTANTS_HPP()","title":"BATTERIES_CONSTANTS_HPP"},{"location":"_autogen/Files/constants_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_CONSTANTS_HPP #define BATTERIES_CONSTANTS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> namespace batt { namespace constants { constexpr u64 kKB = 1000ull ; constexpr u64 kMB = 1000ull * kKB ; constexpr u64 kGB = 1000ull * kMB ; constexpr u64 kTB = 1000ull * kGB ; constexpr u64 kPB = 1000ull * kTB ; constexpr u64 kEB = 1000ull * kPB ; constexpr u64 kKiB = 1024ull ; constexpr u64 kMiB = 1024ull * kKiB ; constexpr u64 kGiB = 1024ull * kMiB ; constexpr u64 kTiB = 1024ull * kGiB ; constexpr u64 kPiB = 1024ull * kTiB ; constexpr u64 kEiB = 1024ull * kPiB ; } // namespace constants using namespace constants ; } // namespace batt #endif // BATTERIES_CONSTANTS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/consume_8hpp/","text":"batteries/seq/consume.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::Consume Defines \ud83d\udd17 Name BATTERIES_SEQ_CONSUME_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_CONSUME_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_CONSUME_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_CONSUME_HPP #define BATTERIES_SEQ_CONSUME_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/seq/requirements.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // consume // struct Consume { }; inline auto consume () { return Consume {}; } template < typename Seq , typename = EnableIfSeq < Seq >> void operator | ( Seq && seq , Consume && ) { LoopControl result = BATT_FORWARD ( seq ) | for_each ([]( auto && ...) noexcept { // nom, nom, nom... }); BATT_CHECK_EQ ( result , kContinue ); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_CONSUME_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/consume.hpp"},{"location":"_autogen/Files/consume_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/consume_8hpp/#classes","text":"Name struct batt::seq::Consume","title":"Classes"},{"location":"_autogen/Files/consume_8hpp/#defines","text":"Name BATTERIES_SEQ_CONSUME_HPP","title":"Defines"},{"location":"_autogen/Files/consume_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/consume_8hpp/#batteries_seq_consume_hpp","text":"1 #define BATTERIES_SEQ_CONSUME_HPP()","title":"BATTERIES_SEQ_CONSUME_HPP"},{"location":"_autogen/Files/consume_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_CONSUME_HPP #define BATTERIES_SEQ_CONSUME_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/seq/requirements.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // consume // struct Consume { }; inline auto consume () { return Consume {}; } template < typename Seq , typename = EnableIfSeq < Seq >> void operator | ( Seq && seq , Consume && ) { LoopControl result = BATT_FORWARD ( seq ) | for_each ([]( auto && ...) noexcept { // nom, nom, nom... }); BATT_CHECK_EQ ( result , kContinue ); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_CONSUME_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/continuation_8hpp/","text":"batteries/async/continuation.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::AbstractStackAllocator class batt::StackAllocatorImpl class batt::StackAllocator Defines \ud83d\udd17 Name BATTERIES_ASYNC_CONTINUATION_HPP BOOST_USE_VALGRIND Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_CONTINUATION_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_CONTINUATION_HPP() BOOST_USE_VALGRIND \ud83d\udd17 1 #define BOOST_USE_VALGRIND() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_CONTINUATION_HPP #define BATTERIES_ASYNC_CONTINUATION_HPP #include <batteries/config.hpp> // #include <batteries/math.hpp> #include <batteries/static_assert.hpp> #include <batteries/static_dispatch.hpp> #include <batteries/strong_typedef.hpp> #include <batteries/type_traits.hpp> #ifndef NDEBUG #define BOOST_USE_VALGRIND 1 #endif #include <boost/context/continuation.hpp> #include <boost/context/fixedsize_stack.hpp> #include <boost/context/pooled_fixedsize_stack.hpp> #include <boost/context/protected_fixedsize_stack.hpp> #include <boost/smart_ptr/intrusive_ref_counter.hpp> namespace batt { using Continuation = boost :: context :: continuation ; class AbstractStackAllocator : public boost :: intrusive_ref_counter < AbstractStackAllocator > { public : AbstractStackAllocator ( const AbstractStackAllocator & ) = delete ; AbstractStackAllocator & operator = ( const AbstractStackAllocator & ) = delete ; virtual ~ AbstractStackAllocator () = default ; virtual boost :: context :: stack_context allocate () = 0 ; virtual void deallocate ( boost :: context :: stack_context & ) = 0 ; protected : AbstractStackAllocator () = default ; }; template < typename T > class StackAllocatorImpl : public AbstractStackAllocator { public : template < typename ... Args , typename = EnableIfNoShadow < StackAllocatorImpl , Args && ... >> explicit StackAllocatorImpl ( Args && ... args ) : obj_ ( BATT_FORWARD ( args )...) { } boost :: context :: stack_context allocate () override { return this -> obj_ . allocate (); } void deallocate ( boost :: context :: stack_context & ctx ) override { return this -> obj_ . deallocate ( ctx ); } private : T obj_ ; }; class StackAllocator { public : StackAllocator () noexcept : impl_ { nullptr } { } StackAllocator ( const StackAllocator & ) = default ; StackAllocator & operator = ( const StackAllocator & ) = default ; template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> /*implicit*/ StackAllocator ( T && obj ) : impl_ { new StackAllocatorImpl < std :: decay_t < T >> ( BATT_FORWARD ( obj ))} { } template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> StackAllocator & operator = ( T && obj ) { this -> impl_ . reset ( new StackAllocatorImpl < std :: decay_t < T >> ( BATT_FORWARD ( obj ))); return * this ; } boost :: context :: stack_context allocate () const { return this -> impl_ -> allocate (); } void deallocate ( boost :: context :: stack_context & ctx ) const { return this -> impl_ -> deallocate ( ctx ); } private : boost :: intrusive_ptr < AbstractStackAllocator > impl_ ; }; #ifdef BOOST_USE_VALGRIND BATT_STATIC_ASSERT_EQ ( sizeof ( void * ) * 3 , sizeof ( boost :: context :: stack_context )); #else BATT_STATIC_ASSERT_EQ ( sizeof ( void * ) * 2 , sizeof ( boost :: context :: stack_context )); #endif enum struct StackType { kFixedSize = 0 , kProtectedFixedSize = 1 , kPooledFixedSize = 2 , kMaxValue , }; BATT_STRONG_TYPEDEF ( usize , StackSize ); constexpr usize kMinStackSizeLog2 = 10u ; constexpr usize kMaxStackSizeLog2 = 32u ; template < typename T > inline const StackAllocator & get_stack_allocator_with_type ( StackSize stack_size ) { static const std :: array < StackAllocator , kMaxStackSizeLog2 > instance = [] { std :: array < StackAllocator , kMaxStackSizeLog2 > a ; usize z = 1 ; for ( usize i = 0 ; i < a . size (); ++ i ) { if ( i >= kMinStackSizeLog2 ) { BATT_CHECK_EQ ( z , usize { 1 } << i ); a [ i ] = T { usize { 1 } << i }; } z *= 2 ; } return a ; }(); const usize n = std :: max < usize > ( kMinStackSizeLog2 , log2_ceil ( stack_size )); BATT_CHECK_GE ( n , kMinStackSizeLog2 ); BATT_CHECK_LT ( n , instance . size ()); BATT_CHECK_GE ( usize { 1 } << n , stack_size ); return instance [ n ]; } inline const StackAllocator & get_stack_allocator ( StackSize stack_size , StackType stack_type ) { switch ( stack_type ) { case StackType :: kFixedSize : return get_stack_allocator_with_type < boost :: context :: fixedsize_stack > ( stack_size ); case StackType :: kProtectedFixedSize : return get_stack_allocator_with_type < boost :: context :: protected_fixedsize_stack > ( stack_size ); case StackType :: kPooledFixedSize : BATT_PANIC () << \"This stack allocator type is not thread-safe; do not use yet!\" ; return get_stack_allocator_with_type < boost :: context :: pooled_fixedsize_stack > ( stack_size ); case StackType :: kMaxValue : // fall-through default : break ; } BATT_PANIC () << \"Bad stack type: \" << static_cast < int > ( stack_type ); BATT_UNREACHABLE (); } template < typename Fn > inline Continuation callcc ( StackSize stack_size , StackType stack_type , Fn && fn ) { return boost :: context :: callcc ( std :: allocator_arg , get_stack_allocator ( stack_size , stack_type ), BATT_FORWARD ( fn )); } } // namespace batt #endif // BATTERIES_ASYNC_CONTINUATION_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/continuation.hpp"},{"location":"_autogen/Files/continuation_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/continuation_8hpp/#classes","text":"Name class batt::AbstractStackAllocator class batt::StackAllocatorImpl class batt::StackAllocator","title":"Classes"},{"location":"_autogen/Files/continuation_8hpp/#defines","text":"Name BATTERIES_ASYNC_CONTINUATION_HPP BOOST_USE_VALGRIND","title":"Defines"},{"location":"_autogen/Files/continuation_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/continuation_8hpp/#batteries_async_continuation_hpp","text":"1 #define BATTERIES_ASYNC_CONTINUATION_HPP()","title":"BATTERIES_ASYNC_CONTINUATION_HPP"},{"location":"_autogen/Files/continuation_8hpp/#boost_use_valgrind","text":"1 #define BOOST_USE_VALGRIND()","title":"BOOST_USE_VALGRIND"},{"location":"_autogen/Files/continuation_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_CONTINUATION_HPP #define BATTERIES_ASYNC_CONTINUATION_HPP #include <batteries/config.hpp> // #include <batteries/math.hpp> #include <batteries/static_assert.hpp> #include <batteries/static_dispatch.hpp> #include <batteries/strong_typedef.hpp> #include <batteries/type_traits.hpp> #ifndef NDEBUG #define BOOST_USE_VALGRIND 1 #endif #include <boost/context/continuation.hpp> #include <boost/context/fixedsize_stack.hpp> #include <boost/context/pooled_fixedsize_stack.hpp> #include <boost/context/protected_fixedsize_stack.hpp> #include <boost/smart_ptr/intrusive_ref_counter.hpp> namespace batt { using Continuation = boost :: context :: continuation ; class AbstractStackAllocator : public boost :: intrusive_ref_counter < AbstractStackAllocator > { public : AbstractStackAllocator ( const AbstractStackAllocator & ) = delete ; AbstractStackAllocator & operator = ( const AbstractStackAllocator & ) = delete ; virtual ~ AbstractStackAllocator () = default ; virtual boost :: context :: stack_context allocate () = 0 ; virtual void deallocate ( boost :: context :: stack_context & ) = 0 ; protected : AbstractStackAllocator () = default ; }; template < typename T > class StackAllocatorImpl : public AbstractStackAllocator { public : template < typename ... Args , typename = EnableIfNoShadow < StackAllocatorImpl , Args && ... >> explicit StackAllocatorImpl ( Args && ... args ) : obj_ ( BATT_FORWARD ( args )...) { } boost :: context :: stack_context allocate () override { return this -> obj_ . allocate (); } void deallocate ( boost :: context :: stack_context & ctx ) override { return this -> obj_ . deallocate ( ctx ); } private : T obj_ ; }; class StackAllocator { public : StackAllocator () noexcept : impl_ { nullptr } { } StackAllocator ( const StackAllocator & ) = default ; StackAllocator & operator = ( const StackAllocator & ) = default ; template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> /*implicit*/ StackAllocator ( T && obj ) : impl_ { new StackAllocatorImpl < std :: decay_t < T >> ( BATT_FORWARD ( obj ))} { } template < typename T , typename = EnableIfNoShadow < StackAllocator , T &&>> StackAllocator & operator = ( T && obj ) { this -> impl_ . reset ( new StackAllocatorImpl < std :: decay_t < T >> ( BATT_FORWARD ( obj ))); return * this ; } boost :: context :: stack_context allocate () const { return this -> impl_ -> allocate (); } void deallocate ( boost :: context :: stack_context & ctx ) const { return this -> impl_ -> deallocate ( ctx ); } private : boost :: intrusive_ptr < AbstractStackAllocator > impl_ ; }; #ifdef BOOST_USE_VALGRIND BATT_STATIC_ASSERT_EQ ( sizeof ( void * ) * 3 , sizeof ( boost :: context :: stack_context )); #else BATT_STATIC_ASSERT_EQ ( sizeof ( void * ) * 2 , sizeof ( boost :: context :: stack_context )); #endif enum struct StackType { kFixedSize = 0 , kProtectedFixedSize = 1 , kPooledFixedSize = 2 , kMaxValue , }; BATT_STRONG_TYPEDEF ( usize , StackSize ); constexpr usize kMinStackSizeLog2 = 10u ; constexpr usize kMaxStackSizeLog2 = 32u ; template < typename T > inline const StackAllocator & get_stack_allocator_with_type ( StackSize stack_size ) { static const std :: array < StackAllocator , kMaxStackSizeLog2 > instance = [] { std :: array < StackAllocator , kMaxStackSizeLog2 > a ; usize z = 1 ; for ( usize i = 0 ; i < a . size (); ++ i ) { if ( i >= kMinStackSizeLog2 ) { BATT_CHECK_EQ ( z , usize { 1 } << i ); a [ i ] = T { usize { 1 } << i }; } z *= 2 ; } return a ; }(); const usize n = std :: max < usize > ( kMinStackSizeLog2 , log2_ceil ( stack_size )); BATT_CHECK_GE ( n , kMinStackSizeLog2 ); BATT_CHECK_LT ( n , instance . size ()); BATT_CHECK_GE ( usize { 1 } << n , stack_size ); return instance [ n ]; } inline const StackAllocator & get_stack_allocator ( StackSize stack_size , StackType stack_type ) { switch ( stack_type ) { case StackType :: kFixedSize : return get_stack_allocator_with_type < boost :: context :: fixedsize_stack > ( stack_size ); case StackType :: kProtectedFixedSize : return get_stack_allocator_with_type < boost :: context :: protected_fixedsize_stack > ( stack_size ); case StackType :: kPooledFixedSize : BATT_PANIC () << \"This stack allocator type is not thread-safe; do not use yet!\" ; return get_stack_allocator_with_type < boost :: context :: pooled_fixedsize_stack > ( stack_size ); case StackType :: kMaxValue : // fall-through default : break ; } BATT_PANIC () << \"Bad stack type: \" << static_cast < int > ( stack_type ); BATT_UNREACHABLE (); } template < typename Fn > inline Continuation callcc ( StackSize stack_size , StackType stack_type , Fn && fn ) { return boost :: context :: callcc ( std :: allocator_arg , get_stack_allocator ( stack_size , stack_type ), BATT_FORWARD ( fn )); } } // namespace batt #endif // BATTERIES_ASYNC_CONTINUATION_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/count_8hpp/","text":"batteries/seq/count.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::CountBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_COUNT_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_COUNT_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_COUNT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_COUNT_HPP #define BATTERIES_SEQ_COUNT_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // count // struct CountBinder { }; inline CountBinder count () { return {}; } template < typename Seq > BATT_MAYBE_UNUSED usize operator | ( Seq && seq , CountBinder ) { usize n = 0 ; auto loop_body = [ & n ]( auto && ...) noexcept { ++ n ; }; BATT_FORWARD ( seq ) | for_each ( loop_body ); return n ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_COUNT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/count.hpp"},{"location":"_autogen/Files/count_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/count_8hpp/#classes","text":"Name struct batt::seq::CountBinder","title":"Classes"},{"location":"_autogen/Files/count_8hpp/#defines","text":"Name BATTERIES_SEQ_COUNT_HPP","title":"Defines"},{"location":"_autogen/Files/count_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/count_8hpp/#batteries_seq_count_hpp","text":"1 #define BATTERIES_SEQ_COUNT_HPP()","title":"BATTERIES_SEQ_COUNT_HPP"},{"location":"_autogen/Files/count_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_COUNT_HPP #define BATTERIES_SEQ_COUNT_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // count // struct CountBinder { }; inline CountBinder count () { return {}; } template < typename Seq > BATT_MAYBE_UNUSED usize operator | ( Seq && seq , CountBinder ) { usize n = 0 ; auto loop_body = [ & n ]( auto && ...) noexcept { ++ n ; }; BATT_FORWARD ( seq ) | for_each ( loop_body ); return n ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_COUNT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/cpu__align_8hpp/","text":"batteries/cpu_align.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::CpuCacheLineIsolated Defines \ud83d\udd17 Name BATT_CPU_ALIGN_HPP Macro Documentation \ud83d\udd17 BATT_CPU_ALIGN_HPP \ud83d\udd17 1 #define BATT_CPU_ALIGN_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATT_CPU_ALIGN_HPP #define BATT_CPU_ALIGN_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #ifdef __linux__ #include <sched.h> #endif // __linux__ namespace batt { constexpr auto kCpuCacheLineSize = usize { 64 }; // An instance of `T` guaranteed not to reside in the same cache lines as any other object. // template < typename T > class CpuCacheLineIsolated { public : // The contained type. // using value_type = T ; // The size of T rounded up to the nearest multiple of cache line size. // static constexpr usize kIsolatedSize = ( sizeof ( T ) + kCpuCacheLineSize - 1 ) - (( sizeof ( T ) + kCpuCacheLineSize - 1 ) % kCpuCacheLineSize ); // If the passed pointer is constructed within a CpuCacheLineIsolated<T>, return a pointer to the outer // object. Else, behavior is undefined. // static CpuCacheLineIsolated * pointer_from ( T * inner_obj ) { return reinterpret_cast < CpuCacheLineIsolated *> ( inner_obj ); } static const CpuCacheLineIsolated * pointer_from ( const T * inner_obj ) { return reinterpret_cast < const CpuCacheLineIsolated *> ( inner_obj ); } // Default-construct the object. // CpuCacheLineIsolated () noexcept ( noexcept ( T {})) { new ( & storage_ ) T {}; } // Pass-through construct the object from arbitrary arguments. // template < typename ... Args , typename = EnableIfNoShadow < CpuCacheLineIsolated , Args ... >> explicit CpuCacheLineIsolated ( Args && ... args ) noexcept ( noexcept ( T ( std :: forward < Args > ( args )...))) { new ( & storage_ ) T ( std :: forward < Args > ( args )...); } // Construct the object by copying from `that`. // CpuCacheLineIsolated ( const CpuCacheLineIsolated & that ) noexcept ( noexcept ( T ( that . value ()))) { new ( & storage_ ) T ( that . value ()); } // Construct the object by moving from `that`. // CpuCacheLineIsolated ( CpuCacheLineIsolated && that ) noexcept ( noexcept ( T ( std :: move ( that ). value ()))) { new ( & storage_ ) T ( std :: move ( that ). value ()); } // Assign a new value to the object from the object contained within `that`. // CpuCacheLineIsolated & operator = ( const CpuCacheLineIsolated & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> value () = that . value (); } return * this ; } // Pass-through assignment from any type assignable to T. // template < typename V , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < V > , CpuCacheLineIsolated >>> CpuCacheLineIsolated & operator = ( V && val ) noexcept ( noexcept ( std :: declval < CpuCacheLineIsolated *> () -> value () = std :: forward < V > ( val ))) { this -> value () = std :: forward < V > ( val ); return * this ; } // Move a new value to the object from the object contained within `that`. // CpuCacheLineIsolated & operator = ( CpuCacheLineIsolated && that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> value () = std :: move ( that ). value (); } return * this ; } // Destroy the object. // ~ CpuCacheLineIsolated () noexcept { value (). ~ T (); } // Return a pointer to the isolated object. // T * get () { return reinterpret_cast < T *> ( & storage_ ); } const T * get () const { return reinterpret_cast < const T *> ( & storage_ ); } // Return a reference to the isolated object. // T & value () & noexcept { return * reinterpret_cast < T *> ( & storage_ ); } const T & value () const & noexcept { return * reinterpret_cast < const T *> ( & storage_ ); } T && value () && noexcept { return std :: move ( * reinterpret_cast < T *> ( & storage_ )); } const T && value () const && = delete ; // Member-dereference the isolated object. // T * operator -> () { return this -> get (); } const T * operator -> () const { return this -> get (); } // Dereference the isolated object. // T & operator * () & { return this -> value (); } const T & operator * () const & { return this -> value (); } T && operator * () && { return std :: move ( this -> value ()); } private : // The properly padded and aligned storage to hold the isolated object. // std :: aligned_storage_t < kIsolatedSize , kCpuCacheLineSize > storage_ ; }; template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const CpuCacheLineIsolated < T >& t ) { return out << make_printable ( t . value ()); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- inline Status pin_thread_to_cpu ( usize cpu_i ) { #ifdef __linux__ cpu_set_t mask ; CPU_ZERO ( & mask ); CPU_SET ( cpu_i , & mask ); const int retval = sched_setaffinity ( 0 , sizeof ( mask ), & mask ); return status_from_retval ( retval ); #else return StatusCode :: kUnimplemented ; #endif //__linux__ } } // namespace batt #endif // BATT_CPU_ALIGN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/cpu_align.hpp"},{"location":"_autogen/Files/cpu__align_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/cpu__align_8hpp/#classes","text":"Name class batt::CpuCacheLineIsolated","title":"Classes"},{"location":"_autogen/Files/cpu__align_8hpp/#defines","text":"Name BATT_CPU_ALIGN_HPP","title":"Defines"},{"location":"_autogen/Files/cpu__align_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/cpu__align_8hpp/#batt_cpu_align_hpp","text":"1 #define BATT_CPU_ALIGN_HPP()","title":"BATT_CPU_ALIGN_HPP"},{"location":"_autogen/Files/cpu__align_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATT_CPU_ALIGN_HPP #define BATT_CPU_ALIGN_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #ifdef __linux__ #include <sched.h> #endif // __linux__ namespace batt { constexpr auto kCpuCacheLineSize = usize { 64 }; // An instance of `T` guaranteed not to reside in the same cache lines as any other object. // template < typename T > class CpuCacheLineIsolated { public : // The contained type. // using value_type = T ; // The size of T rounded up to the nearest multiple of cache line size. // static constexpr usize kIsolatedSize = ( sizeof ( T ) + kCpuCacheLineSize - 1 ) - (( sizeof ( T ) + kCpuCacheLineSize - 1 ) % kCpuCacheLineSize ); // If the passed pointer is constructed within a CpuCacheLineIsolated<T>, return a pointer to the outer // object. Else, behavior is undefined. // static CpuCacheLineIsolated * pointer_from ( T * inner_obj ) { return reinterpret_cast < CpuCacheLineIsolated *> ( inner_obj ); } static const CpuCacheLineIsolated * pointer_from ( const T * inner_obj ) { return reinterpret_cast < const CpuCacheLineIsolated *> ( inner_obj ); } // Default-construct the object. // CpuCacheLineIsolated () noexcept ( noexcept ( T {})) { new ( & storage_ ) T {}; } // Pass-through construct the object from arbitrary arguments. // template < typename ... Args , typename = EnableIfNoShadow < CpuCacheLineIsolated , Args ... >> explicit CpuCacheLineIsolated ( Args && ... args ) noexcept ( noexcept ( T ( std :: forward < Args > ( args )...))) { new ( & storage_ ) T ( std :: forward < Args > ( args )...); } // Construct the object by copying from `that`. // CpuCacheLineIsolated ( const CpuCacheLineIsolated & that ) noexcept ( noexcept ( T ( that . value ()))) { new ( & storage_ ) T ( that . value ()); } // Construct the object by moving from `that`. // CpuCacheLineIsolated ( CpuCacheLineIsolated && that ) noexcept ( noexcept ( T ( std :: move ( that ). value ()))) { new ( & storage_ ) T ( std :: move ( that ). value ()); } // Assign a new value to the object from the object contained within `that`. // CpuCacheLineIsolated & operator = ( const CpuCacheLineIsolated & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> value () = that . value (); } return * this ; } // Pass-through assignment from any type assignable to T. // template < typename V , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < V > , CpuCacheLineIsolated >>> CpuCacheLineIsolated & operator = ( V && val ) noexcept ( noexcept ( std :: declval < CpuCacheLineIsolated *> () -> value () = std :: forward < V > ( val ))) { this -> value () = std :: forward < V > ( val ); return * this ; } // Move a new value to the object from the object contained within `that`. // CpuCacheLineIsolated & operator = ( CpuCacheLineIsolated && that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> value () = std :: move ( that ). value (); } return * this ; } // Destroy the object. // ~ CpuCacheLineIsolated () noexcept { value (). ~ T (); } // Return a pointer to the isolated object. // T * get () { return reinterpret_cast < T *> ( & storage_ ); } const T * get () const { return reinterpret_cast < const T *> ( & storage_ ); } // Return a reference to the isolated object. // T & value () & noexcept { return * reinterpret_cast < T *> ( & storage_ ); } const T & value () const & noexcept { return * reinterpret_cast < const T *> ( & storage_ ); } T && value () && noexcept { return std :: move ( * reinterpret_cast < T *> ( & storage_ )); } const T && value () const && = delete ; // Member-dereference the isolated object. // T * operator -> () { return this -> get (); } const T * operator -> () const { return this -> get (); } // Dereference the isolated object. // T & operator * () & { return this -> value (); } const T & operator * () const & { return this -> value (); } T && operator * () && { return std :: move ( this -> value ()); } private : // The properly padded and aligned storage to hold the isolated object. // std :: aligned_storage_t < kIsolatedSize , kCpuCacheLineSize > storage_ ; }; template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const CpuCacheLineIsolated < T >& t ) { return out << make_printable ( t . value ()); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- inline Status pin_thread_to_cpu ( usize cpu_i ) { #ifdef __linux__ cpu_set_t mask ; CPU_ZERO ( & mask ); CPU_SET ( cpu_i , & mask ); const int retval = sched_setaffinity ( 0 , sizeof ( mask ), & mask ); return status_from_retval ( retval ); #else return StatusCode :: kUnimplemented ; #endif //__linux__ } } // namespace batt #endif // BATT_CPU_ALIGN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/debug__info_8hpp/","text":"batteries/async/debug_info.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> // #include <batteries/async/debug_info_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/debug_info_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/debug_info.hpp"},{"location":"_autogen/Files/debug__info_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> // #include <batteries/async/debug_info_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/debug_info_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/debug__info__decl_8hpp/","text":"batteries/async/debug_info_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::DebugInfoFrame Defines \ud83d\udd17 Name BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP BATT_DEBUG_INFO (expr) Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP() BATT_DEBUG_INFO \ud83d\udd17 1 #define BATT_DEBUG_INFO(expr) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP #define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/slice.hpp> #include <array> #include <functional> #include <ostream> namespace batt { constexpr usize kMaxDebugInfoThreads = 32 ; class DebugInfoFrame ; // Print the stack of DebugInfoFrame objects for the current task/thread. // void this_task_debug_info ( std :: ostream & out ); // Print the given stack of DebugInfoFrame objects. // void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); // Print DebugInfoFrame stacks for all (non-Task) threads. // void print_all_threads_debug_info ( std :: ostream & out ); // Shortens the passed source code file name by applying heuristics. // const char * shortened_source_file ( const char * raw ); // A stack-local linked list node that captures diagnostic information. This class should most often not be // used directly; see `BATT_DEBUG_INFO` below. // class DebugInfoFrame { public : // A fixed-sized slice of pointers to DebugInfoFrame stack tops; indexed by the thread id. // static Slice < DebugInfoFrame *> all_threads (); // (Thread-Local) A read/write reference to the top-of-stack debug info frame for the current thread. // static DebugInfoFrame *& top (); // `Fn` is a callable object with signature `void (std::ostream&)`. // `fn` should print human readable diagnostic information to the passed stream when invoked. // // When a DebugInfoFrame is created, it automatically links to the thread/Task-local \"top\" // DebugInfoFrame*, forming a stack. *WARNING*: this means it will create problems if you try to create a // DebugInfoFrame in one block scope and then move it to another one for destruction. In most cases, you // should just use the BATT_DEBUG_INFO macro inside a function to create a DebugInfoFrame implicitly. // template < typename Fn > explicit DebugInfoFrame ( Fn && fn ) noexcept : print_info_ { BATT_FORWARD ( fn )} { this -> prev_ = top (); top () = this ; } // Pop this frame from the top of the stack, restoring the old top frame. // ~ DebugInfoFrame () noexcept ; // Declare as friend so `print_debug_info` can traverse the chain of `prev_` pointers. // friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); private : // The diagnostic information emitter function passed in at construction time. // std :: function < void ( std :: ostream & , const void * ) > print_info_ ; // The previous top-of-stack, when this object was created. // DebugInfoFrame * prev_ ; }; // Create a local variable that passively reports human-readable debugging information in response to // generating a backtrace of all Tasks/threads. // // Example: // ``` // void called_from_a_thread(int n) { // for (int i=0; i<n; ++i) { // BATT_DEBUG_INFO(\"loop iteration \" << i << \" of \" << n); // } // } // ``` // #define BATT_DEBUG_INFO(expr) \\ ::batt::DebugInfoFrame BOOST_PP_CAT(debug_info_BATTERIES_, __LINE__) \\ { \\ [&](std::ostream& out, const void* frame) { \\ out << \" \" << expr << std::endl \\ << \" at \" << ::batt::shortened_source_file(__FILE__) << \":\" << __LINE__ << std::endl \\ << \" in \" << __PRETTY_FUNCTION__ << std::endl \\ << \" stack offset: \" << ::batt::Task::current_stack_pos_of(frame) << std::endl; \\ } \\ } } // namespace batt #endif // BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/debug_info_decl.hpp"},{"location":"_autogen/Files/debug__info__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/debug__info__decl_8hpp/#classes","text":"Name class batt::DebugInfoFrame","title":"Classes"},{"location":"_autogen/Files/debug__info__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP BATT_DEBUG_INFO (expr)","title":"Defines"},{"location":"_autogen/Files/debug__info__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/debug__info__decl_8hpp/#batteries_async_debug_info_decl_hpp","text":"1 #define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP()","title":"BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP"},{"location":"_autogen/Files/debug__info__decl_8hpp/#batt_debug_info","text":"1 #define BATT_DEBUG_INFO(expr)","title":"BATT_DEBUG_INFO"},{"location":"_autogen/Files/debug__info__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP #define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/slice.hpp> #include <array> #include <functional> #include <ostream> namespace batt { constexpr usize kMaxDebugInfoThreads = 32 ; class DebugInfoFrame ; // Print the stack of DebugInfoFrame objects for the current task/thread. // void this_task_debug_info ( std :: ostream & out ); // Print the given stack of DebugInfoFrame objects. // void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); // Print DebugInfoFrame stacks for all (non-Task) threads. // void print_all_threads_debug_info ( std :: ostream & out ); // Shortens the passed source code file name by applying heuristics. // const char * shortened_source_file ( const char * raw ); // A stack-local linked list node that captures diagnostic information. This class should most often not be // used directly; see `BATT_DEBUG_INFO` below. // class DebugInfoFrame { public : // A fixed-sized slice of pointers to DebugInfoFrame stack tops; indexed by the thread id. // static Slice < DebugInfoFrame *> all_threads (); // (Thread-Local) A read/write reference to the top-of-stack debug info frame for the current thread. // static DebugInfoFrame *& top (); // `Fn` is a callable object with signature `void (std::ostream&)`. // `fn` should print human readable diagnostic information to the passed stream when invoked. // // When a DebugInfoFrame is created, it automatically links to the thread/Task-local \"top\" // DebugInfoFrame*, forming a stack. *WARNING*: this means it will create problems if you try to create a // DebugInfoFrame in one block scope and then move it to another one for destruction. In most cases, you // should just use the BATT_DEBUG_INFO macro inside a function to create a DebugInfoFrame implicitly. // template < typename Fn > explicit DebugInfoFrame ( Fn && fn ) noexcept : print_info_ { BATT_FORWARD ( fn )} { this -> prev_ = top (); top () = this ; } // Pop this frame from the top of the stack, restoring the old top frame. // ~ DebugInfoFrame () noexcept ; // Declare as friend so `print_debug_info` can traverse the chain of `prev_` pointers. // friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); private : // The diagnostic information emitter function passed in at construction time. // std :: function < void ( std :: ostream & , const void * ) > print_info_ ; // The previous top-of-stack, when this object was created. // DebugInfoFrame * prev_ ; }; // Create a local variable that passively reports human-readable debugging information in response to // generating a backtrace of all Tasks/threads. // // Example: // ``` // void called_from_a_thread(int n) { // for (int i=0; i<n; ++i) { // BATT_DEBUG_INFO(\"loop iteration \" << i << \" of \" << n); // } // } // ``` // #define BATT_DEBUG_INFO(expr) \\ ::batt::DebugInfoFrame BOOST_PP_CAT(debug_info_BATTERIES_, __LINE__) \\ { \\ [&](std::ostream& out, const void* frame) { \\ out << \" \" << expr << std::endl \\ << \" at \" << ::batt::shortened_source_file(__FILE__) << \":\" << __LINE__ << std::endl \\ << \" in \" << __PRETTY_FUNCTION__ << std::endl \\ << \" stack offset: \" << ::batt::Task::current_stack_pos_of(frame) << std::endl; \\ } \\ } } // namespace batt #endif // BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/debug__info__impl_8hpp/","text":"batteries/async/debug_info_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP #define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP #include <batteries/async/debug_info_decl.hpp> #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/segv.hpp> #include <array> #include <cstring> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Slice < DebugInfoFrame *> DebugInfoFrame :: all_threads () { static auto p_ = [] { std :: array < DebugInfoFrame * , kMaxDebugInfoThreads > p ; p . fill ( nullptr ); return p ; }(); return as_slice ( p_ ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL DebugInfoFrame *& DebugInfoFrame :: top () { thread_local DebugInfoFrame * ptr = nullptr ; if ( Task :: current_ptr ()) { return Task :: current (). debug_info ; } const auto i = this_thread_id (); if (( usize ) i < all_threads (). size ()) { return all_threads ()[ i ]; } return ptr ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL DebugInfoFrame ::~ DebugInfoFrame () noexcept { top () = this -> prev_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ) { usize depth = 0 ; while ( p ) { out << \" \" << depth << \".\" ; p -> print_info_ ( out , p ); p = p -> prev_ ; depth += 1 ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void print_all_threads_debug_info ( std :: ostream & out ) { const auto & a = DebugInfoFrame :: all_threads (); for ( std :: size_t i = 0 ; i < a . size (); ++ i ) { if ( a [ i ]) { out << \"DEBUG (thread:\" << i << \")\" << std :: endl ; print_debug_info ( a [ i ], out ); } } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL const char * shortened_source_file ( const char * raw ) { static const std :: string kIncludeDir = \"/include/\" ; static const std :: string kSrcDir = \"/src/\" ; static const std :: string kSourceDir = \"/source/\" ; if ( ! raw ) { return \"\" ; } for (;;) { bool found = false ; for ( const std :: string & pattern : { kIncludeDir , kSrcDir , kSourceDir }) { const char * pos = std :: strstr ( raw , pattern . c_str ()); if ( pos ) { raw = pos + pattern . length (); found = true ; break ; } } if ( ! found ) { break ; } } return raw ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void this_task_debug_info ( std :: ostream & out ) { print_debug_info ( DebugInfoFrame :: top (), out ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL const bool kTaskDebugInfoSegvCallbackInstalled = [] { extra_segv_debug_info_callback () = & this_task_debug_info ; return true ; }(); } // namespace batt #endif // BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/debug_info_impl.hpp"},{"location":"_autogen/Files/debug__info__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/debug__info__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/debug__info__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/debug__info__impl_8hpp/#batteries_async_debug_info_impl_hpp","text":"1 #define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP()","title":"BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP"},{"location":"_autogen/Files/debug__info__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP #define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP #include <batteries/async/debug_info_decl.hpp> #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/segv.hpp> #include <array> #include <cstring> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Slice < DebugInfoFrame *> DebugInfoFrame :: all_threads () { static auto p_ = [] { std :: array < DebugInfoFrame * , kMaxDebugInfoThreads > p ; p . fill ( nullptr ); return p ; }(); return as_slice ( p_ ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL DebugInfoFrame *& DebugInfoFrame :: top () { thread_local DebugInfoFrame * ptr = nullptr ; if ( Task :: current_ptr ()) { return Task :: current (). debug_info ; } const auto i = this_thread_id (); if (( usize ) i < all_threads (). size ()) { return all_threads ()[ i ]; } return ptr ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL DebugInfoFrame ::~ DebugInfoFrame () noexcept { top () = this -> prev_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ) { usize depth = 0 ; while ( p ) { out << \" \" << depth << \".\" ; p -> print_info_ ( out , p ); p = p -> prev_ ; depth += 1 ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void print_all_threads_debug_info ( std :: ostream & out ) { const auto & a = DebugInfoFrame :: all_threads (); for ( std :: size_t i = 0 ; i < a . size (); ++ i ) { if ( a [ i ]) { out << \"DEBUG (thread:\" << i << \")\" << std :: endl ; print_debug_info ( a [ i ], out ); } } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL const char * shortened_source_file ( const char * raw ) { static const std :: string kIncludeDir = \"/include/\" ; static const std :: string kSrcDir = \"/src/\" ; static const std :: string kSourceDir = \"/source/\" ; if ( ! raw ) { return \"\" ; } for (;;) { bool found = false ; for ( const std :: string & pattern : { kIncludeDir , kSrcDir , kSourceDir }) { const char * pos = std :: strstr ( raw , pattern . c_str ()); if ( pos ) { raw = pos + pattern . length (); found = true ; break ; } } if ( ! found ) { break ; } } return raw ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void this_task_debug_info ( std :: ostream & out ) { print_debug_info ( DebugInfoFrame :: top (), out ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL const bool kTaskDebugInfoSegvCallbackInstalled = [] { extra_segv_debug_info_callback () = & this_task_debug_info ; return true ; }(); } // namespace batt #endif // BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/deref_8hpp/","text":"batteries/seq/deref.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::Deref Defines \ud83d\udd17 Name BATTERIES_SEQ_DEREF_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_DEREF_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_DEREF_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_DEREF_HPP #define BATTERIES_SEQ_DEREF_HPP #include <batteries/config.hpp> // #include <batteries/seq/map.hpp> namespace batt { namespace seq { struct Deref { template < typename T > auto operator ()( T && val ) const { return * val ; } }; inline auto deref () { return map ( Deref {}); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_DEREF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/deref.hpp"},{"location":"_autogen/Files/deref_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/deref_8hpp/#classes","text":"Name struct batt::seq::Deref","title":"Classes"},{"location":"_autogen/Files/deref_8hpp/#defines","text":"Name BATTERIES_SEQ_DEREF_HPP","title":"Defines"},{"location":"_autogen/Files/deref_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/deref_8hpp/#batteries_seq_deref_hpp","text":"1 #define BATTERIES_SEQ_DEREF_HPP()","title":"BATTERIES_SEQ_DEREF_HPP"},{"location":"_autogen/Files/deref_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_DEREF_HPP #define BATTERIES_SEQ_DEREF_HPP #include <batteries/config.hpp> // #include <batteries/seq/map.hpp> namespace batt { namespace seq { struct Deref { template < typename T > auto operator ()( T && val ) const { return * val ; } }; inline auto deref () { return map ( Deref {}); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_DEREF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/dir_0985703d1fb34e0edc7cc330d020d62d/","text":"batteries/seq \ud83d\udd17 Files \ud83d\udd17 Name batteries/seq/boxed.hpp batteries/seq/cache_next.hpp batteries/seq/chain.hpp batteries/seq/collect_vec.hpp batteries/seq/consume.hpp batteries/seq/count.hpp batteries/seq/deref.hpp batteries/seq/emplace_back.hpp batteries/seq/empty.hpp batteries/seq/filter.hpp batteries/seq/filter_map.hpp batteries/seq/first.hpp batteries/seq/flatten.hpp batteries/seq/for_each.hpp batteries/seq/group_by.hpp batteries/seq/lazy.hpp batteries/seq/loop_control.hpp batteries/seq/map.hpp batteries/seq/merge_by.hpp batteries/seq/natural_equals.hpp batteries/seq/natural_order.hpp batteries/seq/prepend.hpp batteries/seq/print_out.hpp batteries/seq/printable.hpp batteries/seq/reduce.hpp batteries/seq/requirements.hpp batteries/seq/reverse.hpp batteries/seq/seq_item.hpp batteries/seq/skip_n.hpp batteries/seq/status_ok.hpp batteries/seq/sub_range_seq.hpp batteries/seq/take_n.hpp batteries/seq/take_while.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq"},{"location":"_autogen/Files/dir_0985703d1fb34e0edc7cc330d020d62d/#files","text":"Name batteries/seq/boxed.hpp batteries/seq/cache_next.hpp batteries/seq/chain.hpp batteries/seq/collect_vec.hpp batteries/seq/consume.hpp batteries/seq/count.hpp batteries/seq/deref.hpp batteries/seq/emplace_back.hpp batteries/seq/empty.hpp batteries/seq/filter.hpp batteries/seq/filter_map.hpp batteries/seq/first.hpp batteries/seq/flatten.hpp batteries/seq/for_each.hpp batteries/seq/group_by.hpp batteries/seq/lazy.hpp batteries/seq/loop_control.hpp batteries/seq/map.hpp batteries/seq/merge_by.hpp batteries/seq/natural_equals.hpp batteries/seq/natural_order.hpp batteries/seq/prepend.hpp batteries/seq/print_out.hpp batteries/seq/printable.hpp batteries/seq/reduce.hpp batteries/seq/requirements.hpp batteries/seq/reverse.hpp batteries/seq/seq_item.hpp batteries/seq/skip_n.hpp batteries/seq/status_ok.hpp batteries/seq/sub_range_seq.hpp batteries/seq/take_n.hpp batteries/seq/take_while.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_23237b2d5d682108d256c42b41036300/","text":"batteries/algo \ud83d\udd17 Files \ud83d\udd17 Name batteries/algo/parallel_accumulate.hpp batteries/algo/parallel_copy.hpp batteries/algo/parallel_merge.hpp batteries/algo/parallel_running_total.hpp batteries/algo/parallel_transform.hpp batteries/algo/running_total.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo"},{"location":"_autogen/Files/dir_23237b2d5d682108d256c42b41036300/#files","text":"Name batteries/algo/parallel_accumulate.hpp batteries/algo/parallel_copy.hpp batteries/algo/parallel_merge.hpp batteries/algo/parallel_running_total.hpp batteries/algo/parallel_transform.hpp batteries/algo/running_total.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_5ba863940ce6067bb787d1b849676df9/","text":"batteries/metrics \ud83d\udd17 Files \ud83d\udd17 Name batteries/metrics/metric_collectors.hpp batteries/metrics/metric_collectors_impl.hpp batteries/metrics/metric_csv_formatter.hpp batteries/metrics/metric_csv_formatter_impl.hpp batteries/metrics/metric_dumper.hpp batteries/metrics/metric_dumper_impl.hpp batteries/metrics/metric_formatter.hpp batteries/metrics/metric_formatter_impl.hpp batteries/metrics/metric_registry.hpp batteries/metrics/metric_registry_impl.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics"},{"location":"_autogen/Files/dir_5ba863940ce6067bb787d1b849676df9/#files","text":"Name batteries/metrics/metric_collectors.hpp batteries/metrics/metric_collectors_impl.hpp batteries/metrics/metric_csv_formatter.hpp batteries/metrics/metric_csv_formatter_impl.hpp batteries/metrics/metric_dumper.hpp batteries/metrics/metric_dumper_impl.hpp batteries/metrics/metric_formatter.hpp batteries/metrics/metric_formatter_impl.hpp batteries/metrics/metric_registry.hpp batteries/metrics/metric_registry_impl.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/","text":"batteries/http \ud83d\udd17 Files \ud83d\udd17 Name batteries/http/host_address.hpp batteries/http/http_chunk_decoder.hpp batteries/http/http_chunk_encoder.hpp batteries/http/http_client.hpp batteries/http/http_client_connection.hpp batteries/http/http_client_connection_decl.hpp batteries/http/http_client_connection_impl.hpp batteries/http/http_client_host_context.hpp batteries/http/http_client_host_context_decl.hpp batteries/http/http_client_host_context_impl.hpp batteries/http/http_client_impl.hpp batteries/http/http_data.hpp batteries/http/http_header.hpp batteries/http/http_message_base.hpp batteries/http/http_request.hpp batteries/http/http_response.hpp batteries/http/http_server.hpp batteries/http/http_server_impl.hpp batteries/http/http_version.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http"},{"location":"_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/#files","text":"Name batteries/http/host_address.hpp batteries/http/http_chunk_decoder.hpp batteries/http/http_chunk_encoder.hpp batteries/http/http_client.hpp batteries/http/http_client_connection.hpp batteries/http/http_client_connection_decl.hpp batteries/http/http_client_connection_impl.hpp batteries/http/http_client_host_context.hpp batteries/http/http_client_host_context_decl.hpp batteries/http/http_client_host_context_impl.hpp batteries/http/http_client_impl.hpp batteries/http/http_data.hpp batteries/http/http_header.hpp batteries/http/http_message_base.hpp batteries/http/http_request.hpp batteries/http/http_response.hpp batteries/http/http_server.hpp batteries/http/http_server_impl.hpp batteries/http/http_version.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_a632bc4ac9c412aedbec832ef7391aeb/","text":"batteries/state_machine_model \ud83d\udd17 Files \ud83d\udd17 Name batteries/state_machine_model/advanced_options.hpp batteries/state_machine_model/entropy_source.hpp batteries/state_machine_model/exhaustive_model_checker.hpp batteries/state_machine_model/parallel_model_check_state.hpp batteries/state_machine_model/state_machine_result.hpp batteries/state_machine_model/state_machine_traits.hpp batteries/state_machine_model/stochastic_model_checker.hpp batteries/state_machine_model/verbose.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model"},{"location":"_autogen/Files/dir_a632bc4ac9c412aedbec832ef7391aeb/#files","text":"Name batteries/state_machine_model/advanced_options.hpp batteries/state_machine_model/entropy_source.hpp batteries/state_machine_model/exhaustive_model_checker.hpp batteries/state_machine_model/parallel_model_check_state.hpp batteries/state_machine_model/state_machine_result.hpp batteries/state_machine_model/state_machine_traits.hpp batteries/state_machine_model/stochastic_model_checker.hpp batteries/state_machine_model/verbose.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_ad31cac107356ba3b876e0559a878901/","text":"batteries/protobuf \ud83d\udd17 Files \ud83d\udd17 Name batteries/protobuf/stream_buffer_input_stream.hpp batteries/protobuf/stream_buffer_output_stream.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/protobuf"},{"location":"_autogen/Files/dir_ad31cac107356ba3b876e0559a878901/#files","text":"Name batteries/protobuf/stream_buffer_input_stream.hpp batteries/protobuf/stream_buffer_output_stream.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/","text":"batteries \ud83d\udd17 Directories \ud83d\udd17 Name batteries/algo batteries/async batteries/http batteries/metrics batteries/pico_http batteries/protobuf batteries/seq batteries/state_machine_model Files \ud83d\udd17 Name batteries/assert.hpp batteries/bounds.hpp batteries/buffer.hpp batteries/case_of.hpp batteries/checked_cast.hpp batteries/config.hpp batteries/constants.hpp batteries/cpu_align.hpp batteries/do_nothing.hpp batteries/env.hpp batteries/finally.hpp batteries/hash.hpp batteries/hint.hpp batteries/int_types.hpp batteries/interval.hpp batteries/interval_traits.hpp batteries/logging.hpp batteries/math.hpp batteries/nullable.hpp batteries/optional.hpp batteries/pointers.hpp batteries/radix_queue.hpp batteries/ref.hpp batteries/require.hpp batteries/segv.hpp batteries/seq.hpp batteries/shared_ptr.hpp batteries/slice.hpp batteries/small_fn.hpp batteries/small_vec.hpp batteries/state_machine_model.hpp batteries/static_assert.hpp batteries/static_dispatch.hpp batteries/status.hpp batteries/status_impl.hpp batteries/stream_util.hpp batteries/strict.hpp batteries/strong_typedef.hpp batteries/suppress.hpp batteries/syscall_retry.hpp batteries/token.hpp batteries/tuples.hpp batteries/type_erasure.hpp batteries/type_traits.hpp batteries/url_parse.hpp batteries/utility.hpp batteries/var_size_array.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries"},{"location":"_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#directories","text":"Name batteries/algo batteries/async batteries/http batteries/metrics batteries/pico_http batteries/protobuf batteries/seq batteries/state_machine_model","title":"Directories"},{"location":"_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#files","text":"Name batteries/assert.hpp batteries/bounds.hpp batteries/buffer.hpp batteries/case_of.hpp batteries/checked_cast.hpp batteries/config.hpp batteries/constants.hpp batteries/cpu_align.hpp batteries/do_nothing.hpp batteries/env.hpp batteries/finally.hpp batteries/hash.hpp batteries/hint.hpp batteries/int_types.hpp batteries/interval.hpp batteries/interval_traits.hpp batteries/logging.hpp batteries/math.hpp batteries/nullable.hpp batteries/optional.hpp batteries/pointers.hpp batteries/radix_queue.hpp batteries/ref.hpp batteries/require.hpp batteries/segv.hpp batteries/seq.hpp batteries/shared_ptr.hpp batteries/slice.hpp batteries/small_fn.hpp batteries/small_vec.hpp batteries/state_machine_model.hpp batteries/static_assert.hpp batteries/static_dispatch.hpp batteries/status.hpp batteries/status_impl.hpp batteries/stream_util.hpp batteries/strict.hpp batteries/strong_typedef.hpp batteries/suppress.hpp batteries/syscall_retry.hpp batteries/token.hpp batteries/tuples.hpp batteries/type_erasure.hpp batteries/type_traits.hpp batteries/url_parse.hpp batteries/utility.hpp batteries/var_size_array.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_c14a1d4d12bee09dc523319537c13e97/","text":"batteries/pico_http \ud83d\udd17 Files \ud83d\udd17 Name batteries/pico_http/parser.hpp batteries/pico_http/parser_decl.hpp batteries/pico_http/parser_impl.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/pico_http"},{"location":"_autogen/Files/dir_c14a1d4d12bee09dc523319537c13e97/#files","text":"Name batteries/pico_http/parser.hpp batteries/pico_http/parser_decl.hpp batteries/pico_http/parser_impl.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/dir_faaa2176564b41e79cedcf3028f42662/","text":"batteries/async \ud83d\udd17 Files \ud83d\udd17 Name batteries/async/backoff.hpp batteries/async/buffer_source.hpp batteries/async/buffer_source_impl.hpp batteries/async/channel.hpp batteries/async/continuation.hpp batteries/async/debug_info.hpp batteries/async/debug_info_decl.hpp batteries/async/debug_info_impl.hpp batteries/async/dump_tasks.hpp batteries/async/fake_execution_context.hpp batteries/async/fake_execution_context_decl.hpp batteries/async/fake_execution_context_impl.hpp batteries/async/fake_executor.hpp batteries/async/fake_executor_decl.hpp batteries/async/fake_executor_impl.hpp batteries/async/fake_task_scheduler.hpp batteries/async/fake_time_service.hpp batteries/async/fake_time_service_decl.hpp batteries/async/fake_time_service_impl.hpp batteries/async/future.hpp batteries/async/future_decl.hpp batteries/async/future_impl.hpp batteries/async/grant.hpp batteries/async/grant_decl.hpp batteries/async/grant_impl.hpp batteries/async/handler.hpp batteries/async/io_result.hpp batteries/async/latch.hpp batteries/async/mutex.hpp batteries/async/pin.hpp batteries/async/queue.hpp batteries/async/rate_limiter.hpp batteries/async/runtime.hpp batteries/async/single_thread_executor.hpp batteries/async/slice_work.hpp batteries/async/slice_work_impl.hpp batteries/async/stream_buffer.hpp batteries/async/stream_buffer_impl.hpp batteries/async/task.hpp batteries/async/task_decl.hpp batteries/async/task_impl.hpp batteries/async/task_scheduler.hpp batteries/async/types.hpp batteries/async/watch.hpp batteries/async/watch_decl.hpp batteries/async/watch_impl.hpp batteries/async/work_context.hpp batteries/async/worker.hpp batteries/async/worker_pool.hpp batteries/async/worker_pool_impl.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async"},{"location":"_autogen/Files/dir_faaa2176564b41e79cedcf3028f42662/#files","text":"Name batteries/async/backoff.hpp batteries/async/buffer_source.hpp batteries/async/buffer_source_impl.hpp batteries/async/channel.hpp batteries/async/continuation.hpp batteries/async/debug_info.hpp batteries/async/debug_info_decl.hpp batteries/async/debug_info_impl.hpp batteries/async/dump_tasks.hpp batteries/async/fake_execution_context.hpp batteries/async/fake_execution_context_decl.hpp batteries/async/fake_execution_context_impl.hpp batteries/async/fake_executor.hpp batteries/async/fake_executor_decl.hpp batteries/async/fake_executor_impl.hpp batteries/async/fake_task_scheduler.hpp batteries/async/fake_time_service.hpp batteries/async/fake_time_service_decl.hpp batteries/async/fake_time_service_impl.hpp batteries/async/future.hpp batteries/async/future_decl.hpp batteries/async/future_impl.hpp batteries/async/grant.hpp batteries/async/grant_decl.hpp batteries/async/grant_impl.hpp batteries/async/handler.hpp batteries/async/io_result.hpp batteries/async/latch.hpp batteries/async/mutex.hpp batteries/async/pin.hpp batteries/async/queue.hpp batteries/async/rate_limiter.hpp batteries/async/runtime.hpp batteries/async/single_thread_executor.hpp batteries/async/slice_work.hpp batteries/async/slice_work_impl.hpp batteries/async/stream_buffer.hpp batteries/async/stream_buffer_impl.hpp batteries/async/task.hpp batteries/async/task_decl.hpp batteries/async/task_impl.hpp batteries/async/task_scheduler.hpp batteries/async/types.hpp batteries/async/watch.hpp batteries/async/watch_decl.hpp batteries/async/watch_impl.hpp batteries/async/work_context.hpp batteries/async/worker.hpp batteries/async/worker_pool.hpp batteries/async/worker_pool_impl.hpp Updated on 26 August 2022 at 17:30:03 UTC","title":"Files"},{"location":"_autogen/Files/do__nothing_8hpp/","text":"batteries/do_nothing.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::DoNothing Defines \ud83d\udd17 Name BATTERIES_DO_NOTHING_HPP Macro Documentation \ud83d\udd17 BATTERIES_DO_NOTHING_HPP \ud83d\udd17 1 #define BATTERIES_DO_NOTHING_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_DO_NOTHING_HPP #define BATTERIES_DO_NOTHING_HPP #include <batteries/config.hpp> // namespace batt { template < typename ... Args > void do_nothing ( Args && ...) { } struct DoNothing { using result_type = void ; template < typename ... Args > void operator ()( Args && ...) const { } }; } // namespace batt #endif // BATTERIES_DO_NOTHING_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/do_nothing.hpp"},{"location":"_autogen/Files/do__nothing_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/do__nothing_8hpp/#classes","text":"Name struct batt::DoNothing","title":"Classes"},{"location":"_autogen/Files/do__nothing_8hpp/#defines","text":"Name BATTERIES_DO_NOTHING_HPP","title":"Defines"},{"location":"_autogen/Files/do__nothing_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/do__nothing_8hpp/#batteries_do_nothing_hpp","text":"1 #define BATTERIES_DO_NOTHING_HPP()","title":"BATTERIES_DO_NOTHING_HPP"},{"location":"_autogen/Files/do__nothing_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_DO_NOTHING_HPP #define BATTERIES_DO_NOTHING_HPP #include <batteries/config.hpp> // namespace batt { template < typename ... Args > void do_nothing ( Args && ...) { } struct DoNothing { using result_type = void ; template < typename ... Args > void operator ()( Args && ...) const { } }; } // namespace batt #endif // BATTERIES_DO_NOTHING_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/dump__tasks_8hpp/","text":"batteries/async/dump_tasks.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name class batt::detail::SigInfoHandler Defines \ud83d\udd17 Name BATTERIES_ASYNC_DUMP_TASKS_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_DUMP_TASKS_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_DUMP_TASKS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_DUMP_TASKS_HPP #define BATTERIES_ASYNC_DUMP_TASKS_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/assert.hpp> #include <batteries/optional.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/signal_set.hpp> #include <atomic> #include <chrono> #include <functional> #include <thread> #include <type_traits> namespace batt { namespace detail { class SigInfoHandler { public : static constexpr int kSignalNum = #ifdef __linux__ SIGUSR1 #else SIGINFO #endif ; using WorkGuard = batt :: Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type >> ; static SigInfoHandler & instance () { static std :: aligned_storage_t < sizeof ( SigInfoHandler ) > storage_ ; static SigInfoHandler * instance_ = new ( & storage_ ) SigInfoHandler ; return * instance_ ; } SigInfoHandler () { this -> sig_info_thread_ . detach (); } void start () { BATT_CHECK ( this -> sig_info_ ); this -> sig_info_ -> async_wait ( std :: ref ( * this )); } void halt () { const bool halted_prior = this -> halted_ . exchange ( true ); if ( halted_prior ) { return ; } { batt :: ErrorCode ec ; this -> sig_info_ -> cancel ( ec ); } this -> sig_info_work_guard_ = None ; this -> sig_info_io_ . stop (); BATT_LOG ( INFO ) << \"signal handlers cancelled\" ; } void join () { if ( this -> sig_info_thread_ . joinable ()) { this -> sig_info_thread_ . join (); } } void operator ()( const boost :: system :: error_code & ec , int signal_n ) { this -> sig_info_ -> async_wait ([ this ]( const batt :: ErrorCode & ec , int n ) { if ( ec || this -> halted_ . load ()) { return ; } using namespace std :: literals :: chrono_literals ; const bool force = ( std :: chrono :: steady_clock :: now () - this -> last_sig_info_ ) <= 5 s ; std :: cerr << \"[batt::SigInfoHandler::operator()(\" << n << \"); force=\" << force << \"]\" << std :: endl ; batt :: Task :: backtrace_all ( force ); this -> last_sig_info_ = std :: chrono :: steady_clock :: now (); this -> start (); }); } private : std :: atomic < bool > halted_ { false }; boost :: asio :: io_context sig_info_io_ ; Optional < WorkGuard > sig_info_work_guard_ { this -> sig_info_io_ . get_executor ()}; Optional < boost :: asio :: signal_set > sig_info_ { this -> sig_info_io_ , SigInfoHandler :: kSignalNum }; std :: chrono :: steady_clock :: time_point last_sig_info_ = std :: chrono :: steady_clock :: now (); std :: thread sig_info_thread_ {[ this ] { this -> sig_info_io_ . run (); }}; }; } // namespace detail inline bool enable_dump_tasks () { static bool initialized_ = [] { detail :: SigInfoHandler :: instance (). start (); return true ; }(); return initialized_ ; } } // namespace batt #endif // BATTERIES_ASYNC_DUMP_TASKS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/dump_tasks.hpp"},{"location":"_autogen/Files/dump__tasks_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/dump__tasks_8hpp/#classes","text":"Name class batt::detail::SigInfoHandler","title":"Classes"},{"location":"_autogen/Files/dump__tasks_8hpp/#defines","text":"Name BATTERIES_ASYNC_DUMP_TASKS_HPP","title":"Defines"},{"location":"_autogen/Files/dump__tasks_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/dump__tasks_8hpp/#batteries_async_dump_tasks_hpp","text":"1 #define BATTERIES_ASYNC_DUMP_TASKS_HPP()","title":"BATTERIES_ASYNC_DUMP_TASKS_HPP"},{"location":"_autogen/Files/dump__tasks_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_DUMP_TASKS_HPP #define BATTERIES_ASYNC_DUMP_TASKS_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/assert.hpp> #include <batteries/optional.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/signal_set.hpp> #include <atomic> #include <chrono> #include <functional> #include <thread> #include <type_traits> namespace batt { namespace detail { class SigInfoHandler { public : static constexpr int kSignalNum = #ifdef __linux__ SIGUSR1 #else SIGINFO #endif ; using WorkGuard = batt :: Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type >> ; static SigInfoHandler & instance () { static std :: aligned_storage_t < sizeof ( SigInfoHandler ) > storage_ ; static SigInfoHandler * instance_ = new ( & storage_ ) SigInfoHandler ; return * instance_ ; } SigInfoHandler () { this -> sig_info_thread_ . detach (); } void start () { BATT_CHECK ( this -> sig_info_ ); this -> sig_info_ -> async_wait ( std :: ref ( * this )); } void halt () { const bool halted_prior = this -> halted_ . exchange ( true ); if ( halted_prior ) { return ; } { batt :: ErrorCode ec ; this -> sig_info_ -> cancel ( ec ); } this -> sig_info_work_guard_ = None ; this -> sig_info_io_ . stop (); BATT_LOG ( INFO ) << \"signal handlers cancelled\" ; } void join () { if ( this -> sig_info_thread_ . joinable ()) { this -> sig_info_thread_ . join (); } } void operator ()( const boost :: system :: error_code & ec , int signal_n ) { this -> sig_info_ -> async_wait ([ this ]( const batt :: ErrorCode & ec , int n ) { if ( ec || this -> halted_ . load ()) { return ; } using namespace std :: literals :: chrono_literals ; const bool force = ( std :: chrono :: steady_clock :: now () - this -> last_sig_info_ ) <= 5 s ; std :: cerr << \"[batt::SigInfoHandler::operator()(\" << n << \"); force=\" << force << \"]\" << std :: endl ; batt :: Task :: backtrace_all ( force ); this -> last_sig_info_ = std :: chrono :: steady_clock :: now (); this -> start (); }); } private : std :: atomic < bool > halted_ { false }; boost :: asio :: io_context sig_info_io_ ; Optional < WorkGuard > sig_info_work_guard_ { this -> sig_info_io_ . get_executor ()}; Optional < boost :: asio :: signal_set > sig_info_ { this -> sig_info_io_ , SigInfoHandler :: kSignalNum }; std :: chrono :: steady_clock :: time_point last_sig_info_ = std :: chrono :: steady_clock :: now (); std :: thread sig_info_thread_ {[ this ] { this -> sig_info_io_ . run (); }}; }; } // namespace detail inline bool enable_dump_tasks () { static bool initialized_ = [] { detail :: SigInfoHandler :: instance (). start (); return true ; }(); return initialized_ ; } } // namespace batt #endif // BATTERIES_ASYNC_DUMP_TASKS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/emplace__back_8hpp/","text":"batteries/seq/emplace_back.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Defines \ud83d\udd17 Name BATTERIES_SEQ_EMPLACE_BACK_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_EMPLACE_BACK_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_EMPLACE_BACK_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_EMPLACE_BACK_HPP #define BATTERIES_SEQ_EMPLACE_BACK_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // emplace_back template < typename Container > inline auto emplace_back ( Container * dst ) { return for_each ([ dst ]( auto && item ) { dst -> emplace_back ( BATT_FORWARD ( item )); }); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_EMPLACE_BACK_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/emplace_back.hpp"},{"location":"_autogen/Files/emplace__back_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/emplace__back_8hpp/#defines","text":"Name BATTERIES_SEQ_EMPLACE_BACK_HPP","title":"Defines"},{"location":"_autogen/Files/emplace__back_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/emplace__back_8hpp/#batteries_seq_emplace_back_hpp","text":"1 #define BATTERIES_SEQ_EMPLACE_BACK_HPP()","title":"BATTERIES_SEQ_EMPLACE_BACK_HPP"},{"location":"_autogen/Files/emplace__back_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_EMPLACE_BACK_HPP #define BATTERIES_SEQ_EMPLACE_BACK_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // emplace_back template < typename Container > inline auto emplace_back ( Container * dst ) { return for_each ([ dst ]( auto && item ) { dst -> emplace_back ( BATT_FORWARD ( item )); }); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_EMPLACE_BACK_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/empty_8hpp/","text":"batteries/seq/empty.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Empty Defines \ud83d\udd17 Name BATTERIES_SEQ_EMPTY_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_EMPTY_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_EMPTY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_EMPTY_HPP #define BATTERIES_SEQ_EMPTY_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > class Empty { public : using Item = T ; Optional < T > peek () { return None ; } Optional < T > next () { return None ; } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_EMPTY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/empty.hpp"},{"location":"_autogen/Files/empty_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/empty_8hpp/#classes","text":"Name class batt::seq::Empty","title":"Classes"},{"location":"_autogen/Files/empty_8hpp/#defines","text":"Name BATTERIES_SEQ_EMPTY_HPP","title":"Defines"},{"location":"_autogen/Files/empty_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/empty_8hpp/#batteries_seq_empty_hpp","text":"1 #define BATTERIES_SEQ_EMPTY_HPP()","title":"BATTERIES_SEQ_EMPTY_HPP"},{"location":"_autogen/Files/empty_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_EMPTY_HPP #define BATTERIES_SEQ_EMPTY_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > class Empty { public : using Item = T ; Optional < T > peek () { return None ; } Optional < T > next () { return None ; } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_EMPTY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/entropy__source_8hpp/","text":"batteries/state_machine_model/entropy_source.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::BasicStateMachineEntropySource class batt::BasicStateMachineEntropySource Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP #define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_executor.hpp> #include <batteries/async/handler.hpp> #include <batteries/int_types.hpp> #include <batteries/static_dispatch.hpp> #include <batteries/utility.hpp> #include <functional> #include <initializer_list> #include <tuple> #include <utility> namespace batt { // Forward-declaration. // template < typename Fn > class BasicStateMachineEntropySource ; // A type-erased entropy source. // using StateMachineEntropySource = BasicStateMachineEntropySource < std :: function < usize ( usize min_value , usize max_value ) >> ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Fn > class BasicStateMachineEntropySource { public : using PickIntFn = Fn ; // Allow default construction if `Fn` permits. // BasicStateMachineEntropySource () = default ; // Constructs a new entropy source from the given `pick_int` function. // explicit BasicStateMachineEntropySource ( PickIntFn && pick_int_fn ) noexcept : pick_int_ { BATT_FORWARD ( pick_int_fn )} { } // Returns an integer `i` non-deterministically, such that `i >= min_value && i <= max_value`. // usize pick_int ( usize min_value , usize max_value ) const { return this -> pick_int_ ( min_value , max_value ); } // Returns false or true. // bool pick_branch () const { return this -> pick_int ( 0 , 1 ) == 0 ; } // Returns one of the items in `values`, using `pick_int`. // template < typename T > T pick_one_of ( std :: initializer_list < T > values ) const { const usize index = this -> pick_int ( 0 , values . size () - 1 ); return * ( values . begin () + index ); } // If there is at least one runnable completion handler in `context`, one such handler is selected (via // `pick_int`) and invoked, and this function returns true. Else false is returned. // bool run_one ( FakeExecutionContext & context ) const { UniqueHandler <> handler = context . pop_ready_handler ([ this ]( usize count ) { return this -> pick_int ( 0 , count - 1 ); }); if ( ! handler ) { return false ; } handler (); return true ; } // Performs one of the passed action functions. Each `Fn` in `actions...` must be callable with no // arguments and its return type must be ignorable. // template < typename ... ActionFn > void do_one_of ( ActionFn && ... actions ) const { auto actions_tuple = std :: forward_as_tuple ( BATT_FORWARD ( actions )...); static_dispatch < usize , 0 , sizeof ...( ActionFn ) > ( this -> pick_int ( 0 , sizeof ...( ActionFn ) - 1 ), [ & ]( auto kI ) { std :: get < decltype ( kI ) :: value > ( std :: move ( actions_tuple ))(); }); } private : PickIntFn pick_int_ ; }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/entropy_source.hpp"},{"location":"_autogen/Files/entropy__source_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/entropy__source_8hpp/#classes","text":"Name class batt::BasicStateMachineEntropySource class batt::BasicStateMachineEntropySource","title":"Classes"},{"location":"_autogen/Files/entropy__source_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP","title":"Defines"},{"location":"_autogen/Files/entropy__source_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/entropy__source_8hpp/#batteries_state_machine_model_entropy_source_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP"},{"location":"_autogen/Files/entropy__source_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP #define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_executor.hpp> #include <batteries/async/handler.hpp> #include <batteries/int_types.hpp> #include <batteries/static_dispatch.hpp> #include <batteries/utility.hpp> #include <functional> #include <initializer_list> #include <tuple> #include <utility> namespace batt { // Forward-declaration. // template < typename Fn > class BasicStateMachineEntropySource ; // A type-erased entropy source. // using StateMachineEntropySource = BasicStateMachineEntropySource < std :: function < usize ( usize min_value , usize max_value ) >> ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Fn > class BasicStateMachineEntropySource { public : using PickIntFn = Fn ; // Allow default construction if `Fn` permits. // BasicStateMachineEntropySource () = default ; // Constructs a new entropy source from the given `pick_int` function. // explicit BasicStateMachineEntropySource ( PickIntFn && pick_int_fn ) noexcept : pick_int_ { BATT_FORWARD ( pick_int_fn )} { } // Returns an integer `i` non-deterministically, such that `i >= min_value && i <= max_value`. // usize pick_int ( usize min_value , usize max_value ) const { return this -> pick_int_ ( min_value , max_value ); } // Returns false or true. // bool pick_branch () const { return this -> pick_int ( 0 , 1 ) == 0 ; } // Returns one of the items in `values`, using `pick_int`. // template < typename T > T pick_one_of ( std :: initializer_list < T > values ) const { const usize index = this -> pick_int ( 0 , values . size () - 1 ); return * ( values . begin () + index ); } // If there is at least one runnable completion handler in `context`, one such handler is selected (via // `pick_int`) and invoked, and this function returns true. Else false is returned. // bool run_one ( FakeExecutionContext & context ) const { UniqueHandler <> handler = context . pop_ready_handler ([ this ]( usize count ) { return this -> pick_int ( 0 , count - 1 ); }); if ( ! handler ) { return false ; } handler (); return true ; } // Performs one of the passed action functions. Each `Fn` in `actions...` must be callable with no // arguments and its return type must be ignorable. // template < typename ... ActionFn > void do_one_of ( ActionFn && ... actions ) const { auto actions_tuple = std :: forward_as_tuple ( BATT_FORWARD ( actions )...); static_dispatch < usize , 0 , sizeof ...( ActionFn ) > ( this -> pick_int ( 0 , sizeof ...( ActionFn ) - 1 ), [ & ]( auto kI ) { std :: get < decltype ( kI ) :: value > ( std :: move ( actions_tuple ))(); }); } private : PickIntFn pick_int_ ; }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/env_8hpp/","text":"batteries/env.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ENV_HPP Macro Documentation \ud83d\udd17 BATTERIES_ENV_HPP \ud83d\udd17 1 #define BATTERIES_ENV_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ENV_HPP #define BATTERIES_ENV_HPP #include <batteries/config.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/optional.hpp> #include <batteries/stream_util.hpp> #include <cstddef> namespace batt { template < typename T > Optional < T > getenv_as ( const char * var_name ) { BATT_VLOG ( 1 ) << \"reading env variable '\" << var_name << \"'\" ; const char * var_value = std :: getenv ( var_name ); if ( var_value == nullptr ) { BATT_VLOG ( 1 ) << \"... not set\" ; return None ; } auto result = batt :: from_string < T > ( var_value ); BATT_VLOG ( 1 ) << \"... value is '\" << var_value << \"'; parsing as \" << typeid ( T ). name () << \" == \" << result ; return result ; } } // namespace batt #endif // BATTERIES_ENV_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/env.hpp"},{"location":"_autogen/Files/env_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/env_8hpp/#defines","text":"Name BATTERIES_ENV_HPP","title":"Defines"},{"location":"_autogen/Files/env_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/env_8hpp/#batteries_env_hpp","text":"1 #define BATTERIES_ENV_HPP()","title":"BATTERIES_ENV_HPP"},{"location":"_autogen/Files/env_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ENV_HPP #define BATTERIES_ENV_HPP #include <batteries/config.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/optional.hpp> #include <batteries/stream_util.hpp> #include <cstddef> namespace batt { template < typename T > Optional < T > getenv_as ( const char * var_name ) { BATT_VLOG ( 1 ) << \"reading env variable '\" << var_name << \"'\" ; const char * var_value = std :: getenv ( var_name ); if ( var_value == nullptr ) { BATT_VLOG ( 1 ) << \"... not set\" ; return None ; } auto result = batt :: from_string < T > ( var_value ); BATT_VLOG ( 1 ) << \"... value is '\" << var_value << \"'; parsing as \" << typeid ( T ). name () << \" == \" << result ; return result ; } } // namespace batt #endif // BATTERIES_ENV_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/","text":"batteries/state_machine_model/exhaustive_model_checker.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::StateMachineBranch class batt::ExhaustiveModelChecker Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP #define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP #include <batteries/config.hpp> // #include <batteries/state_machine_model/advanced_options.hpp> #include <batteries/state_machine_model/parallel_model_check_state.hpp> #include <batteries/state_machine_model/state_machine_result.hpp> #include <batteries/state_machine_model/state_machine_traits.hpp> #include <batteries/state_machine_model/verbose.hpp> #include <batteries/radix_queue.hpp> #include <batteries/stream_util.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename StateT , typename StateHash , typename StateEqual > struct StateMachineBranch { using state_type = StateT ; using state_hash_type = StateHash ; using state_equal_type = StateEqual ; using delta_type = RadixQueue < StateMachineTraits < StateT >:: kRadixQueueSize > ; state_type snapshot ; delta_type delta ; }; template < typename StateT , typename StateHash , typename StateEqual > inline std :: ostream & operator << ( std :: ostream & out , const StateMachineBranch < StateT , StateHash , StateEqual >& t ) { return out << \"Branch{\" << std :: endl << pretty_print_indent () << \".snapshot=\" << make_printable ( t . snapshot ) << \",\" << std :: endl << pretty_print_indent () << \".delta=\" << t . delta << \",\" << std :: endl << \"}\" ; } template < typename StateT , typename StateHash , typename StateEqual > inline bool operator == ( const StateMachineBranch < StateT , StateHash , StateEqual >& l , const StateMachineBranch < StateT , StateHash , StateEqual >& r ) { return StateEqual {}( l . snapshot , r . snapshot ) && l . delta == r . delta ; } template < typename StateT , typename StateHash , typename StateEqual > inline usize hash_value ( const StateMachineBranch < StateT , StateHash , StateEqual >& branch ) { return hash ( StateHash {}( branch . snapshot ), branch . delta ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename ModelT > class ExhaustiveModelChecker { public : using StateMachineModel = ModelT ; using Branch = typename StateMachineModel :: Branch ; using StateT = typename StateMachineModel :: state_type ; using Result = StateMachineResult ; using AdvancedOptions = StateMachineModelCheckAdvancedOptions ; using BranchDelta = typename Branch :: delta_type ; using VisitResult = typename StateMachineModel :: VisitResult ; BATT_STRONG_TYPEDEF ( bool , ForceSend ); explicit ExhaustiveModelChecker ( StateMachineModel & model , detail :: ParallelModelCheckState < Branch >& mesh , usize shard_i ) noexcept ; ~ ExhaustiveModelChecker () noexcept ; Result run (); usize pick_int ( usize min_value , usize max_value ); private : void explore ( Branch && branch , ForceSend force_send = ForceSend { false }); void enter_loop ( usize loop_counter ); bool pop_next (); //+++++++++++-+-+--+----- --- -- - - - - StateMachineModel & model_ ; const AdvancedOptions options_ = this -> model_ . advanced_options (); detail :: ParallelModelCheckState < Branch >& mesh_ ; const usize shard_i_ ; Optional < Branch > current_branch_ ; BranchDelta history_ ; std :: deque < Branch > queue_ ; Result result_ ; usize progress_reports_ = 0 ; }; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline ExhaustiveModelChecker < ModelT >:: ExhaustiveModelChecker ( StateMachineModel & model , detail :: ParallelModelCheckState < Branch >& mesh , usize shard_i ) noexcept : model_ { model } , mesh_ { mesh } , shard_i_ { shard_i } { BATT_CHECK_GT ( this -> mesh_ . shard_count , 0u ); BATT_CHECK_LT ( this -> shard_i_ , this -> mesh_ . shard_count ); this -> model_ . set_entropy ( StateMachineEntropySource {[ this ]( usize min_value , usize max_value ) { return this -> pick_int ( min_value , max_value ); }}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline ExhaustiveModelChecker < ModelT >::~ ExhaustiveModelChecker () noexcept { this -> model_ . set_entropy ( StateMachineEntropySource {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline usize ExhaustiveModelChecker < ModelT >:: pick_int ( usize min_value , usize max_value ) { if ( min_value == max_value ) { return min_value ; } BATT_CHECK_LT ( min_value , max_value ); const usize radix = max_value - min_value + 1 ; if ( ! this -> current_branch_ -> delta . empty ()) { auto before = this -> current_branch_ -> delta ; const usize value = this -> current_branch_ -> delta . pop ( radix ); this -> history_ . push ( radix , value ); BATT_STATE_MACHINE_VERBOSE () << \"pick_int(\" << min_value << \",\" << max_value << \") [delta=\" << before << \"] returning branch value: \" << ( min_value + value ); return min_value + value ; } for ( usize value = 1 ; value < radix ; ++ value ) { Branch to_explore { . snapshot = this -> current_branch_ -> snapshot , . delta = this -> history_ , }; to_explore . delta . push ( radix , value ); BATT_STATE_MACHINE_VERBOSE () << \"pick_int(\" << min_value << \",\" << max_value << \") -> \" << min_value << \"; queuing new branch: \" << ( min_value + value ) << \" [delta=\" << to_explore . delta << \"]\" ; this -> explore ( std :: move ( to_explore )); } this -> history_ . push ( radix , /*value=*/ 0 ); return /*value=*/ min_value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline void ExhaustiveModelChecker < ModelT >:: explore ( Branch && branch , ForceSend force_send ) { const usize dst_i = this -> mesh_ . find_shard ( branch ); // Update cross-shard branch hit rate stats. // if ( dst_i != this -> shard_i_ ) { this -> result_ . branch_miss_count += 1 ; } if ( dst_i == this -> shard_i_ && ! force_send ) { this -> result_ . branch_push_count += 1 ; this -> queue_ . emplace_back ( std :: move ( branch )); } else { this -> mesh_ . send ( /*src_i=*/ this -> shard_i_ , /*dst_i=*/ dst_i , std :: move ( branch )); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > void ExhaustiveModelChecker < ModelT >:: enter_loop ( usize loop_counter ) { // Flush outbound queues to other shards periodically to try to prevent stalls. // if ((( loop_counter + 1 ) % this -> options_ . max_loop_iterations_between_flush ) == 0 ) { if ( this -> mesh_ . shard_count > 1 ) { this -> mesh_ . flush_all ( this -> shard_i_ ); } } // Update elapsed time and send a progress report if necessary. // if ((( loop_counter + 1 ) % this -> options_ . max_loop_iterations_between_update ) == 0 ) { this -> result_ . update_elapsed_time (); const double elapsed_seconds = double ( this -> result_ . elapsed_ms ) / 1000.0 ; const usize required_reports = elapsed_seconds / this -> model_ . progress_report_interval_seconds (); if ( this -> progress_reports_ < required_reports ) { this -> progress_reports_ += 1 ; this -> model_ . report_progress ( this -> result_ ); } } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > bool ExhaustiveModelChecker < ModelT >:: pop_next () { for (;;) { while ( this -> queue_ . empty ()) { const usize size_before = this -> queue_ . size (); StatusOr < usize > n_recv = this -> mesh_ . recv ( this -> shard_i_ , this -> queue_ ); if ( ! n_recv . ok ()) { if ( n_recv . status () != batt :: StatusCode :: kClosed ) { this -> result_ . ok = false ; } return false ; } const usize size_after = this -> queue_ . size (); BATT_CHECK_EQ ( size_before , 0u ); BATT_CHECK_GT ( * n_recv , 0u ); BATT_CHECK_EQ ( size_after - size_before , * n_recv ); // Deduplicate incoming branches. // auto first_duplicate = std :: remove_if ( this -> queue_ . begin (), this -> queue_ . end (), [ & ]( const Branch & branch ) { const bool is_duplicate = branch . delta . empty () && ( this -> model_ . visit ( branch . snapshot , /*src_branch=*/ Branch {} // TODO [tastolfi 2022-01-24] restore the trace history when // merging `visited_` sets at the end of a parallel run. ) == VisitResult :: kSeenBefore ); return is_duplicate ; }); this -> queue_ . erase ( first_duplicate , this -> queue_ . end ()); this -> result_ . branch_push_count += this -> queue_ . size (); } BATT_CHECK ( ! this -> queue_ . empty ()); auto & next_branch = this -> queue_ . front (); const usize branch_shard_i = this -> mesh_ . find_shard ( next_branch ); BATT_CHECK_EQ ( branch_shard_i , this -> shard_i_ ); // Pop the next branch of the state graph to explore. // this -> current_branch_ = std :: move ( next_branch ); this -> history_ . clear (); this -> queue_ . pop_front (); this -> result_ . branch_pop_count += 1 ; return true ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > auto ExhaustiveModelChecker < ModelT >:: run () -> Result { // Clear current state. // this -> progress_reports_ = 0 ; this -> current_branch_ = None ; this -> history_ . clear (); this -> model_ . reset_visited_states (); this -> queue_ . clear (); // Initialize new state and seed the BFS for model checking. // { StateT s = this -> model_ . normalize ( this -> model_ . initialize ()); this -> explore ( Branch { . snapshot = std :: move ( s ), . delta = BranchDelta {}, }, ForceSend { true }); } this -> mesh_ . flush_all ( this -> shard_i_ ); BATT_CHECK_OK ( this -> mesh_ . wait_for_other_shards ()); BATT_CHECK_GT ( this -> mesh_ . total_pending_count -> load (), 0 ); this -> result_ . ok = true ; this -> result_ . state_count = 1 ; this -> result_ . start_time = std :: chrono :: steady_clock :: now (); const auto notify_finished = finally ([ & ] { this -> mesh_ . finished ( this -> shard_i_ ); this -> result_ . update_elapsed_time (); this -> model_ . report_progress ( this -> result_ ); }); for ( usize loop_counter = 0 ;; ++ loop_counter ) { // Perform top-of-loop maintenance tasks. // this -> enter_loop ( loop_counter ); // Pop the next branch off the queue (this may block on other shards if the local queue is empty). // if ( ! this -> pop_next ()) { break ; } // Enter the new state. // this -> model_ . enter_state ( this -> current_branch_ -> snapshot ); BATT_STATE_MACHINE_VERBOSE () << \" branch=\" << this -> current_branch_ -> delta ; // We should have already checked invariants for this state before enqueuing it for the first time // (and the initial state should always pass invariant checks), but one can never be too sure... // if ( ! this -> model_ . check_invariants ()) { this -> result_ . ok = false ; break ; } // Expand the \"out-edges\" of this node of the graph. // this -> model_ . step (); // Make sure the state machine hasn't violated any of its invariants. // if ( ! this -> model_ . check_invariants ()) { this -> result_ . ok = false ; break ; } // Grab the new state and normalize it. // StateT after = this -> model_ . normalize ( this -> model_ . leave_state ()); if ( after == this -> current_branch_ -> snapshot ) { BATT_STATE_MACHINE_VERBOSE () << \"(no state change) pruning self-branch\" ; this -> result_ . self_branch_count += 1 ; continue ; } // If this is the first time we are visiting the new state, add it to the queue and note how we // discovered it in the trace. // if ( this -> model_ . visit ( after , /*src_branch=*/ Branch { . snapshot = this -> current_branch_ -> snapshot , . delta = this -> history_ , }) == VisitResult :: kFirstTime ) { this -> result_ . state_count += 1 ; BATT_STATE_MACHINE_VERBOSE () << \"new state discovered\" ; // This is the branch (or \"out-edge\") that represents choosing 0 for all non-deterministic // variables inside `step()`. We added all the non-0 branches already inside // `pick_int`. // this -> explore ( Branch { . snapshot = after , . delta = BranchDelta {}, }); } else { BATT_STATE_MACHINE_VERBOSE () << \"state already visited; pruning\" ; } } return this -> result_ ; } } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/exhaustive_model_checker.hpp"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#classes","text":"Name struct batt::StateMachineBranch class batt::ExhaustiveModelChecker","title":"Classes"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP","title":"Defines"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#batteries_state_machine_model_exhaustive_model_checker_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP #define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP #include <batteries/config.hpp> // #include <batteries/state_machine_model/advanced_options.hpp> #include <batteries/state_machine_model/parallel_model_check_state.hpp> #include <batteries/state_machine_model/state_machine_result.hpp> #include <batteries/state_machine_model/state_machine_traits.hpp> #include <batteries/state_machine_model/verbose.hpp> #include <batteries/radix_queue.hpp> #include <batteries/stream_util.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename StateT , typename StateHash , typename StateEqual > struct StateMachineBranch { using state_type = StateT ; using state_hash_type = StateHash ; using state_equal_type = StateEqual ; using delta_type = RadixQueue < StateMachineTraits < StateT >:: kRadixQueueSize > ; state_type snapshot ; delta_type delta ; }; template < typename StateT , typename StateHash , typename StateEqual > inline std :: ostream & operator << ( std :: ostream & out , const StateMachineBranch < StateT , StateHash , StateEqual >& t ) { return out << \"Branch{\" << std :: endl << pretty_print_indent () << \".snapshot=\" << make_printable ( t . snapshot ) << \",\" << std :: endl << pretty_print_indent () << \".delta=\" << t . delta << \",\" << std :: endl << \"}\" ; } template < typename StateT , typename StateHash , typename StateEqual > inline bool operator == ( const StateMachineBranch < StateT , StateHash , StateEqual >& l , const StateMachineBranch < StateT , StateHash , StateEqual >& r ) { return StateEqual {}( l . snapshot , r . snapshot ) && l . delta == r . delta ; } template < typename StateT , typename StateHash , typename StateEqual > inline usize hash_value ( const StateMachineBranch < StateT , StateHash , StateEqual >& branch ) { return hash ( StateHash {}( branch . snapshot ), branch . delta ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename ModelT > class ExhaustiveModelChecker { public : using StateMachineModel = ModelT ; using Branch = typename StateMachineModel :: Branch ; using StateT = typename StateMachineModel :: state_type ; using Result = StateMachineResult ; using AdvancedOptions = StateMachineModelCheckAdvancedOptions ; using BranchDelta = typename Branch :: delta_type ; using VisitResult = typename StateMachineModel :: VisitResult ; BATT_STRONG_TYPEDEF ( bool , ForceSend ); explicit ExhaustiveModelChecker ( StateMachineModel & model , detail :: ParallelModelCheckState < Branch >& mesh , usize shard_i ) noexcept ; ~ ExhaustiveModelChecker () noexcept ; Result run (); usize pick_int ( usize min_value , usize max_value ); private : void explore ( Branch && branch , ForceSend force_send = ForceSend { false }); void enter_loop ( usize loop_counter ); bool pop_next (); //+++++++++++-+-+--+----- --- -- - - - - StateMachineModel & model_ ; const AdvancedOptions options_ = this -> model_ . advanced_options (); detail :: ParallelModelCheckState < Branch >& mesh_ ; const usize shard_i_ ; Optional < Branch > current_branch_ ; BranchDelta history_ ; std :: deque < Branch > queue_ ; Result result_ ; usize progress_reports_ = 0 ; }; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline ExhaustiveModelChecker < ModelT >:: ExhaustiveModelChecker ( StateMachineModel & model , detail :: ParallelModelCheckState < Branch >& mesh , usize shard_i ) noexcept : model_ { model } , mesh_ { mesh } , shard_i_ { shard_i } { BATT_CHECK_GT ( this -> mesh_ . shard_count , 0u ); BATT_CHECK_LT ( this -> shard_i_ , this -> mesh_ . shard_count ); this -> model_ . set_entropy ( StateMachineEntropySource {[ this ]( usize min_value , usize max_value ) { return this -> pick_int ( min_value , max_value ); }}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline ExhaustiveModelChecker < ModelT >::~ ExhaustiveModelChecker () noexcept { this -> model_ . set_entropy ( StateMachineEntropySource {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline usize ExhaustiveModelChecker < ModelT >:: pick_int ( usize min_value , usize max_value ) { if ( min_value == max_value ) { return min_value ; } BATT_CHECK_LT ( min_value , max_value ); const usize radix = max_value - min_value + 1 ; if ( ! this -> current_branch_ -> delta . empty ()) { auto before = this -> current_branch_ -> delta ; const usize value = this -> current_branch_ -> delta . pop ( radix ); this -> history_ . push ( radix , value ); BATT_STATE_MACHINE_VERBOSE () << \"pick_int(\" << min_value << \",\" << max_value << \") [delta=\" << before << \"] returning branch value: \" << ( min_value + value ); return min_value + value ; } for ( usize value = 1 ; value < radix ; ++ value ) { Branch to_explore { . snapshot = this -> current_branch_ -> snapshot , . delta = this -> history_ , }; to_explore . delta . push ( radix , value ); BATT_STATE_MACHINE_VERBOSE () << \"pick_int(\" << min_value << \",\" << max_value << \") -> \" << min_value << \"; queuing new branch: \" << ( min_value + value ) << \" [delta=\" << to_explore . delta << \"]\" ; this -> explore ( std :: move ( to_explore )); } this -> history_ . push ( radix , /*value=*/ 0 ); return /*value=*/ min_value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > inline void ExhaustiveModelChecker < ModelT >:: explore ( Branch && branch , ForceSend force_send ) { const usize dst_i = this -> mesh_ . find_shard ( branch ); // Update cross-shard branch hit rate stats. // if ( dst_i != this -> shard_i_ ) { this -> result_ . branch_miss_count += 1 ; } if ( dst_i == this -> shard_i_ && ! force_send ) { this -> result_ . branch_push_count += 1 ; this -> queue_ . emplace_back ( std :: move ( branch )); } else { this -> mesh_ . send ( /*src_i=*/ this -> shard_i_ , /*dst_i=*/ dst_i , std :: move ( branch )); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > void ExhaustiveModelChecker < ModelT >:: enter_loop ( usize loop_counter ) { // Flush outbound queues to other shards periodically to try to prevent stalls. // if ((( loop_counter + 1 ) % this -> options_ . max_loop_iterations_between_flush ) == 0 ) { if ( this -> mesh_ . shard_count > 1 ) { this -> mesh_ . flush_all ( this -> shard_i_ ); } } // Update elapsed time and send a progress report if necessary. // if ((( loop_counter + 1 ) % this -> options_ . max_loop_iterations_between_update ) == 0 ) { this -> result_ . update_elapsed_time (); const double elapsed_seconds = double ( this -> result_ . elapsed_ms ) / 1000.0 ; const usize required_reports = elapsed_seconds / this -> model_ . progress_report_interval_seconds (); if ( this -> progress_reports_ < required_reports ) { this -> progress_reports_ += 1 ; this -> model_ . report_progress ( this -> result_ ); } } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > bool ExhaustiveModelChecker < ModelT >:: pop_next () { for (;;) { while ( this -> queue_ . empty ()) { const usize size_before = this -> queue_ . size (); StatusOr < usize > n_recv = this -> mesh_ . recv ( this -> shard_i_ , this -> queue_ ); if ( ! n_recv . ok ()) { if ( n_recv . status () != batt :: StatusCode :: kClosed ) { this -> result_ . ok = false ; } return false ; } const usize size_after = this -> queue_ . size (); BATT_CHECK_EQ ( size_before , 0u ); BATT_CHECK_GT ( * n_recv , 0u ); BATT_CHECK_EQ ( size_after - size_before , * n_recv ); // Deduplicate incoming branches. // auto first_duplicate = std :: remove_if ( this -> queue_ . begin (), this -> queue_ . end (), [ & ]( const Branch & branch ) { const bool is_duplicate = branch . delta . empty () && ( this -> model_ . visit ( branch . snapshot , /*src_branch=*/ Branch {} // TODO [tastolfi 2022-01-24] restore the trace history when // merging `visited_` sets at the end of a parallel run. ) == VisitResult :: kSeenBefore ); return is_duplicate ; }); this -> queue_ . erase ( first_duplicate , this -> queue_ . end ()); this -> result_ . branch_push_count += this -> queue_ . size (); } BATT_CHECK ( ! this -> queue_ . empty ()); auto & next_branch = this -> queue_ . front (); const usize branch_shard_i = this -> mesh_ . find_shard ( next_branch ); BATT_CHECK_EQ ( branch_shard_i , this -> shard_i_ ); // Pop the next branch of the state graph to explore. // this -> current_branch_ = std :: move ( next_branch ); this -> history_ . clear (); this -> queue_ . pop_front (); this -> result_ . branch_pop_count += 1 ; return true ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename ModelT > auto ExhaustiveModelChecker < ModelT >:: run () -> Result { // Clear current state. // this -> progress_reports_ = 0 ; this -> current_branch_ = None ; this -> history_ . clear (); this -> model_ . reset_visited_states (); this -> queue_ . clear (); // Initialize new state and seed the BFS for model checking. // { StateT s = this -> model_ . normalize ( this -> model_ . initialize ()); this -> explore ( Branch { . snapshot = std :: move ( s ), . delta = BranchDelta {}, }, ForceSend { true }); } this -> mesh_ . flush_all ( this -> shard_i_ ); BATT_CHECK_OK ( this -> mesh_ . wait_for_other_shards ()); BATT_CHECK_GT ( this -> mesh_ . total_pending_count -> load (), 0 ); this -> result_ . ok = true ; this -> result_ . state_count = 1 ; this -> result_ . start_time = std :: chrono :: steady_clock :: now (); const auto notify_finished = finally ([ & ] { this -> mesh_ . finished ( this -> shard_i_ ); this -> result_ . update_elapsed_time (); this -> model_ . report_progress ( this -> result_ ); }); for ( usize loop_counter = 0 ;; ++ loop_counter ) { // Perform top-of-loop maintenance tasks. // this -> enter_loop ( loop_counter ); // Pop the next branch off the queue (this may block on other shards if the local queue is empty). // if ( ! this -> pop_next ()) { break ; } // Enter the new state. // this -> model_ . enter_state ( this -> current_branch_ -> snapshot ); BATT_STATE_MACHINE_VERBOSE () << \" branch=\" << this -> current_branch_ -> delta ; // We should have already checked invariants for this state before enqueuing it for the first time // (and the initial state should always pass invariant checks), but one can never be too sure... // if ( ! this -> model_ . check_invariants ()) { this -> result_ . ok = false ; break ; } // Expand the \"out-edges\" of this node of the graph. // this -> model_ . step (); // Make sure the state machine hasn't violated any of its invariants. // if ( ! this -> model_ . check_invariants ()) { this -> result_ . ok = false ; break ; } // Grab the new state and normalize it. // StateT after = this -> model_ . normalize ( this -> model_ . leave_state ()); if ( after == this -> current_branch_ -> snapshot ) { BATT_STATE_MACHINE_VERBOSE () << \"(no state change) pruning self-branch\" ; this -> result_ . self_branch_count += 1 ; continue ; } // If this is the first time we are visiting the new state, add it to the queue and note how we // discovered it in the trace. // if ( this -> model_ . visit ( after , /*src_branch=*/ Branch { . snapshot = this -> current_branch_ -> snapshot , . delta = this -> history_ , }) == VisitResult :: kFirstTime ) { this -> result_ . state_count += 1 ; BATT_STATE_MACHINE_VERBOSE () << \"new state discovered\" ; // This is the branch (or \"out-edge\") that represents choosing 0 for all non-deterministic // variables inside `step()`. We added all the non-0 branches already inside // `pick_int`. // this -> explore ( Branch { . snapshot = after , . delta = BranchDelta {}, }); } else { BATT_STATE_MACHINE_VERBOSE () << \"state already visited; pruning\" ; } } return this -> result_ ; } } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__execution__context_8hpp/","text":"batteries/async/fake_execution_context.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/fake_execution_context_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_execution_context.hpp"},{"location":"_autogen/Files/fake__execution__context_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/fake_execution_context_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/","text":"batteries/async/fake_execution_context_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::BasicFakeExecutor class batt::FakeExecutionContext struct batt::FakeExecutionContext::AlwaysReturnZero Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP #include <batteries/config.hpp> // #include <batteries/async/handler.hpp> #include <batteries/async/watch_decl.hpp> #include <batteries/int_types.hpp> #include <boost/asio/execution_context.hpp> #include <functional> #include <mutex> #include <vector> namespace batt { template < typename OutstandingWorkP > class BasicFakeExecutor ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A drop-in replacement for boost::asio::io_context, suitable for fake-testing in unit tests. // // Unlike a \"real\" execution context, this class doesn't // class FakeExecutionContext : public boost :: asio :: execution_context { public : template < typename OutstandingWorkP > friend class BasicFakeExecutor ; struct AlwaysReturnZero { usize operator ()( usize ) const { return 0 ; } }; using executor_type = BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; FakeExecutionContext () = default ; ~ FakeExecutionContext () = default ; executor_type get_executor (); // The current work count. // Watch < i64 >& work_count (); // Add a ready-to-run completion handler to the context. This handler is never run automatically by the // FakeExecutionContext; it must be removed via `pop_ready_handler` and run by the client code. // void push_ready_handler ( UniqueHandler <>&& handler ); // Passes `picker` the current number of ready-to-run completion handlers for this executor; picker then // returns some non-negative integer smaller than this number. This method then removes that handler from // the ready set and returns it. // UniqueHandler <> pop_ready_handler ( const std :: function < usize ( usize ) >& picker = AlwaysReturnZero {}); // Access the default allocator directly. // std :: allocator < void > get_allocator () const { return this -> allocator_ ; } // Shortcut to pop an arbitrary ready handler and run it. // bool poll_one (); // Shortcut to pop all ready handlers and run them. // usize poll (); // Shortcut to wait for ready handlers and run them, while work count is > 0. // usize run (); private : Watch < i64 > work_count_ { 0 }; Watch < i64 > push_ready_count_ { 0 }; Watch < i64 > pop_ready_count_ { 0 }; std :: allocator < void > allocator_ ; std :: mutex mutex_ ; std :: vector < UniqueHandler <>> ready_to_run_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_execution_context_decl.hpp"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#classes","text":"Name class batt::BasicFakeExecutor class batt::FakeExecutionContext struct batt::FakeExecutionContext::AlwaysReturnZero","title":"Classes"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#batteries_async_fake_execution_context_decl_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP()","title":"BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP #include <batteries/config.hpp> // #include <batteries/async/handler.hpp> #include <batteries/async/watch_decl.hpp> #include <batteries/int_types.hpp> #include <boost/asio/execution_context.hpp> #include <functional> #include <mutex> #include <vector> namespace batt { template < typename OutstandingWorkP > class BasicFakeExecutor ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A drop-in replacement for boost::asio::io_context, suitable for fake-testing in unit tests. // // Unlike a \"real\" execution context, this class doesn't // class FakeExecutionContext : public boost :: asio :: execution_context { public : template < typename OutstandingWorkP > friend class BasicFakeExecutor ; struct AlwaysReturnZero { usize operator ()( usize ) const { return 0 ; } }; using executor_type = BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; FakeExecutionContext () = default ; ~ FakeExecutionContext () = default ; executor_type get_executor (); // The current work count. // Watch < i64 >& work_count (); // Add a ready-to-run completion handler to the context. This handler is never run automatically by the // FakeExecutionContext; it must be removed via `pop_ready_handler` and run by the client code. // void push_ready_handler ( UniqueHandler <>&& handler ); // Passes `picker` the current number of ready-to-run completion handlers for this executor; picker then // returns some non-negative integer smaller than this number. This method then removes that handler from // the ready set and returns it. // UniqueHandler <> pop_ready_handler ( const std :: function < usize ( usize ) >& picker = AlwaysReturnZero {}); // Access the default allocator directly. // std :: allocator < void > get_allocator () const { return this -> allocator_ ; } // Shortcut to pop an arbitrary ready handler and run it. // bool poll_one (); // Shortcut to pop all ready handlers and run them. // usize poll (); // Shortcut to wait for ready handlers and run them, while work count is > 0. // usize run (); private : Watch < i64 > work_count_ { 0 }; Watch < i64 > push_ready_count_ { 0 }; Watch < i64 > pop_ready_count_ { 0 }; std :: allocator < void > allocator_ ; std :: mutex mutex_ ; std :: vector < UniqueHandler <>> ready_to_run_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/","text":"batteries/async/fake_execution_context_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context_decl.hpp> #include <batteries/async/fake_executor.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL FakeExecutor FakeExecutionContext :: get_executor () { return FakeExecutor { this }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Watch < i64 >& FakeExecutionContext :: work_count () { BATT_CHECK_GE ( this -> work_count_ . get_value (), 0 ); return this -> work_count_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void FakeExecutionContext :: push_ready_handler ( UniqueHandler <>&& handler ) { if ( ! handler ) { return ; } { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; this -> ready_to_run_ . emplace_back ( std :: move ( handler )); } this -> push_ready_count_ . fetch_add ( 1 ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL UniqueHandler <> FakeExecutionContext :: pop_ready_handler ( const std :: function < usize ( usize ) >& picker ) { UniqueHandler <> popped_handler ; { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; if ( this -> ready_to_run_ . empty ()) { return UniqueHandler <> {}; } const usize next_i = picker ( this -> ready_to_run_ . size ()); BATT_CHECK_LT ( next_i , this -> ready_to_run_ . size ()); popped_handler = std :: move ( this -> ready_to_run_ [ next_i ]); if ( next_i != this -> ready_to_run_ . size () - 1 ) { this -> ready_to_run_ [ next_i ] = std :: move ( this -> ready_to_run_ . back ()); } this -> ready_to_run_ . pop_back (); } this -> pop_ready_count_ . fetch_add ( 1 ); return popped_handler ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool FakeExecutionContext :: poll_one () { UniqueHandler <> handler = this -> pop_ready_handler ([]( usize ) { return usize { 0 }; }); if ( ! handler ) { return false ; } handler (); return true ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize FakeExecutionContext :: poll () { usize count = 0 ; while ( this -> poll_one ()) { count += 1 ; } return count ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize FakeExecutionContext :: run () { BATT_PANIC () << \"TODO [tastolfi 2022-01-19] implement me\" ; BATT_UNREACHABLE (); /* usize count = 0; i64 observed_push_count = this->push_ready_count_.get_value(); for (;;) { } */ } } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_execution_context_impl.hpp"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#batteries_async_fake_execution_context_impl_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP()","title":"BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context_decl.hpp> #include <batteries/async/fake_executor.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL FakeExecutor FakeExecutionContext :: get_executor () { return FakeExecutor { this }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Watch < i64 >& FakeExecutionContext :: work_count () { BATT_CHECK_GE ( this -> work_count_ . get_value (), 0 ); return this -> work_count_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void FakeExecutionContext :: push_ready_handler ( UniqueHandler <>&& handler ) { if ( ! handler ) { return ; } { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; this -> ready_to_run_ . emplace_back ( std :: move ( handler )); } this -> push_ready_count_ . fetch_add ( 1 ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL UniqueHandler <> FakeExecutionContext :: pop_ready_handler ( const std :: function < usize ( usize ) >& picker ) { UniqueHandler <> popped_handler ; { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; if ( this -> ready_to_run_ . empty ()) { return UniqueHandler <> {}; } const usize next_i = picker ( this -> ready_to_run_ . size ()); BATT_CHECK_LT ( next_i , this -> ready_to_run_ . size ()); popped_handler = std :: move ( this -> ready_to_run_ [ next_i ]); if ( next_i != this -> ready_to_run_ . size () - 1 ) { this -> ready_to_run_ [ next_i ] = std :: move ( this -> ready_to_run_ . back ()); } this -> ready_to_run_ . pop_back (); } this -> pop_ready_count_ . fetch_add ( 1 ); return popped_handler ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool FakeExecutionContext :: poll_one () { UniqueHandler <> handler = this -> pop_ready_handler ([]( usize ) { return usize { 0 }; }); if ( ! handler ) { return false ; } handler (); return true ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize FakeExecutionContext :: poll () { usize count = 0 ; while ( this -> poll_one ()) { count += 1 ; } return count ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize FakeExecutionContext :: run () { BATT_PANIC () << \"TODO [tastolfi 2022-01-19] implement me\" ; BATT_UNREACHABLE (); /* usize count = 0; i64 observed_push_count = this->push_ready_count_.get_value(); for (;;) { } */ } } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__executor_8hpp/","text":"batteries/async/fake_executor.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> // #include <batteries/async/fake_executor_decl.hpp> #include <batteries/async/fake_executor_impl.ipp> #if BATT_HEADER_ONLY #include <batteries/async/fake_executor_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_executor.hpp"},{"location":"_autogen/Files/fake__executor_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> // #include <batteries/async/fake_executor_decl.hpp> #include <batteries/async/fake_executor_impl.ipp> #if BATT_HEADER_ONLY #include <batteries/async/fake_executor_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__executor__decl_8hpp/","text":"batteries/async/fake_executor_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::BasicFakeExecutor class batt::BasicFakeExecutor Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <boost/asio/any_io_executor.hpp> #include <memory> namespace batt { class FakeExecutionContext ; template < typename OutstandingWorkP > class BasicFakeExecutor ; using FakeExecutor = BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename OutstandingWorkP > constexpr bool operator == ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept ; template < typename OutstandingWorkP > constexpr bool operator != ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename OutstandingWorkP > class BasicFakeExecutor { public : using Self = BasicFakeExecutor ; //+++++++++++-+-+--+----- --- -- - - - - constexpr explicit BasicFakeExecutor () noexcept : context_ { nullptr } { } constexpr explicit BasicFakeExecutor ( FakeExecutionContext * context ) noexcept : context_ { context } { if ( std :: is_same_v < OutstandingWorkP , boost :: asio :: execution :: outstanding_work_t :: tracked_t > ) { this -> on_work_started (); } } constexpr BasicFakeExecutor ( const Self & other ) noexcept : Self { other . context_ } { } constexpr BasicFakeExecutor ( Self && other ) noexcept : context_ { other . context_ } { other . context_ = nullptr ; } //+++++++++++-+-+--+----- --- -- - - - - Self & operator = ( const Self & other ) noexcept { Self tmp { other }; this -> swap ( tmp ); return * this ; } Self & operator = ( Self && other ) noexcept { Self tmp { std :: move ( other )}; this -> swap ( tmp ); return * this ; } //+++++++++++-+-+--+----- --- -- - - - - ~ BasicFakeExecutor () noexcept { if ( std :: is_same_v < OutstandingWorkP , boost :: asio :: execution :: outstanding_work_t :: tracked_t > ) { this -> on_work_finished (); } } //+++++++++++-+-+--+----- --- -- - - - - void swap ( Self & other ) { std :: swap ( this -> context_ , other . context_ ); } //+++++++++++-+-+--+----- --- -- - - - - FakeExecutionContext & context () const { return * this -> context_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: blocking_t :: possibly_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: blocking_t :: never_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: relationship_t :: fork_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: relationship_t :: continuation_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: tracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - template < typename OtherAllocator > constexpr Self require ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: allocator_t < void > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: possibly_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: never_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: fork_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: continuation_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: tracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - template < typename OtherAllocator > constexpr Self prefer ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: allocator_t < void > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - static constexpr boost :: asio :: execution :: mapping_t query ( boost :: asio :: execution :: mapping_t ) noexcept { return boost :: asio :: execution :: mapping . thread ; } //+++++++++++-+-+--+----- --- -- - - - - FakeExecutionContext & query ( boost :: asio :: execution :: context_t ) const noexcept ; boost :: asio :: execution_context & query ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) const noexcept ; //+++++++++++-+-+--+----- --- -- - - - - constexpr boost :: asio :: execution :: blocking_t query ( boost :: asio :: execution :: blocking_t ) const noexcept { return boost :: asio :: execution :: blocking_t ( boost :: asio :: execution :: blocking . never ); } //+++++++++++-+-+--+----- --- -- - - - - constexpr boost :: asio :: execution :: relationship_t query ( boost :: asio :: execution :: relationship_t ) const noexcept { return boost :: asio :: execution :: relationship_t ( boost :: asio :: execution :: relationship . continuation ); } //+++++++++++-+-+--+----- --- -- - - - - // static constexpr boost :: asio :: execution :: outstanding_work_t query ( boost :: asio :: execution :: outstanding_work_t ) noexcept { return ( std :: is_same_v < OutstandingWorkP , boost :: asio :: execution :: outstanding_work_t :: tracked_t > ) ? boost :: asio :: execution :: outstanding_work_t ( boost :: asio :: execution :: outstanding_work . tracked ) : boost :: asio :: execution :: outstanding_work_t ( boost :: asio :: execution :: outstanding_work . untracked ); } //+++++++++++-+-+--+----- --- -- - - - - // template < typename OtherAllocator > constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const noexcept ; //+++++++++++-+-+--+----- --- -- - - - - // constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < void > ) const noexcept ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - void on_work_started () const ; void on_work_finished () const ; template < typename Fn > void execute ( Fn && fn ) const ; template < typename Fn , typename FnAllocator > void dispatch ( Fn && fn , FnAllocator && ) const { this -> execute ( fn ); } template < typename Fn , typename FnAllocator > void post ( Fn && fn , FnAllocator && ) const { this -> execute ( fn ); } template < typename Fn , typename FnAllocator > void defer ( Fn && fn , FnAllocator && ) const { this -> execute ( fn ); } private : FakeExecutionContext * context_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_executor_decl.hpp"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#classes","text":"Name class batt::BasicFakeExecutor class batt::BasicFakeExecutor","title":"Classes"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#batteries_async_fake_executor_decl_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP()","title":"BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <boost/asio/any_io_executor.hpp> #include <memory> namespace batt { class FakeExecutionContext ; template < typename OutstandingWorkP > class BasicFakeExecutor ; using FakeExecutor = BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename OutstandingWorkP > constexpr bool operator == ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept ; template < typename OutstandingWorkP > constexpr bool operator != ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename OutstandingWorkP > class BasicFakeExecutor { public : using Self = BasicFakeExecutor ; //+++++++++++-+-+--+----- --- -- - - - - constexpr explicit BasicFakeExecutor () noexcept : context_ { nullptr } { } constexpr explicit BasicFakeExecutor ( FakeExecutionContext * context ) noexcept : context_ { context } { if ( std :: is_same_v < OutstandingWorkP , boost :: asio :: execution :: outstanding_work_t :: tracked_t > ) { this -> on_work_started (); } } constexpr BasicFakeExecutor ( const Self & other ) noexcept : Self { other . context_ } { } constexpr BasicFakeExecutor ( Self && other ) noexcept : context_ { other . context_ } { other . context_ = nullptr ; } //+++++++++++-+-+--+----- --- -- - - - - Self & operator = ( const Self & other ) noexcept { Self tmp { other }; this -> swap ( tmp ); return * this ; } Self & operator = ( Self && other ) noexcept { Self tmp { std :: move ( other )}; this -> swap ( tmp ); return * this ; } //+++++++++++-+-+--+----- --- -- - - - - ~ BasicFakeExecutor () noexcept { if ( std :: is_same_v < OutstandingWorkP , boost :: asio :: execution :: outstanding_work_t :: tracked_t > ) { this -> on_work_finished (); } } //+++++++++++-+-+--+----- --- -- - - - - void swap ( Self & other ) { std :: swap ( this -> context_ , other . context_ ); } //+++++++++++-+-+--+----- --- -- - - - - FakeExecutionContext & context () const { return * this -> context_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: blocking_t :: possibly_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: blocking_t :: never_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: relationship_t :: fork_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: relationship_t :: continuation_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: tracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto require ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - template < typename OtherAllocator > constexpr Self require ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self require ( boost :: asio :: execution :: allocator_t < void > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: possibly_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: blocking_t :: never_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: fork_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: relationship_t :: continuation_t ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: tracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: tracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - constexpr auto prefer ( boost :: asio :: execution :: outstanding_work_t :: untracked_t ) const { return BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > { this -> context_ }; } //+++++++++++-+-+--+----- --- -- - - - - template < typename OtherAllocator > constexpr Self prefer ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - constexpr Self prefer ( boost :: asio :: execution :: allocator_t < void > ) const { return * this ; } //+++++++++++-+-+--+----- --- -- - - - - static constexpr boost :: asio :: execution :: mapping_t query ( boost :: asio :: execution :: mapping_t ) noexcept { return boost :: asio :: execution :: mapping . thread ; } //+++++++++++-+-+--+----- --- -- - - - - FakeExecutionContext & query ( boost :: asio :: execution :: context_t ) const noexcept ; boost :: asio :: execution_context & query ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) const noexcept ; //+++++++++++-+-+--+----- --- -- - - - - constexpr boost :: asio :: execution :: blocking_t query ( boost :: asio :: execution :: blocking_t ) const noexcept { return boost :: asio :: execution :: blocking_t ( boost :: asio :: execution :: blocking . never ); } //+++++++++++-+-+--+----- --- -- - - - - constexpr boost :: asio :: execution :: relationship_t query ( boost :: asio :: execution :: relationship_t ) const noexcept { return boost :: asio :: execution :: relationship_t ( boost :: asio :: execution :: relationship . continuation ); } //+++++++++++-+-+--+----- --- -- - - - - // static constexpr boost :: asio :: execution :: outstanding_work_t query ( boost :: asio :: execution :: outstanding_work_t ) noexcept { return ( std :: is_same_v < OutstandingWorkP , boost :: asio :: execution :: outstanding_work_t :: tracked_t > ) ? boost :: asio :: execution :: outstanding_work_t ( boost :: asio :: execution :: outstanding_work . tracked ) : boost :: asio :: execution :: outstanding_work_t ( boost :: asio :: execution :: outstanding_work . untracked ); } //+++++++++++-+-+--+----- --- -- - - - - // template < typename OtherAllocator > constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < OtherAllocator > ) const noexcept ; //+++++++++++-+-+--+----- --- -- - - - - // constexpr std :: allocator < void > query ( boost :: asio :: execution :: allocator_t < void > ) const noexcept ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - void on_work_started () const ; void on_work_finished () const ; template < typename Fn > void execute ( Fn && fn ) const ; template < typename Fn , typename FnAllocator > void dispatch ( Fn && fn , FnAllocator && ) const { this -> execute ( fn ); } template < typename Fn , typename FnAllocator > void post ( Fn && fn , FnAllocator && ) const { this -> execute ( fn ); } template < typename Fn , typename FnAllocator > void defer ( Fn && fn , FnAllocator && ) const { this -> execute ( fn ); } private : FakeExecutionContext * context_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__executor__impl_8hpp/","text":"batteries/async/fake_executor_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_executor_decl.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL FakeExecutionContext & BasicFakeExecutor < OutstandingWorkP >:: query ( boost :: asio :: execution :: context_t ) const noexcept { return * this -> context_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL boost :: asio :: execution_context & BasicFakeExecutor < OutstandingWorkP >:: query ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) const noexcept { return * this -> context_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL constexpr std :: allocator < void > BasicFakeExecutor < OutstandingWorkP >:: query ( boost :: asio :: execution :: allocator_t < void > ) const noexcept { return this -> context_ -> allocator_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL void BasicFakeExecutor < OutstandingWorkP >:: on_work_started () const { if ( this -> context_ != nullptr ) { BATT_CHECK_NE ( this -> context_ -> work_count_ . fetch_add ( 1 ) + 1u , 0u ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL void BasicFakeExecutor < OutstandingWorkP >:: on_work_finished () const { if ( this -> context_ != nullptr ) { BATT_CHECK_GT ( this -> context_ -> work_count_ . fetch_sub ( 1 ), 0u ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL constexpr bool operator == ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept { return & ( l . context ()) == & ( r . context ()); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL constexpr bool operator != ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept { return ! ( l == r ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Explicit instantiations. // template class BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: tracked_t > ; template class BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ // Type requirement checks. static_assert ( std :: is_constructible < boost :: asio :: any_io_executor , FakeExecutor > {}, \"If this check fails, hopefully one or more of the following more scoped checks will fail as \" \"well, which will help with debugging!\" ); static_assert ( boost :: asio :: execution :: can_execute < FakeExecutor , boost :: asio :: execution :: invocable_archetype >:: value , \"\" ); static_assert ( std :: is_same_v < bool , decltype ( std :: declval < const FakeExecutor > () == std :: declval < const FakeExecutor > ()) > , \"\" ); static_assert ( std :: is_same_v < bool , decltype ( std :: declval < const FakeExecutor > () != std :: declval < const FakeExecutor > ()) > , \"\" ); static_assert ( std :: is_nothrow_copy_constructible < FakeExecutor >:: value , \"\" ); static_assert ( std :: is_nothrow_destructible < FakeExecutor >:: value , \"\" ); static_assert ( boost :: asio :: traits :: equality_comparable < FakeExecutor >:: is_valid , \"\" ); static_assert ( boost :: asio :: traits :: equality_comparable < FakeExecutor >:: is_noexcept , \"\" ); static_assert ( boost :: asio :: execution :: is_executor_v < FakeExecutor > , \"\" ); static_assert ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &>:: is_applicable_property_v < FakeExecutor > , \"\" ); static_assert ( boost :: asio :: can_query < FakeExecutor , boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &>>:: value || true , \"\" ); static_assert ( boost :: asio :: is_applicable_property_v < FakeExecutor , boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &>> , \"\" ); static_assert ( boost :: asio :: execution :: detail :: supportable_properties < 0 , void ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) >:: template is_valid_target < FakeExecutor >:: value || true , \"\" ); static_assert ( boost :: asio :: execution :: detail :: is_valid_target_executor < FakeExecutor , void ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) >:: value , \"\" ); static_assert ( std :: is_same_v < decltype ( boost :: asio :: query ( std :: declval < const FakeExecutor > (), boost :: asio :: execution :: context_as < boost :: asio :: execution_context &> )), boost :: asio :: execution_context &> , \"\" ); } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_executor_impl.hpp"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#batteries_async_fake_executor_impl_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP()","title":"BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP #define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_executor_decl.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL FakeExecutionContext & BasicFakeExecutor < OutstandingWorkP >:: query ( boost :: asio :: execution :: context_t ) const noexcept { return * this -> context_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL boost :: asio :: execution_context & BasicFakeExecutor < OutstandingWorkP >:: query ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) const noexcept { return * this -> context_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL constexpr std :: allocator < void > BasicFakeExecutor < OutstandingWorkP >:: query ( boost :: asio :: execution :: allocator_t < void > ) const noexcept { return this -> context_ -> allocator_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL void BasicFakeExecutor < OutstandingWorkP >:: on_work_started () const { if ( this -> context_ != nullptr ) { BATT_CHECK_NE ( this -> context_ -> work_count_ . fetch_add ( 1 ) + 1u , 0u ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL void BasicFakeExecutor < OutstandingWorkP >:: on_work_finished () const { if ( this -> context_ != nullptr ) { BATT_CHECK_GT ( this -> context_ -> work_count_ . fetch_sub ( 1 ), 0u ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL constexpr bool operator == ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept { return & ( l . context ()) == & ( r . context ()); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename OutstandingWorkP > BATT_INLINE_IMPL constexpr bool operator != ( const BasicFakeExecutor < OutstandingWorkP >& l , const BasicFakeExecutor < OutstandingWorkP >& r ) noexcept { return ! ( l == r ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Explicit instantiations. // template class BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: tracked_t > ; template class BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ // Type requirement checks. static_assert ( std :: is_constructible < boost :: asio :: any_io_executor , FakeExecutor > {}, \"If this check fails, hopefully one or more of the following more scoped checks will fail as \" \"well, which will help with debugging!\" ); static_assert ( boost :: asio :: execution :: can_execute < FakeExecutor , boost :: asio :: execution :: invocable_archetype >:: value , \"\" ); static_assert ( std :: is_same_v < bool , decltype ( std :: declval < const FakeExecutor > () == std :: declval < const FakeExecutor > ()) > , \"\" ); static_assert ( std :: is_same_v < bool , decltype ( std :: declval < const FakeExecutor > () != std :: declval < const FakeExecutor > ()) > , \"\" ); static_assert ( std :: is_nothrow_copy_constructible < FakeExecutor >:: value , \"\" ); static_assert ( std :: is_nothrow_destructible < FakeExecutor >:: value , \"\" ); static_assert ( boost :: asio :: traits :: equality_comparable < FakeExecutor >:: is_valid , \"\" ); static_assert ( boost :: asio :: traits :: equality_comparable < FakeExecutor >:: is_noexcept , \"\" ); static_assert ( boost :: asio :: execution :: is_executor_v < FakeExecutor > , \"\" ); static_assert ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &>:: is_applicable_property_v < FakeExecutor > , \"\" ); static_assert ( boost :: asio :: can_query < FakeExecutor , boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &>>:: value || true , \"\" ); static_assert ( boost :: asio :: is_applicable_property_v < FakeExecutor , boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &>> , \"\" ); static_assert ( boost :: asio :: execution :: detail :: supportable_properties < 0 , void ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) >:: template is_valid_target < FakeExecutor >:: value || true , \"\" ); static_assert ( boost :: asio :: execution :: detail :: is_valid_target_executor < FakeExecutor , void ( boost :: asio :: execution :: context_as_t < boost :: asio :: execution_context &> ) >:: value , \"\" ); static_assert ( std :: is_same_v < decltype ( boost :: asio :: query ( std :: declval < const FakeExecutor > (), boost :: asio :: execution :: context_as < boost :: asio :: execution_context &> )), boost :: asio :: execution_context &> , \"\" ); } // namespace batt #endif // BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/","text":"batteries/async/fake_task_scheduler.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::FakeTaskScheduler class batt::FakeTaskScheduler::ScopeGuard Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP #define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context.hpp> #include <batteries/async/runtime.hpp> #include <batteries/async/task_scheduler.hpp> namespace batt { // A TaskScheduler that embeds a FakeExecutionContext; for model-based simulation testing. // class FakeTaskScheduler : public TaskScheduler { public : class ScopeGuard ; FakeTaskScheduler () = default ; FakeExecutionContext & get_context () { return this -> context_ ; } FakeExecutor get_executor () { return this -> context_ . get_executor (); } // Select an executor to run a new task. // boost :: asio :: any_io_executor schedule_task () override { return this -> get_executor (); } // Request shutdown of all threads/executors owned by this scheduler. Does not wait for shutdown // to complete; see TaskScheduler::join(). // void halt () override { // Nothing to do. } // Wait for shutdown of all threads/executors owned by this scheduler. Does not initiate shutdown // per se, just waits for shutdown to complete. See TaskScheduler::halt(). // void join () override { // Nothing to do. } private : FakeExecutionContext context_ ; }; class FakeTaskScheduler :: ScopeGuard { public : ScopeGuard ( const ScopeGuard & ) = delete ; ScopeGuard & operator = ( const ScopeGuard & ) = delete ; explicit ScopeGuard ( FakeTaskScheduler & scheduler ) noexcept : saved_ { Runtime :: instance (). exchange_task_scheduler ( & scheduler )} { } ~ ScopeGuard () noexcept { ( void ) Runtime :: instance (). exchange_task_scheduler ( this -> saved_ ); } private : TaskScheduler * saved_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_task_scheduler.hpp"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#classes","text":"Name class batt::FakeTaskScheduler class batt::FakeTaskScheduler::ScopeGuard","title":"Classes"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP","title":"Defines"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#batteries_async_fake_task_scheduler_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP()","title":"BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP #define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context.hpp> #include <batteries/async/runtime.hpp> #include <batteries/async/task_scheduler.hpp> namespace batt { // A TaskScheduler that embeds a FakeExecutionContext; for model-based simulation testing. // class FakeTaskScheduler : public TaskScheduler { public : class ScopeGuard ; FakeTaskScheduler () = default ; FakeExecutionContext & get_context () { return this -> context_ ; } FakeExecutor get_executor () { return this -> context_ . get_executor (); } // Select an executor to run a new task. // boost :: asio :: any_io_executor schedule_task () override { return this -> get_executor (); } // Request shutdown of all threads/executors owned by this scheduler. Does not wait for shutdown // to complete; see TaskScheduler::join(). // void halt () override { // Nothing to do. } // Wait for shutdown of all threads/executors owned by this scheduler. Does not initiate shutdown // per se, just waits for shutdown to complete. See TaskScheduler::halt(). // void join () override { // Nothing to do. } private : FakeExecutionContext context_ ; }; class FakeTaskScheduler :: ScopeGuard { public : ScopeGuard ( const ScopeGuard & ) = delete ; ScopeGuard & operator = ( const ScopeGuard & ) = delete ; explicit ScopeGuard ( FakeTaskScheduler & scheduler ) noexcept : saved_ { Runtime :: instance (). exchange_task_scheduler ( & scheduler )} { } ~ ScopeGuard () noexcept { ( void ) Runtime :: instance (). exchange_task_scheduler ( this -> saved_ ); } private : TaskScheduler * saved_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__time__service_8hpp/","text":"batteries/async/fake_time_service.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/fake_time_service_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/fake_time_service_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_time_service.hpp"},{"location":"_autogen/Files/fake__time__service_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/fake_time_service_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/fake_time_service_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/","text":"batteries/async/fake_time_service_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::FakeTimeService struct batt::FakeTimeService::TimerInstance struct batt::FakeTimeService::TimerInstance::Impl class batt::FakeTimeService::State Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP #include <batteries/config.hpp> // #include <batteries/async/handler.hpp> #include <batteries/async/io_result.hpp> #include <batteries/bounds.hpp> #include <boost/asio/any_io_executor.hpp> #include <boost/asio/execution_context.hpp> #include <boost/date_time/posix_time/ptime.hpp> #if defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wunused-parameter\" #if __GNUC__ >= 9 #pragma GCC diagnostic ignored \"-Wdeprecated-copy\" #endif // __GNUC__ >= 9 #endif // __GNUC__ #include <boost/heap/d_ary_heap.hpp> #include <boost/heap/policies.hpp> #include <memory> namespace batt { class FakeExecutionContext ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A time/timer service that virtualizes the passage of time, to implement simulations and tests. // class FakeTimeService : public boost :: asio :: execution_context :: service { public : using Self = FakeTimeService ; using TimePoint = boost :: posix_time :: ptime ; using Duration = boost :: posix_time :: time_duration ; struct TimerInstance { struct Impl { FakeTimeService * service_instance ; boost :: asio :: any_io_executor executor ; TimePoint expires_at ; UniqueHandler < ErrorCode > handler ; explicit Impl ( FakeTimeService * service , boost :: asio :: any_io_executor ex , TimePoint expire , UniqueHandler < ErrorCode > h ) : service_instance { service } , executor { ex } , expires_at { expire } , handler { std :: move ( h )} { } }; std :: shared_ptr < Impl > impl ; }; using TimerQueue = boost :: heap :: d_ary_heap < TimerInstance , // boost :: heap :: arity < 2 > , // boost :: heap :: compare < std :: greater <>> , // boost :: heap :: mutable_ < true > // > ; class State { public : using Lock = std :: unique_lock < std :: mutex > ; // Initialize the fake time service state. The initial value for `now` will be set to the current // local system time. // State (); // Returns the current fake time. // TimePoint now (); // Queue a timer for later invocation, or immediate invocation if \"fake time\" is at or beyond // `expires_at`. // template < typename HandlerFn > void schedule_timer ( FakeTimeService * service_instance , const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ); // // ^^ TODO [tastolfi 2022-01-14] return a timer id of some sort so we can implement cancel // Move \"fake time\" ahead by the specified amount. // void advance_time ( Duration delta ); private : std :: mutex mutex_ ; TimePoint fake_time_ ; TimerQueue timer_queue_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - static boost :: asio :: execution_context :: id id ; static State & state () { static State instance_ ; return instance_ ; } static TimePoint now () { return Self :: state (). now (); } static void advance_time ( Duration delta ) { Self :: state (). advance_time ( delta ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - explicit FakeTimeService ( boost :: asio :: execution_context & context ); void shutdown () override ; template < typename HandlerFn > void async_wait ( const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ) { Self :: state (). schedule_timer ( this , executor , expires_at , BATT_FORWARD ( fn )); } }; bool operator < ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r ); BATT_TOTALLY_ORDERED (( inline ), FakeTimeService :: TimerInstance , FakeTimeService :: TimerInstance ) } // namespace batt #endif // BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_time_service_decl.hpp"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#classes","text":"Name class batt::FakeTimeService struct batt::FakeTimeService::TimerInstance struct batt::FakeTimeService::TimerInstance::Impl class batt::FakeTimeService::State","title":"Classes"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#batteries_async_fake_time_service_decl_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP()","title":"BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP #include <batteries/config.hpp> // #include <batteries/async/handler.hpp> #include <batteries/async/io_result.hpp> #include <batteries/bounds.hpp> #include <boost/asio/any_io_executor.hpp> #include <boost/asio/execution_context.hpp> #include <boost/date_time/posix_time/ptime.hpp> #if defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wunused-parameter\" #if __GNUC__ >= 9 #pragma GCC diagnostic ignored \"-Wdeprecated-copy\" #endif // __GNUC__ >= 9 #endif // __GNUC__ #include <boost/heap/d_ary_heap.hpp> #include <boost/heap/policies.hpp> #include <memory> namespace batt { class FakeExecutionContext ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A time/timer service that virtualizes the passage of time, to implement simulations and tests. // class FakeTimeService : public boost :: asio :: execution_context :: service { public : using Self = FakeTimeService ; using TimePoint = boost :: posix_time :: ptime ; using Duration = boost :: posix_time :: time_duration ; struct TimerInstance { struct Impl { FakeTimeService * service_instance ; boost :: asio :: any_io_executor executor ; TimePoint expires_at ; UniqueHandler < ErrorCode > handler ; explicit Impl ( FakeTimeService * service , boost :: asio :: any_io_executor ex , TimePoint expire , UniqueHandler < ErrorCode > h ) : service_instance { service } , executor { ex } , expires_at { expire } , handler { std :: move ( h )} { } }; std :: shared_ptr < Impl > impl ; }; using TimerQueue = boost :: heap :: d_ary_heap < TimerInstance , // boost :: heap :: arity < 2 > , // boost :: heap :: compare < std :: greater <>> , // boost :: heap :: mutable_ < true > // > ; class State { public : using Lock = std :: unique_lock < std :: mutex > ; // Initialize the fake time service state. The initial value for `now` will be set to the current // local system time. // State (); // Returns the current fake time. // TimePoint now (); // Queue a timer for later invocation, or immediate invocation if \"fake time\" is at or beyond // `expires_at`. // template < typename HandlerFn > void schedule_timer ( FakeTimeService * service_instance , const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ); // // ^^ TODO [tastolfi 2022-01-14] return a timer id of some sort so we can implement cancel // Move \"fake time\" ahead by the specified amount. // void advance_time ( Duration delta ); private : std :: mutex mutex_ ; TimePoint fake_time_ ; TimerQueue timer_queue_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - static boost :: asio :: execution_context :: id id ; static State & state () { static State instance_ ; return instance_ ; } static TimePoint now () { return Self :: state (). now (); } static void advance_time ( Duration delta ) { Self :: state (). advance_time ( delta ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - explicit FakeTimeService ( boost :: asio :: execution_context & context ); void shutdown () override ; template < typename HandlerFn > void async_wait ( const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ) { Self :: state (). schedule_timer ( this , executor , expires_at , BATT_FORWARD ( fn )); } }; bool operator < ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r ); BATT_TOTALLY_ORDERED (( inline ), FakeTimeService :: TimerInstance , FakeTimeService :: TimerInstance ) } // namespace batt #endif // BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/","text":"batteries/async/fake_time_service_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context.hpp> #include <batteries/async/fake_time_service_decl.hpp> #include <boost/asio/post.hpp> #include <boost/asio/time_traits.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ boost :: asio :: execution_context :: id FakeTimeService :: id ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ FakeTimeService::FakeTimeService ( boost :: asio :: execution_context & context ) : boost :: asio :: execution_context :: service { context } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool operator < ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r ) { return ( l . impl == nullptr && r . impl != nullptr ) || (( l . impl != nullptr && r . impl != nullptr ) && ( l . impl -> expires_at < r . impl -> expires_at )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL FakeTimeService :: State :: State () : fake_time_ { boost :: asio :: time_traits < TimePoint >:: now ()} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto FakeTimeService :: State :: now () -> TimePoint { Lock lock { this -> mutex_ }; return this -> fake_time_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename HandlerFn > BATT_INLINE_IMPL void FakeTimeService :: State :: schedule_timer ( FakeTimeService * service_instance , const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ) { static_assert ( IsCallable < HandlerFn , ErrorCode > {}, \"async_wait handlers must be callable as: void(boost::system::error_code)\" ); // Check to see whether the timer has already expired. // if ( expires_at <= this -> now ()) { boost :: asio :: post ( executor , std :: bind ( BATT_FORWARD ( fn ), ErrorCode {})); return ; } UniqueHandler < ErrorCode > handler { BATT_FORWARD ( fn )}; TimerInstance timer_instance { std :: make_shared < TimerInstance :: Impl > ( service_instance , executor , expires_at , std :: move ( handler )), }; // Insert the timer into the timer_queue with the lock held. { Lock lock { this -> mutex_ }; this -> timer_queue_ . push ( std :: move ( timer_instance )); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void FakeTimeService :: State :: advance_time ( Duration delta ) { std :: vector < TimerInstance > expired_timers ; { Lock lock { this -> mutex_ }; this -> fake_time_ += delta ; while ( ! this -> timer_queue_ . empty () && this -> timer_queue_ . top (). impl -> expires_at <= this -> fake_time_ ) { expired_timers . emplace_back ( this -> timer_queue_ . top ()); timer_queue_ . pop (); } } for ( TimerInstance & timer : expired_timers ) { boost :: asio :: post ( timer . impl -> executor , std :: bind ( std :: move ( timer . impl -> handler ), ErrorCode {})); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void FakeTimeService :: shutdown () /*override*/ { // TODO [tastolfi 2022-01-14] how to cancel timers associated with this? } } // namespace batt #endif // BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/fake_time_service_impl.hpp"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#batteries_async_fake_time_service_impl_hpp","text":"1 #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP()","title":"BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP #define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/fake_execution_context.hpp> #include <batteries/async/fake_time_service_decl.hpp> #include <boost/asio/post.hpp> #include <boost/asio/time_traits.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ boost :: asio :: execution_context :: id FakeTimeService :: id ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ FakeTimeService::FakeTimeService ( boost :: asio :: execution_context & context ) : boost :: asio :: execution_context :: service { context } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool operator < ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r ) { return ( l . impl == nullptr && r . impl != nullptr ) || (( l . impl != nullptr && r . impl != nullptr ) && ( l . impl -> expires_at < r . impl -> expires_at )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL FakeTimeService :: State :: State () : fake_time_ { boost :: asio :: time_traits < TimePoint >:: now ()} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto FakeTimeService :: State :: now () -> TimePoint { Lock lock { this -> mutex_ }; return this -> fake_time_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename HandlerFn > BATT_INLINE_IMPL void FakeTimeService :: State :: schedule_timer ( FakeTimeService * service_instance , const boost :: asio :: any_io_executor & executor , TimePoint expires_at , HandlerFn && fn ) { static_assert ( IsCallable < HandlerFn , ErrorCode > {}, \"async_wait handlers must be callable as: void(boost::system::error_code)\" ); // Check to see whether the timer has already expired. // if ( expires_at <= this -> now ()) { boost :: asio :: post ( executor , std :: bind ( BATT_FORWARD ( fn ), ErrorCode {})); return ; } UniqueHandler < ErrorCode > handler { BATT_FORWARD ( fn )}; TimerInstance timer_instance { std :: make_shared < TimerInstance :: Impl > ( service_instance , executor , expires_at , std :: move ( handler )), }; // Insert the timer into the timer_queue with the lock held. { Lock lock { this -> mutex_ }; this -> timer_queue_ . push ( std :: move ( timer_instance )); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void FakeTimeService :: State :: advance_time ( Duration delta ) { std :: vector < TimerInstance > expired_timers ; { Lock lock { this -> mutex_ }; this -> fake_time_ += delta ; while ( ! this -> timer_queue_ . empty () && this -> timer_queue_ . top (). impl -> expires_at <= this -> fake_time_ ) { expired_timers . emplace_back ( this -> timer_queue_ . top ()); timer_queue_ . pop (); } } for ( TimerInstance & timer : expired_timers ) { boost :: asio :: post ( timer . impl -> executor , std :: bind ( std :: move ( timer . impl -> handler ), ErrorCode {})); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void FakeTimeService :: shutdown () /*override*/ { // TODO [tastolfi 2022-01-14] how to cancel timers associated with this? } } // namespace batt #endif // BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/filter_8hpp/","text":"batteries/seq/filter.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Filter struct batt::seq::FilterBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_FILTER_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_FILTER_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_FILTER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FILTER_HPP #define BATTERIES_SEQ_FILTER_HPP #include <batteries/config.hpp> #include <batteries/hint.hpp> #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // filter // template < typename Seq , typename Predicate > class Filter { public : using Item = SeqItem < Seq > ; explicit Filter ( Seq && seq , Predicate && predicate ) noexcept : seq_ ( BATT_FORWARD ( seq )) , predicate_ ( BATT_FORWARD ( predicate )) { } Filter ( Filter && that ) noexcept : seq_ ( BATT_FORWARD ( that . seq_ )), predicate_ ( BATT_FORWARD ( * that . predicate_ )) { } Filter & operator = ( Filter && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { seq_ = BATT_FORWARD ( that . seq_ ); predicate_ . emplace ( BATT_FORWARD ( * that . predicate_ )); } return * this ; } Filter ( const Filter & that ) : seq_ ( that . seq_ ), predicate_ ( * that . predicate_ ) { } Filter & operator = ( const Filter & that ) { if ( BATT_HINT_TRUE ( this != & that )) { seq_ = that . seq_ ; predicate_ . emplace ( * that . predicate_ ); } return * this ; } Optional < Item > peek () { for (;;) { Optional < Item > item = seq_ . peek (); if ( ! item || ( * predicate_ )( * item )) { return item ; } ( void ) seq_ . next (); } } Optional < Item > next () { for (;;) { Optional < Item > item = seq_ . next (); if ( ! item || ( * predicate_ )( * item )) { return item ; } } } //-------------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename Pred , typename EachFn > friend LoopControl operator | ( Filter < Seq_ , Pred >&& filter_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : Seq seq_ ; Optional < Predicate > predicate_ ; }; template < typename Predicate > struct FilterBinder { Predicate predicate ; }; template < typename Predicate > FilterBinder < Predicate > filter ( Predicate && predicate ) { return { BATT_FORWARD ( predicate )}; } template < typename Seq , typename Predicate > [[ nodiscard ]] Filter < Seq , Predicate > operator | ( Seq && seq , FilterBinder < Predicate >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Filtered sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Predicate , std :: decay_t < Predicate >> , \"Predicate functions may not be captured implicitly by reference.\" ); return Filter < Seq , Predicate > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . predicate )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq , typename Pred , typename EachFn > LoopControl operator | ( Filter < Seq , Pred >&& filter_seq , ForEachBinder < EachFn >&& binder ) { auto & pred_fn = * filter_seq . predicate_ ; auto loop_body = [ & ]( auto && item ) -> LoopControl { if ( ! pred_fn ( item )) { return kContinue ; } return run_loop_fn ( binder . fn , item ); }; return std :: forward < Seq > ( filter_seq . seq_ ) | for_each ( loop_body ); } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FILTER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/filter.hpp"},{"location":"_autogen/Files/filter_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/filter_8hpp/#classes","text":"Name class batt::seq::Filter struct batt::seq::FilterBinder","title":"Classes"},{"location":"_autogen/Files/filter_8hpp/#defines","text":"Name BATTERIES_SEQ_FILTER_HPP","title":"Defines"},{"location":"_autogen/Files/filter_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/filter_8hpp/#batteries_seq_filter_hpp","text":"1 #define BATTERIES_SEQ_FILTER_HPP()","title":"BATTERIES_SEQ_FILTER_HPP"},{"location":"_autogen/Files/filter_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FILTER_HPP #define BATTERIES_SEQ_FILTER_HPP #include <batteries/config.hpp> #include <batteries/hint.hpp> #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // filter // template < typename Seq , typename Predicate > class Filter { public : using Item = SeqItem < Seq > ; explicit Filter ( Seq && seq , Predicate && predicate ) noexcept : seq_ ( BATT_FORWARD ( seq )) , predicate_ ( BATT_FORWARD ( predicate )) { } Filter ( Filter && that ) noexcept : seq_ ( BATT_FORWARD ( that . seq_ )), predicate_ ( BATT_FORWARD ( * that . predicate_ )) { } Filter & operator = ( Filter && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { seq_ = BATT_FORWARD ( that . seq_ ); predicate_ . emplace ( BATT_FORWARD ( * that . predicate_ )); } return * this ; } Filter ( const Filter & that ) : seq_ ( that . seq_ ), predicate_ ( * that . predicate_ ) { } Filter & operator = ( const Filter & that ) { if ( BATT_HINT_TRUE ( this != & that )) { seq_ = that . seq_ ; predicate_ . emplace ( * that . predicate_ ); } return * this ; } Optional < Item > peek () { for (;;) { Optional < Item > item = seq_ . peek (); if ( ! item || ( * predicate_ )( * item )) { return item ; } ( void ) seq_ . next (); } } Optional < Item > next () { for (;;) { Optional < Item > item = seq_ . next (); if ( ! item || ( * predicate_ )( * item )) { return item ; } } } //-------------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename Pred , typename EachFn > friend LoopControl operator | ( Filter < Seq_ , Pred >&& filter_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : Seq seq_ ; Optional < Predicate > predicate_ ; }; template < typename Predicate > struct FilterBinder { Predicate predicate ; }; template < typename Predicate > FilterBinder < Predicate > filter ( Predicate && predicate ) { return { BATT_FORWARD ( predicate )}; } template < typename Seq , typename Predicate > [[ nodiscard ]] Filter < Seq , Predicate > operator | ( Seq && seq , FilterBinder < Predicate >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Filtered sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Predicate , std :: decay_t < Predicate >> , \"Predicate functions may not be captured implicitly by reference.\" ); return Filter < Seq , Predicate > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . predicate )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq , typename Pred , typename EachFn > LoopControl operator | ( Filter < Seq , Pred >&& filter_seq , ForEachBinder < EachFn >&& binder ) { auto & pred_fn = * filter_seq . predicate_ ; auto loop_body = [ & ]( auto && item ) -> LoopControl { if ( ! pred_fn ( item )) { return kContinue ; } return run_loop_fn ( binder . fn , item ); }; return std :: forward < Seq > ( filter_seq . seq_ ) | for_each ( loop_body ); } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FILTER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/filter__map_8hpp/","text":"batteries/seq/filter_map.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::IsNotFalse class batt::seq::FilterMap struct batt::seq::FilterMapBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_FILTER_MAP_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_FILTER_MAP_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_FILTER_MAP_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FILTER_MAP_HPP #define BATTERIES_SEQ_FILTER_MAP_HPP #include <batteries/config.hpp> #include <batteries/seq/deref.hpp> #include <batteries/seq/filter.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/map.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // filter_map // struct IsNotFalse { template < typename T > bool operator ()( T && val ) const { return bool { val }; } }; template < typename Seq , typename Fn > auto filter_map_impl ( Seq && seq , Fn && fn ) { return BATT_FORWARD ( seq ) // | map ( BATT_FORWARD ( fn )) // | filter ( IsNotFalse {}) // | deref (); } template < typename Seq , typename Fn > class FilterMap { public : using impl_type = decltype ( filter_map_impl < Seq , Fn > ( std :: declval < Seq > (), std :: declval < Fn > ())); using Item = SeqItem < impl_type > ; explicit FilterMap ( Seq && seq , Fn && fn ) noexcept : impl_ { filter_map_impl ( BATT_FORWARD ( seq ), BATT_FORWARD ( fn ))} { } Optional < Item > peek () { return impl_ . peek (); } Optional < Item > next () { return impl_ . next (); } //-------------------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename MapFn , typename EachFn > friend LoopControl operator | ( FilterMap < Seq_ , MapFn >&& filter_map_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : impl_type impl_ ; }; template < typename Fn > struct FilterMapBinder { Fn fn ; }; template < typename Fn > FilterMapBinder < Fn > filter_map ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn > [[ nodiscard ]] FilterMap < Seq , Fn > operator | ( Seq && seq , FilterMapBinder < Fn >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Filtered/mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Fn , std :: decay_t < Fn >> , \"Filter/map functions may not be captured implicitly by reference.\" ); return FilterMap < Seq , Fn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . fn )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // filter_map(...) | for_each(...) // template < typename Seq , typename MapFn , typename EachFn > LoopControl operator | ( FilterMap < Seq , MapFn >&& filter_map_seq , ForEachBinder < EachFn >&& binder ) { return BATT_FORWARD ( filter_map_seq . impl_ ) | BATT_FORWARD ( binder ); } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FILTER_MAP_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/filter_map.hpp"},{"location":"_autogen/Files/filter__map_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/filter__map_8hpp/#classes","text":"Name struct batt::seq::IsNotFalse class batt::seq::FilterMap struct batt::seq::FilterMapBinder","title":"Classes"},{"location":"_autogen/Files/filter__map_8hpp/#defines","text":"Name BATTERIES_SEQ_FILTER_MAP_HPP","title":"Defines"},{"location":"_autogen/Files/filter__map_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/filter__map_8hpp/#batteries_seq_filter_map_hpp","text":"1 #define BATTERIES_SEQ_FILTER_MAP_HPP()","title":"BATTERIES_SEQ_FILTER_MAP_HPP"},{"location":"_autogen/Files/filter__map_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FILTER_MAP_HPP #define BATTERIES_SEQ_FILTER_MAP_HPP #include <batteries/config.hpp> #include <batteries/seq/deref.hpp> #include <batteries/seq/filter.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/map.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // filter_map // struct IsNotFalse { template < typename T > bool operator ()( T && val ) const { return bool { val }; } }; template < typename Seq , typename Fn > auto filter_map_impl ( Seq && seq , Fn && fn ) { return BATT_FORWARD ( seq ) // | map ( BATT_FORWARD ( fn )) // | filter ( IsNotFalse {}) // | deref (); } template < typename Seq , typename Fn > class FilterMap { public : using impl_type = decltype ( filter_map_impl < Seq , Fn > ( std :: declval < Seq > (), std :: declval < Fn > ())); using Item = SeqItem < impl_type > ; explicit FilterMap ( Seq && seq , Fn && fn ) noexcept : impl_ { filter_map_impl ( BATT_FORWARD ( seq ), BATT_FORWARD ( fn ))} { } Optional < Item > peek () { return impl_ . peek (); } Optional < Item > next () { return impl_ . next (); } //-------------------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename MapFn , typename EachFn > friend LoopControl operator | ( FilterMap < Seq_ , MapFn >&& filter_map_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : impl_type impl_ ; }; template < typename Fn > struct FilterMapBinder { Fn fn ; }; template < typename Fn > FilterMapBinder < Fn > filter_map ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn > [[ nodiscard ]] FilterMap < Seq , Fn > operator | ( Seq && seq , FilterMapBinder < Fn >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Filtered/mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Fn , std :: decay_t < Fn >> , \"Filter/map functions may not be captured implicitly by reference.\" ); return FilterMap < Seq , Fn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . fn )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // filter_map(...) | for_each(...) // template < typename Seq , typename MapFn , typename EachFn > LoopControl operator | ( FilterMap < Seq , MapFn >&& filter_map_seq , ForEachBinder < EachFn >&& binder ) { return BATT_FORWARD ( filter_map_seq . impl_ ) | BATT_FORWARD ( binder ); } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FILTER_MAP_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/finally_8hpp/","text":"batteries/finally.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::FinalAct Defines \ud83d\udd17 Name BATTERIES_FINALLY_HPP Macro Documentation \ud83d\udd17 BATTERIES_FINALLY_HPP \ud83d\udd17 1 #define BATTERIES_FINALLY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_FINALLY_HPP #define BATTERIES_FINALLY_HPP #include <batteries/config.hpp> // #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <optional> #include <utility> namespace batt { template < typename Fn > class FinalAct { public : FinalAct ( const FinalAct & ) = delete ; FinalAct & operator = ( const FinalAct & ) = delete ; // Moves a final act to a more narrow scope in order to invoke it early. // FinalAct ( FinalAct && that ) noexcept : fn_ { that . fn_ } { that . cancel (); } template < typename FnArg , typename = EnableIfNoShadow < FinalAct , FnArg &&>> explicit FinalAct ( FnArg && arg ) noexcept : fn_ { BATT_FORWARD ( arg )} { } ~ FinalAct () noexcept { if ( fn_ ) { auto local_copy = std :: move ( fn_ ); ( * local_copy )(); } } void cancel () { fn_ = std :: nullopt ; } private : std :: optional < Fn > fn_ ; }; template < typename Fn > auto finally ( Fn && fn ) noexcept -> FinalAct < std :: decay_t < Fn >> { return FinalAct < std :: decay_t < Fn >> { BATT_FORWARD ( fn )}; } } // namespace batt #endif // BATTERIES_FINALLY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/finally.hpp"},{"location":"_autogen/Files/finally_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/finally_8hpp/#classes","text":"Name class batt::FinalAct","title":"Classes"},{"location":"_autogen/Files/finally_8hpp/#defines","text":"Name BATTERIES_FINALLY_HPP","title":"Defines"},{"location":"_autogen/Files/finally_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/finally_8hpp/#batteries_finally_hpp","text":"1 #define BATTERIES_FINALLY_HPP()","title":"BATTERIES_FINALLY_HPP"},{"location":"_autogen/Files/finally_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_FINALLY_HPP #define BATTERIES_FINALLY_HPP #include <batteries/config.hpp> // #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <optional> #include <utility> namespace batt { template < typename Fn > class FinalAct { public : FinalAct ( const FinalAct & ) = delete ; FinalAct & operator = ( const FinalAct & ) = delete ; // Moves a final act to a more narrow scope in order to invoke it early. // FinalAct ( FinalAct && that ) noexcept : fn_ { that . fn_ } { that . cancel (); } template < typename FnArg , typename = EnableIfNoShadow < FinalAct , FnArg &&>> explicit FinalAct ( FnArg && arg ) noexcept : fn_ { BATT_FORWARD ( arg )} { } ~ FinalAct () noexcept { if ( fn_ ) { auto local_copy = std :: move ( fn_ ); ( * local_copy )(); } } void cancel () { fn_ = std :: nullopt ; } private : std :: optional < Fn > fn_ ; }; template < typename Fn > auto finally ( Fn && fn ) noexcept -> FinalAct < std :: decay_t < Fn >> { return FinalAct < std :: decay_t < Fn >> { BATT_FORWARD ( fn )}; } } // namespace batt #endif // BATTERIES_FINALLY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/first_8hpp/","text":"batteries/seq/first.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::FirstBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_FIRST_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_FIRST_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_FIRST_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FIRST_HPP #define BATTERIES_SEQ_FIRST_HPP #include <batteries/config.hpp> // namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // first // struct FirstBinder { }; inline FirstBinder first () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , FirstBinder ) { return seq . peek (); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FIRST_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/first.hpp"},{"location":"_autogen/Files/first_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/first_8hpp/#classes","text":"Name struct batt::seq::FirstBinder","title":"Classes"},{"location":"_autogen/Files/first_8hpp/#defines","text":"Name BATTERIES_SEQ_FIRST_HPP","title":"Defines"},{"location":"_autogen/Files/first_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/first_8hpp/#batteries_seq_first_hpp","text":"1 #define BATTERIES_SEQ_FIRST_HPP()","title":"BATTERIES_SEQ_FIRST_HPP"},{"location":"_autogen/Files/first_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FIRST_HPP #define BATTERIES_SEQ_FIRST_HPP #include <batteries/config.hpp> // namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // first // struct FirstBinder { }; inline FirstBinder first () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , FirstBinder ) { return seq . peek (); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FIRST_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/flatten_8hpp/","text":"batteries/seq/flatten.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Flatten struct batt::seq::FlattenBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_FLATTEN_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_FLATTEN_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_FLATTEN_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FLATTEN_HPP #define BATTERIES_SEQ_FLATTEN_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/count.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // flatten - turns Seq<Seq<T>> into Seq<T> by concatenating // template < typename OuterSeq , typename InnerSeqT = std :: decay_t < SeqItem < OuterSeq >>> class Flatten { public : using InnerSeq = InnerSeqT ; using Item = SeqItem < InnerSeq > ; explicit Flatten ( OuterSeq && outer ) noexcept : outer_ ( BATT_FORWARD ( outer )), inner_ ( outer_ . next ()) { } Optional < Item > peek () { return impl ( /*consume_item=*/ false ); } Optional < Item > next () { return impl ( /*consume_item=*/ true ); } //---------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename OuterSeq_ , typename Fn > friend LoopControl operator | ( Flatten < OuterSeq_ >&& flatten_seq , ForEachBinder < Fn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : Optional < Item > impl ( bool consume_item ) { if ( ! inner_ ) { return None ; } for (;;) { auto v = consume_item ? inner_ -> next () : inner_ -> peek (); if ( v ) { return v ; } auto next_inner = outer_ . next (); if ( next_inner ) { inner_ . emplace ( std :: move ( * next_inner )); } else { inner_ = None ; return None ; } } } OuterSeq outer_ ; Optional < InnerSeq > inner_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - struct FlattenBinder { }; inline FlattenBinder flatten () { return {}; } template < typename OuterSeq > [[ nodiscard ]] Flatten < OuterSeq > operator | ( OuterSeq && seq , FlattenBinder ) { static_assert ( std :: is_same_v < OuterSeq , std :: decay_t < OuterSeq >> , \"Flattened sequences may not be captured implicitly by reference.\" ); return Flatten < OuterSeq > { BATT_FORWARD ( seq )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // flatten() | for_each(...) // template < typename OuterSeq , typename Fn > LoopControl operator | ( Flatten < OuterSeq >&& flatten_seq , ForEachBinder < Fn >&& binder ) { using InnerSeq = typename Flatten < OuterSeq >:: InnerSeq ; if ( flatten_seq . inner_ ) { LoopControl control = std :: forward < InnerSeq > ( * flatten_seq . inner_ ) | for_each ( binder . fn ); if ( BATT_HINT_FALSE ( control == kBreak )) { return kBreak ; } flatten_seq . inner_ = None ; } auto loop_body = [ & binder ]( auto && inner_seq ) -> LoopControl { return BATT_FORWARD ( inner_seq ) | for_each ( binder . fn ); }; return std :: forward < OuterSeq > ( flatten_seq . outer_ ) | for_each ( loop_body ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // flatten() | count() // #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FLATTEN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/flatten.hpp"},{"location":"_autogen/Files/flatten_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/flatten_8hpp/#classes","text":"Name class batt::seq::Flatten struct batt::seq::FlattenBinder","title":"Classes"},{"location":"_autogen/Files/flatten_8hpp/#defines","text":"Name BATTERIES_SEQ_FLATTEN_HPP","title":"Defines"},{"location":"_autogen/Files/flatten_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/flatten_8hpp/#batteries_seq_flatten_hpp","text":"1 #define BATTERIES_SEQ_FLATTEN_HPP()","title":"BATTERIES_SEQ_FLATTEN_HPP"},{"location":"_autogen/Files/flatten_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FLATTEN_HPP #define BATTERIES_SEQ_FLATTEN_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/count.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // flatten - turns Seq<Seq<T>> into Seq<T> by concatenating // template < typename OuterSeq , typename InnerSeqT = std :: decay_t < SeqItem < OuterSeq >>> class Flatten { public : using InnerSeq = InnerSeqT ; using Item = SeqItem < InnerSeq > ; explicit Flatten ( OuterSeq && outer ) noexcept : outer_ ( BATT_FORWARD ( outer )), inner_ ( outer_ . next ()) { } Optional < Item > peek () { return impl ( /*consume_item=*/ false ); } Optional < Item > next () { return impl ( /*consume_item=*/ true ); } //---------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename OuterSeq_ , typename Fn > friend LoopControl operator | ( Flatten < OuterSeq_ >&& flatten_seq , ForEachBinder < Fn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : Optional < Item > impl ( bool consume_item ) { if ( ! inner_ ) { return None ; } for (;;) { auto v = consume_item ? inner_ -> next () : inner_ -> peek (); if ( v ) { return v ; } auto next_inner = outer_ . next (); if ( next_inner ) { inner_ . emplace ( std :: move ( * next_inner )); } else { inner_ = None ; return None ; } } } OuterSeq outer_ ; Optional < InnerSeq > inner_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - struct FlattenBinder { }; inline FlattenBinder flatten () { return {}; } template < typename OuterSeq > [[ nodiscard ]] Flatten < OuterSeq > operator | ( OuterSeq && seq , FlattenBinder ) { static_assert ( std :: is_same_v < OuterSeq , std :: decay_t < OuterSeq >> , \"Flattened sequences may not be captured implicitly by reference.\" ); return Flatten < OuterSeq > { BATT_FORWARD ( seq )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // flatten() | for_each(...) // template < typename OuterSeq , typename Fn > LoopControl operator | ( Flatten < OuterSeq >&& flatten_seq , ForEachBinder < Fn >&& binder ) { using InnerSeq = typename Flatten < OuterSeq >:: InnerSeq ; if ( flatten_seq . inner_ ) { LoopControl control = std :: forward < InnerSeq > ( * flatten_seq . inner_ ) | for_each ( binder . fn ); if ( BATT_HINT_FALSE ( control == kBreak )) { return kBreak ; } flatten_seq . inner_ = None ; } auto loop_body = [ & binder ]( auto && inner_seq ) -> LoopControl { return BATT_FORWARD ( inner_seq ) | for_each ( binder . fn ); }; return std :: forward < OuterSeq > ( flatten_seq . outer_ ) | for_each ( loop_body ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // flatten() | count() // #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FLATTEN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/for__each_8hpp/","text":"batteries/seq/for_each.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::ForEachBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_FOR_EACH_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_FOR_EACH_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_FOR_EACH_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FOR_EACH_HPP #define BATTERIES_SEQ_FOR_EACH_HPP #include <batteries/config.hpp> // #include <batteries/seq/loop_control.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/hint.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // for_each // template < typename Fn > struct ForEachBinder { Fn fn ; }; template < typename Fn > ForEachBinder < Fn > for_each ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn , typename = EnableIfSeq < Seq >> LoopControl operator | ( Seq && seq , ForEachBinder < Fn >&& binder ) { for (;;) { auto n = seq . next (); if ( ! n ) { break ; } if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , * n ) == kBreak )) { return kBreak ; } } return kContinue ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FOR_EACH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/for_each.hpp"},{"location":"_autogen/Files/for__each_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/for__each_8hpp/#classes","text":"Name struct batt::seq::ForEachBinder","title":"Classes"},{"location":"_autogen/Files/for__each_8hpp/#defines","text":"Name BATTERIES_SEQ_FOR_EACH_HPP","title":"Defines"},{"location":"_autogen/Files/for__each_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/for__each_8hpp/#batteries_seq_for_each_hpp","text":"1 #define BATTERIES_SEQ_FOR_EACH_HPP()","title":"BATTERIES_SEQ_FOR_EACH_HPP"},{"location":"_autogen/Files/for__each_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_FOR_EACH_HPP #define BATTERIES_SEQ_FOR_EACH_HPP #include <batteries/config.hpp> // #include <batteries/seq/loop_control.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/hint.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // for_each // template < typename Fn > struct ForEachBinder { Fn fn ; }; template < typename Fn > ForEachBinder < Fn > for_each ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn , typename = EnableIfSeq < Seq >> LoopControl operator | ( Seq && seq , ForEachBinder < Fn >&& binder ) { for (;;) { auto n = seq . next (); if ( ! n ) { break ; } if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , * n ) == kBreak )) { return kBreak ; } } return kContinue ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_FOR_EACH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/future_8hpp/","text":"batteries/async/future.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/future_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/future_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/future.hpp"},{"location":"_autogen/Files/future_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/future_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/future_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/future__decl_8hpp/","text":"batteries/async/future_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name class batt::detail::FutureImpl class batt::Future class batt::Promise class batt::Future Defines \ud83d\udd17 Name BATTERIES_ASYNC_FUTURE_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FUTURE_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FUTURE_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FUTURE_DECL_HPP #define BATTERIES_ASYNC_FUTURE_DECL_HPP #include <batteries/config.hpp> // #include <batteries/shared_ptr.hpp> #include <memory> namespace batt { namespace detail { template < typename T > class FutureImpl ; } // namespace detail template < typename T > class Future ; template < typename T > class Promise { public : Promise (); void set_value ( T && value ); template < typename U > friend Future < U > get_future ( const Promise < U >& promise ); private : boost :: intrusive_ptr < detail :: FutureImpl < T >> impl_ ; }; template < typename T > class Future { public : template < typename Handler > void async_wait ( Handler && handler ) const ; //+++++++++++-+-+--+----- --- -- - - - - // To retrieve the value of the future, use `StatusOr<T> result = Task::await(future);` //+++++++++++-+-+--+----- --- -- - - - - template < typename U > friend Future < U > get_future ( const Promise < U >& promise ); bool is_ready () const ; private : explicit Future ( boost :: intrusive_ptr < detail :: FutureImpl < T >>&& impl ) noexcept ; boost :: intrusive_ptr < detail :: FutureImpl < T >> impl_ ; }; template < typename T > Future < T > get_future ( const Promise < T >& promise ); } // namespace batt #endif // BATTERIES_ASYNC_FUTURE_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/future_decl.hpp"},{"location":"_autogen/Files/future__decl_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/future__decl_8hpp/#classes","text":"Name class batt::detail::FutureImpl class batt::Future class batt::Promise class batt::Future","title":"Classes"},{"location":"_autogen/Files/future__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FUTURE_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/future__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/future__decl_8hpp/#batteries_async_future_decl_hpp","text":"1 #define BATTERIES_ASYNC_FUTURE_DECL_HPP()","title":"BATTERIES_ASYNC_FUTURE_DECL_HPP"},{"location":"_autogen/Files/future__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FUTURE_DECL_HPP #define BATTERIES_ASYNC_FUTURE_DECL_HPP #include <batteries/config.hpp> // #include <batteries/shared_ptr.hpp> #include <memory> namespace batt { namespace detail { template < typename T > class FutureImpl ; } // namespace detail template < typename T > class Future ; template < typename T > class Promise { public : Promise (); void set_value ( T && value ); template < typename U > friend Future < U > get_future ( const Promise < U >& promise ); private : boost :: intrusive_ptr < detail :: FutureImpl < T >> impl_ ; }; template < typename T > class Future { public : template < typename Handler > void async_wait ( Handler && handler ) const ; //+++++++++++-+-+--+----- --- -- - - - - // To retrieve the value of the future, use `StatusOr<T> result = Task::await(future);` //+++++++++++-+-+--+----- --- -- - - - - template < typename U > friend Future < U > get_future ( const Promise < U >& promise ); bool is_ready () const ; private : explicit Future ( boost :: intrusive_ptr < detail :: FutureImpl < T >>&& impl ) noexcept ; boost :: intrusive_ptr < detail :: FutureImpl < T >> impl_ ; }; template < typename T > Future < T > get_future ( const Promise < T >& promise ); } // namespace batt #endif // BATTERIES_ASYNC_FUTURE_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/future__impl_8hpp/","text":"batteries/async/future_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name class batt::detail::FutureImpl Defines \ud83d\udd17 Name BATTERIES_ASYNC_FUTURE_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_FUTURE_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_FUTURE_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FUTURE_IMPL_HPP #define BATTERIES_ASYNC_FUTURE_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/future_decl.hpp> #include <batteries/async/handler.hpp> #include <batteries/async/latch.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/utility.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace detail { template < typename T > class FutureImpl : public Latch < T > { public : using Latch < T >:: Latch ; }; } // namespace detail //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL Promise < T >:: Promise () : impl_ { batt :: make_shared < detail :: FutureImpl < T >> ()} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL void Promise < T >:: set_value ( T && value ) { this -> impl_ -> set_value ( BATT_FORWARD ( value )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Handler > BATT_INLINE_IMPL void Future < T >:: async_wait ( Handler && handler ) const { impl_ -> async_get ( BATT_FORWARD ( handler )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL Future < T >:: Future ( boost :: intrusive_ptr < detail :: FutureImpl < T >>&& impl ) noexcept : impl_ { std :: move ( impl )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL Future < T > get_future ( const Promise < T >& promise ) { return Future < T > { make_copy ( promise . impl_ )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL bool Future < T >:: is_ready () const { return this -> impl_ -> is_ready (); } } // namespace batt #endif // BATTERIES_ASYNC_FUTURE_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/future_impl.hpp"},{"location":"_autogen/Files/future__impl_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/future__impl_8hpp/#classes","text":"Name class batt::detail::FutureImpl","title":"Classes"},{"location":"_autogen/Files/future__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_FUTURE_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/future__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/future__impl_8hpp/#batteries_async_future_impl_hpp","text":"1 #define BATTERIES_ASYNC_FUTURE_IMPL_HPP()","title":"BATTERIES_ASYNC_FUTURE_IMPL_HPP"},{"location":"_autogen/Files/future__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_FUTURE_IMPL_HPP #define BATTERIES_ASYNC_FUTURE_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/future_decl.hpp> #include <batteries/async/handler.hpp> #include <batteries/async/latch.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/utility.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace detail { template < typename T > class FutureImpl : public Latch < T > { public : using Latch < T >:: Latch ; }; } // namespace detail //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL Promise < T >:: Promise () : impl_ { batt :: make_shared < detail :: FutureImpl < T >> ()} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL void Promise < T >:: set_value ( T && value ) { this -> impl_ -> set_value ( BATT_FORWARD ( value )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Handler > BATT_INLINE_IMPL void Future < T >:: async_wait ( Handler && handler ) const { impl_ -> async_get ( BATT_FORWARD ( handler )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL Future < T >:: Future ( boost :: intrusive_ptr < detail :: FutureImpl < T >>&& impl ) noexcept : impl_ { std :: move ( impl )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL Future < T > get_future ( const Promise < T >& promise ) { return Future < T > { make_copy ( promise . impl_ )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL bool Future < T >:: is_ready () const { return this -> impl_ -> is_ready (); } } // namespace batt #endif // BATTERIES_ASYNC_FUTURE_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/grant_8hpp/","text":"batteries/async/grant.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATTERIES_ASYNC_GRANT_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_GRANT_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_GRANT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_GRANT_HPP #define BATTERIES_ASYNC_GRANT_HPP #include <batteries/config.hpp> #include <batteries/async/grant_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/grant_impl.hpp> #endif #endif // BATTERIES_ASYNC_GRANT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/grant.hpp"},{"location":"_autogen/Files/grant_8hpp/#defines","text":"Name BATTERIES_ASYNC_GRANT_HPP","title":"Defines"},{"location":"_autogen/Files/grant_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/grant_8hpp/#batteries_async_grant_hpp","text":"1 #define BATTERIES_ASYNC_GRANT_HPP()","title":"BATTERIES_ASYNC_GRANT_HPP"},{"location":"_autogen/Files/grant_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_GRANT_HPP #define BATTERIES_ASYNC_GRANT_HPP #include <batteries/config.hpp> #include <batteries/async/grant_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/grant_impl.hpp> #endif #endif // BATTERIES_ASYNC_GRANT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/grant__decl_8hpp/","text":"batteries/async/grant_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Grant class batt::Grant::Issuer Defines \ud83d\udd17 Name BATTERIES_ASYNC_GRANT_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_GRANT_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_GRANT_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_GRANT_DECL_HPP #define BATTERIES_ASYNC_GRANT_DECL_HPP #include <batteries/config.hpp> // #include <batteries/async/types.hpp> #include <batteries/async/watch.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/pointers.hpp> #include <atomic> namespace batt { class Grant { public : class Issuer { friend class Grant ; public : Issuer () = default ; explicit Issuer ( u64 initial_count ) noexcept ; Issuer ( const Issuer & ) = delete ; Issuer & operator = ( const Issuer & ) = delete ; ~ Issuer () noexcept ; StatusOr < Grant > issue_grant ( u64 count , WaitForResource wait_for_resource ); void grow ( u64 count ); void close (); u64 available () const { return this -> available_ . get_value (); } private : void recycle ( u64 count ); Watch < u64 > available_ { 0 }; std :: atomic < u64 > total_size_ { 0 }; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - //----- --- -- - - - - // (Grant has no default constructor; you must create a new one by calling `Grant::Issuer::issue_grant` or // by spending part of an existing Grant. This guarantees that a Grant is never detached from a // Grant::Issuer unless it has gone out of scope via move, which is equivalent to destruction.) //----- --- -- - - - - Grant ( const Grant & ) = delete ; Grant & operator = ( const Grant & ) = delete ; // A Grant may be move-constructed, but not move-assigned (like a built-in reference type). // Grant ( Grant && that ) noexcept ; Grant & operator = ( Grant && ) = delete ; ~ Grant () noexcept ; //----- --- -- - - - - const Issuer * get_issuer () const { return this -> issuer_ . get (); } bool empty () const { return this -> size () == 0 ; } explicit operator bool () const { return this -> is_valid (); } bool is_valid () const { return this -> size () != 0 && this -> issuer_ ; } bool is_revoked () const { return this -> size_ . is_closed (); } //----- --- -- - - - - // All of the following public methods are thread-safe with respect to each other; they MUST NOT be called // concurrent to: // - `Grant::~Grant()` // - `Grant other = std::move(*this);` //----- --- -- - - - - // Permanently invalidate this Grant, waking all waiters with error status. // void revoke (); // The current count available for spending on this Grant. // u64 size () const ; // Spend part of the grant, returning a new Grant representing the spent amount if successful; otherwise: // - `batt::StatusCode::kGrantUnavailable` if the remaining size of this grant isn't big enough // - `batt::StatusCode::kGrantRevoked` if this Grant has been revoked // - `batt::StatusCode::kFailedPrecondition` if this Grant has been invalidated by a move // StatusOr < Grant > spend ( u64 count , WaitForResource wait_for_resource = WaitForResource :: kFalse ); // Spend all of the grant, returning the previous size. // u64 spend_all (); // Increase this grant by that.size() and set that to empty. // // Will panic unless all of the following are true: // - `this->get_issuer() != nullptr` // - `this->get_issuer() == that.get_issuer()` // Grant & subsume ( Grant && that ); // Swap the values of this and that. // void swap ( Grant & that ); private : static StatusOr < Grant > transfer_impl ( Grant :: Issuer * issuer , Watch < u64 >& source , u64 count , WaitForResource wait_for_resource ); //+++++++++++-+-+--+----- --- -- - - - - explicit Grant ( Issuer * issuer , u64 size ) noexcept ; //+++++++++++-+-+--+----- --- -- - - - - // This field *must not* change after it is initialized. // UniqueNonOwningPtr < Issuer > issuer_ ; // The size of this Grant. // Watch < u64 > size_ { 0 }; }; inline std :: ostream & operator << ( std :: ostream & out , const Grant & t ) { return out << \"Grant{.size=\" << t . size () << \",}\" ; } } // namespace batt #endif // BATTERIES_ASYNC_GRANT_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/grant_decl.hpp"},{"location":"_autogen/Files/grant__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/grant__decl_8hpp/#classes","text":"Name class batt::Grant class batt::Grant::Issuer","title":"Classes"},{"location":"_autogen/Files/grant__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_GRANT_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/grant__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/grant__decl_8hpp/#batteries_async_grant_decl_hpp","text":"1 #define BATTERIES_ASYNC_GRANT_DECL_HPP()","title":"BATTERIES_ASYNC_GRANT_DECL_HPP"},{"location":"_autogen/Files/grant__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_GRANT_DECL_HPP #define BATTERIES_ASYNC_GRANT_DECL_HPP #include <batteries/config.hpp> // #include <batteries/async/types.hpp> #include <batteries/async/watch.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/pointers.hpp> #include <atomic> namespace batt { class Grant { public : class Issuer { friend class Grant ; public : Issuer () = default ; explicit Issuer ( u64 initial_count ) noexcept ; Issuer ( const Issuer & ) = delete ; Issuer & operator = ( const Issuer & ) = delete ; ~ Issuer () noexcept ; StatusOr < Grant > issue_grant ( u64 count , WaitForResource wait_for_resource ); void grow ( u64 count ); void close (); u64 available () const { return this -> available_ . get_value (); } private : void recycle ( u64 count ); Watch < u64 > available_ { 0 }; std :: atomic < u64 > total_size_ { 0 }; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - //----- --- -- - - - - // (Grant has no default constructor; you must create a new one by calling `Grant::Issuer::issue_grant` or // by spending part of an existing Grant. This guarantees that a Grant is never detached from a // Grant::Issuer unless it has gone out of scope via move, which is equivalent to destruction.) //----- --- -- - - - - Grant ( const Grant & ) = delete ; Grant & operator = ( const Grant & ) = delete ; // A Grant may be move-constructed, but not move-assigned (like a built-in reference type). // Grant ( Grant && that ) noexcept ; Grant & operator = ( Grant && ) = delete ; ~ Grant () noexcept ; //----- --- -- - - - - const Issuer * get_issuer () const { return this -> issuer_ . get (); } bool empty () const { return this -> size () == 0 ; } explicit operator bool () const { return this -> is_valid (); } bool is_valid () const { return this -> size () != 0 && this -> issuer_ ; } bool is_revoked () const { return this -> size_ . is_closed (); } //----- --- -- - - - - // All of the following public methods are thread-safe with respect to each other; they MUST NOT be called // concurrent to: // - `Grant::~Grant()` // - `Grant other = std::move(*this);` //----- --- -- - - - - // Permanently invalidate this Grant, waking all waiters with error status. // void revoke (); // The current count available for spending on this Grant. // u64 size () const ; // Spend part of the grant, returning a new Grant representing the spent amount if successful; otherwise: // - `batt::StatusCode::kGrantUnavailable` if the remaining size of this grant isn't big enough // - `batt::StatusCode::kGrantRevoked` if this Grant has been revoked // - `batt::StatusCode::kFailedPrecondition` if this Grant has been invalidated by a move // StatusOr < Grant > spend ( u64 count , WaitForResource wait_for_resource = WaitForResource :: kFalse ); // Spend all of the grant, returning the previous size. // u64 spend_all (); // Increase this grant by that.size() and set that to empty. // // Will panic unless all of the following are true: // - `this->get_issuer() != nullptr` // - `this->get_issuer() == that.get_issuer()` // Grant & subsume ( Grant && that ); // Swap the values of this and that. // void swap ( Grant & that ); private : static StatusOr < Grant > transfer_impl ( Grant :: Issuer * issuer , Watch < u64 >& source , u64 count , WaitForResource wait_for_resource ); //+++++++++++-+-+--+----- --- -- - - - - explicit Grant ( Issuer * issuer , u64 size ) noexcept ; //+++++++++++-+-+--+----- --- -- - - - - // This field *must not* change after it is initialized. // UniqueNonOwningPtr < Issuer > issuer_ ; // The size of this Grant. // Watch < u64 > size_ { 0 }; }; inline std :: ostream & operator << ( std :: ostream & out , const Grant & t ) { return out << \"Grant{.size=\" << t . size () << \",}\" ; } } // namespace batt #endif // BATTERIES_ASYNC_GRANT_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/grant__impl_8hpp/","text":"batteries/async/grant_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_GRANT_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_GRANT_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_GRANT_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_GRANT_IMPL_HPP #define BATTERIES_ASYNC_GRANT_IMPL_HPP #include <batteries/config.hpp> // namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant::Issuer::Issuer ( u64 initial_count ) noexcept : available_ { initial_count } , total_size_ { initial_count } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant :: Issuer ::~ Issuer () noexcept { BATT_CHECK_EQ ( this -> total_size_ . load (), this -> available_ . get_value ()) << \"This may indicate a Grant is still active!\" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < Grant > Grant :: Issuer :: issue_grant ( u64 count , WaitForResource wait_for_resource ) { BATT_DEBUG_INFO ( \"[Grant::Issuer::issue_grant]\" ); return transfer_impl ( /*issuer=*/ this , /*source=*/ this -> available_ , /*count=*/ count , /*wait_for_resource=*/ wait_for_resource ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: Issuer :: grow ( u64 count ) { [[ maybe_unused ]] const u64 old_size = this -> total_size_ . fetch_add ( count ); BATT_ASSERT_GT ( u64 { old_size + count }, old_size ) << \"Integer overflow detected!\" ; this -> recycle ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: Issuer :: recycle ( u64 count ) { this -> available_ . fetch_add ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: Issuer :: close () { this -> available_ . close (); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant :: Grant ( Issuer * issuer , u64 size ) noexcept : issuer_ { issuer }, size_ { size } { BATT_CHECK_NOT_NULLPTR ( issuer ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant :: Grant ( Grant && that ) noexcept : issuer_ { std :: move ( that . issuer_ )} , size_ { that . size_ . set_value ( 0 )} { BATT_CHECK_EQ ( that . issuer_ , nullptr ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant ::~ Grant () noexcept { this -> revoke (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: revoke () { this -> spend_all (); this -> size_ . close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: swap ( Grant & that ) { std :: swap ( this -> issuer_ , that . issuer_ ); that . size_ . set_value ( this -> size_ . set_value ( that . size_ . set_value ( 0 ))); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL u64 Grant :: size () const { return this -> size_ . get_value (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < Grant > Grant :: spend ( u64 count , WaitForResource wait_for_resource ) { return transfer_impl ( /*issuer=*/ this -> issuer_ . get (), /*source=*/ this -> size_ , /*count=*/ count , /*wait_for_resource=*/ wait_for_resource ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL u64 Grant :: spend_all () { if ( ! this -> issuer_ ) { return 0 ; } const u64 previous_size = this -> size_ . set_value ( 0 ); this -> issuer_ -> recycle ( previous_size ); return previous_size ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant & Grant :: subsume ( Grant && that ) { if ( ! that . issuer_ ) { return * this ; } BATT_CHECK_NOT_NULLPTR ( this -> issuer_ ) << \"It is NOT legal to subsume a Grant into an invalidated Grant.\" ; BATT_CHECK_EQ ( this -> issuer_ , that . issuer_ ); const u64 count = that . size_ . set_value ( 0 ); this -> size_ . fetch_add ( count ); return * this ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ StatusOr < Grant > Grant :: transfer_impl ( Grant :: Issuer * issuer , Watch < u64 >& source , u64 count , WaitForResource wait_for_resource ) { if ( issuer == nullptr ) { return { StatusCode :: kFailedPrecondition }; } for (;;) { BATT_DEBUG_INFO ( \"[Grant::transfer_impl] count=\" << count << \" wait_for_resource=\" << ( bool ) wait_for_resource << \" available=\" << source . get_value ()); const Optional < u64 > pre_transfer_count = source . modify_if ([ count ]( u64 observed ) -> Optional < u64 > { if ( observed >= count ) { return observed - count ; } return None ; }); // If the spend succeeded, return a new Grant representing the spent amount. // if ( pre_transfer_count ) { return Grant { issuer , count }; } // At this point, we must wait for the Grant to be increased in size, so if we are in non-blocking // mode, fail now. // if ( wait_for_resource == WaitForResource :: kFalse ) { if ( source . is_closed ()) { return { StatusCode :: kGrantRevoked }; } return { StatusCode :: kGrantUnavailable }; } // Await the increase of the grant size. // StatusOr < u64 > available = source . await_true ([ count ]( u64 observed ) { return observed >= count ; }); BATT_REQUIRE_OK ( available ); } } } // namespace batt #endif // BATTERIES_ASYNC_GRANT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/grant_impl.hpp"},{"location":"_autogen/Files/grant__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/grant__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_GRANT_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/grant__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/grant__impl_8hpp/#batteries_async_grant_impl_hpp","text":"1 #define BATTERIES_ASYNC_GRANT_IMPL_HPP()","title":"BATTERIES_ASYNC_GRANT_IMPL_HPP"},{"location":"_autogen/Files/grant__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_GRANT_IMPL_HPP #define BATTERIES_ASYNC_GRANT_IMPL_HPP #include <batteries/config.hpp> // namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant::Issuer::Issuer ( u64 initial_count ) noexcept : available_ { initial_count } , total_size_ { initial_count } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant :: Issuer ::~ Issuer () noexcept { BATT_CHECK_EQ ( this -> total_size_ . load (), this -> available_ . get_value ()) << \"This may indicate a Grant is still active!\" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < Grant > Grant :: Issuer :: issue_grant ( u64 count , WaitForResource wait_for_resource ) { BATT_DEBUG_INFO ( \"[Grant::Issuer::issue_grant]\" ); return transfer_impl ( /*issuer=*/ this , /*source=*/ this -> available_ , /*count=*/ count , /*wait_for_resource=*/ wait_for_resource ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: Issuer :: grow ( u64 count ) { [[ maybe_unused ]] const u64 old_size = this -> total_size_ . fetch_add ( count ); BATT_ASSERT_GT ( u64 { old_size + count }, old_size ) << \"Integer overflow detected!\" ; this -> recycle ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: Issuer :: recycle ( u64 count ) { this -> available_ . fetch_add ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: Issuer :: close () { this -> available_ . close (); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant :: Grant ( Issuer * issuer , u64 size ) noexcept : issuer_ { issuer }, size_ { size } { BATT_CHECK_NOT_NULLPTR ( issuer ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant :: Grant ( Grant && that ) noexcept : issuer_ { std :: move ( that . issuer_ )} , size_ { that . size_ . set_value ( 0 )} { BATT_CHECK_EQ ( that . issuer_ , nullptr ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant ::~ Grant () noexcept { this -> revoke (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: revoke () { this -> spend_all (); this -> size_ . close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Grant :: swap ( Grant & that ) { std :: swap ( this -> issuer_ , that . issuer_ ); that . size_ . set_value ( this -> size_ . set_value ( that . size_ . set_value ( 0 ))); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL u64 Grant :: size () const { return this -> size_ . get_value (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < Grant > Grant :: spend ( u64 count , WaitForResource wait_for_resource ) { return transfer_impl ( /*issuer=*/ this -> issuer_ . get (), /*source=*/ this -> size_ , /*count=*/ count , /*wait_for_resource=*/ wait_for_resource ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL u64 Grant :: spend_all () { if ( ! this -> issuer_ ) { return 0 ; } const u64 previous_size = this -> size_ . set_value ( 0 ); this -> issuer_ -> recycle ( previous_size ); return previous_size ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Grant & Grant :: subsume ( Grant && that ) { if ( ! that . issuer_ ) { return * this ; } BATT_CHECK_NOT_NULLPTR ( this -> issuer_ ) << \"It is NOT legal to subsume a Grant into an invalidated Grant.\" ; BATT_CHECK_EQ ( this -> issuer_ , that . issuer_ ); const u64 count = that . size_ . set_value ( 0 ); this -> size_ . fetch_add ( count ); return * this ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ StatusOr < Grant > Grant :: transfer_impl ( Grant :: Issuer * issuer , Watch < u64 >& source , u64 count , WaitForResource wait_for_resource ) { if ( issuer == nullptr ) { return { StatusCode :: kFailedPrecondition }; } for (;;) { BATT_DEBUG_INFO ( \"[Grant::transfer_impl] count=\" << count << \" wait_for_resource=\" << ( bool ) wait_for_resource << \" available=\" << source . get_value ()); const Optional < u64 > pre_transfer_count = source . modify_if ([ count ]( u64 observed ) -> Optional < u64 > { if ( observed >= count ) { return observed - count ; } return None ; }); // If the spend succeeded, return a new Grant representing the spent amount. // if ( pre_transfer_count ) { return Grant { issuer , count }; } // At this point, we must wait for the Grant to be increased in size, so if we are in non-blocking // mode, fail now. // if ( wait_for_resource == WaitForResource :: kFalse ) { if ( source . is_closed ()) { return { StatusCode :: kGrantRevoked }; } return { StatusCode :: kGrantUnavailable }; } // Await the increase of the grant size. // StatusOr < u64 > available = source . await_true ([ count ]( u64 observed ) { return observed >= count ; }); BATT_REQUIRE_OK ( available ); } } } // namespace batt #endif // BATTERIES_ASYNC_GRANT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/group__by_8hpp/","text":"batteries/seq/group_by.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::GroupBy class batt::seq::GroupBy::SubGroup struct batt::seq::GroupByBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_GROUP_BY_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_GROUP_BY_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_GROUP_BY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_GROUP_BY_HPP #define BATTERIES_SEQ_GROUP_BY_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <batteries/optional.hpp> #include <batteries/seq/consume.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> #include <utility> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // group_by // template < typename Seq , typename GroupEq > class GroupBy { public : static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"GroupBy is not supported for Seq references.\" ); class SubGroup ; static void detach ( SubGroup * , bool ); using SubGroupItem = SeqItem < Seq > ; using Item = SubGroup ; explicit GroupBy ( Seq && seq , GroupEq && group_eq ) noexcept : seq_ ( BATT_FORWARD ( seq )) , group_eq_ ( BATT_FORWARD ( group_eq )) , next_item_ ( seq_ . next ()) { } explicit GroupBy ( Seq && seq , GroupEq && group_eq , Optional < SubGroupItem >&& next_item ) noexcept : seq_ ( BATT_FORWARD ( seq )) , group_eq_ ( BATT_FORWARD ( group_eq )) , next_item_ ( std :: move ( next_item )) { } ~ GroupBy () noexcept { #if defined(__GNUC__) && !defined(__clang__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\" #endif detach ( this -> sub_group_ , /*skip_advance=*/ true ); #if defined(__GNUC__) && !defined(__clang__) #pragma GCC diagnostic pop #endif } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // We need custom copy and move constructors because `sub_group_` contains a // back-reference to the GroupBy sequence object that needs to be fixed up // when we copy/move. // GroupBy ( GroupBy && that ) noexcept : seq_ ( std :: move ( that . seq_ )) , group_eq_ ( std :: move ( that . group_eq_ )) , next_item_ ( std :: move ( that . next_item_ )) { move_sub_group ( std :: move ( that )); } GroupBy & operator = ( GroupBy && that ) { if ( BATT_HINT_TRUE ( this != & that )) { detach ( this -> sub_group_ , /*skip_advance=*/ true ); this -> seq_ = BATT_FORWARD ( that . seq_ ); this -> group_eq_ . emplace ( BATT_FORWARD ( * that . group_eq_ )); this -> next_item_ = BATT_FORWARD ( that . next_item_ ); move_sub_group ( std :: move ( that )); } return * this ; } GroupBy ( const GroupBy & that ) noexcept : seq_ ( that . seq_ ) , group_eq_ ( that . group_eq_ ) , next_item_ ( that . next_item_ ) { copy_sub_group ( that ); } GroupBy & operator = ( const GroupBy & that ) { if ( BATT_HINT_TRUE ( this != & that )) { detach ( this -> sub_group_ , /*skip_advance=*/ true ); this -> seq_ = that . seq_ ; this -> group_eq_ . emplace ( * that . group_eq_ ); this -> next_item_ = that . next_item_ ; this -> sub_group_ = nullptr ; copy_sub_group ( that ); } return * this ; } // //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Optional < Item > peek (); Optional < Item > next (); #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( GroupBy < Seq_ , GroupEq_ >&& group_by_seq , ForEachBinder < Fn >&& binder ); template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( typename GroupBy < Seq_ , GroupEq_ >:: SubGroup && sub_group , ForEachBinder < Fn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : void move_sub_group ( GroupBy && that ) { if ( that . sub_group_ ) { this -> sub_group_ = that . sub_group_ ; this -> sub_group_ -> group_by_ = this ; } else { this -> sub_group_ = nullptr ; } that . sub_group_ = nullptr ; } void copy_sub_group ( const GroupBy & that ) { BATT_ASSERT ( this -> sub_group_ == nullptr ); if ( that . sub_group_ ) { SubGroup { & this -> sub_group_ , this } | consume (); } BATT_ASSERT ( this -> sub_group_ == nullptr ); } Optional < SubGroupItem > sub_group_peek () { return next_item_ ; } Optional < SubGroupItem > sub_group_next (); SubGroup * sub_group_ = nullptr ; Seq seq_ ; Optional < GroupEq > group_eq_ ; Optional < SeqItem < Seq >> next_item_ ; }; template < typename Seq , typename GroupEq > class GroupBy < Seq , GroupEq >:: SubGroup { public : static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"\" ); friend class GroupBy < Seq , GroupEq > ; #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( GroupBy < Seq_ , GroupEq_ >&& group_by_seq , ForEachBinder < Fn >&& binder ); template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( typename GroupBy < Seq_ , GroupEq_ >:: SubGroup && sub_group , ForEachBinder < Fn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS using Item = SeqItem < Seq > ; private : explicit SubGroup ( SubGroup ** sub_group_out , GroupBy * group_by ) noexcept : private_group_by_ {} , group_by_ { group_by } { if ( private_group_by_ ) { private_group_by_ -> sub_group_ = this ; } if ( sub_group_out ) { * sub_group_out = this ; } } template < typename ... PrivateGroupByArgs > explicit SubGroup ( SubGroup ** sub_group_out , std :: nullptr_t , PrivateGroupByArgs && ... private_group_by_args ) noexcept : private_group_by_ { InPlaceInit , BATT_FORWARD ( private_group_by_args )...} , group_by_ { private_group_by_ . get_ptr ()} { private_group_by_ -> sub_group_ = this ; if ( sub_group_out ) { * sub_group_out = this ; } } public : SubGroup ( SubGroup && that ) noexcept : group_by_ { nullptr } { move_impl ( std :: move ( that )); } SubGroup ( const SubGroup & that ) noexcept : group_by_ { nullptr } { copy_impl ( that ); } ~ SubGroup () noexcept { if ( this -> group_by_ ) { GroupBy :: detach ( this , /*skip_advance=*/ false ); } } SubGroup & operator = ( SubGroup && that ) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> group_by_ ) { GroupBy :: detach ( this , /*skip_advance=*/ false ); } move_impl ( std :: move ( that )); } return * this ; } SubGroup & operator = ( const SubGroup & that ) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> group_by_ ) { GroupBy :: detach ( this , /*skip_advance=*/ false ); } copy_impl ( that ); } return * this ; } bool is_detached () const noexcept { if ( this -> group_by_ == nullptr ) { return true ; } BATT_ASSERT_IMPLIES ( bool { this -> private_group_by_ }, this -> group_by_ == this -> private_group_by_ . get_ptr ()); return bool { private_group_by_ }; } Optional < Item > peek () { if ( ! group_by_ ) { return None ; } return group_by_ -> sub_group_peek (); } Optional < Item > next () { if ( ! group_by_ ) { return None ; } return group_by_ -> sub_group_next (); } private : void move_impl ( SubGroup && that ) { if ( ! that . group_by_ ) { this -> group_by_ = nullptr ; this -> private_group_by_ = None ; return ; } if ( that . private_group_by_ ) { { GroupBy & that_group_by = * that . private_group_by_ ; this -> private_group_by_ . emplace ( std :: move ( that_group_by . seq_ ), std :: move ( * that_group_by . group_eq_ ), std :: move ( that_group_by . next_item_ )); that_group_by . sub_group_ = nullptr ; } that . private_group_by_ = None ; this -> group_by_ = this -> private_group_by_ . get_ptr (); } else { this -> private_group_by_ = None ; this -> group_by_ = that . group_by_ ; } this -> group_by_ -> sub_group_ = this ; that . group_by_ = nullptr ; } void copy_impl ( const SubGroup & that ) { if ( ! that . group_by_ ) { this -> group_by_ = nullptr ; this -> private_group_by_ = None ; return ; } this -> private_group_by_ . emplace ( batt :: make_copy ( that . group_by_ -> seq_ ), batt :: make_copy ( * that . group_by_ -> group_eq_ ), batt :: make_copy ( that . group_by_ -> next_item_ )); this -> group_by_ = this -> private_group_by_ . get_ptr (); this -> group_by_ -> sub_group_ = this ; } // If this SubGroup is detached, private_group_by_ holds the GroupBy object to // which this->group_by_ points (if any). // Optional < GroupBy > private_group_by_ ; // If nullptr, then this SubGroup has been consumed. Otherwise, points to the // sequence state for this SubGroup. // GroupBy * group_by_ = nullptr ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // If *p_sub_group points to a SubGroup that is attached to an external GroupBy // object, copy its external state into the sub group and set the GroupBy // sub_group_ pointer to nullptr. // template < typename Seq , typename GroupEq > inline void GroupBy < Seq , GroupEq >:: detach ( SubGroup * sub_group , bool skip_advance ) { if ( ! sub_group || sub_group -> is_detached ()) { return ; } BATT_ASSERT ( ! sub_group -> private_group_by_ ); BATT_ASSERT_NOT_NULLPTR ( sub_group -> group_by_ ); BATT_ASSERT_EQ ( sub_group -> group_by_ -> sub_group_ , sub_group ); sub_group -> private_group_by_ . emplace ( batt :: make_copy ( sub_group -> group_by_ -> seq_ ), batt :: make_copy ( * sub_group -> group_by_ -> group_eq_ ), batt :: make_copy ( sub_group -> group_by_ -> next_item_ )); if ( skip_advance ) { sub_group -> group_by_ -> sub_group_ = nullptr ; } else { GroupBy * const group_by = sub_group -> group_by_ ; SubGroup { & group_by -> sub_group_ , group_by } | consume (); BATT_ASSERT ( group_by -> sub_group_ == nullptr ); } sub_group -> group_by_ = sub_group -> private_group_by_ . get_ptr (); sub_group -> group_by_ -> sub_group_ = sub_group ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename Seq , typename GroupEq > inline Optional < typename GroupBy < Seq , GroupEq >:: SubGroupItem > GroupBy < Seq , GroupEq >:: sub_group_next () { if ( ! next_item_ ) { BATT_ASSERT ( this -> sub_group_ == nullptr ); return None ; } Optional < SeqItem < Seq >> item = std :: move ( next_item_ ); next_item_ = this -> seq_ . next (); if ( ! next_item_ || ! ( * group_eq_ )( * item , * next_item_ )) { this -> sub_group_ -> group_by_ = nullptr ; this -> sub_group_ -> private_group_by_ = None ; this -> sub_group_ = nullptr ; } return item ; } template < typename Seq , typename GroupEq > inline Optional < typename GroupBy < Seq , GroupEq >:: SubGroup > GroupBy < Seq , GroupEq >:: peek () { if ( this -> sub_group_ == nullptr ) { if ( ! this -> next_item_ ) { return None ; } return { SubGroup { nullptr , nullptr , batt :: make_copy ( seq_ ), batt :: make_copy ( * group_eq_ ), batt :: make_copy ( next_item_ )}}; } return GroupBy { static_cast < const GroupBy &> ( * this )}. peek (); } template < typename Seq , typename GroupEq > inline Optional < typename GroupBy < Seq , GroupEq >:: SubGroup > GroupBy < Seq , GroupEq >:: next () { if ( this -> sub_group_ != nullptr ) { detach ( this -> sub_group_ , /*skip_advance=*/ false ); } BATT_ASSERT ( this -> sub_group_ == nullptr ); if ( ! this -> next_item_ ) { return None ; } return { SubGroup { & this -> sub_group_ , this }}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename GroupEq > struct GroupByBinder { GroupEq group_eq ; }; template < typename GroupEq > GroupByBinder < GroupEq > group_by ( GroupEq && group_eq ) { return { BATT_FORWARD ( group_eq )}; } template < typename Seq , typename GroupEq > [[ nodiscard ]] GroupBy < Seq , GroupEq > operator | ( Seq && seq , GroupByBinder < GroupEq >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Grouped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < GroupEq , std :: decay_t < GroupEq >> , \"Grouping functions may not be captured implicitly by reference.\" ); return GroupBy < Seq , GroupEq > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . group_eq )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename Seq , typename GroupEq , typename Fn > LoopControl operator | ( GroupBy < Seq , GroupEq >&& group_by_seq , ForEachBinder < Fn >&& binder ) { using SubGroup = typename GroupBy < Seq , GroupEq >:: SubGroup ; while ( group_by_seq . next_item_ ) { if ( group_by_seq . sub_group_ != nullptr ) { group_by_seq . detach ( group_by_seq . sub_group_ , /*skip_advance=*/ false ); } BATT_ASSERT ( group_by_seq . sub_group_ == nullptr ); if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , SubGroup { & group_by_seq . sub_group_ , & group_by_seq }) == kBreak )) { return kBreak ; } } return kContinue ; } template < typename Seq , typename GroupEq , typename Fn > LoopControl operator | ( typename GroupBy < Seq , GroupEq >:: SubGroup && sub_group , ForEachBinder < Fn >&& binder ) { GroupBy < Seq , GroupEq >* p_group_by = sub_group . group_by_ ; if ( ! p_group_by || ! p_group_by -> next_item_ ) { return kContinue ; } auto & group_by_seq = * p_group_by ; auto & group_eq = * group_by_seq . group_eq_ ; LoopControl first_result = run_loop_fn ( binder . fn , * group_by_seq . next_item_ ); if ( BATT_HINT_FALSE ( first_result == kBreak )) { group_by_seq . next_item_ = group_by_seq . seq_ . next (); return kBreak ; } Optional < SeqItem < Seq >> prev_item = std :: move ( group_by_seq . next_item_ ); group_by_seq . next_item_ = None ; auto loop_body = [ & ]( auto && item ) -> LoopControl { if ( group_eq ( * prev_item , item )) { LoopControl item_result = run_loop_fn ( binder . fn , item ); prev_item = BATT_FORWARD ( item ); return item_result ; } group_by_seq . next_item_ = BATT_FORWARD ( item ); sub_group . group_by_ = nullptr ; sub_group . private_group_by_ = None ; group_by_seq . sub_group_ = nullptr ; return kBreak ; }; LoopControl rest_result = group_by_seq . seq_ | for_each ( loop_body ); if ( sub_group . group_by_ == nullptr ) { return kContinue ; } return rest_result ; } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_GROUP_BY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/group_by.hpp"},{"location":"_autogen/Files/group__by_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/group__by_8hpp/#classes","text":"Name class batt::seq::GroupBy class batt::seq::GroupBy::SubGroup struct batt::seq::GroupByBinder","title":"Classes"},{"location":"_autogen/Files/group__by_8hpp/#defines","text":"Name BATTERIES_SEQ_GROUP_BY_HPP","title":"Defines"},{"location":"_autogen/Files/group__by_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/group__by_8hpp/#batteries_seq_group_by_hpp","text":"1 #define BATTERIES_SEQ_GROUP_BY_HPP()","title":"BATTERIES_SEQ_GROUP_BY_HPP"},{"location":"_autogen/Files/group__by_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_GROUP_BY_HPP #define BATTERIES_SEQ_GROUP_BY_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <batteries/optional.hpp> #include <batteries/seq/consume.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> #include <utility> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // group_by // template < typename Seq , typename GroupEq > class GroupBy { public : static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"GroupBy is not supported for Seq references.\" ); class SubGroup ; static void detach ( SubGroup * , bool ); using SubGroupItem = SeqItem < Seq > ; using Item = SubGroup ; explicit GroupBy ( Seq && seq , GroupEq && group_eq ) noexcept : seq_ ( BATT_FORWARD ( seq )) , group_eq_ ( BATT_FORWARD ( group_eq )) , next_item_ ( seq_ . next ()) { } explicit GroupBy ( Seq && seq , GroupEq && group_eq , Optional < SubGroupItem >&& next_item ) noexcept : seq_ ( BATT_FORWARD ( seq )) , group_eq_ ( BATT_FORWARD ( group_eq )) , next_item_ ( std :: move ( next_item )) { } ~ GroupBy () noexcept { #if defined(__GNUC__) && !defined(__clang__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\" #endif detach ( this -> sub_group_ , /*skip_advance=*/ true ); #if defined(__GNUC__) && !defined(__clang__) #pragma GCC diagnostic pop #endif } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // We need custom copy and move constructors because `sub_group_` contains a // back-reference to the GroupBy sequence object that needs to be fixed up // when we copy/move. // GroupBy ( GroupBy && that ) noexcept : seq_ ( std :: move ( that . seq_ )) , group_eq_ ( std :: move ( that . group_eq_ )) , next_item_ ( std :: move ( that . next_item_ )) { move_sub_group ( std :: move ( that )); } GroupBy & operator = ( GroupBy && that ) { if ( BATT_HINT_TRUE ( this != & that )) { detach ( this -> sub_group_ , /*skip_advance=*/ true ); this -> seq_ = BATT_FORWARD ( that . seq_ ); this -> group_eq_ . emplace ( BATT_FORWARD ( * that . group_eq_ )); this -> next_item_ = BATT_FORWARD ( that . next_item_ ); move_sub_group ( std :: move ( that )); } return * this ; } GroupBy ( const GroupBy & that ) noexcept : seq_ ( that . seq_ ) , group_eq_ ( that . group_eq_ ) , next_item_ ( that . next_item_ ) { copy_sub_group ( that ); } GroupBy & operator = ( const GroupBy & that ) { if ( BATT_HINT_TRUE ( this != & that )) { detach ( this -> sub_group_ , /*skip_advance=*/ true ); this -> seq_ = that . seq_ ; this -> group_eq_ . emplace ( * that . group_eq_ ); this -> next_item_ = that . next_item_ ; this -> sub_group_ = nullptr ; copy_sub_group ( that ); } return * this ; } // //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Optional < Item > peek (); Optional < Item > next (); #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( GroupBy < Seq_ , GroupEq_ >&& group_by_seq , ForEachBinder < Fn >&& binder ); template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( typename GroupBy < Seq_ , GroupEq_ >:: SubGroup && sub_group , ForEachBinder < Fn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : void move_sub_group ( GroupBy && that ) { if ( that . sub_group_ ) { this -> sub_group_ = that . sub_group_ ; this -> sub_group_ -> group_by_ = this ; } else { this -> sub_group_ = nullptr ; } that . sub_group_ = nullptr ; } void copy_sub_group ( const GroupBy & that ) { BATT_ASSERT ( this -> sub_group_ == nullptr ); if ( that . sub_group_ ) { SubGroup { & this -> sub_group_ , this } | consume (); } BATT_ASSERT ( this -> sub_group_ == nullptr ); } Optional < SubGroupItem > sub_group_peek () { return next_item_ ; } Optional < SubGroupItem > sub_group_next (); SubGroup * sub_group_ = nullptr ; Seq seq_ ; Optional < GroupEq > group_eq_ ; Optional < SeqItem < Seq >> next_item_ ; }; template < typename Seq , typename GroupEq > class GroupBy < Seq , GroupEq >:: SubGroup { public : static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"\" ); friend class GroupBy < Seq , GroupEq > ; #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( GroupBy < Seq_ , GroupEq_ >&& group_by_seq , ForEachBinder < Fn >&& binder ); template < typename Seq_ , typename GroupEq_ , typename Fn > friend LoopControl operator | ( typename GroupBy < Seq_ , GroupEq_ >:: SubGroup && sub_group , ForEachBinder < Fn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS using Item = SeqItem < Seq > ; private : explicit SubGroup ( SubGroup ** sub_group_out , GroupBy * group_by ) noexcept : private_group_by_ {} , group_by_ { group_by } { if ( private_group_by_ ) { private_group_by_ -> sub_group_ = this ; } if ( sub_group_out ) { * sub_group_out = this ; } } template < typename ... PrivateGroupByArgs > explicit SubGroup ( SubGroup ** sub_group_out , std :: nullptr_t , PrivateGroupByArgs && ... private_group_by_args ) noexcept : private_group_by_ { InPlaceInit , BATT_FORWARD ( private_group_by_args )...} , group_by_ { private_group_by_ . get_ptr ()} { private_group_by_ -> sub_group_ = this ; if ( sub_group_out ) { * sub_group_out = this ; } } public : SubGroup ( SubGroup && that ) noexcept : group_by_ { nullptr } { move_impl ( std :: move ( that )); } SubGroup ( const SubGroup & that ) noexcept : group_by_ { nullptr } { copy_impl ( that ); } ~ SubGroup () noexcept { if ( this -> group_by_ ) { GroupBy :: detach ( this , /*skip_advance=*/ false ); } } SubGroup & operator = ( SubGroup && that ) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> group_by_ ) { GroupBy :: detach ( this , /*skip_advance=*/ false ); } move_impl ( std :: move ( that )); } return * this ; } SubGroup & operator = ( const SubGroup & that ) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> group_by_ ) { GroupBy :: detach ( this , /*skip_advance=*/ false ); } copy_impl ( that ); } return * this ; } bool is_detached () const noexcept { if ( this -> group_by_ == nullptr ) { return true ; } BATT_ASSERT_IMPLIES ( bool { this -> private_group_by_ }, this -> group_by_ == this -> private_group_by_ . get_ptr ()); return bool { private_group_by_ }; } Optional < Item > peek () { if ( ! group_by_ ) { return None ; } return group_by_ -> sub_group_peek (); } Optional < Item > next () { if ( ! group_by_ ) { return None ; } return group_by_ -> sub_group_next (); } private : void move_impl ( SubGroup && that ) { if ( ! that . group_by_ ) { this -> group_by_ = nullptr ; this -> private_group_by_ = None ; return ; } if ( that . private_group_by_ ) { { GroupBy & that_group_by = * that . private_group_by_ ; this -> private_group_by_ . emplace ( std :: move ( that_group_by . seq_ ), std :: move ( * that_group_by . group_eq_ ), std :: move ( that_group_by . next_item_ )); that_group_by . sub_group_ = nullptr ; } that . private_group_by_ = None ; this -> group_by_ = this -> private_group_by_ . get_ptr (); } else { this -> private_group_by_ = None ; this -> group_by_ = that . group_by_ ; } this -> group_by_ -> sub_group_ = this ; that . group_by_ = nullptr ; } void copy_impl ( const SubGroup & that ) { if ( ! that . group_by_ ) { this -> group_by_ = nullptr ; this -> private_group_by_ = None ; return ; } this -> private_group_by_ . emplace ( batt :: make_copy ( that . group_by_ -> seq_ ), batt :: make_copy ( * that . group_by_ -> group_eq_ ), batt :: make_copy ( that . group_by_ -> next_item_ )); this -> group_by_ = this -> private_group_by_ . get_ptr (); this -> group_by_ -> sub_group_ = this ; } // If this SubGroup is detached, private_group_by_ holds the GroupBy object to // which this->group_by_ points (if any). // Optional < GroupBy > private_group_by_ ; // If nullptr, then this SubGroup has been consumed. Otherwise, points to the // sequence state for this SubGroup. // GroupBy * group_by_ = nullptr ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // If *p_sub_group points to a SubGroup that is attached to an external GroupBy // object, copy its external state into the sub group and set the GroupBy // sub_group_ pointer to nullptr. // template < typename Seq , typename GroupEq > inline void GroupBy < Seq , GroupEq >:: detach ( SubGroup * sub_group , bool skip_advance ) { if ( ! sub_group || sub_group -> is_detached ()) { return ; } BATT_ASSERT ( ! sub_group -> private_group_by_ ); BATT_ASSERT_NOT_NULLPTR ( sub_group -> group_by_ ); BATT_ASSERT_EQ ( sub_group -> group_by_ -> sub_group_ , sub_group ); sub_group -> private_group_by_ . emplace ( batt :: make_copy ( sub_group -> group_by_ -> seq_ ), batt :: make_copy ( * sub_group -> group_by_ -> group_eq_ ), batt :: make_copy ( sub_group -> group_by_ -> next_item_ )); if ( skip_advance ) { sub_group -> group_by_ -> sub_group_ = nullptr ; } else { GroupBy * const group_by = sub_group -> group_by_ ; SubGroup { & group_by -> sub_group_ , group_by } | consume (); BATT_ASSERT ( group_by -> sub_group_ == nullptr ); } sub_group -> group_by_ = sub_group -> private_group_by_ . get_ptr (); sub_group -> group_by_ -> sub_group_ = sub_group ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename Seq , typename GroupEq > inline Optional < typename GroupBy < Seq , GroupEq >:: SubGroupItem > GroupBy < Seq , GroupEq >:: sub_group_next () { if ( ! next_item_ ) { BATT_ASSERT ( this -> sub_group_ == nullptr ); return None ; } Optional < SeqItem < Seq >> item = std :: move ( next_item_ ); next_item_ = this -> seq_ . next (); if ( ! next_item_ || ! ( * group_eq_ )( * item , * next_item_ )) { this -> sub_group_ -> group_by_ = nullptr ; this -> sub_group_ -> private_group_by_ = None ; this -> sub_group_ = nullptr ; } return item ; } template < typename Seq , typename GroupEq > inline Optional < typename GroupBy < Seq , GroupEq >:: SubGroup > GroupBy < Seq , GroupEq >:: peek () { if ( this -> sub_group_ == nullptr ) { if ( ! this -> next_item_ ) { return None ; } return { SubGroup { nullptr , nullptr , batt :: make_copy ( seq_ ), batt :: make_copy ( * group_eq_ ), batt :: make_copy ( next_item_ )}}; } return GroupBy { static_cast < const GroupBy &> ( * this )}. peek (); } template < typename Seq , typename GroupEq > inline Optional < typename GroupBy < Seq , GroupEq >:: SubGroup > GroupBy < Seq , GroupEq >:: next () { if ( this -> sub_group_ != nullptr ) { detach ( this -> sub_group_ , /*skip_advance=*/ false ); } BATT_ASSERT ( this -> sub_group_ == nullptr ); if ( ! this -> next_item_ ) { return None ; } return { SubGroup { & this -> sub_group_ , this }}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename GroupEq > struct GroupByBinder { GroupEq group_eq ; }; template < typename GroupEq > GroupByBinder < GroupEq > group_by ( GroupEq && group_eq ) { return { BATT_FORWARD ( group_eq )}; } template < typename Seq , typename GroupEq > [[ nodiscard ]] GroupBy < Seq , GroupEq > operator | ( Seq && seq , GroupByBinder < GroupEq >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Grouped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < GroupEq , std :: decay_t < GroupEq >> , \"Grouping functions may not be captured implicitly by reference.\" ); return GroupBy < Seq , GroupEq > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . group_eq )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename Seq , typename GroupEq , typename Fn > LoopControl operator | ( GroupBy < Seq , GroupEq >&& group_by_seq , ForEachBinder < Fn >&& binder ) { using SubGroup = typename GroupBy < Seq , GroupEq >:: SubGroup ; while ( group_by_seq . next_item_ ) { if ( group_by_seq . sub_group_ != nullptr ) { group_by_seq . detach ( group_by_seq . sub_group_ , /*skip_advance=*/ false ); } BATT_ASSERT ( group_by_seq . sub_group_ == nullptr ); if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , SubGroup { & group_by_seq . sub_group_ , & group_by_seq }) == kBreak )) { return kBreak ; } } return kContinue ; } template < typename Seq , typename GroupEq , typename Fn > LoopControl operator | ( typename GroupBy < Seq , GroupEq >:: SubGroup && sub_group , ForEachBinder < Fn >&& binder ) { GroupBy < Seq , GroupEq >* p_group_by = sub_group . group_by_ ; if ( ! p_group_by || ! p_group_by -> next_item_ ) { return kContinue ; } auto & group_by_seq = * p_group_by ; auto & group_eq = * group_by_seq . group_eq_ ; LoopControl first_result = run_loop_fn ( binder . fn , * group_by_seq . next_item_ ); if ( BATT_HINT_FALSE ( first_result == kBreak )) { group_by_seq . next_item_ = group_by_seq . seq_ . next (); return kBreak ; } Optional < SeqItem < Seq >> prev_item = std :: move ( group_by_seq . next_item_ ); group_by_seq . next_item_ = None ; auto loop_body = [ & ]( auto && item ) -> LoopControl { if ( group_eq ( * prev_item , item )) { LoopControl item_result = run_loop_fn ( binder . fn , item ); prev_item = BATT_FORWARD ( item ); return item_result ; } group_by_seq . next_item_ = BATT_FORWARD ( item ); sub_group . group_by_ = nullptr ; sub_group . private_group_by_ = None ; group_by_seq . sub_group_ = nullptr ; return kBreak ; }; LoopControl rest_result = group_by_seq . seq_ | for_each ( loop_body ); if ( sub_group . group_by_ == nullptr ) { return kContinue ; } return rest_result ; } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_GROUP_BY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/handler_8hpp/","text":"batteries/async/handler.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::AbstractHandler struct batt::AbstractHandler::Deleter class batt::HandlerImpl class batt::UniqueHandler class batt::HandlerBinder class batt::HandlerMemoryBase class batt::HandlerMemory class batt::HandlerAllocator class batt::CustomAllocHandler Defines \ud83d\udd17 Name BATTERIES_ASYNC_HANDLER_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_HANDLER_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_HANDLER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_HANDLER_HPP #define BATTERIES_ASYNC_HANDLER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/static_assert.hpp> #include <batteries/stream_util.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/asio/associated_allocator.hpp> #include <boost/intrusive/list.hpp> #include <memory> #include <type_traits> #include <utility> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A type-erased async completion handler with linked list pointers. // template < typename ... Args > class AbstractHandler : public boost :: intrusive :: list_base_hook <> { public : struct Deleter { void operator ()( AbstractHandler * handler ) const { if ( handler != nullptr ) { handler -> destroy (); } } }; // Non-copyable! // AbstractHandler ( const AbstractHandler & ) = delete ; AbstractHandler & operator = ( const AbstractHandler & ) = delete ; // `notify` should delete `this` as a side-effect. // virtual void notify ( Args ... args ) = 0 ; // Release memory associated with this handler and destroy the implementation object, without invoking it. // virtual void destroy () = 0 ; // Print the type and any other associated information about the handler. // virtual void dump ( std :: ostream & out ) = 0 ; protected : AbstractHandler () = default ; // The handler should only be deleted from inside `notify`. // virtual ~ AbstractHandler () = default ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename HandlerFn , typename ... Args > class HandlerImpl : public AbstractHandler < Args ... > { public : static_assert ( std :: is_same_v < HandlerFn , std :: decay_t < HandlerFn >> , \"HandlerFn may not be a reference type\" ); static_assert ( batt :: IsCallable < HandlerFn , Args ... > {}, \"HandlerFn must be callable with (Args...)\" ); using allocator_type = typename std :: allocator_traits < boost :: asio :: associated_allocator_t < HandlerFn >>:: template rebind_alloc < HandlerImpl > ; template < typename HandlerFnArg > static HandlerImpl * make_new ( HandlerFnArg && h ) { allocator_type local_allocator = std :: move ( boost :: asio :: get_associated_allocator ( h )); void * memory = local_allocator . allocate ( 1 ); return new ( memory ) HandlerImpl { BATT_FORWARD ( h )}; } template < typename HandlerFnArg > static HandlerImpl * make_new ( HandlerFnArg && h , usize extra_bytes ) { allocator_type local_allocator = std :: move ( boost :: asio :: get_associated_allocator ( h )); void * memory = local_allocator . allocate ( 1 + ( extra_bytes + sizeof ( HandlerImpl ) - 1 ) / sizeof ( HandlerImpl )); return new ( memory ) HandlerImpl { BATT_FORWARD ( h )}; } template < typename HandlerFnArg , typename = batt :: EnableIfNoShadow < HandlerImpl , HandlerFnArg &&>> explicit HandlerImpl ( HandlerFnArg && h ) noexcept : fn_ ( BATT_FORWARD ( h )) { } void notify ( Args ... args ) override { this -> consume_impl ([ & ]( auto && local_fn ) { std :: move ( local_fn )( BATT_FORWARD ( args )...); }); } void destroy () override { this -> consume_impl ([]( auto && /*local_fn*/ ) { /* do nothing */ }); } void dump ( std :: ostream & out ) override { out << \"HandlerImpl<\" << name_of ( StaticType < HandlerFn > {}) << \">{}\" ; } HandlerFn & get_fn () { return this -> fn_ ; } private : template < typename FnAction > void consume_impl ( FnAction && fn_action ) { allocator_type local_allocator = std :: move ( boost :: asio :: get_associated_allocator ( this -> fn_ )); HandlerFn local_fn = std :: move ( this -> fn_ ); this ->~ HandlerImpl (); local_allocator . deallocate ( this , 1 ); BATT_FORWARD ( fn_action )( BATT_FORWARD ( local_fn )); } HandlerFn fn_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename ... Args > class UniqueHandler { public : template < typename Fn , typename = EnableIfNoShadow < UniqueHandler , Fn > , typename = std :: enable_if_t < IsCallable < std :: decay_t < Fn > , Args ... >:: value >> explicit UniqueHandler ( Fn && fn ) noexcept : handler_ { HandlerImpl < std :: decay_t < Fn > , Args ... >:: make_new ( BATT_FORWARD ( fn ))} { } UniqueHandler () = default ; UniqueHandler ( const UniqueHandler & ) = delete ; UniqueHandler & operator = ( const UniqueHandler & ) = delete ; UniqueHandler ( UniqueHandler && ) = default ; UniqueHandler & operator = ( UniqueHandler && ) = default ; ~ UniqueHandler () noexcept { } explicit operator bool () const { return this -> handler_ != nullptr ; } void operator ()( Args ... args ) { if ( this -> handler_ != nullptr ) { auto * local_handler = this -> handler_ . release (); local_handler -> notify ( BATT_FORWARD ( args )...); } } friend inline std :: ostream & operator << ( std :: ostream & out , const UniqueHandler & t ) { if ( t . handler_ == nullptr ) { return out << \"<nullptr>\" ; } out << ( void * ) t . handler_ . get () << \": \" ; t . handler_ -> dump ( out ); return out ; } private : std :: unique_ptr < AbstractHandler < Args ... > , typename AbstractHandler < Args ... >:: Deleter > handler_ ; }; BATT_STATIC_ASSERT_EQ ( sizeof ( UniqueHandler <> ), sizeof ( void * )); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename ... Args > using HandlerList = boost :: intrusive :: list < AbstractHandler < Args ... >> ; template < typename ... Args , typename HandlerFn > inline void push_handler ( HandlerList < Args ... >* list , HandlerFn && fn ) { list -> push_back ( * HandlerImpl < HandlerFn , Args ... >:: make_new ( BATT_FORWARD ( fn ))); } template < typename ... Params , typename ... Args > inline void invoke_all_handlers ( HandlerList < Params ... >* handlers , Args && ... args ) { while ( ! handlers -> empty ()) { AbstractHandler < Params ... >& l = handlers -> front (); handlers -> pop_front (); l . notify ( args ...); } } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename InnerFn , typename OuterFn > class HandlerBinder { public : using allocator_type = boost :: asio :: associated_allocator_t < InnerFn > ; template < typename InnerFnArg , typename OuterFnArg > explicit HandlerBinder ( InnerFnArg && inner , OuterFnArg && outer ) : inner_fn_ { BATT_FORWARD ( inner )} , outer_fn_ { BATT_FORWARD ( outer )} { } allocator_type get_allocator () const noexcept { return boost :: asio :: get_associated_allocator ( this -> inner_fn_ ); } template < typename ... Args > void operator ()( Args && ... args ) noexcept ( noexcept ( std :: declval < HandlerBinder *> () -> outer_fn_ ( BATT_FORWARD ( std :: declval < HandlerBinder *> () -> inner_fn_ ), std :: declval < Args > ()...))) { this -> outer_fn_ ( BATT_FORWARD ( this -> inner_fn_ ), BATT_FORWARD ( args )...); } InnerFn inner_fn_ ; OuterFn outer_fn_ ; }; template < typename InnerFn , typename OuterFn > HandlerBinder < std :: decay_t < InnerFn > , std :: decay_t < OuterFn >> bind_handler ( InnerFn && inner , OuterFn && outer ) { return HandlerBinder < std :: decay_t < InnerFn > , std :: decay_t < OuterFn >> { BATT_FORWARD ( inner ), BATT_FORWARD ( outer )}; } //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ // Abstract base for HandlerMemory<kSize>. Decouples users of HandlerMemory from knowledge of the static // memory size. // class HandlerMemoryBase { public : HandlerMemoryBase ( const HandlerMemoryBase & ) = delete ; HandlerMemoryBase & operator = ( const HandlerMemoryBase & ) = delete ; virtual ~ HandlerMemoryBase () = default ; virtual void * allocate ( usize size ) = 0 ; virtual void deallocate ( void * pointer ) = 0 ; bool in_use () const { return this -> in_use_ ; } protected : HandlerMemoryBase () = default ; // Tracks whether the memory is currently in use. // bool in_use_ = false ; }; // A chunk of memory that can be attached to an async completion handler. // template < usize kSize > class HandlerMemory : public HandlerMemoryBase { public : HandlerMemory () noexcept { } HandlerMemory ( const HandlerMemory & ) = delete ; HandlerMemory & operator = ( const HandlerMemory & ) = delete ; void * allocate ( usize size ) override { if ( ! this -> in_use_ && size < sizeof ( this -> storage_ )) { this -> in_use_ = true ; return & this -> storage_ ; } else { return :: operator new ( size ); } } void deallocate ( void * pointer ) override { if ( pointer == & this -> storage_ ) { this -> in_use_ = false ; } else { :: operator delete ( pointer ); } } private : // The memory. // std :: aligned_storage_t < kSize > storage_ ; }; // An allocator associated with a completion handler. // // Designed to satisfy the C++11 minimal allocator requirements. // template < typename T > class HandlerAllocator { public : using value_type = T ; explicit HandlerAllocator ( HandlerMemoryBase & mem ) : memory_ ( mem ) { } template < typename U > HandlerAllocator ( const HandlerAllocator < U >& that ) noexcept : memory_ ( that . memory_ ) { } bool operator == ( const HandlerAllocator & that ) const noexcept { return & memory_ == & that . memory_ ; } bool operator != ( const HandlerAllocator & that ) const noexcept { return & memory_ != & that . memory_ ; } T * allocate ( usize n ) const { return static_cast < T *> ( memory_ . allocate ( sizeof ( T ) * n )); } void deallocate ( T * p , usize /*n*/ ) const { return memory_ . deallocate ( p ); } private : template < typename > friend class HandlerAllocator ; // The attached memory. // HandlerMemoryBase & memory_ ; }; // Wrapper for an async completion handler type `Handler`. Provides an associated allocator that allocates // from a `HandlerMemory` instance. // template < typename Handler > class CustomAllocHandler { public : using allocator_type = HandlerAllocator < Handler > ; template < typename HandlerArg > CustomAllocHandler ( HandlerMemoryBase & m , HandlerArg && h ) : memory_ { m } , handler_ ( std :: forward < HandlerArg > ( h )) { } allocator_type get_allocator () const noexcept { return allocator_type { memory_ }; } template < typename ... Args > void operator ()( Args && ... args ) noexcept ( noexcept ( std :: declval < Handler &> ()( std :: declval < Args > ()...))) { handler_ ( std :: forward < Args > ( args )...); } private : // The attached memory. // HandlerMemoryBase & memory_ ; // The wrapped completion handler. // Handler handler_ ; }; // Helper function to wrap a handler object to add custom allocation. // template < typename Handler > inline CustomAllocHandler < std :: decay_t < Handler >> make_custom_alloc_handler ( HandlerMemoryBase & m , Handler && h ) { return CustomAllocHandler < std :: decay_t < Handler >> { m , std :: forward < Handler > ( h )}; } } // namespace batt #endif // BATTERIES_ASYNC_HANDLER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/handler.hpp"},{"location":"_autogen/Files/handler_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/handler_8hpp/#classes","text":"Name class batt::AbstractHandler struct batt::AbstractHandler::Deleter class batt::HandlerImpl class batt::UniqueHandler class batt::HandlerBinder class batt::HandlerMemoryBase class batt::HandlerMemory class batt::HandlerAllocator class batt::CustomAllocHandler","title":"Classes"},{"location":"_autogen/Files/handler_8hpp/#defines","text":"Name BATTERIES_ASYNC_HANDLER_HPP","title":"Defines"},{"location":"_autogen/Files/handler_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/handler_8hpp/#batteries_async_handler_hpp","text":"1 #define BATTERIES_ASYNC_HANDLER_HPP()","title":"BATTERIES_ASYNC_HANDLER_HPP"},{"location":"_autogen/Files/handler_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_HANDLER_HPP #define BATTERIES_ASYNC_HANDLER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/static_assert.hpp> #include <batteries/stream_util.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/asio/associated_allocator.hpp> #include <boost/intrusive/list.hpp> #include <memory> #include <type_traits> #include <utility> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A type-erased async completion handler with linked list pointers. // template < typename ... Args > class AbstractHandler : public boost :: intrusive :: list_base_hook <> { public : struct Deleter { void operator ()( AbstractHandler * handler ) const { if ( handler != nullptr ) { handler -> destroy (); } } }; // Non-copyable! // AbstractHandler ( const AbstractHandler & ) = delete ; AbstractHandler & operator = ( const AbstractHandler & ) = delete ; // `notify` should delete `this` as a side-effect. // virtual void notify ( Args ... args ) = 0 ; // Release memory associated with this handler and destroy the implementation object, without invoking it. // virtual void destroy () = 0 ; // Print the type and any other associated information about the handler. // virtual void dump ( std :: ostream & out ) = 0 ; protected : AbstractHandler () = default ; // The handler should only be deleted from inside `notify`. // virtual ~ AbstractHandler () = default ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename HandlerFn , typename ... Args > class HandlerImpl : public AbstractHandler < Args ... > { public : static_assert ( std :: is_same_v < HandlerFn , std :: decay_t < HandlerFn >> , \"HandlerFn may not be a reference type\" ); static_assert ( batt :: IsCallable < HandlerFn , Args ... > {}, \"HandlerFn must be callable with (Args...)\" ); using allocator_type = typename std :: allocator_traits < boost :: asio :: associated_allocator_t < HandlerFn >>:: template rebind_alloc < HandlerImpl > ; template < typename HandlerFnArg > static HandlerImpl * make_new ( HandlerFnArg && h ) { allocator_type local_allocator = std :: move ( boost :: asio :: get_associated_allocator ( h )); void * memory = local_allocator . allocate ( 1 ); return new ( memory ) HandlerImpl { BATT_FORWARD ( h )}; } template < typename HandlerFnArg > static HandlerImpl * make_new ( HandlerFnArg && h , usize extra_bytes ) { allocator_type local_allocator = std :: move ( boost :: asio :: get_associated_allocator ( h )); void * memory = local_allocator . allocate ( 1 + ( extra_bytes + sizeof ( HandlerImpl ) - 1 ) / sizeof ( HandlerImpl )); return new ( memory ) HandlerImpl { BATT_FORWARD ( h )}; } template < typename HandlerFnArg , typename = batt :: EnableIfNoShadow < HandlerImpl , HandlerFnArg &&>> explicit HandlerImpl ( HandlerFnArg && h ) noexcept : fn_ ( BATT_FORWARD ( h )) { } void notify ( Args ... args ) override { this -> consume_impl ([ & ]( auto && local_fn ) { std :: move ( local_fn )( BATT_FORWARD ( args )...); }); } void destroy () override { this -> consume_impl ([]( auto && /*local_fn*/ ) { /* do nothing */ }); } void dump ( std :: ostream & out ) override { out << \"HandlerImpl<\" << name_of ( StaticType < HandlerFn > {}) << \">{}\" ; } HandlerFn & get_fn () { return this -> fn_ ; } private : template < typename FnAction > void consume_impl ( FnAction && fn_action ) { allocator_type local_allocator = std :: move ( boost :: asio :: get_associated_allocator ( this -> fn_ )); HandlerFn local_fn = std :: move ( this -> fn_ ); this ->~ HandlerImpl (); local_allocator . deallocate ( this , 1 ); BATT_FORWARD ( fn_action )( BATT_FORWARD ( local_fn )); } HandlerFn fn_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename ... Args > class UniqueHandler { public : template < typename Fn , typename = EnableIfNoShadow < UniqueHandler , Fn > , typename = std :: enable_if_t < IsCallable < std :: decay_t < Fn > , Args ... >:: value >> explicit UniqueHandler ( Fn && fn ) noexcept : handler_ { HandlerImpl < std :: decay_t < Fn > , Args ... >:: make_new ( BATT_FORWARD ( fn ))} { } UniqueHandler () = default ; UniqueHandler ( const UniqueHandler & ) = delete ; UniqueHandler & operator = ( const UniqueHandler & ) = delete ; UniqueHandler ( UniqueHandler && ) = default ; UniqueHandler & operator = ( UniqueHandler && ) = default ; ~ UniqueHandler () noexcept { } explicit operator bool () const { return this -> handler_ != nullptr ; } void operator ()( Args ... args ) { if ( this -> handler_ != nullptr ) { auto * local_handler = this -> handler_ . release (); local_handler -> notify ( BATT_FORWARD ( args )...); } } friend inline std :: ostream & operator << ( std :: ostream & out , const UniqueHandler & t ) { if ( t . handler_ == nullptr ) { return out << \"<nullptr>\" ; } out << ( void * ) t . handler_ . get () << \": \" ; t . handler_ -> dump ( out ); return out ; } private : std :: unique_ptr < AbstractHandler < Args ... > , typename AbstractHandler < Args ... >:: Deleter > handler_ ; }; BATT_STATIC_ASSERT_EQ ( sizeof ( UniqueHandler <> ), sizeof ( void * )); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename ... Args > using HandlerList = boost :: intrusive :: list < AbstractHandler < Args ... >> ; template < typename ... Args , typename HandlerFn > inline void push_handler ( HandlerList < Args ... >* list , HandlerFn && fn ) { list -> push_back ( * HandlerImpl < HandlerFn , Args ... >:: make_new ( BATT_FORWARD ( fn ))); } template < typename ... Params , typename ... Args > inline void invoke_all_handlers ( HandlerList < Params ... >* handlers , Args && ... args ) { while ( ! handlers -> empty ()) { AbstractHandler < Params ... >& l = handlers -> front (); handlers -> pop_front (); l . notify ( args ...); } } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename InnerFn , typename OuterFn > class HandlerBinder { public : using allocator_type = boost :: asio :: associated_allocator_t < InnerFn > ; template < typename InnerFnArg , typename OuterFnArg > explicit HandlerBinder ( InnerFnArg && inner , OuterFnArg && outer ) : inner_fn_ { BATT_FORWARD ( inner )} , outer_fn_ { BATT_FORWARD ( outer )} { } allocator_type get_allocator () const noexcept { return boost :: asio :: get_associated_allocator ( this -> inner_fn_ ); } template < typename ... Args > void operator ()( Args && ... args ) noexcept ( noexcept ( std :: declval < HandlerBinder *> () -> outer_fn_ ( BATT_FORWARD ( std :: declval < HandlerBinder *> () -> inner_fn_ ), std :: declval < Args > ()...))) { this -> outer_fn_ ( BATT_FORWARD ( this -> inner_fn_ ), BATT_FORWARD ( args )...); } InnerFn inner_fn_ ; OuterFn outer_fn_ ; }; template < typename InnerFn , typename OuterFn > HandlerBinder < std :: decay_t < InnerFn > , std :: decay_t < OuterFn >> bind_handler ( InnerFn && inner , OuterFn && outer ) { return HandlerBinder < std :: decay_t < InnerFn > , std :: decay_t < OuterFn >> { BATT_FORWARD ( inner ), BATT_FORWARD ( outer )}; } //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ // Abstract base for HandlerMemory<kSize>. Decouples users of HandlerMemory from knowledge of the static // memory size. // class HandlerMemoryBase { public : HandlerMemoryBase ( const HandlerMemoryBase & ) = delete ; HandlerMemoryBase & operator = ( const HandlerMemoryBase & ) = delete ; virtual ~ HandlerMemoryBase () = default ; virtual void * allocate ( usize size ) = 0 ; virtual void deallocate ( void * pointer ) = 0 ; bool in_use () const { return this -> in_use_ ; } protected : HandlerMemoryBase () = default ; // Tracks whether the memory is currently in use. // bool in_use_ = false ; }; // A chunk of memory that can be attached to an async completion handler. // template < usize kSize > class HandlerMemory : public HandlerMemoryBase { public : HandlerMemory () noexcept { } HandlerMemory ( const HandlerMemory & ) = delete ; HandlerMemory & operator = ( const HandlerMemory & ) = delete ; void * allocate ( usize size ) override { if ( ! this -> in_use_ && size < sizeof ( this -> storage_ )) { this -> in_use_ = true ; return & this -> storage_ ; } else { return :: operator new ( size ); } } void deallocate ( void * pointer ) override { if ( pointer == & this -> storage_ ) { this -> in_use_ = false ; } else { :: operator delete ( pointer ); } } private : // The memory. // std :: aligned_storage_t < kSize > storage_ ; }; // An allocator associated with a completion handler. // // Designed to satisfy the C++11 minimal allocator requirements. // template < typename T > class HandlerAllocator { public : using value_type = T ; explicit HandlerAllocator ( HandlerMemoryBase & mem ) : memory_ ( mem ) { } template < typename U > HandlerAllocator ( const HandlerAllocator < U >& that ) noexcept : memory_ ( that . memory_ ) { } bool operator == ( const HandlerAllocator & that ) const noexcept { return & memory_ == & that . memory_ ; } bool operator != ( const HandlerAllocator & that ) const noexcept { return & memory_ != & that . memory_ ; } T * allocate ( usize n ) const { return static_cast < T *> ( memory_ . allocate ( sizeof ( T ) * n )); } void deallocate ( T * p , usize /*n*/ ) const { return memory_ . deallocate ( p ); } private : template < typename > friend class HandlerAllocator ; // The attached memory. // HandlerMemoryBase & memory_ ; }; // Wrapper for an async completion handler type `Handler`. Provides an associated allocator that allocates // from a `HandlerMemory` instance. // template < typename Handler > class CustomAllocHandler { public : using allocator_type = HandlerAllocator < Handler > ; template < typename HandlerArg > CustomAllocHandler ( HandlerMemoryBase & m , HandlerArg && h ) : memory_ { m } , handler_ ( std :: forward < HandlerArg > ( h )) { } allocator_type get_allocator () const noexcept { return allocator_type { memory_ }; } template < typename ... Args > void operator ()( Args && ... args ) noexcept ( noexcept ( std :: declval < Handler &> ()( std :: declval < Args > ()...))) { handler_ ( std :: forward < Args > ( args )...); } private : // The attached memory. // HandlerMemoryBase & memory_ ; // The wrapped completion handler. // Handler handler_ ; }; // Helper function to wrap a handler object to add custom allocation. // template < typename Handler > inline CustomAllocHandler < std :: decay_t < Handler >> make_custom_alloc_handler ( HandlerMemoryBase & m , Handler && h ) { return CustomAllocHandler < std :: decay_t < Handler >> { m , std :: forward < Handler > ( h )}; } } // namespace batt #endif // BATTERIES_ASYNC_HANDLER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/hash_8hpp/","text":"batteries/hash.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HASH_HPP Macro Documentation \ud83d\udd17 BATTERIES_HASH_HPP \ud83d\udd17 1 #define BATTERIES_HASH_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HASH_HPP #define BATTERIES_HASH_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/utility.hpp> #include <boost/functional/hash.hpp> #include <type_traits> namespace batt { inline usize hash () { return 0 ; } template < typename T > usize hash ( T && obj ) { return boost :: hash < T > {}( BATT_FORWARD ( obj )); } template < typename T , typename HashT = typename std :: decay_t < T >:: Hash > usize hash_value ( T && obj ) { static const HashT hash_impl ; return hash_impl ( obj ); } template < typename First , typename ... Rest > usize hash ( First && first , Rest && ... rest ) { usize seed = batt :: hash ( BATT_FORWARD ( first )); boost :: hash_combine ( seed , batt :: hash ( BATT_FORWARD ( rest )...)); return seed ; } } // namespace batt #endif // BATTERIES_HASH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/hash.hpp"},{"location":"_autogen/Files/hash_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/hash_8hpp/#defines","text":"Name BATTERIES_HASH_HPP","title":"Defines"},{"location":"_autogen/Files/hash_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/hash_8hpp/#batteries_hash_hpp","text":"1 #define BATTERIES_HASH_HPP()","title":"BATTERIES_HASH_HPP"},{"location":"_autogen/Files/hash_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HASH_HPP #define BATTERIES_HASH_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/utility.hpp> #include <boost/functional/hash.hpp> #include <type_traits> namespace batt { inline usize hash () { return 0 ; } template < typename T > usize hash ( T && obj ) { return boost :: hash < T > {}( BATT_FORWARD ( obj )); } template < typename T , typename HashT = typename std :: decay_t < T >:: Hash > usize hash_value ( T && obj ) { static const HashT hash_impl ; return hash_impl ( obj ); } template < typename First , typename ... Rest > usize hash ( First && first , Rest && ... rest ) { usize seed = batt :: hash ( BATT_FORWARD ( first )); boost :: hash_combine ( seed , batt :: hash ( BATT_FORWARD ( rest )...)); return seed ; } } // namespace batt #endif // BATTERIES_HASH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/hint_8hpp/","text":"batteries/hint.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATT_HINT_TRUE (expr) BATT_HINT_FALSE (expr) Macro Documentation \ud83d\udd17 BATT_HINT_TRUE \ud83d\udd17 1 #define BATT_HINT_TRUE(expr) BATT_HINT_FALSE \ud83d\udd17 1 #define BATT_HINT_FALSE(expr) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // namespace batt { // ============================================================================= // Branch prediction hints. // #define BATT_HINT_TRUE(expr) __builtin_expect(static_cast<bool>(expr), 1) #define BATT_HINT_FALSE(expr) __builtin_expect(static_cast<bool>(expr), 0) } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/hint.hpp"},{"location":"_autogen/Files/hint_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/hint_8hpp/#defines","text":"Name BATT_HINT_TRUE (expr) BATT_HINT_FALSE (expr)","title":"Defines"},{"location":"_autogen/Files/hint_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/hint_8hpp/#batt_hint_true","text":"1 #define BATT_HINT_TRUE(expr)","title":"BATT_HINT_TRUE"},{"location":"_autogen/Files/hint_8hpp/#batt_hint_false","text":"1 #define BATT_HINT_FALSE(expr)","title":"BATT_HINT_FALSE"},{"location":"_autogen/Files/hint_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // namespace batt { // ============================================================================= // Branch prediction hints. // #define BATT_HINT_TRUE(expr) __builtin_expect(static_cast<bool>(expr), 1) #define BATT_HINT_FALSE(expr) __builtin_expect(static_cast<bool>(expr), 0) } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/host__address_8hpp/","text":"batteries/http/host_address.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::HostAddress Defines \ud83d\udd17 Name BATTERIES_HTTP_HOST_ADDRESS_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HOST_ADDRESS_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HOST_ADDRESS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HOST_ADDRESS_HPP #define BATTERIES_HTTP_HOST_ADDRESS_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <batteries/stream_util.hpp> #include <batteries/utility.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/ip/tcp.hpp> #include <boost/functional/hash.hpp> #include <string> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // struct HostAddress { std :: string scheme ; std :: string hostname ; Optional < i64 > port ; friend usize hash_value ( const HostAddress & host_key ); }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint >> await_resolve ( boost :: asio :: ip :: tcp :: resolver & resolver , const HostAddress & host_address ) { auto hosts = Task :: await < IOResult < boost :: asio :: ip :: tcp :: resolver :: results_type >> ([ & ]( auto && handler ) { resolver . async_resolve ( host_address . hostname , host_address . scheme , BATT_FORWARD ( handler )); }); BATT_REQUIRE_OK ( hosts ); SmallVec < boost :: asio :: ip :: tcp :: endpoint > endpoints ; for ( const auto & result : * hosts ) { auto endpoint = result . endpoint (); if ( host_address . port ) { endpoint . port ( * host_address . port ); } endpoints . emplace_back ( std :: move ( endpoint )); } return endpoints ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint >> await_resolve ( boost :: asio :: io_context & io , const HostAddress & host_address ) { boost :: asio :: ip :: tcp :: resolver resolver { io }; return await_resolve ( resolver , host_address ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline usize hash_value ( const HostAddress & host_key ) { usize seed = 0 ; boost :: hash_combine ( seed , host_key . scheme ); boost :: hash_combine ( seed , host_key . hostname ); boost :: hash_combine ( seed , host_key . port . value_or ( -1 )); return seed ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator == ( const HostAddress & l , const HostAddress & r ) { return l . scheme == r . scheme && l . hostname == r . hostname && l . port == r . port ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator != ( const HostAddress & l , const HostAddress & r ) { return ! ( l == r ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: ostream & operator << ( std :: ostream & out , const HostAddress & t ) { return out << \"HostAddress{.scheme=\" << batt :: c_str_literal ( t . scheme ) << \", .hostname=\" << batt :: c_str_literal ( t . hostname ) << \", .port=\" << t . port << \",}\" ; } } // namespace batt #endif // BATTERIES_HTTP_HOST_ADDRESS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/host_address.hpp"},{"location":"_autogen/Files/host__address_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/host__address_8hpp/#classes","text":"Name struct batt::HostAddress","title":"Classes"},{"location":"_autogen/Files/host__address_8hpp/#defines","text":"Name BATTERIES_HTTP_HOST_ADDRESS_HPP","title":"Defines"},{"location":"_autogen/Files/host__address_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/host__address_8hpp/#batteries_http_host_address_hpp","text":"1 #define BATTERIES_HTTP_HOST_ADDRESS_HPP()","title":"BATTERIES_HTTP_HOST_ADDRESS_HPP"},{"location":"_autogen/Files/host__address_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HOST_ADDRESS_HPP #define BATTERIES_HTTP_HOST_ADDRESS_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <batteries/stream_util.hpp> #include <batteries/utility.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/ip/tcp.hpp> #include <boost/functional/hash.hpp> #include <string> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // struct HostAddress { std :: string scheme ; std :: string hostname ; Optional < i64 > port ; friend usize hash_value ( const HostAddress & host_key ); }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint >> await_resolve ( boost :: asio :: ip :: tcp :: resolver & resolver , const HostAddress & host_address ) { auto hosts = Task :: await < IOResult < boost :: asio :: ip :: tcp :: resolver :: results_type >> ([ & ]( auto && handler ) { resolver . async_resolve ( host_address . hostname , host_address . scheme , BATT_FORWARD ( handler )); }); BATT_REQUIRE_OK ( hosts ); SmallVec < boost :: asio :: ip :: tcp :: endpoint > endpoints ; for ( const auto & result : * hosts ) { auto endpoint = result . endpoint (); if ( host_address . port ) { endpoint . port ( * host_address . port ); } endpoints . emplace_back ( std :: move ( endpoint )); } return endpoints ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint >> await_resolve ( boost :: asio :: io_context & io , const HostAddress & host_address ) { boost :: asio :: ip :: tcp :: resolver resolver { io }; return await_resolve ( resolver , host_address ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline usize hash_value ( const HostAddress & host_key ) { usize seed = 0 ; boost :: hash_combine ( seed , host_key . scheme ); boost :: hash_combine ( seed , host_key . hostname ); boost :: hash_combine ( seed , host_key . port . value_or ( -1 )); return seed ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator == ( const HostAddress & l , const HostAddress & r ) { return l . scheme == r . scheme && l . hostname == r . hostname && l . port == r . port ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator != ( const HostAddress & l , const HostAddress & r ) { return ! ( l == r ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: ostream & operator << ( std :: ostream & out , const HostAddress & t ) { return out << \"HostAddress{.scheme=\" << batt :: c_str_literal ( t . scheme ) << \", .hostname=\" << batt :: c_str_literal ( t . hostname ) << \", .port=\" << t . port << \",}\" ; } } // namespace batt #endif // BATTERIES_HTTP_HOST_ADDRESS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/","text":"batteries/http/http_chunk_decoder.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpChunkDecoder Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP #define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/pico_http/parser.hpp> namespace batt { template < typename Src > class HttpChunkDecoder { public : explicit HttpChunkDecoder ( Src && src , IncludeHttpTrailer consume_trailer = IncludeHttpTrailer { false }) noexcept : src_ { BATT_FORWARD ( src )} { std :: memset ( & this -> decoder_checkpoint_ , 0 , sizeof ( pico_http :: ChunkedDecoder )); this -> decoder_checkpoint_ . consume_trailer = consume_trailer ; this -> decoder_latest_ = this -> decoder_checkpoint_ ; } // The current number of bytes available as consumable data. // usize size () const { return this -> output_available_ - this -> output_consumed_ ; } // The decoder has completed. // bool done () const { return this -> done_ ; } // Returns a ConstBufferSequence containing at least `min_count` bytes of data. // // This method may block the current task if there isn't enough data available to satisfy // the request (i.e., if `this->size() < min_count`). // StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( const i64 min_count_i ) { const usize min_count = BATT_CHECKED_CAST ( usize , min_count_i ); // Keep decoding chunks from the src stream until we have at least the minimum amount of bytes. // while ( this -> size () < min_count ) { if ( this -> done_ ) { if ( this -> size () == 0 ) { this -> release_decoded_chunks (); } return { StatusCode :: kEndOfStream }; } const i64 src_min_count = BATT_CHECKED_CAST ( i64 , this -> decoded_src_size_ ) + ( min_count_i - BATT_CHECKED_CAST ( i64 , this -> size ())); auto fetched = this -> src_ . fetch_at_least ( src_min_count ); if ( ! fetched . ok () && fetched . status () == StatusCode :: kEndOfStream && ! this -> done_ ) { if ( this -> size () == 0 ) { this -> release_decoded_chunks (); } return { StatusCode :: kClosedBeforeEndOfStream }; } BATT_REQUIRE_OK ( fetched ); this -> decoded_src_size_ = 0 ; this -> decoded_chunks_ . clear (); this -> decoder_latest_ = this -> decoder_checkpoint_ ; usize n_to_consume_from_src = 0 ; const auto on_loop_exit = finally ([ & ] { if ( n_to_consume_from_src > 0 ) { this -> consume_from_src ( n_to_consume_from_src ); } this -> output_available_ = boost :: asio :: buffer_size ( this -> decoded_chunks_ ); }); for ( ConstBuffer src_buffer : * fetched ) { StatusOr < pico_http :: DecodeResult > result = pico_http :: decode_chunked ( & this -> decoder_latest_ , src_buffer , & this -> decoded_chunks_ ); BATT_REQUIRE_OK ( result ); this -> decoded_src_size_ += result -> bytes_consumed ; if ( this -> output_consumed_ != 0 ) { const usize decoded_size = boost :: asio :: buffer_size ( this -> decoded_chunks_ ); if ( this -> output_consumed_ >= decoded_size ) { this -> output_consumed_ -= decoded_size ; this -> decoded_chunks_ . clear (); this -> decoder_checkpoint_ = this -> decoder_latest_ ; n_to_consume_from_src += result -> bytes_consumed ; } } if ( result -> done ) { this -> done_ = true ; break ; } } } return consume_buffers_copy ( this -> decoded_chunks_ , this -> output_consumed_ ); } // Consume the specified number of bytes from the front of the stream so that future calls to // `fetch_at_least` will not return the same data. // void consume ( i64 count ) { this -> output_consumed_ += count ; BATT_CHECK_LE ( this -> output_consumed_ , this -> output_available_ ); if ( this -> output_consumed_ == this -> output_available_ ) { this -> release_decoded_chunks (); } } // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be read/consumed. // void close_for_read () { this -> release_decoded_chunks (); } private : void release_decoded_chunks () { this -> output_available_ = 0 ; this -> output_consumed_ = 0 ; this -> decoded_chunks_ . clear (); this -> decoder_checkpoint_ = this -> decoder_latest_ ; this -> consume_from_src ( this -> decoded_src_size_ ); } void consume_from_src ( usize count ) { this -> decoded_src_size_ -= count ; this -> src_ . consume ( count ); } //+++++++++++-+-+--+----- --- -- - - - - Src src_ ; pico_http :: ChunkedDecoder decoder_checkpoint_ ; pico_http :: ChunkedDecoder decoder_latest_ ; bool done_ = false ; usize decoded_src_size_ = 0 ; usize output_available_ = 0 ; usize output_consumed_ = 0 ; SmallVec < ConstBuffer , 4 > decoded_chunks_ ; }; static_assert ( has_buffer_source_requirements < HttpChunkDecoder < StreamBuffer &>> (), \"\" ); } // namespace batt #endif // BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_chunk_decoder.hpp"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#classes","text":"Name class batt::HttpChunkDecoder","title":"Classes"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP","title":"Defines"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#batteries_http_http_chunk_decoder_hpp","text":"1 #define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP()","title":"BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP #define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/pico_http/parser.hpp> namespace batt { template < typename Src > class HttpChunkDecoder { public : explicit HttpChunkDecoder ( Src && src , IncludeHttpTrailer consume_trailer = IncludeHttpTrailer { false }) noexcept : src_ { BATT_FORWARD ( src )} { std :: memset ( & this -> decoder_checkpoint_ , 0 , sizeof ( pico_http :: ChunkedDecoder )); this -> decoder_checkpoint_ . consume_trailer = consume_trailer ; this -> decoder_latest_ = this -> decoder_checkpoint_ ; } // The current number of bytes available as consumable data. // usize size () const { return this -> output_available_ - this -> output_consumed_ ; } // The decoder has completed. // bool done () const { return this -> done_ ; } // Returns a ConstBufferSequence containing at least `min_count` bytes of data. // // This method may block the current task if there isn't enough data available to satisfy // the request (i.e., if `this->size() < min_count`). // StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( const i64 min_count_i ) { const usize min_count = BATT_CHECKED_CAST ( usize , min_count_i ); // Keep decoding chunks from the src stream until we have at least the minimum amount of bytes. // while ( this -> size () < min_count ) { if ( this -> done_ ) { if ( this -> size () == 0 ) { this -> release_decoded_chunks (); } return { StatusCode :: kEndOfStream }; } const i64 src_min_count = BATT_CHECKED_CAST ( i64 , this -> decoded_src_size_ ) + ( min_count_i - BATT_CHECKED_CAST ( i64 , this -> size ())); auto fetched = this -> src_ . fetch_at_least ( src_min_count ); if ( ! fetched . ok () && fetched . status () == StatusCode :: kEndOfStream && ! this -> done_ ) { if ( this -> size () == 0 ) { this -> release_decoded_chunks (); } return { StatusCode :: kClosedBeforeEndOfStream }; } BATT_REQUIRE_OK ( fetched ); this -> decoded_src_size_ = 0 ; this -> decoded_chunks_ . clear (); this -> decoder_latest_ = this -> decoder_checkpoint_ ; usize n_to_consume_from_src = 0 ; const auto on_loop_exit = finally ([ & ] { if ( n_to_consume_from_src > 0 ) { this -> consume_from_src ( n_to_consume_from_src ); } this -> output_available_ = boost :: asio :: buffer_size ( this -> decoded_chunks_ ); }); for ( ConstBuffer src_buffer : * fetched ) { StatusOr < pico_http :: DecodeResult > result = pico_http :: decode_chunked ( & this -> decoder_latest_ , src_buffer , & this -> decoded_chunks_ ); BATT_REQUIRE_OK ( result ); this -> decoded_src_size_ += result -> bytes_consumed ; if ( this -> output_consumed_ != 0 ) { const usize decoded_size = boost :: asio :: buffer_size ( this -> decoded_chunks_ ); if ( this -> output_consumed_ >= decoded_size ) { this -> output_consumed_ -= decoded_size ; this -> decoded_chunks_ . clear (); this -> decoder_checkpoint_ = this -> decoder_latest_ ; n_to_consume_from_src += result -> bytes_consumed ; } } if ( result -> done ) { this -> done_ = true ; break ; } } } return consume_buffers_copy ( this -> decoded_chunks_ , this -> output_consumed_ ); } // Consume the specified number of bytes from the front of the stream so that future calls to // `fetch_at_least` will not return the same data. // void consume ( i64 count ) { this -> output_consumed_ += count ; BATT_CHECK_LE ( this -> output_consumed_ , this -> output_available_ ); if ( this -> output_consumed_ == this -> output_available_ ) { this -> release_decoded_chunks (); } } // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be read/consumed. // void close_for_read () { this -> release_decoded_chunks (); } private : void release_decoded_chunks () { this -> output_available_ = 0 ; this -> output_consumed_ = 0 ; this -> decoded_chunks_ . clear (); this -> decoder_checkpoint_ = this -> decoder_latest_ ; this -> consume_from_src ( this -> decoded_src_size_ ); } void consume_from_src ( usize count ) { this -> decoded_src_size_ -= count ; this -> src_ . consume ( count ); } //+++++++++++-+-+--+----- --- -- - - - - Src src_ ; pico_http :: ChunkedDecoder decoder_checkpoint_ ; pico_http :: ChunkedDecoder decoder_latest_ ; bool done_ = false ; usize decoded_src_size_ = 0 ; usize output_available_ = 0 ; usize output_consumed_ = 0 ; SmallVec < ConstBuffer , 4 > decoded_chunks_ ; }; static_assert ( has_buffer_source_requirements < HttpChunkDecoder < StreamBuffer &>> (), \"\" ); } // namespace batt #endif // BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/","text":"batteries/http/http_chunk_encoder.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP #define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP #include <batteries/config.hpp> // #include <batteries/http/http_data.hpp> #include <batteries/async/io_result.hpp> #include <batteries/async/task.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <array> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Src , typename AsyncWriteStream > inline Status http_encode_chunked ( Src && src , AsyncWriteStream && dst , IncludeHttpTrailer include_trailer = IncludeHttpTrailer { false }) { static const std :: array < char , 16 > hex_digits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' }; static const ConstBuffer last_chunk { \" \\r\\n 0 \\r\\n \" , 5 }; static const ConstBuffer last_chunk_with_trailer { \" \\r\\n 0 \\r\\n\\r\\n \" , 7 }; const auto encode_hex = []( u64 n , char * dst ) -> char * { if ( n == 0 ) { * dst = '0' ; return dst + 1 ; } i32 bit_offset = sizeof ( u64 ) * 8 - 4 ; while (( n & ( u64 { 0b1111 } << bit_offset )) == 0 ) { bit_offset -= 4 ; } do { * dst = hex_digits [( n >> bit_offset ) & 0b1111 ]; ++ dst ; bit_offset -= 4 ; } while ( bit_offset >= 0 ); return dst ; }; std :: array < char , sizeof ( u64 ) * 2 + 4 > header_storage ; bool first_chunk = true ; for (;;) { auto fetched_chunks = src . fetch_at_least ( 1 ); if ( fetched_chunks . status () == StatusCode :: kEndOfStream ) { IOResult < usize > result = Task :: await_write ( dst , [ & ] { if ( include_trailer ) { return last_chunk_with_trailer ; } else { return last_chunk ; } }()); BATT_REQUIRE_OK ( result ); return OkStatus (); } BATT_REQUIRE_OK ( fetched_chunks ); usize n_consumed = 0 ; auto on_scope_exit = finally ([ & ] { src . consume ( n_consumed ); }); for ( ConstBuffer chunk : * fetched_chunks ) { char * const header_begin = header_storage . data (); char * header_end = header_begin ; if ( ! first_chunk ) { header_end [ 0 ] = '\\r' ; header_end [ 1 ] = '\\n' ; header_end += 2 ; } first_chunk = false ; header_end = encode_hex ( chunk . size (), header_end ); header_end [ 0 ] = '\\r' ; header_end [ 1 ] = '\\n' ; header_end += 2 ; SmallVec < ConstBuffer , 2 > data ; data . emplace_back ( ConstBuffer { header_begin , BATT_CHECKED_CAST ( usize , header_end - header_begin )}); if ( chunk . size () > 0 ) { data . emplace_back ( chunk ); } IOResult < usize > result = Task :: await_write ( dst , data ); BATT_REQUIRE_OK ( result ); BATT_CHECK_GT ( chunk . size (), 0 ); n_consumed += chunk . size (); } } } } // namespace batt #endif // BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_chunk_encoder.hpp"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP","title":"Defines"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#batteries_http_http_chunk_encoder_hpp","text":"1 #define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP()","title":"BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP #define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP #include <batteries/config.hpp> // #include <batteries/http/http_data.hpp> #include <batteries/async/io_result.hpp> #include <batteries/async/task.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <array> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Src , typename AsyncWriteStream > inline Status http_encode_chunked ( Src && src , AsyncWriteStream && dst , IncludeHttpTrailer include_trailer = IncludeHttpTrailer { false }) { static const std :: array < char , 16 > hex_digits = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' }; static const ConstBuffer last_chunk { \" \\r\\n 0 \\r\\n \" , 5 }; static const ConstBuffer last_chunk_with_trailer { \" \\r\\n 0 \\r\\n\\r\\n \" , 7 }; const auto encode_hex = []( u64 n , char * dst ) -> char * { if ( n == 0 ) { * dst = '0' ; return dst + 1 ; } i32 bit_offset = sizeof ( u64 ) * 8 - 4 ; while (( n & ( u64 { 0b1111 } << bit_offset )) == 0 ) { bit_offset -= 4 ; } do { * dst = hex_digits [( n >> bit_offset ) & 0b1111 ]; ++ dst ; bit_offset -= 4 ; } while ( bit_offset >= 0 ); return dst ; }; std :: array < char , sizeof ( u64 ) * 2 + 4 > header_storage ; bool first_chunk = true ; for (;;) { auto fetched_chunks = src . fetch_at_least ( 1 ); if ( fetched_chunks . status () == StatusCode :: kEndOfStream ) { IOResult < usize > result = Task :: await_write ( dst , [ & ] { if ( include_trailer ) { return last_chunk_with_trailer ; } else { return last_chunk ; } }()); BATT_REQUIRE_OK ( result ); return OkStatus (); } BATT_REQUIRE_OK ( fetched_chunks ); usize n_consumed = 0 ; auto on_scope_exit = finally ([ & ] { src . consume ( n_consumed ); }); for ( ConstBuffer chunk : * fetched_chunks ) { char * const header_begin = header_storage . data (); char * header_end = header_begin ; if ( ! first_chunk ) { header_end [ 0 ] = '\\r' ; header_end [ 1 ] = '\\n' ; header_end += 2 ; } first_chunk = false ; header_end = encode_hex ( chunk . size (), header_end ); header_end [ 0 ] = '\\r' ; header_end [ 1 ] = '\\n' ; header_end += 2 ; SmallVec < ConstBuffer , 2 > data ; data . emplace_back ( ConstBuffer { header_begin , BATT_CHECKED_CAST ( usize , header_end - header_begin )}); if ( chunk . size () > 0 ) { data . emplace_back ( chunk ); } IOResult < usize > result = Task :: await_write ( dst , data ); BATT_REQUIRE_OK ( result ); BATT_CHECK_GT ( chunk . size (), 0 ); n_consumed += chunk . size (); } } } } // namespace batt #endif // BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client_8hpp/","text":"batteries/http/http_client.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name class batt::HttpClient class batt::DefaultHttpClient class batt::detail::HttpClientRequestContext Defines \ud83d\udd17 Name BATTERIES_HTTP_CLIENT_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_CLIENT_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_CLIENT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_CLIENT_HPP #define BATTERIES_HTTP_CLIENT_HPP #include <batteries/config.hpp> // #include <batteries/http/host_address.hpp> #include <batteries/http/http_client_connection_decl.hpp> #include <batteries/http/http_client_host_context_decl.hpp> #include <batteries/http/http_data.hpp> #include <batteries/http/http_header.hpp> #include <batteries/http/http_request.hpp> #include <batteries/http/http_response.hpp> #include <batteries/http/http_version.hpp> #include <batteries/pico_http/parser.hpp> #include <batteries/async/mutex.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/async/task.hpp> #include <batteries/case_of.hpp> #include <batteries/optional.hpp> #include <batteries/small_fn.hpp> #include <batteries/status.hpp> #include <batteries/url_parse.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/ip/tcp.hpp> #include <boost/functional/hash.hpp> #include <unordered_map> namespace batt { class HttpClient { public : static constexpr usize kDefaultMaxConnectionsPerHost = HttpClientHostContext :: kDefaultMaxConnections ; //+++++++++++-+-+--+----- --- -- - - - - explicit HttpClient ( boost :: asio :: io_context & io ) noexcept : io_ { io } { } boost :: asio :: io_context & get_io_context () const noexcept { return this -> io_ ; } Status submit_request ( const HostAddress & host_address , Pin < HttpRequest >&& request , Pin < HttpResponse >&& response ); private : boost :: asio :: io_context & io_ ; Mutex < std :: unordered_map < HostAddress , SharedPtr < HttpClientHostContext > , boost :: hash < HostAddress >>> host_contexts_ ; }; class DefaultHttpClient { public : static HttpClient & get () { static DefaultHttpClient * default_client_ = new DefaultHttpClient ; // // This object is intentionally leaked! return default_client_ -> client_ ; } private : boost :: asio :: io_context io_ ; Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type >> work_guard_ { this -> io_ . get_executor ()}; HttpClient client_ { this -> io_ }; std :: thread io_thread_ {[ this ] { this -> io_ . run (); }}; }; namespace detail { class HttpClientRequestContext { public : explicit HttpClientRequestContext () { this -> set_version ( HttpVersion { 1 , 1 }). IgnoreError (); this -> request_ . async_set_message ( this -> message_ ); this -> request_ . async_set_data ( this -> data_ ); } //+++++++++++-+-+--+----- --- -- - - - - Status set_params () { return OkStatus (); } template < typename ... Rest > Status set_params ( const HttpHeader & hdr , Rest && ... rest ) { this -> set_header ( hdr ); this -> message_ . headers . push_back ( hdr ); return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( HttpData && data , Rest && ... rest ) { this -> set_data ( std :: move ( data )); return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( HttpClient & client , Rest && ... rest ) { this -> client_ = & client ; return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( HttpResponse * response , Rest && ... rest ) { BATT_CHECK_NOT_NULLPTR ( response ); this -> set_response_object ( response ); return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( const HttpVersion & version , Rest && ... rest ) { Status result = this -> set_version ( version ); BATT_REQUIRE_OK ( result ); return this -> set_params ( BATT_FORWARD ( rest )...); } //+++++++++++-+-+--+----- --- -- - - - - Status set_version ( const HttpVersion & version ) { this -> message_ . major_version = version . major_version ; this -> message_ . minor_version = version . minor_version ; return OkStatus (); } Status set_method ( std :: string_view method ) { this -> message_ . method = method ; return OkStatus (); } Status set_path ( std :: string_view path ) { this -> message_ . path = path ; return OkStatus (); } Status set_url ( const UrlParse & url ) { this -> host_address_ . scheme = url . scheme ; this -> host_address_ . hostname = url . host ; this -> host_address_ . port = url . port ; usize needed = url . path . size (); if ( ! url . query . empty ()) { needed += 1 + url . query . size (); } if ( ! url . fragment . empty ()) { needed += 1 + url . fragment . size (); } this -> path_ . reserve ( needed ); this -> path_ = url . path ; if ( ! url . query . empty ()) { this -> path_ += \"?\" ; this -> path_ += url . query ; } if ( ! url . fragment . empty ()) { this -> path_ += \"#\" ; this -> path_ += url . fragment ; } this -> message_ . path = this -> path_ ; return OkStatus (); } void set_header ( const HttpHeader & hdr ) { this -> message_ . headers . push_back ( hdr ); } void set_data ( HttpData && data ) { this -> data_ = std :: move ( data ); } //+++++++++++-+-+--+----- --- -- - - - - HttpResponse * get_response_object () const noexcept { return this -> response_ ; } void set_response_object ( HttpResponse * response ) noexcept { this -> response_ = response ; } const HttpRequest * get_request_object () const noexcept { return & this -> request_ ; } HttpRequest * get_request_object () noexcept { return & this -> request_ ; } //+++++++++++-+-+--+----- --- -- - - - - Status submit () { BATT_CHECK_NOT_NULLPTR ( this -> client_ ); BATT_CHECK_NOT_NULLPTR ( this -> response_ ); // TODO [tastolfi 2022-03-29] Check headers and adjust `this->data_` accordingly. this -> request_ . state (). set_value ( HttpRequest :: kInitialized ); return this -> client_ -> submit_request ( this -> host_address_ , make_pin ( & this -> request_ ), make_pin ( this -> response_ )); } //+++++++++++-+-+--+----- --- -- - - - - private : HttpClient * client_ = & DefaultHttpClient :: get (); std :: string path_ ; std :: string content_length_ ; HostAddress host_address_ ; pico_http :: Request message_ ; HttpData data_ ; HttpRequest request_ ; HttpResponse * response_ = nullptr ; }; // class HttpClientRequestContext } // namespace detail template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse >> http_request ( std :: string_view method , std :: string_view url , Params && ... params ) { StatusOr < UrlParse > url_parse = parse_url ( url ); BATT_REQUIRE_OK ( url_parse ); // Create a request context object to hold all the things we may need to submit the request. // detail :: HttpClientRequestContext context ; // Initialize the request from args. // Status method_status = context . set_method ( method ); BATT_REQUIRE_OK ( method_status ); Status path_status = context . set_url ( * url_parse ); BATT_REQUIRE_OK ( path_status ); Status params_status = context . set_params ( BATT_FORWARD ( params )...); BATT_REQUIRE_OK ( params_status ); // If the caller did not pass an HttpResponse object to receive the response, then create one to // use/return. // std :: unique_ptr < HttpResponse > new_response ; if ( context . get_response_object () == nullptr ) { new_response = std :: make_unique < HttpResponse > (); context . set_response_object ( new_response . get ()); } // The request is now ready to go! // Status submitted = context . submit (); BATT_REQUIRE_OK ( submitted ); //----- --- -- - - - - // Before we can return, we must make sure that the context object is not in use by the HttpClient. //----- --- -- - - - - HttpRequest * const request = context . get_request_object (); HttpResponse * const response = context . get_response_object (); // Await notification from the HttpClient that our request has been fully consumed. // Status request_consumed = request -> state (). await_equal ( HttpRequest :: kConsumed ); if ( ! request_consumed . ok ()) { BATT_REQUIRE_OK ( request -> get_status ()); } BATT_REQUIRE_OK ( request_consumed ); // Await notification from the HttpClient that the response has been read and parsed; this is not required // for object/reference lifetime issues (like `request` above), but rather so that any errors in the // response can be reported via StatusCode from this function. // // TODO [tastolfi 2022-05-06] Should we provide an option to skip this step? // Status response_received = response -> state (). await_equal ( HttpResponse :: kInitialized ); if ( ! response_received . ok ()) { BATT_REQUIRE_OK ( response -> get_status ()); } BATT_REQUIRE_OK ( response_received ); // Return the response that was created on behalf of the caller, if there was one. NOTE: if this is // nullptr, that isn't an error, it just means that the caller supplied their own HttpResponse object // pointer. // return new_response ; } template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse >> http_get ( std :: string_view url , Params && ... params ) { return http_request ( \"GET\" , url , BATT_FORWARD ( params )...); } template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse >> http_post ( std :: string_view url , Params && ... params ) { return http_request ( \"POST\" , url , BATT_FORWARD ( params )...); } } // namespace batt #endif // BATTERIES_HTTP_CLIENT_HPP #if BATT_HEADER_ONLY #include <batteries/http/http_client_connection_impl.hpp> #include <batteries/http/http_client_host_context_impl.hpp> #include <batteries/http/http_client_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client.hpp"},{"location":"_autogen/Files/http__client_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/http__client_8hpp/#classes","text":"Name class batt::HttpClient class batt::DefaultHttpClient class batt::detail::HttpClientRequestContext","title":"Classes"},{"location":"_autogen/Files/http__client_8hpp/#defines","text":"Name BATTERIES_HTTP_CLIENT_HPP","title":"Defines"},{"location":"_autogen/Files/http__client_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__client_8hpp/#batteries_http_client_hpp","text":"1 #define BATTERIES_HTTP_CLIENT_HPP()","title":"BATTERIES_HTTP_CLIENT_HPP"},{"location":"_autogen/Files/http__client_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_CLIENT_HPP #define BATTERIES_HTTP_CLIENT_HPP #include <batteries/config.hpp> // #include <batteries/http/host_address.hpp> #include <batteries/http/http_client_connection_decl.hpp> #include <batteries/http/http_client_host_context_decl.hpp> #include <batteries/http/http_data.hpp> #include <batteries/http/http_header.hpp> #include <batteries/http/http_request.hpp> #include <batteries/http/http_response.hpp> #include <batteries/http/http_version.hpp> #include <batteries/pico_http/parser.hpp> #include <batteries/async/mutex.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/async/task.hpp> #include <batteries/case_of.hpp> #include <batteries/optional.hpp> #include <batteries/small_fn.hpp> #include <batteries/status.hpp> #include <batteries/url_parse.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/ip/tcp.hpp> #include <boost/functional/hash.hpp> #include <unordered_map> namespace batt { class HttpClient { public : static constexpr usize kDefaultMaxConnectionsPerHost = HttpClientHostContext :: kDefaultMaxConnections ; //+++++++++++-+-+--+----- --- -- - - - - explicit HttpClient ( boost :: asio :: io_context & io ) noexcept : io_ { io } { } boost :: asio :: io_context & get_io_context () const noexcept { return this -> io_ ; } Status submit_request ( const HostAddress & host_address , Pin < HttpRequest >&& request , Pin < HttpResponse >&& response ); private : boost :: asio :: io_context & io_ ; Mutex < std :: unordered_map < HostAddress , SharedPtr < HttpClientHostContext > , boost :: hash < HostAddress >>> host_contexts_ ; }; class DefaultHttpClient { public : static HttpClient & get () { static DefaultHttpClient * default_client_ = new DefaultHttpClient ; // // This object is intentionally leaked! return default_client_ -> client_ ; } private : boost :: asio :: io_context io_ ; Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type >> work_guard_ { this -> io_ . get_executor ()}; HttpClient client_ { this -> io_ }; std :: thread io_thread_ {[ this ] { this -> io_ . run (); }}; }; namespace detail { class HttpClientRequestContext { public : explicit HttpClientRequestContext () { this -> set_version ( HttpVersion { 1 , 1 }). IgnoreError (); this -> request_ . async_set_message ( this -> message_ ); this -> request_ . async_set_data ( this -> data_ ); } //+++++++++++-+-+--+----- --- -- - - - - Status set_params () { return OkStatus (); } template < typename ... Rest > Status set_params ( const HttpHeader & hdr , Rest && ... rest ) { this -> set_header ( hdr ); this -> message_ . headers . push_back ( hdr ); return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( HttpData && data , Rest && ... rest ) { this -> set_data ( std :: move ( data )); return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( HttpClient & client , Rest && ... rest ) { this -> client_ = & client ; return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( HttpResponse * response , Rest && ... rest ) { BATT_CHECK_NOT_NULLPTR ( response ); this -> set_response_object ( response ); return this -> set_params ( BATT_FORWARD ( rest )...); } template < typename ... Rest > Status set_params ( const HttpVersion & version , Rest && ... rest ) { Status result = this -> set_version ( version ); BATT_REQUIRE_OK ( result ); return this -> set_params ( BATT_FORWARD ( rest )...); } //+++++++++++-+-+--+----- --- -- - - - - Status set_version ( const HttpVersion & version ) { this -> message_ . major_version = version . major_version ; this -> message_ . minor_version = version . minor_version ; return OkStatus (); } Status set_method ( std :: string_view method ) { this -> message_ . method = method ; return OkStatus (); } Status set_path ( std :: string_view path ) { this -> message_ . path = path ; return OkStatus (); } Status set_url ( const UrlParse & url ) { this -> host_address_ . scheme = url . scheme ; this -> host_address_ . hostname = url . host ; this -> host_address_ . port = url . port ; usize needed = url . path . size (); if ( ! url . query . empty ()) { needed += 1 + url . query . size (); } if ( ! url . fragment . empty ()) { needed += 1 + url . fragment . size (); } this -> path_ . reserve ( needed ); this -> path_ = url . path ; if ( ! url . query . empty ()) { this -> path_ += \"?\" ; this -> path_ += url . query ; } if ( ! url . fragment . empty ()) { this -> path_ += \"#\" ; this -> path_ += url . fragment ; } this -> message_ . path = this -> path_ ; return OkStatus (); } void set_header ( const HttpHeader & hdr ) { this -> message_ . headers . push_back ( hdr ); } void set_data ( HttpData && data ) { this -> data_ = std :: move ( data ); } //+++++++++++-+-+--+----- --- -- - - - - HttpResponse * get_response_object () const noexcept { return this -> response_ ; } void set_response_object ( HttpResponse * response ) noexcept { this -> response_ = response ; } const HttpRequest * get_request_object () const noexcept { return & this -> request_ ; } HttpRequest * get_request_object () noexcept { return & this -> request_ ; } //+++++++++++-+-+--+----- --- -- - - - - Status submit () { BATT_CHECK_NOT_NULLPTR ( this -> client_ ); BATT_CHECK_NOT_NULLPTR ( this -> response_ ); // TODO [tastolfi 2022-03-29] Check headers and adjust `this->data_` accordingly. this -> request_ . state (). set_value ( HttpRequest :: kInitialized ); return this -> client_ -> submit_request ( this -> host_address_ , make_pin ( & this -> request_ ), make_pin ( this -> response_ )); } //+++++++++++-+-+--+----- --- -- - - - - private : HttpClient * client_ = & DefaultHttpClient :: get (); std :: string path_ ; std :: string content_length_ ; HostAddress host_address_ ; pico_http :: Request message_ ; HttpData data_ ; HttpRequest request_ ; HttpResponse * response_ = nullptr ; }; // class HttpClientRequestContext } // namespace detail template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse >> http_request ( std :: string_view method , std :: string_view url , Params && ... params ) { StatusOr < UrlParse > url_parse = parse_url ( url ); BATT_REQUIRE_OK ( url_parse ); // Create a request context object to hold all the things we may need to submit the request. // detail :: HttpClientRequestContext context ; // Initialize the request from args. // Status method_status = context . set_method ( method ); BATT_REQUIRE_OK ( method_status ); Status path_status = context . set_url ( * url_parse ); BATT_REQUIRE_OK ( path_status ); Status params_status = context . set_params ( BATT_FORWARD ( params )...); BATT_REQUIRE_OK ( params_status ); // If the caller did not pass an HttpResponse object to receive the response, then create one to // use/return. // std :: unique_ptr < HttpResponse > new_response ; if ( context . get_response_object () == nullptr ) { new_response = std :: make_unique < HttpResponse > (); context . set_response_object ( new_response . get ()); } // The request is now ready to go! // Status submitted = context . submit (); BATT_REQUIRE_OK ( submitted ); //----- --- -- - - - - // Before we can return, we must make sure that the context object is not in use by the HttpClient. //----- --- -- - - - - HttpRequest * const request = context . get_request_object (); HttpResponse * const response = context . get_response_object (); // Await notification from the HttpClient that our request has been fully consumed. // Status request_consumed = request -> state (). await_equal ( HttpRequest :: kConsumed ); if ( ! request_consumed . ok ()) { BATT_REQUIRE_OK ( request -> get_status ()); } BATT_REQUIRE_OK ( request_consumed ); // Await notification from the HttpClient that the response has been read and parsed; this is not required // for object/reference lifetime issues (like `request` above), but rather so that any errors in the // response can be reported via StatusCode from this function. // // TODO [tastolfi 2022-05-06] Should we provide an option to skip this step? // Status response_received = response -> state (). await_equal ( HttpResponse :: kInitialized ); if ( ! response_received . ok ()) { BATT_REQUIRE_OK ( response -> get_status ()); } BATT_REQUIRE_OK ( response_received ); // Return the response that was created on behalf of the caller, if there was one. NOTE: if this is // nullptr, that isn't an error, it just means that the caller supplied their own HttpResponse object // pointer. // return new_response ; } template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse >> http_get ( std :: string_view url , Params && ... params ) { return http_request ( \"GET\" , url , BATT_FORWARD ( params )...); } template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse >> http_post ( std :: string_view url , Params && ... params ) { return http_request ( \"POST\" , url , BATT_FORWARD ( params )...); } } // namespace batt #endif // BATTERIES_HTTP_CLIENT_HPP #if BATT_HEADER_ONLY #include <batteries/http/http_client_connection_impl.hpp> #include <batteries/http/http_client_host_context_impl.hpp> #include <batteries/http/http_client_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__connection_8hpp/","text":"batteries/http/http_client_connection.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/http/http_client_connection_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/http/http_client_connection_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_connection.hpp"},{"location":"_autogen/Files/http__client__connection_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/http/http_client_connection_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/http/http_client_connection_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/","text":"batteries/http/http_client_connection_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpClientConnection struct batt::HttpClientConnection::ResponseInfo Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP #include <batteries/config.hpp> // #include <batteries/http/http_data.hpp> #include <batteries/http/http_request.hpp> #include <batteries/http/http_response.hpp> #include <batteries/async/buffer_source.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/status.hpp> #include <boost/asio/ip/tcp.hpp> namespace batt { class HttpClientHostContext ; class HttpClientConnection { public : struct ResponseInfo { explicit ResponseInfo ( const pico_http :: Response & response ); bool is_valid () const { return this -> content_length || this -> chunked_encoding || ! this -> keep_alive ; } HttpData get_data ( StreamBuffer & input_buffer ); Optional < usize > content_length ; bool keep_alive ; bool chunked_encoding ; }; explicit HttpClientConnection ( HttpClientHostContext & context ) noexcept ; void start (); void halt (); void join (); Status process_requests (); Status fill_input_buffer (); Status process_responses (); Status open_connection (); void close_connection (); StatusOr < i32 > read_next_response ( pico_http :: Response & response ); boost :: asio :: io_context & get_io_context (); //+++++++++++-+-+--+----- --- -- - - - - HttpClientHostContext & context_ ; boost :: asio :: ip :: tcp :: socket socket_ ; Queue < Pin < HttpResponse >> response_queue_ ; StreamBuffer input_buffer_ { 16 * 1024 }; // Must be last! // Optional < Task > task_ ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_connection_decl.hpp"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#classes","text":"Name class batt::HttpClientConnection struct batt::HttpClientConnection::ResponseInfo","title":"Classes"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#batteries_http_http_client_connection_decl_hpp","text":"1 #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP()","title":"BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP #include <batteries/config.hpp> // #include <batteries/http/http_data.hpp> #include <batteries/http/http_request.hpp> #include <batteries/http/http_response.hpp> #include <batteries/async/buffer_source.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/status.hpp> #include <boost/asio/ip/tcp.hpp> namespace batt { class HttpClientHostContext ; class HttpClientConnection { public : struct ResponseInfo { explicit ResponseInfo ( const pico_http :: Response & response ); bool is_valid () const { return this -> content_length || this -> chunked_encoding || ! this -> keep_alive ; } HttpData get_data ( StreamBuffer & input_buffer ); Optional < usize > content_length ; bool keep_alive ; bool chunked_encoding ; }; explicit HttpClientConnection ( HttpClientHostContext & context ) noexcept ; void start (); void halt (); void join (); Status process_requests (); Status fill_input_buffer (); Status process_responses (); Status open_connection (); void close_connection (); StatusOr < i32 > read_next_response ( pico_http :: Response & response ); boost :: asio :: io_context & get_io_context (); //+++++++++++-+-+--+----- --- -- - - - - HttpClientHostContext & context_ ; boost :: asio :: ip :: tcp :: socket socket_ ; Queue < Pin < HttpResponse >> response_queue_ ; StreamBuffer input_buffer_ { 16 * 1024 }; // Must be last! // Optional < Task > task_ ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/","text":"batteries/http/http_client_connection_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/http/http_chunk_decoder.hpp> #include <batteries/http/http_client_connection.hpp> #include <batteries/http/http_client_host_context.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ HttpClientConnection::HttpClientConnection ( HttpClientHostContext & context ) noexcept : context_ { context } , socket_ { this -> context_ . get_io_context ()} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL boost :: asio :: io_context & HttpClientConnection :: get_io_context () { return this -> context_ . get_io_context (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientConnection :: start () { this -> task_ . emplace ( this -> get_io_context (). get_executor (), [ this ] { auto executor = Task :: current (). get_executor (); Task process_requests_task { executor , [ this ] { this -> process_requests (). IgnoreError (); }}; Task process_responses_task { executor , [ this ] { this -> process_responses (). IgnoreError (); }}; process_requests_task . join (); process_responses_task . join (); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: open_connection () { StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint >> hosts = await_resolve ( this -> get_io_context (), this -> context_ . host_address ()); BATT_REQUIRE_OK ( hosts ); for ( const boost :: asio :: ip :: tcp :: endpoint & endpoint : * hosts ) { ErrorCode ec = Task :: await_connect ( this -> socket_ , endpoint ); if ( ! ec ) { return OkStatus (); } } return StatusCode :: kUnavailable ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: process_requests () { Optional < Task > fill_input_buffer_task ; auto on_exit = finally ([ this , & fill_input_buffer_task ] { boost :: system :: error_code ec ; this -> socket_ . shutdown ( boost :: asio :: socket_base :: shutdown_send , ec ); this -> response_queue_ . close (); if ( fill_input_buffer_task ) { fill_input_buffer_task -> join (); } }); bool connected = false ; for (;;) { Pin < HttpRequest > request ; Pin < HttpResponse > response ; BATT_ASSIGN_OK_RESULT ( std :: tie ( request , response ), this -> context_ . await_next_request ()); BATT_CHECK_NOT_NULLPTR ( request ); BATT_CHECK_NOT_NULLPTR ( response ); BATT_CHECK_EQ ( request -> state (). get_value (), HttpRequest :: kInitialized ); if ( ! connected ) { Status status = this -> open_connection (); if ( ! status . ok ()) { request -> update_status ( status ); request -> state (). close (); } BATT_REQUIRE_OK ( status ); connected = true ; fill_input_buffer_task . emplace ( Task :: current (). get_executor (), [ this ] { this -> fill_input_buffer (). IgnoreError (); }); } this -> response_queue_ . push ( response ); Status status = request -> serialize ( this -> socket_ ); BATT_REQUIRE_OK ( status ); request -> state (). set_value ( HttpRequest :: kConsumed ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: fill_input_buffer () { auto on_exit = finally ([ this ] { this -> input_buffer_ . close_for_write (); }); for (;;) { // Allocate some space in the input buffer for incoming data. // StatusOr < SmallVec < MutableBuffer , 2 >> buffer = this -> input_buffer_ . prepare_at_least ( 1 ); BATT_REQUIRE_OK ( buffer ); // Read data from the socket into the buffer. // auto n_read = Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { this -> socket_ . async_read_some ( * buffer , BATT_FORWARD ( handler )); }); BATT_REQUIRE_OK ( n_read ); // Assuming we were successful, commit the read data so it can be consumed by the parser task. // this -> input_buffer_ . commit ( * n_read ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: process_responses () { auto on_exit = finally ([ this ] { this -> input_buffer_ . close_for_read (); }); for (;;) { BATT_ASSIGN_OK_RESULT ( Pin < HttpResponse > const response , this -> response_queue_ . await_next ()); BATT_CHECK_NOT_NULLPTR ( response ); pico_http :: Response response_message ; StatusOr < i32 > message_length = this -> read_next_response ( response_message ); BATT_REQUIRE_OK ( message_length ); ResponseInfo response_info ( response_message ); if ( ! response_info . is_valid ()) { response -> update_status ( StatusCode :: kInvalidArgument ); response -> state (). close (); return StatusCode :: kInvalidArgument ; } response -> state (). set_value ( HttpResponse :: kInitialized ); // Pass control over to the consumer and wait for it to signal it is done reading the message headers. // Status message_consumed = response -> await_set_message ( response_message ); BATT_REQUIRE_OK ( message_consumed ); // The consume is done with the message; consume it and move on to the body. // this -> input_buffer_ . consume ( * message_length ); HttpData response_data { response_info . get_data ( this -> input_buffer_ )}; response -> await_set_data ( response_data ). IgnoreError (); // // We must not touch `response` after `await_set_data` returns! // If we are going to keep the connection alive, we must consume any extra data that wasn't read by // the application. Otherwise we just close it. // if ( response_info . keep_alive ) { Status data_consumed = std :: move ( response_data ) | seq :: consume (); BATT_REQUIRE_OK ( data_consumed ); } else { boost :: system :: error_code ec ; this -> socket_ . close ( ec ); return OkStatus (); } } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < i32 > HttpClientConnection :: read_next_response ( pico_http :: Response & response ) { i32 result = 0 ; usize min_to_fetch = 1 ; for (;;) { StatusOr < SmallVec < ConstBuffer , 2 >> fetched = this -> input_buffer_ . fetch_at_least ( min_to_fetch ); BATT_REQUIRE_OK ( fetched ); auto & buffers = * fetched ; const usize n_bytes_fetched = boost :: asio :: buffer_size ( buffers ); BATT_CHECK ( ! buffers . empty ()); result = response . parse ( buffers . front ()); if ( result == pico_http :: kParseIncomplete ) { min_to_fetch = std :: max ( min_to_fetch + 1 , n_bytes_fetched ); continue ; } if ( result == pico_http :: kParseFailed ) { return { StatusCode :: kInternal }; } BATT_CHECK_GT ( result , 0 ); return result ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientConnection :: join () { if ( this -> task_ ) { this -> task_ -> join (); this -> task_ = None ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // HttpClientConnection :: ResponseInfo :: ResponseInfo ( const pico_http :: Response & response ) : content_length { find_header ( response . headers , \"Content-Length\" ). flat_map ([]( std :: string_view s ) { return Optional { from_string < usize > ( std :: string ( s ))}; })} , keep_alive { find_header ( response . headers , \"Connection\" ) . map ([]( std :: string_view s ) { return s == \"keep-alive\" ; }) . value_or ( response . major_version == 1 && response . minor_version >= 1 )} , chunked_encoding { find_header ( response . headers , \"Transfer-Encoding\" ) . map ([]( std :: string_view s ) { return s == \"chunked\" ; }) . value_or ( false )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // HttpData HttpClientConnection :: ResponseInfo :: get_data ( StreamBuffer & input_buffer ) { return HttpData {[ & ]() -> BufferSource { if ( this -> content_length == None ) { if ( this -> chunked_encoding ) { return HttpChunkDecoder < StreamBuffer &> { input_buffer }; } else { if ( this -> keep_alive ) { return BufferSource {}; } else { return std :: ref ( input_buffer ); } } } else { if ( this -> chunked_encoding ) { return HttpChunkDecoder < StreamBuffer &> { input_buffer } | seq :: take_n ( * this -> content_length ); } else { return input_buffer | seq :: take_n ( * this -> content_length ); } } }()}; } } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_connection_impl.hpp"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#batteries_http_http_client_connection_impl_hpp","text":"1 #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP()","title":"BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/http/http_chunk_decoder.hpp> #include <batteries/http/http_client_connection.hpp> #include <batteries/http/http_client_host_context.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ HttpClientConnection::HttpClientConnection ( HttpClientHostContext & context ) noexcept : context_ { context } , socket_ { this -> context_ . get_io_context ()} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL boost :: asio :: io_context & HttpClientConnection :: get_io_context () { return this -> context_ . get_io_context (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientConnection :: start () { this -> task_ . emplace ( this -> get_io_context (). get_executor (), [ this ] { auto executor = Task :: current (). get_executor (); Task process_requests_task { executor , [ this ] { this -> process_requests (). IgnoreError (); }}; Task process_responses_task { executor , [ this ] { this -> process_responses (). IgnoreError (); }}; process_requests_task . join (); process_responses_task . join (); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: open_connection () { StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint >> hosts = await_resolve ( this -> get_io_context (), this -> context_ . host_address ()); BATT_REQUIRE_OK ( hosts ); for ( const boost :: asio :: ip :: tcp :: endpoint & endpoint : * hosts ) { ErrorCode ec = Task :: await_connect ( this -> socket_ , endpoint ); if ( ! ec ) { return OkStatus (); } } return StatusCode :: kUnavailable ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: process_requests () { Optional < Task > fill_input_buffer_task ; auto on_exit = finally ([ this , & fill_input_buffer_task ] { boost :: system :: error_code ec ; this -> socket_ . shutdown ( boost :: asio :: socket_base :: shutdown_send , ec ); this -> response_queue_ . close (); if ( fill_input_buffer_task ) { fill_input_buffer_task -> join (); } }); bool connected = false ; for (;;) { Pin < HttpRequest > request ; Pin < HttpResponse > response ; BATT_ASSIGN_OK_RESULT ( std :: tie ( request , response ), this -> context_ . await_next_request ()); BATT_CHECK_NOT_NULLPTR ( request ); BATT_CHECK_NOT_NULLPTR ( response ); BATT_CHECK_EQ ( request -> state (). get_value (), HttpRequest :: kInitialized ); if ( ! connected ) { Status status = this -> open_connection (); if ( ! status . ok ()) { request -> update_status ( status ); request -> state (). close (); } BATT_REQUIRE_OK ( status ); connected = true ; fill_input_buffer_task . emplace ( Task :: current (). get_executor (), [ this ] { this -> fill_input_buffer (). IgnoreError (); }); } this -> response_queue_ . push ( response ); Status status = request -> serialize ( this -> socket_ ); BATT_REQUIRE_OK ( status ); request -> state (). set_value ( HttpRequest :: kConsumed ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: fill_input_buffer () { auto on_exit = finally ([ this ] { this -> input_buffer_ . close_for_write (); }); for (;;) { // Allocate some space in the input buffer for incoming data. // StatusOr < SmallVec < MutableBuffer , 2 >> buffer = this -> input_buffer_ . prepare_at_least ( 1 ); BATT_REQUIRE_OK ( buffer ); // Read data from the socket into the buffer. // auto n_read = Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { this -> socket_ . async_read_some ( * buffer , BATT_FORWARD ( handler )); }); BATT_REQUIRE_OK ( n_read ); // Assuming we were successful, commit the read data so it can be consumed by the parser task. // this -> input_buffer_ . commit ( * n_read ); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClientConnection :: process_responses () { auto on_exit = finally ([ this ] { this -> input_buffer_ . close_for_read (); }); for (;;) { BATT_ASSIGN_OK_RESULT ( Pin < HttpResponse > const response , this -> response_queue_ . await_next ()); BATT_CHECK_NOT_NULLPTR ( response ); pico_http :: Response response_message ; StatusOr < i32 > message_length = this -> read_next_response ( response_message ); BATT_REQUIRE_OK ( message_length ); ResponseInfo response_info ( response_message ); if ( ! response_info . is_valid ()) { response -> update_status ( StatusCode :: kInvalidArgument ); response -> state (). close (); return StatusCode :: kInvalidArgument ; } response -> state (). set_value ( HttpResponse :: kInitialized ); // Pass control over to the consumer and wait for it to signal it is done reading the message headers. // Status message_consumed = response -> await_set_message ( response_message ); BATT_REQUIRE_OK ( message_consumed ); // The consume is done with the message; consume it and move on to the body. // this -> input_buffer_ . consume ( * message_length ); HttpData response_data { response_info . get_data ( this -> input_buffer_ )}; response -> await_set_data ( response_data ). IgnoreError (); // // We must not touch `response` after `await_set_data` returns! // If we are going to keep the connection alive, we must consume any extra data that wasn't read by // the application. Otherwise we just close it. // if ( response_info . keep_alive ) { Status data_consumed = std :: move ( response_data ) | seq :: consume (); BATT_REQUIRE_OK ( data_consumed ); } else { boost :: system :: error_code ec ; this -> socket_ . close ( ec ); return OkStatus (); } } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < i32 > HttpClientConnection :: read_next_response ( pico_http :: Response & response ) { i32 result = 0 ; usize min_to_fetch = 1 ; for (;;) { StatusOr < SmallVec < ConstBuffer , 2 >> fetched = this -> input_buffer_ . fetch_at_least ( min_to_fetch ); BATT_REQUIRE_OK ( fetched ); auto & buffers = * fetched ; const usize n_bytes_fetched = boost :: asio :: buffer_size ( buffers ); BATT_CHECK ( ! buffers . empty ()); result = response . parse ( buffers . front ()); if ( result == pico_http :: kParseIncomplete ) { min_to_fetch = std :: max ( min_to_fetch + 1 , n_bytes_fetched ); continue ; } if ( result == pico_http :: kParseFailed ) { return { StatusCode :: kInternal }; } BATT_CHECK_GT ( result , 0 ); return result ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientConnection :: join () { if ( this -> task_ ) { this -> task_ -> join (); this -> task_ = None ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // HttpClientConnection :: ResponseInfo :: ResponseInfo ( const pico_http :: Response & response ) : content_length { find_header ( response . headers , \"Content-Length\" ). flat_map ([]( std :: string_view s ) { return Optional { from_string < usize > ( std :: string ( s ))}; })} , keep_alive { find_header ( response . headers , \"Connection\" ) . map ([]( std :: string_view s ) { return s == \"keep-alive\" ; }) . value_or ( response . major_version == 1 && response . minor_version >= 1 )} , chunked_encoding { find_header ( response . headers , \"Transfer-Encoding\" ) . map ([]( std :: string_view s ) { return s == \"chunked\" ; }) . value_or ( false )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // HttpData HttpClientConnection :: ResponseInfo :: get_data ( StreamBuffer & input_buffer ) { return HttpData {[ & ]() -> BufferSource { if ( this -> content_length == None ) { if ( this -> chunked_encoding ) { return HttpChunkDecoder < StreamBuffer &> { input_buffer }; } else { if ( this -> keep_alive ) { return BufferSource {}; } else { return std :: ref ( input_buffer ); } } } else { if ( this -> chunked_encoding ) { return HttpChunkDecoder < StreamBuffer &> { input_buffer } | seq :: take_n ( * this -> content_length ); } else { return input_buffer | seq :: take_n ( * this -> content_length ); } } }()}; } } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__host__context_8hpp/","text":"batteries/http/http_client_host_context.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/http/http_client_host_context_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/http/http_client_host_context_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_host_context.hpp"},{"location":"_autogen/Files/http__client__host__context_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/http/http_client_host_context_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/http/http_client_host_context_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/","text":"batteries/http/http_client_host_context_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpClientHostContext Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP #include <batteries/config.hpp> #include <batteries/http/http_client_connection_decl.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/task.hpp> #include <batteries/async/watch.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/small_vec.hpp> #include <tuple> namespace batt { class HttpClient ; class HttpRequest ; class HttpResponse ; class HttpClientHostContext : public RefCounted < HttpClientHostContext > { public : static constexpr usize kDefaultMaxConnections = 2 ; //+++++++++++-+-+--+----- --- -- - - - - explicit HttpClientHostContext ( HttpClient & client , const HostAddress & host_address ); //+++++++++++-+-+--+----- --- -- - - - - boost :: asio :: io_context & get_io_context (); HttpClient & client () const noexcept { return this -> client_ ; } Status submit_request ( Pin < HttpRequest >&& request , Pin < HttpResponse >&& response ) { this -> request_queue_ . push ( std :: make_tuple ( std :: move ( request ), std :: move ( response ))); return OkStatus (); } void join () { this -> task_ . join (); } bool can_grow () const { return this -> connection_tasks_ . size () < this -> max_connections_ . get_value (); } const HostAddress & host_address () const { return this -> host_address_ ; } StatusOr < std :: tuple < Pin < HttpRequest > , Pin < HttpResponse >>> await_next_request () { return this -> request_queue_ . await_next (); } private : void host_task_main (); void create_connection (); //+++++++++++-+-+--+----- --- -- - - - - HttpClient & client_ ; HostAddress host_address_ ; Queue < std :: tuple < Pin < HttpRequest > , Pin < HttpResponse >>> request_queue_ ; Watch < usize > max_connections_ { HttpClientHostContext :: kDefaultMaxConnections }; Task task_ ; SmallVec < std :: unique_ptr < HttpClientConnection > , HttpClientHostContext :: kDefaultMaxConnections > connection_tasks_ ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_host_context_decl.hpp"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#classes","text":"Name class batt::HttpClientHostContext","title":"Classes"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP","title":"Defines"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#batteries_http_http_client_host_context_decl_hpp","text":"1 #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP()","title":"BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP #include <batteries/config.hpp> #include <batteries/http/http_client_connection_decl.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/task.hpp> #include <batteries/async/watch.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/small_vec.hpp> #include <tuple> namespace batt { class HttpClient ; class HttpRequest ; class HttpResponse ; class HttpClientHostContext : public RefCounted < HttpClientHostContext > { public : static constexpr usize kDefaultMaxConnections = 2 ; //+++++++++++-+-+--+----- --- -- - - - - explicit HttpClientHostContext ( HttpClient & client , const HostAddress & host_address ); //+++++++++++-+-+--+----- --- -- - - - - boost :: asio :: io_context & get_io_context (); HttpClient & client () const noexcept { return this -> client_ ; } Status submit_request ( Pin < HttpRequest >&& request , Pin < HttpResponse >&& response ) { this -> request_queue_ . push ( std :: make_tuple ( std :: move ( request ), std :: move ( response ))); return OkStatus (); } void join () { this -> task_ . join (); } bool can_grow () const { return this -> connection_tasks_ . size () < this -> max_connections_ . get_value (); } const HostAddress & host_address () const { return this -> host_address_ ; } StatusOr < std :: tuple < Pin < HttpRequest > , Pin < HttpResponse >>> await_next_request () { return this -> request_queue_ . await_next (); } private : void host_task_main (); void create_connection (); //+++++++++++-+-+--+----- --- -- - - - - HttpClient & client_ ; HostAddress host_address_ ; Queue < std :: tuple < Pin < HttpRequest > , Pin < HttpResponse >>> request_queue_ ; Watch < usize > max_connections_ { HttpClientHostContext :: kDefaultMaxConnections }; Task task_ ; SmallVec < std :: unique_ptr < HttpClientConnection > , HttpClientHostContext :: kDefaultMaxConnections > connection_tasks_ ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/","text":"batteries/http/http_client_host_context_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/http/http_client.hpp> #include <batteries/http/http_client_host_context.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ HttpClientHostContext::HttpClientHostContext ( HttpClient & client , const HostAddress & host_addr ) : client_ { client } , host_address_ { host_addr } , task_ { this -> client_ . get_io_context (). get_executor (), [ this ] { this -> host_task_main (); }} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL boost :: asio :: io_context & HttpClientHostContext :: get_io_context () { return this -> client_ . get_io_context (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientHostContext :: host_task_main () { Status status = [ & ]() -> Status { auto on_scope_exit = batt :: finally ([ & ] { for ( auto & connection : this -> connection_tasks_ ) { connection -> join (); } }); for (;;) { const usize queue_depth = this -> request_queue_ . size (); if ( queue_depth > 0 && this -> can_grow ()) { this -> create_connection (); } StatusOr < i64 > new_queue_depth = this -> request_queue_ . await_size_is_truly ([ & ]( i64 size ) { return size != BATT_CHECKED_CAST ( i64 , queue_depth ); }); BATT_REQUIRE_OK ( new_queue_depth ); } }(); status . IgnoreError (); // TODO [tastolfi 2022-03-17] do something better! } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientHostContext :: create_connection () { auto connection = std :: make_unique < HttpClientConnection > ( /*context=*/ * this ); connection -> start (); this -> connection_tasks_ . emplace_back ( std :: move ( connection )); } } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_host_context_impl.hpp"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#batteries_http_http_client_host_context_impl_hpp","text":"1 #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP()","title":"BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP #define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/http/http_client.hpp> #include <batteries/http/http_client_host_context.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ HttpClientHostContext::HttpClientHostContext ( HttpClient & client , const HostAddress & host_addr ) : client_ { client } , host_address_ { host_addr } , task_ { this -> client_ . get_io_context (). get_executor (), [ this ] { this -> host_task_main (); }} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL boost :: asio :: io_context & HttpClientHostContext :: get_io_context () { return this -> client_ . get_io_context (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientHostContext :: host_task_main () { Status status = [ & ]() -> Status { auto on_scope_exit = batt :: finally ([ & ] { for ( auto & connection : this -> connection_tasks_ ) { connection -> join (); } }); for (;;) { const usize queue_depth = this -> request_queue_ . size (); if ( queue_depth > 0 && this -> can_grow ()) { this -> create_connection (); } StatusOr < i64 > new_queue_depth = this -> request_queue_ . await_size_is_truly ([ & ]( i64 size ) { return size != BATT_CHECKED_CAST ( i64 , queue_depth ); }); BATT_REQUIRE_OK ( new_queue_depth ); } }(); status . IgnoreError (); // TODO [tastolfi 2022-03-17] do something better! } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpClientHostContext :: create_connection () { auto connection = std :: make_unique < HttpClientConnection > ( /*context=*/ * this ); connection -> start (); this -> connection_tasks_ . emplace_back ( std :: move ( connection )); } } // namespace batt #endif // BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__client__impl_8hpp/","text":"batteries/http/http_client_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HTTP_CLIENT_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_CLIENT_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_CLIENT_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_CLIENT_IMPL_HPP #define BATTERIES_HTTP_CLIENT_IMPL_HPP #include <batteries/config.hpp> // namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClient :: submit_request ( const HostAddress & host_address , Pin < HttpRequest >&& request , Pin < HttpResponse >&& response ) { BATT_CHECK_NOT_NULLPTR ( request ); BATT_CHECK_NOT_NULLPTR ( response ); SharedPtr < HttpClientHostContext > host_context = [ & ] { auto locked_contexts = this -> host_contexts_ . lock (); auto iter = locked_contexts -> find ( host_address ); if ( iter == locked_contexts -> end ()) { iter = locked_contexts -> emplace ( host_address , make_shared < HttpClientHostContext > ( /*client=*/ * this , host_address )) . first ; } return iter -> second ; }(); return host_context -> submit_request ( std :: move ( request ), std :: move ( response )); } } // namespace batt #endif // BATTERIES_HTTP_CLIENT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_client_impl.hpp"},{"location":"_autogen/Files/http__client__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__client__impl_8hpp/#defines","text":"Name BATTERIES_HTTP_CLIENT_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/http__client__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__client__impl_8hpp/#batteries_http_client_impl_hpp","text":"1 #define BATTERIES_HTTP_CLIENT_IMPL_HPP()","title":"BATTERIES_HTTP_CLIENT_IMPL_HPP"},{"location":"_autogen/Files/http__client__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_CLIENT_IMPL_HPP #define BATTERIES_HTTP_CLIENT_IMPL_HPP #include <batteries/config.hpp> // namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status HttpClient :: submit_request ( const HostAddress & host_address , Pin < HttpRequest >&& request , Pin < HttpResponse >&& response ) { BATT_CHECK_NOT_NULLPTR ( request ); BATT_CHECK_NOT_NULLPTR ( response ); SharedPtr < HttpClientHostContext > host_context = [ & ] { auto locked_contexts = this -> host_contexts_ . lock (); auto iter = locked_contexts -> find ( host_address ); if ( iter == locked_contexts -> end ()) { iter = locked_contexts -> emplace ( host_address , make_shared < HttpClientHostContext > ( /*client=*/ * this , host_address )) . first ; } return iter -> second ; }(); return host_context -> submit_request ( std :: move ( request ), std :: move ( response )); } } // namespace batt #endif // BATTERIES_HTTP_CLIENT_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__data_8hpp/","text":"batteries/http/http_data.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::HttpData Defines \ud83d\udd17 Name BATTERIES_HTTP_DATA_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_DATA_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_DATA_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_DATA_HPP #define BATTERIES_HTTP_DATA_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <batteries/strong_typedef.hpp> namespace batt { struct HttpData { BufferSource source ; bool empty () const { return ! this -> source ; } usize size () const { if ( ! this -> source ) { return 0 ; } return this -> source . size (); } StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) { if ( ! this -> source ) { return { StatusCode :: kEndOfStream }; } return this -> source . fetch_at_least ( min_count ); } void consume ( i64 count ) { if ( this -> source ) { this -> source . consume ( count ); } } void close_for_read () { if ( this -> source ) { this -> source . close_for_read (); } } }; BATT_STRONG_TYPEDEF ( bool , IncludeHttpTrailer ); } // namespace batt #endif // BATTERIES_HTTP_DATA_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_data.hpp"},{"location":"_autogen/Files/http__data_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__data_8hpp/#classes","text":"Name struct batt::HttpData","title":"Classes"},{"location":"_autogen/Files/http__data_8hpp/#defines","text":"Name BATTERIES_HTTP_DATA_HPP","title":"Defines"},{"location":"_autogen/Files/http__data_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__data_8hpp/#batteries_http_data_hpp","text":"1 #define BATTERIES_HTTP_DATA_HPP()","title":"BATTERIES_HTTP_DATA_HPP"},{"location":"_autogen/Files/http__data_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_DATA_HPP #define BATTERIES_HTTP_DATA_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <batteries/strong_typedef.hpp> namespace batt { struct HttpData { BufferSource source ; bool empty () const { return ! this -> source ; } usize size () const { if ( ! this -> source ) { return 0 ; } return this -> source . size (); } StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ) { if ( ! this -> source ) { return { StatusCode :: kEndOfStream }; } return this -> source . fetch_at_least ( min_count ); } void consume ( i64 count ) { if ( this -> source ) { this -> source . consume ( count ); } } void close_for_read () { if ( this -> source ) { this -> source . close_for_read (); } } }; BATT_STRONG_TYPEDEF ( bool , IncludeHttpTrailer ); } // namespace batt #endif // BATTERIES_HTTP_DATA_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__header_8hpp/","text":"batteries/http/http_header.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HTTP_HEADER_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HEADER_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HEADER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HEADER_HPP #define BATTERIES_HTTP_HEADER_HPP #include <batteries/config.hpp> // #include <batteries/pico_http/parser.hpp> namespace batt { using HttpHeader = :: pico_http :: MessageHeader ; inline Optional < std :: string_view > find_header ( const SmallVecBase < HttpHeader >& headers , const std :: string_view & name ) { const auto iter = std :: find_if ( headers . begin (), headers . end (), [ & ]( const HttpHeader & hdr ) { return hdr . name == name ; }); if ( iter == headers . end ()) { return None ; } return iter -> value ; } } // namespace batt #endif // BATTERIES_HTTP_HEADER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_header.hpp"},{"location":"_autogen/Files/http__header_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__header_8hpp/#defines","text":"Name BATTERIES_HTTP_HEADER_HPP","title":"Defines"},{"location":"_autogen/Files/http__header_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__header_8hpp/#batteries_http_header_hpp","text":"1 #define BATTERIES_HTTP_HEADER_HPP()","title":"BATTERIES_HTTP_HEADER_HPP"},{"location":"_autogen/Files/http__header_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HEADER_HPP #define BATTERIES_HTTP_HEADER_HPP #include <batteries/config.hpp> // #include <batteries/pico_http/parser.hpp> namespace batt { using HttpHeader = :: pico_http :: MessageHeader ; inline Optional < std :: string_view > find_header ( const SmallVecBase < HttpHeader >& headers , const std :: string_view & name ) { const auto iter = std :: find_if ( headers . begin (), headers . end (), [ & ]( const HttpHeader & hdr ) { return hdr . name == name ; }); if ( iter == headers . end ()) { return None ; } return iter -> value ; } } // namespace batt #endif // BATTERIES_HTTP_HEADER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__message__base_8hpp/","text":"batteries/http/http_message_base.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpMessageBase Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP #define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP #include <batteries/config.hpp> // #include <batteries/http/http_data.hpp> #include <batteries/http/http_header.hpp> #include <batteries/async/channel.hpp> #include <batteries/async/pin.hpp> #include <batteries/async/task.hpp> #include <batteries/async/watch.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <string_view> namespace batt { template < typename T > class HttpMessageBase : public Pinnable { public : using Message = T ; enum State { kCreated = 0 , kInitialized = 1 , kConsumed = 2 , }; HttpMessageBase ( const HttpMessageBase & ) = delete ; HttpMessageBase & operator = ( const HttpMessageBase & ) = delete ; HttpMessageBase () { } ~ HttpMessageBase () { this -> release_message (); this -> release_data (); } Watch < i32 >& state () { return this -> state_ ; } void update_status ( Status status ) { this -> status_ . Update ( status ); } Status get_status () const { return this -> status_ ; } //+++++++++++-+-+--+----- --- -- - - - - void async_set_message ( Message & message ) { this -> message_ . async_write ( message , []( Status status ) { status . IgnoreError (); }); } Status await_set_message ( Message & message ) { return this -> message_ . write ( message ); } StatusOr < Message &> await_message () { return this -> message_ . read (); } Message & await_message_or_panic () { StatusOr < Message &> msg = this -> await_message (); BATT_CHECK_OK ( msg ); return * msg ; } void release_message () { if ( this -> message_ . is_active ()) { this -> message_ . consume (); } } void async_set_data ( HttpData & data ) { this -> data_ . async_write ( data , []( Status status ) { status . IgnoreError (); }); } Status await_set_data ( HttpData & data ) { return this -> data_ . write ( data ); } StatusOr < HttpData &> await_data () { this -> release_message (); return this -> data_ . read (); } void release_data () { if ( this -> data_ . is_active ()) { this -> data_ . consume (); } } //+++++++++++-+-+--+----- --- -- - - - - const SmallVecBase < HttpHeader >& headers () const { return this -> await_message_or_panic (). headers ; } Optional < std :: string_view > find_header ( const std :: string_view & name ) const { return :: batt :: find_header ( this -> headers (), name ); } //+++++++++++-+-+--+----- --- -- - - - - protected : Status status_ { OkStatus ()}; Watch < i32 > state_ { kCreated }; Channel < Message > message_ ; Channel < HttpData > data_ ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_message_base.hpp"},{"location":"_autogen/Files/http__message__base_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__message__base_8hpp/#classes","text":"Name class batt::HttpMessageBase","title":"Classes"},{"location":"_autogen/Files/http__message__base_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP","title":"Defines"},{"location":"_autogen/Files/http__message__base_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__message__base_8hpp/#batteries_http_http_message_base_hpp","text":"1 #define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP()","title":"BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP"},{"location":"_autogen/Files/http__message__base_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP #define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP #include <batteries/config.hpp> // #include <batteries/http/http_data.hpp> #include <batteries/http/http_header.hpp> #include <batteries/async/channel.hpp> #include <batteries/async/pin.hpp> #include <batteries/async/task.hpp> #include <batteries/async/watch.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <string_view> namespace batt { template < typename T > class HttpMessageBase : public Pinnable { public : using Message = T ; enum State { kCreated = 0 , kInitialized = 1 , kConsumed = 2 , }; HttpMessageBase ( const HttpMessageBase & ) = delete ; HttpMessageBase & operator = ( const HttpMessageBase & ) = delete ; HttpMessageBase () { } ~ HttpMessageBase () { this -> release_message (); this -> release_data (); } Watch < i32 >& state () { return this -> state_ ; } void update_status ( Status status ) { this -> status_ . Update ( status ); } Status get_status () const { return this -> status_ ; } //+++++++++++-+-+--+----- --- -- - - - - void async_set_message ( Message & message ) { this -> message_ . async_write ( message , []( Status status ) { status . IgnoreError (); }); } Status await_set_message ( Message & message ) { return this -> message_ . write ( message ); } StatusOr < Message &> await_message () { return this -> message_ . read (); } Message & await_message_or_panic () { StatusOr < Message &> msg = this -> await_message (); BATT_CHECK_OK ( msg ); return * msg ; } void release_message () { if ( this -> message_ . is_active ()) { this -> message_ . consume (); } } void async_set_data ( HttpData & data ) { this -> data_ . async_write ( data , []( Status status ) { status . IgnoreError (); }); } Status await_set_data ( HttpData & data ) { return this -> data_ . write ( data ); } StatusOr < HttpData &> await_data () { this -> release_message (); return this -> data_ . read (); } void release_data () { if ( this -> data_ . is_active ()) { this -> data_ . consume (); } } //+++++++++++-+-+--+----- --- -- - - - - const SmallVecBase < HttpHeader >& headers () const { return this -> await_message_or_panic (). headers ; } Optional < std :: string_view > find_header ( const std :: string_view & name ) const { return :: batt :: find_header ( this -> headers (), name ); } //+++++++++++-+-+--+----- --- -- - - - - protected : Status status_ { OkStatus ()}; Watch < i32 > state_ { kCreated }; Channel < Message > message_ ; Channel < HttpData > data_ ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__request_8hpp/","text":"batteries/http/http_request.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpRequest Defines \ud83d\udd17 Name BATTERIES_HTTP_REQUEST_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_REQUEST_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_REQUEST_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_REQUEST_HPP #define BATTERIES_HTTP_REQUEST_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/http/http_data.hpp> #include <batteries/http/http_header.hpp> #include <batteries/http/http_message_base.hpp> #include <batteries/int_types.hpp> #include <batteries/status.hpp> #include <batteries/stream_util.hpp> #include <string_view> namespace batt { class HttpRequest : public HttpMessageBase < pico_http :: Request > { public : using HttpMessageBase < pico_http :: Request >:: HttpMessageBase ; template < typename AsyncWriteStream > Status serialize ( AsyncWriteStream & stream ) { StatusOr < pico_http :: Request &> message = this -> await_message (); BATT_REQUIRE_OK ( message ); const std :: string message_str = to_string ( * message ); this -> release_message (); StatusOr < HttpData &> data = this -> await_data (); BATT_REQUIRE_OK ( data ); //----- --- -- - - - - auto on_scope_exit = finally ([ & ] { this -> release_data (); }); //----- --- -- - - - StatusOr < usize > bytes_written = // * data // | seq :: prepend ( make_buffer ( message_str )) // | seq :: write_to ( stream ); BATT_REQUIRE_OK ( bytes_written ); return OkStatus (); } }; } // namespace batt #endif // BATTERIES_HTTP_REQUEST_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_request.hpp"},{"location":"_autogen/Files/http__request_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__request_8hpp/#classes","text":"Name class batt::HttpRequest","title":"Classes"},{"location":"_autogen/Files/http__request_8hpp/#defines","text":"Name BATTERIES_HTTP_REQUEST_HPP","title":"Defines"},{"location":"_autogen/Files/http__request_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__request_8hpp/#batteries_http_request_hpp","text":"1 #define BATTERIES_HTTP_REQUEST_HPP()","title":"BATTERIES_HTTP_REQUEST_HPP"},{"location":"_autogen/Files/http__request_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_REQUEST_HPP #define BATTERIES_HTTP_REQUEST_HPP #include <batteries/config.hpp> // #include <batteries/async/buffer_source.hpp> #include <batteries/http/http_data.hpp> #include <batteries/http/http_header.hpp> #include <batteries/http/http_message_base.hpp> #include <batteries/int_types.hpp> #include <batteries/status.hpp> #include <batteries/stream_util.hpp> #include <string_view> namespace batt { class HttpRequest : public HttpMessageBase < pico_http :: Request > { public : using HttpMessageBase < pico_http :: Request >:: HttpMessageBase ; template < typename AsyncWriteStream > Status serialize ( AsyncWriteStream & stream ) { StatusOr < pico_http :: Request &> message = this -> await_message (); BATT_REQUIRE_OK ( message ); const std :: string message_str = to_string ( * message ); this -> release_message (); StatusOr < HttpData &> data = this -> await_data (); BATT_REQUIRE_OK ( data ); //----- --- -- - - - - auto on_scope_exit = finally ([ & ] { this -> release_data (); }); //----- --- -- - - - StatusOr < usize > bytes_written = // * data // | seq :: prepend ( make_buffer ( message_str )) // | seq :: write_to ( stream ); BATT_REQUIRE_OK ( bytes_written ); return OkStatus (); } }; } // namespace batt #endif // BATTERIES_HTTP_REQUEST_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__response_8hpp/","text":"batteries/http/http_response.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpResponse Defines \ud83d\udd17 Name BATTERIES_HTTP_RESPONSE_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_RESPONSE_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_RESPONSE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_RESPONSE_HPP #define BATTERIES_HTTP_RESPONSE_HPP #include <batteries/config.hpp> // #include <batteries/http/http_message_base.hpp> #include <batteries/pico_http/parser.hpp> #include <batteries/int_types.hpp> namespace batt { class HttpResponse : public HttpMessageBase < pico_http :: Response > { public : using HttpMessageBase < pico_http :: Response >:: HttpMessageBase ; i32 major_version () { return this -> await_message_or_panic (). major_version ; } i32 minor_version () { return this -> await_message_or_panic (). minor_version ; } i32 code () { return this -> await_message_or_panic (). status ; } std :: string_view message_text () { return this -> await_message_or_panic (). message ; } }; } // namespace batt #endif // BATTERIES_HTTP_RESPONSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_response.hpp"},{"location":"_autogen/Files/http__response_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__response_8hpp/#classes","text":"Name class batt::HttpResponse","title":"Classes"},{"location":"_autogen/Files/http__response_8hpp/#defines","text":"Name BATTERIES_HTTP_RESPONSE_HPP","title":"Defines"},{"location":"_autogen/Files/http__response_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__response_8hpp/#batteries_http_response_hpp","text":"1 #define BATTERIES_HTTP_RESPONSE_HPP()","title":"BATTERIES_HTTP_RESPONSE_HPP"},{"location":"_autogen/Files/http__response_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_RESPONSE_HPP #define BATTERIES_HTTP_RESPONSE_HPP #include <batteries/config.hpp> // #include <batteries/http/http_message_base.hpp> #include <batteries/pico_http/parser.hpp> #include <batteries/int_types.hpp> namespace batt { class HttpResponse : public HttpMessageBase < pico_http :: Response > { public : using HttpMessageBase < pico_http :: Response >:: HttpMessageBase ; i32 major_version () { return this -> await_message_or_panic (). major_version ; } i32 minor_version () { return this -> await_message_or_panic (). minor_version ; } i32 code () { return this -> await_message_or_panic (). status ; } std :: string_view message_text () { return this -> await_message_or_panic (). message ; } }; } // namespace batt #endif // BATTERIES_HTTP_RESPONSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__server_8hpp/","text":"batteries/http/http_server.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::HttpServer Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_SERVER_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_SERVER_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_SERVER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_SERVER_HPP #define BATTERIES_HTTP_HTTP_SERVER_HPP #include <batteries/config.hpp> #include <batteries/http/http_request.hpp> #include <batteries/http/http_response.hpp> #include <batteries/async/task.hpp> #include <batteries/async/watch.hpp> #include <batteries/small_fn.hpp> #include <batteries/status.hpp> #include <boost/asio/io_context.hpp> #include <memory> namespace batt { class HttpServer { public : using RequestDispatcherFn = SmallFn < StatusOr < std :: unique_ptr < HttpResponse >> ( const HttpRequest & request ) > ; using RequestDispatcherFactoryFn = SmallFn < StatusOr < RequestDispatcherFn > () > ; explicit HttpServer ( boost :: asio :: io_context & io , HostAddress && host_address , RequestDispatcherFactoryFn && dispatcher_factory ) noexcept ; ~ HttpServer () noexcept ; boost :: asio :: io_context & get_io_context () const noexcept { return this -> io_ ; } void halt (); void join (); Status get_final_status () const ; //+++++++++++-+-+--+----- --- -- - - - - private : void acceptor_task_main (); //+++++++++++-+-+--+----- --- -- - - - - boost :: asio :: io_context & io_ ; HostAddress host_address_ ; RequestDispatcherFactoryFn dispatcher_factory_ ; Watch < bool > halt_requested_ { false }; Status final_status_ ; Task acceptor_task_ ; }; } // namespace batt #if BATT_HEADER_ONLY #include <batteries/http/http_server_impl.hpp> #endif // BATT_HEADER_ONLY #endif // BATTERIES_HTTP_HTTP_SERVER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_server.hpp"},{"location":"_autogen/Files/http__server_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__server_8hpp/#classes","text":"Name class batt::HttpServer","title":"Classes"},{"location":"_autogen/Files/http__server_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_HPP","title":"Defines"},{"location":"_autogen/Files/http__server_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__server_8hpp/#batteries_http_http_server_hpp","text":"1 #define BATTERIES_HTTP_HTTP_SERVER_HPP()","title":"BATTERIES_HTTP_HTTP_SERVER_HPP"},{"location":"_autogen/Files/http__server_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_SERVER_HPP #define BATTERIES_HTTP_HTTP_SERVER_HPP #include <batteries/config.hpp> #include <batteries/http/http_request.hpp> #include <batteries/http/http_response.hpp> #include <batteries/async/task.hpp> #include <batteries/async/watch.hpp> #include <batteries/small_fn.hpp> #include <batteries/status.hpp> #include <boost/asio/io_context.hpp> #include <memory> namespace batt { class HttpServer { public : using RequestDispatcherFn = SmallFn < StatusOr < std :: unique_ptr < HttpResponse >> ( const HttpRequest & request ) > ; using RequestDispatcherFactoryFn = SmallFn < StatusOr < RequestDispatcherFn > () > ; explicit HttpServer ( boost :: asio :: io_context & io , HostAddress && host_address , RequestDispatcherFactoryFn && dispatcher_factory ) noexcept ; ~ HttpServer () noexcept ; boost :: asio :: io_context & get_io_context () const noexcept { return this -> io_ ; } void halt (); void join (); Status get_final_status () const ; //+++++++++++-+-+--+----- --- -- - - - - private : void acceptor_task_main (); //+++++++++++-+-+--+----- --- -- - - - - boost :: asio :: io_context & io_ ; HostAddress host_address_ ; RequestDispatcherFactoryFn dispatcher_factory_ ; Watch < bool > halt_requested_ { false }; Status final_status_ ; Task acceptor_task_ ; }; } // namespace batt #if BATT_HEADER_ONLY #include <batteries/http/http_server_impl.hpp> #endif // BATT_HEADER_ONLY #endif // BATTERIES_HTTP_HTTP_SERVER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__server__impl_8hpp/","text":"batteries/http/http_server_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #pragma once #ifndef BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP #define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP #include <batteries/config.hpp> #include <batteries/http/http_server.hpp> #include <batteries/assert.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ HttpServer::HttpServer ( boost :: asio :: io_context & io , HostAddress && host_address , RequestDispatcherFactoryFn && dispatcher_factory ) noexcept : io_ { io } , host_address_ { std :: move ( host_address )} , dispatcher_factory_ { std :: move ( dispatcher_factory )} , acceptor_task_ { io . get_executor (), [ this ] { this -> acceptor_task_main (); }, \"HttpServer::acceptor_task\" } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL HttpServer ::~ HttpServer () noexcept { this -> halt (); this -> join (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpServer :: halt () { this -> halt_requested_ . set_value ( true ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpServer :: join () { this -> acceptor_task_ . join (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpServer :: acceptor_task_main () { this -> final_status_ = [ & ]() -> Status { BATT_CHECK_EQ ( this -> host_address_ . scheme , \"http\" ) << \"TODO [tastolfi 2022-05-06] implement https!\" ; }(); } } // namespace batt #endif // BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_server_impl.hpp"},{"location":"_autogen/Files/http__server__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__server__impl_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/http__server__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__server__impl_8hpp/#batteries_http_http_server_impl_hpp","text":"1 #define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP()","title":"BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP"},{"location":"_autogen/Files/http__server__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #pragma once #ifndef BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP #define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP #include <batteries/config.hpp> #include <batteries/http/http_server.hpp> #include <batteries/assert.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ HttpServer::HttpServer ( boost :: asio :: io_context & io , HostAddress && host_address , RequestDispatcherFactoryFn && dispatcher_factory ) noexcept : io_ { io } , host_address_ { std :: move ( host_address )} , dispatcher_factory_ { std :: move ( dispatcher_factory )} , acceptor_task_ { io . get_executor (), [ this ] { this -> acceptor_task_main (); }, \"HttpServer::acceptor_task\" } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL HttpServer ::~ HttpServer () noexcept { this -> halt (); this -> join (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpServer :: halt () { this -> halt_requested_ . set_value ( true ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpServer :: join () { this -> acceptor_task_ . join (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void HttpServer :: acceptor_task_main () { this -> final_status_ = [ & ]() -> Status { BATT_CHECK_EQ ( this -> host_address_ . scheme , \"http\" ) << \"TODO [tastolfi 2022-05-06] implement https!\" ; }(); } } // namespace batt #endif // BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/http__version_8hpp/","text":"batteries/http/http_version.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::HttpVersion Defines \ud83d\udd17 Name BATTERIES_HTTP_HTTP_VERSION_HPP Macro Documentation \ud83d\udd17 BATTERIES_HTTP_HTTP_VERSION_HPP \ud83d\udd17 1 #define BATTERIES_HTTP_HTTP_VERSION_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_VERSION_HPP #define BATTERIES_HTTP_HTTP_VERSION_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> namespace batt { struct HttpVersion { i32 major_version ; i32 minor_version ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_VERSION_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/http/http_version.hpp"},{"location":"_autogen/Files/http__version_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/http__version_8hpp/#classes","text":"Name struct batt::HttpVersion","title":"Classes"},{"location":"_autogen/Files/http__version_8hpp/#defines","text":"Name BATTERIES_HTTP_HTTP_VERSION_HPP","title":"Defines"},{"location":"_autogen/Files/http__version_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/http__version_8hpp/#batteries_http_http_version_hpp","text":"1 #define BATTERIES_HTTP_HTTP_VERSION_HPP()","title":"BATTERIES_HTTP_HTTP_VERSION_HPP"},{"location":"_autogen/Files/http__version_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_HTTP_HTTP_VERSION_HPP #define BATTERIES_HTTP_HTTP_VERSION_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> namespace batt { struct HttpVersion { i32 major_version ; i32 minor_version ; }; } // namespace batt #endif // BATTERIES_HTTP_HTTP_VERSION_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/int__types_8hpp/","text":"batteries/int_types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::int_types Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <cstddef> #include <cstdint> namespace batt { namespace int_types { // ============================================================================= // Integral type definitions - adopt Rust style, to make code more concise. // using u8 = std :: uint8_t ; using i8 = std :: int8_t ; using u16 = std :: uint16_t ; using i16 = std :: int16_t ; using u32 = std :: uint32_t ; using i32 = std :: int32_t ; using u64 = std :: uint64_t ; using i64 = std :: int64_t ; using usize = std :: size_t ; using isize = std :: ptrdiff_t ; } // namespace int_types using namespace int_types ; } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/int_types.hpp"},{"location":"_autogen/Files/int__types_8hpp/#namespaces","text":"Name batt batt::int_types","title":"Namespaces"},{"location":"_autogen/Files/int__types_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <cstddef> #include <cstdint> namespace batt { namespace int_types { // ============================================================================= // Integral type definitions - adopt Rust style, to make code more concise. // using u8 = std :: uint8_t ; using i8 = std :: int8_t ; using u16 = std :: uint16_t ; using i16 = std :: int16_t ; using u32 = std :: uint32_t ; using i32 = std :: int32_t ; using u64 = std :: uint64_t ; using i64 = std :: int64_t ; using usize = std :: size_t ; using isize = std :: ptrdiff_t ; } // namespace int_types using namespace int_types ; } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/interval_8hpp/","text":"batteries/interval.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::IClosedOpen struct batt::IClosed struct batt::BasicInterval struct batt::BasicInterval struct batt::BasicInterval::LinearOrder struct batt::BasicInterval::LexicographicalOrder Defines \ud83d\udd17 Name BATTERIES_INTERVAL_HPP Macro Documentation \ud83d\udd17 BATTERIES_INTERVAL_HPP \ud83d\udd17 1 #define BATTERIES_INTERVAL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_INTERVAL_HPP #define BATTERIES_INTERVAL_HPP #include <batteries/config.hpp> // #include <batteries/interval_traits.hpp> #include <batteries/seq/reverse.hpp> #include <batteries/small_vec.hpp> #include <cstddef> #include <ostream> namespace batt { template < typename T , typename U = T > struct IClosedOpen : IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , seq :: NaturalOrder , seq :: NaturalEquals > { }; template < typename T , typename U = T > struct IClosed : IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , seq :: NaturalOrder , seq :: NaturalEquals > { }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Traits > struct BasicInterval ; template < typename T > using Interval = BasicInterval < IClosedOpen < T >> ; template < typename T > using CInterval = BasicInterval < IClosed < T >> ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Traits > struct BasicInterval { using traits_type = Traits ; typename Traits :: lower_bound_type lower_bound ; typename Traits :: upper_bound_type upper_bound ; auto size () const { return Traits :: size ( this -> lower_bound , this -> upper_bound ); } bool empty () const { return Traits :: empty ( this -> lower_bound , this -> upper_bound ); } template < typename V > bool contains ( const V & item ) const { return Traits :: lower_includes_x ( this -> lower_bound , item ) && Traits :: x_included_by_upper ( item , this -> upper_bound ); } template < typename ThatTraits > bool adjacent_to ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); // The intervals are adjacent if no non-empty interval can be constructed between them. // return Traits :: adjacent ( this -> lower_bound , this -> upper_bound , that . lower_bound , that . upper_bound ); } template < typename ThatTraits > BasicInterval union_with ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); return BasicInterval { std :: min ( this -> lower_bound , that . lower_bound ), std :: max ( this -> upper_bound , that . upper_bound )}; } template < typename ThatTraits > bool overlaps ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); return ! Traits :: empty ( that . lower_bound , this -> upper_bound ) && ! ThatTraits :: empty ( this -> lower_bound , that . upper_bound ); } template < typename ThatTraits > BasicInterval intersection_with ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); BasicInterval i { . lower_bound = Traits :: max ( this -> lower_bound , that . lower_bound ), . upper_bound = Traits :: min ( this -> upper_bound , that . upper_bound ), }; if ( i . empty ()) { return BasicInterval { this -> lower_bound , this -> lower_bound }; } return i ; } SmallVec < BasicInterval , 2 > without ( const BasicInterval & that ) const { if ( this -> empty ()) { return {}; } BasicInterval first { this -> lower_bound , Traits :: min ( this -> upper_bound , that . lower_bound )}; BasicInterval second { Traits :: max ( this -> lower_bound , that . upper_bound ), this -> upper_bound }; if ( first . adjacent_to ( second )) { return { * this }; } SmallVec < BasicInterval , 2 > diff ; if ( ! first . empty ()) { diff . emplace_back ( first ); } if ( ! second . empty ()) { diff . emplace_back ( second ); } return diff ; } template < typename TraitsL , typename TraitsR > friend bool operator == ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ); template < typename TraitsL , typename TraitsR > friend bool operator != ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ); template < typename TraitsT > friend std :: ostream & operator << ( std :: ostream & out , const BasicInterval < TraitsT >& t ); // Partial order on Interval values that corresponds to a strict ordering on a one dimensional number // line; i.e. requires that the lower bound of the \"greater\" interval is greater than or equal to the // upper bound of the \"lesser.\" // struct LinearOrder { template < typename TraitsL , typename TraitsR > bool operator ()( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) const { static_assert ( interval_traits_compatible < TraitsL , TraitsR > (), \"\" ); return TraitsL :: empty ( r . lower_bound , l . upper_bound ); } template < typename L , typename TraitsR > bool operator ()( const L & l , const BasicInterval < TraitsR >& r ) const { return TraitsR :: x_excluded_by_lower ( l , r . lower_bound ); } template < typename TraitsL , typename R > bool operator ()( const BasicInterval < TraitsL >& l , const R & r ) const { return TraitsL :: upper_excludes_x ( l . upper_bound , r ); } }; // For max-heaps. // using ReverseLinearOrder = seq :: Reverse < LinearOrder > ; // Total order that sorts intervals first by lower bound, then by upper bound. // struct LexicographicalOrder { template < typename TraitsL , typename TraitsR > bool operator ()( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) const { static_assert ( interval_traits_compatible < TraitsL , TraitsR > (), \"\" ); return TraitsL :: less_than ( l . lower_bound , r . lower_bound ) || ( TraitsL :: equal ( l . lower_bound , r . lower_bound ) && TraitsL :: less_than ( l . upper_bound , r . upper_bound )); } }; // Reverse of LexicographicalOrder; so max-heap functions can be used to implement a min-heap. // using ReverseLexicographicalOrder = seq :: Reverse < LexicographicalOrder > ; }; template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_back ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound , i . upper_bound + delta }; } template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_front ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound - delta , i . upper_bound }; } template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_back ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound , i . upper_bound - delta }; } template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_front ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound + delta , i . upper_bound }; } template < typename T , typename U > BasicInterval < IClosedOpen < std :: decay_t < T > , std :: decay_t < U >>> make_interval ( T && lower , U && upper ) { return { BATT_FORWARD ( lower ), BATT_FORWARD ( upper )}; } template < typename TraitsL , typename TraitsR > inline bool operator == ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) { return interval_traits_compatible < TraitsL , TraitsR > () && TraitsL :: equal ( l . lower_bound , r . lower_bound ) && TraitsL :: equal ( l . upper_bound , r . upper_bound ); } template < typename TraitsL , typename TraitsR > inline bool operator != ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) { return ! ( l == r ); } template < typename Traits > inline std :: ostream & operator << ( std :: ostream & out , const BasicInterval < Traits >& t ) { return out << Traits :: left_bracket () << t . lower_bound << \",\" << t . upper_bound << Traits :: right_bracket (); } } // namespace batt #endif // BATTERIES_INTERVAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/interval.hpp"},{"location":"_autogen/Files/interval_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/interval_8hpp/#classes","text":"Name struct batt::IClosedOpen struct batt::IClosed struct batt::BasicInterval struct batt::BasicInterval struct batt::BasicInterval::LinearOrder struct batt::BasicInterval::LexicographicalOrder","title":"Classes"},{"location":"_autogen/Files/interval_8hpp/#defines","text":"Name BATTERIES_INTERVAL_HPP","title":"Defines"},{"location":"_autogen/Files/interval_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/interval_8hpp/#batteries_interval_hpp","text":"1 #define BATTERIES_INTERVAL_HPP()","title":"BATTERIES_INTERVAL_HPP"},{"location":"_autogen/Files/interval_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_INTERVAL_HPP #define BATTERIES_INTERVAL_HPP #include <batteries/config.hpp> // #include <batteries/interval_traits.hpp> #include <batteries/seq/reverse.hpp> #include <batteries/small_vec.hpp> #include <cstddef> #include <ostream> namespace batt { template < typename T , typename U = T > struct IClosedOpen : IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , seq :: NaturalOrder , seq :: NaturalEquals > { }; template < typename T , typename U = T > struct IClosed : IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , seq :: NaturalOrder , seq :: NaturalEquals > { }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Traits > struct BasicInterval ; template < typename T > using Interval = BasicInterval < IClosedOpen < T >> ; template < typename T > using CInterval = BasicInterval < IClosed < T >> ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Traits > struct BasicInterval { using traits_type = Traits ; typename Traits :: lower_bound_type lower_bound ; typename Traits :: upper_bound_type upper_bound ; auto size () const { return Traits :: size ( this -> lower_bound , this -> upper_bound ); } bool empty () const { return Traits :: empty ( this -> lower_bound , this -> upper_bound ); } template < typename V > bool contains ( const V & item ) const { return Traits :: lower_includes_x ( this -> lower_bound , item ) && Traits :: x_included_by_upper ( item , this -> upper_bound ); } template < typename ThatTraits > bool adjacent_to ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); // The intervals are adjacent if no non-empty interval can be constructed between them. // return Traits :: adjacent ( this -> lower_bound , this -> upper_bound , that . lower_bound , that . upper_bound ); } template < typename ThatTraits > BasicInterval union_with ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); return BasicInterval { std :: min ( this -> lower_bound , that . lower_bound ), std :: max ( this -> upper_bound , that . upper_bound )}; } template < typename ThatTraits > bool overlaps ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); return ! Traits :: empty ( that . lower_bound , this -> upper_bound ) && ! ThatTraits :: empty ( this -> lower_bound , that . upper_bound ); } template < typename ThatTraits > BasicInterval intersection_with ( const BasicInterval < ThatTraits >& that ) const { static_assert ( interval_traits_compatible < Traits , ThatTraits > (), \"\" ); BasicInterval i { . lower_bound = Traits :: max ( this -> lower_bound , that . lower_bound ), . upper_bound = Traits :: min ( this -> upper_bound , that . upper_bound ), }; if ( i . empty ()) { return BasicInterval { this -> lower_bound , this -> lower_bound }; } return i ; } SmallVec < BasicInterval , 2 > without ( const BasicInterval & that ) const { if ( this -> empty ()) { return {}; } BasicInterval first { this -> lower_bound , Traits :: min ( this -> upper_bound , that . lower_bound )}; BasicInterval second { Traits :: max ( this -> lower_bound , that . upper_bound ), this -> upper_bound }; if ( first . adjacent_to ( second )) { return { * this }; } SmallVec < BasicInterval , 2 > diff ; if ( ! first . empty ()) { diff . emplace_back ( first ); } if ( ! second . empty ()) { diff . emplace_back ( second ); } return diff ; } template < typename TraitsL , typename TraitsR > friend bool operator == ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ); template < typename TraitsL , typename TraitsR > friend bool operator != ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ); template < typename TraitsT > friend std :: ostream & operator << ( std :: ostream & out , const BasicInterval < TraitsT >& t ); // Partial order on Interval values that corresponds to a strict ordering on a one dimensional number // line; i.e. requires that the lower bound of the \"greater\" interval is greater than or equal to the // upper bound of the \"lesser.\" // struct LinearOrder { template < typename TraitsL , typename TraitsR > bool operator ()( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) const { static_assert ( interval_traits_compatible < TraitsL , TraitsR > (), \"\" ); return TraitsL :: empty ( r . lower_bound , l . upper_bound ); } template < typename L , typename TraitsR > bool operator ()( const L & l , const BasicInterval < TraitsR >& r ) const { return TraitsR :: x_excluded_by_lower ( l , r . lower_bound ); } template < typename TraitsL , typename R > bool operator ()( const BasicInterval < TraitsL >& l , const R & r ) const { return TraitsL :: upper_excludes_x ( l . upper_bound , r ); } }; // For max-heaps. // using ReverseLinearOrder = seq :: Reverse < LinearOrder > ; // Total order that sorts intervals first by lower bound, then by upper bound. // struct LexicographicalOrder { template < typename TraitsL , typename TraitsR > bool operator ()( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) const { static_assert ( interval_traits_compatible < TraitsL , TraitsR > (), \"\" ); return TraitsL :: less_than ( l . lower_bound , r . lower_bound ) || ( TraitsL :: equal ( l . lower_bound , r . lower_bound ) && TraitsL :: less_than ( l . upper_bound , r . upper_bound )); } }; // Reverse of LexicographicalOrder; so max-heap functions can be used to implement a min-heap. // using ReverseLexicographicalOrder = seq :: Reverse < LexicographicalOrder > ; }; template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_back ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound , i . upper_bound + delta }; } template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_front ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound - delta , i . upper_bound }; } template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_back ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound , i . upper_bound - delta }; } template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_front ( const BasicInterval < TraitsT >& i , DeltaT delta ) { return { i . lower_bound + delta , i . upper_bound }; } template < typename T , typename U > BasicInterval < IClosedOpen < std :: decay_t < T > , std :: decay_t < U >>> make_interval ( T && lower , U && upper ) { return { BATT_FORWARD ( lower ), BATT_FORWARD ( upper )}; } template < typename TraitsL , typename TraitsR > inline bool operator == ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) { return interval_traits_compatible < TraitsL , TraitsR > () && TraitsL :: equal ( l . lower_bound , r . lower_bound ) && TraitsL :: equal ( l . upper_bound , r . upper_bound ); } template < typename TraitsL , typename TraitsR > inline bool operator != ( const BasicInterval < TraitsL >& l , const BasicInterval < TraitsR >& r ) { return ! ( l == r ); } template < typename Traits > inline std :: ostream & operator << ( std :: ostream & out , const BasicInterval < Traits >& t ) { return out << Traits :: left_bracket () << t . lower_bound << \",\" << t . upper_bound << Traits :: right_bracket (); } } // namespace batt #endif // BATTERIES_INTERVAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/interval__traits_8hpp/","text":"batteries/interval_traits.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::IntervalTraits struct batt::IntervalTraitsBase struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn > struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn > Defines \ud83d\udd17 Name BATTERIES_INTERVAL_TRAITS_HPP Macro Documentation \ud83d\udd17 BATTERIES_INTERVAL_TRAITS_HPP \ud83d\udd17 1 #define BATTERIES_INTERVAL_TRAITS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_INTERVAL_TRAITS_HPP #define BATTERIES_INTERVAL_TRAITS_HPP #include <batteries/config.hpp> // #include <batteries/bounds.hpp> #include <batteries/seq/natural_equals.hpp> #include <batteries/seq/natural_order.hpp> #include <type_traits> namespace batt { template < typename T , typename U , InclusiveLowerBound kLowerInclusive , InclusiveUpperBound kUpperInclusive , typename OrderFn , typename EqualFn > struct IntervalTraits ; template < typename Derived , typename OrderFn , typename EqualFn > struct IntervalTraitsBase { using Base = IntervalTraitsBase ; template < typename T0 , typename T1 > static bool less_than ( const T0 & left , const T1 & right ) { return OrderFn {}( left , right ); } template < typename T0 , typename T1 > static std :: common_type_t < T0 , T1 > min ( const T0 & left , const T1 & right ) { if ( Base :: less_than ( right , left )) { return right ; } else { return left ; } } template < typename T0 , typename T1 > static std :: common_type_t < T0 , T1 > max ( const T0 & left , const T1 & right ) { if ( Base :: less_than ( left , right )) { return right ; } else { return left ; } } template < typename T0 , typename T1 > static bool equal ( const T0 & left , const T1 & right ) { return EqualFn {}( left , right ); } template < typename T0 , typename T1 > static bool not_equal ( const T0 & left , const T1 & right ) { return ! Base :: equal ( left , right ); } template < typename T0 , typename T1 > static bool greater_than ( const T0 & left , const T1 & right ) { return Base :: less_than ( right , left ); } template < typename T0 , typename T1 > static bool less_or_equal ( const T0 & left , const T1 & right ) { return ! Base :: greater_than ( left , right ); } template < typename T0 , typename T1 > static bool greater_or_equal ( const T0 & left , const T1 & right ) { return ! Base :: less_than ( left , right ); } template < typename T0 , typename T1 > static bool x_included_by_lower ( const T0 & x , const T1 & lower ) { return Derived :: lower_includes_x ( lower , x ); } template < typename T0 , typename T1 > static bool upper_includes_x ( const T0 & upper , const T1 & x ) { return Derived :: x_included_by_upper ( x , upper ); } template < typename T0 , typename T1 > static bool lower_excludes_x ( const T0 & lower , const T0 & x ) { return ! Derived :: lower_includes_x ( lower , x ); } template < typename T0 , typename T1 > static bool x_excluded_by_upper ( const T0 & x , const T1 & upper ) { return ! Derived :: x_included_by_upper ( x , upper ); } template < typename T0 , typename T1 > static bool x_excluded_by_lower ( const T0 & x , const T1 & lower ) { return ! Derived :: x_included_by_lower ( x , lower ); } template < typename T0 , typename T1 > static bool upper_excludes_x ( const T0 & upper , const T1 & x ) { return ! Derived :: upper_includes_x ( upper , x ); } }; template < typename T , typename U , typename OrderFn , typename EqualFn > struct IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn > : IntervalTraitsBase < IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn > , OrderFn , EqualFn > { // static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ; static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kFalse ; using lower_bound_type = T ; using upper_bound_type = U ; using Self = IntervalTraits ; static std :: ptrdiff_t size ( const T & lower , const U & upper ) { return upper - lower ; } static bool empty ( const T & lower , const U & upper ) { return Self :: less_or_equal ( upper , lower ); } template < typename V > static bool lower_includes_x ( const T & lower , const V & x ) { return Self :: less_or_equal ( lower , x ); } template < typename V > static bool x_included_by_upper ( const V & x , const U & upper ) { return Self :: less_than ( x , upper ); } template < typename T1 , typename U1 > static bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper ) { return ! Self :: less_than ( a_upper , b_lower ) && ! Self :: less_than ( b_upper , a_lower ); } static char left_bracket () { return '[' ; } static char right_bracket () { return ')' ; } }; template < typename T , typename U , typename OrderFn , typename EqualFn > struct IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn > : IntervalTraitsBase < IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn > , OrderFn , EqualFn > { // static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ; static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kTrue ; using lower_bound_type = T ; using upper_bound_type = U ; using Self = IntervalTraits ; static std :: ptrdiff_t size ( const T & lower , const U & upper ) { return upper - lower + 1 ; } static bool empty ( const T & lower , const U & upper ) { return Self :: less_than ( upper , lower ); } template < typename V > static bool lower_includes_x ( const T & lower , const V & x ) { return Self :: less_or_equal ( lower , x ); } template < typename V > static bool x_included_by_upper ( const V & x , const U & upper ) { return Self :: less_or_equal ( x , upper ); } template < typename T1 , typename U1 > static bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper ) { return Self :: lower_includes_x ( a_lower , least_upper_bound ( b_upper )) && Self :: x_included_by_upper ( b_lower , least_upper_bound ( a_upper )); } static char left_bracket () { return '[' ; } static char right_bracket () { return ']' ; } }; template < typename Traits0 , typename Traits1 > inline constexpr bool interval_traits_compatible () { return Traits0 :: inclusive_lower_bound == Traits1 :: inclusive_lower_bound && Traits0 :: inclusive_upper_bound == Traits1 :: inclusive_upper_bound ; } } // namespace batt #endif // BATTERIES_INTERVAL_TRAITS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/interval_traits.hpp"},{"location":"_autogen/Files/interval__traits_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/interval__traits_8hpp/#classes","text":"Name struct batt::IntervalTraits struct batt::IntervalTraitsBase struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn > struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn >","title":"Classes"},{"location":"_autogen/Files/interval__traits_8hpp/#defines","text":"Name BATTERIES_INTERVAL_TRAITS_HPP","title":"Defines"},{"location":"_autogen/Files/interval__traits_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/interval__traits_8hpp/#batteries_interval_traits_hpp","text":"1 #define BATTERIES_INTERVAL_TRAITS_HPP()","title":"BATTERIES_INTERVAL_TRAITS_HPP"},{"location":"_autogen/Files/interval__traits_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_INTERVAL_TRAITS_HPP #define BATTERIES_INTERVAL_TRAITS_HPP #include <batteries/config.hpp> // #include <batteries/bounds.hpp> #include <batteries/seq/natural_equals.hpp> #include <batteries/seq/natural_order.hpp> #include <type_traits> namespace batt { template < typename T , typename U , InclusiveLowerBound kLowerInclusive , InclusiveUpperBound kUpperInclusive , typename OrderFn , typename EqualFn > struct IntervalTraits ; template < typename Derived , typename OrderFn , typename EqualFn > struct IntervalTraitsBase { using Base = IntervalTraitsBase ; template < typename T0 , typename T1 > static bool less_than ( const T0 & left , const T1 & right ) { return OrderFn {}( left , right ); } template < typename T0 , typename T1 > static std :: common_type_t < T0 , T1 > min ( const T0 & left , const T1 & right ) { if ( Base :: less_than ( right , left )) { return right ; } else { return left ; } } template < typename T0 , typename T1 > static std :: common_type_t < T0 , T1 > max ( const T0 & left , const T1 & right ) { if ( Base :: less_than ( left , right )) { return right ; } else { return left ; } } template < typename T0 , typename T1 > static bool equal ( const T0 & left , const T1 & right ) { return EqualFn {}( left , right ); } template < typename T0 , typename T1 > static bool not_equal ( const T0 & left , const T1 & right ) { return ! Base :: equal ( left , right ); } template < typename T0 , typename T1 > static bool greater_than ( const T0 & left , const T1 & right ) { return Base :: less_than ( right , left ); } template < typename T0 , typename T1 > static bool less_or_equal ( const T0 & left , const T1 & right ) { return ! Base :: greater_than ( left , right ); } template < typename T0 , typename T1 > static bool greater_or_equal ( const T0 & left , const T1 & right ) { return ! Base :: less_than ( left , right ); } template < typename T0 , typename T1 > static bool x_included_by_lower ( const T0 & x , const T1 & lower ) { return Derived :: lower_includes_x ( lower , x ); } template < typename T0 , typename T1 > static bool upper_includes_x ( const T0 & upper , const T1 & x ) { return Derived :: x_included_by_upper ( x , upper ); } template < typename T0 , typename T1 > static bool lower_excludes_x ( const T0 & lower , const T0 & x ) { return ! Derived :: lower_includes_x ( lower , x ); } template < typename T0 , typename T1 > static bool x_excluded_by_upper ( const T0 & x , const T1 & upper ) { return ! Derived :: x_included_by_upper ( x , upper ); } template < typename T0 , typename T1 > static bool x_excluded_by_lower ( const T0 & x , const T1 & lower ) { return ! Derived :: x_included_by_lower ( x , lower ); } template < typename T0 , typename T1 > static bool upper_excludes_x ( const T0 & upper , const T1 & x ) { return ! Derived :: upper_includes_x ( upper , x ); } }; template < typename T , typename U , typename OrderFn , typename EqualFn > struct IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn > : IntervalTraitsBase < IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kFalse , OrderFn , EqualFn > , OrderFn , EqualFn > { // static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ; static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kFalse ; using lower_bound_type = T ; using upper_bound_type = U ; using Self = IntervalTraits ; static std :: ptrdiff_t size ( const T & lower , const U & upper ) { return upper - lower ; } static bool empty ( const T & lower , const U & upper ) { return Self :: less_or_equal ( upper , lower ); } template < typename V > static bool lower_includes_x ( const T & lower , const V & x ) { return Self :: less_or_equal ( lower , x ); } template < typename V > static bool x_included_by_upper ( const V & x , const U & upper ) { return Self :: less_than ( x , upper ); } template < typename T1 , typename U1 > static bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper ) { return ! Self :: less_than ( a_upper , b_lower ) && ! Self :: less_than ( b_upper , a_lower ); } static char left_bracket () { return '[' ; } static char right_bracket () { return ')' ; } }; template < typename T , typename U , typename OrderFn , typename EqualFn > struct IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn > : IntervalTraitsBase < IntervalTraits < T , U , InclusiveLowerBound :: kTrue , InclusiveUpperBound :: kTrue , OrderFn , EqualFn > , OrderFn , EqualFn > { // static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound :: kTrue ; static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound :: kTrue ; using lower_bound_type = T ; using upper_bound_type = U ; using Self = IntervalTraits ; static std :: ptrdiff_t size ( const T & lower , const U & upper ) { return upper - lower + 1 ; } static bool empty ( const T & lower , const U & upper ) { return Self :: less_than ( upper , lower ); } template < typename V > static bool lower_includes_x ( const T & lower , const V & x ) { return Self :: less_or_equal ( lower , x ); } template < typename V > static bool x_included_by_upper ( const V & x , const U & upper ) { return Self :: less_or_equal ( x , upper ); } template < typename T1 , typename U1 > static bool adjacent ( const T & a_lower , const U & a_upper , const T1 & b_lower , const U1 & b_upper ) { return Self :: lower_includes_x ( a_lower , least_upper_bound ( b_upper )) && Self :: x_included_by_upper ( b_lower , least_upper_bound ( a_upper )); } static char left_bracket () { return '[' ; } static char right_bracket () { return ']' ; } }; template < typename Traits0 , typename Traits1 > inline constexpr bool interval_traits_compatible () { return Traits0 :: inclusive_lower_bound == Traits1 :: inclusive_lower_bound && Traits0 :: inclusive_upper_bound == Traits1 :: inclusive_upper_bound ; } } // namespace batt #endif // BATTERIES_INTERVAL_TRAITS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/io__result_8hpp/","text":"batteries/async/io_result.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::IOResult Defines \ud83d\udd17 Name BATTERIES_ASYNC_IO_RESULT_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_IO_RESULT_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_IO_RESULT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_IO_RESULT_HPP #define BATTERIES_ASYNC_IO_RESULT_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> #include <boost/system/error_code.hpp> #include <ostream> #include <tuple> #include <type_traits> namespace batt { using ErrorCode = boost :: system :: error_code ; template < typename ... Ts > class IOResult { public : using value_type = std :: tuple_element_t < 0 , std :: conditional_t < ( sizeof ...( Ts ) == 1 ), std :: tuple < Ts ... > , std :: tuple < std :: tuple < Ts ... >>>> ; template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < value_type , Args && ... >>> explicit IOResult ( const ErrorCode & ec , Args && ... args ) noexcept : ec_ { ec } , value_ { BATT_FORWARD ( args )...} { } bool ok () const { return ! bool { this -> ec_ }; } const ErrorCode & error () const { return this -> ec_ ; } value_type & operator * () { return value_ ; } const value_type & operator * () const { return value_ ; } value_type & value () { return this -> value_ ; } const value_type & value () const { return this -> value_ ; } value_type * operator -> () { return & this -> value_ ; } const value_type * operator -> () const { return & this -> value_ ; } private : ErrorCode ec_ ; value_type value_ ; }; template < typename ... Ts > inline std :: ostream & operator << ( std :: ostream & out , const IOResult < Ts ... >& t ) { return out << \"IOResult{.error=\" << t . error () << \"(\" << t . error (). message () << \"), .value=\" << make_printable ( t . value ()) << \",}\" ; } template < typename ... Ts > bool is_ok_status ( const IOResult < Ts ... >& io_result ) { return ! io_result . error (); } inline bool is_ok_status ( const ErrorCode & ec ) { return ! ec ; } template < typename ... Ts > Status to_status ( const IOResult < Ts ... >& io_result ) { return to_status ( io_result . error ()); } } // namespace batt #endif // BATTERIES_ASYNC_IO_RESULT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/io_result.hpp"},{"location":"_autogen/Files/io__result_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/io__result_8hpp/#classes","text":"Name class batt::IOResult","title":"Classes"},{"location":"_autogen/Files/io__result_8hpp/#defines","text":"Name BATTERIES_ASYNC_IO_RESULT_HPP","title":"Defines"},{"location":"_autogen/Files/io__result_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/io__result_8hpp/#batteries_async_io_result_hpp","text":"1 #define BATTERIES_ASYNC_IO_RESULT_HPP()","title":"BATTERIES_ASYNC_IO_RESULT_HPP"},{"location":"_autogen/Files/io__result_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_IO_RESULT_HPP #define BATTERIES_ASYNC_IO_RESULT_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> #include <boost/system/error_code.hpp> #include <ostream> #include <tuple> #include <type_traits> namespace batt { using ErrorCode = boost :: system :: error_code ; template < typename ... Ts > class IOResult { public : using value_type = std :: tuple_element_t < 0 , std :: conditional_t < ( sizeof ...( Ts ) == 1 ), std :: tuple < Ts ... > , std :: tuple < std :: tuple < Ts ... >>>> ; template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < value_type , Args && ... >>> explicit IOResult ( const ErrorCode & ec , Args && ... args ) noexcept : ec_ { ec } , value_ { BATT_FORWARD ( args )...} { } bool ok () const { return ! bool { this -> ec_ }; } const ErrorCode & error () const { return this -> ec_ ; } value_type & operator * () { return value_ ; } const value_type & operator * () const { return value_ ; } value_type & value () { return this -> value_ ; } const value_type & value () const { return this -> value_ ; } value_type * operator -> () { return & this -> value_ ; } const value_type * operator -> () const { return & this -> value_ ; } private : ErrorCode ec_ ; value_type value_ ; }; template < typename ... Ts > inline std :: ostream & operator << ( std :: ostream & out , const IOResult < Ts ... >& t ) { return out << \"IOResult{.error=\" << t . error () << \"(\" << t . error (). message () << \"), .value=\" << make_printable ( t . value ()) << \",}\" ; } template < typename ... Ts > bool is_ok_status ( const IOResult < Ts ... >& io_result ) { return ! io_result . error (); } inline bool is_ok_status ( const ErrorCode & ec ) { return ! ec ; } template < typename ... Ts > Status to_status ( const IOResult < Ts ... >& io_result ) { return to_status ( io_result . error ()); } } // namespace batt #endif // BATTERIES_ASYNC_IO_RESULT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/latch_8hpp/","text":"batteries/async/latch.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Latch class batt::Latch class batt::Latch::AsyncGetHandler Defines \ud83d\udd17 Name BATTERIES_ASYNC_LATCH_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_LATCH_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_LATCH_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_LATCH_HPP #define BATTERIES_ASYNC_LATCH_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/handler.hpp> #include <batteries/async/watch_decl.hpp> #include <batteries/optional.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> namespace batt { template < typename T > class Latch ; // A write-once, single-value synchronized container. // // Similar to a Future/Promise pair, but Latch has no defined copy/move semantics. // template < typename T > class Latch : public RefCounted < Latch < T >> { public : enum State : u32 { kInitial = 0 , kSetting = 1 , // 2 intentionally skipped; these states are treated as a bitmap of orthogonal conditions. kReady = 3 , }; Latch () = default ; Latch ( const Latch & ) = delete ; Latch & operator = ( const Latch & ) = delete ; // Sets the value, closing the latch. `args` are used to construct a `StatusOr<T>`, so you can pass an // instance of `T` to `set_value`, or a `Status` to indicate an error occurred. // template < typename ... Args > bool set_value ( Args && ... args ) { const u32 prior_state = this -> state_ . fetch_or ( kSetting ); if ( prior_state != kInitial ) { return false ; } this -> value_ . emplace ( BATT_FORWARD ( args )...); this -> state_ . set_value ( kReady ); return true ; } // Returns true iff the latch is in the ready state. // bool is_ready () const { return this -> state_ . get_value () == kReady ; } // Block the current task until the Latch is ready, then return the set value (or Status). // StatusOr < T > await () { Status status = this -> state_ . await_equal ( kReady ); BATT_REQUIRE_OK ( status ); return this -> get_ready_value_or_panic (); } // Same as `await()`, except this method never blocks; if the Latch isn't ready yet, it immediately // returns `StatusCode::kUnavailable`. // StatusOr < T > poll () { if ( this -> state_ . get_value () != kReady ) { return Status { StatusCode :: kUnavailable }; } return this -> get_ready_value_or_panic (); } // Returns the value of the Latch (non-blocking), panicking if it is not in the ready state. // StatusOr < T > get_ready_value_or_panic () { BATT_CHECK_EQ ( this -> state_ . get_value (), kReady ); BATT_CHECK ( this -> value_ ); return * this -> value_ ; } // Invokes `handler` when the Latch value is set (i.e., when it enters the ready state); invokes handler // immediately if the Latch is ready when this method is called. // template < typename Handler > void async_get ( Handler && handler ); // Force the latch into an invalid state (for testing mostly). // void invalidate () { this -> state_ . close (); } private : class AsyncGetHandler ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Watch < u32 > state_ { kInitial }; Optional < StatusOr < T >> value_ ; }; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ template < typename T > class Latch < T >:: AsyncGetHandler { public : explicit AsyncGetHandler ( Latch * latch ) noexcept : latch_ { latch } { } template < typename Handler > void operator ()( Handler && handler , const StatusOr < u32 >& result ) const { if ( ! result . ok ()) { BATT_FORWARD ( handler )( result . status ()); return ; } if ( * result == kReady ) { BATT_CHECK ( this -> latch_ -> value_ ); BATT_FORWARD ( handler )( * this -> latch_ -> value_ ); return ; } this -> latch_ -> state_ . async_wait ( /*last_seen=*/ * result , bind_handler ( BATT_FORWARD ( handler ), * this )); } private : Latch * latch_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Handler > inline void Latch < T >:: async_get ( Handler && handler ) { this -> state_ . async_wait ( kInitial , bind_handler ( BATT_FORWARD ( handler ), AsyncGetHandler { this })); } } // namespace batt #endif // BATTERIES_ASYNC_LATCH_HPP #include <batteries/config.hpp> #if BATT_HEADER_ONLY #include \"watch_impl.hpp\" #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/latch.hpp"},{"location":"_autogen/Files/latch_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/latch_8hpp/#classes","text":"Name class batt::Latch class batt::Latch class batt::Latch::AsyncGetHandler","title":"Classes"},{"location":"_autogen/Files/latch_8hpp/#defines","text":"Name BATTERIES_ASYNC_LATCH_HPP","title":"Defines"},{"location":"_autogen/Files/latch_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/latch_8hpp/#batteries_async_latch_hpp","text":"1 #define BATTERIES_ASYNC_LATCH_HPP()","title":"BATTERIES_ASYNC_LATCH_HPP"},{"location":"_autogen/Files/latch_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_LATCH_HPP #define BATTERIES_ASYNC_LATCH_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/handler.hpp> #include <batteries/async/watch_decl.hpp> #include <batteries/optional.hpp> #include <batteries/shared_ptr.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> namespace batt { template < typename T > class Latch ; // A write-once, single-value synchronized container. // // Similar to a Future/Promise pair, but Latch has no defined copy/move semantics. // template < typename T > class Latch : public RefCounted < Latch < T >> { public : enum State : u32 { kInitial = 0 , kSetting = 1 , // 2 intentionally skipped; these states are treated as a bitmap of orthogonal conditions. kReady = 3 , }; Latch () = default ; Latch ( const Latch & ) = delete ; Latch & operator = ( const Latch & ) = delete ; // Sets the value, closing the latch. `args` are used to construct a `StatusOr<T>`, so you can pass an // instance of `T` to `set_value`, or a `Status` to indicate an error occurred. // template < typename ... Args > bool set_value ( Args && ... args ) { const u32 prior_state = this -> state_ . fetch_or ( kSetting ); if ( prior_state != kInitial ) { return false ; } this -> value_ . emplace ( BATT_FORWARD ( args )...); this -> state_ . set_value ( kReady ); return true ; } // Returns true iff the latch is in the ready state. // bool is_ready () const { return this -> state_ . get_value () == kReady ; } // Block the current task until the Latch is ready, then return the set value (or Status). // StatusOr < T > await () { Status status = this -> state_ . await_equal ( kReady ); BATT_REQUIRE_OK ( status ); return this -> get_ready_value_or_panic (); } // Same as `await()`, except this method never blocks; if the Latch isn't ready yet, it immediately // returns `StatusCode::kUnavailable`. // StatusOr < T > poll () { if ( this -> state_ . get_value () != kReady ) { return Status { StatusCode :: kUnavailable }; } return this -> get_ready_value_or_panic (); } // Returns the value of the Latch (non-blocking), panicking if it is not in the ready state. // StatusOr < T > get_ready_value_or_panic () { BATT_CHECK_EQ ( this -> state_ . get_value (), kReady ); BATT_CHECK ( this -> value_ ); return * this -> value_ ; } // Invokes `handler` when the Latch value is set (i.e., when it enters the ready state); invokes handler // immediately if the Latch is ready when this method is called. // template < typename Handler > void async_get ( Handler && handler ); // Force the latch into an invalid state (for testing mostly). // void invalidate () { this -> state_ . close (); } private : class AsyncGetHandler ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Watch < u32 > state_ { kInitial }; Optional < StatusOr < T >> value_ ; }; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ template < typename T > class Latch < T >:: AsyncGetHandler { public : explicit AsyncGetHandler ( Latch * latch ) noexcept : latch_ { latch } { } template < typename Handler > void operator ()( Handler && handler , const StatusOr < u32 >& result ) const { if ( ! result . ok ()) { BATT_FORWARD ( handler )( result . status ()); return ; } if ( * result == kReady ) { BATT_CHECK ( this -> latch_ -> value_ ); BATT_FORWARD ( handler )( * this -> latch_ -> value_ ); return ; } this -> latch_ -> state_ . async_wait ( /*last_seen=*/ * result , bind_handler ( BATT_FORWARD ( handler ), * this )); } private : Latch * latch_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Handler > inline void Latch < T >:: async_get ( Handler && handler ) { this -> state_ . async_wait ( kInitial , bind_handler ( BATT_FORWARD ( handler ), AsyncGetHandler { this })); } } // namespace batt #endif // BATTERIES_ASYNC_LATCH_HPP #include <batteries/config.hpp> #if BATT_HEADER_ONLY #include \"watch_impl.hpp\" #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/lazy_8hpp/","text":"batteries/seq/lazy.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Lazy Defines \ud83d\udd17 Name BATTERIES_SEQ_LAZY_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_LAZY_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_LAZY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_LAZY_HPP #define BATTERIES_SEQ_LAZY_HPP #include <batteries/config.hpp> // #include <batteries/case_of.hpp> #include <batteries/optional.hpp> #include <batteries/utility.hpp> #include <type_traits> #include <variant> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // lazy - sequence created from a factory function when `peek()/next()` is first // invoked. // template < typename Fn > class Lazy { public : using Seq = decltype ( std :: declval < Fn > ()()); using Item = SeqItem < Seq > ; explicit Lazy ( Fn && fn ) noexcept : state_ { BATT_FORWARD ( fn )} { } Optional < Item > peek () { return this -> seq (). peek (); } Optional < Item > next () { return this -> seq (). next (); } private : Seq & seq () { case_of ( state_ , [ & ]( Fn & fn ) -> Seq & { Fn fn_copy = BATT_FORWARD ( fn ); return state_ . template emplace < Seq > ( fn_copy ()); }, []( Seq & seq ) -> Seq & { return seq ; }); } std :: variant < Fn , Seq > state_ ; }; template < typename Fn > [[ nodiscard ]] auto lazy ( Fn && fn ) { return Lazy < Fn > { BATT_FORWARD ( fn )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_LAZY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/lazy.hpp"},{"location":"_autogen/Files/lazy_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/lazy_8hpp/#classes","text":"Name class batt::seq::Lazy","title":"Classes"},{"location":"_autogen/Files/lazy_8hpp/#defines","text":"Name BATTERIES_SEQ_LAZY_HPP","title":"Defines"},{"location":"_autogen/Files/lazy_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/lazy_8hpp/#batteries_seq_lazy_hpp","text":"1 #define BATTERIES_SEQ_LAZY_HPP()","title":"BATTERIES_SEQ_LAZY_HPP"},{"location":"_autogen/Files/lazy_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_LAZY_HPP #define BATTERIES_SEQ_LAZY_HPP #include <batteries/config.hpp> // #include <batteries/case_of.hpp> #include <batteries/optional.hpp> #include <batteries/utility.hpp> #include <type_traits> #include <variant> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // lazy - sequence created from a factory function when `peek()/next()` is first // invoked. // template < typename Fn > class Lazy { public : using Seq = decltype ( std :: declval < Fn > ()()); using Item = SeqItem < Seq > ; explicit Lazy ( Fn && fn ) noexcept : state_ { BATT_FORWARD ( fn )} { } Optional < Item > peek () { return this -> seq (). peek (); } Optional < Item > next () { return this -> seq (). next (); } private : Seq & seq () { case_of ( state_ , [ & ]( Fn & fn ) -> Seq & { Fn fn_copy = BATT_FORWARD ( fn ); return state_ . template emplace < Seq > ( fn_copy ()); }, []( Seq & seq ) -> Seq & { return seq ; }); } std :: variant < Fn , Seq > state_ ; }; template < typename Fn > [[ nodiscard ]] auto lazy ( Fn && fn ) { return Lazy < Fn > { BATT_FORWARD ( fn )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_LAZY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/logging_8hpp/","text":"batteries/logging.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATTERIES_LOGGING_HPP BATT_LOG_DISABLED (...) BATT_LOG BATT_VLOG BATT_DLOG BATT_DVLOG Macro Documentation \ud83d\udd17 BATTERIES_LOGGING_HPP \ud83d\udd17 1 #define BATTERIES_LOGGING_HPP() BATT_LOG_DISABLED \ud83d\udd17 1 #define BATT_LOG_DISABLED(...) BATT_LOG \ud83d\udd17 1 #define BATT_LOG() BATT_VLOG \ud83d\udd17 1 #define BATT_VLOG() BATT_DLOG \ud83d\udd17 1 #define BATT_DLOG() BATT_DVLOG \ud83d\udd17 1 #define BATT_DVLOG() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_LOGGING_HPP #define BATTERIES_LOGGING_HPP #include <batteries/config.hpp> //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // #ifdef BATT_GLOG_AVAILABLE #include <glog/logging.h> #define BATT_LOG LOG #define BATT_VLOG VLOG #define BATT_DLOG DLOG #define BATT_DVLOG DLOG #else // ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #include <iostream> #define BATT_LOG_DISABLED(...) \\ if (false) \\ std::cerr #define BATT_LOG BATT_LOG_DISABLED #define BATT_VLOG BATT_LOG_DISABLED #define BATT_DLOG BATT_LOG_DISABLED #define BATT_DVLOG BATT_LOG_DISABLED #endif // BATT_GLOG_AVAILABLE #endif // BATTERIES_LOGGING_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/logging.hpp"},{"location":"_autogen/Files/logging_8hpp/#defines","text":"Name BATTERIES_LOGGING_HPP BATT_LOG_DISABLED (...) BATT_LOG BATT_VLOG BATT_DLOG BATT_DVLOG","title":"Defines"},{"location":"_autogen/Files/logging_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/logging_8hpp/#batteries_logging_hpp","text":"1 #define BATTERIES_LOGGING_HPP()","title":"BATTERIES_LOGGING_HPP"},{"location":"_autogen/Files/logging_8hpp/#batt_log_disabled","text":"1 #define BATT_LOG_DISABLED(...)","title":"BATT_LOG_DISABLED"},{"location":"_autogen/Files/logging_8hpp/#batt_log","text":"1 #define BATT_LOG()","title":"BATT_LOG"},{"location":"_autogen/Files/logging_8hpp/#batt_vlog","text":"1 #define BATT_VLOG()","title":"BATT_VLOG"},{"location":"_autogen/Files/logging_8hpp/#batt_dlog","text":"1 #define BATT_DLOG()","title":"BATT_DLOG"},{"location":"_autogen/Files/logging_8hpp/#batt_dvlog","text":"1 #define BATT_DVLOG()","title":"BATT_DVLOG"},{"location":"_autogen/Files/logging_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_LOGGING_HPP #define BATTERIES_LOGGING_HPP #include <batteries/config.hpp> //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // #ifdef BATT_GLOG_AVAILABLE #include <glog/logging.h> #define BATT_LOG LOG #define BATT_VLOG VLOG #define BATT_DLOG DLOG #define BATT_DVLOG DLOG #else // ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #include <iostream> #define BATT_LOG_DISABLED(...) \\ if (false) \\ std::cerr #define BATT_LOG BATT_LOG_DISABLED #define BATT_VLOG BATT_LOG_DISABLED #define BATT_DLOG BATT_LOG_DISABLED #define BATT_DVLOG BATT_LOG_DISABLED #endif // BATT_GLOG_AVAILABLE #endif // BATTERIES_LOGGING_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/loop__control_8hpp/","text":"batteries/seq/loop_control.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Defines \ud83d\udd17 Name BATTERIES_SEQ_LOOP_CONTROL_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_LOOP_CONTROL_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_LOOP_CONTROL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_LOOP_CONTROL_HPP #define BATTERIES_SEQ_LOOP_CONTROL_HPP #include <batteries/config.hpp> // #include <type_traits> #include <utility> namespace batt { namespace seq { enum LoopControl { kContinue = 0 , kBreak = 1 , }; template < typename Fn , typename ... Args , typename = std :: enable_if_t < std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >>> LoopControl run_loop_fn ( Fn && fn , Args && ... args ) { return std :: forward < Fn > ( fn )( std :: forward < Args > ( args )...); } template < typename Fn , typename ... Args , typename = std :: enable_if_t <! std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >> , typename = void > LoopControl run_loop_fn ( Fn && fn , Args && ... args ) { std :: forward < Fn > ( fn )( std :: forward < Args > ( args )...); return kContinue ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_LOOP_CONTROL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/loop_control.hpp"},{"location":"_autogen/Files/loop__control_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/loop__control_8hpp/#defines","text":"Name BATTERIES_SEQ_LOOP_CONTROL_HPP","title":"Defines"},{"location":"_autogen/Files/loop__control_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/loop__control_8hpp/#batteries_seq_loop_control_hpp","text":"1 #define BATTERIES_SEQ_LOOP_CONTROL_HPP()","title":"BATTERIES_SEQ_LOOP_CONTROL_HPP"},{"location":"_autogen/Files/loop__control_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_LOOP_CONTROL_HPP #define BATTERIES_SEQ_LOOP_CONTROL_HPP #include <batteries/config.hpp> // #include <type_traits> #include <utility> namespace batt { namespace seq { enum LoopControl { kContinue = 0 , kBreak = 1 , }; template < typename Fn , typename ... Args , typename = std :: enable_if_t < std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >>> LoopControl run_loop_fn ( Fn && fn , Args && ... args ) { return std :: forward < Fn > ( fn )( std :: forward < Args > ( args )...); } template < typename Fn , typename ... Args , typename = std :: enable_if_t <! std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >> , typename = void > LoopControl run_loop_fn ( Fn && fn , Args && ... args ) { std :: forward < Fn > ( fn )( std :: forward < Args > ( args )...); return kContinue ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_LOOP_CONTROL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/map_8hpp/","text":"batteries/seq/map.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Map struct batt::seq::MapBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_MAP_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_MAP_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_MAP_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_MAP_HPP #define BATTERIES_SEQ_MAP_HPP #include <batteries/config.hpp> #include <batteries/optional.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/hint.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map // template < typename Seq , typename MapFn > class Map { public : using Item = batt :: DecayRValueRef < std :: invoke_result_t < MapFn , SeqItem < Seq >>> ; explicit Map ( Seq && seq , MapFn && map_fn ) noexcept : seq_ ( BATT_FORWARD ( seq )), map_fn_ ( BATT_FORWARD ( map_fn )) { } Map ( Map && that ) noexcept : seq_ ( BATT_FORWARD ( that . seq_ )), map_fn_ ( BATT_FORWARD ( * that . map_fn_ )) { } Map ( const Map & that ) noexcept : seq_ ( that . seq_ ), map_fn_ ( * that . map_fn_ ) { } Map & operator = ( Map && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = BATT_FORWARD ( that . seq_ ); this -> map_fn_ . emplace ( BATT_FORWARD ( * that . map_fn_ )); } return * this ; } Map & operator = ( const Map & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = that . seq_ ; this -> map_fn_ . emplace ( * that . map_fn_ ); } return * this ; } Optional < Item > peek () { auto item = seq_ . peek (); if ( ! item ) { return None ; } return ( * map_fn_ )( std :: forward < SeqItem < Seq >> ( * item )); } Optional < Item > next () { auto item = seq_ . next (); if ( ! item ) { return None ; } return ( * map_fn_ )( std :: forward < SeqItem < Seq >> ( * item )); } //---------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename MapFn_ , typename EachFn > friend LoopControl operator | ( Map < Seq_ , MapFn_ >&& map_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : Seq seq_ ; Optional < batt :: DecayRValueRef < MapFn >> map_fn_ ; }; template < typename MapFn > struct MapBinder { MapFn map_fn ; }; template < typename MapFn > MapBinder < MapFn > map ( MapFn && map_fn ) { return { BATT_FORWARD ( map_fn )}; } template < typename Seq , typename MapFn > [[ nodiscard ]] Map < Seq , MapFn > operator | ( Seq && seq , MapBinder < MapFn >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < MapFn , std :: decay_t < MapFn >> , \"Mapped functions may not be captured implicitly by reference.\" ); return Map < Seq , MapFn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . map_fn )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename Seq , typename MapFn , typename EachFn > LoopControl operator | ( Map < Seq , MapFn >&& map_seq , ForEachBinder < EachFn >&& binder ) { auto & map_fn = * map_seq . map_fn_ ; auto loop_body = [ & ]( auto && item ) { return binder . fn ( map_fn ( std :: forward < SeqItem < Seq >> ( item ))); }; return std :: forward < Seq > ( map_seq . seq_ ) | for_each ( loop_body ); } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_MAP_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/map.hpp"},{"location":"_autogen/Files/map_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/map_8hpp/#classes","text":"Name class batt::seq::Map struct batt::seq::MapBinder","title":"Classes"},{"location":"_autogen/Files/map_8hpp/#defines","text":"Name BATTERIES_SEQ_MAP_HPP","title":"Defines"},{"location":"_autogen/Files/map_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/map_8hpp/#batteries_seq_map_hpp","text":"1 #define BATTERIES_SEQ_MAP_HPP()","title":"BATTERIES_SEQ_MAP_HPP"},{"location":"_autogen/Files/map_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_MAP_HPP #define BATTERIES_SEQ_MAP_HPP #include <batteries/config.hpp> #include <batteries/optional.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/hint.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map // template < typename Seq , typename MapFn > class Map { public : using Item = batt :: DecayRValueRef < std :: invoke_result_t < MapFn , SeqItem < Seq >>> ; explicit Map ( Seq && seq , MapFn && map_fn ) noexcept : seq_ ( BATT_FORWARD ( seq )), map_fn_ ( BATT_FORWARD ( map_fn )) { } Map ( Map && that ) noexcept : seq_ ( BATT_FORWARD ( that . seq_ )), map_fn_ ( BATT_FORWARD ( * that . map_fn_ )) { } Map ( const Map & that ) noexcept : seq_ ( that . seq_ ), map_fn_ ( * that . map_fn_ ) { } Map & operator = ( Map && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = BATT_FORWARD ( that . seq_ ); this -> map_fn_ . emplace ( BATT_FORWARD ( * that . map_fn_ )); } return * this ; } Map & operator = ( const Map & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = that . seq_ ; this -> map_fn_ . emplace ( * that . map_fn_ ); } return * this ; } Optional < Item > peek () { auto item = seq_ . peek (); if ( ! item ) { return None ; } return ( * map_fn_ )( std :: forward < SeqItem < Seq >> ( * item )); } Optional < Item > next () { auto item = seq_ . next (); if ( ! item ) { return None ; } return ( * map_fn_ )( std :: forward < SeqItem < Seq >> ( * item )); } //---------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename Seq_ , typename MapFn_ , typename EachFn > friend LoopControl operator | ( Map < Seq_ , MapFn_ >&& map_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : Seq seq_ ; Optional < batt :: DecayRValueRef < MapFn >> map_fn_ ; }; template < typename MapFn > struct MapBinder { MapFn map_fn ; }; template < typename MapFn > MapBinder < MapFn > map ( MapFn && map_fn ) { return { BATT_FORWARD ( map_fn )}; } template < typename Seq , typename MapFn > [[ nodiscard ]] Map < Seq , MapFn > operator | ( Seq && seq , MapBinder < MapFn >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < MapFn , std :: decay_t < MapFn >> , \"Mapped functions may not be captured implicitly by reference.\" ); return Map < Seq , MapFn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . map_fn )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename Seq , typename MapFn , typename EachFn > LoopControl operator | ( Map < Seq , MapFn >&& map_seq , ForEachBinder < EachFn >&& binder ) { auto & map_fn = * map_seq . map_fn_ ; auto loop_body = [ & ]( auto && item ) { return binder . fn ( map_fn ( std :: forward < SeqItem < Seq >> ( item ))); }; return std :: forward < Seq > ( map_seq . seq_ ) | for_each ( loop_body ); } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_MAP_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/math_8hpp/","text":"batteries/math.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_MATH_HPP Macro Documentation \ud83d\udd17 BATTERIES_MATH_HPP \ud83d\udd17 1 #define BATTERIES_MATH_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_MATH_HPP #define BATTERIES_MATH_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <type_traits> namespace batt { inline constexpr i32 log2_ceil ( u64 i ) { return ( i <= 1 ) ? 0 : ( 64 - ( i32 ) __builtin_clzll ( i - 1 )); } inline constexpr i32 log2_floor ( u64 i ) { return ( i == 0 ) ? 0 : ( 63 - ( i32 ) __builtin_clzll ( i )); } // lsb_mask - Least Significant Bits Mask // // Returns a value of type IntT with `bits` ones as the least significant bits, and zeros for all other bits. // template < typename IntT > inline constexpr IntT lsb_mask ( i32 bits ) { return (( IntT { 1 } << bits ) - 1 ); } // round_down_bits - round an integer value down to the nearest multiple of 2^bits. For example, // round_down_bits(8, n) will round n down to the nearest multiple of 256; if n is already a multiple of 256, // it will return n. // template < typename IntT > inline constexpr IntT round_down_bits ( i32 bits , IntT n ) { return n & ~ lsb_mask < IntT > ( bits ); } // round_up_bits - round an integer value up to the nearest multiple of 2^bits. For example, // round_up_bits(8, n) will round n up to the nearest multiple of 256; if n is already a multiple of 256, it // will return n. // template < typename IntT > inline constexpr IntT round_up_bits ( i32 bits , IntT n ) { return round_down_bits ( bits , n + lsb_mask < IntT > ( bits )); } // Compile-time integer exponentiation. // template < typename IntT > inline constexpr IntT ipow ( IntT base , IntT exponent , IntT accumulator = static_cast < IntT > ( 1 )) { static_assert ( std :: is_integral_v < IntT > , \"batt::ipow may only be used with integral types.\" ); return ( exponent > 0 ) ? ipow ( base , exponent - 1 , accumulator * base ) : accumulator ; } } // namespace batt #endif // BATTERIES_MATH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/math.hpp"},{"location":"_autogen/Files/math_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/math_8hpp/#defines","text":"Name BATTERIES_MATH_HPP","title":"Defines"},{"location":"_autogen/Files/math_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/math_8hpp/#batteries_math_hpp","text":"1 #define BATTERIES_MATH_HPP()","title":"BATTERIES_MATH_HPP"},{"location":"_autogen/Files/math_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_MATH_HPP #define BATTERIES_MATH_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <type_traits> namespace batt { inline constexpr i32 log2_ceil ( u64 i ) { return ( i <= 1 ) ? 0 : ( 64 - ( i32 ) __builtin_clzll ( i - 1 )); } inline constexpr i32 log2_floor ( u64 i ) { return ( i == 0 ) ? 0 : ( 63 - ( i32 ) __builtin_clzll ( i )); } // lsb_mask - Least Significant Bits Mask // // Returns a value of type IntT with `bits` ones as the least significant bits, and zeros for all other bits. // template < typename IntT > inline constexpr IntT lsb_mask ( i32 bits ) { return (( IntT { 1 } << bits ) - 1 ); } // round_down_bits - round an integer value down to the nearest multiple of 2^bits. For example, // round_down_bits(8, n) will round n down to the nearest multiple of 256; if n is already a multiple of 256, // it will return n. // template < typename IntT > inline constexpr IntT round_down_bits ( i32 bits , IntT n ) { return n & ~ lsb_mask < IntT > ( bits ); } // round_up_bits - round an integer value up to the nearest multiple of 2^bits. For example, // round_up_bits(8, n) will round n up to the nearest multiple of 256; if n is already a multiple of 256, it // will return n. // template < typename IntT > inline constexpr IntT round_up_bits ( i32 bits , IntT n ) { return round_down_bits ( bits , n + lsb_mask < IntT > ( bits )); } // Compile-time integer exponentiation. // template < typename IntT > inline constexpr IntT ipow ( IntT base , IntT exponent , IntT accumulator = static_cast < IntT > ( 1 )) { static_assert ( std :: is_integral_v < IntT > , \"batt::ipow may only be used with integral types.\" ); return ( exponent > 0 ) ? ipow ( base , exponent - 1 , accumulator * base ) : accumulator ; } } // namespace batt #endif // BATTERIES_MATH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/merge__by_8hpp/","text":"batteries/seq/merge_by.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::MergeBy struct batt::seq::MergeByBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_MERGE_BY_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_MERGE_BY_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_MERGE_BY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_MERGE_BY_HPP #define BATTERIES_SEQ_MERGE_BY_HPP #include <batteries/config.hpp> #include <batteries/hint.hpp> #include <batteries/seq/emplace_back.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/natural_order.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/small_vec.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // merge/merge_by // template < typename LeftSeq , typename RightSeq , typename Compare > class MergeBy { public : // If merging two sequences of the same type, just use that; otherwise // produce a variant of the two types. // using Item = std :: conditional_t < /* if */ std :: is_same_v < SeqItem < LeftSeq > , SeqItem < RightSeq >> , /* then */ SeqItem < LeftSeq > , /* else */ std :: conditional_t < /* if */ std :: is_same_v < std :: decay_t < SeqItem < LeftSeq >> , std :: decay_t < SeqItem < RightSeq >>> , /* then */ std :: decay_t < SeqItem < LeftSeq >> , // TODO [tastolfi 2020-09-28] fix it so we can have refs /* else */ std :: variant < std :: decay_t < SeqItem < LeftSeq >> , std :: decay_t < SeqItem < RightSeq >>>>> ; explicit MergeBy ( LeftSeq && left , RightSeq && right , Compare && compare ) noexcept : left_ ( BATT_FORWARD ( left )) , right_ ( BATT_FORWARD ( right )) , compare_ ( BATT_FORWARD ( compare )) { } MergeBy ( MergeBy && that ) noexcept : left_ ( BATT_FORWARD ( that . left_ )) , right_ ( BATT_FORWARD ( that . right_ )) , compare_ ( BATT_FORWARD ( * that . compare_ )) { } MergeBy & operator = ( MergeBy && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { left_ = BATT_FORWARD ( that . left_ ); right_ = BATT_FORWARD ( that . right_ ); compare_ . emplace ( BATT_FORWARD ( * that . compare_ )); } return * this ; } MergeBy ( const MergeBy & that ) : left_ ( that . left_ ), right_ ( that . right_ ), compare_ ( * that . compare_ ) { } MergeBy & operator = ( const MergeBy & that ) { if ( BATT_HINT_TRUE ( this != & that )) { left_ = that . left_ ; right_ = that . right_ ; compare_ . emplace ( * that . compare_ ); } return * this ; } Optional < Item > peek () { return impl ( /*consume=*/ false ); } Optional < Item > next () { return impl ( /*consume=*/ true ); } //-------------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename LeftSeq_ , typename RightSeq_ , typename Compare_ , typename EachFn > friend LoopControl operator | ( MergeBy < LeftSeq_ , RightSeq_ , Compare_ >&& merge_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : struct ToItem { template < typename T , typename = std :: enable_if_t <! std :: is_same_v < Item , T &&>>> Item operator ()( T && item ) const { return Item { BATT_FORWARD ( item )}; } template < typename T , typename = std :: enable_if_t < std :: is_same_v < Item , T &&>> , typename = void > Item operator ()( T && item ) const { return item ; } }; Optional < Item > impl ( bool consume ) { auto l = left_ . peek (); auto r = right_ . peek (); if ( l ) { if ( r ) { if (( * compare_ )( * r , * l )) { if ( consume ) { return right_ . next (). map ( ToItem {}); } return r . map ( ToItem {}); } else { if ( consume ) { return left_ . next (). map ( ToItem {}); } return l . map ( ToItem {}); } } else { if ( consume ) { return left_ . next (). map ( ToItem {}); } return l . map ( ToItem {}); } } else { if ( r ) { if ( consume ) { return right_ . next (). map ( ToItem {}); } return r . map ( ToItem {}); } else { return None ; } } } LeftSeq left_ ; RightSeq right_ ; Optional < Compare > compare_ ; }; template < typename RightSeq , typename Compare > struct MergeByBinder { RightSeq right ; Compare compare ; }; template < typename Compare , typename RightSeq > MergeByBinder < RightSeq , Compare > merge_by ( Compare && compare , RightSeq && right ) { return { BATT_FORWARD ( right ), BATT_FORWARD ( compare )}; } template < typename RightSeq > auto merge ( RightSeq && right ) { return merge_by ( NaturalOrder {}, BATT_FORWARD ( right )); } template < typename LeftSeq , typename RightSeq , typename Compare > [[ nodiscard ]] MergeBy < LeftSeq , RightSeq , Compare > operator | ( LeftSeq && left , MergeByBinder < RightSeq , Compare >&& binder ) { static_assert ( std :: is_same_v < LeftSeq , std :: decay_t < LeftSeq >> , \"Merged sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < RightSeq , std :: decay_t < RightSeq >> , \"Merged sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Compare , std :: decay_t < Compare >> , \"Comparison functions may not be captured implicitly by reference.\" ); return MergeBy < LeftSeq , RightSeq , Compare > { BATT_FORWARD ( left ), BATT_FORWARD ( binder . right ), BATT_FORWARD ( binder . compare )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename LeftSeq , typename RightSeq , typename Compare , typename EachFn > LoopControl operator | ( MergeBy < LeftSeq , RightSeq , Compare >&& merge_seq , ForEachBinder < EachFn >&& binder ) { using LeftItem = std :: decay_t < SeqItem < LeftSeq >> ; SmallVec < LeftItem , 4096 / sizeof ( LeftItem ) > left_items_cached ; std :: forward < LeftSeq > ( merge_seq . left_ ) | emplace_back ( & left_items_cached ); auto * left_next = left_items_cached . data (); auto * left_end = left_items_cached . data () + left_items_cached . size (); auto & compare = * merge_seq . compare_ ; auto loop_body = [ & ]( auto && right_item ) -> LoopControl { while ( left_next != left_end && ! compare ( right_item , * left_next )) { if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , * left_next ) == kBreak )) { return kBreak ; } ++ left_next ; } return run_loop_fn ( binder . fn , right_item ); }; LoopControl control = std :: forward < RightSeq > ( merge_seq . right_ ) | for_each ( loop_body ); if ( BATT_HINT_FALSE ( control == kBreak )) { return kBreak ; } while ( left_next != left_end ) { if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , * left_next ) == kBreak )) { return kBreak ; } ++ left_next ; } return kContinue ; } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_MERGE_BY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/merge_by.hpp"},{"location":"_autogen/Files/merge__by_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/merge__by_8hpp/#classes","text":"Name class batt::seq::MergeBy struct batt::seq::MergeByBinder","title":"Classes"},{"location":"_autogen/Files/merge__by_8hpp/#defines","text":"Name BATTERIES_SEQ_MERGE_BY_HPP","title":"Defines"},{"location":"_autogen/Files/merge__by_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/merge__by_8hpp/#batteries_seq_merge_by_hpp","text":"1 #define BATTERIES_SEQ_MERGE_BY_HPP()","title":"BATTERIES_SEQ_MERGE_BY_HPP"},{"location":"_autogen/Files/merge__by_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_MERGE_BY_HPP #define BATTERIES_SEQ_MERGE_BY_HPP #include <batteries/config.hpp> #include <batteries/hint.hpp> #include <batteries/seq/emplace_back.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/natural_order.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/small_vec.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // merge/merge_by // template < typename LeftSeq , typename RightSeq , typename Compare > class MergeBy { public : // If merging two sequences of the same type, just use that; otherwise // produce a variant of the two types. // using Item = std :: conditional_t < /* if */ std :: is_same_v < SeqItem < LeftSeq > , SeqItem < RightSeq >> , /* then */ SeqItem < LeftSeq > , /* else */ std :: conditional_t < /* if */ std :: is_same_v < std :: decay_t < SeqItem < LeftSeq >> , std :: decay_t < SeqItem < RightSeq >>> , /* then */ std :: decay_t < SeqItem < LeftSeq >> , // TODO [tastolfi 2020-09-28] fix it so we can have refs /* else */ std :: variant < std :: decay_t < SeqItem < LeftSeq >> , std :: decay_t < SeqItem < RightSeq >>>>> ; explicit MergeBy ( LeftSeq && left , RightSeq && right , Compare && compare ) noexcept : left_ ( BATT_FORWARD ( left )) , right_ ( BATT_FORWARD ( right )) , compare_ ( BATT_FORWARD ( compare )) { } MergeBy ( MergeBy && that ) noexcept : left_ ( BATT_FORWARD ( that . left_ )) , right_ ( BATT_FORWARD ( that . right_ )) , compare_ ( BATT_FORWARD ( * that . compare_ )) { } MergeBy & operator = ( MergeBy && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { left_ = BATT_FORWARD ( that . left_ ); right_ = BATT_FORWARD ( that . right_ ); compare_ . emplace ( BATT_FORWARD ( * that . compare_ )); } return * this ; } MergeBy ( const MergeBy & that ) : left_ ( that . left_ ), right_ ( that . right_ ), compare_ ( * that . compare_ ) { } MergeBy & operator = ( const MergeBy & that ) { if ( BATT_HINT_TRUE ( this != & that )) { left_ = that . left_ ; right_ = that . right_ ; compare_ . emplace ( * that . compare_ ); } return * this ; } Optional < Item > peek () { return impl ( /*consume=*/ false ); } Optional < Item > next () { return impl ( /*consume=*/ true ); } //-------------------------- #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename LeftSeq_ , typename RightSeq_ , typename Compare_ , typename EachFn > friend LoopControl operator | ( MergeBy < LeftSeq_ , RightSeq_ , Compare_ >&& merge_seq , ForEachBinder < EachFn >&& binder ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : struct ToItem { template < typename T , typename = std :: enable_if_t <! std :: is_same_v < Item , T &&>>> Item operator ()( T && item ) const { return Item { BATT_FORWARD ( item )}; } template < typename T , typename = std :: enable_if_t < std :: is_same_v < Item , T &&>> , typename = void > Item operator ()( T && item ) const { return item ; } }; Optional < Item > impl ( bool consume ) { auto l = left_ . peek (); auto r = right_ . peek (); if ( l ) { if ( r ) { if (( * compare_ )( * r , * l )) { if ( consume ) { return right_ . next (). map ( ToItem {}); } return r . map ( ToItem {}); } else { if ( consume ) { return left_ . next (). map ( ToItem {}); } return l . map ( ToItem {}); } } else { if ( consume ) { return left_ . next (). map ( ToItem {}); } return l . map ( ToItem {}); } } else { if ( r ) { if ( consume ) { return right_ . next (). map ( ToItem {}); } return r . map ( ToItem {}); } else { return None ; } } } LeftSeq left_ ; RightSeq right_ ; Optional < Compare > compare_ ; }; template < typename RightSeq , typename Compare > struct MergeByBinder { RightSeq right ; Compare compare ; }; template < typename Compare , typename RightSeq > MergeByBinder < RightSeq , Compare > merge_by ( Compare && compare , RightSeq && right ) { return { BATT_FORWARD ( right ), BATT_FORWARD ( compare )}; } template < typename RightSeq > auto merge ( RightSeq && right ) { return merge_by ( NaturalOrder {}, BATT_FORWARD ( right )); } template < typename LeftSeq , typename RightSeq , typename Compare > [[ nodiscard ]] MergeBy < LeftSeq , RightSeq , Compare > operator | ( LeftSeq && left , MergeByBinder < RightSeq , Compare >&& binder ) { static_assert ( std :: is_same_v < LeftSeq , std :: decay_t < LeftSeq >> , \"Merged sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < RightSeq , std :: decay_t < RightSeq >> , \"Merged sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Compare , std :: decay_t < Compare >> , \"Comparison functions may not be captured implicitly by reference.\" ); return MergeBy < LeftSeq , RightSeq , Compare > { BATT_FORWARD ( left ), BATT_FORWARD ( binder . right ), BATT_FORWARD ( binder . compare )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename LeftSeq , typename RightSeq , typename Compare , typename EachFn > LoopControl operator | ( MergeBy < LeftSeq , RightSeq , Compare >&& merge_seq , ForEachBinder < EachFn >&& binder ) { using LeftItem = std :: decay_t < SeqItem < LeftSeq >> ; SmallVec < LeftItem , 4096 / sizeof ( LeftItem ) > left_items_cached ; std :: forward < LeftSeq > ( merge_seq . left_ ) | emplace_back ( & left_items_cached ); auto * left_next = left_items_cached . data (); auto * left_end = left_items_cached . data () + left_items_cached . size (); auto & compare = * merge_seq . compare_ ; auto loop_body = [ & ]( auto && right_item ) -> LoopControl { while ( left_next != left_end && ! compare ( right_item , * left_next )) { if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , * left_next ) == kBreak )) { return kBreak ; } ++ left_next ; } return run_loop_fn ( binder . fn , right_item ); }; LoopControl control = std :: forward < RightSeq > ( merge_seq . right_ ) | for_each ( loop_body ); if ( BATT_HINT_FALSE ( control == kBreak )) { return kBreak ; } while ( left_next != left_end ) { if ( BATT_HINT_FALSE ( run_loop_fn ( binder . fn , * left_next ) == kBreak )) { return kBreak ; } ++ left_next ; } return kContinue ; } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_MERGE_BY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__collectors_8hpp/","text":"batteries/metrics/metric_collectors.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::CountMetric class batt::LatencyMetric class batt::LatencyTimer class batt::RateMetric Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_COLLECTORS_HPP BATT_COLLECT_LATENCY (metric, expr) BATT_COLLECT_LATENCY_N (metric, expr, count_delta) Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_COLLECTORS_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_COLLECTORS_HPP() BATT_COLLECT_LATENCY \ud83d\udd17 1 #define BATT_COLLECT_LATENCY(metric, expr) BATT_COLLECT_LATENCY_N \ud83d\udd17 1 #define BATT_COLLECT_LATENCY_N(metric, expr, count_delta) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_COLLECTORS_HPP #define BATTERIES_METRICS_METRIC_COLLECTORS_HPP #include <batteries/config.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <atomic> #include <chrono> #include <functional> #include <ostream> namespace batt { template < typename T > class CountMetric { public : CountMetric () = default ; /*implicit*/ CountMetric ( T init_val ) noexcept : value_ { init_val } { } void set ( T value ) { this -> value_ . store ( value , std :: memory_order_relaxed ); } template < typename D > void add ( D delta ) { this -> value_ . fetch_add ( delta , std :: memory_order_relaxed ); } template < typename D > decltype ( auto ) fetch_add ( D delta ) { return this -> value_ . fetch_add ( delta , std :: memory_order_relaxed ); } operator T () const { return this -> value_ ; } decltype ( auto ) operator ++ ( int ) { return this -> value_ ++ ; } decltype ( auto ) operator ++ () { return ++ this -> value_ ; } template < typename D > decltype ( auto ) operator += ( D delta ) { return this -> value_ += delta ; } T load () const { return value_ . load ( std :: memory_order_relaxed ); } void reset () { this -> value_ . store ( 0 , std :: memory_order_relaxed ); } private : std :: atomic < T > value_ { 0 }; }; class LatencyMetric { public : void update ( std :: chrono :: steady_clock :: time_point start , u64 count_delta = 1 ) { return this -> update ( std :: chrono :: steady_clock :: now () - start , count_delta ); } void update ( std :: chrono :: steady_clock :: duration elapsed_duration , u64 count_delta = 1 ) { const i64 elapsed_usec = std :: max < i64 > ( 0 , std :: chrono :: duration_cast < std :: chrono :: microseconds > ( elapsed_duration ). count ()); this -> total_usec . add ( elapsed_usec ); this -> count . add ( count_delta ); } // Count per second. // double rate_per_second () const { return double ( count ) / double ( total_usec ) * 1000.0 * 1000.0 ; } void reset () { this -> total_usec . reset (); this -> count . reset (); } CountMetric < u64 > total_usec { 0 }; CountMetric < u64 > count { 0 }; }; inline std :: ostream & operator << ( std :: ostream & out , const LatencyMetric & t ) { // return out << t.total_usec << \"/\" << t.count << \"(avg=\" << ((double)t.total_usec / // (double)(t.count + 1)) // << \"usec)\"; return out << (( double ) t . total_usec / ( double )( t . count + 1 )) << \"us(n=\" << t . count << \")\" ; } class LatencyTimer { public : LatencyTimer ( const LatencyTimer & ) = delete ; LatencyTimer & operator = ( const LatencyTimer & ) = delete ; explicit LatencyTimer ( LatencyMetric & counter , u64 delta = 1 ) noexcept : metric_ { & counter }, delta_ { delta } { } ~ LatencyTimer () noexcept { this -> stop (); } i64 read_usec () const { return std :: max < i64 > ( 0 , std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - this -> start_ ) . count ()); } void stop () noexcept { if ( this -> metric_ ) { this -> metric_ -> update ( this -> start_ , this -> delta_ ); this -> metric_ = nullptr ; } } private : LatencyMetric * metric_ ; const u64 delta_ ; const std :: chrono :: steady_clock :: time_point start_ = std :: chrono :: steady_clock :: now (); }; #define BATT_COLLECT_LATENCY(metric, expr) \\ [&] { \\ ::batt::LatencyTimer ANONYMOUS_latency_timer_{(metric)}; \\ return expr; \\ }() #define BATT_COLLECT_LATENCY_N(metric, expr, count_delta) \\ [&] { \\ ::batt::LatencyTimer ANONYMOUS_latency_timer_{(metric), (count_delta)}; \\ return expr; \\ }() //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T > using DerivedMetric = std :: function < T () > ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T , i64 kIntervalSeconds > class RateMetric { public : static const auto & base_time () { static const auto base_time_ = std :: chrono :: steady_clock :: now (); return base_time_ ; } void update ( T value ) { this -> current_value_ . store ( value ); const i64 now_usec = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - base_time ()) . count (); const i64 elapsed_usec = now_usec - this -> start_time_ ; if ( elapsed_usec >= kIntervalSeconds * 1000 * 1000 * 2 ) { this -> start_time_ . fetch_add ( elapsed_usec / 2 ); this -> start_value_ . store (( value + this -> start_value_ . load ()) / 2 ); } } double get () const { const auto now_usec = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - base_time ()) . count (); const auto elapsed_usec = now_usec - this -> start_time_ ; return static_cast < double > ( this -> current_value_ - this -> start_value_ ) * 1000000.0 / static_cast < double > ( elapsed_usec ); } private : std :: atomic < i64 > start_time_ { std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - base_time ()) . count ()}; std :: atomic < T > start_value_ { 0 }; std :: atomic < T > current_value_ ; }; } // namespace batt #endif // BATTERIES_METRICS_METRIC_COLLECTORS_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_collectors_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_collectors.hpp"},{"location":"_autogen/Files/metric__collectors_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__collectors_8hpp/#classes","text":"Name class batt::CountMetric class batt::LatencyMetric class batt::LatencyTimer class batt::RateMetric","title":"Classes"},{"location":"_autogen/Files/metric__collectors_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_COLLECTORS_HPP BATT_COLLECT_LATENCY (metric, expr) BATT_COLLECT_LATENCY_N (metric, expr, count_delta)","title":"Defines"},{"location":"_autogen/Files/metric__collectors_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__collectors_8hpp/#batteries_metrics_metric_collectors_hpp","text":"1 #define BATTERIES_METRICS_METRIC_COLLECTORS_HPP()","title":"BATTERIES_METRICS_METRIC_COLLECTORS_HPP"},{"location":"_autogen/Files/metric__collectors_8hpp/#batt_collect_latency","text":"1 #define BATT_COLLECT_LATENCY(metric, expr)","title":"BATT_COLLECT_LATENCY"},{"location":"_autogen/Files/metric__collectors_8hpp/#batt_collect_latency_n","text":"1 #define BATT_COLLECT_LATENCY_N(metric, expr, count_delta)","title":"BATT_COLLECT_LATENCY_N"},{"location":"_autogen/Files/metric__collectors_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_COLLECTORS_HPP #define BATTERIES_METRICS_METRIC_COLLECTORS_HPP #include <batteries/config.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <atomic> #include <chrono> #include <functional> #include <ostream> namespace batt { template < typename T > class CountMetric { public : CountMetric () = default ; /*implicit*/ CountMetric ( T init_val ) noexcept : value_ { init_val } { } void set ( T value ) { this -> value_ . store ( value , std :: memory_order_relaxed ); } template < typename D > void add ( D delta ) { this -> value_ . fetch_add ( delta , std :: memory_order_relaxed ); } template < typename D > decltype ( auto ) fetch_add ( D delta ) { return this -> value_ . fetch_add ( delta , std :: memory_order_relaxed ); } operator T () const { return this -> value_ ; } decltype ( auto ) operator ++ ( int ) { return this -> value_ ++ ; } decltype ( auto ) operator ++ () { return ++ this -> value_ ; } template < typename D > decltype ( auto ) operator += ( D delta ) { return this -> value_ += delta ; } T load () const { return value_ . load ( std :: memory_order_relaxed ); } void reset () { this -> value_ . store ( 0 , std :: memory_order_relaxed ); } private : std :: atomic < T > value_ { 0 }; }; class LatencyMetric { public : void update ( std :: chrono :: steady_clock :: time_point start , u64 count_delta = 1 ) { return this -> update ( std :: chrono :: steady_clock :: now () - start , count_delta ); } void update ( std :: chrono :: steady_clock :: duration elapsed_duration , u64 count_delta = 1 ) { const i64 elapsed_usec = std :: max < i64 > ( 0 , std :: chrono :: duration_cast < std :: chrono :: microseconds > ( elapsed_duration ). count ()); this -> total_usec . add ( elapsed_usec ); this -> count . add ( count_delta ); } // Count per second. // double rate_per_second () const { return double ( count ) / double ( total_usec ) * 1000.0 * 1000.0 ; } void reset () { this -> total_usec . reset (); this -> count . reset (); } CountMetric < u64 > total_usec { 0 }; CountMetric < u64 > count { 0 }; }; inline std :: ostream & operator << ( std :: ostream & out , const LatencyMetric & t ) { // return out << t.total_usec << \"/\" << t.count << \"(avg=\" << ((double)t.total_usec / // (double)(t.count + 1)) // << \"usec)\"; return out << (( double ) t . total_usec / ( double )( t . count + 1 )) << \"us(n=\" << t . count << \")\" ; } class LatencyTimer { public : LatencyTimer ( const LatencyTimer & ) = delete ; LatencyTimer & operator = ( const LatencyTimer & ) = delete ; explicit LatencyTimer ( LatencyMetric & counter , u64 delta = 1 ) noexcept : metric_ { & counter }, delta_ { delta } { } ~ LatencyTimer () noexcept { this -> stop (); } i64 read_usec () const { return std :: max < i64 > ( 0 , std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - this -> start_ ) . count ()); } void stop () noexcept { if ( this -> metric_ ) { this -> metric_ -> update ( this -> start_ , this -> delta_ ); this -> metric_ = nullptr ; } } private : LatencyMetric * metric_ ; const u64 delta_ ; const std :: chrono :: steady_clock :: time_point start_ = std :: chrono :: steady_clock :: now (); }; #define BATT_COLLECT_LATENCY(metric, expr) \\ [&] { \\ ::batt::LatencyTimer ANONYMOUS_latency_timer_{(metric)}; \\ return expr; \\ }() #define BATT_COLLECT_LATENCY_N(metric, expr, count_delta) \\ [&] { \\ ::batt::LatencyTimer ANONYMOUS_latency_timer_{(metric), (count_delta)}; \\ return expr; \\ }() //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T > using DerivedMetric = std :: function < T () > ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T , i64 kIntervalSeconds > class RateMetric { public : static const auto & base_time () { static const auto base_time_ = std :: chrono :: steady_clock :: now (); return base_time_ ; } void update ( T value ) { this -> current_value_ . store ( value ); const i64 now_usec = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - base_time ()) . count (); const i64 elapsed_usec = now_usec - this -> start_time_ ; if ( elapsed_usec >= kIntervalSeconds * 1000 * 1000 * 2 ) { this -> start_time_ . fetch_add ( elapsed_usec / 2 ); this -> start_value_ . store (( value + this -> start_value_ . load ()) / 2 ); } } double get () const { const auto now_usec = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - base_time ()) . count (); const auto elapsed_usec = now_usec - this -> start_time_ ; return static_cast < double > ( this -> current_value_ - this -> start_value_ ) * 1000000.0 / static_cast < double > ( elapsed_usec ); } private : std :: atomic < i64 > start_time_ { std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - base_time ()) . count ()}; std :: atomic < T > start_value_ { 0 }; std :: atomic < T > current_value_ ; }; } // namespace batt #endif // BATTERIES_METRICS_METRIC_COLLECTORS_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_collectors_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__collectors__impl_8hpp/","text":"batteries/metrics/metric_collectors_impl.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_collectors_impl.hpp"},{"location":"_autogen/Files/metric__collectors__impl_8hpp/#source-code","text":"1 2 3 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/","text":"batteries/metrics/metric_csv_formatter.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::MetricCsvFormatter Defines \ud83d\udd17 Name BATTERIES_METRIC_CSV_FORMATTER_HPP Macro Documentation \ud83d\udd17 BATTERIES_METRIC_CSV_FORMATTER_HPP \ud83d\udd17 1 #define BATTERIES_METRIC_CSV_FORMATTER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRIC_CSV_FORMATTER_HPP #define BATTERIES_METRIC_CSV_FORMATTER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_formatter.hpp> #include <batteries/metrics/metric_registry.hpp> #include <batteries/int_types.hpp> #include <chrono> #include <string> #include <unordered_map> #include <vector> namespace batt { class MetricCsvFormatter : public MetricFormatter { public : void initialize ( MetricRegistry & src , std :: ostream & dst ) override ; void format_values ( MetricRegistry & src , std :: ostream & dst ) override ; void finished ( MetricRegistry & src , std :: ostream & dst ) override ; private : // Additional columns added by this formatter: the metric id and starting time. // usize id_ = 0 ; std :: chrono :: steady_clock :: time_point start_time_ ; // Saved column names and positions. // std :: unordered_map < std :: string , usize > index_of_ ; // So we don't have to keep reallocating. // std :: vector < double > values_ ; }; } // namespace batt #endif // BATTERIES_METRIC_CSV_FORMATTER_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_csv_formatter_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_csv_formatter.hpp"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#classes","text":"Name class batt::MetricCsvFormatter","title":"Classes"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#defines","text":"Name BATTERIES_METRIC_CSV_FORMATTER_HPP","title":"Defines"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#batteries_metric_csv_formatter_hpp","text":"1 #define BATTERIES_METRIC_CSV_FORMATTER_HPP()","title":"BATTERIES_METRIC_CSV_FORMATTER_HPP"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRIC_CSV_FORMATTER_HPP #define BATTERIES_METRIC_CSV_FORMATTER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_formatter.hpp> #include <batteries/metrics/metric_registry.hpp> #include <batteries/int_types.hpp> #include <chrono> #include <string> #include <unordered_map> #include <vector> namespace batt { class MetricCsvFormatter : public MetricFormatter { public : void initialize ( MetricRegistry & src , std :: ostream & dst ) override ; void format_values ( MetricRegistry & src , std :: ostream & dst ) override ; void finished ( MetricRegistry & src , std :: ostream & dst ) override ; private : // Additional columns added by this formatter: the metric id and starting time. // usize id_ = 0 ; std :: chrono :: steady_clock :: time_point start_time_ ; // Saved column names and positions. // std :: unordered_map < std :: string , usize > index_of_ ; // So we don't have to keep reallocating. // std :: vector < double > values_ ; }; } // namespace batt #endif // BATTERIES_METRIC_CSV_FORMATTER_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_csv_formatter_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/","text":"batteries/metrics/metric_csv_formatter_impl.hpp \ud83d\udd17 Functions \ud83d\udd17 Name _Pragma (\"GCC diagnostic push\" ) Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP Functions Documentation \ud83d\udd17 function _Pragma \ud83d\udd17 1 2 3 _Pragma ( \"GCC diagnostic push\" ) Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP #define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_csv_formatter.hpp> #include <batteries/suppress.hpp> BATT_SUPPRESS ( \"-Wswitch-enum\" ) #include <boost/date_time/posix_time/posix_time.hpp> BATT_UNSUPPRESS () #include <algorithm> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricCsvFormatter :: initialize ( MetricRegistry & src , std :: ostream & dst ) { // Build the schema for dumping metric rows. // std :: vector < std :: string > all_names ; src . read_all ([ & ]( std :: string_view name , double , const MetricLabelSet & ) { all_names . emplace_back ( name ); }); std :: sort ( all_names . begin (), all_names . end ()); dst << \"id,time_usec,date_time\" ; for ( usize i = 0 ; i < all_names . size (); ++ i ) { this -> index_of_ [ all_names [ i ]] = i ; dst << \",\" << all_names [ i ]; } dst << \" \\n \" ; this -> values_ . resize ( all_names . size ()); this -> id_ = 0 ; this -> start_time_ = std :: chrono :: steady_clock :: now (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricCsvFormatter :: format_values ( MetricRegistry & src , std :: ostream & dst ) { this -> id_ += 1 ; const double time_usec = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - this -> start_time_ ) . count (); // Read the registry, reordering the columns according to the schema we built above. // src . read_all ([ & ]( std :: string_view name , double value , const MetricLabelSet & ) { auto iter = this -> index_of_ . find ( std :: string ( name )); if ( iter == this -> index_of_ . end ()) { return ; } this -> values_ [ iter -> second ] = value ; }); // First dump id and time_usec. // boost :: posix_time :: ptime t = boost :: posix_time :: microsec_clock :: universal_time (); dst << this -> id_ << \",\" << time_usec << \",\" << boost :: posix_time :: to_iso_extended_string ( t ); // Dump metric value columns in order. // for ( double v : this -> values_ ) { dst << \",\" << std :: setprecision ( 10 ) << v ; } dst << \" \\n \" ; // NOTE: don't flush (let the caller decide when to) } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricCsvFormatter :: finished ( MetricRegistry & /*src*/ , std :: ostream & /*dst*/ ) { // Nothing to do for CSV format. } } // namespace batt #endif // BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_csv_formatter_impl.hpp"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#functions","text":"Name _Pragma (\"GCC diagnostic push\" )","title":"Functions"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP","title":"Defines"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#function-_pragma","text":"1 2 3 _Pragma ( \"GCC diagnostic push\" )","title":"function _Pragma"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#batteries_metrics_metric_csv_formatter_hpp","text":"1 #define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP()","title":"BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP #define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_csv_formatter.hpp> #include <batteries/suppress.hpp> BATT_SUPPRESS ( \"-Wswitch-enum\" ) #include <boost/date_time/posix_time/posix_time.hpp> BATT_UNSUPPRESS () #include <algorithm> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricCsvFormatter :: initialize ( MetricRegistry & src , std :: ostream & dst ) { // Build the schema for dumping metric rows. // std :: vector < std :: string > all_names ; src . read_all ([ & ]( std :: string_view name , double , const MetricLabelSet & ) { all_names . emplace_back ( name ); }); std :: sort ( all_names . begin (), all_names . end ()); dst << \"id,time_usec,date_time\" ; for ( usize i = 0 ; i < all_names . size (); ++ i ) { this -> index_of_ [ all_names [ i ]] = i ; dst << \",\" << all_names [ i ]; } dst << \" \\n \" ; this -> values_ . resize ( all_names . size ()); this -> id_ = 0 ; this -> start_time_ = std :: chrono :: steady_clock :: now (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricCsvFormatter :: format_values ( MetricRegistry & src , std :: ostream & dst ) { this -> id_ += 1 ; const double time_usec = std :: chrono :: duration_cast < std :: chrono :: microseconds > ( std :: chrono :: steady_clock :: now () - this -> start_time_ ) . count (); // Read the registry, reordering the columns according to the schema we built above. // src . read_all ([ & ]( std :: string_view name , double value , const MetricLabelSet & ) { auto iter = this -> index_of_ . find ( std :: string ( name )); if ( iter == this -> index_of_ . end ()) { return ; } this -> values_ [ iter -> second ] = value ; }); // First dump id and time_usec. // boost :: posix_time :: ptime t = boost :: posix_time :: microsec_clock :: universal_time (); dst << this -> id_ << \",\" << time_usec << \",\" << boost :: posix_time :: to_iso_extended_string ( t ); // Dump metric value columns in order. // for ( double v : this -> values_ ) { dst << \",\" << std :: setprecision ( 10 ) << v ; } dst << \" \\n \" ; // NOTE: don't flush (let the caller decide when to) } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricCsvFormatter :: finished ( MetricRegistry & /*src*/ , std :: ostream & /*dst*/ ) { // Nothing to do for CSV format. } } // namespace batt #endif // BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__dumper_8hpp/","text":"batteries/metrics/metric_dumper.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::MetricDumper Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_DUMPER_HPP Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_DUMPER_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_DUMPER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_DUMPER_HPP #define BATTERIES_METRICS_METRIC_DUMPER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_formatter.hpp> #include <batteries/metrics/metric_registry.hpp> #include <batteries/optional.hpp> #include <chrono> #include <future> #include <memory> #include <ostream> #include <thread> namespace batt { class MetricDumper { public : explicit MetricDumper ( MetricRegistry & registry , double rows_per_sec , std :: ostream & out , std :: unique_ptr < MetricFormatter > formatter ) noexcept ; ~ MetricDumper () noexcept ; void halt (); void join (); void stop () { this -> halt (); this -> join (); } private : MetricRegistry & registry_ ; const double rows_per_sec_ ; std :: ostream & out_ ; std :: unique_ptr < MetricFormatter > formatter_ ; std :: promise < bool > done_ ; Optional < std :: thread > thread_ ; }; } // namespace batt #endif // BATTERIES_METRICS_METRIC_DUMPER_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_dumper_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_dumper.hpp"},{"location":"_autogen/Files/metric__dumper_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__dumper_8hpp/#classes","text":"Name class batt::MetricDumper","title":"Classes"},{"location":"_autogen/Files/metric__dumper_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_DUMPER_HPP","title":"Defines"},{"location":"_autogen/Files/metric__dumper_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__dumper_8hpp/#batteries_metrics_metric_dumper_hpp","text":"1 #define BATTERIES_METRICS_METRIC_DUMPER_HPP()","title":"BATTERIES_METRICS_METRIC_DUMPER_HPP"},{"location":"_autogen/Files/metric__dumper_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_DUMPER_HPP #define BATTERIES_METRICS_METRIC_DUMPER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_formatter.hpp> #include <batteries/metrics/metric_registry.hpp> #include <batteries/optional.hpp> #include <chrono> #include <future> #include <memory> #include <ostream> #include <thread> namespace batt { class MetricDumper { public : explicit MetricDumper ( MetricRegistry & registry , double rows_per_sec , std :: ostream & out , std :: unique_ptr < MetricFormatter > formatter ) noexcept ; ~ MetricDumper () noexcept ; void halt (); void join (); void stop () { this -> halt (); this -> join (); } private : MetricRegistry & registry_ ; const double rows_per_sec_ ; std :: ostream & out_ ; std :: unique_ptr < MetricFormatter > formatter_ ; std :: promise < bool > done_ ; Optional < std :: thread > thread_ ; }; } // namespace batt #endif // BATTERIES_METRICS_METRIC_DUMPER_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_dumper_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/","text":"batteries/metrics/metric_dumper_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP #define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_dumper.hpp> #include <algorithm> #include <chrono> #include <future> #include <map> #include <memory> #include <unordered_map> #include <utility> #include <vector> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricDumper::MetricDumper ( MetricRegistry & registry , double rows_per_sec , std :: ostream & out , std :: unique_ptr < MetricFormatter > formatter ) noexcept : registry_ { registry } , rows_per_sec_ { rows_per_sec } , out_ { out } , formatter_ { std :: move ( formatter )} , done_ {} , thread_ {[ this ] { std :: future < bool > done = this -> done_ . get_future (); this -> formatter_ -> initialize ( this -> registry_ , this -> out_ ); for (;;) { const bool stop_requested = done . wait_for ( std :: chrono :: microseconds ( i64 ( 1000000.0 / this -> rows_per_sec_ ))) != std :: future_status :: timeout ; this -> formatter_ -> format_values ( this -> registry_ , this -> out_ ); if ( stop_requested ) { break ; } } this -> formatter_ -> finished ( this -> registry_ , this -> out_ ); }} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricDumper ::~ MetricDumper () noexcept { this -> stop (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricDumper :: halt () { this -> done_ . set_value ( true ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricDumper :: join () { if ( this -> thread_ ) { this -> thread_ -> join (); this -> thread_ = None ; } } } // namespace batt #endif // BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_dumper_impl.hpp"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#batteries_metrics_metric_dumper_impl_hpp","text":"1 #define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP()","title":"BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP #define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_dumper.hpp> #include <algorithm> #include <chrono> #include <future> #include <map> #include <memory> #include <unordered_map> #include <utility> #include <vector> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricDumper::MetricDumper ( MetricRegistry & registry , double rows_per_sec , std :: ostream & out , std :: unique_ptr < MetricFormatter > formatter ) noexcept : registry_ { registry } , rows_per_sec_ { rows_per_sec } , out_ { out } , formatter_ { std :: move ( formatter )} , done_ {} , thread_ {[ this ] { std :: future < bool > done = this -> done_ . get_future (); this -> formatter_ -> initialize ( this -> registry_ , this -> out_ ); for (;;) { const bool stop_requested = done . wait_for ( std :: chrono :: microseconds ( i64 ( 1000000.0 / this -> rows_per_sec_ ))) != std :: future_status :: timeout ; this -> formatter_ -> format_values ( this -> registry_ , this -> out_ ); if ( stop_requested ) { break ; } } this -> formatter_ -> finished ( this -> registry_ , this -> out_ ); }} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricDumper ::~ MetricDumper () noexcept { this -> stop (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricDumper :: halt () { this -> done_ . set_value ( true ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void MetricDumper :: join () { if ( this -> thread_ ) { this -> thread_ -> join (); this -> thread_ = None ; } } } // namespace batt #endif // BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__formatter_8hpp/","text":"batteries/metrics/metric_formatter.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::MetricFormatter Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_FORMATTER_HPP Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_FORMATTER_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_FORMATTER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_FORMATTER_HPP #define BATTERIES_METRICS_METRIC_FORMATTER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_registry.hpp> #include <ostream> namespace batt { class MetricFormatter { public : MetricFormatter ( const MetricFormatter & ) = delete ; MetricFormatter & operator = ( const MetricFormatter & ) = delete ; virtual ~ MetricFormatter () = default ; // Called once per ostream before any calls to `format_values` for that ostream. // virtual void initialize ( MetricRegistry & src , std :: ostream & dst ) = 0 ; // Called any number of times to format the current metric values in `src` to `dst`. // virtual void format_values ( MetricRegistry & src , std :: ostream & dst ) = 0 ; // Called once per ostream after all calls to `format_values` for that ostream. // virtual void finished ( MetricRegistry & src , std :: ostream & dst ) = 0 ; protected : MetricFormatter () = default ; }; } // namespace batt #endif // BATTERIES_METRICS_METRIC_FORMATTER_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_formatter_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_formatter.hpp"},{"location":"_autogen/Files/metric__formatter_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__formatter_8hpp/#classes","text":"Name class batt::MetricFormatter","title":"Classes"},{"location":"_autogen/Files/metric__formatter_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_FORMATTER_HPP","title":"Defines"},{"location":"_autogen/Files/metric__formatter_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__formatter_8hpp/#batteries_metrics_metric_formatter_hpp","text":"1 #define BATTERIES_METRICS_METRIC_FORMATTER_HPP()","title":"BATTERIES_METRICS_METRIC_FORMATTER_HPP"},{"location":"_autogen/Files/metric__formatter_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_FORMATTER_HPP #define BATTERIES_METRICS_METRIC_FORMATTER_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_registry.hpp> #include <ostream> namespace batt { class MetricFormatter { public : MetricFormatter ( const MetricFormatter & ) = delete ; MetricFormatter & operator = ( const MetricFormatter & ) = delete ; virtual ~ MetricFormatter () = default ; // Called once per ostream before any calls to `format_values` for that ostream. // virtual void initialize ( MetricRegistry & src , std :: ostream & dst ) = 0 ; // Called any number of times to format the current metric values in `src` to `dst`. // virtual void format_values ( MetricRegistry & src , std :: ostream & dst ) = 0 ; // Called once per ostream after all calls to `format_values` for that ostream. // virtual void finished ( MetricRegistry & src , std :: ostream & dst ) = 0 ; protected : MetricFormatter () = default ; }; } // namespace batt #endif // BATTERIES_METRICS_METRIC_FORMATTER_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_formatter_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__formatter__impl_8hpp/","text":"batteries/metrics/metric_formatter_impl.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_formatter_impl.hpp"},{"location":"_autogen/Files/metric__formatter__impl_8hpp/#source-code","text":"1 2 3 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__registry_8hpp/","text":"batteries/metrics/metric_registry.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::MetricLabel class batt::MetricExporter class batt::CountMetricExporter class batt::DerivedMetricExporter class batt::VariableExporter class batt::WatchExporter class batt::QueueDepthExporter class batt::MetricRegistry Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_REGISTRY_HPP Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_REGISTRY_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_REGISTRY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_REGISTRY_HPP #define BATTERIES_METRICS_METRIC_REGISTRY_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_collectors.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/watch.hpp> #include <batteries/config.hpp> #include <batteries/finally.hpp> #include <batteries/logging.hpp> #include <batteries/stream_util.hpp> #include <batteries/token.hpp> #include <memory> #include <mutex> #include <string_view> #include <unordered_map> #include <vector> namespace batt { // A key/value pair applied to a multi-dimensional metric. // struct MetricLabel { Token key ; Token value ; }; // A collection of MetricLabel values applied to a metric. // using MetricLabelSet = std :: vector < MetricLabel > ; // Sorts the given metric set and eliminates duplicates. // MetricLabelSet normalize_labels ( MetricLabelSet && labels ); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // This interface must be implemented to export a metric. // class MetricExporter { public : MetricExporter ( const MetricExporter & ) = delete ; MetricExporter & operator = ( const MetricExporter & ) = delete ; virtual ~ MetricExporter () = default ; virtual Token get_name () const = 0 ; virtual std :: string_view get_description () const { return \"A metric.\" ; } virtual std :: string_view get_type () const { return \"counter\" ; } virtual const MetricLabelSet & get_labels () const { return this -> labels_ ; } virtual void set_labels ( MetricLabelSet && labels ) { this -> labels_ = normalize_labels ( std :: move ( labels )); } virtual double get_value () const = 0 ; protected : MetricExporter () = default ; private : MetricLabelSet labels_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a CountMetric<T>. // template < typename T > class CountMetricExporter : public MetricExporter { public : explicit CountMetricExporter ( const std :: string & name , CountMetric < T >& counter ) noexcept : name_ { name } , counter_ { counter } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> counter_ . load ()); } private : Token name_ ; CountMetric < T >& counter_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a DerivedMetric<T>. // template < typename T > class DerivedMetricExporter : public MetricExporter { public : explicit DerivedMetricExporter ( const std :: string & name , DerivedMetric < T >& metric ) noexcept : name_ { name } , metric_ { metric } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> metric_ ()); } private : Token name_ ; DerivedMetric < T >& metric_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a variable as a metric. // template < typename T > class VariableExporter : public MetricExporter { public : explicit VariableExporter ( const std :: string & name , const T & var ) noexcept : name_ { name }, var_ { var } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> var_ ); } private : Token name_ ; const T & var_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a Watch<T> as a metric. // template < typename T > class WatchExporter : public MetricExporter { public : explicit WatchExporter ( const std :: string & name , Watch < T >& watch ) noexcept : name_ { name }, watch_ { watch } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> watch_ . get_value ()); } private : Token name_ ; Watch < T >& watch_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports Queue depth as a metric. // class QueueDepthExporter : public MetricExporter { public : explicit QueueDepthExporter ( const std :: string & name , QueueBase & queue ) noexcept : name_ { name } , queue_ { queue } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> queue_ . size ()); } private : Token name_ ; QueueBase & queue_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // A set of metric exporters. // class MetricRegistry { public : MetricRegistry & add_exporter ( const void * obj , std :: unique_ptr < MetricExporter > exporter , MetricLabelSet && labels ) { exporter -> set_labels ( std :: move ( labels )); std :: unique_lock < std :: mutex > lock { this -> mutex_ }; this -> metrics_ . emplace ( obj , std :: move ( exporter )); return * this ; } template < typename T > MetricRegistry & add ( std :: string_view name , CountMetric < T >& counter , MetricLabelSet && labels = MetricLabelSet {}) { BATT_VLOG ( 1 ) << \"adding CountMetric:\" << name ; return this -> add_exporter ( & counter , std :: make_unique < CountMetricExporter < T >> ( std :: string ( name ), counter ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , LatencyMetric & latency , MetricLabelSet && labels = MetricLabelSet {}) { BATT_VLOG ( 1 ) << \"adding LatencyMetric:\" << name ; this -> add_exporter ( & latency , std :: make_unique < CountMetricExporter < u64 >> ( to_string ( name , \"_total_usec\" ), latency . total_usec ), std :: move ( labels )); this -> add_exporter ( & latency , std :: make_unique < CountMetricExporter < u64 >> ( to_string ( name , \"_count\" ), latency . count ), std :: move ( labels )); return * this ; } template < typename T > MetricRegistry & add ( std :: string_view name , Watch < T >& watch , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & watch , std :: make_unique < WatchExporter < T >> ( std :: string ( name ), watch ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , QueueBase & queue , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & queue , std :: make_unique < QueueDepthExporter > ( to_string ( name , \"_queue_depth\" ), queue ), std :: move ( labels )); } template < typename T > MetricRegistry & add ( std :: string_view name , DerivedMetric < T >& metric , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & metric , std :: make_unique < DerivedMetricExporter < T >> ( name , metric ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , const double & var , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & var , std :: make_unique < VariableExporter < double >> ( std :: string ( name ), var ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , const usize & var , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & var , std :: make_unique < VariableExporter < usize >> ( std :: string ( name ), var ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , const isize & var , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & var , std :: make_unique < VariableExporter < isize >> ( std :: string ( name ), var ), std :: move ( labels )); } // Invokes the passed function for all registered metrics. // void read_all ( std :: function < void ( std :: string_view name , double value , const MetricLabelSet & labels ) >&& fn ) const { struct MetricSnapshot { std :: string_view name ; double value ; MetricLabelSet labels ; }; std :: vector < MetricSnapshot > local_snapshot ; { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; for ( const auto & p : this -> metrics_ ) { local_snapshot . emplace_back ( MetricSnapshot { static_cast < const std :: string &> ( p . second -> get_name ()), p . second -> get_value (), p . second -> get_labels (), }); } } for ( const auto & m : local_snapshot ) { fn ( m . name , m . value , m . labels ); } } // Removes the passed metric from this registry. // template < typename T > MetricRegistry & remove ( T & obj ) { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; this -> metrics_ . erase ( & obj ); return * this ; } // Adds the passed metric exporter (`obj`) to the registry under the given `name`; the metric will // automatically be removed from the registry when the last (moved) copy of the returned guard object goes // out of scope. // template < typename T > auto scoped_add ( std :: string_view name , T & obj ) { this -> add ( name , obj ); return finally ([ & obj , this ] { this -> remove ( obj ); }); } private : mutable std :: mutex mutex_ ; std :: unordered_multimap < const void * , std :: unique_ptr < MetricExporter >> metrics_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // A process-wide instance of MetricRegistry used by various components by default. // MetricRegistry & global_metric_registry (); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #if 0 const auto metric_name = [this](std::string_view property) { return ::batt::to_string(\"Scope_\", this->name_, \"_\", property); }; #define ADD_METRIC_(n) ::batt::global_metric_registry().add(metric_name(#n), this->metrics_.n) ADD_METRIC_(field_name); #undef ADD_METRIC_ ::batt::global_metric_registry() .add(metric_name(\"other_name\"), this->other_thing_); #endif } // namespace batt #endif // BATTERIES_METRICS_METRIC_REGISTRY_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_registry_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_registry.hpp"},{"location":"_autogen/Files/metric__registry_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__registry_8hpp/#classes","text":"Name struct batt::MetricLabel class batt::MetricExporter class batt::CountMetricExporter class batt::DerivedMetricExporter class batt::VariableExporter class batt::WatchExporter class batt::QueueDepthExporter class batt::MetricRegistry","title":"Classes"},{"location":"_autogen/Files/metric__registry_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_REGISTRY_HPP","title":"Defines"},{"location":"_autogen/Files/metric__registry_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__registry_8hpp/#batteries_metrics_metric_registry_hpp","text":"1 #define BATTERIES_METRICS_METRIC_REGISTRY_HPP()","title":"BATTERIES_METRICS_METRIC_REGISTRY_HPP"},{"location":"_autogen/Files/metric__registry_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_REGISTRY_HPP #define BATTERIES_METRICS_METRIC_REGISTRY_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_collectors.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/watch.hpp> #include <batteries/config.hpp> #include <batteries/finally.hpp> #include <batteries/logging.hpp> #include <batteries/stream_util.hpp> #include <batteries/token.hpp> #include <memory> #include <mutex> #include <string_view> #include <unordered_map> #include <vector> namespace batt { // A key/value pair applied to a multi-dimensional metric. // struct MetricLabel { Token key ; Token value ; }; // A collection of MetricLabel values applied to a metric. // using MetricLabelSet = std :: vector < MetricLabel > ; // Sorts the given metric set and eliminates duplicates. // MetricLabelSet normalize_labels ( MetricLabelSet && labels ); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // This interface must be implemented to export a metric. // class MetricExporter { public : MetricExporter ( const MetricExporter & ) = delete ; MetricExporter & operator = ( const MetricExporter & ) = delete ; virtual ~ MetricExporter () = default ; virtual Token get_name () const = 0 ; virtual std :: string_view get_description () const { return \"A metric.\" ; } virtual std :: string_view get_type () const { return \"counter\" ; } virtual const MetricLabelSet & get_labels () const { return this -> labels_ ; } virtual void set_labels ( MetricLabelSet && labels ) { this -> labels_ = normalize_labels ( std :: move ( labels )); } virtual double get_value () const = 0 ; protected : MetricExporter () = default ; private : MetricLabelSet labels_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a CountMetric<T>. // template < typename T > class CountMetricExporter : public MetricExporter { public : explicit CountMetricExporter ( const std :: string & name , CountMetric < T >& counter ) noexcept : name_ { name } , counter_ { counter } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> counter_ . load ()); } private : Token name_ ; CountMetric < T >& counter_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a DerivedMetric<T>. // template < typename T > class DerivedMetricExporter : public MetricExporter { public : explicit DerivedMetricExporter ( const std :: string & name , DerivedMetric < T >& metric ) noexcept : name_ { name } , metric_ { metric } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> metric_ ()); } private : Token name_ ; DerivedMetric < T >& metric_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a variable as a metric. // template < typename T > class VariableExporter : public MetricExporter { public : explicit VariableExporter ( const std :: string & name , const T & var ) noexcept : name_ { name }, var_ { var } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> var_ ); } private : Token name_ ; const T & var_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports a Watch<T> as a metric. // template < typename T > class WatchExporter : public MetricExporter { public : explicit WatchExporter ( const std :: string & name , Watch < T >& watch ) noexcept : name_ { name }, watch_ { watch } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> watch_ . get_value ()); } private : Token name_ ; Watch < T >& watch_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Exports Queue depth as a metric. // class QueueDepthExporter : public MetricExporter { public : explicit QueueDepthExporter ( const std :: string & name , QueueBase & queue ) noexcept : name_ { name } , queue_ { queue } { } Token get_name () const override { return this -> name_ ; } double get_value () const override { return static_cast < double > ( this -> queue_ . size ()); } private : Token name_ ; QueueBase & queue_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // A set of metric exporters. // class MetricRegistry { public : MetricRegistry & add_exporter ( const void * obj , std :: unique_ptr < MetricExporter > exporter , MetricLabelSet && labels ) { exporter -> set_labels ( std :: move ( labels )); std :: unique_lock < std :: mutex > lock { this -> mutex_ }; this -> metrics_ . emplace ( obj , std :: move ( exporter )); return * this ; } template < typename T > MetricRegistry & add ( std :: string_view name , CountMetric < T >& counter , MetricLabelSet && labels = MetricLabelSet {}) { BATT_VLOG ( 1 ) << \"adding CountMetric:\" << name ; return this -> add_exporter ( & counter , std :: make_unique < CountMetricExporter < T >> ( std :: string ( name ), counter ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , LatencyMetric & latency , MetricLabelSet && labels = MetricLabelSet {}) { BATT_VLOG ( 1 ) << \"adding LatencyMetric:\" << name ; this -> add_exporter ( & latency , std :: make_unique < CountMetricExporter < u64 >> ( to_string ( name , \"_total_usec\" ), latency . total_usec ), std :: move ( labels )); this -> add_exporter ( & latency , std :: make_unique < CountMetricExporter < u64 >> ( to_string ( name , \"_count\" ), latency . count ), std :: move ( labels )); return * this ; } template < typename T > MetricRegistry & add ( std :: string_view name , Watch < T >& watch , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & watch , std :: make_unique < WatchExporter < T >> ( std :: string ( name ), watch ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , QueueBase & queue , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & queue , std :: make_unique < QueueDepthExporter > ( to_string ( name , \"_queue_depth\" ), queue ), std :: move ( labels )); } template < typename T > MetricRegistry & add ( std :: string_view name , DerivedMetric < T >& metric , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & metric , std :: make_unique < DerivedMetricExporter < T >> ( name , metric ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , const double & var , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & var , std :: make_unique < VariableExporter < double >> ( std :: string ( name ), var ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , const usize & var , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & var , std :: make_unique < VariableExporter < usize >> ( std :: string ( name ), var ), std :: move ( labels )); } MetricRegistry & add ( std :: string_view name , const isize & var , MetricLabelSet && labels = MetricLabelSet {}) { return this -> add_exporter ( & var , std :: make_unique < VariableExporter < isize >> ( std :: string ( name ), var ), std :: move ( labels )); } // Invokes the passed function for all registered metrics. // void read_all ( std :: function < void ( std :: string_view name , double value , const MetricLabelSet & labels ) >&& fn ) const { struct MetricSnapshot { std :: string_view name ; double value ; MetricLabelSet labels ; }; std :: vector < MetricSnapshot > local_snapshot ; { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; for ( const auto & p : this -> metrics_ ) { local_snapshot . emplace_back ( MetricSnapshot { static_cast < const std :: string &> ( p . second -> get_name ()), p . second -> get_value (), p . second -> get_labels (), }); } } for ( const auto & m : local_snapshot ) { fn ( m . name , m . value , m . labels ); } } // Removes the passed metric from this registry. // template < typename T > MetricRegistry & remove ( T & obj ) { std :: unique_lock < std :: mutex > lock { this -> mutex_ }; this -> metrics_ . erase ( & obj ); return * this ; } // Adds the passed metric exporter (`obj`) to the registry under the given `name`; the metric will // automatically be removed from the registry when the last (moved) copy of the returned guard object goes // out of scope. // template < typename T > auto scoped_add ( std :: string_view name , T & obj ) { this -> add ( name , obj ); return finally ([ & obj , this ] { this -> remove ( obj ); }); } private : mutable std :: mutex mutex_ ; std :: unordered_multimap < const void * , std :: unique_ptr < MetricExporter >> metrics_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // A process-wide instance of MetricRegistry used by various components by default. // MetricRegistry & global_metric_registry (); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #if 0 const auto metric_name = [this](std::string_view property) { return ::batt::to_string(\"Scope_\", this->name_, \"_\", property); }; #define ADD_METRIC_(n) ::batt::global_metric_registry().add(metric_name(#n), this->metrics_.n) ADD_METRIC_(field_name); #undef ADD_METRIC_ ::batt::global_metric_registry() .add(metric_name(\"other_name\"), this->other_thing_); #endif } // namespace batt #endif // BATTERIES_METRICS_METRIC_REGISTRY_HPP #if BATT_HEADER_ONLY #include <batteries/metrics/metric_registry_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/metric__registry__impl_8hpp/","text":"batteries/metrics/metric_registry_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP #define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_registry.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricRegistry & global_metric_registry () { static MetricRegistry instance_ ; return instance_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricLabelSet normalize_labels ( MetricLabelSet && labels ) { std :: sort ( labels . begin (), labels . end (), []( const MetricLabel & left , const MetricLabel & right ) { return left . key < right . key ; }); labels . erase ( std :: unique ( labels . begin (), labels . end (), []( const MetricLabel & left , const MetricLabel & right ) { return left . key == right . key ; }), labels . end ()); return std :: move ( labels ); } } // namespace batt #endif // BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/metrics/metric_registry_impl.hpp"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#defines","text":"Name BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#batteries_metrics_metric_registry_impl_hpp","text":"1 #define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP()","title":"BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP #define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/metrics/metric_registry.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricRegistry & global_metric_registry () { static MetricRegistry instance_ ; return instance_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL MetricLabelSet normalize_labels ( MetricLabelSet && labels ) { std :: sort ( labels . begin (), labels . end (), []( const MetricLabel & left , const MetricLabel & right ) { return left . key < right . key ; }); labels . erase ( std :: unique ( labels . begin (), labels . end (), []( const MetricLabel & left , const MetricLabel & right ) { return left . key == right . key ; }), labels . end ()); return std :: move ( labels ); } } // namespace batt #endif // BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/mutex_8hpp/","text":"batteries/async/mutex.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Mutex class batt::Mutex::LockImpl struct batt::Mutex::ThreadSafeBaseIsNotSupportedByType Defines \ud83d\udd17 Name BATTERIES_ASYNC_MUTEX_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_MUTEX_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_MUTEX_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_MUTEX_HPP #define BATTERIES_ASYNC_MUTEX_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/watch.hpp> #include <batteries/int_types.hpp> #include <batteries/pointers.hpp> #include <atomic> namespace batt { template < typename T > class Mutex { public : template < typename U , typename MutexT > class LockImpl { public : explicit LockImpl ( MutexT & m ) noexcept : m_ { m }, val_ { & ( U & ) m_ . acquire ()} { } LockImpl ( const LockImpl & ) = delete ; LockImpl & operator = ( const LockImpl & ) = delete ; LockImpl ( LockImpl && ) = default ; LockImpl & operator = ( LockImpl && ) = default ; ~ LockImpl () noexcept { this -> release (); } bool is_held () const noexcept { return val_ != nullptr ; } explicit operator bool () const noexcept { return this -> is_held (); } U & operator * () noexcept { return * val_ ; } U * get () noexcept { return val_ . get (); } U & value () noexcept { return * val_ ; } U * operator -> () noexcept { return val_ . get (); } bool release () { if ( val_ != nullptr ) { val_ . release (); m_ . release (); return true ; } return false ; } private : MutexT & m_ ; UniqueNonOwningPtr < U > val_ ; }; using Lock = LockImpl < T , Mutex > ; using ConstLock = LockImpl < const T , const Mutex > ; Mutex ( const Mutex & ) = delete ; Mutex & operator = ( const Mutex & ) = delete ; Mutex () = default ; template < typename ... Args , typename = EnableIfNoShadow < Mutex , Args ... >> explicit Mutex ( Args && ... args ) noexcept : value_ ( BATT_FORWARD ( args )...) { } Lock lock () { return Lock { * this }; } ConstLock lock () const { return ConstLock { * this }; } template < typename Action > decltype ( auto ) with_lock ( Action && action ) { Lock lock { * this }; return BATT_FORWARD ( action )( value_ ); } template < typename Self , typename Base = typename Self :: ThreadSafeBase > static Base * thread_safe_base ( Self * ptr ) { return ptr ; } template < typename Self , typename Base = typename Self :: ThreadSafeBase > static const Base * thread_safe_base ( const Self * ptr ) { return ptr ; } template < typename Self , typename Base = typename Self :: ThreadSafeBase , typename = void > static Base * thread_safe_base ( const std :: unique_ptr < Self >* ptr ) { return ptr -> get (); } template < typename > struct ThreadSafeBaseIsNotSupportedByType { }; static ThreadSafeBaseIsNotSupportedByType < T >* thread_safe_base (...) { return nullptr ; } auto operator -> () { return thread_safe_base ( & this -> value_ ); } decltype ( auto ) no_lock () { return * thread_safe_base ( & this -> value_ ); } decltype ( auto ) no_lock () const { return * thread_safe_base ( & this -> value_ ); } private : const T & acquire () const { const u64 my_ticket = next_ticket_ . fetch_add ( 1 ); StatusOr < u64 > latest_ticket = current_ticket_ . get_value (); // This is OK since it will probably take something like 100 years to wrap. We should be so lucky! // while ( latest_ticket . ok () && * latest_ticket < my_ticket ) { latest_ticket = current_ticket_ . await_not_equal ( * latest_ticket ); } BATT_CHECK_EQ ( * latest_ticket , my_ticket ); return value_ ; } void release () const { current_ticket_ . fetch_add ( 1 ); } mutable std :: atomic < u64 > next_ticket_ { 0 }; mutable Watch < u64 > current_ticket_ { 0 }; T value_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_MUTEX_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/mutex.hpp"},{"location":"_autogen/Files/mutex_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/mutex_8hpp/#classes","text":"Name class batt::Mutex class batt::Mutex::LockImpl struct batt::Mutex::ThreadSafeBaseIsNotSupportedByType","title":"Classes"},{"location":"_autogen/Files/mutex_8hpp/#defines","text":"Name BATTERIES_ASYNC_MUTEX_HPP","title":"Defines"},{"location":"_autogen/Files/mutex_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/mutex_8hpp/#batteries_async_mutex_hpp","text":"1 #define BATTERIES_ASYNC_MUTEX_HPP()","title":"BATTERIES_ASYNC_MUTEX_HPP"},{"location":"_autogen/Files/mutex_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_MUTEX_HPP #define BATTERIES_ASYNC_MUTEX_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/watch.hpp> #include <batteries/int_types.hpp> #include <batteries/pointers.hpp> #include <atomic> namespace batt { template < typename T > class Mutex { public : template < typename U , typename MutexT > class LockImpl { public : explicit LockImpl ( MutexT & m ) noexcept : m_ { m }, val_ { & ( U & ) m_ . acquire ()} { } LockImpl ( const LockImpl & ) = delete ; LockImpl & operator = ( const LockImpl & ) = delete ; LockImpl ( LockImpl && ) = default ; LockImpl & operator = ( LockImpl && ) = default ; ~ LockImpl () noexcept { this -> release (); } bool is_held () const noexcept { return val_ != nullptr ; } explicit operator bool () const noexcept { return this -> is_held (); } U & operator * () noexcept { return * val_ ; } U * get () noexcept { return val_ . get (); } U & value () noexcept { return * val_ ; } U * operator -> () noexcept { return val_ . get (); } bool release () { if ( val_ != nullptr ) { val_ . release (); m_ . release (); return true ; } return false ; } private : MutexT & m_ ; UniqueNonOwningPtr < U > val_ ; }; using Lock = LockImpl < T , Mutex > ; using ConstLock = LockImpl < const T , const Mutex > ; Mutex ( const Mutex & ) = delete ; Mutex & operator = ( const Mutex & ) = delete ; Mutex () = default ; template < typename ... Args , typename = EnableIfNoShadow < Mutex , Args ... >> explicit Mutex ( Args && ... args ) noexcept : value_ ( BATT_FORWARD ( args )...) { } Lock lock () { return Lock { * this }; } ConstLock lock () const { return ConstLock { * this }; } template < typename Action > decltype ( auto ) with_lock ( Action && action ) { Lock lock { * this }; return BATT_FORWARD ( action )( value_ ); } template < typename Self , typename Base = typename Self :: ThreadSafeBase > static Base * thread_safe_base ( Self * ptr ) { return ptr ; } template < typename Self , typename Base = typename Self :: ThreadSafeBase > static const Base * thread_safe_base ( const Self * ptr ) { return ptr ; } template < typename Self , typename Base = typename Self :: ThreadSafeBase , typename = void > static Base * thread_safe_base ( const std :: unique_ptr < Self >* ptr ) { return ptr -> get (); } template < typename > struct ThreadSafeBaseIsNotSupportedByType { }; static ThreadSafeBaseIsNotSupportedByType < T >* thread_safe_base (...) { return nullptr ; } auto operator -> () { return thread_safe_base ( & this -> value_ ); } decltype ( auto ) no_lock () { return * thread_safe_base ( & this -> value_ ); } decltype ( auto ) no_lock () const { return * thread_safe_base ( & this -> value_ ); } private : const T & acquire () const { const u64 my_ticket = next_ticket_ . fetch_add ( 1 ); StatusOr < u64 > latest_ticket = current_ticket_ . get_value (); // This is OK since it will probably take something like 100 years to wrap. We should be so lucky! // while ( latest_ticket . ok () && * latest_ticket < my_ticket ) { latest_ticket = current_ticket_ . await_not_equal ( * latest_ticket ); } BATT_CHECK_EQ ( * latest_ticket , my_ticket ); return value_ ; } void release () const { current_ticket_ . fetch_add ( 1 ); } mutable std :: atomic < u64 > next_ticket_ { 0 }; mutable Watch < u64 > current_ticket_ { 0 }; T value_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_MUTEX_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/natural__equals_8hpp/","text":"batteries/seq/natural_equals.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::NaturalEquals Defines \ud83d\udd17 Name BATTERIES_SEQ_NATURAL_EQUALS_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_NATURAL_EQUALS_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_NATURAL_EQUALS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_NATURAL_EQUALS_HPP #define BATTERIES_SEQ_NATURAL_EQUALS_HPP #include <batteries/config.hpp> // namespace batt { namespace seq { struct NaturalEquals { template < typename L , typename R > bool operator ()( L && l , R && r ) const { return l == r ; } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_NATURAL_EQUALS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/natural_equals.hpp"},{"location":"_autogen/Files/natural__equals_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/natural__equals_8hpp/#classes","text":"Name struct batt::seq::NaturalEquals","title":"Classes"},{"location":"_autogen/Files/natural__equals_8hpp/#defines","text":"Name BATTERIES_SEQ_NATURAL_EQUALS_HPP","title":"Defines"},{"location":"_autogen/Files/natural__equals_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/natural__equals_8hpp/#batteries_seq_natural_equals_hpp","text":"1 #define BATTERIES_SEQ_NATURAL_EQUALS_HPP()","title":"BATTERIES_SEQ_NATURAL_EQUALS_HPP"},{"location":"_autogen/Files/natural__equals_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_NATURAL_EQUALS_HPP #define BATTERIES_SEQ_NATURAL_EQUALS_HPP #include <batteries/config.hpp> // namespace batt { namespace seq { struct NaturalEquals { template < typename L , typename R > bool operator ()( L && l , R && r ) const { return l == r ; } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_NATURAL_EQUALS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/natural__order_8hpp/","text":"batteries/seq/natural_order.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::NaturalOrder Defines \ud83d\udd17 Name BATTERIES_SEQ_NATURAL_ORDER_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_NATURAL_ORDER_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_NATURAL_ORDER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_NATURAL_ORDER_HPP #define BATTERIES_SEQ_NATURAL_ORDER_HPP #include <batteries/config.hpp> // namespace batt { namespace seq { struct NaturalOrder { template < typename L , typename R > bool operator ()( L && l , R && r ) const { return l < r ; } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_NATURAL_ORDER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/natural_order.hpp"},{"location":"_autogen/Files/natural__order_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/natural__order_8hpp/#classes","text":"Name struct batt::seq::NaturalOrder","title":"Classes"},{"location":"_autogen/Files/natural__order_8hpp/#defines","text":"Name BATTERIES_SEQ_NATURAL_ORDER_HPP","title":"Defines"},{"location":"_autogen/Files/natural__order_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/natural__order_8hpp/#batteries_seq_natural_order_hpp","text":"1 #define BATTERIES_SEQ_NATURAL_ORDER_HPP()","title":"BATTERIES_SEQ_NATURAL_ORDER_HPP"},{"location":"_autogen/Files/natural__order_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_NATURAL_ORDER_HPP #define BATTERIES_SEQ_NATURAL_ORDER_HPP #include <batteries/config.hpp> // namespace batt { namespace seq { struct NaturalOrder { template < typename L , typename R > bool operator ()( L && l , R && r ) const { return l < r ; } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_NATURAL_ORDER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/nullable_8hpp/","text":"batteries/nullable.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::detail::NullableImpl struct batt::detail::NullableImpl< std::optional< T > > struct batt::detail::NullableImpl< std::unique_ptr< T > > struct batt::detail::NullableImpl< std::shared_ptr< T > > struct batt::detail::NullableImpl< T * > Defines \ud83d\udd17 Name BATTERIES_NULLABLE_HPP Macro Documentation \ud83d\udd17 BATTERIES_NULLABLE_HPP \ud83d\udd17 1 #define BATTERIES_NULLABLE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_NULLABLE_HPP #define BATTERIES_NULLABLE_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> #include <memory> #include <optional> namespace batt { namespace detail { template < typename T > struct NullableImpl { using type = std :: optional < T > ; }; template < typename T > struct NullableImpl < std :: optional < T >> { using type = std :: optional < T > ; }; template < typename T > struct NullableImpl < std :: unique_ptr < T >> { using type = std :: unique_ptr < T > ; }; template < typename T > struct NullableImpl < std :: shared_ptr < T >> { using type = std :: shared_ptr < T > ; }; template < typename T > struct NullableImpl < T *> { using type = T * ; }; } // namespace detail template < typename T > using Nullable = typename detail :: NullableImpl < T >:: type ; template < typename T > auto make_nullable ( T && obj ) -> Nullable < std :: decay_t < T >> { return Nullable < std :: decay_t < T >> ( BATT_FORWARD ( obj )); } } // namespace batt #endif // BATTERIES_NULLABLE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/nullable.hpp"},{"location":"_autogen/Files/nullable_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/nullable_8hpp/#classes","text":"Name struct batt::detail::NullableImpl struct batt::detail::NullableImpl< std::optional< T > > struct batt::detail::NullableImpl< std::unique_ptr< T > > struct batt::detail::NullableImpl< std::shared_ptr< T > > struct batt::detail::NullableImpl< T * >","title":"Classes"},{"location":"_autogen/Files/nullable_8hpp/#defines","text":"Name BATTERIES_NULLABLE_HPP","title":"Defines"},{"location":"_autogen/Files/nullable_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/nullable_8hpp/#batteries_nullable_hpp","text":"1 #define BATTERIES_NULLABLE_HPP()","title":"BATTERIES_NULLABLE_HPP"},{"location":"_autogen/Files/nullable_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_NULLABLE_HPP #define BATTERIES_NULLABLE_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> #include <memory> #include <optional> namespace batt { namespace detail { template < typename T > struct NullableImpl { using type = std :: optional < T > ; }; template < typename T > struct NullableImpl < std :: optional < T >> { using type = std :: optional < T > ; }; template < typename T > struct NullableImpl < std :: unique_ptr < T >> { using type = std :: unique_ptr < T > ; }; template < typename T > struct NullableImpl < std :: shared_ptr < T >> { using type = std :: shared_ptr < T > ; }; template < typename T > struct NullableImpl < T *> { using type = T * ; }; } // namespace detail template < typename T > using Nullable = typename detail :: NullableImpl < T >:: type ; template < typename T > auto make_nullable ( T && obj ) -> Nullable < std :: decay_t < T >> { return Nullable < std :: decay_t < T >> ( BATT_FORWARD ( obj )); } } // namespace batt #endif // BATTERIES_NULLABLE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/optional_8hpp/","text":"batteries/optional.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::NoneType struct batt::InPlaceInitType class batt::Optional class batt::Optional< T & > Defines \ud83d\udd17 Name BATTERIES_OPTIONAL_HPP Macro Documentation \ud83d\udd17 BATTERIES_OPTIONAL_HPP \ud83d\udd17 1 #define BATTERIES_OPTIONAL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_OPTIONAL_HPP #define BATTERIES_OPTIONAL_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <optional> #ifdef BATT_USE_BOOST_OPTIONAL #include <boost/optional.hpp> #include <boost/optional/optional_io.hpp> namespace batt { template < typename T > using Optional = boost :: optional < T > ; namespace { decltype ( auto ) None = boost :: none ; decltype ( auto ) InPlaceInit = boost :: in_place_init ; } // namespace using NoneType = std :: decay_t < decltype ( boost :: none ) > ; template < typename ... Args > auto make_optional ( Args && ... args ) { return boost :: make_optional ( std :: forward < Args > ( args )...); } template < typename T , typename U , typename = decltype ( std :: declval < const T &> () == std :: declval < const U &> ()) > inline bool operator == ( const Optional < T >& l , const Optional < U >& r ) { return ( l && r && * l == * r ) || ( ! l && ! r ); } } // namespace batt #else //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Custom optional implementation. //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { struct NoneType { }; struct InPlaceInitType { }; #if defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wunused-variable\" #endif namespace { NoneType None ; InPlaceInitType InPlaceInit ; } // namespace #if defined(__GNUC__) #pragma GCC diagnostic pop #endif template < typename T > class Optional { public : static_assert ( std :: is_same_v < T , std :: decay_t < T > > , \"Optional<T&> is (partially) explicitly specialized below\" ); Optional () noexcept : valid_ { false } { } Optional ( NoneType ) noexcept : valid_ { false } { } template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > > > Optional ( InPlaceInitType , Args && ... args ) noexcept : valid_ { false } { new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); valid_ = true ; } Optional ( std :: optional < T >&& init ) noexcept : valid_ { !! init } { if ( this -> valid_ ) { new ( & this -> storage_ ) T ( std :: move ( * init )); } } /* template <typename U, typename = std::enable_if_t<!std::is_constructible_v<T, U&&> && std::is_convertible_v<U, T> >, typename = batt::EnableIfNoShadow<Optional, U> > Optional(U&& u) noexcept : valid_{false} { new (&this->storage_) T(BATT_FORWARD(u)); valid_ = true; } */ template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U > > Optional ( Optional < U >&& u ) noexcept : valid_ { false } { if ( u ) { new ( & this -> storage_ ) T ( std :: move ( * u )); valid_ = true ; } } template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U > > Optional ( const Optional < U >& u ) noexcept : valid_ { false } { if ( u ) { new ( & this -> storage_ ) T ( * u ); valid_ = true ; } } template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > > , typename = batt :: EnableIfNoShadow < Optional , Args ... > > Optional ( Args && ... args ) noexcept : valid_ { false } { new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); valid_ = true ; } Optional ( const T & val ) noexcept : valid_ { false } { new ( & this -> storage_ ) T ( val ); valid_ = true ; } ~ Optional () noexcept { if ( this -> valid_ ) { this -> obj (). ~ T (); } } Optional ( Optional && that ) noexcept : valid_ { false } { if ( that . valid_ ) { new ( & this -> storage_ ) T ( std :: move ( that . obj ())); valid_ = true ; } } Optional ( const Optional & that ) noexcept : valid_ { false } { if ( that . valid_ ) { new ( & this -> storage_ ) T ( that . obj ()); valid_ = true ; } } Optional & operator = ( Optional && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } if ( that . valid_ ) { new ( & this -> storage_ ) T ( std :: move ( that . obj ())); this -> valid_ = true ; } } return * this ; } Optional & operator = ( const Optional & that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } if ( that . valid_ ) { new ( & this -> storage_ ) T ( that . obj ()); this -> valid_ = true ; } } return * this ; } template < typename ... Args > T & emplace ( Args && ... args ) noexcept { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); this -> valid_ = true ; return this -> obj (); } template < typename U > T value_or ( U && else_val ) const noexcept { if ( this -> valid_ ) { return this -> obj (); } return T ( BATT_FORWARD ( else_val )); } template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &> > Optional < U > map ( Fn && fn ) const noexcept { if ( this -> valid_ ) { return BATT_FORWARD ( fn )( this -> obj ()); } return None ; } template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &> > OptionalU flat_map ( Fn && fn ) const noexcept { if ( this -> valid_ ) { return BATT_FORWARD ( fn )( this -> obj ()); } return None ; } explicit operator bool () const noexcept { return this -> valid_ ; } bool has_value () const noexcept { return this -> valid_ ; } Optional & operator = ( NoneType ) noexcept { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } return * this ; } T & operator * () & noexcept { return this -> obj (); } const T & operator * () const & noexcept { return this -> obj (); } T operator * () && noexcept { return std :: move ( this -> obj ()); } T operator * () const && noexcept = delete ; T * operator -> () noexcept { return & this -> obj (); } const T * operator -> () const noexcept { return & this -> obj (); } T * get_ptr () noexcept { return & this -> obj (); } const T * get_ptr () const noexcept { return & this -> obj (); } private : T & obj () noexcept { return * ( T * ) & this -> storage_ ; } const T & obj () const noexcept { return * ( T * ) & this -> storage_ ; } std :: aligned_storage_t < sizeof ( T ), alignof ( T ) > storage_ ; bool valid_ = false ; }; template < typename T > class Optional < T &> { public : Optional ( NoneType ) noexcept : ptr_ { nullptr } { } Optional ( T & ref ) noexcept : ptr_ { & ref } { } ~ Optional () noexcept { // nothing to do. } template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &> > Optional < U > map ( Fn && fn ) const noexcept { if ( this -> ptr_ ) { return BATT_FORWARD ( fn )( * this -> ptr_ ); } return None ; } template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &> > OptionalU flat_map ( Fn && fn ) const noexcept { if ( this -> ptr_ ) { return BATT_FORWARD ( fn )( * this -> ptr_ ); } return None ; } T & operator * () const noexcept { return * this -> ptr_ ; } explicit operator bool () const noexcept { return this -> ptr_ != nullptr ; } bool operator ! () const noexcept { return this -> ptr_ == nullptr ; } private : T * ptr_ = nullptr ; }; template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 >& v0 , const Optional < T1 >& v1 ) { return ( v0 && v1 && ( * v0 == * v1 )) || ( ! v0 && ! v1 ); } template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 >& v0 , const Optional < T1 >& v1 ) { return ! ( v0 == v1 ); } template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 >& v0 , const T1 & v1 ) { return v0 && ( * v0 == v1 ); } template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 >& v0 , const T1 & v1 ) { return ! ( v0 == v1 ); } template < typename T0 , typename T1 > inline bool operator == ( const T0 & v0 , const Optional < T1 >& v1 ) { return v1 && ( v0 == * v1 ); } template < typename T0 , typename T1 > inline bool operator != ( const T0 & v0 , const Optional < T1 >& v1 ) { return ! ( v0 == v1 ); } template < typename T > inline bool operator == ( NoneType , const Optional < T >& v ) { return ! v ; } template < typename T > inline bool operator != ( NoneType , const Optional < T >& v ) { return ! ( None == v ); } template < typename T > inline bool operator == ( const Optional < T >& v , NoneType ) { return ! v ; } template < typename T > inline bool operator != ( const Optional < T >& v , NoneType ) { return ! ( v == None ); } template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Optional < T >& t ) { if ( ! t ) { return out << \"--\" ; } return out << make_printable ( * t ); } inline std :: ostream & operator << ( std :: ostream & out , const NoneType & ) { return out << \"--\" ; } template < typename T > Optional < std :: decay_t < T > > make_optional ( T && val ) noexcept { return { BATT_FORWARD ( val )}; } } // namespace batt #endif namespace batt { template < typename T > decltype ( auto ) get_or_panic ( Optional < T >& opt ) { BATT_CHECK ( opt ); return * opt ; } template < typename T > decltype ( auto ) get_or_panic ( const Optional < T >& opt ) { BATT_CHECK ( opt ); return * opt ; } template < typename T > decltype ( auto ) get_or_panic ( Optional < T >&& opt ) { BATT_CHECK ( opt ); return std :: move ( * opt ); } } // namespace batt #endif // BATTERIES_OPTIONAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/optional.hpp"},{"location":"_autogen/Files/optional_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/optional_8hpp/#classes","text":"Name struct batt::NoneType struct batt::InPlaceInitType class batt::Optional class batt::Optional< T & >","title":"Classes"},{"location":"_autogen/Files/optional_8hpp/#defines","text":"Name BATTERIES_OPTIONAL_HPP","title":"Defines"},{"location":"_autogen/Files/optional_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/optional_8hpp/#batteries_optional_hpp","text":"1 #define BATTERIES_OPTIONAL_HPP()","title":"BATTERIES_OPTIONAL_HPP"},{"location":"_autogen/Files/optional_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_OPTIONAL_HPP #define BATTERIES_OPTIONAL_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <optional> #ifdef BATT_USE_BOOST_OPTIONAL #include <boost/optional.hpp> #include <boost/optional/optional_io.hpp> namespace batt { template < typename T > using Optional = boost :: optional < T > ; namespace { decltype ( auto ) None = boost :: none ; decltype ( auto ) InPlaceInit = boost :: in_place_init ; } // namespace using NoneType = std :: decay_t < decltype ( boost :: none ) > ; template < typename ... Args > auto make_optional ( Args && ... args ) { return boost :: make_optional ( std :: forward < Args > ( args )...); } template < typename T , typename U , typename = decltype ( std :: declval < const T &> () == std :: declval < const U &> ()) > inline bool operator == ( const Optional < T >& l , const Optional < U >& r ) { return ( l && r && * l == * r ) || ( ! l && ! r ); } } // namespace batt #else //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Custom optional implementation. //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { struct NoneType { }; struct InPlaceInitType { }; #if defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wunused-variable\" #endif namespace { NoneType None ; InPlaceInitType InPlaceInit ; } // namespace #if defined(__GNUC__) #pragma GCC diagnostic pop #endif template < typename T > class Optional { public : static_assert ( std :: is_same_v < T , std :: decay_t < T > > , \"Optional<T&> is (partially) explicitly specialized below\" ); Optional () noexcept : valid_ { false } { } Optional ( NoneType ) noexcept : valid_ { false } { } template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > > > Optional ( InPlaceInitType , Args && ... args ) noexcept : valid_ { false } { new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); valid_ = true ; } Optional ( std :: optional < T >&& init ) noexcept : valid_ { !! init } { if ( this -> valid_ ) { new ( & this -> storage_ ) T ( std :: move ( * init )); } } /* template <typename U, typename = std::enable_if_t<!std::is_constructible_v<T, U&&> && std::is_convertible_v<U, T> >, typename = batt::EnableIfNoShadow<Optional, U> > Optional(U&& u) noexcept : valid_{false} { new (&this->storage_) T(BATT_FORWARD(u)); valid_ = true; } */ template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U > > Optional ( Optional < U >&& u ) noexcept : valid_ { false } { if ( u ) { new ( & this -> storage_ ) T ( std :: move ( * u )); valid_ = true ; } } template < typename U , typename = std :: enable_if_t < std :: is_convertible_v < U , T > && ! std :: is_same_v < T , Optional < U > > > , typename = batt :: EnableIfNoShadow < Optional , U > > Optional ( const Optional < U >& u ) noexcept : valid_ { false } { if ( u ) { new ( & this -> storage_ ) T ( * u ); valid_ = true ; } } template < typename ... Args , typename = std :: enable_if_t < std :: is_constructible_v < T , Args && ... > > , typename = batt :: EnableIfNoShadow < Optional , Args ... > > Optional ( Args && ... args ) noexcept : valid_ { false } { new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); valid_ = true ; } Optional ( const T & val ) noexcept : valid_ { false } { new ( & this -> storage_ ) T ( val ); valid_ = true ; } ~ Optional () noexcept { if ( this -> valid_ ) { this -> obj (). ~ T (); } } Optional ( Optional && that ) noexcept : valid_ { false } { if ( that . valid_ ) { new ( & this -> storage_ ) T ( std :: move ( that . obj ())); valid_ = true ; } } Optional ( const Optional & that ) noexcept : valid_ { false } { if ( that . valid_ ) { new ( & this -> storage_ ) T ( that . obj ()); valid_ = true ; } } Optional & operator = ( Optional && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } if ( that . valid_ ) { new ( & this -> storage_ ) T ( std :: move ( that . obj ())); this -> valid_ = true ; } } return * this ; } Optional & operator = ( const Optional & that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } if ( that . valid_ ) { new ( & this -> storage_ ) T ( that . obj ()); this -> valid_ = true ; } } return * this ; } template < typename ... Args > T & emplace ( Args && ... args ) noexcept { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); this -> valid_ = true ; return this -> obj (); } template < typename U > T value_or ( U && else_val ) const noexcept { if ( this -> valid_ ) { return this -> obj (); } return T ( BATT_FORWARD ( else_val )); } template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &> > Optional < U > map ( Fn && fn ) const noexcept { if ( this -> valid_ ) { return BATT_FORWARD ( fn )( this -> obj ()); } return None ; } template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &> > OptionalU flat_map ( Fn && fn ) const noexcept { if ( this -> valid_ ) { return BATT_FORWARD ( fn )( this -> obj ()); } return None ; } explicit operator bool () const noexcept { return this -> valid_ ; } bool has_value () const noexcept { return this -> valid_ ; } Optional & operator = ( NoneType ) noexcept { if ( this -> valid_ ) { this -> valid_ = false ; this -> obj (). ~ T (); } return * this ; } T & operator * () & noexcept { return this -> obj (); } const T & operator * () const & noexcept { return this -> obj (); } T operator * () && noexcept { return std :: move ( this -> obj ()); } T operator * () const && noexcept = delete ; T * operator -> () noexcept { return & this -> obj (); } const T * operator -> () const noexcept { return & this -> obj (); } T * get_ptr () noexcept { return & this -> obj (); } const T * get_ptr () const noexcept { return & this -> obj (); } private : T & obj () noexcept { return * ( T * ) & this -> storage_ ; } const T & obj () const noexcept { return * ( T * ) & this -> storage_ ; } std :: aligned_storage_t < sizeof ( T ), alignof ( T ) > storage_ ; bool valid_ = false ; }; template < typename T > class Optional < T &> { public : Optional ( NoneType ) noexcept : ptr_ { nullptr } { } Optional ( T & ref ) noexcept : ptr_ { & ref } { } ~ Optional () noexcept { // nothing to do. } template < typename Fn , typename U = std :: invoke_result_t < Fn , const T &> > Optional < U > map ( Fn && fn ) const noexcept { if ( this -> ptr_ ) { return BATT_FORWARD ( fn )( * this -> ptr_ ); } return None ; } template < typename Fn , typename OptionalU = std :: invoke_result_t < Fn , const T &> > OptionalU flat_map ( Fn && fn ) const noexcept { if ( this -> ptr_ ) { return BATT_FORWARD ( fn )( * this -> ptr_ ); } return None ; } T & operator * () const noexcept { return * this -> ptr_ ; } explicit operator bool () const noexcept { return this -> ptr_ != nullptr ; } bool operator ! () const noexcept { return this -> ptr_ == nullptr ; } private : T * ptr_ = nullptr ; }; template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 >& v0 , const Optional < T1 >& v1 ) { return ( v0 && v1 && ( * v0 == * v1 )) || ( ! v0 && ! v1 ); } template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 >& v0 , const Optional < T1 >& v1 ) { return ! ( v0 == v1 ); } template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 >& v0 , const T1 & v1 ) { return v0 && ( * v0 == v1 ); } template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 >& v0 , const T1 & v1 ) { return ! ( v0 == v1 ); } template < typename T0 , typename T1 > inline bool operator == ( const T0 & v0 , const Optional < T1 >& v1 ) { return v1 && ( v0 == * v1 ); } template < typename T0 , typename T1 > inline bool operator != ( const T0 & v0 , const Optional < T1 >& v1 ) { return ! ( v0 == v1 ); } template < typename T > inline bool operator == ( NoneType , const Optional < T >& v ) { return ! v ; } template < typename T > inline bool operator != ( NoneType , const Optional < T >& v ) { return ! ( None == v ); } template < typename T > inline bool operator == ( const Optional < T >& v , NoneType ) { return ! v ; } template < typename T > inline bool operator != ( const Optional < T >& v , NoneType ) { return ! ( v == None ); } template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Optional < T >& t ) { if ( ! t ) { return out << \"--\" ; } return out << make_printable ( * t ); } inline std :: ostream & operator << ( std :: ostream & out , const NoneType & ) { return out << \"--\" ; } template < typename T > Optional < std :: decay_t < T > > make_optional ( T && val ) noexcept { return { BATT_FORWARD ( val )}; } } // namespace batt #endif namespace batt { template < typename T > decltype ( auto ) get_or_panic ( Optional < T >& opt ) { BATT_CHECK ( opt ); return * opt ; } template < typename T > decltype ( auto ) get_or_panic ( const Optional < T >& opt ) { BATT_CHECK ( opt ); return * opt ; } template < typename T > decltype ( auto ) get_or_panic ( Optional < T >&& opt ) { BATT_CHECK ( opt ); return std :: move ( * opt ); } } // namespace batt #endif // BATTERIES_OPTIONAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parallel__accumulate_8hpp/","text":"batteries/algo/parallel_accumulate.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP Macro Documentation \ud83d\udd17 BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP \ud83d\udd17 1 #define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP #define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/slice.hpp> #include <batteries/small_vec.hpp> #include <algorithm> #include <iterator> #include <numeric> #include <thread> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter , typename T , typename BinaryOp > Slice < T > parallel_accumulate_partial ( WorkContext & context , // Iter first , Iter last , T init , // const BinaryOp & binary_op , T identity , // const Slice < T >& task_result_buffer , // const WorkSliceParams & params ) { if ( first == last ) { return as_slice ( task_result_buffer . begin (), 0 ); } if ( params . max_tasks == 1 ) { BATT_CHECK_GE ( task_result_buffer . size (), 1u ); task_result_buffer . front () = std :: accumulate ( first , last , init , binary_op ); return as_slice ( task_result_buffer . begin (), 1 ); } const WorkSlicePlan plan { params , first , last }; Slice < T > task_results = as_slice ( task_result_buffer . begin (), plan . n_tasks ); std :: fill ( task_results . begin (), task_results . end (), identity ); if ( ! task_results . empty ()) { task_results . front () = init ; } slice_work ( context , plan , /*gen_work_fn=*/ [ & ]( TaskIndex task_index , TaskOffset task_offset , TaskSize task_size ) { return [ task_index , task_offset , task_size , first , & binary_op , task_results ] { auto task_begin = std :: next ( first , task_offset ); auto task_end = std :: next ( task_begin , task_size ); task_results [ task_index ] = std :: accumulate ( task_begin , task_end , task_results [ task_index ], binary_op ); }; }); return task_results ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Iter , typename T , typename BinaryOp > T parallel_accumulate ( WorkerPool & worker_pool , // Iter first , Iter last , T init , // const BinaryOp & binary_op , T identity , // TaskSize min_task_size = TaskSize { 4096 }, // TaskCount max_tasks = TaskCount { std :: thread :: hardware_concurrency ()}) { if ( first == last ) { return init ; } BATT_CHECK_GT ( min_task_size , 0 ); BATT_CHECK_GT ( max_tasks , 0 ); const InputSize input_size { BATT_CHECKED_CAST ( usize , std :: distance ( first , last ))}; if ( max_tasks == 1 || input_size <= std :: max < usize > ( min_task_size , max_tasks )) { return std :: accumulate ( first , last , init , binary_op ); } SmallVec < T , 64 > task_result_buffer ( max_tasks ); Slice < T > task_results ; { ScopedWorkContext context { worker_pool }; task_results = parallel_accumulate_partial ( context , // first , last , init , // binary_op , identity , // as_slice ( task_result_buffer ), // WorkSliceParams { min_task_size , max_tasks }); } BATT_CHECK ( ! task_results . empty ()); return parallel_accumulate ( worker_pool , // std :: next ( task_results . begin ()), task_results . end (), task_results . front (), // binary_op , identity , // min_task_size , // max_tasks ); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo/parallel_accumulate.hpp"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#defines","text":"Name BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP","title":"Defines"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#batteries_algo_parallel_accumulate_hpp","text":"1 #define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP()","title":"BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP #define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/slice.hpp> #include <batteries/small_vec.hpp> #include <algorithm> #include <iterator> #include <numeric> #include <thread> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter , typename T , typename BinaryOp > Slice < T > parallel_accumulate_partial ( WorkContext & context , // Iter first , Iter last , T init , // const BinaryOp & binary_op , T identity , // const Slice < T >& task_result_buffer , // const WorkSliceParams & params ) { if ( first == last ) { return as_slice ( task_result_buffer . begin (), 0 ); } if ( params . max_tasks == 1 ) { BATT_CHECK_GE ( task_result_buffer . size (), 1u ); task_result_buffer . front () = std :: accumulate ( first , last , init , binary_op ); return as_slice ( task_result_buffer . begin (), 1 ); } const WorkSlicePlan plan { params , first , last }; Slice < T > task_results = as_slice ( task_result_buffer . begin (), plan . n_tasks ); std :: fill ( task_results . begin (), task_results . end (), identity ); if ( ! task_results . empty ()) { task_results . front () = init ; } slice_work ( context , plan , /*gen_work_fn=*/ [ & ]( TaskIndex task_index , TaskOffset task_offset , TaskSize task_size ) { return [ task_index , task_offset , task_size , first , & binary_op , task_results ] { auto task_begin = std :: next ( first , task_offset ); auto task_end = std :: next ( task_begin , task_size ); task_results [ task_index ] = std :: accumulate ( task_begin , task_end , task_results [ task_index ], binary_op ); }; }); return task_results ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Iter , typename T , typename BinaryOp > T parallel_accumulate ( WorkerPool & worker_pool , // Iter first , Iter last , T init , // const BinaryOp & binary_op , T identity , // TaskSize min_task_size = TaskSize { 4096 }, // TaskCount max_tasks = TaskCount { std :: thread :: hardware_concurrency ()}) { if ( first == last ) { return init ; } BATT_CHECK_GT ( min_task_size , 0 ); BATT_CHECK_GT ( max_tasks , 0 ); const InputSize input_size { BATT_CHECKED_CAST ( usize , std :: distance ( first , last ))}; if ( max_tasks == 1 || input_size <= std :: max < usize > ( min_task_size , max_tasks )) { return std :: accumulate ( first , last , init , binary_op ); } SmallVec < T , 64 > task_result_buffer ( max_tasks ); Slice < T > task_results ; { ScopedWorkContext context { worker_pool }; task_results = parallel_accumulate_partial ( context , // first , last , init , // binary_op , identity , // as_slice ( task_result_buffer ), // WorkSliceParams { min_task_size , max_tasks }); } BATT_CHECK ( ! task_results . empty ()); return parallel_accumulate ( worker_pool , // std :: next ( task_results . begin ()), task_results . end (), task_results . front (), // binary_op , identity , // min_task_size , // max_tasks ); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parallel__copy_8hpp/","text":"batteries/algo/parallel_copy.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ALGO_PARALLEL_COPY_HPP Macro Documentation \ud83d\udd17 BATTERIES_ALGO_PARALLEL_COPY_HPP \ud83d\udd17 1 #define BATTERIES_ALGO_PARALLEL_COPY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_COPY_HPP #define BATTERIES_ALGO_PARALLEL_COPY_HPP #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <iterator> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Src , typename Dst > void parallel_copy ( WorkContext & work_context , // Src src_begin , Src src_end , // Dst dst_begin , // TaskSize min_task_size , // TaskCount max_tasks ) { if ( max_tasks == 1 ) { std :: copy ( src_begin , src_end , dst_begin ); return ; } const WorkSlicePlan plan { WorkSliceParams { min_task_size , max_tasks }, src_begin , src_end }; slice_work ( work_context , plan , /*gen_work_fn=*/ [ & ]( usize /*task_index*/ , isize task_offset , isize task_size ) { return [ src_begin , dst_begin , task_offset , task_size ] { auto task_src_begin = std :: next ( src_begin , task_offset ); auto task_src_end = std :: next ( task_src_begin , task_size ); auto task_dst_begin = std :: next ( dst_begin , task_offset ); std :: copy ( task_src_begin , task_src_end , task_dst_begin ); }; }); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_COPY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo/parallel_copy.hpp"},{"location":"_autogen/Files/parallel__copy_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/parallel__copy_8hpp/#defines","text":"Name BATTERIES_ALGO_PARALLEL_COPY_HPP","title":"Defines"},{"location":"_autogen/Files/parallel__copy_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parallel__copy_8hpp/#batteries_algo_parallel_copy_hpp","text":"1 #define BATTERIES_ALGO_PARALLEL_COPY_HPP()","title":"BATTERIES_ALGO_PARALLEL_COPY_HPP"},{"location":"_autogen/Files/parallel__copy_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_COPY_HPP #define BATTERIES_ALGO_PARALLEL_COPY_HPP #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <iterator> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Src , typename Dst > void parallel_copy ( WorkContext & work_context , // Src src_begin , Src src_end , // Dst dst_begin , // TaskSize min_task_size , // TaskCount max_tasks ) { if ( max_tasks == 1 ) { std :: copy ( src_begin , src_end , dst_begin ); return ; } const WorkSlicePlan plan { WorkSliceParams { min_task_size , max_tasks }, src_begin , src_end }; slice_work ( work_context , plan , /*gen_work_fn=*/ [ & ]( usize /*task_index*/ , isize task_offset , isize task_size ) { return [ src_begin , dst_begin , task_offset , task_size ] { auto task_src_begin = std :: next ( src_begin , task_offset ); auto task_src_end = std :: next ( task_src_begin , task_size ); auto task_dst_begin = std :: next ( dst_begin , task_offset ); std :: copy ( task_src_begin , task_src_end , task_dst_begin ); }; }); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_COPY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parallel__merge_8hpp/","text":"batteries/algo/parallel_merge.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::detail::FirstPhase struct batt::detail::SecondPhase struct batt::detail::ThirdPhase Defines \ud83d\udd17 Name BATTERIES_ALGO_PARALLEL_MERGE_HPP Macro Documentation \ud83d\udd17 BATTERIES_ALGO_PARALLEL_MERGE_HPP \ud83d\udd17 1 #define BATTERIES_ALGO_PARALLEL_MERGE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_MERGE_HPP #define BATTERIES_ALGO_PARALLEL_MERGE_HPP #include <batteries/algo/parallel_copy.hpp> #include <batteries/async/work_context.hpp> #include <batteries/int_types.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // namespace detail { struct FirstPhase ; struct SecondPhase ; struct ThirdPhase ; struct FirstPhase { static const char * name () { return \"FirstPhase\" ; } using NextPhase = SecondPhase ; template < typename Src0 , typename Src1 > static const Src0 & fixed_iter ( const Src0 & src_0 , const Src1 & /*src_1*/ ) { return src_0 ; } template < typename Src0 , typename Src1 > static const Src1 & search_iter ( const Src0 & /*src_0*/ , const Src1 & src_1 ) { return src_1 ; } template < typename Fixed , typename Search > static const Fixed & src_0_iter ( const Fixed & fixed , const Search & /*search*/ ) { return fixed ; } template < typename Fixed , typename Search > static const Search & src_1_iter ( const Fixed & /*fixed*/ , const Search & search ) { return search ; } }; struct SecondPhase { static const char * name () { return \"SecondPhase\" ; } using NextPhase = ThirdPhase ; template < typename Src0 , typename Src1 > static const Src1 & fixed_iter ( const Src0 & /*src_0*/ , const Src1 & src_1 ) { return src_1 ; } template < typename Src0 , typename Src1 > static const Src0 & search_iter ( const Src0 & src_0 , const Src1 & /*src_1*/ ) { return src_0 ; } template < typename Fixed , typename Search > static const Search & src_0_iter ( const Fixed & /*fixed*/ , const Search & search ) { return search ; } template < typename Fixed , typename Search > static const Fixed & src_1_iter ( const Fixed & fixed , const Search & /*search*/ ) { return fixed ; } }; struct ThirdPhase : SecondPhase { static const char * name () { return \"ThirdPhase\" ; } }; static constexpr isize kThreshold = 1400 ; static constexpr isize kMaxShards = 8 ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , // Fixed fixed_begin , Fixed fixed_end , // Search search_begin , Search search_end , // Dst dst_begin , // Compare && compare , // usize min_task_size , // usize max_tasks , // batt :: StaticType < Phase > ); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Src0 , typename Src1 , typename Dst , typename Compare , typename Phase > void parallel_merge_impl ( WorkContext & context , // Src0 src_0_begin , Src0 src_0_end , // Src1 src_1_begin , Src1 src_1_end , // Dst dst_begin , // Compare && compare , // usize min_task_size , // usize max_tasks , // batt :: StaticType < Phase > phase ) { const isize src_0_size = std :: distance ( src_0_begin , src_0_end ); const isize src_1_size = std :: distance ( src_1_begin , src_1_end ); // Trivial merge edge cases. // if ( src_0_begin == src_0_end ) { return parallel_copy ( context , src_1_begin , src_1_end , dst_begin , // /*min_task_size=*/ TaskSize { 0 }, /*max_tasks=*/ TaskCount { 1 }); } BATT_CHECK_LT ( src_0_begin , src_0_end ); if ( src_1_begin == src_1_end ) { return parallel_copy ( context , src_0_begin , src_0_end , dst_begin , // /*min_task_size=*/ TaskSize { 0 }, /*max_tasks=*/ TaskCount { 1 }); } BATT_CHECK_LT ( src_1_begin , src_1_end ); // Sequential merge base case. // if ( std :: is_same_v < Phase , ThirdPhase > || src_0_size + src_1_size <= ( isize ) min_task_size ) { std :: merge ( src_0_begin , src_0_end , src_1_begin , src_1_end , dst_begin , compare ); return ; } // General case: break up the work and do it in parallel. // auto fixed_begin = Phase :: fixed_iter ( src_0_begin , src_1_begin ); auto fixed_end = Phase :: fixed_iter ( src_0_end , src_1_end ); auto search_begin = Phase :: search_iter ( src_0_begin , src_1_begin ); auto search_end = Phase :: search_iter ( src_0_end , src_1_end ); parallel_merge_fanout ( context , // fixed_begin , fixed_end , // fixed_begin , fixed_end , // search_begin , search_end , // dst_begin , // compare , // min_task_size , // max_tasks , // phase ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , // Fixed fixed_begin , Fixed fixed_end , // Fixed fixed_part_begin , Fixed fixed_part_end , // Search search_begin , Search search_end , // Dst dst_begin , // Compare && compare , // usize min_task_size , // usize max_tasks , // batt :: StaticType < Phase > ) { const usize max_tasks_per_phase = ( max_tasks + 1 ) / 2 ; isize fixed_part_size = std :: distance ( fixed_part_begin , fixed_part_end ); const isize target_size = std :: max (( fixed_part_size + max_tasks_per_phase - 1 ) / max_tasks_per_phase , ( min_task_size + 1 ) / 2 ); while ( fixed_part_begin != fixed_part_end ) { isize shard_size = std :: min ( target_size , fixed_part_size ); BATT_CHECK_GT ( shard_size , 0 ); // Set up the extents of the next task's shard. `shard_size` may need to be increased if the // initial shard end estimate cuts into the middle of an equivalence group. // const Fixed fixed_shard_begin = fixed_part_begin ; Fixed fixed_shard_back = std :: next ( fixed_shard_begin , shard_size - 1 ); Fixed fixed_shard_end = std :: next ( fixed_shard_back ); // Advance `fixed_shard_end` to include the entire equivalence group at the end of the fixed // shard. // TODO [tastolfi 2021-09-02] use std::upper_bound here? // while ( fixed_shard_end != fixed_part_end && ! compare ( * fixed_shard_back , * fixed_shard_end )) { BATT_CHECK_LT ( shard_size , fixed_part_size ); fixed_shard_back = fixed_shard_end ; ++ fixed_shard_end ; ++ shard_size ; } // MUST be after we advance `fixed_shard_end` above. // const bool is_first = ( fixed_shard_begin == fixed_begin ); const bool is_last = ( fixed_shard_end == fixed_end ); // Capture the shard variables. // auto work_fn = [ & context , // fixed_shard_begin , fixed_shard_end , // search_begin , search_end , // dst_begin , compare , is_first , is_last , // min_task_size , max_tasks ] { auto search_shard_begin = [ & ] { if ( is_first ) { return search_begin ; } return std :: lower_bound ( search_begin , search_end , * fixed_shard_begin , compare ); }(); auto search_shard_end = [ & ] { if ( is_last ) { return search_end ; } BATT_CHECK_LE ( search_shard_begin , search_end ); return std :: lower_bound ( search_shard_begin , search_end , * fixed_shard_end , compare ); }(); auto src_0_shard_begin = Phase :: src_0_iter ( fixed_shard_begin , search_shard_begin ); auto src_0_shard_end = Phase :: src_0_iter ( fixed_shard_end , search_shard_end ); BATT_CHECK_LE ( src_0_shard_begin , src_0_shard_end ); auto src_1_shard_begin = Phase :: src_1_iter ( fixed_shard_begin , search_shard_begin ); auto src_1_shard_end = Phase :: src_1_iter ( fixed_shard_end , search_shard_end ); BATT_CHECK_LE ( src_1_shard_begin , src_1_shard_end ); auto dst_shard_begin = std :: next ( dst_begin , std :: distance ( search_begin , search_shard_begin )); parallel_merge_impl ( context , // src_0_shard_begin , src_0_shard_end , // src_1_shard_begin , src_1_shard_end , // dst_shard_begin , // compare , // min_task_size , // max_tasks , // batt :: StaticType < typename Phase :: NextPhase > {}); }; if ( fixed_shard_end != fixed_part_end ) { context . async_run ( work_fn ); } else { work_fn (); } fixed_part_begin = fixed_shard_end ; std :: advance ( dst_begin , shard_size ); fixed_part_size -= shard_size ; } } } // namespace detail //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkerPool & worker_pool , // Src0 src_0_begin , Src0 src_0_end , // Src1 src_1_begin , Src1 src_1_end , // Dst dst_begin , // Compare && compare , // usize min_task_size = 1400 , // usize max_tasks = std :: thread :: hardware_concurrency () / 2 // ) { ScopedWorkContext context { worker_pool }; detail :: parallel_merge_impl ( context , // src_0_begin , src_0_end , // src_1_begin , src_1_end , // dst_begin , // BATT_FORWARD ( compare ), // min_task_size , // max_tasks , // batt :: StaticType < detail :: FirstPhase > {}); } template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkContext & context , // Src0 src_0_begin , Src0 src_0_end , // Src1 src_1_begin , Src1 src_1_end , // Dst dst_begin , // Compare && compare , // usize min_task_size = 1400 , // usize max_tasks = std :: thread :: hardware_concurrency () / 2 // ) { detail :: parallel_merge_impl ( context , // src_0_begin , src_0_end , // src_1_begin , src_1_end , // dst_begin , // BATT_FORWARD ( compare ), // min_task_size , // max_tasks , // batt :: StaticType < detail :: FirstPhase > {}); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_MERGE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo/parallel_merge.hpp"},{"location":"_autogen/Files/parallel__merge_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/parallel__merge_8hpp/#classes","text":"Name struct batt::detail::FirstPhase struct batt::detail::SecondPhase struct batt::detail::ThirdPhase","title":"Classes"},{"location":"_autogen/Files/parallel__merge_8hpp/#defines","text":"Name BATTERIES_ALGO_PARALLEL_MERGE_HPP","title":"Defines"},{"location":"_autogen/Files/parallel__merge_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parallel__merge_8hpp/#batteries_algo_parallel_merge_hpp","text":"1 #define BATTERIES_ALGO_PARALLEL_MERGE_HPP()","title":"BATTERIES_ALGO_PARALLEL_MERGE_HPP"},{"location":"_autogen/Files/parallel__merge_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_MERGE_HPP #define BATTERIES_ALGO_PARALLEL_MERGE_HPP #include <batteries/algo/parallel_copy.hpp> #include <batteries/async/work_context.hpp> #include <batteries/int_types.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // namespace detail { struct FirstPhase ; struct SecondPhase ; struct ThirdPhase ; struct FirstPhase { static const char * name () { return \"FirstPhase\" ; } using NextPhase = SecondPhase ; template < typename Src0 , typename Src1 > static const Src0 & fixed_iter ( const Src0 & src_0 , const Src1 & /*src_1*/ ) { return src_0 ; } template < typename Src0 , typename Src1 > static const Src1 & search_iter ( const Src0 & /*src_0*/ , const Src1 & src_1 ) { return src_1 ; } template < typename Fixed , typename Search > static const Fixed & src_0_iter ( const Fixed & fixed , const Search & /*search*/ ) { return fixed ; } template < typename Fixed , typename Search > static const Search & src_1_iter ( const Fixed & /*fixed*/ , const Search & search ) { return search ; } }; struct SecondPhase { static const char * name () { return \"SecondPhase\" ; } using NextPhase = ThirdPhase ; template < typename Src0 , typename Src1 > static const Src1 & fixed_iter ( const Src0 & /*src_0*/ , const Src1 & src_1 ) { return src_1 ; } template < typename Src0 , typename Src1 > static const Src0 & search_iter ( const Src0 & src_0 , const Src1 & /*src_1*/ ) { return src_0 ; } template < typename Fixed , typename Search > static const Search & src_0_iter ( const Fixed & /*fixed*/ , const Search & search ) { return search ; } template < typename Fixed , typename Search > static const Fixed & src_1_iter ( const Fixed & fixed , const Search & /*search*/ ) { return fixed ; } }; struct ThirdPhase : SecondPhase { static const char * name () { return \"ThirdPhase\" ; } }; static constexpr isize kThreshold = 1400 ; static constexpr isize kMaxShards = 8 ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , // Fixed fixed_begin , Fixed fixed_end , // Search search_begin , Search search_end , // Dst dst_begin , // Compare && compare , // usize min_task_size , // usize max_tasks , // batt :: StaticType < Phase > ); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Src0 , typename Src1 , typename Dst , typename Compare , typename Phase > void parallel_merge_impl ( WorkContext & context , // Src0 src_0_begin , Src0 src_0_end , // Src1 src_1_begin , Src1 src_1_end , // Dst dst_begin , // Compare && compare , // usize min_task_size , // usize max_tasks , // batt :: StaticType < Phase > phase ) { const isize src_0_size = std :: distance ( src_0_begin , src_0_end ); const isize src_1_size = std :: distance ( src_1_begin , src_1_end ); // Trivial merge edge cases. // if ( src_0_begin == src_0_end ) { return parallel_copy ( context , src_1_begin , src_1_end , dst_begin , // /*min_task_size=*/ TaskSize { 0 }, /*max_tasks=*/ TaskCount { 1 }); } BATT_CHECK_LT ( src_0_begin , src_0_end ); if ( src_1_begin == src_1_end ) { return parallel_copy ( context , src_0_begin , src_0_end , dst_begin , // /*min_task_size=*/ TaskSize { 0 }, /*max_tasks=*/ TaskCount { 1 }); } BATT_CHECK_LT ( src_1_begin , src_1_end ); // Sequential merge base case. // if ( std :: is_same_v < Phase , ThirdPhase > || src_0_size + src_1_size <= ( isize ) min_task_size ) { std :: merge ( src_0_begin , src_0_end , src_1_begin , src_1_end , dst_begin , compare ); return ; } // General case: break up the work and do it in parallel. // auto fixed_begin = Phase :: fixed_iter ( src_0_begin , src_1_begin ); auto fixed_end = Phase :: fixed_iter ( src_0_end , src_1_end ); auto search_begin = Phase :: search_iter ( src_0_begin , src_1_begin ); auto search_end = Phase :: search_iter ( src_0_end , src_1_end ); parallel_merge_fanout ( context , // fixed_begin , fixed_end , // fixed_begin , fixed_end , // search_begin , search_end , // dst_begin , // compare , // min_task_size , // max_tasks , // phase ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , // Fixed fixed_begin , Fixed fixed_end , // Fixed fixed_part_begin , Fixed fixed_part_end , // Search search_begin , Search search_end , // Dst dst_begin , // Compare && compare , // usize min_task_size , // usize max_tasks , // batt :: StaticType < Phase > ) { const usize max_tasks_per_phase = ( max_tasks + 1 ) / 2 ; isize fixed_part_size = std :: distance ( fixed_part_begin , fixed_part_end ); const isize target_size = std :: max (( fixed_part_size + max_tasks_per_phase - 1 ) / max_tasks_per_phase , ( min_task_size + 1 ) / 2 ); while ( fixed_part_begin != fixed_part_end ) { isize shard_size = std :: min ( target_size , fixed_part_size ); BATT_CHECK_GT ( shard_size , 0 ); // Set up the extents of the next task's shard. `shard_size` may need to be increased if the // initial shard end estimate cuts into the middle of an equivalence group. // const Fixed fixed_shard_begin = fixed_part_begin ; Fixed fixed_shard_back = std :: next ( fixed_shard_begin , shard_size - 1 ); Fixed fixed_shard_end = std :: next ( fixed_shard_back ); // Advance `fixed_shard_end` to include the entire equivalence group at the end of the fixed // shard. // TODO [tastolfi 2021-09-02] use std::upper_bound here? // while ( fixed_shard_end != fixed_part_end && ! compare ( * fixed_shard_back , * fixed_shard_end )) { BATT_CHECK_LT ( shard_size , fixed_part_size ); fixed_shard_back = fixed_shard_end ; ++ fixed_shard_end ; ++ shard_size ; } // MUST be after we advance `fixed_shard_end` above. // const bool is_first = ( fixed_shard_begin == fixed_begin ); const bool is_last = ( fixed_shard_end == fixed_end ); // Capture the shard variables. // auto work_fn = [ & context , // fixed_shard_begin , fixed_shard_end , // search_begin , search_end , // dst_begin , compare , is_first , is_last , // min_task_size , max_tasks ] { auto search_shard_begin = [ & ] { if ( is_first ) { return search_begin ; } return std :: lower_bound ( search_begin , search_end , * fixed_shard_begin , compare ); }(); auto search_shard_end = [ & ] { if ( is_last ) { return search_end ; } BATT_CHECK_LE ( search_shard_begin , search_end ); return std :: lower_bound ( search_shard_begin , search_end , * fixed_shard_end , compare ); }(); auto src_0_shard_begin = Phase :: src_0_iter ( fixed_shard_begin , search_shard_begin ); auto src_0_shard_end = Phase :: src_0_iter ( fixed_shard_end , search_shard_end ); BATT_CHECK_LE ( src_0_shard_begin , src_0_shard_end ); auto src_1_shard_begin = Phase :: src_1_iter ( fixed_shard_begin , search_shard_begin ); auto src_1_shard_end = Phase :: src_1_iter ( fixed_shard_end , search_shard_end ); BATT_CHECK_LE ( src_1_shard_begin , src_1_shard_end ); auto dst_shard_begin = std :: next ( dst_begin , std :: distance ( search_begin , search_shard_begin )); parallel_merge_impl ( context , // src_0_shard_begin , src_0_shard_end , // src_1_shard_begin , src_1_shard_end , // dst_shard_begin , // compare , // min_task_size , // max_tasks , // batt :: StaticType < typename Phase :: NextPhase > {}); }; if ( fixed_shard_end != fixed_part_end ) { context . async_run ( work_fn ); } else { work_fn (); } fixed_part_begin = fixed_shard_end ; std :: advance ( dst_begin , shard_size ); fixed_part_size -= shard_size ; } } } // namespace detail //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkerPool & worker_pool , // Src0 src_0_begin , Src0 src_0_end , // Src1 src_1_begin , Src1 src_1_end , // Dst dst_begin , // Compare && compare , // usize min_task_size = 1400 , // usize max_tasks = std :: thread :: hardware_concurrency () / 2 // ) { ScopedWorkContext context { worker_pool }; detail :: parallel_merge_impl ( context , // src_0_begin , src_0_end , // src_1_begin , src_1_end , // dst_begin , // BATT_FORWARD ( compare ), // min_task_size , // max_tasks , // batt :: StaticType < detail :: FirstPhase > {}); } template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkContext & context , // Src0 src_0_begin , Src0 src_0_end , // Src1 src_1_begin , Src1 src_1_end , // Dst dst_begin , // Compare && compare , // usize min_task_size = 1400 , // usize max_tasks = std :: thread :: hardware_concurrency () / 2 // ) { detail :: parallel_merge_impl ( context , // src_0_begin , src_0_end , // src_1_begin , src_1_end , // dst_begin , // BATT_FORWARD ( compare ), // min_task_size , // max_tasks , // batt :: StaticType < detail :: FirstPhase > {}); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_MERGE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/","text":"batteries/state_machine_model/parallel_model_check_state.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::detail::ModelCheckShardMetrics class batt::detail::ParallelModelCheckState Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP #define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP #include <batteries/config.hpp> // #include <batteries/async/queue.hpp> #include <batteries/async/watch.hpp> #include <batteries/assert.hpp> #include <batteries/cpu_align.hpp> #include <batteries/int_types.hpp> #include <memory> #include <ostream> #include <vector> namespace batt { namespace detail { struct ModelCheckShardMetrics { i64 stall_count = 0 ; i64 flush_count = 0 ; i64 send_count = 0 ; i64 recv_count = 0 ; }; inline std :: ostream & operator << ( std :: ostream & out , const ModelCheckShardMetrics & t ) { return out << \"ShardMetrics{\" // << \".stall=\" << t . stall_count // << \", .flush=\" << t . flush_count // << \", .send=\" << t . send_count // << \", .recv=\" << t . recv_count // << \", .stall_rate=\" << double ( t . stall_count + 1 ) / double ( t . recv_count + 1 ) // << \",}\" ; } template < typename Branch > class ParallelModelCheckState { public : static constexpr u64 kStallEpochUnit = u64 { 1 } << 32 ; static constexpr u64 kStallCountMask = kStallEpochUnit - 1 ; static constexpr u64 kStallEpochMask = ~ kStallCountMask ; using ShardMetrics = ModelCheckShardMetrics ; explicit ParallelModelCheckState ( usize n_shards ) : shard_count { n_shards } , stalled ( this -> shard_count ) , recv_queues ( this -> shard_count ) , send_queues ( this -> shard_count ) , shard_metrics ( this -> shard_count ) , local_consume_count ( this -> shard_count ) { BATT_CHECK_EQ ( this -> stalled . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> local_consume_count . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> recv_queues . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> send_queues . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> shard_metrics . size (), this -> shard_count ); for ( std :: unique_ptr < std :: atomic < bool > [] >& stalled_per_other : this -> stalled ) { stalled_per_other . reset ( new std :: atomic < bool > [ this -> shard_count ]); for ( usize i = 0 ; i < this -> shard_count ; ++ i ) { stalled_per_other [ i ]. store ( false ); } } for ( auto & recv_queues_per_dst : this -> recv_queues ) { recv_queues_per_dst = std :: make_unique < Queue < std :: vector < Branch >>> (); } for ( CpuCacheLineIsolated < std :: vector < std :: vector < Branch >>>& // send_queues_per_src : this -> send_queues ) { send_queues_per_src -> resize ( this -> shard_count ); } for ( auto & count : this -> local_consume_count ) { * count = 0 ; } } usize find_shard ( const Branch & branch ) const { const usize branch_hash = hash ( branch ); const usize branch_shard = branch_hash / this -> hash_space_per_shard ; return branch_shard ; } void send ( usize src_i , usize dst_i , Branch && branch ) { std :: vector < std :: vector < Branch >>& src_send_queues = * this -> send_queues [ src_i ]; std :: vector < Branch >& src_dst_send_queue = src_send_queues [ dst_i ]; src_dst_send_queue . emplace_back ( std :: move ( branch )); this -> metrics ( src_i ). send_count += 1 ; if ( this -> stalled [ src_i ][ dst_i ]. load ()) { this -> queue_push ( dst_i , & src_dst_send_queue ); } } void flush_all ( usize src_i ) { std :: vector < std :: vector < Branch >>& src_send_queues = * this -> send_queues [ src_i ]; usize dst_i = 0 ; for ( std :: vector < Branch >& src_dst_send_queue : src_send_queues ) { const auto advance_dst_i = finally ([ & dst_i ] { dst_i += 1 ; }); if ( src_dst_send_queue . empty ()) { continue ; } this -> metrics ( src_i ). flush_count += 1 ; this -> queue_push ( dst_i , & src_dst_send_queue ); } } void queue_push ( usize dst_i , std :: vector < Branch >* branch ) { std :: vector < Branch > to_send ; std :: swap ( to_send , * branch ); this -> total_pending_count -> fetch_add ( 1 ); const Optional < i64 > success = this -> recv_queues [ dst_i ] -> push ( std :: move ( to_send )); BATT_CHECK ( success ) << BATT_INSPECT ( dst_i ) << BATT_INSPECT ( this -> shard_count ); this -> queue_push_count . fetch_add ( 1 ); } StatusOr < usize > recv ( usize shard_i , std :: deque < Branch >& local_queue ) { Queue < std :: vector < Branch >>& src_queue = * this -> recv_queues [ shard_i ]; this -> metrics ( shard_i ). recv_count += 1 ; const auto transfer_batch = [ this , & local_queue , shard_i ]( auto & maybe_next_batch ) { std :: vector < Branch >& next_batch = * maybe_next_batch ; this -> queue_pop_count . fetch_add ( 1 ); usize count = next_batch . size (); local_queue . insert ( local_queue . end (), // std :: make_move_iterator ( next_batch . begin ()), // std :: make_move_iterator ( next_batch . end ())); * this -> local_consume_count [ shard_i ] += 1 ; return count ; }; // Try to pop branches without stalling. // { Optional < std :: vector < Branch >> next_batch = src_queue . try_pop_next (); if ( next_batch ) { return transfer_batch ( next_batch ); } } this -> metrics ( shard_i ). stall_count += 1 ; // Set \"stalled\" flags for this shard so that other shards know to send queued batches ASAP. // for ( usize other_i = 0 ; other_i < shard_count ; ++ other_i ) { this -> stalled [ other_i ][ shard_i ]. store ( true ); } const auto reset_stall_flags = finally ([ & ] { // Clear \"stalled\" flags, now that we have a some branches to process, or the entire job is // done. // for ( usize other_i = 0 ; other_i < shard_count ; ++ other_i ) { this -> stalled [ other_i ][ shard_i ]. store ( false ); } }); // Because we are about to go to put the current task to sleep awaiting the next batch, flush all // outgoing batches so no other shards are blocked on `shard_i`. // this -> flush_all ( shard_i ); // Now that we've flushed all outgoing branches, it is safe to ack the read message timestamp // upper bound for this shard. // i64 n_to_consume = 0 ; std :: swap ( n_to_consume , * this -> local_consume_count [ shard_i ]); const i64 old_value = this -> total_pending_count -> fetch_sub ( n_to_consume ); // Check for deadlock; if all shards are stalled, then the branch-state-space has been fully explored // and we are done! // if ( old_value - n_to_consume == 0 ) { this -> close_all ( shard_i ); // // More than one shard task may call close_all; this is fine! } StatusOr < std :: vector < Branch >> next_batch = src_queue . await_next (); BATT_REQUIRE_OK ( next_batch ); return transfer_batch ( next_batch ); } void close_all ( usize shard_i , bool allow_pending = false ) { for ( usize dst_i = 0 ; dst_i < this -> recv_queues . size (); ++ dst_i ) { const auto & p_queue = this -> recv_queues [ dst_i ]; bool queue_is_empty = p_queue -> empty (); if ( ! queue_is_empty ) { Task :: sleep ( boost :: posix_time :: milliseconds ( 1200 )); queue_is_empty = p_queue -> empty (); } BATT_CHECK ( allow_pending || queue_is_empty ) << BATT_INSPECT ( shard_i ) << BATT_INSPECT ( dst_i ) << BATT_INSPECT ( queue_is_empty ) << BATT_INSPECT ( p_queue -> empty ()) << BATT_INSPECT ( allow_pending ) << BATT_INSPECT ( p_queue -> size ()) << BATT_INSPECT ( this -> shard_count ); p_queue -> close (); } } void finished ( usize shard_i ) { this -> flush_all ( shard_i ); this -> recv_queues [ shard_i ] -> close (); this -> queue_pop_count . fetch_add ( this -> recv_queues [ shard_i ] -> drain ()); } ShardMetrics & metrics ( usize shard_i ) { return * this -> shard_metrics [ shard_i ]; } Status wait_for_other_shards () { this -> barrier_ . fetch_sub ( 1 ); return this -> barrier_ . await_equal ( 0 ); } const usize shard_count ; const usize hash_space_per_shard = std :: numeric_limits < usize >:: max () / this -> shard_count ; Watch < usize > barrier_ { this -> shard_count }; std :: atomic < i64 > queue_push_count { 0 }; std :: atomic < i64 > queue_pop_count { 0 }; std :: vector < std :: unique_ptr < std :: atomic < bool > [] >> stalled ; std :: vector < std :: unique_ptr < Queue < std :: vector < Branch >>>> recv_queues ; std :: vector < CpuCacheLineIsolated < std :: vector < std :: vector < Branch >>>> send_queues ; std :: vector < CpuCacheLineIsolated < ShardMetrics >> shard_metrics ; CpuCacheLineIsolated < std :: atomic < i64 >> total_pending_count { 0 }; std :: vector < CpuCacheLineIsolated < i64 >> local_consume_count ; }; } // namespace detail } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/parallel_model_check_state.hpp"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#classes","text":"Name struct batt::detail::ModelCheckShardMetrics class batt::detail::ParallelModelCheckState","title":"Classes"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP","title":"Defines"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#batteries_state_machine_model_parallel_model_check_state_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP #define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP #include <batteries/config.hpp> // #include <batteries/async/queue.hpp> #include <batteries/async/watch.hpp> #include <batteries/assert.hpp> #include <batteries/cpu_align.hpp> #include <batteries/int_types.hpp> #include <memory> #include <ostream> #include <vector> namespace batt { namespace detail { struct ModelCheckShardMetrics { i64 stall_count = 0 ; i64 flush_count = 0 ; i64 send_count = 0 ; i64 recv_count = 0 ; }; inline std :: ostream & operator << ( std :: ostream & out , const ModelCheckShardMetrics & t ) { return out << \"ShardMetrics{\" // << \".stall=\" << t . stall_count // << \", .flush=\" << t . flush_count // << \", .send=\" << t . send_count // << \", .recv=\" << t . recv_count // << \", .stall_rate=\" << double ( t . stall_count + 1 ) / double ( t . recv_count + 1 ) // << \",}\" ; } template < typename Branch > class ParallelModelCheckState { public : static constexpr u64 kStallEpochUnit = u64 { 1 } << 32 ; static constexpr u64 kStallCountMask = kStallEpochUnit - 1 ; static constexpr u64 kStallEpochMask = ~ kStallCountMask ; using ShardMetrics = ModelCheckShardMetrics ; explicit ParallelModelCheckState ( usize n_shards ) : shard_count { n_shards } , stalled ( this -> shard_count ) , recv_queues ( this -> shard_count ) , send_queues ( this -> shard_count ) , shard_metrics ( this -> shard_count ) , local_consume_count ( this -> shard_count ) { BATT_CHECK_EQ ( this -> stalled . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> local_consume_count . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> recv_queues . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> send_queues . size (), this -> shard_count ); BATT_CHECK_EQ ( this -> shard_metrics . size (), this -> shard_count ); for ( std :: unique_ptr < std :: atomic < bool > [] >& stalled_per_other : this -> stalled ) { stalled_per_other . reset ( new std :: atomic < bool > [ this -> shard_count ]); for ( usize i = 0 ; i < this -> shard_count ; ++ i ) { stalled_per_other [ i ]. store ( false ); } } for ( auto & recv_queues_per_dst : this -> recv_queues ) { recv_queues_per_dst = std :: make_unique < Queue < std :: vector < Branch >>> (); } for ( CpuCacheLineIsolated < std :: vector < std :: vector < Branch >>>& // send_queues_per_src : this -> send_queues ) { send_queues_per_src -> resize ( this -> shard_count ); } for ( auto & count : this -> local_consume_count ) { * count = 0 ; } } usize find_shard ( const Branch & branch ) const { const usize branch_hash = hash ( branch ); const usize branch_shard = branch_hash / this -> hash_space_per_shard ; return branch_shard ; } void send ( usize src_i , usize dst_i , Branch && branch ) { std :: vector < std :: vector < Branch >>& src_send_queues = * this -> send_queues [ src_i ]; std :: vector < Branch >& src_dst_send_queue = src_send_queues [ dst_i ]; src_dst_send_queue . emplace_back ( std :: move ( branch )); this -> metrics ( src_i ). send_count += 1 ; if ( this -> stalled [ src_i ][ dst_i ]. load ()) { this -> queue_push ( dst_i , & src_dst_send_queue ); } } void flush_all ( usize src_i ) { std :: vector < std :: vector < Branch >>& src_send_queues = * this -> send_queues [ src_i ]; usize dst_i = 0 ; for ( std :: vector < Branch >& src_dst_send_queue : src_send_queues ) { const auto advance_dst_i = finally ([ & dst_i ] { dst_i += 1 ; }); if ( src_dst_send_queue . empty ()) { continue ; } this -> metrics ( src_i ). flush_count += 1 ; this -> queue_push ( dst_i , & src_dst_send_queue ); } } void queue_push ( usize dst_i , std :: vector < Branch >* branch ) { std :: vector < Branch > to_send ; std :: swap ( to_send , * branch ); this -> total_pending_count -> fetch_add ( 1 ); const Optional < i64 > success = this -> recv_queues [ dst_i ] -> push ( std :: move ( to_send )); BATT_CHECK ( success ) << BATT_INSPECT ( dst_i ) << BATT_INSPECT ( this -> shard_count ); this -> queue_push_count . fetch_add ( 1 ); } StatusOr < usize > recv ( usize shard_i , std :: deque < Branch >& local_queue ) { Queue < std :: vector < Branch >>& src_queue = * this -> recv_queues [ shard_i ]; this -> metrics ( shard_i ). recv_count += 1 ; const auto transfer_batch = [ this , & local_queue , shard_i ]( auto & maybe_next_batch ) { std :: vector < Branch >& next_batch = * maybe_next_batch ; this -> queue_pop_count . fetch_add ( 1 ); usize count = next_batch . size (); local_queue . insert ( local_queue . end (), // std :: make_move_iterator ( next_batch . begin ()), // std :: make_move_iterator ( next_batch . end ())); * this -> local_consume_count [ shard_i ] += 1 ; return count ; }; // Try to pop branches without stalling. // { Optional < std :: vector < Branch >> next_batch = src_queue . try_pop_next (); if ( next_batch ) { return transfer_batch ( next_batch ); } } this -> metrics ( shard_i ). stall_count += 1 ; // Set \"stalled\" flags for this shard so that other shards know to send queued batches ASAP. // for ( usize other_i = 0 ; other_i < shard_count ; ++ other_i ) { this -> stalled [ other_i ][ shard_i ]. store ( true ); } const auto reset_stall_flags = finally ([ & ] { // Clear \"stalled\" flags, now that we have a some branches to process, or the entire job is // done. // for ( usize other_i = 0 ; other_i < shard_count ; ++ other_i ) { this -> stalled [ other_i ][ shard_i ]. store ( false ); } }); // Because we are about to go to put the current task to sleep awaiting the next batch, flush all // outgoing batches so no other shards are blocked on `shard_i`. // this -> flush_all ( shard_i ); // Now that we've flushed all outgoing branches, it is safe to ack the read message timestamp // upper bound for this shard. // i64 n_to_consume = 0 ; std :: swap ( n_to_consume , * this -> local_consume_count [ shard_i ]); const i64 old_value = this -> total_pending_count -> fetch_sub ( n_to_consume ); // Check for deadlock; if all shards are stalled, then the branch-state-space has been fully explored // and we are done! // if ( old_value - n_to_consume == 0 ) { this -> close_all ( shard_i ); // // More than one shard task may call close_all; this is fine! } StatusOr < std :: vector < Branch >> next_batch = src_queue . await_next (); BATT_REQUIRE_OK ( next_batch ); return transfer_batch ( next_batch ); } void close_all ( usize shard_i , bool allow_pending = false ) { for ( usize dst_i = 0 ; dst_i < this -> recv_queues . size (); ++ dst_i ) { const auto & p_queue = this -> recv_queues [ dst_i ]; bool queue_is_empty = p_queue -> empty (); if ( ! queue_is_empty ) { Task :: sleep ( boost :: posix_time :: milliseconds ( 1200 )); queue_is_empty = p_queue -> empty (); } BATT_CHECK ( allow_pending || queue_is_empty ) << BATT_INSPECT ( shard_i ) << BATT_INSPECT ( dst_i ) << BATT_INSPECT ( queue_is_empty ) << BATT_INSPECT ( p_queue -> empty ()) << BATT_INSPECT ( allow_pending ) << BATT_INSPECT ( p_queue -> size ()) << BATT_INSPECT ( this -> shard_count ); p_queue -> close (); } } void finished ( usize shard_i ) { this -> flush_all ( shard_i ); this -> recv_queues [ shard_i ] -> close (); this -> queue_pop_count . fetch_add ( this -> recv_queues [ shard_i ] -> drain ()); } ShardMetrics & metrics ( usize shard_i ) { return * this -> shard_metrics [ shard_i ]; } Status wait_for_other_shards () { this -> barrier_ . fetch_sub ( 1 ); return this -> barrier_ . await_equal ( 0 ); } const usize shard_count ; const usize hash_space_per_shard = std :: numeric_limits < usize >:: max () / this -> shard_count ; Watch < usize > barrier_ { this -> shard_count }; std :: atomic < i64 > queue_push_count { 0 }; std :: atomic < i64 > queue_pop_count { 0 }; std :: vector < std :: unique_ptr < std :: atomic < bool > [] >> stalled ; std :: vector < std :: unique_ptr < Queue < std :: vector < Branch >>>> recv_queues ; std :: vector < CpuCacheLineIsolated < std :: vector < std :: vector < Branch >>>> send_queues ; std :: vector < CpuCacheLineIsolated < ShardMetrics >> shard_metrics ; CpuCacheLineIsolated < std :: atomic < i64 >> total_pending_count { 0 }; std :: vector < CpuCacheLineIsolated < i64 >> local_consume_count ; }; } // namespace detail } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parallel__running__total_8hpp/","text":"batteries/algo/parallel_running_total.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP \ud83d\udd17 1 #define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP #define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP #include <batteries/algo/running_total.hpp> #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/assert.hpp> #include <batteries/int_types.hpp> namespace batt { template < typename Iter , typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const Fn & fn , const WorkSliceParams & params ); template < typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const WorkSliceParams & params ); //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter , typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const Fn & fn , const WorkSliceParams & params ) { const WorkSlicePlan plan { params , first , last }; if ( plan . input_size == 0 ) { return RunningTotal {}; } RunningTotal running_total { PartsCount { plan . n_tasks }, PartSize { plan . task_size }}; running_total . set_size ( plan . input_size + 1u ); { ScopedWorkContext context { worker_pool }; slice_work ( context , plan , [ & running_total , & first , & fn , & plan ]( TaskIndex task_index , TaskOffset task_offset , TaskSize task_size ) { return [ & running_total , & fn , task_index , src_begin = std :: next ( first , task_offset ), task_size , & plan ] { auto src_end = std :: next ( src_begin , task_size ); auto dst = running_total . mutable_part ( task_index ); auto dst_iter = dst . begin (); usize part_total = 0 ; if ( task_index + 1 < plan . n_tasks ) { BATT_CHECK_EQ ( dst . size (), static_cast < usize > ( std :: distance ( src_begin , src_end )) + 1u ) << BATT_INSPECT ( task_index ) << BATT_INSPECT ( plan ); } BATT_CHECK_EQ ( * dst_iter , 0u ); ++ dst_iter ; std :: for_each ( src_begin , src_end , [ & ]( const auto & item ) { part_total += fn ( item ); * dst_iter = part_total ; ++ dst_iter ; }); // Fill to the end with the last value. // std :: fill ( dst_iter , dst . end (), part_total ); }; }); } // Finally, calculate the running total of part totals. // running_total . update_summary (); return running_total ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const WorkSliceParams & params ) { return parallel_running_total ( worker_pool , first , last , /*fn=*/ []( auto && value ) -> decltype ( auto ) { return BATT_FORWARD ( value ); }, params ); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo/parallel_running_total.hpp"},{"location":"_autogen/Files/parallel__running__total_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/parallel__running__total_8hpp/#defines","text":"Name BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP","title":"Defines"},{"location":"_autogen/Files/parallel__running__total_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parallel__running__total_8hpp/#batteries_algo_parallel_running_total_hpp","text":"1 #define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP()","title":"BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP"},{"location":"_autogen/Files/parallel__running__total_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP #define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP #include <batteries/algo/running_total.hpp> #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/assert.hpp> #include <batteries/int_types.hpp> namespace batt { template < typename Iter , typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const Fn & fn , const WorkSliceParams & params ); template < typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const WorkSliceParams & params ); //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter , typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const Fn & fn , const WorkSliceParams & params ) { const WorkSlicePlan plan { params , first , last }; if ( plan . input_size == 0 ) { return RunningTotal {}; } RunningTotal running_total { PartsCount { plan . n_tasks }, PartSize { plan . task_size }}; running_total . set_size ( plan . input_size + 1u ); { ScopedWorkContext context { worker_pool }; slice_work ( context , plan , [ & running_total , & first , & fn , & plan ]( TaskIndex task_index , TaskOffset task_offset , TaskSize task_size ) { return [ & running_total , & fn , task_index , src_begin = std :: next ( first , task_offset ), task_size , & plan ] { auto src_end = std :: next ( src_begin , task_size ); auto dst = running_total . mutable_part ( task_index ); auto dst_iter = dst . begin (); usize part_total = 0 ; if ( task_index + 1 < plan . n_tasks ) { BATT_CHECK_EQ ( dst . size (), static_cast < usize > ( std :: distance ( src_begin , src_end )) + 1u ) << BATT_INSPECT ( task_index ) << BATT_INSPECT ( plan ); } BATT_CHECK_EQ ( * dst_iter , 0u ); ++ dst_iter ; std :: for_each ( src_begin , src_end , [ & ]( const auto & item ) { part_total += fn ( item ); * dst_iter = part_total ; ++ dst_iter ; }); // Fill to the end with the last value. // std :: fill ( dst_iter , dst . end (), part_total ); }; }); } // Finally, calculate the running total of part totals. // running_total . update_summary (); return running_total ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const WorkSliceParams & params ) { return parallel_running_total ( worker_pool , first , last , /*fn=*/ []( auto && value ) -> decltype ( auto ) { return BATT_FORWARD ( value ); }, params ); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parallel__transform_8hpp/","text":"batteries/algo/parallel_transform.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP Macro Documentation \ud83d\udd17 BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP \ud83d\udd17 1 #define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP #define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <iterator> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Src , typename Dst , typename TransformFn > void parallel_transform ( WorkContext & work_context , // Src src_begin , Src src_end , // Dst dst_begin , // const TransformFn & transform_fn , // TaskSize min_task_size , // TaskCount max_tasks ) { if ( max_tasks == 1 ) { std :: transform ( src_begin , src_end , dst_begin , transform_fn ); return ; } const WorkSlicePlan plan { WorkSliceParams { min_task_size , max_tasks }, src_begin , src_end }; slice_work ( work_context , plan , /*gen_work_fn=*/ [ & ]( usize /*task_index*/ , isize task_offset , isize task_size ) { return [ src_begin , dst_begin , task_offset , task_size , transform_fn ] { auto task_src_begin = std :: next ( src_begin , task_offset ); auto task_src_end = std :: next ( task_src_begin , task_size ); auto task_dst_begin = std :: next ( dst_begin , task_offset ); std :: transform ( task_src_begin , task_src_end , task_dst_begin , transform_fn ); }; }); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo/parallel_transform.hpp"},{"location":"_autogen/Files/parallel__transform_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/parallel__transform_8hpp/#defines","text":"Name BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP","title":"Defines"},{"location":"_autogen/Files/parallel__transform_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parallel__transform_8hpp/#batteries_algo_parallel_transform_hpp","text":"1 #define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP()","title":"BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP"},{"location":"_autogen/Files/parallel__transform_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP #define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP #include <batteries/async/slice_work.hpp> #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <iterator> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename Src , typename Dst , typename TransformFn > void parallel_transform ( WorkContext & work_context , // Src src_begin , Src src_end , // Dst dst_begin , // const TransformFn & transform_fn , // TaskSize min_task_size , // TaskCount max_tasks ) { if ( max_tasks == 1 ) { std :: transform ( src_begin , src_end , dst_begin , transform_fn ); return ; } const WorkSlicePlan plan { WorkSliceParams { min_task_size , max_tasks }, src_begin , src_end }; slice_work ( work_context , plan , /*gen_work_fn=*/ [ & ]( usize /*task_index*/ , isize task_offset , isize task_size ) { return [ src_begin , dst_begin , task_offset , task_size , transform_fn ] { auto task_src_begin = std :: next ( src_begin , task_offset ); auto task_src_end = std :: next ( task_src_begin , task_size ); auto task_dst_begin = std :: next ( dst_begin , task_offset ); std :: transform ( task_src_begin , task_src_end , task_dst_begin , transform_fn ); }; }); } } // namespace batt #endif // BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parser_8hpp/","text":"batteries/pico_http/parser.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATTERIES_PICO_HTTP_PARSER_HPP Macro Documentation \ud83d\udd17 BATTERIES_PICO_HTTP_PARSER_HPP \ud83d\udd17 1 #define BATTERIES_PICO_HTTP_PARSER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 #pragma once #ifndef BATTERIES_PICO_HTTP_PARSER_HPP #define BATTERIES_PICO_HTTP_PARSER_HPP #include <batteries/config.hpp> #include <batteries/pico_http/parser_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/pico_http/parser_impl.hpp> #endif // BATT_HEADER_ONLY #endif // BATTERIES_PICO_HTTP_PARSER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/pico_http/parser.hpp"},{"location":"_autogen/Files/parser_8hpp/#defines","text":"Name BATTERIES_PICO_HTTP_PARSER_HPP","title":"Defines"},{"location":"_autogen/Files/parser_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parser_8hpp/#batteries_pico_http_parser_hpp","text":"1 #define BATTERIES_PICO_HTTP_PARSER_HPP()","title":"BATTERIES_PICO_HTTP_PARSER_HPP"},{"location":"_autogen/Files/parser_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 #pragma once #ifndef BATTERIES_PICO_HTTP_PARSER_HPP #define BATTERIES_PICO_HTTP_PARSER_HPP #include <batteries/config.hpp> #include <batteries/pico_http/parser_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/pico_http/parser_impl.hpp> #endif // BATT_HEADER_ONLY #endif // BATTERIES_PICO_HTTP_PARSER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parser__decl_8hpp/","text":"batteries/pico_http/parser_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name pico_http Classes \ud83d\udd17 Name struct pico_http::MessageHeader struct pico_http::Request struct pico_http::Response struct pico_http::ChunkedDecoder struct pico_http::DecodeResult Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 /* * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */ #ifndef BATTERIES_PICO_HTTP_PARSER_DECL_HPP #define BATTERIES_PICO_HTTP_PARSER_DECL_HPP #include <batteries/config.hpp> // #include <batteries/buffer.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <string_view> #include <sys/types.h> #ifdef _MSC_VER #define ssize_t intptr_t #endif namespace pico_http { using namespace batt :: int_types ; /* contains name and value of a header (name == NULL if is a continuing line * of a multiline header */ struct MessageHeader { std :: string_view name ; std :: string_view value ; }; std :: ostream & operator << ( std :: ostream & out , const MessageHeader & t ); std :: ostream & operator << ( std :: ostream & out , const batt :: SmallVecBase < MessageHeader >& t ); constexpr usize kDefaultNumHeaders = 16 ; constexpr int kParseOk = 0 ; constexpr int kParseFailed = -1 ; constexpr int kParseIncomplete = -2 ; struct Request { std :: string_view method ; std :: string_view path ; int major_version ; int minor_version ; batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; /* returns number of bytes consumed if successful, kParseIncomplete if request is partial, * kParseFailed if failed */ int parse ( const char * buf , usize len , usize last_len = 0 ); // Convenience. // int parse ( const batt :: ConstBuffer & buf ) { return this -> parse ( static_cast < const char *> ( buf . data ()), buf . size ()); } }; std :: ostream & operator << ( std :: ostream & out , const Request & t ); struct Response { int major_version ; int minor_version ; int status ; std :: string_view message ; batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; /* returns number of bytes consumed if successful, kParseIncomplete if request is partial, * kParseFailed if failed */ int parse ( const char * buf , usize len , usize last_len = 0 ); // Convenience. // int parse ( const batt :: ConstBuffer & buf ) { return this -> parse ( static_cast < const char *> ( buf . data ()), buf . size ()); } }; std :: ostream & operator << ( std :: ostream & out , const Response & t ); /* returns number of bytes consumed if successful, kParseIncomplete if request is partial, * kParseFailed if failed */ int parse_headers ( const char * buf , usize len , batt :: SmallVecBase < MessageHeader >* headers , usize last_len = 0 ); /* should be zero-filled before start */ struct ChunkedDecoder { usize bytes_left_in_chunk ; /* number of bytes left in current chunk */ bool consume_trailer ; /* if trailing headers should be consumed */ i8 hex_count_ ; i8 state_ ; }; struct DecodeResult { bool done ; usize bytes_consumed ; }; /* the function rewrites the buffer given as (buf, bufsz) removing the chunked- * encoding headers. When the function returns without an error, bufsz is * updated to the length of the decoded data available. Applications should * repeatedly call the function while it returns kParseIncomplete (incomplete) every time * supplying newly arrived data. If the end of the chunked-encoded data is * found, the function returns a non-negative number indicating the number of * octets left undecoded, that starts from the offset returned by `*bufsz`. * Returns kParseFailed on error. */ batt :: StatusOr < DecodeResult > decode_chunked ( ChunkedDecoder * decoder , const batt :: ConstBuffer & input , batt :: SmallVecBase < batt :: ConstBuffer >* output ); /* returns if the chunked decoder is in middle of chunked data */ int decode_chunked_is_in_data ( ChunkedDecoder * decoder ); } // namespace pico_http #endif // BATTERIES_PICO_HTTP_PARSER_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/pico_http/parser_decl.hpp"},{"location":"_autogen/Files/parser__decl_8hpp/#namespaces","text":"Name pico_http","title":"Namespaces"},{"location":"_autogen/Files/parser__decl_8hpp/#classes","text":"Name struct pico_http::MessageHeader struct pico_http::Request struct pico_http::Response struct pico_http::ChunkedDecoder struct pico_http::DecodeResult","title":"Classes"},{"location":"_autogen/Files/parser__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 /* * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */ #ifndef BATTERIES_PICO_HTTP_PARSER_DECL_HPP #define BATTERIES_PICO_HTTP_PARSER_DECL_HPP #include <batteries/config.hpp> // #include <batteries/buffer.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <string_view> #include <sys/types.h> #ifdef _MSC_VER #define ssize_t intptr_t #endif namespace pico_http { using namespace batt :: int_types ; /* contains name and value of a header (name == NULL if is a continuing line * of a multiline header */ struct MessageHeader { std :: string_view name ; std :: string_view value ; }; std :: ostream & operator << ( std :: ostream & out , const MessageHeader & t ); std :: ostream & operator << ( std :: ostream & out , const batt :: SmallVecBase < MessageHeader >& t ); constexpr usize kDefaultNumHeaders = 16 ; constexpr int kParseOk = 0 ; constexpr int kParseFailed = -1 ; constexpr int kParseIncomplete = -2 ; struct Request { std :: string_view method ; std :: string_view path ; int major_version ; int minor_version ; batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; /* returns number of bytes consumed if successful, kParseIncomplete if request is partial, * kParseFailed if failed */ int parse ( const char * buf , usize len , usize last_len = 0 ); // Convenience. // int parse ( const batt :: ConstBuffer & buf ) { return this -> parse ( static_cast < const char *> ( buf . data ()), buf . size ()); } }; std :: ostream & operator << ( std :: ostream & out , const Request & t ); struct Response { int major_version ; int minor_version ; int status ; std :: string_view message ; batt :: SmallVec < MessageHeader , kDefaultNumHeaders > headers ; /* returns number of bytes consumed if successful, kParseIncomplete if request is partial, * kParseFailed if failed */ int parse ( const char * buf , usize len , usize last_len = 0 ); // Convenience. // int parse ( const batt :: ConstBuffer & buf ) { return this -> parse ( static_cast < const char *> ( buf . data ()), buf . size ()); } }; std :: ostream & operator << ( std :: ostream & out , const Response & t ); /* returns number of bytes consumed if successful, kParseIncomplete if request is partial, * kParseFailed if failed */ int parse_headers ( const char * buf , usize len , batt :: SmallVecBase < MessageHeader >* headers , usize last_len = 0 ); /* should be zero-filled before start */ struct ChunkedDecoder { usize bytes_left_in_chunk ; /* number of bytes left in current chunk */ bool consume_trailer ; /* if trailing headers should be consumed */ i8 hex_count_ ; i8 state_ ; }; struct DecodeResult { bool done ; usize bytes_consumed ; }; /* the function rewrites the buffer given as (buf, bufsz) removing the chunked- * encoding headers. When the function returns without an error, bufsz is * updated to the length of the decoded data available. Applications should * repeatedly call the function while it returns kParseIncomplete (incomplete) every time * supplying newly arrived data. If the end of the chunked-encoded data is * found, the function returns a non-negative number indicating the number of * octets left undecoded, that starts from the offset returned by `*bufsz`. * Returns kParseFailed on error. */ batt :: StatusOr < DecodeResult > decode_chunked ( ChunkedDecoder * decoder , const batt :: ConstBuffer & input , batt :: SmallVecBase < batt :: ConstBuffer >* output ); /* returns if the chunked decoder is in middle of chunked data */ int decode_chunked_is_in_data ( ChunkedDecoder * decoder ); } // namespace pico_http #endif // BATTERIES_PICO_HTTP_PARSER_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/parser__impl_8hpp/","text":"batteries/pico_http/parser_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name pico_http pico_http::detail Defines \ud83d\udd17 Name BATTERIES_PICO_HTTP_PARSER_IMPL_HPP BATT_PICO_HTTP_ALIGNED (n) BATT_PICO_HTTP_IS_PRINTABLE_ASCII (c) BATT_PICO_HTTP_CHECK_EOF () BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK (ch) BATT_PICO_HTTP_EXPECT_CHAR (ch) BATT_PICO_HTTP_ADVANCE_TOKEN (tok, toklen) BATT_PICO_HTTP_DOIT () BATT_PICO_HTTP_PARSE_INT (valp_, mul_) BATT_PICO_HTTP_PARSE_INT_3 (valp_) BATT_PICO_HTTP_PARSER_DUMP_CHUNKS Macro Documentation \ud83d\udd17 BATTERIES_PICO_HTTP_PARSER_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP() BATT_PICO_HTTP_ALIGNED \ud83d\udd17 1 #define BATT_PICO_HTTP_ALIGNED(n) BATT_PICO_HTTP_IS_PRINTABLE_ASCII \ud83d\udd17 1 #define BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c) BATT_PICO_HTTP_CHECK_EOF \ud83d\udd17 1 #define BATT_PICO_HTTP_CHECK_EOF() BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK \ud83d\udd17 1 #define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch) BATT_PICO_HTTP_EXPECT_CHAR \ud83d\udd17 1 #define BATT_PICO_HTTP_EXPECT_CHAR(ch) BATT_PICO_HTTP_ADVANCE_TOKEN \ud83d\udd17 1 #define BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen) BATT_PICO_HTTP_DOIT \ud83d\udd17 1 #define BATT_PICO_HTTP_DOIT() BATT_PICO_HTTP_PARSE_INT \ud83d\udd17 1 #define BATT_PICO_HTTP_PARSE_INT(valp_, mul_) BATT_PICO_HTTP_PARSE_INT_3 \ud83d\udd17 1 #define BATT_PICO_HTTP_PARSE_INT_3(valp_) BATT_PICO_HTTP_PARSER_DUMP_CHUNKS \ud83d\udd17 1 #define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 /* * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */ #pragma once #ifndef BATTERIES_PICO_HTTP_PARSER_IMPL_HPP #define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP #include <batteries/config.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <assert.h> #include <stddef.h> #include <string.h> #ifdef __SSE4_2__ #ifdef _MSC_VER #include <nmmintrin.h> #else #include <x86intrin.h> #endif #endif #include <batteries/pico_http/parser_decl.hpp> namespace pico_http { using namespace batt :: int_types ; } #ifdef _MSC_VER #define BATT_PICO_HTTP_ALIGNED(n) _declspec(align(n)) #else #define BATT_PICO_HTTP_ALIGNED(n) __attribute__((aligned(n))) #endif #define BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c) ((unsigned char)(c)-040u < 0137u) #define BATT_PICO_HTTP_CHECK_EOF() \\ if (buf == buf_end) { \\ *ret = -2; \\ return nullptr; \\ } #define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch) \\ if (*buf++ != ch) { \\ *ret = -1; \\ return nullptr; \\ } #define BATT_PICO_HTTP_EXPECT_CHAR(ch) \\ BATT_PICO_HTTP_CHECK_EOF(); \\ BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch); #define BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen) \\ do { \\ const char* tok_start = buf; \\ static const char BATT_PICO_HTTP_ALIGNED(16) ranges2[16] = \"\\000\\040\\177\\177\"; \\ int found2; \\ buf = findchar_fast(buf, buf_end, ranges2, 4, &found2); \\ if (!found2) { \\ BATT_PICO_HTTP_CHECK_EOF(); \\ } \\ while (1) { \\ if (*buf == ' ') { \\ break; \\ } else if (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) { \\ if ((unsigned char)*buf < '\\040' || *buf == '\\177') { \\ *ret = -1; \\ return nullptr; \\ } \\ } \\ ++buf; \\ BATT_PICO_HTTP_CHECK_EOF(); \\ } \\ tok = tok_start; \\ toklen = buf - tok_start; \\ } while (0) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace pico_http { namespace detail { namespace { const char * token_char_map = \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\1\\0\\1\\1\\1\\1\\1\\0\\0\\1\\1\\0\\1\\1\\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0 \" \" \\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\1\\1 \" \" \\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\1\\0\\1\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" ; BATT_INLINE_IMPL const char * findchar_fast ( const char * buf , const char * buf_end , const char * ranges , usize ranges_size , int * found ) { * found = 0 ; #if __SSE4_2__ if ( BATT_HINT_TRUE ( buf_end - buf >= 16 )) { __m128i ranges16 = _mm_loadu_si128 (( const __m128i * ) ranges ); usize left = ( buf_end - buf ) & ~ 15 ; do { __m128i b16 = _mm_loadu_si128 (( const __m128i * ) buf ); int r = _mm_cmpestri ( ranges16 , ranges_size , b16 , 16 , _SIDD_LEAST_SIGNIFICANT | _SIDD_CMP_RANGES | _SIDD_UBYTE_OPS ); if ( BATT_HINT_FALSE ( r != 16 )) { buf += r ; * found = 1 ; break ; } buf += 16 ; left -= 16 ; } while ( BATT_HINT_TRUE ( left != 0 )); } #else /* suppress unused parameter warning */ ( void ) buf_end ; ( void ) ranges ; ( void ) ranges_size ; #endif return buf ; } BATT_INLINE_IMPL const char * get_token_to_eol ( const char * buf , const char * buf_end , std :: string_view * token , int * ret ) { const char * token_start = buf ; int token_len = 0 ; #ifdef __SSE4_2__ static const char BATT_PICO_HTTP_ALIGNED ( 16 ) ranges1 [ 16 ] = \" \\0\\010 \" /* allow HT */ \" \\012\\037 \" /* allow SP and up to but not including DEL */ \" \\177\\177 \" ; /* allow chars w. MSB set */ int found ; buf = findchar_fast ( buf , buf_end , ranges1 , 6 , & found ); if ( found ) { goto FOUND_CTL ; } #else /* find non-printable char within the next 8 bytes, this is the hottest code; manually inlined */ while ( BATT_HINT_TRUE ( buf_end - buf >= 8 )) { //+++++++++++-+-+--+----- --- -- - - - - #define BATT_PICO_HTTP_DOIT() \\ do { \\ if (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) { \\ goto NonPrintable; \\ } \\ ++buf; \\ } while (0) BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); #undef BATT_PICO_HTTP_DOIT //+++++++++++-+-+--+----- --- -- - - - - continue ; NonPrintable : if (( BATT_HINT_TRUE (( unsigned char ) * buf < '\\040' ) && BATT_HINT_TRUE ( * buf != '\\011' )) || BATT_HINT_FALSE ( * buf == '\\177' )) { goto FOUND_CTL ; } ++ buf ; } #endif for (;; ++ buf ) { BATT_PICO_HTTP_CHECK_EOF (); if ( BATT_HINT_FALSE ( ! BATT_PICO_HTTP_IS_PRINTABLE_ASCII ( * buf ))) { if (( BATT_HINT_TRUE (( unsigned char ) * buf < '\\040' ) && BATT_HINT_TRUE ( * buf != '\\011' )) || BATT_HINT_FALSE ( * buf == '\\177' )) { goto FOUND_CTL ; } } } FOUND_CTL : if ( BATT_HINT_TRUE ( * buf == '\\015' )) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); token_len = buf - 2 - token_start ; } else if ( * buf == '\\012' ) { token_len = buf - token_start ; ++ buf ; } else { * ret = -1 ; return nullptr ; } * token = std :: string_view { token_start , static_cast < usize > ( token_len )}; return buf ; } BATT_INLINE_IMPL const char * is_complete ( const char * buf , const char * buf_end , usize last_len , int * ret ) { int ret_cnt = 0 ; buf = last_len < 3 ? buf : buf + last_len - 3 ; while ( 1 ) { BATT_PICO_HTTP_CHECK_EOF (); if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); ++ ret_cnt ; } else if ( * buf == '\\012' ) { ++ buf ; ++ ret_cnt ; } else { ++ buf ; ret_cnt = 0 ; } if ( ret_cnt == 2 ) { return buf ; } } * ret = -2 ; return nullptr ; } #define BATT_PICO_HTTP_PARSE_INT(valp_, mul_) \\ if (*buf < '0' || '9' < *buf) { \\ buf++; \\ *ret = -1; \\ return nullptr; \\ } \\ *(valp_) = (mul_) * (*buf++ - '0'); #define BATT_PICO_HTTP_PARSE_INT_3(valp_) \\ do { \\ int res_ = 0; \\ BATT_PICO_HTTP_PARSE_INT(&res_, 100) \\ *valp_ = res_; \\ BATT_PICO_HTTP_PARSE_INT(&res_, 10) \\ *valp_ += res_; \\ BATT_PICO_HTTP_PARSE_INT(&res_, 1) \\ *valp_ += res_; \\ } while (0) /* returned pointer is always within [buf, buf_end), or null */ BATT_INLINE_IMPL const char * parse_token ( const char * buf , const char * buf_end , std :: string_view * token , char next_char , int * ret ) { /* We use pcmpestri to detect non-token characters. This instruction can take no more than eight character * ranges (8*2*8=128 * bits that is the size of a SSE register). Due to this restriction, characters `|` and `~` are handled * in the slow loop. */ static const char BATT_PICO_HTTP_ALIGNED ( 16 ) ranges [] = \" \\x00 \" /* control chars and up to SP */ \" \\\"\\\" \" /* 0x22 */ \"()\" /* 0x28,0x29 */ \",,\" /* 0x2c */ \"//\" /* 0x2f */ \":@\" /* 0x3a-0x40 */ \"[]\" /* 0x5b-0x5d */ \"{ \\xff \" ; /* 0x7b-0xff */ const char * buf_start = buf ; int found ; buf = findchar_fast ( buf , buf_end , ranges , sizeof ( ranges ) - 1 , & found ); if ( ! found ) { BATT_PICO_HTTP_CHECK_EOF (); } while ( 1 ) { if ( * buf == next_char ) { break ; } else if ( ! token_char_map [( unsigned char ) * buf ]) { * ret = -1 ; return nullptr ; } ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } * token = std :: string_view { buf_start , static_cast < usize > ( buf - buf_start )}; return buf ; } /* returned pointer is always within [buf, buf_end), or null */ BATT_INLINE_IMPL const char * parse_http_version ( const char * buf , const char * buf_end , int * minor_version , int * ret ) { /* we want at least [HTTP/1.<two chars>] to try to parse */ if ( buf_end - buf < 9 ) { * ret = -2 ; return nullptr ; } BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'H' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'T' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'T' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'P' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( '/' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( '1' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( '.' ); BATT_PICO_HTTP_PARSE_INT ( minor_version , 1 ); return buf ; } BATT_INLINE_IMPL const char * parse_headers_impl ( const char * buf , const char * buf_end , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , int * ret ) { usize num_headers = 0 ; std :: string_view header_name ; std :: string_view header_value ; const auto commit_header = [ & ] { headers -> emplace_back ( pico_http :: MessageHeader { header_name , header_value }); ++ num_headers ; }; for (;; commit_header ()) { BATT_PICO_HTTP_CHECK_EOF (); if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); break ; } else if ( * buf == '\\012' ) { ++ buf ; break ; } if ( ! ( num_headers != 0 && ( * buf == ' ' || * buf == '\\t' ))) { /* parsing name, but do not discard SP before colon, see * http://www.mozilla.org/security/announce/2006/mfsa2006-33.html */ if (( buf = parse_token ( buf , buf_end , & header_name , ':' , ret )) == nullptr ) { return nullptr ; } if ( header_name . size () == 0 ) { * ret = -1 ; return nullptr ; } ++ buf ; for (;; ++ buf ) { BATT_PICO_HTTP_CHECK_EOF (); if ( ! ( * buf == ' ' || * buf == '\\t' )) { break ; } } } else { header_name = std :: string_view {}; } std :: string_view value ; if (( buf = get_token_to_eol ( buf , buf_end , & value , ret )) == nullptr ) { return nullptr ; } /* remove trailing SPs and HTABs */ const char * const value_begin = value . data (); const char * value_end = value_begin + value . size (); for (; value_end != value_begin ; -- value_end ) { const char c = * ( value_end - 1 ); if ( ! ( c == ' ' || c == '\\t' )) { break ; } } header_value = std :: string_view { value_begin , static_cast < usize > ( value_end - value_begin )}; } return buf ; } BATT_INLINE_IMPL const char * parse_request_impl ( const char * buf , const char * buf_end , std :: string_view * method , std :: string_view * path , int * minor_version , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , int * ret ) { /* skip first empty line (some clients add CRLF after POST content) */ BATT_PICO_HTTP_CHECK_EOF (); if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); } else if ( * buf == '\\012' ) { ++ buf ; } /* parse request line */ if (( buf = parse_token ( buf , buf_end , method , ' ' , ret )) == nullptr ) { return nullptr ; } do { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } while ( * buf == ' ' ); { const char * path_begin ; usize path_len ; BATT_PICO_HTTP_ADVANCE_TOKEN ( path_begin , path_len ); * path = std :: string_view { path_begin , path_len }; } do { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } while ( * buf == ' ' ); if ( method -> size () == 0 || path -> size () == 0 ) { * ret = -1 ; return nullptr ; } if (( buf = parse_http_version ( buf , buf_end , minor_version , ret )) == nullptr ) { return nullptr ; } if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); } else if ( * buf == '\\012' ) { ++ buf ; } else { * ret = -1 ; return nullptr ; } return :: pico_http :: detail :: parse_headers_impl ( buf , buf_end , headers , ret ); } } // namespace } // namespace detail } // namespace pico_http //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL int pico_http :: Request :: parse ( const char * buf_start , usize len , usize last_len ) { const char * buf = buf_start , * buf_end = buf_start + len ; int r ; this -> method = std :: string_view {}; this -> path = std :: string_view {}; this -> major_version = -1 ; this -> minor_version = -1 ; this -> headers . clear (); /* if last_len != 0, check if the request is complete (a fast countermeasure againt slowloris */ if ( last_len != 0 && :: pico_http :: detail :: is_complete ( buf , buf_end , last_len , & r ) == nullptr ) { this -> major_version = 1 ; return r ; } buf = :: pico_http :: detail :: parse_request_impl ( buf , buf_end , & this -> method , & this -> path , & this -> minor_version , & this -> headers , & r ); if ( buf == nullptr ) { return r ; } this -> major_version = 1 ; return ( int )( buf - buf_start ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace pico_http { namespace detail { namespace { BATT_INLINE_IMPL const char * parse_response_impl ( const char * buf , const char * buf_end , int * minor_version , int * status , std :: string_view * msg , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , int * ret ) { /* parse \"HTTP/1.x\" */ if (( buf = parse_http_version ( buf , buf_end , minor_version , ret )) == nullptr ) { return nullptr ; } /* skip space */ if ( * buf != ' ' ) { * ret = -1 ; return nullptr ; } do { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } while ( * buf == ' ' ); /* parse status code, we want at least [:digit:][:digit:][:digit:]<other char> to try to parse */ if ( buf_end - buf < 4 ) { * ret = -2 ; return nullptr ; } BATT_PICO_HTTP_PARSE_INT_3 ( status ); /* get message including preceding space */ if (( buf = get_token_to_eol ( buf , buf_end , msg , ret )) == nullptr ) { return nullptr ; } if ( msg -> size () == 0 ) { /* ok */ } else if (( * msg )[ 0 ] == ' ' ) { /* Remove preceding space. Successful return from `get_token_to_eol` guarantees that we would hit * something other than SP before running past the end of the given buffer. */ const char * msg_begin = msg -> data (); usize msg_len = msg -> size (); do { ++ msg_begin ; -- msg_len ; } while ( * msg_begin == ' ' ); * msg = std :: string_view { msg_begin , msg_len }; } else { /* garbage found after status code */ * ret = -1 ; return nullptr ; } return :: pico_http :: detail :: parse_headers_impl ( buf , buf_end , headers , ret ); } } // namespace } // namespace detail } // namespace pico_http #undef BATT_PICO_HTTP_PARSE_INT #undef BATT_PICO_HTTP_PARSE_INT_3 //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL int pico_http :: Response :: parse ( const char * buf_start , usize len , usize last_len ) { const char * buf = buf_start , * buf_end = buf + len ; int r ; this -> major_version = -1 ; this -> minor_version = -1 ; this -> status = 0 ; this -> message = std :: string_view {}; this -> headers . clear (); /* if last_len != 0, check if the response is complete (a fast countermeasure against slowloris */ if ( last_len != 0 && :: pico_http :: detail :: is_complete ( buf , buf_end , last_len , & r ) == nullptr ) { this -> major_version = 1 ; return r ; } buf = :: pico_http :: detail :: parse_response_impl ( buf , buf_end , & this -> minor_version , & this -> status , & this -> message , & this -> headers , & r ); if ( buf == nullptr ) { return r ; } this -> major_version = 1 ; return ( int )( buf - buf_start ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL int pico_http :: parse_headers ( const char * buf_start , usize len , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , usize last_len ) { const char * buf = buf_start , * buf_end = buf + len ; int r ; headers -> clear (); /* if last_len != 0, check if the response is complete (a fast countermeasure against slowloris */ if ( last_len != 0 && :: pico_http :: detail :: is_complete ( buf , buf_end , last_len , & r ) == nullptr ) { return r ; } if (( buf = :: pico_http :: detail :: parse_headers_impl ( buf , buf_end , headers , & r )) == nullptr ) { return r ; } return ( int )( buf - buf_start ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace pico_http { namespace detail { namespace { enum { CHUNKED_IN_CHUNK_SIZE , CHUNKED_IN_CHUNK_EXT , CHUNKED_IN_CHUNK_DATA , CHUNKED_IN_CHUNK_CRLF , CHUNKED_IN_TRAILERS_LINE_HEAD , CHUNKED_IN_TRAILERS_LINE_MIDDLE }; BATT_INLINE_IMPL int decode_hex ( int ch ) { if ( '0' <= ch && ch <= '9' ) { return ch - '0' ; } else if ( 'A' <= ch && ch <= 'F' ) { return ch - 'A' + 0xa ; } else if ( 'a' <= ch && ch <= 'f' ) { return ch - 'a' + 0xa ; } else { return kParseFailed ; } } } // namespace } // namespace detail } // namespace pico_http #define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS 0 //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL batt :: StatusOr < pico_http :: DecodeResult > pico_http :: decode_chunked ( pico_http :: ChunkedDecoder * decoder , const batt :: ConstBuffer & input , batt :: SmallVecBase < batt :: ConstBuffer >* output ) { const char * const buf = static_cast < const char *> ( input . data ()); const usize bufsz = input . size (); #if BATT_PICO_HTTP_PARSER_DUMP_CHUNKS std :: cerr << \"decode_chunks(\" << batt :: c_str_literal ( std :: string_view { buf , bufsz }) << \")\" << std :: endl ; #endif DecodeResult result ; result . done = false ; result . bytes_consumed = 0 ; usize & src = result . bytes_consumed ; for (;;) { switch ( decoder -> state_ ) { case :: pico_http :: detail :: CHUNKED_IN_CHUNK_SIZE : for (;; ++ src ) { int v ; if ( src == bufsz ) { return result ; } if (( v = :: pico_http :: detail :: decode_hex ( buf [ src ])) == kParseFailed ) { if ( decoder -> hex_count_ == 0 ) { return { batt :: StatusCode :: kInvalidArgument }; } break ; } if ( decoder -> hex_count_ == sizeof ( usize ) * 2 ) { return { batt :: StatusCode :: kInvalidArgument }; } decoder -> bytes_left_in_chunk = decoder -> bytes_left_in_chunk * 16 + v ; ++ decoder -> hex_count_ ; } decoder -> hex_count_ = 0 ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_EXT ; /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_CHUNK_EXT : /* RFC 7230 A.2 \"Line folding in chunk extensions is disallowed\" */ for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] == '\\012' ) { break ; } } ++ src ; if ( decoder -> bytes_left_in_chunk == 0 ) { if ( decoder -> consume_trailer ) { decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_HEAD ; break ; } else { result . done = true ; return result ; } } decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_DATA ; /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_CHUNK_DATA : { const usize avail = bufsz - src ; if ( avail < decoder -> bytes_left_in_chunk ) { if ( avail > 0 ) { output -> emplace_back ( batt :: ConstBuffer { buf + src , avail }); } src += avail ; decoder -> bytes_left_in_chunk -= avail ; return result ; } output -> emplace_back ( batt :: ConstBuffer { buf + src , decoder -> bytes_left_in_chunk }); src += decoder -> bytes_left_in_chunk ; decoder -> bytes_left_in_chunk = 0 ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_CRLF ; } /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_CHUNK_CRLF : for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] != '\\015' ) { break ; } } if ( buf [ src ] != '\\012' ) { return { batt :: StatusCode :: kInvalidArgument }; } ++ src ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_SIZE ; break ; case :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_HEAD : for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] != '\\015' ) { break ; } } if ( buf [ src ++ ] == '\\012' ) { result . done = true ; return result ; } decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_MIDDLE ; /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_MIDDLE : for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] == '\\012' ) { break ; } } ++ src ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_HEAD ; break ; default : BATT_PANIC () << \"decoder is corrupt\" ; } } } BATT_INLINE_IMPL int pico_http :: decode_chunked_is_in_data ( pico_http :: ChunkedDecoder * decoder ) { return decoder -> state_ == :: pico_http :: detail :: CHUNKED_IN_CHUNK_DATA ; } #undef BATT_PICO_HTTP_CHECK_EOF #undef BATT_PICO_HTTP_EXPECT_CHAR #undef BATT_PICO_HTTP_ADVANCE_TOKEN #undef BATT_PICO_HTTP_ALIGNED namespace pico_http { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const MessageHeader & t ) { return out << t . name << \": \" << t . value << \" \\r\\n \" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const batt :: SmallVecBase < MessageHeader >& t ) { for ( const MessageHeader & hdr : t ) { out << hdr ; } return out ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const Request & t ) { return out << t . method << ' ' << t . path << \" HTTP/\" << t . major_version << '.' << t . minor_version << \" \\r\\n \" << t . headers << \" \\r\\n \" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const Response & t ) { return out << \"HTTP/\" << t . major_version << '.' << t . minor_version << ' ' << t . status << ' ' << t . message << \" \\r\\n \" << t . headers << \" \\r\\n \" ; } } // namespace pico_http #endif // BATTERIES_PICO_HTTP_PARSER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/pico_http/parser_impl.hpp"},{"location":"_autogen/Files/parser__impl_8hpp/#namespaces","text":"Name pico_http pico_http::detail","title":"Namespaces"},{"location":"_autogen/Files/parser__impl_8hpp/#defines","text":"Name BATTERIES_PICO_HTTP_PARSER_IMPL_HPP BATT_PICO_HTTP_ALIGNED (n) BATT_PICO_HTTP_IS_PRINTABLE_ASCII (c) BATT_PICO_HTTP_CHECK_EOF () BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK (ch) BATT_PICO_HTTP_EXPECT_CHAR (ch) BATT_PICO_HTTP_ADVANCE_TOKEN (tok, toklen) BATT_PICO_HTTP_DOIT () BATT_PICO_HTTP_PARSE_INT (valp_, mul_) BATT_PICO_HTTP_PARSE_INT_3 (valp_) BATT_PICO_HTTP_PARSER_DUMP_CHUNKS","title":"Defines"},{"location":"_autogen/Files/parser__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/parser__impl_8hpp/#batteries_pico_http_parser_impl_hpp","text":"1 #define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP()","title":"BATTERIES_PICO_HTTP_PARSER_IMPL_HPP"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_aligned","text":"1 #define BATT_PICO_HTTP_ALIGNED(n)","title":"BATT_PICO_HTTP_ALIGNED"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_is_printable_ascii","text":"1 #define BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c)","title":"BATT_PICO_HTTP_IS_PRINTABLE_ASCII"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_check_eof","text":"1 #define BATT_PICO_HTTP_CHECK_EOF()","title":"BATT_PICO_HTTP_CHECK_EOF"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_expect_char_no_check","text":"1 #define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch)","title":"BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_expect_char","text":"1 #define BATT_PICO_HTTP_EXPECT_CHAR(ch)","title":"BATT_PICO_HTTP_EXPECT_CHAR"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_advance_token","text":"1 #define BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen)","title":"BATT_PICO_HTTP_ADVANCE_TOKEN"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_doit","text":"1 #define BATT_PICO_HTTP_DOIT()","title":"BATT_PICO_HTTP_DOIT"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_parse_int","text":"1 #define BATT_PICO_HTTP_PARSE_INT(valp_, mul_)","title":"BATT_PICO_HTTP_PARSE_INT"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_parse_int_3","text":"1 #define BATT_PICO_HTTP_PARSE_INT_3(valp_)","title":"BATT_PICO_HTTP_PARSE_INT_3"},{"location":"_autogen/Files/parser__impl_8hpp/#batt_pico_http_parser_dump_chunks","text":"1 #define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS()","title":"BATT_PICO_HTTP_PARSER_DUMP_CHUNKS"},{"location":"_autogen/Files/parser__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 /* * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */ #pragma once #ifndef BATTERIES_PICO_HTTP_PARSER_IMPL_HPP #define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP #include <batteries/config.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <assert.h> #include <stddef.h> #include <string.h> #ifdef __SSE4_2__ #ifdef _MSC_VER #include <nmmintrin.h> #else #include <x86intrin.h> #endif #endif #include <batteries/pico_http/parser_decl.hpp> namespace pico_http { using namespace batt :: int_types ; } #ifdef _MSC_VER #define BATT_PICO_HTTP_ALIGNED(n) _declspec(align(n)) #else #define BATT_PICO_HTTP_ALIGNED(n) __attribute__((aligned(n))) #endif #define BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c) ((unsigned char)(c)-040u < 0137u) #define BATT_PICO_HTTP_CHECK_EOF() \\ if (buf == buf_end) { \\ *ret = -2; \\ return nullptr; \\ } #define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch) \\ if (*buf++ != ch) { \\ *ret = -1; \\ return nullptr; \\ } #define BATT_PICO_HTTP_EXPECT_CHAR(ch) \\ BATT_PICO_HTTP_CHECK_EOF(); \\ BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch); #define BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen) \\ do { \\ const char* tok_start = buf; \\ static const char BATT_PICO_HTTP_ALIGNED(16) ranges2[16] = \"\\000\\040\\177\\177\"; \\ int found2; \\ buf = findchar_fast(buf, buf_end, ranges2, 4, &found2); \\ if (!found2) { \\ BATT_PICO_HTTP_CHECK_EOF(); \\ } \\ while (1) { \\ if (*buf == ' ') { \\ break; \\ } else if (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) { \\ if ((unsigned char)*buf < '\\040' || *buf == '\\177') { \\ *ret = -1; \\ return nullptr; \\ } \\ } \\ ++buf; \\ BATT_PICO_HTTP_CHECK_EOF(); \\ } \\ tok = tok_start; \\ toklen = buf - tok_start; \\ } while (0) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace pico_http { namespace detail { namespace { const char * token_char_map = \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\1\\0\\1\\1\\1\\1\\1\\0\\0\\1\\1\\0\\1\\1\\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0 \" \" \\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\1\\1 \" \" \\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\1\\0\\1\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" \" \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 \" ; BATT_INLINE_IMPL const char * findchar_fast ( const char * buf , const char * buf_end , const char * ranges , usize ranges_size , int * found ) { * found = 0 ; #if __SSE4_2__ if ( BATT_HINT_TRUE ( buf_end - buf >= 16 )) { __m128i ranges16 = _mm_loadu_si128 (( const __m128i * ) ranges ); usize left = ( buf_end - buf ) & ~ 15 ; do { __m128i b16 = _mm_loadu_si128 (( const __m128i * ) buf ); int r = _mm_cmpestri ( ranges16 , ranges_size , b16 , 16 , _SIDD_LEAST_SIGNIFICANT | _SIDD_CMP_RANGES | _SIDD_UBYTE_OPS ); if ( BATT_HINT_FALSE ( r != 16 )) { buf += r ; * found = 1 ; break ; } buf += 16 ; left -= 16 ; } while ( BATT_HINT_TRUE ( left != 0 )); } #else /* suppress unused parameter warning */ ( void ) buf_end ; ( void ) ranges ; ( void ) ranges_size ; #endif return buf ; } BATT_INLINE_IMPL const char * get_token_to_eol ( const char * buf , const char * buf_end , std :: string_view * token , int * ret ) { const char * token_start = buf ; int token_len = 0 ; #ifdef __SSE4_2__ static const char BATT_PICO_HTTP_ALIGNED ( 16 ) ranges1 [ 16 ] = \" \\0\\010 \" /* allow HT */ \" \\012\\037 \" /* allow SP and up to but not including DEL */ \" \\177\\177 \" ; /* allow chars w. MSB set */ int found ; buf = findchar_fast ( buf , buf_end , ranges1 , 6 , & found ); if ( found ) { goto FOUND_CTL ; } #else /* find non-printable char within the next 8 bytes, this is the hottest code; manually inlined */ while ( BATT_HINT_TRUE ( buf_end - buf >= 8 )) { //+++++++++++-+-+--+----- --- -- - - - - #define BATT_PICO_HTTP_DOIT() \\ do { \\ if (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) { \\ goto NonPrintable; \\ } \\ ++buf; \\ } while (0) BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); BATT_PICO_HTTP_DOIT (); #undef BATT_PICO_HTTP_DOIT //+++++++++++-+-+--+----- --- -- - - - - continue ; NonPrintable : if (( BATT_HINT_TRUE (( unsigned char ) * buf < '\\040' ) && BATT_HINT_TRUE ( * buf != '\\011' )) || BATT_HINT_FALSE ( * buf == '\\177' )) { goto FOUND_CTL ; } ++ buf ; } #endif for (;; ++ buf ) { BATT_PICO_HTTP_CHECK_EOF (); if ( BATT_HINT_FALSE ( ! BATT_PICO_HTTP_IS_PRINTABLE_ASCII ( * buf ))) { if (( BATT_HINT_TRUE (( unsigned char ) * buf < '\\040' ) && BATT_HINT_TRUE ( * buf != '\\011' )) || BATT_HINT_FALSE ( * buf == '\\177' )) { goto FOUND_CTL ; } } } FOUND_CTL : if ( BATT_HINT_TRUE ( * buf == '\\015' )) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); token_len = buf - 2 - token_start ; } else if ( * buf == '\\012' ) { token_len = buf - token_start ; ++ buf ; } else { * ret = -1 ; return nullptr ; } * token = std :: string_view { token_start , static_cast < usize > ( token_len )}; return buf ; } BATT_INLINE_IMPL const char * is_complete ( const char * buf , const char * buf_end , usize last_len , int * ret ) { int ret_cnt = 0 ; buf = last_len < 3 ? buf : buf + last_len - 3 ; while ( 1 ) { BATT_PICO_HTTP_CHECK_EOF (); if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); ++ ret_cnt ; } else if ( * buf == '\\012' ) { ++ buf ; ++ ret_cnt ; } else { ++ buf ; ret_cnt = 0 ; } if ( ret_cnt == 2 ) { return buf ; } } * ret = -2 ; return nullptr ; } #define BATT_PICO_HTTP_PARSE_INT(valp_, mul_) \\ if (*buf < '0' || '9' < *buf) { \\ buf++; \\ *ret = -1; \\ return nullptr; \\ } \\ *(valp_) = (mul_) * (*buf++ - '0'); #define BATT_PICO_HTTP_PARSE_INT_3(valp_) \\ do { \\ int res_ = 0; \\ BATT_PICO_HTTP_PARSE_INT(&res_, 100) \\ *valp_ = res_; \\ BATT_PICO_HTTP_PARSE_INT(&res_, 10) \\ *valp_ += res_; \\ BATT_PICO_HTTP_PARSE_INT(&res_, 1) \\ *valp_ += res_; \\ } while (0) /* returned pointer is always within [buf, buf_end), or null */ BATT_INLINE_IMPL const char * parse_token ( const char * buf , const char * buf_end , std :: string_view * token , char next_char , int * ret ) { /* We use pcmpestri to detect non-token characters. This instruction can take no more than eight character * ranges (8*2*8=128 * bits that is the size of a SSE register). Due to this restriction, characters `|` and `~` are handled * in the slow loop. */ static const char BATT_PICO_HTTP_ALIGNED ( 16 ) ranges [] = \" \\x00 \" /* control chars and up to SP */ \" \\\"\\\" \" /* 0x22 */ \"()\" /* 0x28,0x29 */ \",,\" /* 0x2c */ \"//\" /* 0x2f */ \":@\" /* 0x3a-0x40 */ \"[]\" /* 0x5b-0x5d */ \"{ \\xff \" ; /* 0x7b-0xff */ const char * buf_start = buf ; int found ; buf = findchar_fast ( buf , buf_end , ranges , sizeof ( ranges ) - 1 , & found ); if ( ! found ) { BATT_PICO_HTTP_CHECK_EOF (); } while ( 1 ) { if ( * buf == next_char ) { break ; } else if ( ! token_char_map [( unsigned char ) * buf ]) { * ret = -1 ; return nullptr ; } ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } * token = std :: string_view { buf_start , static_cast < usize > ( buf - buf_start )}; return buf ; } /* returned pointer is always within [buf, buf_end), or null */ BATT_INLINE_IMPL const char * parse_http_version ( const char * buf , const char * buf_end , int * minor_version , int * ret ) { /* we want at least [HTTP/1.<two chars>] to try to parse */ if ( buf_end - buf < 9 ) { * ret = -2 ; return nullptr ; } BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'H' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'T' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'T' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( 'P' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( '/' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( '1' ); BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK ( '.' ); BATT_PICO_HTTP_PARSE_INT ( minor_version , 1 ); return buf ; } BATT_INLINE_IMPL const char * parse_headers_impl ( const char * buf , const char * buf_end , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , int * ret ) { usize num_headers = 0 ; std :: string_view header_name ; std :: string_view header_value ; const auto commit_header = [ & ] { headers -> emplace_back ( pico_http :: MessageHeader { header_name , header_value }); ++ num_headers ; }; for (;; commit_header ()) { BATT_PICO_HTTP_CHECK_EOF (); if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); break ; } else if ( * buf == '\\012' ) { ++ buf ; break ; } if ( ! ( num_headers != 0 && ( * buf == ' ' || * buf == '\\t' ))) { /* parsing name, but do not discard SP before colon, see * http://www.mozilla.org/security/announce/2006/mfsa2006-33.html */ if (( buf = parse_token ( buf , buf_end , & header_name , ':' , ret )) == nullptr ) { return nullptr ; } if ( header_name . size () == 0 ) { * ret = -1 ; return nullptr ; } ++ buf ; for (;; ++ buf ) { BATT_PICO_HTTP_CHECK_EOF (); if ( ! ( * buf == ' ' || * buf == '\\t' )) { break ; } } } else { header_name = std :: string_view {}; } std :: string_view value ; if (( buf = get_token_to_eol ( buf , buf_end , & value , ret )) == nullptr ) { return nullptr ; } /* remove trailing SPs and HTABs */ const char * const value_begin = value . data (); const char * value_end = value_begin + value . size (); for (; value_end != value_begin ; -- value_end ) { const char c = * ( value_end - 1 ); if ( ! ( c == ' ' || c == '\\t' )) { break ; } } header_value = std :: string_view { value_begin , static_cast < usize > ( value_end - value_begin )}; } return buf ; } BATT_INLINE_IMPL const char * parse_request_impl ( const char * buf , const char * buf_end , std :: string_view * method , std :: string_view * path , int * minor_version , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , int * ret ) { /* skip first empty line (some clients add CRLF after POST content) */ BATT_PICO_HTTP_CHECK_EOF (); if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); } else if ( * buf == '\\012' ) { ++ buf ; } /* parse request line */ if (( buf = parse_token ( buf , buf_end , method , ' ' , ret )) == nullptr ) { return nullptr ; } do { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } while ( * buf == ' ' ); { const char * path_begin ; usize path_len ; BATT_PICO_HTTP_ADVANCE_TOKEN ( path_begin , path_len ); * path = std :: string_view { path_begin , path_len }; } do { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } while ( * buf == ' ' ); if ( method -> size () == 0 || path -> size () == 0 ) { * ret = -1 ; return nullptr ; } if (( buf = parse_http_version ( buf , buf_end , minor_version , ret )) == nullptr ) { return nullptr ; } if ( * buf == '\\015' ) { ++ buf ; BATT_PICO_HTTP_EXPECT_CHAR ( '\\012' ); } else if ( * buf == '\\012' ) { ++ buf ; } else { * ret = -1 ; return nullptr ; } return :: pico_http :: detail :: parse_headers_impl ( buf , buf_end , headers , ret ); } } // namespace } // namespace detail } // namespace pico_http //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL int pico_http :: Request :: parse ( const char * buf_start , usize len , usize last_len ) { const char * buf = buf_start , * buf_end = buf_start + len ; int r ; this -> method = std :: string_view {}; this -> path = std :: string_view {}; this -> major_version = -1 ; this -> minor_version = -1 ; this -> headers . clear (); /* if last_len != 0, check if the request is complete (a fast countermeasure againt slowloris */ if ( last_len != 0 && :: pico_http :: detail :: is_complete ( buf , buf_end , last_len , & r ) == nullptr ) { this -> major_version = 1 ; return r ; } buf = :: pico_http :: detail :: parse_request_impl ( buf , buf_end , & this -> method , & this -> path , & this -> minor_version , & this -> headers , & r ); if ( buf == nullptr ) { return r ; } this -> major_version = 1 ; return ( int )( buf - buf_start ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace pico_http { namespace detail { namespace { BATT_INLINE_IMPL const char * parse_response_impl ( const char * buf , const char * buf_end , int * minor_version , int * status , std :: string_view * msg , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , int * ret ) { /* parse \"HTTP/1.x\" */ if (( buf = parse_http_version ( buf , buf_end , minor_version , ret )) == nullptr ) { return nullptr ; } /* skip space */ if ( * buf != ' ' ) { * ret = -1 ; return nullptr ; } do { ++ buf ; BATT_PICO_HTTP_CHECK_EOF (); } while ( * buf == ' ' ); /* parse status code, we want at least [:digit:][:digit:][:digit:]<other char> to try to parse */ if ( buf_end - buf < 4 ) { * ret = -2 ; return nullptr ; } BATT_PICO_HTTP_PARSE_INT_3 ( status ); /* get message including preceding space */ if (( buf = get_token_to_eol ( buf , buf_end , msg , ret )) == nullptr ) { return nullptr ; } if ( msg -> size () == 0 ) { /* ok */ } else if (( * msg )[ 0 ] == ' ' ) { /* Remove preceding space. Successful return from `get_token_to_eol` guarantees that we would hit * something other than SP before running past the end of the given buffer. */ const char * msg_begin = msg -> data (); usize msg_len = msg -> size (); do { ++ msg_begin ; -- msg_len ; } while ( * msg_begin == ' ' ); * msg = std :: string_view { msg_begin , msg_len }; } else { /* garbage found after status code */ * ret = -1 ; return nullptr ; } return :: pico_http :: detail :: parse_headers_impl ( buf , buf_end , headers , ret ); } } // namespace } // namespace detail } // namespace pico_http #undef BATT_PICO_HTTP_PARSE_INT #undef BATT_PICO_HTTP_PARSE_INT_3 //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL int pico_http :: Response :: parse ( const char * buf_start , usize len , usize last_len ) { const char * buf = buf_start , * buf_end = buf + len ; int r ; this -> major_version = -1 ; this -> minor_version = -1 ; this -> status = 0 ; this -> message = std :: string_view {}; this -> headers . clear (); /* if last_len != 0, check if the response is complete (a fast countermeasure against slowloris */ if ( last_len != 0 && :: pico_http :: detail :: is_complete ( buf , buf_end , last_len , & r ) == nullptr ) { this -> major_version = 1 ; return r ; } buf = :: pico_http :: detail :: parse_response_impl ( buf , buf_end , & this -> minor_version , & this -> status , & this -> message , & this -> headers , & r ); if ( buf == nullptr ) { return r ; } this -> major_version = 1 ; return ( int )( buf - buf_start ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL int pico_http :: parse_headers ( const char * buf_start , usize len , batt :: SmallVecBase < pico_http :: MessageHeader >* headers , usize last_len ) { const char * buf = buf_start , * buf_end = buf + len ; int r ; headers -> clear (); /* if last_len != 0, check if the response is complete (a fast countermeasure against slowloris */ if ( last_len != 0 && :: pico_http :: detail :: is_complete ( buf , buf_end , last_len , & r ) == nullptr ) { return r ; } if (( buf = :: pico_http :: detail :: parse_headers_impl ( buf , buf_end , headers , & r )) == nullptr ) { return r ; } return ( int )( buf - buf_start ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace pico_http { namespace detail { namespace { enum { CHUNKED_IN_CHUNK_SIZE , CHUNKED_IN_CHUNK_EXT , CHUNKED_IN_CHUNK_DATA , CHUNKED_IN_CHUNK_CRLF , CHUNKED_IN_TRAILERS_LINE_HEAD , CHUNKED_IN_TRAILERS_LINE_MIDDLE }; BATT_INLINE_IMPL int decode_hex ( int ch ) { if ( '0' <= ch && ch <= '9' ) { return ch - '0' ; } else if ( 'A' <= ch && ch <= 'F' ) { return ch - 'A' + 0xa ; } else if ( 'a' <= ch && ch <= 'f' ) { return ch - 'a' + 0xa ; } else { return kParseFailed ; } } } // namespace } // namespace detail } // namespace pico_http #define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS 0 //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL batt :: StatusOr < pico_http :: DecodeResult > pico_http :: decode_chunked ( pico_http :: ChunkedDecoder * decoder , const batt :: ConstBuffer & input , batt :: SmallVecBase < batt :: ConstBuffer >* output ) { const char * const buf = static_cast < const char *> ( input . data ()); const usize bufsz = input . size (); #if BATT_PICO_HTTP_PARSER_DUMP_CHUNKS std :: cerr << \"decode_chunks(\" << batt :: c_str_literal ( std :: string_view { buf , bufsz }) << \")\" << std :: endl ; #endif DecodeResult result ; result . done = false ; result . bytes_consumed = 0 ; usize & src = result . bytes_consumed ; for (;;) { switch ( decoder -> state_ ) { case :: pico_http :: detail :: CHUNKED_IN_CHUNK_SIZE : for (;; ++ src ) { int v ; if ( src == bufsz ) { return result ; } if (( v = :: pico_http :: detail :: decode_hex ( buf [ src ])) == kParseFailed ) { if ( decoder -> hex_count_ == 0 ) { return { batt :: StatusCode :: kInvalidArgument }; } break ; } if ( decoder -> hex_count_ == sizeof ( usize ) * 2 ) { return { batt :: StatusCode :: kInvalidArgument }; } decoder -> bytes_left_in_chunk = decoder -> bytes_left_in_chunk * 16 + v ; ++ decoder -> hex_count_ ; } decoder -> hex_count_ = 0 ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_EXT ; /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_CHUNK_EXT : /* RFC 7230 A.2 \"Line folding in chunk extensions is disallowed\" */ for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] == '\\012' ) { break ; } } ++ src ; if ( decoder -> bytes_left_in_chunk == 0 ) { if ( decoder -> consume_trailer ) { decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_HEAD ; break ; } else { result . done = true ; return result ; } } decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_DATA ; /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_CHUNK_DATA : { const usize avail = bufsz - src ; if ( avail < decoder -> bytes_left_in_chunk ) { if ( avail > 0 ) { output -> emplace_back ( batt :: ConstBuffer { buf + src , avail }); } src += avail ; decoder -> bytes_left_in_chunk -= avail ; return result ; } output -> emplace_back ( batt :: ConstBuffer { buf + src , decoder -> bytes_left_in_chunk }); src += decoder -> bytes_left_in_chunk ; decoder -> bytes_left_in_chunk = 0 ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_CRLF ; } /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_CHUNK_CRLF : for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] != '\\015' ) { break ; } } if ( buf [ src ] != '\\012' ) { return { batt :: StatusCode :: kInvalidArgument }; } ++ src ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_CHUNK_SIZE ; break ; case :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_HEAD : for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] != '\\015' ) { break ; } } if ( buf [ src ++ ] == '\\012' ) { result . done = true ; return result ; } decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_MIDDLE ; /* fallthru */ case :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_MIDDLE : for (;; ++ src ) { if ( src == bufsz ) { return result ; } if ( buf [ src ] == '\\012' ) { break ; } } ++ src ; decoder -> state_ = :: pico_http :: detail :: CHUNKED_IN_TRAILERS_LINE_HEAD ; break ; default : BATT_PANIC () << \"decoder is corrupt\" ; } } } BATT_INLINE_IMPL int pico_http :: decode_chunked_is_in_data ( pico_http :: ChunkedDecoder * decoder ) { return decoder -> state_ == :: pico_http :: detail :: CHUNKED_IN_CHUNK_DATA ; } #undef BATT_PICO_HTTP_CHECK_EOF #undef BATT_PICO_HTTP_EXPECT_CHAR #undef BATT_PICO_HTTP_ADVANCE_TOKEN #undef BATT_PICO_HTTP_ALIGNED namespace pico_http { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const MessageHeader & t ) { return out << t . name << \": \" << t . value << \" \\r\\n \" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const batt :: SmallVecBase < MessageHeader >& t ) { for ( const MessageHeader & hdr : t ) { out << hdr ; } return out ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const Request & t ) { return out << t . method << ' ' << t . path << \" HTTP/\" << t . major_version << '.' << t . minor_version << \" \\r\\n \" << t . headers << \" \\r\\n \" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const Response & t ) { return out << \"HTTP/\" << t . major_version << '.' << t . minor_version << ' ' << t . status << ' ' << t . message << \" \\r\\n \" << t . headers << \" \\r\\n \" ; } } // namespace pico_http #endif // BATTERIES_PICO_HTTP_PARSER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/pin_8hpp/","text":"batteries/async/pin.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Pinnable class batt::Pin Functions \ud83d\udd17 Name template <typename T > void batt_pin_object_helper (T * object) template <typename T > void batt_unpin_object_helper (T * object) Defines \ud83d\udd17 Name BATTERIES_ASYNC_PIN_HPP Functions Documentation \ud83d\udd17 function batt_pin_object_helper \ud83d\udd17 1 2 3 4 template < typename T > inline void batt_pin_object_helper ( T * object ) function batt_unpin_object_helper \ud83d\udd17 1 2 3 4 template < typename T > inline void batt_unpin_object_helper ( T * object ) Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_PIN_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_PIN_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_PIN_HPP #define BATTERIES_ASYNC_PIN_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <atomic> // Top-level functions to increase/decrease the pin count of an object; this must be outside of the `batt` // namespace so we can make an unqualified call to `pin_object` in order to utilize ADL (argument-dependent // lookup). // template < typename T > inline void batt_pin_object_helper ( T * object ) { pin_object ( object ); } template < typename T > inline void batt_unpin_object_helper ( T * object ) { unpin_object ( object ); } namespace batt { // Base class that implements the PinnableObject requirements. See Pin<T> for details. // class Pinnable { public : Pinnable () = default ; Pinnable ( const Pinnable & ) = delete ; Pinnable & operator = ( const Pinnable & ) = delete ; ~ Pinnable () { // Release the self-pin before waiting for other pins to be released. // this -> unpin (); // Don't let the current Task continue until all other pins on this object have been released. // while ( this -> pin_count_ . load ( std :: memory_order_acquire ) > 0 ) { Task :: yield (); } // We can safely assert this is the case because once the pin count goes to 0, it should never // increase again (because of the self-pin acquired at construction time and released at destruction // time). // BATT_CHECK_EQ ( this -> pin_count_ . load ( std :: memory_order_release ), 0 ); } void pin () { this -> pin_count_ . fetch_add ( 1 , std :: memory_order_relaxed ); } void unpin () { this -> pin_count_ . fetch_sub ( 1 , std :: memory_order_release ); } private : // The pin count starts out as 1; this way we avoid A/B/A issues where the pin count drops down to zero // then goes back up. // std :: atomic < isize > pin_count_ { 1 }; }; // Default implementation of ADL-enabled pin_object, for `Pinnable`. // template < typename T > void pin_object ( T * object ) { object -> pin (); } // Default implementation of ADL-enabled unpin_object, for `Pinnable`. // template < typename T > void unpin_object ( T * object ) { object -> unpin (); } // A copyable/move-optimized smart pointer to PinnableObject `T` that prevents the pointee from being // destructed. This is an alternative to shared_ptr/intrusive_ptr for the case where application code wishes // to avoid the overhead of heap allocation. The use case is that a unique owner can be identified within the // code, but there may be race conditions on destruction of the object. For example, if one Task creates an // object, hands it to another Task, waits for the other Task to be done with it, then the first Task deletes // the object. Normally you would need some external synchronization mechanism for this, but Pin<T> allows the // object itself to contain the required synchronization. // template < typename T > class Pin { public : Pin () noexcept : ptr_ { nullptr } { } explicit Pin ( std :: nullptr_t ) noexcept : Pin {} { } explicit Pin ( T * object ) noexcept : ptr_ { object } { if ( BATT_HINT_TRUE ( object != nullptr )) { :: batt_pin_object_helper ( object ); } } Pin ( const Pin & other ) noexcept : Pin { other . ptr_ } { } Pin ( Pin && other ) noexcept : ptr_ { other . ptr_ } { other . ptr_ = nullptr ; } ~ Pin () noexcept { this -> release (); } Pin & operator = ( const Pin & other ) { Pin tmp { other }; this -> swap ( tmp ); return * this ; } Pin & operator = ( Pin && other ) { Pin tmp { std :: move ( other )}; this -> swap ( tmp ); return * this ; } explicit operator bool () const { return this -> ptr_ != nullptr ; } void swap ( Pin & other ) { std :: swap ( this -> ptr_ , other . ptr_ ); } void release () { if ( this -> ptr_ ) { :: batt_unpin_object_helper ( this -> ptr_ ); this -> ptr_ = nullptr ; } } T * get () const { return this -> ptr_ ; } T & operator * () const { return * this -> get (); } T * operator -> () const { return this -> get (); } private : T * ptr_ ; }; template < typename T > inline Pin < T > make_pin ( T * object ) { return Pin < T > { object }; } template < typename T , typename U > inline bool operator == ( const Pin < T >& l , const Pin < U >& r ) { return l . get () == r . get (); } template < typename T , typename U > inline bool operator != ( const Pin < T >& l , const Pin < U >& r ) { return ! ( l == r ); } template < typename T > inline bool operator == ( const Pin < T >& l , std :: nullptr_t ) { return l . get () == nullptr ; } template < typename T > inline bool operator != ( const Pin < T >& l , std :: nullptr_t ) { return ! ( l == nullptr ); } template < typename U > inline bool operator == ( std :: nullptr_t , const Pin < U >& r ) { return nullptr == r . get (); } template < typename U > inline bool operator != ( std :: nullptr_t , const Pin < U >& r ) { return ! ( nullptr == r ); } } // namespace batt #endif // BATTERIES_ASYNC_PIN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/pin.hpp"},{"location":"_autogen/Files/pin_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/pin_8hpp/#classes","text":"Name class batt::Pinnable class batt::Pin","title":"Classes"},{"location":"_autogen/Files/pin_8hpp/#functions","text":"Name template <typename T > void batt_pin_object_helper (T * object) template <typename T > void batt_unpin_object_helper (T * object)","title":"Functions"},{"location":"_autogen/Files/pin_8hpp/#defines","text":"Name BATTERIES_ASYNC_PIN_HPP","title":"Defines"},{"location":"_autogen/Files/pin_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Files/pin_8hpp/#function-batt_pin_object_helper","text":"1 2 3 4 template < typename T > inline void batt_pin_object_helper ( T * object )","title":"function batt_pin_object_helper"},{"location":"_autogen/Files/pin_8hpp/#function-batt_unpin_object_helper","text":"1 2 3 4 template < typename T > inline void batt_unpin_object_helper ( T * object )","title":"function batt_unpin_object_helper"},{"location":"_autogen/Files/pin_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/pin_8hpp/#batteries_async_pin_hpp","text":"1 #define BATTERIES_ASYNC_PIN_HPP()","title":"BATTERIES_ASYNC_PIN_HPP"},{"location":"_autogen/Files/pin_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_PIN_HPP #define BATTERIES_ASYNC_PIN_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> #include <batteries/assert.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <atomic> // Top-level functions to increase/decrease the pin count of an object; this must be outside of the `batt` // namespace so we can make an unqualified call to `pin_object` in order to utilize ADL (argument-dependent // lookup). // template < typename T > inline void batt_pin_object_helper ( T * object ) { pin_object ( object ); } template < typename T > inline void batt_unpin_object_helper ( T * object ) { unpin_object ( object ); } namespace batt { // Base class that implements the PinnableObject requirements. See Pin<T> for details. // class Pinnable { public : Pinnable () = default ; Pinnable ( const Pinnable & ) = delete ; Pinnable & operator = ( const Pinnable & ) = delete ; ~ Pinnable () { // Release the self-pin before waiting for other pins to be released. // this -> unpin (); // Don't let the current Task continue until all other pins on this object have been released. // while ( this -> pin_count_ . load ( std :: memory_order_acquire ) > 0 ) { Task :: yield (); } // We can safely assert this is the case because once the pin count goes to 0, it should never // increase again (because of the self-pin acquired at construction time and released at destruction // time). // BATT_CHECK_EQ ( this -> pin_count_ . load ( std :: memory_order_release ), 0 ); } void pin () { this -> pin_count_ . fetch_add ( 1 , std :: memory_order_relaxed ); } void unpin () { this -> pin_count_ . fetch_sub ( 1 , std :: memory_order_release ); } private : // The pin count starts out as 1; this way we avoid A/B/A issues where the pin count drops down to zero // then goes back up. // std :: atomic < isize > pin_count_ { 1 }; }; // Default implementation of ADL-enabled pin_object, for `Pinnable`. // template < typename T > void pin_object ( T * object ) { object -> pin (); } // Default implementation of ADL-enabled unpin_object, for `Pinnable`. // template < typename T > void unpin_object ( T * object ) { object -> unpin (); } // A copyable/move-optimized smart pointer to PinnableObject `T` that prevents the pointee from being // destructed. This is an alternative to shared_ptr/intrusive_ptr for the case where application code wishes // to avoid the overhead of heap allocation. The use case is that a unique owner can be identified within the // code, but there may be race conditions on destruction of the object. For example, if one Task creates an // object, hands it to another Task, waits for the other Task to be done with it, then the first Task deletes // the object. Normally you would need some external synchronization mechanism for this, but Pin<T> allows the // object itself to contain the required synchronization. // template < typename T > class Pin { public : Pin () noexcept : ptr_ { nullptr } { } explicit Pin ( std :: nullptr_t ) noexcept : Pin {} { } explicit Pin ( T * object ) noexcept : ptr_ { object } { if ( BATT_HINT_TRUE ( object != nullptr )) { :: batt_pin_object_helper ( object ); } } Pin ( const Pin & other ) noexcept : Pin { other . ptr_ } { } Pin ( Pin && other ) noexcept : ptr_ { other . ptr_ } { other . ptr_ = nullptr ; } ~ Pin () noexcept { this -> release (); } Pin & operator = ( const Pin & other ) { Pin tmp { other }; this -> swap ( tmp ); return * this ; } Pin & operator = ( Pin && other ) { Pin tmp { std :: move ( other )}; this -> swap ( tmp ); return * this ; } explicit operator bool () const { return this -> ptr_ != nullptr ; } void swap ( Pin & other ) { std :: swap ( this -> ptr_ , other . ptr_ ); } void release () { if ( this -> ptr_ ) { :: batt_unpin_object_helper ( this -> ptr_ ); this -> ptr_ = nullptr ; } } T * get () const { return this -> ptr_ ; } T & operator * () const { return * this -> get (); } T * operator -> () const { return this -> get (); } private : T * ptr_ ; }; template < typename T > inline Pin < T > make_pin ( T * object ) { return Pin < T > { object }; } template < typename T , typename U > inline bool operator == ( const Pin < T >& l , const Pin < U >& r ) { return l . get () == r . get (); } template < typename T , typename U > inline bool operator != ( const Pin < T >& l , const Pin < U >& r ) { return ! ( l == r ); } template < typename T > inline bool operator == ( const Pin < T >& l , std :: nullptr_t ) { return l . get () == nullptr ; } template < typename T > inline bool operator != ( const Pin < T >& l , std :: nullptr_t ) { return ! ( l == nullptr ); } template < typename U > inline bool operator == ( std :: nullptr_t , const Pin < U >& r ) { return nullptr == r . get (); } template < typename U > inline bool operator != ( std :: nullptr_t , const Pin < U >& r ) { return ! ( nullptr == r ); } } // namespace batt #endif // BATTERIES_ASYNC_PIN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/pointers_8hpp/","text":"batteries/pointers.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::NoopDeleter Defines \ud83d\udd17 Name BATTERIES_POINTERS_HPP Macro Documentation \ud83d\udd17 BATTERIES_POINTERS_HPP \ud83d\udd17 1 #define BATTERIES_POINTERS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_POINTERS_HPP #define BATTERIES_POINTERS_HPP #include <batteries/config.hpp> // #include <memory> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // struct NoopDeleter { template < typename T > void operator ()( T * ) const { // do nothing } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > using UniqueNonOwningPtr = std :: unique_ptr < T , NoopDeleter > ; } // namespace batt #endif // BATTERIES_POINTERS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/pointers.hpp"},{"location":"_autogen/Files/pointers_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/pointers_8hpp/#classes","text":"Name struct batt::NoopDeleter","title":"Classes"},{"location":"_autogen/Files/pointers_8hpp/#defines","text":"Name BATTERIES_POINTERS_HPP","title":"Defines"},{"location":"_autogen/Files/pointers_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/pointers_8hpp/#batteries_pointers_hpp","text":"1 #define BATTERIES_POINTERS_HPP()","title":"BATTERIES_POINTERS_HPP"},{"location":"_autogen/Files/pointers_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_POINTERS_HPP #define BATTERIES_POINTERS_HPP #include <batteries/config.hpp> // #include <memory> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // struct NoopDeleter { template < typename T > void operator ()( T * ) const { // do nothing } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > using UniqueNonOwningPtr = std :: unique_ptr < T , NoopDeleter > ; } // namespace batt #endif // BATTERIES_POINTERS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/prepend_8hpp/","text":"batteries/seq/prepend.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::PrependBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_PREPEND_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_PREPEND_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_PREPEND_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_PREPEND_HPP #define BATTERIES_SEQ_PREPEND_HPP #include <batteries/config.hpp> // #include <type_traits> namespace batt { namespace seq { template < typename Item > struct PrependBinder { Item item ; }; template < typename Item > inline auto prepend ( Item && item ) { static_assert ( std :: is_same_v < Item , std :: decay_t < Item >> , \"References may not be passed to batt::seq::prepend\" ); return PrependBinder < Item > { BATT_FORWARD ( item )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_PREPEND_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/prepend.hpp"},{"location":"_autogen/Files/prepend_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/prepend_8hpp/#classes","text":"Name struct batt::seq::PrependBinder","title":"Classes"},{"location":"_autogen/Files/prepend_8hpp/#defines","text":"Name BATTERIES_SEQ_PREPEND_HPP","title":"Defines"},{"location":"_autogen/Files/prepend_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/prepend_8hpp/#batteries_seq_prepend_hpp","text":"1 #define BATTERIES_SEQ_PREPEND_HPP()","title":"BATTERIES_SEQ_PREPEND_HPP"},{"location":"_autogen/Files/prepend_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_PREPEND_HPP #define BATTERIES_SEQ_PREPEND_HPP #include <batteries/config.hpp> // #include <type_traits> namespace batt { namespace seq { template < typename Item > struct PrependBinder { Item item ; }; template < typename Item > inline auto prepend ( Item && item ) { static_assert ( std :: is_same_v < Item , std :: decay_t < Item >> , \"References may not be passed to batt::seq::prepend\" ); return PrependBinder < Item > { BATT_FORWARD ( item )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_PREPEND_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/print__out_8hpp/","text":"batteries/seq/print_out.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::PrintOut Defines \ud83d\udd17 Name BATTERIES_SEQ_PRINT_OUT_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_PRINT_OUT_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_PRINT_OUT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_PRINT_OUT_HPP #define BATTERIES_SEQ_PRINT_OUT_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/seq/map.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/stream_util.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { // print_out // struct PrintOut { std :: ostream & out ; std :: string_view sep ; }; inline auto print_out ( std :: ostream & out , std :: string_view sep = \" \" ) { return PrintOut { out , sep }; } template < typename Seq , typename = EnableIfSeq < Seq >> inline auto operator | ( Seq && seq , PrintOut p ) { return BATT_FORWARD ( seq ) | for_each ([ & ]( auto && item ) { p . out << item << p . sep ; }); } inline auto debug_out ( std :: ostream & out , std :: string_view sep = \" \" ) { return map ([ & out , sep ]( auto && item ) -> auto { out << item << sep ; return BATT_FORWARD ( item ); }); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_PRINT_OUT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/print_out.hpp"},{"location":"_autogen/Files/print__out_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/print__out_8hpp/#classes","text":"Name struct batt::seq::PrintOut","title":"Classes"},{"location":"_autogen/Files/print__out_8hpp/#defines","text":"Name BATTERIES_SEQ_PRINT_OUT_HPP","title":"Defines"},{"location":"_autogen/Files/print__out_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/print__out_8hpp/#batteries_seq_print_out_hpp","text":"1 #define BATTERIES_SEQ_PRINT_OUT_HPP()","title":"BATTERIES_SEQ_PRINT_OUT_HPP"},{"location":"_autogen/Files/print__out_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_PRINT_OUT_HPP #define BATTERIES_SEQ_PRINT_OUT_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/seq/map.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/stream_util.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { // print_out // struct PrintOut { std :: ostream & out ; std :: string_view sep ; }; inline auto print_out ( std :: ostream & out , std :: string_view sep = \" \" ) { return PrintOut { out , sep }; } template < typename Seq , typename = EnableIfSeq < Seq >> inline auto operator | ( Seq && seq , PrintOut p ) { return BATT_FORWARD ( seq ) | for_each ([ & ]( auto && item ) { p . out << item << p . sep ; }); } inline auto debug_out ( std :: ostream & out , std :: string_view sep = \" \" ) { return map ([ & out , sep ]( auto && item ) -> auto { out << item << sep ; return BATT_FORWARD ( item ); }); } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_PRINT_OUT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/printable_8hpp/","text":"batteries/seq/printable.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::Printable struct batt::seq::PrintableBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_PRINTABLE_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_PRINTABLE_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_PRINTABLE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_PRINTABLE_HPP #define BATTERIES_SEQ_PRINTABLE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/optional.hpp> #include <batteries/seq/print_out.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { template < typename Seq > class Printable { public : using Item = SeqItem < Seq > ; explicit Printable ( Seq && seq ) noexcept : seq_ ( BATT_FORWARD ( seq )) { } Optional < Item > peek () { return this -> seq_ . peek (); } Optional < Item > next () { return this -> seq_ . next (); } void operator ()( std :: ostream & out ) { batt :: make_copy ( * this ) // | map ( BATT_OVERLOADS_OF ( batt :: make_printable )) // | print_out ( out ); } private : Seq seq_ ; }; struct PrintableBinder { }; inline PrintableBinder printable () { return {}; } template < typename Seq > inline auto operator | ( Seq && seq , PrintableBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Sequences may not be captured by reference.\" ); return Printable < Seq > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_PRINTABLE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/printable.hpp"},{"location":"_autogen/Files/printable_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/printable_8hpp/#classes","text":"Name class batt::seq::Printable struct batt::seq::PrintableBinder","title":"Classes"},{"location":"_autogen/Files/printable_8hpp/#defines","text":"Name BATTERIES_SEQ_PRINTABLE_HPP","title":"Defines"},{"location":"_autogen/Files/printable_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/printable_8hpp/#batteries_seq_printable_hpp","text":"1 #define BATTERIES_SEQ_PRINTABLE_HPP()","title":"BATTERIES_SEQ_PRINTABLE_HPP"},{"location":"_autogen/Files/printable_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_PRINTABLE_HPP #define BATTERIES_SEQ_PRINTABLE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/optional.hpp> #include <batteries/seq/print_out.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { template < typename Seq > class Printable { public : using Item = SeqItem < Seq > ; explicit Printable ( Seq && seq ) noexcept : seq_ ( BATT_FORWARD ( seq )) { } Optional < Item > peek () { return this -> seq_ . peek (); } Optional < Item > next () { return this -> seq_ . next (); } void operator ()( std :: ostream & out ) { batt :: make_copy ( * this ) // | map ( BATT_OVERLOADS_OF ( batt :: make_printable )) // | print_out ( out ); } private : Seq seq_ ; }; struct PrintableBinder { }; inline PrintableBinder printable () { return {}; } template < typename Seq > inline auto operator | ( Seq && seq , PrintableBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Sequences may not be captured by reference.\" ); return Printable < Seq > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_PRINTABLE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/queue_8hpp/","text":"batteries/async/queue.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::QueueBase class batt::Queue Defines \ud83d\udd17 Name BATTERIES_ASYNC_QUEUE_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_QUEUE_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_QUEUE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_QUEUE_HPP #define BATTERIES_ASYNC_QUEUE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/mutex.hpp> #include <batteries/async/watch.hpp> #include <batteries/finally.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> #include <deque> namespace batt { class QueueBase { public : bool is_open () const { return ! this -> pending_count_ . is_closed (); } bool is_closed () const { return ! this -> is_open (); } i64 size () const { return this -> pending_count_ . get_value (); } bool empty () const { return this -> size () == 0 ; } template < typename Predicate = bool ( i64 ) > StatusOr < i64 > await_size_is_truly ( Predicate && predicate ) { return this -> pending_count_ . await_true ( BATT_FORWARD ( predicate )); } StatusOr < i64 > await_empty () { return this -> await_size_is_truly ([]( i64 count ) { BATT_ASSERT_GE ( count , 0 ); return count == 0 ; }); } void close () { this -> pending_count_ . close (); } protected : Status await_one () noexcept { StatusOr < i64 > prior_count = this -> pending_count_ . await_modify ( & decrement_if_positive ); BATT_REQUIRE_OK ( prior_count ); BATT_CHECK_GT ( * prior_count , 0 ); return OkStatus (); } bool try_acquire () noexcept { Optional < i64 > prior_count = this -> pending_count_ . modify_if ( & decrement_if_positive ); if ( ! prior_count ) { return false ; } BATT_CHECK_GT ( * prior_count , 0 ); return true ; } void notify ( i64 count ) { this -> pending_count_ . fetch_add ( count ); } private : static Optional < i64 > decrement_if_positive ( i64 n ) noexcept { if ( n > 0 ) { return n - 1 ; } return None ; } Watch < i64 > pending_count_ { 0 }; }; template < typename T > class Queue : public QueueBase { public : template < typename ... Args > bool push ( Args && ... args ) { if ( ! this -> is_open ()) { return false ; } this -> pending_items_ . lock () -> emplace_back ( BATT_FORWARD ( args )...); this -> notify ( 1 ); return true ; } template < typename FactoryFn > bool push_with_lock ( FactoryFn && factory_fn ) { if ( ! this -> is_open ()) { return false ; } { auto locked = this -> pending_items_ . lock (); locked -> emplace_back ( BATT_FORWARD ( factory_fn )()); } this -> notify ( 1 ); return true ; } // `items` should be an STL sequence; i.e., something that can be iterated via a for-each loop. // template < typename Items > bool push_all ( Items && items ) { if ( ! this -> is_open ()) { return false ; } const usize count = std :: distance ( std :: begin ( items ), std :: end ( items )); this -> pending_items_ . with_lock ([ & ]( auto & pending ) { pending . insert ( pending . end (), std :: begin ( items ), std :: end ( items )); }); this -> notify ( count ); return true ; } StatusOr < T > await_next () { Status acquired = this -> await_one (); BATT_REQUIRE_OK ( acquired ); return this -> pop_next_or_panic (); } Optional < T > try_pop_next () { if ( ! this -> try_acquire ()) { return None ; } return this -> pop_next_or_panic (); } T pop_next_or_panic () { auto locked = this -> pending_items_ . lock (); BATT_CHECK ( ! locked -> empty ()) << \"pop_next_or_panic FAILED because the queue is empty\" ; auto on_return = batt :: finally ([ & ] { locked -> pop_front (); }); return std :: forward < T > ( locked -> front ()); } usize drain () { usize count = 0 ; while ( this -> try_pop_next ()) { ++ count ; } return count ; } private : Mutex < std :: deque < T >> pending_items_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_QUEUE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/queue.hpp"},{"location":"_autogen/Files/queue_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/queue_8hpp/#classes","text":"Name class batt::QueueBase class batt::Queue","title":"Classes"},{"location":"_autogen/Files/queue_8hpp/#defines","text":"Name BATTERIES_ASYNC_QUEUE_HPP","title":"Defines"},{"location":"_autogen/Files/queue_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/queue_8hpp/#batteries_async_queue_hpp","text":"1 #define BATTERIES_ASYNC_QUEUE_HPP()","title":"BATTERIES_ASYNC_QUEUE_HPP"},{"location":"_autogen/Files/queue_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_QUEUE_HPP #define BATTERIES_ASYNC_QUEUE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/mutex.hpp> #include <batteries/async/watch.hpp> #include <batteries/finally.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> #include <deque> namespace batt { class QueueBase { public : bool is_open () const { return ! this -> pending_count_ . is_closed (); } bool is_closed () const { return ! this -> is_open (); } i64 size () const { return this -> pending_count_ . get_value (); } bool empty () const { return this -> size () == 0 ; } template < typename Predicate = bool ( i64 ) > StatusOr < i64 > await_size_is_truly ( Predicate && predicate ) { return this -> pending_count_ . await_true ( BATT_FORWARD ( predicate )); } StatusOr < i64 > await_empty () { return this -> await_size_is_truly ([]( i64 count ) { BATT_ASSERT_GE ( count , 0 ); return count == 0 ; }); } void close () { this -> pending_count_ . close (); } protected : Status await_one () noexcept { StatusOr < i64 > prior_count = this -> pending_count_ . await_modify ( & decrement_if_positive ); BATT_REQUIRE_OK ( prior_count ); BATT_CHECK_GT ( * prior_count , 0 ); return OkStatus (); } bool try_acquire () noexcept { Optional < i64 > prior_count = this -> pending_count_ . modify_if ( & decrement_if_positive ); if ( ! prior_count ) { return false ; } BATT_CHECK_GT ( * prior_count , 0 ); return true ; } void notify ( i64 count ) { this -> pending_count_ . fetch_add ( count ); } private : static Optional < i64 > decrement_if_positive ( i64 n ) noexcept { if ( n > 0 ) { return n - 1 ; } return None ; } Watch < i64 > pending_count_ { 0 }; }; template < typename T > class Queue : public QueueBase { public : template < typename ... Args > bool push ( Args && ... args ) { if ( ! this -> is_open ()) { return false ; } this -> pending_items_ . lock () -> emplace_back ( BATT_FORWARD ( args )...); this -> notify ( 1 ); return true ; } template < typename FactoryFn > bool push_with_lock ( FactoryFn && factory_fn ) { if ( ! this -> is_open ()) { return false ; } { auto locked = this -> pending_items_ . lock (); locked -> emplace_back ( BATT_FORWARD ( factory_fn )()); } this -> notify ( 1 ); return true ; } // `items` should be an STL sequence; i.e., something that can be iterated via a for-each loop. // template < typename Items > bool push_all ( Items && items ) { if ( ! this -> is_open ()) { return false ; } const usize count = std :: distance ( std :: begin ( items ), std :: end ( items )); this -> pending_items_ . with_lock ([ & ]( auto & pending ) { pending . insert ( pending . end (), std :: begin ( items ), std :: end ( items )); }); this -> notify ( count ); return true ; } StatusOr < T > await_next () { Status acquired = this -> await_one (); BATT_REQUIRE_OK ( acquired ); return this -> pop_next_or_panic (); } Optional < T > try_pop_next () { if ( ! this -> try_acquire ()) { return None ; } return this -> pop_next_or_panic (); } T pop_next_or_panic () { auto locked = this -> pending_items_ . lock (); BATT_CHECK ( ! locked -> empty ()) << \"pop_next_or_panic FAILED because the queue is empty\" ; auto on_return = batt :: finally ([ & ] { locked -> pop_front (); }); return std :: forward < T > ( locked -> front ()); } usize drain () { usize count = 0 ; while ( this -> try_pop_next ()) { ++ count ; } return count ; } private : Mutex < std :: deque < T >> pending_items_ ; }; } // namespace batt #endif // BATTERIES_ASYNC_QUEUE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/radix__queue_8hpp/","text":"batteries/radix_queue.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::RadixQueue class batt::RadixQueue struct batt::RadixQueue::Segment struct batt::RadixQueue::Hash Defines \ud83d\udd17 Name BATTERIES_RADIX_QUEUE_HPP Macro Documentation \ud83d\udd17 BATTERIES_RADIX_QUEUE_HPP \ud83d\udd17 1 #define BATTERIES_RADIX_QUEUE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_RADIX_QUEUE_HPP #define BATTERIES_RADIX_QUEUE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <boost/functional/hash.hpp> #include <boost/operators.hpp> #include <array> #include <limits> #include <type_traits> namespace batt { template < usize kCapacityInBits > class RadixQueue ; template < usize N_ > std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ >& t ); // A fixed-capacity FIFO queue of integers with variable radix per integer. This is used to store sequences // of events. // template < usize kCapacityInBits > class RadixQueue : public boost :: equality_comparable < RadixQueue < kCapacityInBits >> { public : static constexpr usize kQueueSize = kCapacityInBits / 64 ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - using index_type = std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u16 >:: max ()), std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u8 >:: max ()), u8 , u16 > , std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u32 >:: max ()), u32 , u64 >> ; // The queue is stored in segments of 64 bits each. // struct Segment { u64 radix = 1 ; u64 value = 0 ; friend inline std :: ostream & operator << ( std :: ostream & out , const Segment & t ) { return out << \"{.value=\" << t . value << \", .radix=\" << t . radix << \"}\" ; } }; // Default hash function. // struct Hash { using value_type = usize ; usize operator ()( const RadixQueue & r ) const { const usize size = r . queue_size (); usize seed = size ; for ( usize i = 0 ; i < size ; ++ i ) { const usize j = ( r . front_ + i ) % kQueueSize ; boost :: hash_combine ( seed , r . queue_ [ j ]. radix ); boost :: hash_combine ( seed , r . queue_ [ j ]. value ); } return seed ; } }; bool operator == ( const RadixQueue & other ) const { const usize size = this -> queue_size (); if ( size != other . queue_size ()) { return false ; } for ( usize i = 0 ; i < size ; ++ i ) { const usize this_j = ( this -> front_ + i ) % kQueueSize ; const usize other_j = ( other . front_ + i ) % kQueueSize ; if ( this -> queue_ [ this_j ]. radix != other . queue_ [ other_j ]. radix || this -> queue_ [ this_j ]. value != other . queue_ [ other_j ]. value ) { return false ; } } return true ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - RadixQueue () = default ; // Returns true when there are no items in the queue. // bool empty () const { return this -> queue_size () == 1 && this -> front (). radix == 1 ; } // Returns true when the queue has reached its maximum capacity. // bool full () const { return this -> front_ == ( this -> back_ + 1 ) % kQueueSize ; } // Discards the contents of the queue, resetting it to default state. // void clear () { this -> front_ = 0 ; this -> back_ = 0 ; this -> queue_ [ 0 ] = Segment {}; } // Insert the given value with the given radix at the back of the queue. // void push ( u64 radix , u64 value ) { BATT_CHECK_GT ( radix , value ) << \"value must not exceed the supplied radix\" ; const bool would_overflow = std :: numeric_limits < u64 >:: max () / this -> back (). radix < radix ; if ( would_overflow ) { this -> push_back (); } Segment & s = this -> back (); s . value += value * s . radix ; s . radix *= radix ; } // Extract the next value out of the queue. The passed radix must match the radix used when inserting // the item originally; otherwise behavior is undefined. // u64 pop ( u64 radix ) { Segment & s = this -> front (); BATT_CHECK_LE ( radix , s . radix ) << \"the supplied radix is too large\" ; const u64 value = s . value % radix ; s . radix /= radix ; s . value /= radix ; BATT_CHECK_LT ( s . value , s . radix ); if ( s . radix == 1 && this -> queue_size () > 1 ) { this -> pop_front (); } return value ; } template < usize N_ > friend std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ >& t ); private : static void advance_index ( index_type * i ) { * i = ( * i + 1 ) % kQueueSize ; } usize queue_size () const { const usize upper_bound = [ & ]() -> usize { if ( this -> front_ <= this -> back_ ) { return this -> back_ + 1 ; } return kQueueSize + this -> back_ + 1 ; }(); BATT_CHECK_LT ( this -> front_ , upper_bound ); return upper_bound - this -> front_ ; } Segment & front () { return this -> queue_ [ this -> front_ ]; } const Segment & front () const { return this -> queue_ [ this -> front_ ]; } Segment & back () { return this -> queue_ [ this -> back_ ]; } const Segment & back () const { return this -> queue_ [ this -> back_ ]; } void pop_front () { BATT_CHECK_NE ( this -> front_ , this -> back_ ) << \"pull failed; the RadixQueue is empty\" ; advance_index ( & this -> front_ ); } void push_back () { BATT_CHECK ( ! this -> full ()) << \"push failed; the RadixQueue is full\" ; advance_index ( & this -> back_ ); this -> queue_ [ this -> back_ ] = Segment {}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - index_type front_ = 0 ; index_type back_ = 0 ; std :: array < Segment , kQueueSize > queue_ ; }; template < usize N_ > inline std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ >& t ) { usize end = ( t . front_ <= t . back_ ) ? ( t . back_ + 1 ) : ( t . back_ + 1 + t . queue_ . size ()); out << \"{\" ; for ( usize i = t . front_ ; i < end ; ++ i ) { const auto & s = t . queue_ [ i % t . queue_ . size ()]; out << s . value << \"/\" << s . radix << \",\" ; } return out << \"}\" ; } } // namespace batt #endif // BATTERIES_RADIX_QUEUE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/radix_queue.hpp"},{"location":"_autogen/Files/radix__queue_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/radix__queue_8hpp/#classes","text":"Name class batt::RadixQueue class batt::RadixQueue struct batt::RadixQueue::Segment struct batt::RadixQueue::Hash","title":"Classes"},{"location":"_autogen/Files/radix__queue_8hpp/#defines","text":"Name BATTERIES_RADIX_QUEUE_HPP","title":"Defines"},{"location":"_autogen/Files/radix__queue_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/radix__queue_8hpp/#batteries_radix_queue_hpp","text":"1 #define BATTERIES_RADIX_QUEUE_HPP()","title":"BATTERIES_RADIX_QUEUE_HPP"},{"location":"_autogen/Files/radix__queue_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_RADIX_QUEUE_HPP #define BATTERIES_RADIX_QUEUE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <boost/functional/hash.hpp> #include <boost/operators.hpp> #include <array> #include <limits> #include <type_traits> namespace batt { template < usize kCapacityInBits > class RadixQueue ; template < usize N_ > std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ >& t ); // A fixed-capacity FIFO queue of integers with variable radix per integer. This is used to store sequences // of events. // template < usize kCapacityInBits > class RadixQueue : public boost :: equality_comparable < RadixQueue < kCapacityInBits >> { public : static constexpr usize kQueueSize = kCapacityInBits / 64 ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - using index_type = std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u16 >:: max ()), std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u8 >:: max ()), u8 , u16 > , std :: conditional_t < ( kCapacityInBits <= std :: numeric_limits < u32 >:: max ()), u32 , u64 >> ; // The queue is stored in segments of 64 bits each. // struct Segment { u64 radix = 1 ; u64 value = 0 ; friend inline std :: ostream & operator << ( std :: ostream & out , const Segment & t ) { return out << \"{.value=\" << t . value << \", .radix=\" << t . radix << \"}\" ; } }; // Default hash function. // struct Hash { using value_type = usize ; usize operator ()( const RadixQueue & r ) const { const usize size = r . queue_size (); usize seed = size ; for ( usize i = 0 ; i < size ; ++ i ) { const usize j = ( r . front_ + i ) % kQueueSize ; boost :: hash_combine ( seed , r . queue_ [ j ]. radix ); boost :: hash_combine ( seed , r . queue_ [ j ]. value ); } return seed ; } }; bool operator == ( const RadixQueue & other ) const { const usize size = this -> queue_size (); if ( size != other . queue_size ()) { return false ; } for ( usize i = 0 ; i < size ; ++ i ) { const usize this_j = ( this -> front_ + i ) % kQueueSize ; const usize other_j = ( other . front_ + i ) % kQueueSize ; if ( this -> queue_ [ this_j ]. radix != other . queue_ [ other_j ]. radix || this -> queue_ [ this_j ]. value != other . queue_ [ other_j ]. value ) { return false ; } } return true ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - RadixQueue () = default ; // Returns true when there are no items in the queue. // bool empty () const { return this -> queue_size () == 1 && this -> front (). radix == 1 ; } // Returns true when the queue has reached its maximum capacity. // bool full () const { return this -> front_ == ( this -> back_ + 1 ) % kQueueSize ; } // Discards the contents of the queue, resetting it to default state. // void clear () { this -> front_ = 0 ; this -> back_ = 0 ; this -> queue_ [ 0 ] = Segment {}; } // Insert the given value with the given radix at the back of the queue. // void push ( u64 radix , u64 value ) { BATT_CHECK_GT ( radix , value ) << \"value must not exceed the supplied radix\" ; const bool would_overflow = std :: numeric_limits < u64 >:: max () / this -> back (). radix < radix ; if ( would_overflow ) { this -> push_back (); } Segment & s = this -> back (); s . value += value * s . radix ; s . radix *= radix ; } // Extract the next value out of the queue. The passed radix must match the radix used when inserting // the item originally; otherwise behavior is undefined. // u64 pop ( u64 radix ) { Segment & s = this -> front (); BATT_CHECK_LE ( radix , s . radix ) << \"the supplied radix is too large\" ; const u64 value = s . value % radix ; s . radix /= radix ; s . value /= radix ; BATT_CHECK_LT ( s . value , s . radix ); if ( s . radix == 1 && this -> queue_size () > 1 ) { this -> pop_front (); } return value ; } template < usize N_ > friend std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ >& t ); private : static void advance_index ( index_type * i ) { * i = ( * i + 1 ) % kQueueSize ; } usize queue_size () const { const usize upper_bound = [ & ]() -> usize { if ( this -> front_ <= this -> back_ ) { return this -> back_ + 1 ; } return kQueueSize + this -> back_ + 1 ; }(); BATT_CHECK_LT ( this -> front_ , upper_bound ); return upper_bound - this -> front_ ; } Segment & front () { return this -> queue_ [ this -> front_ ]; } const Segment & front () const { return this -> queue_ [ this -> front_ ]; } Segment & back () { return this -> queue_ [ this -> back_ ]; } const Segment & back () const { return this -> queue_ [ this -> back_ ]; } void pop_front () { BATT_CHECK_NE ( this -> front_ , this -> back_ ) << \"pull failed; the RadixQueue is empty\" ; advance_index ( & this -> front_ ); } void push_back () { BATT_CHECK ( ! this -> full ()) << \"push failed; the RadixQueue is full\" ; advance_index ( & this -> back_ ); this -> queue_ [ this -> back_ ] = Segment {}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - index_type front_ = 0 ; index_type back_ = 0 ; std :: array < Segment , kQueueSize > queue_ ; }; template < usize N_ > inline std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ >& t ) { usize end = ( t . front_ <= t . back_ ) ? ( t . back_ + 1 ) : ( t . back_ + 1 + t . queue_ . size ()); out << \"{\" ; for ( usize i = t . front_ ; i < end ; ++ i ) { const auto & s = t . queue_ [ i % t . queue_ . size ()]; out << s . value << \"/\" << s . radix << \",\" ; } return out << \"}\" ; } } // namespace batt #endif // BATTERIES_RADIX_QUEUE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/rate__limiter_8hpp/","text":"batteries/async/rate_limiter.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::BasicRateLimiter Defines \ud83d\udd17 Name BATTERIES_ASYNC_RATE_LIMITER_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_RATE_LIMITER_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_RATE_LIMITER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_RATE_LIMITER_HPP #define BATTERIES_ASYNC_RATE_LIMITER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <chrono> namespace batt { template < typename Clock > class BasicRateLimiter { public : // `rate` - the limit rate in operations per second // `burst` - the number of \"unspent\" operations we allow to accumulate for immediate consumption; // 1 means there is no burst capability, >1 means that a client can temporarily perform up to // `burst` operations immediately, assuming there is enough time in the past to cover those ops. // explicit BasicRateLimiter ( double rate , i64 burst = 1 ) noexcept : rate_ { rate }, burst_ { burst } { } // Performs a non-blocking check to see whether enough time has elapsed for us to consume one // count. If so, consume the count and return true, else return false. // bool poll () { const i64 current_upper_bound = this -> get_current_upper_bound (); if ( current_upper_bound - this -> count_ > this -> burst_ ) { this -> count_ = current_upper_bound - this -> burst_ ; } if ( this -> count_ == current_upper_bound ) { return false ; } this -> count_ += 1 ; BATT_CHECK_LE ( this -> count_ , current_upper_bound ); return true ; } // Returns the amount of accumulated count available for consumption. // i64 available () const { return std :: clamp < i64 > ( this -> get_current_upper_bound () - this -> count_ , 0 , this -> burst_ ); } // How many seconds until the next allowed operation. May return a negative value if `poll()` will return // `true`. // double time_remaining_sec () const { return static_cast < double > ( this -> count_ + 1 ) / this -> rate_ - this -> elapsed_sec (); } // The total elapsed time since this object was created, in microseconds. // double elapsed_usec () const { return static_cast < double > ( std :: max < i64 > ( 0 , std :: chrono :: duration_cast < std :: chrono :: microseconds > ( Clock :: now () - this -> start_ ). count ())); } // The total elapsed time since this object was created, in seconds. // double elapsed_sec () const { return this -> elapsed_usec () / double { 1000.0 * 1000.0 }; } // The minimum allowed amortized time between operations. // double period_sec () const { return double { 1.0 } / this -> rate_ ; } //+++++++++++-+-+--+----- --- -- - - - - private : i64 get_current_upper_bound () const { return static_cast < i64 > ( this -> elapsed_sec () * this -> rate_ ); } //+++++++++++-+-+--+----- --- -- - - - - // The creation time of this object. // typename Clock :: time_point start_ = Clock :: now (); // The number of operations performed (i.e., the number of times `poll()` returned 1). // i64 count_ = 0 ; // The number of allowed _amortized_ operations per second. // double rate_ ; // The maximum amortization factor -- how many operations can be performed immediately if we wait // for `burst_ * rate_` seconds. // i64 burst_ ; }; using RateLimiter = BasicRateLimiter < std :: chrono :: steady_clock > ; } // namespace batt #endif // BATTERIES_ASYNC_RATE_LIMITER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/rate_limiter.hpp"},{"location":"_autogen/Files/rate__limiter_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/rate__limiter_8hpp/#classes","text":"Name class batt::BasicRateLimiter","title":"Classes"},{"location":"_autogen/Files/rate__limiter_8hpp/#defines","text":"Name BATTERIES_ASYNC_RATE_LIMITER_HPP","title":"Defines"},{"location":"_autogen/Files/rate__limiter_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/rate__limiter_8hpp/#batteries_async_rate_limiter_hpp","text":"1 #define BATTERIES_ASYNC_RATE_LIMITER_HPP()","title":"BATTERIES_ASYNC_RATE_LIMITER_HPP"},{"location":"_autogen/Files/rate__limiter_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_RATE_LIMITER_HPP #define BATTERIES_ASYNC_RATE_LIMITER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <algorithm> #include <chrono> namespace batt { template < typename Clock > class BasicRateLimiter { public : // `rate` - the limit rate in operations per second // `burst` - the number of \"unspent\" operations we allow to accumulate for immediate consumption; // 1 means there is no burst capability, >1 means that a client can temporarily perform up to // `burst` operations immediately, assuming there is enough time in the past to cover those ops. // explicit BasicRateLimiter ( double rate , i64 burst = 1 ) noexcept : rate_ { rate }, burst_ { burst } { } // Performs a non-blocking check to see whether enough time has elapsed for us to consume one // count. If so, consume the count and return true, else return false. // bool poll () { const i64 current_upper_bound = this -> get_current_upper_bound (); if ( current_upper_bound - this -> count_ > this -> burst_ ) { this -> count_ = current_upper_bound - this -> burst_ ; } if ( this -> count_ == current_upper_bound ) { return false ; } this -> count_ += 1 ; BATT_CHECK_LE ( this -> count_ , current_upper_bound ); return true ; } // Returns the amount of accumulated count available for consumption. // i64 available () const { return std :: clamp < i64 > ( this -> get_current_upper_bound () - this -> count_ , 0 , this -> burst_ ); } // How many seconds until the next allowed operation. May return a negative value if `poll()` will return // `true`. // double time_remaining_sec () const { return static_cast < double > ( this -> count_ + 1 ) / this -> rate_ - this -> elapsed_sec (); } // The total elapsed time since this object was created, in microseconds. // double elapsed_usec () const { return static_cast < double > ( std :: max < i64 > ( 0 , std :: chrono :: duration_cast < std :: chrono :: microseconds > ( Clock :: now () - this -> start_ ). count ())); } // The total elapsed time since this object was created, in seconds. // double elapsed_sec () const { return this -> elapsed_usec () / double { 1000.0 * 1000.0 }; } // The minimum allowed amortized time between operations. // double period_sec () const { return double { 1.0 } / this -> rate_ ; } //+++++++++++-+-+--+----- --- -- - - - - private : i64 get_current_upper_bound () const { return static_cast < i64 > ( this -> elapsed_sec () * this -> rate_ ); } //+++++++++++-+-+--+----- --- -- - - - - // The creation time of this object. // typename Clock :: time_point start_ = Clock :: now (); // The number of operations performed (i.e., the number of times `poll()` returned 1). // i64 count_ = 0 ; // The number of allowed _amortized_ operations per second. // double rate_ ; // The maximum amortization factor -- how many operations can be performed immediately if we wait // for `burst_ * rate_` seconds. // i64 burst_ ; }; using RateLimiter = BasicRateLimiter < std :: chrono :: steady_clock > ; } // namespace batt #endif // BATTERIES_ASYNC_RATE_LIMITER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/reduce_8hpp/","text":"batteries/seq/reduce.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::ReduceBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_REDUCE_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_REDUCE_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_REDUCE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_REDUCE_HPP #define BATTERIES_SEQ_REDUCE_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // reduce // template < typename State , typename ReduceFn > struct ReduceBinder { State state ; ReduceFn reduce_fn ; }; template < typename State , typename ReduceFn > ReduceBinder < State , ReduceFn > reduce ( State && state , ReduceFn && reduce_fn ) { return { BATT_FORWARD ( state ), BATT_FORWARD ( reduce_fn )}; } template < typename Seq , typename State , typename ReduceFn > [[ nodiscard ]] State operator | ( Seq && seq , ReduceBinder < State , ReduceFn > binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::reduce) Sequences may not be captured implicitly by reference.\" ); BATT_FORWARD ( seq ) | for_each ([ & binder ]( auto && item ) { binder . state = binder . reduce_fn ( binder . state , BATT_FORWARD ( item )); }); return binder . state ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_REDUCE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/reduce.hpp"},{"location":"_autogen/Files/reduce_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/reduce_8hpp/#classes","text":"Name struct batt::seq::ReduceBinder","title":"Classes"},{"location":"_autogen/Files/reduce_8hpp/#defines","text":"Name BATTERIES_SEQ_REDUCE_HPP","title":"Defines"},{"location":"_autogen/Files/reduce_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/reduce_8hpp/#batteries_seq_reduce_hpp","text":"1 #define BATTERIES_SEQ_REDUCE_HPP()","title":"BATTERIES_SEQ_REDUCE_HPP"},{"location":"_autogen/Files/reduce_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_REDUCE_HPP #define BATTERIES_SEQ_REDUCE_HPP #include <batteries/config.hpp> // #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // reduce // template < typename State , typename ReduceFn > struct ReduceBinder { State state ; ReduceFn reduce_fn ; }; template < typename State , typename ReduceFn > ReduceBinder < State , ReduceFn > reduce ( State && state , ReduceFn && reduce_fn ) { return { BATT_FORWARD ( state ), BATT_FORWARD ( reduce_fn )}; } template < typename Seq , typename State , typename ReduceFn > [[ nodiscard ]] State operator | ( Seq && seq , ReduceBinder < State , ReduceFn > binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::reduce) Sequences may not be captured implicitly by reference.\" ); BATT_FORWARD ( seq ) | for_each ([ & binder ]( auto && item ) { binder . state = binder . reduce_fn ( binder . state , BATT_FORWARD ( item )); }); return binder . state ; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_REDUCE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/ref_8hpp/","text":"batteries/ref.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Ref Defines \ud83d\udd17 Name BATTERIES_REF_HPP BATT_REF_DELEGATE_MEMFUN (name, qualifiers) Macro Documentation \ud83d\udd17 BATTERIES_REF_HPP \ud83d\udd17 1 #define BATTERIES_REF_HPP() BATT_REF_DELEGATE_MEMFUN \ud83d\udd17 1 #define BATT_REF_DELEGATE_MEMFUN(name, qualifiers) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_REF_HPP #define BATTERIES_REF_HPP #include <batteries/config.hpp> // #include <batteries/seq.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <ostream> #include <tuple> #include <type_traits> namespace batt { template < typename T > class Ref { public : using Item = typename std :: conditional_t < batt :: HasSeqRequirements < T > {}, // /*then*/ batt :: SeqItem_Impl < T > , /*else*/ batt :: StaticType < void >>:: type ; template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> /*implicit*/ Ref ( U & obj_ref ) noexcept : ptr_ { & obj_ref } { } Ref () noexcept : ptr_ { nullptr } { } template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> Ref ( const Ref < U >& that ) noexcept : ptr_ { that . ptr_ } { } template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> Ref & operator = ( const Ref < U >& that ) noexcept { this -> ptr_ = that . ptr_ ; return * this ; } bool is_valid () const { return this -> ptr_ != nullptr ; } T & get () const { return * this -> ptr_ ; } T * pointer () const { return this -> ptr_ ; } /*implicit*/ operator T & () const { return * this -> ptr_ ; } template < typename ... Args , typename = std :: enable_if_t <! std :: is_same_v < std :: tuple < std :: ostream &> , std :: tuple < Args ... >>>> decltype ( auto ) operator ()( Args && ... args ) const noexcept ( noexcept (( * std :: declval < const Ref *> () -> ptr_ )( BATT_FORWARD ( args )...))) { return ( * this -> ptr_ )( BATT_FORWARD ( args )...); } #define BATT_REF_DELEGATE_MEMFUN(name, qualifiers) \\ template <typename... Args> \\ decltype(auto) name(Args&&... args) qualifiers \\ { \\ return this->ptr_->name(BATT_FORWARD(args)...); \\ } BATT_REF_DELEGATE_MEMFUN ( poll , const ) BATT_REF_DELEGATE_MEMFUN ( poll , ) BATT_REF_DELEGATE_MEMFUN ( peek , const ) BATT_REF_DELEGATE_MEMFUN ( peek , ) BATT_REF_DELEGATE_MEMFUN ( next , const ) BATT_REF_DELEGATE_MEMFUN ( next , ) BATT_REF_DELEGATE_MEMFUN ( push_frame , const ) BATT_REF_DELEGATE_MEMFUN ( await_frame_consumed , const ) BATT_REF_DELEGATE_MEMFUN ( Update , const ) BATT_REF_DELEGATE_MEMFUN ( ok , const ) BATT_REF_DELEGATE_MEMFUN ( recycle_pages , const ) BATT_REF_DELEGATE_MEMFUN ( await_flush , const ) #undef BATT_REF_DELEGATE_MEMFUN private : T * ptr_ ; }; template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Ref < T >& t ) { return out << t . get (); } template < typename T > Ref < T > as_ref ( T & obj_ref ) { return Ref < T > { obj_ref }; } template < typename T > Ref < const T > as_cref ( const T & obj_ref ) { return Ref < const T > { obj_ref }; } template < typename T > Ref < T > into_ref ( T * ptr ) { return as_ref ( * ptr ); } template < typename T > Ref < const T > into_cref ( const T * ptr ) { return as_ref ( * ptr ); } template < typename T > T & unwrap_ref ( const Ref < T >& wrapper ) { return wrapper . get (); } } // namespace batt #endif // BATTERIES_REF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/ref.hpp"},{"location":"_autogen/Files/ref_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/ref_8hpp/#classes","text":"Name class batt::Ref","title":"Classes"},{"location":"_autogen/Files/ref_8hpp/#defines","text":"Name BATTERIES_REF_HPP BATT_REF_DELEGATE_MEMFUN (name, qualifiers)","title":"Defines"},{"location":"_autogen/Files/ref_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/ref_8hpp/#batteries_ref_hpp","text":"1 #define BATTERIES_REF_HPP()","title":"BATTERIES_REF_HPP"},{"location":"_autogen/Files/ref_8hpp/#batt_ref_delegate_memfun","text":"1 #define BATT_REF_DELEGATE_MEMFUN(name, qualifiers)","title":"BATT_REF_DELEGATE_MEMFUN"},{"location":"_autogen/Files/ref_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_REF_HPP #define BATTERIES_REF_HPP #include <batteries/config.hpp> // #include <batteries/seq.hpp> #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <ostream> #include <tuple> #include <type_traits> namespace batt { template < typename T > class Ref { public : using Item = typename std :: conditional_t < batt :: HasSeqRequirements < T > {}, // /*then*/ batt :: SeqItem_Impl < T > , /*else*/ batt :: StaticType < void >>:: type ; template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> /*implicit*/ Ref ( U & obj_ref ) noexcept : ptr_ { & obj_ref } { } Ref () noexcept : ptr_ { nullptr } { } template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> Ref ( const Ref < U >& that ) noexcept : ptr_ { that . ptr_ } { } template < typename U , typename = std :: enable_if_t < std :: is_constructible_v < T * , U *>>> Ref & operator = ( const Ref < U >& that ) noexcept { this -> ptr_ = that . ptr_ ; return * this ; } bool is_valid () const { return this -> ptr_ != nullptr ; } T & get () const { return * this -> ptr_ ; } T * pointer () const { return this -> ptr_ ; } /*implicit*/ operator T & () const { return * this -> ptr_ ; } template < typename ... Args , typename = std :: enable_if_t <! std :: is_same_v < std :: tuple < std :: ostream &> , std :: tuple < Args ... >>>> decltype ( auto ) operator ()( Args && ... args ) const noexcept ( noexcept (( * std :: declval < const Ref *> () -> ptr_ )( BATT_FORWARD ( args )...))) { return ( * this -> ptr_ )( BATT_FORWARD ( args )...); } #define BATT_REF_DELEGATE_MEMFUN(name, qualifiers) \\ template <typename... Args> \\ decltype(auto) name(Args&&... args) qualifiers \\ { \\ return this->ptr_->name(BATT_FORWARD(args)...); \\ } BATT_REF_DELEGATE_MEMFUN ( poll , const ) BATT_REF_DELEGATE_MEMFUN ( poll , ) BATT_REF_DELEGATE_MEMFUN ( peek , const ) BATT_REF_DELEGATE_MEMFUN ( peek , ) BATT_REF_DELEGATE_MEMFUN ( next , const ) BATT_REF_DELEGATE_MEMFUN ( next , ) BATT_REF_DELEGATE_MEMFUN ( push_frame , const ) BATT_REF_DELEGATE_MEMFUN ( await_frame_consumed , const ) BATT_REF_DELEGATE_MEMFUN ( Update , const ) BATT_REF_DELEGATE_MEMFUN ( ok , const ) BATT_REF_DELEGATE_MEMFUN ( recycle_pages , const ) BATT_REF_DELEGATE_MEMFUN ( await_flush , const ) #undef BATT_REF_DELEGATE_MEMFUN private : T * ptr_ ; }; template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Ref < T >& t ) { return out << t . get (); } template < typename T > Ref < T > as_ref ( T & obj_ref ) { return Ref < T > { obj_ref }; } template < typename T > Ref < const T > as_cref ( const T & obj_ref ) { return Ref < const T > { obj_ref }; } template < typename T > Ref < T > into_ref ( T * ptr ) { return as_ref ( * ptr ); } template < typename T > Ref < const T > into_cref ( const T * ptr ) { return as_ref ( * ptr ); } template < typename T > T & unwrap_ref ( const Ref < T >& wrapper ) { return wrapper . get (); } } // namespace batt #endif // BATTERIES_REF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/require_8hpp/","text":"batteries/require.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_REQUIRE_HPP BATT_REQUIRE_RELATION (left, op, right) BATT_REQUIRE_EQ (left, right) BATT_REQUIRE_NE (left, right) BATT_REQUIRE_LT (left, right) BATT_REQUIRE_GT (left, right) BATT_REQUIRE_LE (left, right) BATT_REQUIRE_GE (left, right) BATT_REQUIRE_TRUE (expr) BATT_REQUIRE_FALSE (expr) Macro Documentation \ud83d\udd17 BATTERIES_REQUIRE_HPP \ud83d\udd17 1 #define BATTERIES_REQUIRE_HPP() BATT_REQUIRE_RELATION \ud83d\udd17 1 #define BATT_REQUIRE_RELATION(left, op, right) BATT_REQUIRE_EQ \ud83d\udd17 1 #define BATT_REQUIRE_EQ(left, right) BATT_REQUIRE_NE \ud83d\udd17 1 #define BATT_REQUIRE_NE(left, right) BATT_REQUIRE_LT \ud83d\udd17 1 #define BATT_REQUIRE_LT(left, right) BATT_REQUIRE_GT \ud83d\udd17 1 #define BATT_REQUIRE_GT(left, right) BATT_REQUIRE_LE \ud83d\udd17 1 #define BATT_REQUIRE_LE(left, right) BATT_REQUIRE_GE \ud83d\udd17 1 #define BATT_REQUIRE_GE(left, right) BATT_REQUIRE_TRUE \ud83d\udd17 1 #define BATT_REQUIRE_TRUE(expr) BATT_REQUIRE_FALSE \ud83d\udd17 1 #define BATT_REQUIRE_FALSE(expr) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_REQUIRE_HPP #define BATTERIES_REQUIRE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/status.hpp> #include <boost/preprocessor/stringize.hpp> #include <tuple> namespace batt { #define BATT_REQUIRE_RELATION(left, op, right) \\ for (auto values = std::make_tuple((left), (right)); \\ !BATT_HINT_TRUE(std::get<0>(values) op std::get<1>(values));) \\ return ::batt::detail::NotOkStatusWrapper{__FILE__, __LINE__, {::batt::StatusCode::kFailedPrecondition}} \\ << \"\\n\\n Expected:\\n\\n \" \\ << BOOST_PP_STRINGIZE(left) << \" \" \\ << BOOST_PP_STRINGIZE(op) << \" \" \\ << BOOST_PP_STRINGIZE(right) \\ << \"\\n\\n Actual:\\n\\n \" \\ << BOOST_PP_STRINGIZE(left) \\ << \" == \" << ::batt::make_printable(std::get<0>(values)) \\ << \"\\n\\n \" \\ << BOOST_PP_STRINGIZE(right) << \" == \" \\ << ::batt::make_printable( \\ std::get<1>(values)) \\ << \"\\n\\n\" #define BATT_REQUIRE_EQ(left, right) BATT_REQUIRE_RELATION(left, ==, right) #define BATT_REQUIRE_NE(left, right) BATT_REQUIRE_RELATION(left, !=, right) #define BATT_REQUIRE_LT(left, right) BATT_REQUIRE_RELATION(left, <, right) #define BATT_REQUIRE_GT(left, right) BATT_REQUIRE_RELATION(left, >, right) #define BATT_REQUIRE_LE(left, right) BATT_REQUIRE_RELATION(left, <=, right) #define BATT_REQUIRE_GE(left, right) BATT_REQUIRE_RELATION(left, >=, right) #define BATT_REQUIRE_TRUE(expr) BATT_REQUIRE_RELATION(bool{(expr)}, ==, true) #define BATT_REQUIRE_FALSE(expr) BATT_REQUIRE_RELATION(bool{(expr)}, ==, false) } // namespace batt #endif // BATTERIES_REQUIRE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/require.hpp"},{"location":"_autogen/Files/require_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/require_8hpp/#defines","text":"Name BATTERIES_REQUIRE_HPP BATT_REQUIRE_RELATION (left, op, right) BATT_REQUIRE_EQ (left, right) BATT_REQUIRE_NE (left, right) BATT_REQUIRE_LT (left, right) BATT_REQUIRE_GT (left, right) BATT_REQUIRE_LE (left, right) BATT_REQUIRE_GE (left, right) BATT_REQUIRE_TRUE (expr) BATT_REQUIRE_FALSE (expr)","title":"Defines"},{"location":"_autogen/Files/require_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/require_8hpp/#batteries_require_hpp","text":"1 #define BATTERIES_REQUIRE_HPP()","title":"BATTERIES_REQUIRE_HPP"},{"location":"_autogen/Files/require_8hpp/#batt_require_relation","text":"1 #define BATT_REQUIRE_RELATION(left, op, right)","title":"BATT_REQUIRE_RELATION"},{"location":"_autogen/Files/require_8hpp/#batt_require_eq","text":"1 #define BATT_REQUIRE_EQ(left, right)","title":"BATT_REQUIRE_EQ"},{"location":"_autogen/Files/require_8hpp/#batt_require_ne","text":"1 #define BATT_REQUIRE_NE(left, right)","title":"BATT_REQUIRE_NE"},{"location":"_autogen/Files/require_8hpp/#batt_require_lt","text":"1 #define BATT_REQUIRE_LT(left, right)","title":"BATT_REQUIRE_LT"},{"location":"_autogen/Files/require_8hpp/#batt_require_gt","text":"1 #define BATT_REQUIRE_GT(left, right)","title":"BATT_REQUIRE_GT"},{"location":"_autogen/Files/require_8hpp/#batt_require_le","text":"1 #define BATT_REQUIRE_LE(left, right)","title":"BATT_REQUIRE_LE"},{"location":"_autogen/Files/require_8hpp/#batt_require_ge","text":"1 #define BATT_REQUIRE_GE(left, right)","title":"BATT_REQUIRE_GE"},{"location":"_autogen/Files/require_8hpp/#batt_require_true","text":"1 #define BATT_REQUIRE_TRUE(expr)","title":"BATT_REQUIRE_TRUE"},{"location":"_autogen/Files/require_8hpp/#batt_require_false","text":"1 #define BATT_REQUIRE_FALSE(expr)","title":"BATT_REQUIRE_FALSE"},{"location":"_autogen/Files/require_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_REQUIRE_HPP #define BATTERIES_REQUIRE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/status.hpp> #include <boost/preprocessor/stringize.hpp> #include <tuple> namespace batt { #define BATT_REQUIRE_RELATION(left, op, right) \\ for (auto values = std::make_tuple((left), (right)); \\ !BATT_HINT_TRUE(std::get<0>(values) op std::get<1>(values));) \\ return ::batt::detail::NotOkStatusWrapper{__FILE__, __LINE__, {::batt::StatusCode::kFailedPrecondition}} \\ << \"\\n\\n Expected:\\n\\n \" \\ << BOOST_PP_STRINGIZE(left) << \" \" \\ << BOOST_PP_STRINGIZE(op) << \" \" \\ << BOOST_PP_STRINGIZE(right) \\ << \"\\n\\n Actual:\\n\\n \" \\ << BOOST_PP_STRINGIZE(left) \\ << \" == \" << ::batt::make_printable(std::get<0>(values)) \\ << \"\\n\\n \" \\ << BOOST_PP_STRINGIZE(right) << \" == \" \\ << ::batt::make_printable( \\ std::get<1>(values)) \\ << \"\\n\\n\" #define BATT_REQUIRE_EQ(left, right) BATT_REQUIRE_RELATION(left, ==, right) #define BATT_REQUIRE_NE(left, right) BATT_REQUIRE_RELATION(left, !=, right) #define BATT_REQUIRE_LT(left, right) BATT_REQUIRE_RELATION(left, <, right) #define BATT_REQUIRE_GT(left, right) BATT_REQUIRE_RELATION(left, >, right) #define BATT_REQUIRE_LE(left, right) BATT_REQUIRE_RELATION(left, <=, right) #define BATT_REQUIRE_GE(left, right) BATT_REQUIRE_RELATION(left, >=, right) #define BATT_REQUIRE_TRUE(expr) BATT_REQUIRE_RELATION(bool{(expr)}, ==, true) #define BATT_REQUIRE_FALSE(expr) BATT_REQUIRE_RELATION(bool{(expr)}, ==, false) } // namespace batt #endif // BATTERIES_REQUIRE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/requirements_8hpp/","text":"batteries/seq/requirements.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Defines \ud83d\udd17 Name BATTERIES_SEQ_REQUIREMENTS_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_REQUIREMENTS_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_REQUIREMENTS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_REQUIREMENTS_HPP #define BATTERIES_SEQ_REQUIREMENTS_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/type_traits.hpp> namespace batt { namespace detail { template < typename T > inline std :: false_type has_seq_requirements_impl (...) { return {}; } template < typename T , typename ItemT = typename std :: decay_t < T >:: Item , typename = std :: enable_if_t < // std :: is_convertible_v < decltype ( std :: declval < T > (). next ()), Optional < ItemT >> && // std :: is_convertible_v < decltype ( std :: declval < T > (). peek ()), Optional < ItemT >> // >> inline std :: true_type has_seq_requirements_impl ( std :: decay_t < T >* ) { return {}; } } // namespace detail template < typename T > using HasSeqRequirements = decltype ( detail :: has_seq_requirements_impl < T > ( nullptr )); template < typename T > inline constexpr bool has_seq_requirements ( StaticType < T > = {}) { return HasSeqRequirements < T > {}; } template < typename T > using EnableIfSeq = std :: enable_if_t < has_seq_requirements < T > () > ; } // namespace batt #endif // BATTERIES_SEQ_REQUIREMENTS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/requirements.hpp"},{"location":"_autogen/Files/requirements_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/requirements_8hpp/#defines","text":"Name BATTERIES_SEQ_REQUIREMENTS_HPP","title":"Defines"},{"location":"_autogen/Files/requirements_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/requirements_8hpp/#batteries_seq_requirements_hpp","text":"1 #define BATTERIES_SEQ_REQUIREMENTS_HPP()","title":"BATTERIES_SEQ_REQUIREMENTS_HPP"},{"location":"_autogen/Files/requirements_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_REQUIREMENTS_HPP #define BATTERIES_SEQ_REQUIREMENTS_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/type_traits.hpp> namespace batt { namespace detail { template < typename T > inline std :: false_type has_seq_requirements_impl (...) { return {}; } template < typename T , typename ItemT = typename std :: decay_t < T >:: Item , typename = std :: enable_if_t < // std :: is_convertible_v < decltype ( std :: declval < T > (). next ()), Optional < ItemT >> && // std :: is_convertible_v < decltype ( std :: declval < T > (). peek ()), Optional < ItemT >> // >> inline std :: true_type has_seq_requirements_impl ( std :: decay_t < T >* ) { return {}; } } // namespace detail template < typename T > using HasSeqRequirements = decltype ( detail :: has_seq_requirements_impl < T > ( nullptr )); template < typename T > inline constexpr bool has_seq_requirements ( StaticType < T > = {}) { return HasSeqRequirements < T > {}; } template < typename T > using EnableIfSeq = std :: enable_if_t < has_seq_requirements < T > () > ; } // namespace batt #endif // BATTERIES_SEQ_REQUIREMENTS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/reverse_8hpp/","text":"batteries/seq/reverse.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::Reverse Defines \ud83d\udd17 Name BATTERIES_SEQ_REVERSE_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_REVERSE_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_REVERSE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_REVERSE_HPP #define BATTERIES_SEQ_REVERSE_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> namespace batt { namespace seq { template < typename Fn > struct Reverse : private Fn { using Fn :: Fn ; template < typename Left , typename Right > decltype ( auto ) operator ()( Left && left , Right && right ) const { return Fn :: operator ()( BATT_FORWARD ( right ), BATT_FORWARD ( left )); } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_REVERSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/reverse.hpp"},{"location":"_autogen/Files/reverse_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/reverse_8hpp/#classes","text":"Name struct batt::seq::Reverse","title":"Classes"},{"location":"_autogen/Files/reverse_8hpp/#defines","text":"Name BATTERIES_SEQ_REVERSE_HPP","title":"Defines"},{"location":"_autogen/Files/reverse_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/reverse_8hpp/#batteries_seq_reverse_hpp","text":"1 #define BATTERIES_SEQ_REVERSE_HPP()","title":"BATTERIES_SEQ_REVERSE_HPP"},{"location":"_autogen/Files/reverse_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_REVERSE_HPP #define BATTERIES_SEQ_REVERSE_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> namespace batt { namespace seq { template < typename Fn > struct Reverse : private Fn { using Fn :: Fn ; template < typename Left , typename Right > decltype ( auto ) operator ()( Left && left , Right && right ) const { return Fn :: operator ()( BATT_FORWARD ( right ), BATT_FORWARD ( left )); } }; } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_REVERSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/running__total_8hpp/","text":"batteries/algo/running_total.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::RunningTotal class batt::RunningTotal::Iterator Defines \ud83d\udd17 Name BATTERIES_ALGO_RUNNING_TOTAL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ALGO_RUNNING_TOTAL_HPP \ud83d\udd17 1 #define BATTERIES_ALGO_RUNNING_TOTAL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_RUNNING_TOTAL_HPP #define BATTERIES_ALGO_RUNNING_TOTAL_HPP #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/interval.hpp> #include <batteries/slice.hpp> #include <batteries/stream_util.hpp> #include <batteries/strong_typedef.hpp> #include <boost/iterator/iterator_facade.hpp> #include <functional> #include <iterator> #include <memory> #include <ostream> namespace batt { BATT_STRONG_TYPEDEF ( usize , PartsCount ); BATT_STRONG_TYPEDEF ( usize , PartSize ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A parallel-friendly cummulative running total of `usize` values. // // This collection is structured as a series of adjacent 'parts' (or shards/partitions) plus a 'summary' that // records the running totals of the parts. For example, if the input array (on which we wish to compute the // running total) is: // // `{2, 1, 3, 1, 1, 2, 1, 2, 3, 3, 1, 2}` // // We might divide this into three (logical) parts whose running totals can be computed independently in // parallel: // // input parts: `{{2, 1, 3, 1}, {1, 2, 1, 2}, {3, 3, 1, 2}}` // part totals: `{{2, 3, 6, 7}, {1, 3, 4, 6}, {3, 6, 7, 9}}` // // And then the summary is computed as the running total of the individual part totals plus leading zero: // // summary: `{0, 7, 13, 22}` // // So the overall set of values stored internally by `RunningTotal` for this input would be: // // <part-0> + <part-1> + <part-2> + <summary> => `{2, 3, 6, 7, 1, 3, 4, 6, 3, 6, 7, 9, 0, 7, 13, 22}` // // This allows a fast O(1) calculation of the overall running total at any point; just add the part-local // total to the summary for that part. // class RunningTotal { public : class Iterator ; using iterator = Iterator ; using const_iterator = Iterator ; using value_type = usize ; using slice_type = boost :: iterator_range < Iterator > ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - RunningTotal () = default ; RunningTotal ( RunningTotal && ) = default ; explicit RunningTotal ( PartsCount count , PartSize size ) : values_ { nullptr } { this -> reset ( count , size ); } ~ RunningTotal () = default ; RunningTotal & operator = ( RunningTotal && ) = default ; PartsCount parts_count () const { return PartsCount { this -> parts_count_ }; } PartSize part_size () const { return PartSize { this -> part_size_ }; } usize size () const { return this -> size_ ; } bool empty () const { return this -> size () == 0 ; } usize front () const { BATT_ASSERT ( ! this -> empty ()); return this -> values_ [ 0 ]; } usize back () const { BATT_ASSERT ( ! this -> empty ()); return operator []( this -> size () - 1 ); } iterator begin () const ; iterator end () const ; slice_type slice ( usize begin_index , usize end_index ) const ; slice_type slice ( Interval < usize > interval ) const ; void reset ( PartsCount count , PartSize size ) { BATT_CHECK_GT ( size , 0 ); try { std :: swap ( this -> parts_count_ , count ); std :: swap ( this -> part_size_ , size ); this -> values_ . reset ( new usize [ this -> raw_size ()]); this -> mutable_summary (). front () = 0 ; for ( usize i = 0 ; i < this -> parts_count_ ; ++ i ) { this -> mutable_part ( i ). front () = 0 ; } this -> size_ = this -> parts_count_ * this -> part_size_ + 1 ; } catch (...) { std :: swap ( this -> parts_count_ , count ); std :: swap ( this -> part_size_ , size ); throw ; } } void set_size ( usize new_size ) { BATT_CHECK_LE ( new_size , this -> parts_count_ * this -> part_size_ + 1 ); this -> size_ = new_size ; } Slice < const usize > const_part ( usize i ) const { BATT_ASSERT_LT ( i , this -> parts_count_ ) << BATT_INSPECT ( this -> size ()) << BATT_INSPECT ( this -> raw_size ()); return this -> const_part_impl ( i ); } Slice < usize > mutable_part ( usize i ) { BATT_ASSERT_LT ( i , this -> parts_count_ ) << BATT_INSPECT ( this -> size ()) << BATT_INSPECT ( this -> raw_size ()); return this -> raw_slice ( this -> part_segment_offset ( i ), this -> part_segment_size ()); } Slice < const usize > const_summary () const { return this -> raw_slice ( this -> summary_offset (), this -> summary_size ()); } Slice < usize > mutable_summary () { return this -> raw_slice ( this -> summary_offset (), this -> summary_size ()); } usize operator []( isize i ) const { BATT_ASSERT_LT ( static_cast < usize > ( i ), this -> size ()); const isize part_index = i / this -> part_size_ ; const isize part_offset = i % this -> part_size_ ; return this -> const_summary ()[ part_index ] + this -> const_part_impl ( part_index )[ part_offset ]; } Slice < const usize > raw_values () const { return as_slice ( this -> values_ . get (), this -> raw_size ()); } std :: function < void ( std :: ostream & ) > dump () const ; // Recompute the summary, which is a running total of the parts. Must be called after parts are // updated. // void update_summary () { usize total = 0 ; usize * next_summary = this -> values_ . get () + this -> summary_offset (); BATT_CHECK_EQ ( * next_summary , 0u ); ++ next_summary ; usize step = this -> part_segment_size (); usize * next_part_total = this -> values_ . get () + part_size_ ; usize * last_part_total = next_part_total + ( step * this -> parts_count ()); for (; next_part_total != last_part_total ; next_part_total += step , ++ next_summary ) { total += * next_part_total ; * next_summary = total ; } BATT_CHECK_EQ ( next_summary , this -> values_ . get () + this -> raw_size ()) << BATT_INSPECT ( this -> raw_size ()); } private : Slice < const usize > const_part_impl ( usize i ) const { const usize offset = this -> part_segment_offset ( i ); const usize len = this -> part_segment_size (); BATT_ASSERT_LT ( offset , this -> raw_size ()) << BATT_INSPECT ( offset ) << BATT_INSPECT ( len ); return this -> raw_slice ( offset , len ); } Slice < const usize > raw_slice ( usize offset , usize size ) const { return as_slice ( this -> values_ . get () + offset , size ); } Slice < usize > raw_slice ( usize offset , usize size ) { return as_slice ( this -> values_ . get () + offset , size ); } usize raw_size () const { return this -> summary_offset () + this -> summary_size (); } usize part_segment_offset ( usize part_i ) const { return part_i * this -> part_segment_size (); } usize part_segment_size () const { return this -> part_size_ + /*leading zero*/ 1 ; } usize summary_offset () const { return this -> part_segment_size () * this -> parts_count (); } usize summary_size () const { return this -> parts_count () + /*leading zero*/ 1 ; } usize offset_of_part ( usize part_i ) const { return part_i * this -> part_segment_size (); } std :: unique_ptr < usize [] > values_ { new usize [ 1 ]{ 0 }}; PartsCount parts_count_ { 0 }; PartSize part_size_ { 1 }; usize size_ { 1 }; }; // #=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ class RunningTotal :: Iterator : public boost :: iterator_facade < // Iterator , // <- Derived usize , // <- Value std :: random_access_iterator_tag , // <- CategoryOrTraversal usize , // <- Reference isize // <- Difference > { public : using Self = Iterator ; using iterator_category = std :: random_access_iterator_tag ; using value_type = usize ; using reference = value_type ; explicit Iterator ( const RunningTotal * container , usize position ) noexcept : container_ { container } , position_ { static_cast < isize > ( position )} { BATT_ASSERT_GE ( this -> position_ , 0 ); } reference dereference () const { return ( * this -> container_ )[ this -> position_ ]; } bool equal ( const Self & other ) const { return this -> container_ == other . container_ && this -> position_ == other . position_ ; } void increment () { BATT_ASSERT_LT ( static_cast < usize > ( this -> position_ ), this -> container_ -> size ()); ++ this -> position_ ; } void decrement () { BATT_ASSERT_GT ( this -> position_ , 0 ); -- this -> position_ ; } void advance ( isize delta ) { this -> position_ += delta ; BATT_ASSERT_IN_RANGE ( 0 , this -> position_ , static_cast < isize > ( this -> container_ -> size () + 1 )); } isize distance_to ( const Self & other ) const { return other . position_ - this -> position_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - const RunningTotal * container () const { return this -> container_ ; } isize position () const { return this -> position_ ; } private : const RunningTotal * container_ ; isize position_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: begin () const -> iterator { return iterator { this , 0 }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: end () const -> iterator { return iterator { this , this -> size ()}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: function < void ( std :: ostream & ) > RunningTotal :: dump () const { return [ this ]( std :: ostream & out ) { out << std :: endl << \"RunningTotal{\" << std :: endl << \" .parts_count=\" << this -> parts_count_ << \",\" << std :: endl << \" .part_size=\" << this -> part_size_ << \",\" << std :: endl << \" .raw_size=\" << this -> raw_size () << \",\" << std :: endl << \" .size=\" << this -> size () << \",\" << std :: endl << \" .values=\" << dump_range ( this -> raw_values ()) << std :: endl << \",} == \" << dump_range ( * this ); }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: slice ( usize begin_index , usize end_index ) const -> slice_type { BATT_CHECK_LE ( begin_index , end_index ); return slice_type { std :: next ( this -> begin (), begin_index ), // std :: next ( this -> begin (), end_index ) // }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: slice ( Interval < usize > interval ) const -> slice_type { return this -> slice ( interval . lower_bound , interval . upper_bound ); } } // namespace batt #endif // BATTERIES_ALGO_RUNNING_TOTAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/algo/running_total.hpp"},{"location":"_autogen/Files/running__total_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/running__total_8hpp/#classes","text":"Name class batt::RunningTotal class batt::RunningTotal::Iterator","title":"Classes"},{"location":"_autogen/Files/running__total_8hpp/#defines","text":"Name BATTERIES_ALGO_RUNNING_TOTAL_HPP","title":"Defines"},{"location":"_autogen/Files/running__total_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/running__total_8hpp/#batteries_algo_running_total_hpp","text":"1 #define BATTERIES_ALGO_RUNNING_TOTAL_HPP()","title":"BATTERIES_ALGO_RUNNING_TOTAL_HPP"},{"location":"_autogen/Files/running__total_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ALGO_RUNNING_TOTAL_HPP #define BATTERIES_ALGO_RUNNING_TOTAL_HPP #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/interval.hpp> #include <batteries/slice.hpp> #include <batteries/stream_util.hpp> #include <batteries/strong_typedef.hpp> #include <boost/iterator/iterator_facade.hpp> #include <functional> #include <iterator> #include <memory> #include <ostream> namespace batt { BATT_STRONG_TYPEDEF ( usize , PartsCount ); BATT_STRONG_TYPEDEF ( usize , PartSize ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // A parallel-friendly cummulative running total of `usize` values. // // This collection is structured as a series of adjacent 'parts' (or shards/partitions) plus a 'summary' that // records the running totals of the parts. For example, if the input array (on which we wish to compute the // running total) is: // // `{2, 1, 3, 1, 1, 2, 1, 2, 3, 3, 1, 2}` // // We might divide this into three (logical) parts whose running totals can be computed independently in // parallel: // // input parts: `{{2, 1, 3, 1}, {1, 2, 1, 2}, {3, 3, 1, 2}}` // part totals: `{{2, 3, 6, 7}, {1, 3, 4, 6}, {3, 6, 7, 9}}` // // And then the summary is computed as the running total of the individual part totals plus leading zero: // // summary: `{0, 7, 13, 22}` // // So the overall set of values stored internally by `RunningTotal` for this input would be: // // <part-0> + <part-1> + <part-2> + <summary> => `{2, 3, 6, 7, 1, 3, 4, 6, 3, 6, 7, 9, 0, 7, 13, 22}` // // This allows a fast O(1) calculation of the overall running total at any point; just add the part-local // total to the summary for that part. // class RunningTotal { public : class Iterator ; using iterator = Iterator ; using const_iterator = Iterator ; using value_type = usize ; using slice_type = boost :: iterator_range < Iterator > ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - RunningTotal () = default ; RunningTotal ( RunningTotal && ) = default ; explicit RunningTotal ( PartsCount count , PartSize size ) : values_ { nullptr } { this -> reset ( count , size ); } ~ RunningTotal () = default ; RunningTotal & operator = ( RunningTotal && ) = default ; PartsCount parts_count () const { return PartsCount { this -> parts_count_ }; } PartSize part_size () const { return PartSize { this -> part_size_ }; } usize size () const { return this -> size_ ; } bool empty () const { return this -> size () == 0 ; } usize front () const { BATT_ASSERT ( ! this -> empty ()); return this -> values_ [ 0 ]; } usize back () const { BATT_ASSERT ( ! this -> empty ()); return operator []( this -> size () - 1 ); } iterator begin () const ; iterator end () const ; slice_type slice ( usize begin_index , usize end_index ) const ; slice_type slice ( Interval < usize > interval ) const ; void reset ( PartsCount count , PartSize size ) { BATT_CHECK_GT ( size , 0 ); try { std :: swap ( this -> parts_count_ , count ); std :: swap ( this -> part_size_ , size ); this -> values_ . reset ( new usize [ this -> raw_size ()]); this -> mutable_summary (). front () = 0 ; for ( usize i = 0 ; i < this -> parts_count_ ; ++ i ) { this -> mutable_part ( i ). front () = 0 ; } this -> size_ = this -> parts_count_ * this -> part_size_ + 1 ; } catch (...) { std :: swap ( this -> parts_count_ , count ); std :: swap ( this -> part_size_ , size ); throw ; } } void set_size ( usize new_size ) { BATT_CHECK_LE ( new_size , this -> parts_count_ * this -> part_size_ + 1 ); this -> size_ = new_size ; } Slice < const usize > const_part ( usize i ) const { BATT_ASSERT_LT ( i , this -> parts_count_ ) << BATT_INSPECT ( this -> size ()) << BATT_INSPECT ( this -> raw_size ()); return this -> const_part_impl ( i ); } Slice < usize > mutable_part ( usize i ) { BATT_ASSERT_LT ( i , this -> parts_count_ ) << BATT_INSPECT ( this -> size ()) << BATT_INSPECT ( this -> raw_size ()); return this -> raw_slice ( this -> part_segment_offset ( i ), this -> part_segment_size ()); } Slice < const usize > const_summary () const { return this -> raw_slice ( this -> summary_offset (), this -> summary_size ()); } Slice < usize > mutable_summary () { return this -> raw_slice ( this -> summary_offset (), this -> summary_size ()); } usize operator []( isize i ) const { BATT_ASSERT_LT ( static_cast < usize > ( i ), this -> size ()); const isize part_index = i / this -> part_size_ ; const isize part_offset = i % this -> part_size_ ; return this -> const_summary ()[ part_index ] + this -> const_part_impl ( part_index )[ part_offset ]; } Slice < const usize > raw_values () const { return as_slice ( this -> values_ . get (), this -> raw_size ()); } std :: function < void ( std :: ostream & ) > dump () const ; // Recompute the summary, which is a running total of the parts. Must be called after parts are // updated. // void update_summary () { usize total = 0 ; usize * next_summary = this -> values_ . get () + this -> summary_offset (); BATT_CHECK_EQ ( * next_summary , 0u ); ++ next_summary ; usize step = this -> part_segment_size (); usize * next_part_total = this -> values_ . get () + part_size_ ; usize * last_part_total = next_part_total + ( step * this -> parts_count ()); for (; next_part_total != last_part_total ; next_part_total += step , ++ next_summary ) { total += * next_part_total ; * next_summary = total ; } BATT_CHECK_EQ ( next_summary , this -> values_ . get () + this -> raw_size ()) << BATT_INSPECT ( this -> raw_size ()); } private : Slice < const usize > const_part_impl ( usize i ) const { const usize offset = this -> part_segment_offset ( i ); const usize len = this -> part_segment_size (); BATT_ASSERT_LT ( offset , this -> raw_size ()) << BATT_INSPECT ( offset ) << BATT_INSPECT ( len ); return this -> raw_slice ( offset , len ); } Slice < const usize > raw_slice ( usize offset , usize size ) const { return as_slice ( this -> values_ . get () + offset , size ); } Slice < usize > raw_slice ( usize offset , usize size ) { return as_slice ( this -> values_ . get () + offset , size ); } usize raw_size () const { return this -> summary_offset () + this -> summary_size (); } usize part_segment_offset ( usize part_i ) const { return part_i * this -> part_segment_size (); } usize part_segment_size () const { return this -> part_size_ + /*leading zero*/ 1 ; } usize summary_offset () const { return this -> part_segment_size () * this -> parts_count (); } usize summary_size () const { return this -> parts_count () + /*leading zero*/ 1 ; } usize offset_of_part ( usize part_i ) const { return part_i * this -> part_segment_size (); } std :: unique_ptr < usize [] > values_ { new usize [ 1 ]{ 0 }}; PartsCount parts_count_ { 0 }; PartSize part_size_ { 1 }; usize size_ { 1 }; }; // #=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ class RunningTotal :: Iterator : public boost :: iterator_facade < // Iterator , // <- Derived usize , // <- Value std :: random_access_iterator_tag , // <- CategoryOrTraversal usize , // <- Reference isize // <- Difference > { public : using Self = Iterator ; using iterator_category = std :: random_access_iterator_tag ; using value_type = usize ; using reference = value_type ; explicit Iterator ( const RunningTotal * container , usize position ) noexcept : container_ { container } , position_ { static_cast < isize > ( position )} { BATT_ASSERT_GE ( this -> position_ , 0 ); } reference dereference () const { return ( * this -> container_ )[ this -> position_ ]; } bool equal ( const Self & other ) const { return this -> container_ == other . container_ && this -> position_ == other . position_ ; } void increment () { BATT_ASSERT_LT ( static_cast < usize > ( this -> position_ ), this -> container_ -> size ()); ++ this -> position_ ; } void decrement () { BATT_ASSERT_GT ( this -> position_ , 0 ); -- this -> position_ ; } void advance ( isize delta ) { this -> position_ += delta ; BATT_ASSERT_IN_RANGE ( 0 , this -> position_ , static_cast < isize > ( this -> container_ -> size () + 1 )); } isize distance_to ( const Self & other ) const { return other . position_ - this -> position_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - const RunningTotal * container () const { return this -> container_ ; } isize position () const { return this -> position_ ; } private : const RunningTotal * container_ ; isize position_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: begin () const -> iterator { return iterator { this , 0 }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: end () const -> iterator { return iterator { this , this -> size ()}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: function < void ( std :: ostream & ) > RunningTotal :: dump () const { return [ this ]( std :: ostream & out ) { out << std :: endl << \"RunningTotal{\" << std :: endl << \" .parts_count=\" << this -> parts_count_ << \",\" << std :: endl << \" .part_size=\" << this -> part_size_ << \",\" << std :: endl << \" .raw_size=\" << this -> raw_size () << \",\" << std :: endl << \" .size=\" << this -> size () << \",\" << std :: endl << \" .values=\" << dump_range ( this -> raw_values ()) << std :: endl << \",} == \" << dump_range ( * this ); }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: slice ( usize begin_index , usize end_index ) const -> slice_type { BATT_CHECK_LE ( begin_index , end_index ); return slice_type { std :: next ( this -> begin (), begin_index ), // std :: next ( this -> begin (), end_index ) // }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline auto RunningTotal :: slice ( Interval < usize > interval ) const -> slice_type { return this -> slice ( interval . lower_bound , interval . upper_bound ); } } // namespace batt #endif // BATTERIES_ALGO_RUNNING_TOTAL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/runtime_8hpp/","text":"batteries/async/runtime.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Runtime class batt::Runtime::DefaultScheduler Defines \ud83d\udd17 Name BATTERIES_ASYNC_RUNTIME_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_RUNTIME_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_RUNTIME_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_RUNTIME_HPP #define BATTERIES_ASYNC_RUNTIME_HPP #include <batteries/config.hpp> // #include <batteries/async/dump_tasks.hpp> #include <batteries/async/io_result.hpp> #include <batteries/async/task.hpp> #include <batteries/async/task_scheduler.hpp> #include <batteries/cpu_align.hpp> #include <batteries/hash.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/optional.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/signal_set.hpp> #include <boost/exception/diagnostic_information.hpp> #include <boost/exception_ptr.hpp> #include <chrono> #include <cstddef> #include <thread> #include <vector> #include <sched.h> #include <signal.h> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class Runtime { public : class DefaultScheduler ; static Runtime & instance () { // Intentionally leaked to avoid any potential static deinit order issues. // static Runtime * const instance_ = new Runtime ; return * instance_ ; } explicit Runtime () noexcept ; TaskScheduler & default_scheduler () { return * this -> default_scheduler_ ; } // DEPRECATED; use TaskScheduler explicitly instead for DI testing. // boost :: asio :: any_io_executor schedule_task () { return this -> scheduler_ . load () -> schedule_task (); } TaskScheduler * exchange_task_scheduler ( TaskScheduler * new_scheduler ) { return this -> scheduler_ . exchange ( new_scheduler ); } void halt () { const bool halted_prior = this -> halted_ . exchange ( true ); if ( halted_prior ) { return ; } detail :: SigInfoHandler :: instance (). halt (); this -> default_scheduler_ -> halt (); this -> scheduler_ . load () -> halt (); } void join () { detail :: SigInfoHandler :: instance (). join (); this -> default_scheduler_ -> join (); this -> scheduler_ . load () -> join (); } template < typename ... Ts > void notify ( const Ts & ... objs ) const { batt :: Watch < u64 >& watch = this -> weak_notify_slot_ [ batt :: hash ( objs ...) % this -> n_weak_notify_slots_ ]; watch . fetch_add ( 1 ); } template < typename CheckCondition , typename ... Ts > auto await_condition ( const CheckCondition & check_condition , const Ts & ... objs ) const { auto last_result = check_condition ( objs ...); if ( last_result ) { return last_result ; } batt :: Watch < u64 >& watch = this -> weak_notify_slot_ [ batt :: hash ( objs ...) % this -> n_weak_notify_slots_ ]; u64 observed_ts = watch . get_value (); for (;;) { last_result = check_condition ( objs ...); if ( last_result ) { return last_result ; } StatusOr < u64 > updated_ts = watch . await_not_equal ( observed_ts ); if ( ! updated_ts . ok ()) { return last_result ; } observed_ts = * updated_ts ; } } private : ~ Runtime () noexcept { this -> halt (); } using WorkGuard = batt :: Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type >> ; std :: atomic < bool > halted_ { false }; std :: unique_ptr < TaskScheduler > default_scheduler_ ; std :: atomic < TaskScheduler *> scheduler_ ; const usize n_weak_notify_slots_ = std :: thread :: hardware_concurrency () * 1024 ; const std :: unique_ptr < batt :: Watch < u64 > [] > weak_notify_slot_ { [ this ] { auto * slots = new batt :: Watch < u64 > [ this -> n_weak_notify_slots_ ]; for ( usize i = 0 ; i < this -> n_weak_notify_slots_ ; ++ i ) { slots [ i ]. set_value ( 0 ); } return slots ; }() }; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class Runtime :: DefaultScheduler : public TaskScheduler { public : explicit DefaultScheduler () noexcept { BATT_VLOG ( 1 ) << \"cpu_count == \" << cpu_count_ ; for ( usize i = 0 ; i < cpu_count_ ; ++ i ) { this -> io_ . emplace_back ( std :: make_unique < boost :: asio :: io_context > ()); this -> work_guards_ . emplace_back ( std :: make_unique < WorkGuard > ( io_ . back () -> get_executor ())); this -> thread_pool_ . emplace_back ([ i , this , io = io_ . back (). get ()] { if ( i < this -> cpu_count_ ) { usize cpu_n = i % this -> cpu_count_ ; batt :: this_thread_id () = cpu_n + 1 ; BATT_VLOG ( 1 ) << \"thread \" << batt :: this_thread_id () << \" started; cpu=\" << ( cpu_n + 1 ); BATT_CHECK_OK ( pin_thread_to_cpu ( cpu_n )) << \"cpu=\" << cpu_n ; BATT_VLOG ( 1 ) << \"thread \" << i << \" set affinity mask; running io_context\" ; } io -> run (); }); } } ~ DefaultScheduler () noexcept { this -> halt (); this -> join (); } boost :: asio :: any_io_executor schedule_task () override { const usize i = this -> round_robin_ . fetch_add ( 1 ); return this -> io_ [ i % this -> cpu_count_ ] -> get_executor (); } void halt () override { const bool halted_prior = this -> halted_ . exchange ( true ); if ( halted_prior ) { return ; } BATT_VLOG ( 1 ) << \"halting Runtime::DefaultScheduler...\" ; for ( auto & work_ptr : this -> work_guards_ ) { work_ptr . reset (); } BATT_VLOG ( 1 ) << \"work guards released\" ; for ( auto & io_ptr : this -> io_ ) { io_ptr -> stop (); } BATT_VLOG ( 1 ) << \"io contexts stopped\" ; } void join () override { std :: unique_lock < std :: mutex > lock { this -> join_mutex_ }; while ( ! this -> thread_pool_ . empty ()) { try { this -> thread_pool_ . back (). join (); } catch (...) { std :: cerr << \"unhandled exception: \" << boost :: diagnostic_information ( boost :: current_exception ()) << std :: endl ; } this -> thread_pool_ . pop_back (); } BATT_VLOG ( 1 ) << \"threads joined\" ; } private : // The number of physical execution units on the system; read at construction time. // const unsigned cpu_count_ = std :: thread :: hardware_concurrency (); // One io_context for each thread in the pool. // std :: vector < std :: unique_ptr < boost :: asio :: io_context >> io_ ; // One WorkGuard for each io_context, to keep it alive even if there is no work available at the // moment. // std :: vector < std :: unique_ptr < WorkGuard >> work_guards_ ; // One thread per io_context. // std :: vector < std :: thread > thread_pool_ ; // Latching flag to make it safe to call this->halt() more than once. // std :: atomic < bool > halted_ { false }; // The scheduling algorithm is to increment this counter each time `schedule_task` is invoked. // std :: atomic < usize > round_robin_ { 0 }; // Used to prevent data races inside `join()`. // std :: mutex join_mutex_ ; }; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ inline Runtime :: Runtime () noexcept : default_scheduler_ { new DefaultScheduler {}} , scheduler_ { this -> default_scheduler_ . get ()} { :: batt :: enable_dump_tasks (); } } // namespace batt #endif // BATTERIES_ASYNC_RUNTIME_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/runtime.hpp"},{"location":"_autogen/Files/runtime_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/runtime_8hpp/#classes","text":"Name class batt::Runtime class batt::Runtime::DefaultScheduler","title":"Classes"},{"location":"_autogen/Files/runtime_8hpp/#defines","text":"Name BATTERIES_ASYNC_RUNTIME_HPP","title":"Defines"},{"location":"_autogen/Files/runtime_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/runtime_8hpp/#batteries_async_runtime_hpp","text":"1 #define BATTERIES_ASYNC_RUNTIME_HPP()","title":"BATTERIES_ASYNC_RUNTIME_HPP"},{"location":"_autogen/Files/runtime_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_RUNTIME_HPP #define BATTERIES_ASYNC_RUNTIME_HPP #include <batteries/config.hpp> // #include <batteries/async/dump_tasks.hpp> #include <batteries/async/io_result.hpp> #include <batteries/async/task.hpp> #include <batteries/async/task_scheduler.hpp> #include <batteries/cpu_align.hpp> #include <batteries/hash.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/optional.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/io_context.hpp> #include <boost/asio/signal_set.hpp> #include <boost/exception/diagnostic_information.hpp> #include <boost/exception_ptr.hpp> #include <chrono> #include <cstddef> #include <thread> #include <vector> #include <sched.h> #include <signal.h> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class Runtime { public : class DefaultScheduler ; static Runtime & instance () { // Intentionally leaked to avoid any potential static deinit order issues. // static Runtime * const instance_ = new Runtime ; return * instance_ ; } explicit Runtime () noexcept ; TaskScheduler & default_scheduler () { return * this -> default_scheduler_ ; } // DEPRECATED; use TaskScheduler explicitly instead for DI testing. // boost :: asio :: any_io_executor schedule_task () { return this -> scheduler_ . load () -> schedule_task (); } TaskScheduler * exchange_task_scheduler ( TaskScheduler * new_scheduler ) { return this -> scheduler_ . exchange ( new_scheduler ); } void halt () { const bool halted_prior = this -> halted_ . exchange ( true ); if ( halted_prior ) { return ; } detail :: SigInfoHandler :: instance (). halt (); this -> default_scheduler_ -> halt (); this -> scheduler_ . load () -> halt (); } void join () { detail :: SigInfoHandler :: instance (). join (); this -> default_scheduler_ -> join (); this -> scheduler_ . load () -> join (); } template < typename ... Ts > void notify ( const Ts & ... objs ) const { batt :: Watch < u64 >& watch = this -> weak_notify_slot_ [ batt :: hash ( objs ...) % this -> n_weak_notify_slots_ ]; watch . fetch_add ( 1 ); } template < typename CheckCondition , typename ... Ts > auto await_condition ( const CheckCondition & check_condition , const Ts & ... objs ) const { auto last_result = check_condition ( objs ...); if ( last_result ) { return last_result ; } batt :: Watch < u64 >& watch = this -> weak_notify_slot_ [ batt :: hash ( objs ...) % this -> n_weak_notify_slots_ ]; u64 observed_ts = watch . get_value (); for (;;) { last_result = check_condition ( objs ...); if ( last_result ) { return last_result ; } StatusOr < u64 > updated_ts = watch . await_not_equal ( observed_ts ); if ( ! updated_ts . ok ()) { return last_result ; } observed_ts = * updated_ts ; } } private : ~ Runtime () noexcept { this -> halt (); } using WorkGuard = batt :: Optional < boost :: asio :: executor_work_guard < boost :: asio :: io_context :: executor_type >> ; std :: atomic < bool > halted_ { false }; std :: unique_ptr < TaskScheduler > default_scheduler_ ; std :: atomic < TaskScheduler *> scheduler_ ; const usize n_weak_notify_slots_ = std :: thread :: hardware_concurrency () * 1024 ; const std :: unique_ptr < batt :: Watch < u64 > [] > weak_notify_slot_ { [ this ] { auto * slots = new batt :: Watch < u64 > [ this -> n_weak_notify_slots_ ]; for ( usize i = 0 ; i < this -> n_weak_notify_slots_ ; ++ i ) { slots [ i ]. set_value ( 0 ); } return slots ; }() }; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class Runtime :: DefaultScheduler : public TaskScheduler { public : explicit DefaultScheduler () noexcept { BATT_VLOG ( 1 ) << \"cpu_count == \" << cpu_count_ ; for ( usize i = 0 ; i < cpu_count_ ; ++ i ) { this -> io_ . emplace_back ( std :: make_unique < boost :: asio :: io_context > ()); this -> work_guards_ . emplace_back ( std :: make_unique < WorkGuard > ( io_ . back () -> get_executor ())); this -> thread_pool_ . emplace_back ([ i , this , io = io_ . back (). get ()] { if ( i < this -> cpu_count_ ) { usize cpu_n = i % this -> cpu_count_ ; batt :: this_thread_id () = cpu_n + 1 ; BATT_VLOG ( 1 ) << \"thread \" << batt :: this_thread_id () << \" started; cpu=\" << ( cpu_n + 1 ); BATT_CHECK_OK ( pin_thread_to_cpu ( cpu_n )) << \"cpu=\" << cpu_n ; BATT_VLOG ( 1 ) << \"thread \" << i << \" set affinity mask; running io_context\" ; } io -> run (); }); } } ~ DefaultScheduler () noexcept { this -> halt (); this -> join (); } boost :: asio :: any_io_executor schedule_task () override { const usize i = this -> round_robin_ . fetch_add ( 1 ); return this -> io_ [ i % this -> cpu_count_ ] -> get_executor (); } void halt () override { const bool halted_prior = this -> halted_ . exchange ( true ); if ( halted_prior ) { return ; } BATT_VLOG ( 1 ) << \"halting Runtime::DefaultScheduler...\" ; for ( auto & work_ptr : this -> work_guards_ ) { work_ptr . reset (); } BATT_VLOG ( 1 ) << \"work guards released\" ; for ( auto & io_ptr : this -> io_ ) { io_ptr -> stop (); } BATT_VLOG ( 1 ) << \"io contexts stopped\" ; } void join () override { std :: unique_lock < std :: mutex > lock { this -> join_mutex_ }; while ( ! this -> thread_pool_ . empty ()) { try { this -> thread_pool_ . back (). join (); } catch (...) { std :: cerr << \"unhandled exception: \" << boost :: diagnostic_information ( boost :: current_exception ()) << std :: endl ; } this -> thread_pool_ . pop_back (); } BATT_VLOG ( 1 ) << \"threads joined\" ; } private : // The number of physical execution units on the system; read at construction time. // const unsigned cpu_count_ = std :: thread :: hardware_concurrency (); // One io_context for each thread in the pool. // std :: vector < std :: unique_ptr < boost :: asio :: io_context >> io_ ; // One WorkGuard for each io_context, to keep it alive even if there is no work available at the // moment. // std :: vector < std :: unique_ptr < WorkGuard >> work_guards_ ; // One thread per io_context. // std :: vector < std :: thread > thread_pool_ ; // Latching flag to make it safe to call this->halt() more than once. // std :: atomic < bool > halted_ { false }; // The scheduling algorithm is to increment this counter each time `schedule_task` is invoked. // std :: atomic < usize > round_robin_ { 0 }; // Used to prevent data races inside `join()`. // std :: mutex join_mutex_ ; }; //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ inline Runtime :: Runtime () noexcept : default_scheduler_ { new DefaultScheduler {}} , scheduler_ { this -> default_scheduler_ . get ()} { :: batt :: enable_dump_tasks (); } } // namespace batt #endif // BATTERIES_ASYNC_RUNTIME_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/segv_8hpp/","text":"batteries/segv.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Defines \ud83d\udd17 Name BATT_STACK_TRACE_AT_EXIT BATT_EXIT (code) Macro Documentation \ud83d\udd17 BATT_STACK_TRACE_AT_EXIT \ud83d\udd17 1 #define BATT_STACK_TRACE_AT_EXIT() BATT_EXIT \ud83d\udd17 1 #define BATT_EXIT(code) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifdef BOOST_STACKTRACE_USE_NOOP #undef BOOST_STACKTRACE_USE_NOOP #endif // BOOST_STACKTRACE_USE_NOOP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/suppress.hpp> #if defined(__GNUC__) && !defined(__clang__) BATT_SUPPRESS ( \"-Wmaybe-uninitialized\" ) #endif #include <boost/stacktrace.hpp> #if defined(__GNUC__) && !defined(__clang__) BATT_UNSUPPRESS () #endif #include <atomic> #include <iostream> #include <execinfo.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> namespace batt { using PrintToStreamFunctionPointer = void ( * )( std :: ostream & ); namespace detail { inline void print_nothing ( std :: ostream & ) { } } // namespace detail inline std :: atomic < PrintToStreamFunctionPointer >& extra_segv_debug_info_callback () { static std :: atomic < PrintToStreamFunctionPointer > ptr_ { & detail :: print_nothing }; return ptr_ ; } inline void print_stack_trace () { constexpr usize kMaxStackFrames = 64 ; void * frames [ kMaxStackFrames ]; const usize size = backtrace ( frames , kMaxStackFrames ); // print out all the frames to stderr backtrace_symbols_fd ( frames , size , STDERR_FILENO ); fflush ( stderr ); std :: cerr << std :: endl << boost :: stacktrace :: stacktrace {} << std :: endl ; extra_segv_debug_info_callback (). load ()( std :: cerr ); } #ifndef BATT_STACK_TRACE_AT_EXIT #define BATT_STACK_TRACE_AT_EXIT false #endif inline bool & print_stack_trace_atexit_enabled () { static bool b_ = BATT_STACK_TRACE_AT_EXIT ; return b_ ; } inline void print_stack_trace_atexit () { if ( print_stack_trace_atexit_enabled ()) { print_stack_trace (); } } // ============================================================================= // SEGV backtrace handler // namespace detail { inline void handle_segv ( int sig ) { fprintf ( stderr , \"FATAL: signal %d (%s): \\n [[raw stack]] \\n \" , sig , strsignal ( sig )); print_stack_trace_atexit_enabled () = true ; exit ( sig ); } inline void exit_impl ( int code ) { print_stack_trace_atexit_enabled () = ( code != 0 ); :: exit ( code ); } } // namespace detail inline const bool kSigSegvHandlerInstalled = [] { signal ( SIGSEGV , & detail :: handle_segv ); signal ( SIGABRT , & detail :: handle_segv ); std :: atexit ( & print_stack_trace_atexit ); return true ; }(); #define BATT_EXIT(code) ::batt::detail::exit_impl(code) } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/segv.hpp"},{"location":"_autogen/Files/segv_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/segv_8hpp/#defines","text":"Name BATT_STACK_TRACE_AT_EXIT BATT_EXIT (code)","title":"Defines"},{"location":"_autogen/Files/segv_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/segv_8hpp/#batt_stack_trace_at_exit","text":"1 #define BATT_STACK_TRACE_AT_EXIT()","title":"BATT_STACK_TRACE_AT_EXIT"},{"location":"_autogen/Files/segv_8hpp/#batt_exit","text":"1 #define BATT_EXIT(code)","title":"BATT_EXIT"},{"location":"_autogen/Files/segv_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifdef BOOST_STACKTRACE_USE_NOOP #undef BOOST_STACKTRACE_USE_NOOP #endif // BOOST_STACKTRACE_USE_NOOP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/suppress.hpp> #if defined(__GNUC__) && !defined(__clang__) BATT_SUPPRESS ( \"-Wmaybe-uninitialized\" ) #endif #include <boost/stacktrace.hpp> #if defined(__GNUC__) && !defined(__clang__) BATT_UNSUPPRESS () #endif #include <atomic> #include <iostream> #include <execinfo.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> namespace batt { using PrintToStreamFunctionPointer = void ( * )( std :: ostream & ); namespace detail { inline void print_nothing ( std :: ostream & ) { } } // namespace detail inline std :: atomic < PrintToStreamFunctionPointer >& extra_segv_debug_info_callback () { static std :: atomic < PrintToStreamFunctionPointer > ptr_ { & detail :: print_nothing }; return ptr_ ; } inline void print_stack_trace () { constexpr usize kMaxStackFrames = 64 ; void * frames [ kMaxStackFrames ]; const usize size = backtrace ( frames , kMaxStackFrames ); // print out all the frames to stderr backtrace_symbols_fd ( frames , size , STDERR_FILENO ); fflush ( stderr ); std :: cerr << std :: endl << boost :: stacktrace :: stacktrace {} << std :: endl ; extra_segv_debug_info_callback (). load ()( std :: cerr ); } #ifndef BATT_STACK_TRACE_AT_EXIT #define BATT_STACK_TRACE_AT_EXIT false #endif inline bool & print_stack_trace_atexit_enabled () { static bool b_ = BATT_STACK_TRACE_AT_EXIT ; return b_ ; } inline void print_stack_trace_atexit () { if ( print_stack_trace_atexit_enabled ()) { print_stack_trace (); } } // ============================================================================= // SEGV backtrace handler // namespace detail { inline void handle_segv ( int sig ) { fprintf ( stderr , \"FATAL: signal %d (%s): \\n [[raw stack]] \\n \" , sig , strsignal ( sig )); print_stack_trace_atexit_enabled () = true ; exit ( sig ); } inline void exit_impl ( int code ) { print_stack_trace_atexit_enabled () = ( code != 0 ); :: exit ( code ); } } // namespace detail inline const bool kSigSegvHandlerInstalled = [] { signal ( SIGSEGV , & detail :: handle_segv ); signal ( SIGABRT , & detail :: handle_segv ); std :: atexit ( & print_stack_trace_atexit ); return true ; }(); #define BATT_EXIT(code) ::batt::detail::exit_impl(code) } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/seq_8hpp/","text":"batteries/seq.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::VecSeqBase class batt::VecSeq struct batt::seq::Collect struct batt::seq::DecayItem class batt::seq::KMergeBy struct batt::seq::KMergeBy::HeapOrder struct batt::seq::KMergeByBinder class batt::seq::MapPairwise struct batt::seq::MapPairwiseBinder struct batt::seq::LastBinder struct batt::seq::InnerReduceBinder class batt::seq::SingleItem struct batt::seq::SumBinder struct batt::seq::ProductBinder struct batt::seq::AnyBinder struct batt::seq::AllBinder class batt::seq::MapAdjacent struct batt::seq::MapAdjacentBinder class batt::seq::MapFold struct batt::seq::MapFoldBinder struct batt::seq::RollingBinder struct batt::seq::Addition struct batt::seq::RunningTotalBinder class batt::seq::Splice struct batt::seq::SpliceBinder struct batt::seq::IsSortedBinder class batt::seq::InspectAdjacent struct batt::seq::InspectAdjacentBinder struct batt::seq::ApplyBinder class batt::seq::Attach struct batt::seq::AttachBinder class batt::seq::Fuse struct batt::seq::FuseBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // // Utilities for dealing with sequences. // #pragma once #ifndef BATTERIES_SEQ_HPP #define BATTERIES_SEQ_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/case_of.hpp> #include <batteries/optional.hpp> #include <batteries/seq/boxed.hpp> #include <batteries/seq/cache_next.hpp> #include <batteries/seq/chain.hpp> #include <batteries/seq/collect_vec.hpp> #include <batteries/seq/consume.hpp> #include <batteries/seq/count.hpp> #include <batteries/seq/deref.hpp> #include <batteries/seq/emplace_back.hpp> #include <batteries/seq/filter.hpp> #include <batteries/seq/filter_map.hpp> #include <batteries/seq/first.hpp> #include <batteries/seq/flatten.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/group_by.hpp> #include <batteries/seq/lazy.hpp> #include <batteries/seq/map.hpp> #include <batteries/seq/merge_by.hpp> #include <batteries/seq/natural_order.hpp> #include <batteries/seq/print_out.hpp> #include <batteries/seq/printable.hpp> #include <batteries/seq/reduce.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/seq/skip_n.hpp> #include <batteries/seq/status_ok.hpp> #include <batteries/seq/sub_range_seq.hpp> #include <batteries/seq/take_n.hpp> #include <batteries/seq/take_while.hpp> #include <batteries/small_vec.hpp> #include <batteries/stream_util.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/range/iterator_range.hpp> #include <algorithm> #include <ostream> #include <string_view> #include <type_traits> #include <variant> #include <vector> namespace batt { template < typename ForwardIter > auto as_seq ( ForwardIter && begin , ForwardIter && end ) { return as_seq ( boost :: make_iterator_range ( BATT_FORWARD ( begin ), BATT_FORWARD ( end ))); } template < typename VectorLike , typename = decltype ( std :: declval < VectorLike > (). data ()), typename = decltype ( std :: declval < VectorLike > (). size ()), typename = std :: enable_if_t < std :: is_same_v < decltype ( std :: declval < VectorLike > (). data ()), decltype ( std :: declval < VectorLike > (). data () + std :: declval < VectorLike > (). size ()) >>> auto as_seq ( VectorLike && v ) { return as_seq ( v . data (), v . data () + v . size ()); } template < typename T , typename Begin = decltype ( std :: declval < const T &> (). data ()), typename End = decltype ( std :: declval < Begin > () + std :: declval < const T &> (). size ()), typename = std :: enable_if_t < std :: is_same_v < Begin , End >>> auto vec_range ( const T & vec ) { return boost :: make_iterator_range ( vec . data (), vec . data () + vec . size ()); } template < typename T > struct VecSeqBase { explicit VecSeqBase ( std :: vector < T >&& v ) noexcept : vec ( std :: move ( v )) { } std :: vector < T > vec ; }; template < typename T > class VecSeq : public VecSeqBase < T > , public SubRangeSeq < boost :: iterator_range < const T *>> { public : explicit VecSeq ( std :: vector < T >&& v ) noexcept : VecSeqBase < T > { std :: move ( v )} , SubRangeSeq < boost :: iterator_range < const T *>> { boost :: make_iterator_range ( this -> vec . data (), this -> vec . data () + this -> vec . size ())} { } }; template < typename T > auto into_seq ( std :: vector < T >&& v ) { return VecSeq < T > { std :: move ( v )}; } namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // collect // template < typename T > struct Collect { }; template < typename T > inline Collect < T > collect ( StaticType < T > = {}) { return {}; } template < typename Seq , typename T > [[ nodiscard ]] auto operator | ( Seq && seq , Collect < T > ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::collect) Sequences may not be captured implicitly by reference.\" ); T v ; BATT_FORWARD ( seq ) | for_each ([ & v ]( auto && item ) { v . emplace_back ( BATT_FORWARD ( item )); }); return std :: move ( v ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // decayed // struct DecayItem { template < typename T > std :: decay_t < T > operator ()( T && val ) const { return BATT_FORWARD ( val ); } }; inline auto decayed () { return map ( DecayItem {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // kmerge, kmerge_by // template < typename Seq , typename Compare > class KMergeBy { public : using Item = SeqItem < Seq > ; struct HeapOrder { template < typename L , typename R > bool operator ()( L * l , R * r ) const { // Reversed because it's a max-heap. return compare_ ( * r -> peek (), * l -> peek ()); } Compare compare_ ; }; template < typename KSeqs > explicit KMergeBy ( KSeqs && k_seqs , Compare && compare ) noexcept : order_ { BATT_FORWARD ( compare )} , k_seqs_ ( BATT_FORWARD ( k_seqs ) | decayed () | map ([]( auto && seq ) { return BATT_FORWARD ( seq ) | cache_next (); }) | collect_vec ()) { static_assert ( std :: is_same_v < Seq , SeqItem < KSeqs >> , \"\" ); as_seq ( k_seqs_ ) | for_each ([ this ]( CacheNext < std :: decay_t < Seq >>& seq ) { if ( ! seq . peek ()) { return ; } this -> heap_ . emplace_back ( & seq ); std :: push_heap ( this -> heap_ . begin (), this -> heap_ . end (), this -> order_ ); }); BATT_ASSERT_LE ( this -> heap_ . size (), this -> k_seqs_ . size ()); } KMergeBy ( const KMergeBy & that ) noexcept : order_ ( that . order_ ), k_seqs_ ( that . k_seqs_ ), heap_ ( that . heap_ ) { fix_heap_pointers ( that ); } KMergeBy & operator = ( const KMergeBy & that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> order_ = that . order_ ; this -> k_seqs_ = that . k_seqs_ ; this -> heap_ = that . heap_ ; fix_heap_pointers ( that ); } return * this ; } Optional < Item > next () { if ( this -> heap_ . empty ()) { return None ; } // The lowest key is at the front of the level heap. Pop it off the heap // first, then remove it from that level's sequence and replace the level // in the heap if it isn't empty. // std :: pop_heap ( this -> heap_ . begin (), this -> heap_ . end (), this -> order_ ); CacheNext < std :: decay_t < Seq >>* next_seq = this -> heap_ . back (); BATT_ASSERT_NOT_NULLPTR ( next_seq ); auto next_item = next_seq -> next (); BATT_ASSERT_NE ( next_item , None ); if ( ! next_seq -> peek ()) { this -> heap_ . pop_back (); } else { std :: push_heap ( this -> heap_ . begin (), this -> heap_ . end (), this -> order_ ); } return next_item ; } Optional < Item > peek () { if ( this -> heap_ . empty ()) { return None ; } return this -> heap_ . front () -> peek (); } private : void fix_heap_pointers ( const KMergeBy & that ) { for ( std :: size_t i = 0 ; i < this -> heap_ . size (); ++ i ) { BATT_ASSERT_GE ( this -> heap_ [ i ], that . k_seqs_ . data ()); BATT_ASSERT_LT ( this -> heap_ [ i ], that . k_seqs_ . data () + that . k_seqs_ . size ()); } for ( auto & ptr : this -> heap_ ) { ptr = this -> k_seqs_ . data () + ( ptr - that . k_seqs_ . data ()); } for ( std :: size_t i = 0 ; i < this -> heap_ . size (); ++ i ) { BATT_ASSERT_GE ( this -> heap_ [ i ], this -> k_seqs_ . data ()); BATT_ASSERT_LT ( this -> heap_ [ i ], this -> k_seqs_ . data () + this -> k_seqs_ . size ()); BATT_ASSERT_EQ ( this -> heap_ [ i ] - this -> k_seqs_ . data (), that . heap_ [ i ] - that . k_seqs_ . data ()); } } HeapOrder order_ ; // TODO [tastolfi 2020-10-13] empty base class optimization // The stack of sequences we are merging. // std :: vector < CacheNext < std :: decay_t < Seq >>> k_seqs_ ; // A min-heap (by key) of per-level edit sequences, so we can quickly know // where the next lowest key is. // SmallVec < CacheNext < std :: decay_t < Seq >>* , 6 > heap_ ; }; template < typename Compare > struct KMergeByBinder { Compare compare ; }; template < typename Compare > KMergeByBinder < Compare > kmerge_by ( Compare && compare ) { return { BATT_FORWARD ( compare )}; } inline auto kmerge () { return kmerge_by ( NaturalOrder {}); } template < typename KSeqs , typename Compare > [[ nodiscard ]] KMergeBy < SeqItem < KSeqs > , Compare > operator | ( KSeqs && k_seqs , KMergeByBinder < Compare >&& binder ) { static_assert ( std :: is_same_v < KSeqs , std :: decay_t < KSeqs >> , \"Merged sequences may not be captured implicitly by reference.\" ); return KMergeBy < SeqItem < KSeqs > , Compare > { BATT_FORWARD ( k_seqs ), BATT_FORWARD ( binder . compare )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map_pairwise // Given: seqA = {a0, a1, a2, ...}, seqB = {b0, b1, b2, ...}, fn = (A, B) -> T // Produce: {fn(a0, b0), fn(a1, b1), fn(a2, b2), ...} // template < typename LeftSeq , typename RightSeq , typename MapFn > class MapPairwise { public : using Item = std :: invoke_result_t < MapFn , SeqItem < LeftSeq > , SeqItem < RightSeq >> ; explicit MapPairwise ( LeftSeq && left , RightSeq && right , MapFn && map_fn ) noexcept : left_ ( BATT_FORWARD ( left )) , right_ ( BATT_FORWARD ( right )) , map_fn_ ( BATT_FORWARD ( map_fn )) { } MapPairwise ( MapPairwise && that ) noexcept : left_ ( BATT_FORWARD ( that . left_ )) , right_ ( BATT_FORWARD ( that . right_ )) , map_fn_ ( BATT_FORWARD ( * that . map_fn_ )) { } MapPairwise ( const MapPairwise & that ) : left_ ( that . left_ ), right_ ( that . right_ ), map_fn_ ( * that . map_fn_ ) { } MapPairwise & operator = ( MapPairwise && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> left_ = BATT_FORWARD ( that . left_ ); this -> right_ = BATT_FORWARD ( that . right_ ); this -> map_fn_ . emplace ( BATT_FORWARD ( * that . map_fn_ )); } return * this ; } MapPairwise & operator = ( const MapPairwise & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> left_ = that . left_ ; this -> right_ = that . right_ ; this -> map_fn_ . emplace ( * that . map_fn_ ); } return * this ; } Optional < Item > peek () { return left_ . peek (). flat_map ([ this ]( auto && left_item ) { return right_ . peek (). map ([ this , & left_item ]( auto && right_item ) { return ( * map_fn_ )( BATT_FORWARD ( left_item ), BATT_FORWARD ( right_item )); }); }); } Optional < Item > next () { return left_ . next (). flat_map ([ this ]( auto && left_item ) { return right_ . next (). map ([ this , & left_item ]( auto && right_item ) { return ( * map_fn_ )( BATT_FORWARD ( left_item ), BATT_FORWARD ( right_item )); }); }); } private : LeftSeq left_ ; RightSeq right_ ; Optional < MapFn > map_fn_ ; }; template < typename RightSeq , typename MapFn > struct MapPairwiseBinder { RightSeq right ; MapFn map_fn ; }; template < typename RightSeq , typename MapFn > MapPairwiseBinder < RightSeq , MapFn > map_pairwise ( RightSeq && right , MapFn && map_fn ) { return { BATT_FORWARD ( right ), BATT_FORWARD ( map_fn )}; } template < typename LeftSeq , typename RightSeq , typename MapFn > [[ nodiscard ]] MapPairwise < LeftSeq , RightSeq , MapFn > operator | ( LeftSeq && left , MapPairwiseBinder < RightSeq , MapFn >&& binder ) { static_assert ( std :: is_same_v < LeftSeq , std :: decay_t < LeftSeq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < RightSeq , std :: decay_t < RightSeq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < MapFn , std :: decay_t < MapFn >> , \"Mapping functions may not be captured implicitly by reference.\" ); return MapPairwise < LeftSeq , RightSeq , MapFn > { BATT_FORWARD ( left ), BATT_FORWARD ( binder . right ), BATT_FORWARD ( binder . map_fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // last // struct LastBinder { }; inline LastBinder last () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , LastBinder ) { using Item = SeqItem < Seq > ; Optional < Item > prev , next = seq . next (); while ( next ) { prev = std :: move ( next ); next = seq . next (); } return prev ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inner_reduce // template < typename ReduceFn > struct InnerReduceBinder { ReduceFn reduce_fn ; }; template < typename ReduceFn > InnerReduceBinder < ReduceFn > inner_reduce ( ReduceFn && reduce_fn ) { return { BATT_FORWARD ( reduce_fn )}; } template < typename Seq , typename ReduceFn > [[ nodiscard ]] Optional < std :: decay_t < SeqItem < Seq >>> operator | ( Seq && seq , InnerReduceBinder < ReduceFn > binder ) { Optional < std :: decay_t < SeqItem < Seq >>> state = seq . next (); if ( ! state ) { return state ; } return BATT_FORWARD ( seq ) | reduce ( std :: move ( * state ), BATT_FORWARD ( binder . reduce_fn )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // single_item // template < typename T > class SingleItem { public : using Item = T ; explicit SingleItem ( T && item ) noexcept : item_ ( BATT_FORWARD ( item )) { } Optional < Item > peek () { return item_ ; } Optional < Item > next () { auto n = std :: move ( item_ ); item_ = None ; return n ; } private : Optional < Item > item_ ; }; template < typename T > [[ nodiscard ]] SingleItem < T > single_item ( T && item ) { return SingleItem < T > { BATT_FORWARD ( item )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // sum // struct SumBinder { }; inline SumBinder sum () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , SumBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::sum) Sequences may not be captured implicitly by reference.\" ); return BATT_FORWARD ( seq ) | reduce ( SeqItem < Seq > {}, []( auto && a , auto && b ) { return a + b ; }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // product // struct ProductBinder { }; inline ProductBinder product () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , ProductBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::product) Sequences may not be captured implicitly by reference.\" ); return BATT_FORWARD ( seq ) | reduce ( SeqItem < Seq > { 1 }, []( auto && a , auto && b ) { return a * b ; }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // any_true // struct AnyBinder { }; inline AnyBinder any_true () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , AnyBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::any_true) Sequences may not be captured implicitly by reference.\" ); bool ans = false ; BATT_FORWARD ( seq ) | for_each ([ & ans ]( auto && item ) { if ( bool { item }) { ans = true ; return LoopControl :: kBreak ; } return LoopControl :: kContinue ; }); return ans ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // all_true // struct AllBinder { }; inline AllBinder all_true () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , AllBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::all_true) Sequences may not be captured implicitly by reference.\" ); bool ans = true ; BATT_FORWARD ( seq ) | for_each ([ & ans ]( auto && item ) { if ( ! bool { item }) { ans = false ; return LoopControl :: kBreak ; } return LoopControl :: kContinue ; }); return ans ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map_adjacent(binary_map_fn) - // Transform [i0, i1, i2, i3, i4, ...] // into [f(i0, i1), f(i1, i2), f(i2, i3), ...] // template < typename Seq , typename Fn > class MapAdjacent { public : using Item = decltype ( std :: declval < Fn &> ()( std :: declval < const SeqItem < Seq >&> (), std :: declval < const SeqItem < Seq >&> ())); explicit MapAdjacent ( Seq && seq , Fn && fn ) noexcept : seq_ ( BATT_FORWARD ( seq )), fn_ ( BATT_FORWARD ( fn )) { } Optional < Item > peek () { return item_ . map ([ & ]( const auto & first ) { return seq_ . peek (). map ([ & ]( const auto & second ) { return fn_ ( first , second ); }); }); } Optional < Item > next () { if ( ! item_ ) { return None ; } auto first = std :: move ( * item_ ); item_ = seq_ . next (); return item_ . map ([ & ]( const auto & second ) { return fn_ ( first , second ); }); } private : Seq seq_ ; Fn fn_ ; Optional < SeqItem < Seq >> item_ { seq_ . next ()}; }; template < typename Fn > struct MapAdjacentBinder { Fn fn ; }; template < typename Fn > MapAdjacentBinder < Fn > map_adjacent ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn > [[ nodiscard ]] MapAdjacent < Seq , Fn > operator | ( Seq && seq , MapAdjacentBinder < Fn >&& binder ) { return MapAdjacent < Seq , Fn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map_fold(state, map_fn) // // map_fn: (state, item) -> tuple<state, mapped_item> // // seq | map_fold(...): Seq<mapped_item> // // Threads a state variable through a map operation, so that each invocation // of the map function sees the folded state from previous items. // template < typename Seq , typename State , typename MapFn > class MapFold { public : using Item = std :: tuple_element_t < 1 , std :: invoke_result_t < MapFn , State , SeqItem < Seq >>> ; explicit MapFold ( Seq && seq , State && state , MapFn && map_fn ) noexcept : seq_ ( BATT_FORWARD ( seq )) , state_ ( BATT_FORWARD ( state )) , map_fn_ ( BATT_FORWARD ( map_fn )) { } Optional < Item > peek () { auto tr = seq_ . peek (). map ([ & ]( auto && item ) { return map_fn_ ( state_ , BATT_FORWARD ( item )); }); if ( ! tr ) { return None ; } // Don't update state if we are just peeking. return { std :: get < 1 > ( std :: move ( * tr ))}; } Optional < Item > next () { auto tr = seq_ . next (). map ([ & ]( auto && item ) { return map_fn_ ( state_ , BATT_FORWARD ( item )); }); if ( ! tr ) { return None ; } // Update state. state_ = std :: get < 0 > ( std :: move ( * tr )); return { std :: get < 1 > ( std :: move ( * tr ))}; } private : Seq seq_ ; State state_ ; MapFn map_fn_ ; }; template < typename State , typename MapFn > struct MapFoldBinder { State state ; MapFn map_fn ; }; template < typename State , typename MapFn > MapFoldBinder < State , MapFn > map_fold ( State && state , MapFn && map_fn ) { return { BATT_FORWARD ( state ), BATT_FORWARD ( map_fn )}; } template < typename Seq , typename State , typename MapFn > [[ nodiscard ]] MapFold < Seq , State , MapFn > operator | ( Seq && seq , MapFoldBinder < State , MapFn >&& binder ) { return MapFold < Seq , State , MapFn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . state ), BATT_FORWARD ( binder . map_fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // rolling(initial, binary_fn) // template < typename T , typename BinaryFn > struct RollingBinder { BinaryFn binary_fn ; T initial ; }; template < typename T , typename BinaryFn > inline RollingBinder < T , BinaryFn > rolling ( BinaryFn && binary_fn , T && initial = T {}) { return { BATT_FORWARD ( binary_fn ), BATT_FORWARD ( initial )}; } template < typename Seq , typename T , typename BinaryFn > [[ nodiscard ]] auto operator | ( Seq && seq , RollingBinder < T , BinaryFn >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Sequences may not be captured by reference.\" ); return BATT_FORWARD ( seq ) | map_fold ( BATT_FORWARD ( binder . initial ), [ binary_fn = BATT_FORWARD ( binder . binary_fn )]( auto a , auto b ) { auto c = binary_fn ( a , b ); return std :: make_tuple ( c , c ); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // running_total() // struct Addition { template < typename L , typename R > decltype ( auto ) operator ()( L && l , R && r ) const { return BATT_FORWARD ( l ) + BATT_FORWARD ( r ); } }; struct RunningTotalBinder { }; inline RunningTotalBinder running_total () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , RunningTotalBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Sequences may not be captured by reference.\" ); using T = std :: decay_t < SeqItem < Seq >> ; return BATT_FORWARD ( seq ) | rolling < T > ( Addition {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inspect template < typename Fn > auto inspect ( Fn && fn ) { return map ([ fn = BATT_FORWARD ( fn )]( auto && item ) -> decltype ( auto ) { fn ( item ); return BATT_FORWARD ( item ); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // splice // template < typename OuterSeq , typename InnerSeq > class Splice { public : using OuterSeqRef = std :: add_lvalue_reference_t < OuterSeq > ; using Impl = Chain < TakeN < OuterSeqRef > , Chain < InnerSeq , OuterSeqRef >> ; using Item = SeqItem < Impl > ; explicit Splice ( OuterSeq && outer_seq , std :: size_t n , InnerSeq && inner_seq ) noexcept : outer_seq_ ( BATT_FORWARD ( outer_seq )) , impl_ { TakeN < OuterSeqRef > { outer_seq_ , n }, Chain < InnerSeq , OuterSeqRef > { BATT_FORWARD ( inner_seq ), outer_seq_ }} { } Optional < Item > peek () { return impl_ . peek (); } Optional < Item > next () { return impl_ . next (); } private : OuterSeq outer_seq_ ; Impl impl_ ; }; template < typename InnerSeq > struct SpliceBinder { std :: size_t n ; InnerSeq inner_seq ; }; template < typename InnerSeq > inline SpliceBinder < InnerSeq > splice ( std :: size_t n , InnerSeq && inner_seq ) { return { n , BATT_FORWARD ( inner_seq ), }; } template < typename OuterSeq , typename InnerSeq > [[ nodiscard ]] auto operator | ( OuterSeq && outer_seq , SpliceBinder < InnerSeq >&& binder ) { return Splice < OuterSeq , InnerSeq > { BATT_FORWARD ( outer_seq ), binder . n , BATT_FORWARD ( binder . inner_seq )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // is_sorted // template < typename Compare > struct IsSortedBinder { Compare compare ; }; template < typename Compare > IsSortedBinder < Compare > is_sorted_by ( Compare && compare ) { return { BATT_FORWARD ( compare )}; } inline auto is_sorted () { return is_sorted_by ([]( const auto & left , const auto & right ) { return ( left < right ) || ! ( right < left ); }); } template < typename Seq , typename Compare > [[ nodiscard ]] inline bool operator | ( Seq && seq , IsSortedBinder < Compare >&& binder ) { return BATT_FORWARD ( seq ) | map_adjacent ( BATT_FORWARD ( binder . compare )) | all_true (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inspect_adjacent(binary_fn) // template < typename Seq , typename Fn > class InspectAdjacent { public : using Item = SeqItem < Seq > ; explicit InspectAdjacent ( Seq && seq , Fn && fn ) noexcept : seq_ ( BATT_FORWARD ( seq )), fn_ ( BATT_FORWARD ( fn )) { } InspectAdjacent ( InspectAdjacent && that ) noexcept : seq_ ( BATT_FORWARD ( that . seq_ )) , fn_ ( BATT_FORWARD ( * that . fn_ )) , next_ ( BATT_FORWARD ( that . next_ )) { } InspectAdjacent & operator = ( InspectAdjacent && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = BATT_FORWARD ( that . seq_ ); this -> fn_ . emplace ( BATT_FORWARD ( * that . fn_ )); this -> next_ = BATT_FORWARD ( that . next_ ); } return * this ; } InspectAdjacent ( const InspectAdjacent & that ) : seq_ ( that . seq_ ), fn_ ( * that . fn_ ), next_ ( that . next_ ) { } InspectAdjacent & operator = ( const InspectAdjacent & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = that . seq_ ; this -> fn_ . emplace ( * that . fn_ ); this -> next_ = that . next_ ; } return * this ; } Optional < Item > peek () { return next_ ; } Optional < Item > next () { auto item = std :: move ( next_ ); next_ = seq_ . next (); if ( item && next_ ) { ( * fn_ )( * item , * next_ ); } return item ; } private : Seq seq_ ; Optional < Fn > fn_ ; Optional < SeqItem < Seq >> next_ { seq_ . next ()}; }; template < typename Fn > struct InspectAdjacentBinder { Fn fn ; }; template < typename Fn > InspectAdjacentBinder < Fn > inspect_adjacent ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn > InspectAdjacent < Seq , Fn > operator | ( Seq && seq , InspectAdjacentBinder < Fn >&& binder ) { return InspectAdjacent < Seq , Fn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // apply(seq_function) - apply a function to an entire sequence. // // Not to be confused with map, which applies some function to each item. // template < typename SeqFn > struct ApplyBinder { SeqFn seq_fn ; }; template < typename SeqFn > inline ApplyBinder < SeqFn > apply ( SeqFn && seq_fn ) { return { BATT_FORWARD ( seq_fn )}; } template < typename Seq , typename SeqFn > [[ nodiscard ]] inline decltype ( auto ) operator | ( Seq && seq , ApplyBinder < SeqFn >&& binder ) { return BATT_FORWARD ( binder . seq_fn )( BATT_FORWARD ( seq )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // attach(user_data) - attach a value to a sequence // template < typename Seq , typename Data > class Attach { public : using Item = SeqItem < Seq > ; using UserData = Data ; explicit Attach ( Seq && seq , Data && data ) noexcept : seq_ ( BATT_FORWARD ( seq )), data_ ( BATT_FORWARD ( data )) { } Data & user_data () { return data_ ; } const Data & user_data () const { return data_ ; } Optional < Item > peek () { return seq_ . peek (); } Optional < Item > next () { return seq_ . next (); } private : Seq seq_ ; Data data_ ; }; template < typename D > struct AttachBinder { D data ; }; template < typename D > inline AttachBinder < D > attach ( D && data ) { return { BATT_FORWARD ( data )}; } template < typename Seq , typename D > [[ nodiscard ]] inline auto operator | ( Seq && seq , AttachBinder < D >&& binder ) { static_assert ( std :: is_same_v < std :: decay_t < Seq > , Seq > , \"attach may not be used with references\" ); static_assert ( std :: is_same_v < std :: decay_t < D > , D > , \"attach may not be used with references\" ); return Attach < Seq , D > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . data )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // fuse() - Seq<Optional<T>> => Seq<T>; take T while Optional<T> != None // template < typename Seq > class Fuse { public : using OptionalItem = SeqItem < Seq > ; using Item = typename std :: decay_t < OptionalItem >:: value_type ; explicit Fuse ( Seq && seq ) noexcept : seq_ ( BATT_FORWARD ( seq )) { } Optional < Item > peek () { if ( fused_ ) { return None ; } return * seq_ . peek (); } Optional < Item > next () { if ( fused_ ) { return None ; } Optional < Optional < Item >> opt_item = seq_ . next (); if ( ! opt_item ) { fused_ = true ; return None ; } if ( !* opt_item ) { fused_ = true ; return None ; } return std :: move ( * opt_item ); } private : bool fused_ = false ; Seq seq_ ; }; struct FuseBinder { }; inline FuseBinder fuse () { return {}; } template < typename Seq > [[ nodiscard ]] Fuse < Seq > operator | ( Seq && seq , FuseBinder ) { return Fuse < Seq > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq.hpp"},{"location":"_autogen/Files/seq_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/seq_8hpp/#classes","text":"Name struct batt::VecSeqBase class batt::VecSeq struct batt::seq::Collect struct batt::seq::DecayItem class batt::seq::KMergeBy struct batt::seq::KMergeBy::HeapOrder struct batt::seq::KMergeByBinder class batt::seq::MapPairwise struct batt::seq::MapPairwiseBinder struct batt::seq::LastBinder struct batt::seq::InnerReduceBinder class batt::seq::SingleItem struct batt::seq::SumBinder struct batt::seq::ProductBinder struct batt::seq::AnyBinder struct batt::seq::AllBinder class batt::seq::MapAdjacent struct batt::seq::MapAdjacentBinder class batt::seq::MapFold struct batt::seq::MapFoldBinder struct batt::seq::RollingBinder struct batt::seq::Addition struct batt::seq::RunningTotalBinder class batt::seq::Splice struct batt::seq::SpliceBinder struct batt::seq::IsSortedBinder class batt::seq::InspectAdjacent struct batt::seq::InspectAdjacentBinder struct batt::seq::ApplyBinder class batt::seq::Attach struct batt::seq::AttachBinder class batt::seq::Fuse struct batt::seq::FuseBinder","title":"Classes"},{"location":"_autogen/Files/seq_8hpp/#defines","text":"Name BATTERIES_SEQ_HPP","title":"Defines"},{"location":"_autogen/Files/seq_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/seq_8hpp/#batteries_seq_hpp","text":"1 #define BATTERIES_SEQ_HPP()","title":"BATTERIES_SEQ_HPP"},{"location":"_autogen/Files/seq_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // // Utilities for dealing with sequences. // #pragma once #ifndef BATTERIES_SEQ_HPP #define BATTERIES_SEQ_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/case_of.hpp> #include <batteries/optional.hpp> #include <batteries/seq/boxed.hpp> #include <batteries/seq/cache_next.hpp> #include <batteries/seq/chain.hpp> #include <batteries/seq/collect_vec.hpp> #include <batteries/seq/consume.hpp> #include <batteries/seq/count.hpp> #include <batteries/seq/deref.hpp> #include <batteries/seq/emplace_back.hpp> #include <batteries/seq/filter.hpp> #include <batteries/seq/filter_map.hpp> #include <batteries/seq/first.hpp> #include <batteries/seq/flatten.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/seq/group_by.hpp> #include <batteries/seq/lazy.hpp> #include <batteries/seq/map.hpp> #include <batteries/seq/merge_by.hpp> #include <batteries/seq/natural_order.hpp> #include <batteries/seq/print_out.hpp> #include <batteries/seq/printable.hpp> #include <batteries/seq/reduce.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/seq/skip_n.hpp> #include <batteries/seq/status_ok.hpp> #include <batteries/seq/sub_range_seq.hpp> #include <batteries/seq/take_n.hpp> #include <batteries/seq/take_while.hpp> #include <batteries/small_vec.hpp> #include <batteries/stream_util.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/range/iterator_range.hpp> #include <algorithm> #include <ostream> #include <string_view> #include <type_traits> #include <variant> #include <vector> namespace batt { template < typename ForwardIter > auto as_seq ( ForwardIter && begin , ForwardIter && end ) { return as_seq ( boost :: make_iterator_range ( BATT_FORWARD ( begin ), BATT_FORWARD ( end ))); } template < typename VectorLike , typename = decltype ( std :: declval < VectorLike > (). data ()), typename = decltype ( std :: declval < VectorLike > (). size ()), typename = std :: enable_if_t < std :: is_same_v < decltype ( std :: declval < VectorLike > (). data ()), decltype ( std :: declval < VectorLike > (). data () + std :: declval < VectorLike > (). size ()) >>> auto as_seq ( VectorLike && v ) { return as_seq ( v . data (), v . data () + v . size ()); } template < typename T , typename Begin = decltype ( std :: declval < const T &> (). data ()), typename End = decltype ( std :: declval < Begin > () + std :: declval < const T &> (). size ()), typename = std :: enable_if_t < std :: is_same_v < Begin , End >>> auto vec_range ( const T & vec ) { return boost :: make_iterator_range ( vec . data (), vec . data () + vec . size ()); } template < typename T > struct VecSeqBase { explicit VecSeqBase ( std :: vector < T >&& v ) noexcept : vec ( std :: move ( v )) { } std :: vector < T > vec ; }; template < typename T > class VecSeq : public VecSeqBase < T > , public SubRangeSeq < boost :: iterator_range < const T *>> { public : explicit VecSeq ( std :: vector < T >&& v ) noexcept : VecSeqBase < T > { std :: move ( v )} , SubRangeSeq < boost :: iterator_range < const T *>> { boost :: make_iterator_range ( this -> vec . data (), this -> vec . data () + this -> vec . size ())} { } }; template < typename T > auto into_seq ( std :: vector < T >&& v ) { return VecSeq < T > { std :: move ( v )}; } namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // collect // template < typename T > struct Collect { }; template < typename T > inline Collect < T > collect ( StaticType < T > = {}) { return {}; } template < typename Seq , typename T > [[ nodiscard ]] auto operator | ( Seq && seq , Collect < T > ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::collect) Sequences may not be captured implicitly by reference.\" ); T v ; BATT_FORWARD ( seq ) | for_each ([ & v ]( auto && item ) { v . emplace_back ( BATT_FORWARD ( item )); }); return std :: move ( v ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // decayed // struct DecayItem { template < typename T > std :: decay_t < T > operator ()( T && val ) const { return BATT_FORWARD ( val ); } }; inline auto decayed () { return map ( DecayItem {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // kmerge, kmerge_by // template < typename Seq , typename Compare > class KMergeBy { public : using Item = SeqItem < Seq > ; struct HeapOrder { template < typename L , typename R > bool operator ()( L * l , R * r ) const { // Reversed because it's a max-heap. return compare_ ( * r -> peek (), * l -> peek ()); } Compare compare_ ; }; template < typename KSeqs > explicit KMergeBy ( KSeqs && k_seqs , Compare && compare ) noexcept : order_ { BATT_FORWARD ( compare )} , k_seqs_ ( BATT_FORWARD ( k_seqs ) | decayed () | map ([]( auto && seq ) { return BATT_FORWARD ( seq ) | cache_next (); }) | collect_vec ()) { static_assert ( std :: is_same_v < Seq , SeqItem < KSeqs >> , \"\" ); as_seq ( k_seqs_ ) | for_each ([ this ]( CacheNext < std :: decay_t < Seq >>& seq ) { if ( ! seq . peek ()) { return ; } this -> heap_ . emplace_back ( & seq ); std :: push_heap ( this -> heap_ . begin (), this -> heap_ . end (), this -> order_ ); }); BATT_ASSERT_LE ( this -> heap_ . size (), this -> k_seqs_ . size ()); } KMergeBy ( const KMergeBy & that ) noexcept : order_ ( that . order_ ), k_seqs_ ( that . k_seqs_ ), heap_ ( that . heap_ ) { fix_heap_pointers ( that ); } KMergeBy & operator = ( const KMergeBy & that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> order_ = that . order_ ; this -> k_seqs_ = that . k_seqs_ ; this -> heap_ = that . heap_ ; fix_heap_pointers ( that ); } return * this ; } Optional < Item > next () { if ( this -> heap_ . empty ()) { return None ; } // The lowest key is at the front of the level heap. Pop it off the heap // first, then remove it from that level's sequence and replace the level // in the heap if it isn't empty. // std :: pop_heap ( this -> heap_ . begin (), this -> heap_ . end (), this -> order_ ); CacheNext < std :: decay_t < Seq >>* next_seq = this -> heap_ . back (); BATT_ASSERT_NOT_NULLPTR ( next_seq ); auto next_item = next_seq -> next (); BATT_ASSERT_NE ( next_item , None ); if ( ! next_seq -> peek ()) { this -> heap_ . pop_back (); } else { std :: push_heap ( this -> heap_ . begin (), this -> heap_ . end (), this -> order_ ); } return next_item ; } Optional < Item > peek () { if ( this -> heap_ . empty ()) { return None ; } return this -> heap_ . front () -> peek (); } private : void fix_heap_pointers ( const KMergeBy & that ) { for ( std :: size_t i = 0 ; i < this -> heap_ . size (); ++ i ) { BATT_ASSERT_GE ( this -> heap_ [ i ], that . k_seqs_ . data ()); BATT_ASSERT_LT ( this -> heap_ [ i ], that . k_seqs_ . data () + that . k_seqs_ . size ()); } for ( auto & ptr : this -> heap_ ) { ptr = this -> k_seqs_ . data () + ( ptr - that . k_seqs_ . data ()); } for ( std :: size_t i = 0 ; i < this -> heap_ . size (); ++ i ) { BATT_ASSERT_GE ( this -> heap_ [ i ], this -> k_seqs_ . data ()); BATT_ASSERT_LT ( this -> heap_ [ i ], this -> k_seqs_ . data () + this -> k_seqs_ . size ()); BATT_ASSERT_EQ ( this -> heap_ [ i ] - this -> k_seqs_ . data (), that . heap_ [ i ] - that . k_seqs_ . data ()); } } HeapOrder order_ ; // TODO [tastolfi 2020-10-13] empty base class optimization // The stack of sequences we are merging. // std :: vector < CacheNext < std :: decay_t < Seq >>> k_seqs_ ; // A min-heap (by key) of per-level edit sequences, so we can quickly know // where the next lowest key is. // SmallVec < CacheNext < std :: decay_t < Seq >>* , 6 > heap_ ; }; template < typename Compare > struct KMergeByBinder { Compare compare ; }; template < typename Compare > KMergeByBinder < Compare > kmerge_by ( Compare && compare ) { return { BATT_FORWARD ( compare )}; } inline auto kmerge () { return kmerge_by ( NaturalOrder {}); } template < typename KSeqs , typename Compare > [[ nodiscard ]] KMergeBy < SeqItem < KSeqs > , Compare > operator | ( KSeqs && k_seqs , KMergeByBinder < Compare >&& binder ) { static_assert ( std :: is_same_v < KSeqs , std :: decay_t < KSeqs >> , \"Merged sequences may not be captured implicitly by reference.\" ); return KMergeBy < SeqItem < KSeqs > , Compare > { BATT_FORWARD ( k_seqs ), BATT_FORWARD ( binder . compare )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map_pairwise // Given: seqA = {a0, a1, a2, ...}, seqB = {b0, b1, b2, ...}, fn = (A, B) -> T // Produce: {fn(a0, b0), fn(a1, b1), fn(a2, b2), ...} // template < typename LeftSeq , typename RightSeq , typename MapFn > class MapPairwise { public : using Item = std :: invoke_result_t < MapFn , SeqItem < LeftSeq > , SeqItem < RightSeq >> ; explicit MapPairwise ( LeftSeq && left , RightSeq && right , MapFn && map_fn ) noexcept : left_ ( BATT_FORWARD ( left )) , right_ ( BATT_FORWARD ( right )) , map_fn_ ( BATT_FORWARD ( map_fn )) { } MapPairwise ( MapPairwise && that ) noexcept : left_ ( BATT_FORWARD ( that . left_ )) , right_ ( BATT_FORWARD ( that . right_ )) , map_fn_ ( BATT_FORWARD ( * that . map_fn_ )) { } MapPairwise ( const MapPairwise & that ) : left_ ( that . left_ ), right_ ( that . right_ ), map_fn_ ( * that . map_fn_ ) { } MapPairwise & operator = ( MapPairwise && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> left_ = BATT_FORWARD ( that . left_ ); this -> right_ = BATT_FORWARD ( that . right_ ); this -> map_fn_ . emplace ( BATT_FORWARD ( * that . map_fn_ )); } return * this ; } MapPairwise & operator = ( const MapPairwise & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> left_ = that . left_ ; this -> right_ = that . right_ ; this -> map_fn_ . emplace ( * that . map_fn_ ); } return * this ; } Optional < Item > peek () { return left_ . peek (). flat_map ([ this ]( auto && left_item ) { return right_ . peek (). map ([ this , & left_item ]( auto && right_item ) { return ( * map_fn_ )( BATT_FORWARD ( left_item ), BATT_FORWARD ( right_item )); }); }); } Optional < Item > next () { return left_ . next (). flat_map ([ this ]( auto && left_item ) { return right_ . next (). map ([ this , & left_item ]( auto && right_item ) { return ( * map_fn_ )( BATT_FORWARD ( left_item ), BATT_FORWARD ( right_item )); }); }); } private : LeftSeq left_ ; RightSeq right_ ; Optional < MapFn > map_fn_ ; }; template < typename RightSeq , typename MapFn > struct MapPairwiseBinder { RightSeq right ; MapFn map_fn ; }; template < typename RightSeq , typename MapFn > MapPairwiseBinder < RightSeq , MapFn > map_pairwise ( RightSeq && right , MapFn && map_fn ) { return { BATT_FORWARD ( right ), BATT_FORWARD ( map_fn )}; } template < typename LeftSeq , typename RightSeq , typename MapFn > [[ nodiscard ]] MapPairwise < LeftSeq , RightSeq , MapFn > operator | ( LeftSeq && left , MapPairwiseBinder < RightSeq , MapFn >&& binder ) { static_assert ( std :: is_same_v < LeftSeq , std :: decay_t < LeftSeq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < RightSeq , std :: decay_t < RightSeq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < MapFn , std :: decay_t < MapFn >> , \"Mapping functions may not be captured implicitly by reference.\" ); return MapPairwise < LeftSeq , RightSeq , MapFn > { BATT_FORWARD ( left ), BATT_FORWARD ( binder . right ), BATT_FORWARD ( binder . map_fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // last // struct LastBinder { }; inline LastBinder last () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , LastBinder ) { using Item = SeqItem < Seq > ; Optional < Item > prev , next = seq . next (); while ( next ) { prev = std :: move ( next ); next = seq . next (); } return prev ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inner_reduce // template < typename ReduceFn > struct InnerReduceBinder { ReduceFn reduce_fn ; }; template < typename ReduceFn > InnerReduceBinder < ReduceFn > inner_reduce ( ReduceFn && reduce_fn ) { return { BATT_FORWARD ( reduce_fn )}; } template < typename Seq , typename ReduceFn > [[ nodiscard ]] Optional < std :: decay_t < SeqItem < Seq >>> operator | ( Seq && seq , InnerReduceBinder < ReduceFn > binder ) { Optional < std :: decay_t < SeqItem < Seq >>> state = seq . next (); if ( ! state ) { return state ; } return BATT_FORWARD ( seq ) | reduce ( std :: move ( * state ), BATT_FORWARD ( binder . reduce_fn )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // single_item // template < typename T > class SingleItem { public : using Item = T ; explicit SingleItem ( T && item ) noexcept : item_ ( BATT_FORWARD ( item )) { } Optional < Item > peek () { return item_ ; } Optional < Item > next () { auto n = std :: move ( item_ ); item_ = None ; return n ; } private : Optional < Item > item_ ; }; template < typename T > [[ nodiscard ]] SingleItem < T > single_item ( T && item ) { return SingleItem < T > { BATT_FORWARD ( item )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // sum // struct SumBinder { }; inline SumBinder sum () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , SumBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::sum) Sequences may not be captured implicitly by reference.\" ); return BATT_FORWARD ( seq ) | reduce ( SeqItem < Seq > {}, []( auto && a , auto && b ) { return a + b ; }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // product // struct ProductBinder { }; inline ProductBinder product () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , ProductBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::product) Sequences may not be captured implicitly by reference.\" ); return BATT_FORWARD ( seq ) | reduce ( SeqItem < Seq > { 1 }, []( auto && a , auto && b ) { return a * b ; }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // any_true // struct AnyBinder { }; inline AnyBinder any_true () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , AnyBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::any_true) Sequences may not be captured implicitly by reference.\" ); bool ans = false ; BATT_FORWARD ( seq ) | for_each ([ & ans ]( auto && item ) { if ( bool { item }) { ans = true ; return LoopControl :: kBreak ; } return LoopControl :: kContinue ; }); return ans ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // all_true // struct AllBinder { }; inline AllBinder all_true () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , AllBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"(seq::all_true) Sequences may not be captured implicitly by reference.\" ); bool ans = true ; BATT_FORWARD ( seq ) | for_each ([ & ans ]( auto && item ) { if ( ! bool { item }) { ans = false ; return LoopControl :: kBreak ; } return LoopControl :: kContinue ; }); return ans ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map_adjacent(binary_map_fn) - // Transform [i0, i1, i2, i3, i4, ...] // into [f(i0, i1), f(i1, i2), f(i2, i3), ...] // template < typename Seq , typename Fn > class MapAdjacent { public : using Item = decltype ( std :: declval < Fn &> ()( std :: declval < const SeqItem < Seq >&> (), std :: declval < const SeqItem < Seq >&> ())); explicit MapAdjacent ( Seq && seq , Fn && fn ) noexcept : seq_ ( BATT_FORWARD ( seq )), fn_ ( BATT_FORWARD ( fn )) { } Optional < Item > peek () { return item_ . map ([ & ]( const auto & first ) { return seq_ . peek (). map ([ & ]( const auto & second ) { return fn_ ( first , second ); }); }); } Optional < Item > next () { if ( ! item_ ) { return None ; } auto first = std :: move ( * item_ ); item_ = seq_ . next (); return item_ . map ([ & ]( const auto & second ) { return fn_ ( first , second ); }); } private : Seq seq_ ; Fn fn_ ; Optional < SeqItem < Seq >> item_ { seq_ . next ()}; }; template < typename Fn > struct MapAdjacentBinder { Fn fn ; }; template < typename Fn > MapAdjacentBinder < Fn > map_adjacent ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn > [[ nodiscard ]] MapAdjacent < Seq , Fn > operator | ( Seq && seq , MapAdjacentBinder < Fn >&& binder ) { return MapAdjacent < Seq , Fn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // map_fold(state, map_fn) // // map_fn: (state, item) -> tuple<state, mapped_item> // // seq | map_fold(...): Seq<mapped_item> // // Threads a state variable through a map operation, so that each invocation // of the map function sees the folded state from previous items. // template < typename Seq , typename State , typename MapFn > class MapFold { public : using Item = std :: tuple_element_t < 1 , std :: invoke_result_t < MapFn , State , SeqItem < Seq >>> ; explicit MapFold ( Seq && seq , State && state , MapFn && map_fn ) noexcept : seq_ ( BATT_FORWARD ( seq )) , state_ ( BATT_FORWARD ( state )) , map_fn_ ( BATT_FORWARD ( map_fn )) { } Optional < Item > peek () { auto tr = seq_ . peek (). map ([ & ]( auto && item ) { return map_fn_ ( state_ , BATT_FORWARD ( item )); }); if ( ! tr ) { return None ; } // Don't update state if we are just peeking. return { std :: get < 1 > ( std :: move ( * tr ))}; } Optional < Item > next () { auto tr = seq_ . next (). map ([ & ]( auto && item ) { return map_fn_ ( state_ , BATT_FORWARD ( item )); }); if ( ! tr ) { return None ; } // Update state. state_ = std :: get < 0 > ( std :: move ( * tr )); return { std :: get < 1 > ( std :: move ( * tr ))}; } private : Seq seq_ ; State state_ ; MapFn map_fn_ ; }; template < typename State , typename MapFn > struct MapFoldBinder { State state ; MapFn map_fn ; }; template < typename State , typename MapFn > MapFoldBinder < State , MapFn > map_fold ( State && state , MapFn && map_fn ) { return { BATT_FORWARD ( state ), BATT_FORWARD ( map_fn )}; } template < typename Seq , typename State , typename MapFn > [[ nodiscard ]] MapFold < Seq , State , MapFn > operator | ( Seq && seq , MapFoldBinder < State , MapFn >&& binder ) { return MapFold < Seq , State , MapFn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . state ), BATT_FORWARD ( binder . map_fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // rolling(initial, binary_fn) // template < typename T , typename BinaryFn > struct RollingBinder { BinaryFn binary_fn ; T initial ; }; template < typename T , typename BinaryFn > inline RollingBinder < T , BinaryFn > rolling ( BinaryFn && binary_fn , T && initial = T {}) { return { BATT_FORWARD ( binary_fn ), BATT_FORWARD ( initial )}; } template < typename Seq , typename T , typename BinaryFn > [[ nodiscard ]] auto operator | ( Seq && seq , RollingBinder < T , BinaryFn >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Sequences may not be captured by reference.\" ); return BATT_FORWARD ( seq ) | map_fold ( BATT_FORWARD ( binder . initial ), [ binary_fn = BATT_FORWARD ( binder . binary_fn )]( auto a , auto b ) { auto c = binary_fn ( a , b ); return std :: make_tuple ( c , c ); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // running_total() // struct Addition { template < typename L , typename R > decltype ( auto ) operator ()( L && l , R && r ) const { return BATT_FORWARD ( l ) + BATT_FORWARD ( r ); } }; struct RunningTotalBinder { }; inline RunningTotalBinder running_total () { return {}; } template < typename Seq > [[ nodiscard ]] auto operator | ( Seq && seq , RunningTotalBinder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Sequences may not be captured by reference.\" ); using T = std :: decay_t < SeqItem < Seq >> ; return BATT_FORWARD ( seq ) | rolling < T > ( Addition {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inspect template < typename Fn > auto inspect ( Fn && fn ) { return map ([ fn = BATT_FORWARD ( fn )]( auto && item ) -> decltype ( auto ) { fn ( item ); return BATT_FORWARD ( item ); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // splice // template < typename OuterSeq , typename InnerSeq > class Splice { public : using OuterSeqRef = std :: add_lvalue_reference_t < OuterSeq > ; using Impl = Chain < TakeN < OuterSeqRef > , Chain < InnerSeq , OuterSeqRef >> ; using Item = SeqItem < Impl > ; explicit Splice ( OuterSeq && outer_seq , std :: size_t n , InnerSeq && inner_seq ) noexcept : outer_seq_ ( BATT_FORWARD ( outer_seq )) , impl_ { TakeN < OuterSeqRef > { outer_seq_ , n }, Chain < InnerSeq , OuterSeqRef > { BATT_FORWARD ( inner_seq ), outer_seq_ }} { } Optional < Item > peek () { return impl_ . peek (); } Optional < Item > next () { return impl_ . next (); } private : OuterSeq outer_seq_ ; Impl impl_ ; }; template < typename InnerSeq > struct SpliceBinder { std :: size_t n ; InnerSeq inner_seq ; }; template < typename InnerSeq > inline SpliceBinder < InnerSeq > splice ( std :: size_t n , InnerSeq && inner_seq ) { return { n , BATT_FORWARD ( inner_seq ), }; } template < typename OuterSeq , typename InnerSeq > [[ nodiscard ]] auto operator | ( OuterSeq && outer_seq , SpliceBinder < InnerSeq >&& binder ) { return Splice < OuterSeq , InnerSeq > { BATT_FORWARD ( outer_seq ), binder . n , BATT_FORWARD ( binder . inner_seq )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // is_sorted // template < typename Compare > struct IsSortedBinder { Compare compare ; }; template < typename Compare > IsSortedBinder < Compare > is_sorted_by ( Compare && compare ) { return { BATT_FORWARD ( compare )}; } inline auto is_sorted () { return is_sorted_by ([]( const auto & left , const auto & right ) { return ( left < right ) || ! ( right < left ); }); } template < typename Seq , typename Compare > [[ nodiscard ]] inline bool operator | ( Seq && seq , IsSortedBinder < Compare >&& binder ) { return BATT_FORWARD ( seq ) | map_adjacent ( BATT_FORWARD ( binder . compare )) | all_true (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inspect_adjacent(binary_fn) // template < typename Seq , typename Fn > class InspectAdjacent { public : using Item = SeqItem < Seq > ; explicit InspectAdjacent ( Seq && seq , Fn && fn ) noexcept : seq_ ( BATT_FORWARD ( seq )), fn_ ( BATT_FORWARD ( fn )) { } InspectAdjacent ( InspectAdjacent && that ) noexcept : seq_ ( BATT_FORWARD ( that . seq_ )) , fn_ ( BATT_FORWARD ( * that . fn_ )) , next_ ( BATT_FORWARD ( that . next_ )) { } InspectAdjacent & operator = ( InspectAdjacent && that ) noexcept { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = BATT_FORWARD ( that . seq_ ); this -> fn_ . emplace ( BATT_FORWARD ( * that . fn_ )); this -> next_ = BATT_FORWARD ( that . next_ ); } return * this ; } InspectAdjacent ( const InspectAdjacent & that ) : seq_ ( that . seq_ ), fn_ ( * that . fn_ ), next_ ( that . next_ ) { } InspectAdjacent & operator = ( const InspectAdjacent & that ) { if ( BATT_HINT_TRUE ( this != & that )) { this -> seq_ = that . seq_ ; this -> fn_ . emplace ( * that . fn_ ); this -> next_ = that . next_ ; } return * this ; } Optional < Item > peek () { return next_ ; } Optional < Item > next () { auto item = std :: move ( next_ ); next_ = seq_ . next (); if ( item && next_ ) { ( * fn_ )( * item , * next_ ); } return item ; } private : Seq seq_ ; Optional < Fn > fn_ ; Optional < SeqItem < Seq >> next_ { seq_ . next ()}; }; template < typename Fn > struct InspectAdjacentBinder { Fn fn ; }; template < typename Fn > InspectAdjacentBinder < Fn > inspect_adjacent ( Fn && fn ) { return { BATT_FORWARD ( fn )}; } template < typename Seq , typename Fn > InspectAdjacent < Seq , Fn > operator | ( Seq && seq , InspectAdjacentBinder < Fn >&& binder ) { return InspectAdjacent < Seq , Fn > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . fn )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // apply(seq_function) - apply a function to an entire sequence. // // Not to be confused with map, which applies some function to each item. // template < typename SeqFn > struct ApplyBinder { SeqFn seq_fn ; }; template < typename SeqFn > inline ApplyBinder < SeqFn > apply ( SeqFn && seq_fn ) { return { BATT_FORWARD ( seq_fn )}; } template < typename Seq , typename SeqFn > [[ nodiscard ]] inline decltype ( auto ) operator | ( Seq && seq , ApplyBinder < SeqFn >&& binder ) { return BATT_FORWARD ( binder . seq_fn )( BATT_FORWARD ( seq )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // attach(user_data) - attach a value to a sequence // template < typename Seq , typename Data > class Attach { public : using Item = SeqItem < Seq > ; using UserData = Data ; explicit Attach ( Seq && seq , Data && data ) noexcept : seq_ ( BATT_FORWARD ( seq )), data_ ( BATT_FORWARD ( data )) { } Data & user_data () { return data_ ; } const Data & user_data () const { return data_ ; } Optional < Item > peek () { return seq_ . peek (); } Optional < Item > next () { return seq_ . next (); } private : Seq seq_ ; Data data_ ; }; template < typename D > struct AttachBinder { D data ; }; template < typename D > inline AttachBinder < D > attach ( D && data ) { return { BATT_FORWARD ( data )}; } template < typename Seq , typename D > [[ nodiscard ]] inline auto operator | ( Seq && seq , AttachBinder < D >&& binder ) { static_assert ( std :: is_same_v < std :: decay_t < Seq > , Seq > , \"attach may not be used with references\" ); static_assert ( std :: is_same_v < std :: decay_t < D > , D > , \"attach may not be used with references\" ); return Attach < Seq , D > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . data )}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // fuse() - Seq<Optional<T>> => Seq<T>; take T while Optional<T> != None // template < typename Seq > class Fuse { public : using OptionalItem = SeqItem < Seq > ; using Item = typename std :: decay_t < OptionalItem >:: value_type ; explicit Fuse ( Seq && seq ) noexcept : seq_ ( BATT_FORWARD ( seq )) { } Optional < Item > peek () { if ( fused_ ) { return None ; } return * seq_ . peek (); } Optional < Item > next () { if ( fused_ ) { return None ; } Optional < Optional < Item >> opt_item = seq_ . next (); if ( ! opt_item ) { fused_ = true ; return None ; } if ( !* opt_item ) { fused_ = true ; return None ; } return std :: move ( * opt_item ); } private : bool fused_ = false ; Seq seq_ ; }; struct FuseBinder { }; inline FuseBinder fuse () { return {}; } template < typename Seq > [[ nodiscard ]] Fuse < Seq > operator | ( Seq && seq , FuseBinder ) { return Fuse < Seq > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/seq__item_8hpp/","text":"batteries/seq/seq_item.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::SeqItem_Impl Defines \ud83d\udd17 Name BATTERIES_SEQ_SEQ_ITEM_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_SEQ_ITEM_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_SEQ_ITEM_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_SEQ_ITEM_HPP #define BATTERIES_SEQ_SEQ_ITEM_HPP #include <batteries/config.hpp> // #include <type_traits> namespace batt { template < typename T > struct SeqItem_Impl { using type = typename std :: decay_t < T >:: Item ; static_assert ( ! std :: is_rvalue_reference_v < type > , \"\" ); }; template < typename T > using SeqItem = typename SeqItem_Impl < T >:: type ; } // namespace batt #endif // BATTERIES_SEQ_SEQ_ITEM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/seq_item.hpp"},{"location":"_autogen/Files/seq__item_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/seq__item_8hpp/#classes","text":"Name struct batt::SeqItem_Impl","title":"Classes"},{"location":"_autogen/Files/seq__item_8hpp/#defines","text":"Name BATTERIES_SEQ_SEQ_ITEM_HPP","title":"Defines"},{"location":"_autogen/Files/seq__item_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/seq__item_8hpp/#batteries_seq_seq_item_hpp","text":"1 #define BATTERIES_SEQ_SEQ_ITEM_HPP()","title":"BATTERIES_SEQ_SEQ_ITEM_HPP"},{"location":"_autogen/Files/seq__item_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_SEQ_ITEM_HPP #define BATTERIES_SEQ_SEQ_ITEM_HPP #include <batteries/config.hpp> // #include <type_traits> namespace batt { template < typename T > struct SeqItem_Impl { using type = typename std :: decay_t < T >:: Item ; static_assert ( ! std :: is_rvalue_reference_v < type > , \"\" ); }; template < typename T > using SeqItem = typename SeqItem_Impl < T >:: type ; } // namespace batt #endif // BATTERIES_SEQ_SEQ_ITEM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/shared__ptr_8hpp/","text":"batteries/shared_ptr.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::SharedPtrImpl Defines \ud83d\udd17 Name BATTERIES_SHARED_PTR_HPP Macro Documentation \ud83d\udd17 BATTERIES_SHARED_PTR_HPP \ud83d\udd17 1 #define BATTERIES_SHARED_PTR_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SHARED_PTR_HPP #define BATTERIES_SHARED_PTR_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> #include <boost/smart_ptr/intrusive_ptr.hpp> #include <boost/smart_ptr/intrusive_ref_counter.hpp> #include <memory> #include <type_traits> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Alias to add atomic reference counting intrusively to a class via base class. // template < typename T > using RefCounted = boost :: intrusive_ref_counter < std :: decay_t < T >> ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - namespace detail { template < typename T , // typename = decltype ( intrusive_ptr_add_ref (( T * ) nullptr )), // typename = decltype ( intrusive_ptr_release (( T * ) nullptr )) > std :: true_type is_ref_counted_impl ( void * ); template < typename T > std :: false_type is_ref_counted_impl (...); } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Type trait that determines whether T, when decayed, is intrusively reference counted. // template < typename T > using IsRefCounted = decltype ( detail :: is_ref_counted_impl < std :: decay_t < T >> ( nullptr )); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > struct SharedPtrImpl : std :: conditional < // If T derives from RefCounted<T> IsRefCounted < T > {}, // Then use intrusive_ptr boost :: intrusive_ptr < std :: remove_reference_t < T >> , // Else use shared_ptr std :: shared_ptr < std :: remove_reference_t < T >>> { }; template < typename T > using SharedPtr = typename SharedPtrImpl < T >:: type ; template < typename T , typename ... Args , typename = std :: enable_if_t < IsRefCounted < T > {} >> SharedPtr < T > make_shared ( Args && ... args ) { return SharedPtr < T > { new T ( BATT_FORWARD ( args )...)}; } template < typename T , typename ... Args , typename = std :: enable_if_t <! IsRefCounted < T > {} > , typename = void > SharedPtr < T > make_shared ( Args && ... args ) { return std :: make_shared < T > ( BATT_FORWARD ( args )...); } template < typename T > SharedPtr < T > into_shared ( std :: unique_ptr < T >&& ptr ) { return SharedPtr < T > { ptr . release ()}; } template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , std :: shared_ptr < std :: remove_reference_t < T >>>>> SharedPtr < T > shared_ptr_from ( T * that ) { return that -> shared_from_this (); } template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , boost :: intrusive_ptr < std :: remove_reference_t < T >>>> , typename = void > SharedPtr < T > shared_ptr_from ( T * that ) { return SharedPtr < T > { that }; } } // namespace batt #endif // BATTERIES_SHARED_PTR_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/shared_ptr.hpp"},{"location":"_autogen/Files/shared__ptr_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/shared__ptr_8hpp/#classes","text":"Name struct batt::SharedPtrImpl","title":"Classes"},{"location":"_autogen/Files/shared__ptr_8hpp/#defines","text":"Name BATTERIES_SHARED_PTR_HPP","title":"Defines"},{"location":"_autogen/Files/shared__ptr_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/shared__ptr_8hpp/#batteries_shared_ptr_hpp","text":"1 #define BATTERIES_SHARED_PTR_HPP()","title":"BATTERIES_SHARED_PTR_HPP"},{"location":"_autogen/Files/shared__ptr_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SHARED_PTR_HPP #define BATTERIES_SHARED_PTR_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> #include <boost/smart_ptr/intrusive_ptr.hpp> #include <boost/smart_ptr/intrusive_ref_counter.hpp> #include <memory> #include <type_traits> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Alias to add atomic reference counting intrusively to a class via base class. // template < typename T > using RefCounted = boost :: intrusive_ref_counter < std :: decay_t < T >> ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - namespace detail { template < typename T , // typename = decltype ( intrusive_ptr_add_ref (( T * ) nullptr )), // typename = decltype ( intrusive_ptr_release (( T * ) nullptr )) > std :: true_type is_ref_counted_impl ( void * ); template < typename T > std :: false_type is_ref_counted_impl (...); } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Type trait that determines whether T, when decayed, is intrusively reference counted. // template < typename T > using IsRefCounted = decltype ( detail :: is_ref_counted_impl < std :: decay_t < T >> ( nullptr )); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > struct SharedPtrImpl : std :: conditional < // If T derives from RefCounted<T> IsRefCounted < T > {}, // Then use intrusive_ptr boost :: intrusive_ptr < std :: remove_reference_t < T >> , // Else use shared_ptr std :: shared_ptr < std :: remove_reference_t < T >>> { }; template < typename T > using SharedPtr = typename SharedPtrImpl < T >:: type ; template < typename T , typename ... Args , typename = std :: enable_if_t < IsRefCounted < T > {} >> SharedPtr < T > make_shared ( Args && ... args ) { return SharedPtr < T > { new T ( BATT_FORWARD ( args )...)}; } template < typename T , typename ... Args , typename = std :: enable_if_t <! IsRefCounted < T > {} > , typename = void > SharedPtr < T > make_shared ( Args && ... args ) { return std :: make_shared < T > ( BATT_FORWARD ( args )...); } template < typename T > SharedPtr < T > into_shared ( std :: unique_ptr < T >&& ptr ) { return SharedPtr < T > { ptr . release ()}; } template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , std :: shared_ptr < std :: remove_reference_t < T >>>>> SharedPtr < T > shared_ptr_from ( T * that ) { return that -> shared_from_this (); } template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , boost :: intrusive_ptr < std :: remove_reference_t < T >>>> , typename = void > SharedPtr < T > shared_ptr_from ( T * that ) { return SharedPtr < T > { that }; } } // namespace batt #endif // BATTERIES_SHARED_PTR_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/single__thread__executor_8hpp/","text":"batteries/async/single_thread_executor.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batteries Defines \ud83d\udd17 Name BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP #define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP #include <batteries/config.hpp> // namespace batteries { } // namespace batteries #endif // BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/single_thread_executor.hpp"},{"location":"_autogen/Files/single__thread__executor_8hpp/#namespaces","text":"Name batteries","title":"Namespaces"},{"location":"_autogen/Files/single__thread__executor_8hpp/#defines","text":"Name BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP","title":"Defines"},{"location":"_autogen/Files/single__thread__executor_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/single__thread__executor_8hpp/#batteries_async_single_thread_executor_hpp","text":"1 #define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP()","title":"BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP"},{"location":"_autogen/Files/single__thread__executor_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP #define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP #include <batteries/config.hpp> // namespace batteries { } // namespace batteries #endif // BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/skip__n_8hpp/","text":"batteries/seq/skip_n.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::SkipNBinder class batt::SkipN Defines \ud83d\udd17 Name BATTERIES_SEQ_SKIP_N_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_SKIP_N_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_SKIP_N_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_SKIP_N_HPP #define BATTERIES_SEQ_SKIP_N_HPP #include <batteries/config.hpp> // #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/utility.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // skip(n) // struct SkipNBinder { usize n ; }; inline SkipNBinder skip_n ( usize n ) { return { n }; } template < typename Seq > class SkipN { public : using Item = SeqItem < Seq > ; explicit SkipN ( Seq && seq , usize n ) noexcept : seq_ ( BATT_FORWARD ( seq )), n_ { n } { } Optional < Item > peek () { if ( n_ != 0 ) { return None ; } return seq_ . peek (); } Optional < Item > next () { if ( n_ != 0 ) { -- n_ ; ( void ) seq_ . next (); return None ; } return seq_ . next (); } private : Seq seq_ ; usize n_ ; }; template < typename Seq , typename = EnableIfSeq < Seq >> [[ nodiscard ]] SkipN < Seq > operator | ( Seq && seq , const SkipNBinder & binder ) { return SkipN < Seq > { BATT_FORWARD ( seq ), binder . n }; } } // namespace batt #endif // BATTERIES_SEQ_SKIP_N_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/skip_n.hpp"},{"location":"_autogen/Files/skip__n_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/skip__n_8hpp/#classes","text":"Name struct batt::SkipNBinder class batt::SkipN","title":"Classes"},{"location":"_autogen/Files/skip__n_8hpp/#defines","text":"Name BATTERIES_SEQ_SKIP_N_HPP","title":"Defines"},{"location":"_autogen/Files/skip__n_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/skip__n_8hpp/#batteries_seq_skip_n_hpp","text":"1 #define BATTERIES_SEQ_SKIP_N_HPP()","title":"BATTERIES_SEQ_SKIP_N_HPP"},{"location":"_autogen/Files/skip__n_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_SKIP_N_HPP #define BATTERIES_SEQ_SKIP_N_HPP #include <batteries/config.hpp> // #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/utility.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // skip(n) // struct SkipNBinder { usize n ; }; inline SkipNBinder skip_n ( usize n ) { return { n }; } template < typename Seq > class SkipN { public : using Item = SeqItem < Seq > ; explicit SkipN ( Seq && seq , usize n ) noexcept : seq_ ( BATT_FORWARD ( seq )), n_ { n } { } Optional < Item > peek () { if ( n_ != 0 ) { return None ; } return seq_ . peek (); } Optional < Item > next () { if ( n_ != 0 ) { -- n_ ; ( void ) seq_ . next (); return None ; } return seq_ . next (); } private : Seq seq_ ; usize n_ ; }; template < typename Seq , typename = EnableIfSeq < Seq >> [[ nodiscard ]] SkipN < Seq > operator | ( Seq && seq , const SkipNBinder & binder ) { return SkipN < Seq > { BATT_FORWARD ( seq ), binder . n }; } } // namespace batt #endif // BATTERIES_SEQ_SKIP_N_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/slice_8hpp/","text":"batteries/slice.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_SLICE_HPP Macro Documentation \ud83d\udd17 BATTERIES_SLICE_HPP \ud83d\udd17 1 #define BATTERIES_SLICE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SLICE_HPP #define BATTERIES_SLICE_HPP #include <batteries/config.hpp> // #include <batteries/interval.hpp> #include <batteries/seq.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/range/begin.hpp> #include <boost/range/iterator_range.hpp> #include <memory> #include <type_traits> #include <utility> namespace batt { template < typename T > using Slice = boost :: iterator_range < T *> ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T , typename DataT = decltype ( std :: declval < T > (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < ElementT > as_slice ( T && container ) { return Slice < ElementT > { container . data (), container . data () + container . size ()}; } template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , ElementT * end ) { return Slice < ElementT > { begin , end }; } template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , usize size ) { return Slice < ElementT > { begin , begin + size }; } template < typename ElementT > Slice < ElementT > as_slice ( const Slice < ElementT >& slice ) { return slice ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , const ElementT * end ) { return Slice < const ElementT > { begin , end }; } template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , usize size ) { return as_const_slice ( begin , size ); } template < typename T , typename DataT = decltype ( std :: declval < const T &> (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < const ElementT > as_const_slice ( const T & container ) { return as_const_slice ( container . data (), container . data () + container . size ()); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename ElementT > Slice < ElementT > empty_slice ( StaticType < ElementT > = {}) { static std :: aligned_storage_t < sizeof ( ElementT ), alignof ( ElementT ) > storage_ ; return as_slice ( reinterpret_cast < ElementT *> ( & storage_ ), 0 ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T > SubRangeSeq < Slice < T >> as_seq ( const Slice < T >& s ) { return SubRangeSeq < Slice < T >> { batt :: make_copy ( s )}; } template < typename T > auto as_seq ( Slice < T >& s ) { return as_seq ( const_cast < const Slice < T >&> ( s )); } template < typename T > auto as_seq ( Slice < T >&& s ) { return as_seq ( const_cast < const Slice < T >&> ( s )); } template < typename T > auto as_seq ( const Slice < T >&& s ) { return as_seq ( const_cast < const Slice < T >&> ( s )); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Iter > boost :: iterator_range < Iter > as_range ( const std :: pair < Iter , Iter >& p ) { return boost :: make_iterator_range ( p . first , p . second ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename RangeT , typename Iter = std :: decay_t < decltype ( boost :: begin ( std :: declval < RangeT > ())) > , typename OffsetT , typename = std :: enable_if_t < std :: is_integral_v < OffsetT >>> boost :: iterator_range < Iter > slice_range ( RangeT && range , const Interval < OffsetT >& i ) { return boost :: make_iterator_range ( std :: next ( boost :: begin ( range ), i . lower_bound ), std :: next ( boost :: begin ( range ), i . upper_bound )); } } // namespace batt #endif // BATTERIES_SLICE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/slice.hpp"},{"location":"_autogen/Files/slice_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/slice_8hpp/#defines","text":"Name BATTERIES_SLICE_HPP","title":"Defines"},{"location":"_autogen/Files/slice_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/slice_8hpp/#batteries_slice_hpp","text":"1 #define BATTERIES_SLICE_HPP()","title":"BATTERIES_SLICE_HPP"},{"location":"_autogen/Files/slice_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SLICE_HPP #define BATTERIES_SLICE_HPP #include <batteries/config.hpp> // #include <batteries/interval.hpp> #include <batteries/seq.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/range/begin.hpp> #include <boost/range/iterator_range.hpp> #include <memory> #include <type_traits> #include <utility> namespace batt { template < typename T > using Slice = boost :: iterator_range < T *> ; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T , typename DataT = decltype ( std :: declval < T > (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < ElementT > as_slice ( T && container ) { return Slice < ElementT > { container . data (), container . data () + container . size ()}; } template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , ElementT * end ) { return Slice < ElementT > { begin , end }; } template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , usize size ) { return Slice < ElementT > { begin , begin + size }; } template < typename ElementT > Slice < ElementT > as_slice ( const Slice < ElementT >& slice ) { return slice ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , const ElementT * end ) { return Slice < const ElementT > { begin , end }; } template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , usize size ) { return as_const_slice ( begin , size ); } template < typename T , typename DataT = decltype ( std :: declval < const T &> (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < const ElementT > as_const_slice ( const T & container ) { return as_const_slice ( container . data (), container . data () + container . size ()); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename ElementT > Slice < ElementT > empty_slice ( StaticType < ElementT > = {}) { static std :: aligned_storage_t < sizeof ( ElementT ), alignof ( ElementT ) > storage_ ; return as_slice ( reinterpret_cast < ElementT *> ( & storage_ ), 0 ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T > SubRangeSeq < Slice < T >> as_seq ( const Slice < T >& s ) { return SubRangeSeq < Slice < T >> { batt :: make_copy ( s )}; } template < typename T > auto as_seq ( Slice < T >& s ) { return as_seq ( const_cast < const Slice < T >&> ( s )); } template < typename T > auto as_seq ( Slice < T >&& s ) { return as_seq ( const_cast < const Slice < T >&> ( s )); } template < typename T > auto as_seq ( const Slice < T >&& s ) { return as_seq ( const_cast < const Slice < T >&> ( s )); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename Iter > boost :: iterator_range < Iter > as_range ( const std :: pair < Iter , Iter >& p ) { return boost :: make_iterator_range ( p . first , p . second ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename RangeT , typename Iter = std :: decay_t < decltype ( boost :: begin ( std :: declval < RangeT > ())) > , typename OffsetT , typename = std :: enable_if_t < std :: is_integral_v < OffsetT >>> boost :: iterator_range < Iter > slice_range ( RangeT && range , const Interval < OffsetT >& i ) { return boost :: make_iterator_range ( std :: next ( boost :: begin ( range ), i . lower_bound ), std :: next ( boost :: begin ( range ), i . upper_bound )); } } // namespace batt #endif // BATTERIES_SLICE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/slice__work_8hpp/","text":"batteries/async/slice_work.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::WorkSliceParams struct batt::WorkSlicePlan Defines \ud83d\udd17 Name BATTERIES_ASYNC_SLICE_WORK_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_SLICE_WORK_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_SLICE_WORK_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_SLICE_WORK_HPP #define BATTERIES_ASYNC_SLICE_WORK_HPP #include <batteries/config.hpp> // #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/strong_typedef.hpp> #include <algorithm> namespace batt { BATT_STRONG_TYPEDEF ( usize , TaskCount ); BATT_STRONG_TYPEDEF ( usize , InputSize ); BATT_STRONG_TYPEDEF ( usize , TaskSize ); BATT_STRONG_TYPEDEF ( usize , TaskIndex ); BATT_STRONG_TYPEDEF ( isize , TaskOffset ); template < typename Iter > inline InputSize get_input_size ( const Iter & first , const Iter & last ) { BATT_CHECK_LE ( first , last ); return InputSize { static_cast < usize > ( std :: distance ( first , last ))}; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Parameters that control the formation of a work-slicing plan (WorkSlicePlan). // struct WorkSliceParams { // This isn't too meaningful, as it is a unitless quantity, but supposing it is number of bytes to be // loaded from memory, we define this as a half kilobyte as a \"safe\" lower bound on how small an amount of // data can be transferred to a CPU for processing, without being so small as to not be worth it. // static constexpr TaskSize kDefaultMinTaskSize { 512 }; // Returns reasonable defaults for slicing work to be performed by the given WorkerPool. // static WorkSliceParams from_worker_pool ( WorkerPool & worker_pool ) { return WorkSliceParams { . min_task_size = WorkSliceParams :: kDefaultMinTaskSize , . max_tasks = TaskCount { worker_pool . size () + 1 }, }; } // The minimum size to assign to a task (slice). This depends on the round-trip communication latency // within a WorkerPool and the cost of the computation to be performed on a given amount of input. Too // small and we spend more time transferring data than doing useful work (it would have been cheaper just // to do it locally); too large and we may under-utilize compute resources. // TaskSize min_task_size ; // The maximum number of slices (tasks) to create for parallel execution. This is informed by the amount // of independent execution resources available and the expected variance in cost between work slices. // TaskCount max_tasks ; }; std :: ostream & operator << ( std :: ostream & out , const WorkSliceParams & t ); // Apply the given WorkSliceParams to the given InputSize to produce a target TaskSize. // // The returned value must not be smaller than `params.min_task_size` and large enough so that `input_size / // task_size <= params.max_tasks`. // inline TaskSize get_task_size ( const WorkSliceParams & params , InputSize input_size ) { BATT_CHECK_GT ( params . max_tasks , 0u ); BATT_CHECK_GT ( params . min_task_size , 0u ); return TaskSize { std :: max < usize > ( params . min_task_size , ( input_size + params . max_tasks - 1 ) / params . max_tasks )}; } inline TaskCount get_task_count ( InputSize input_size , TaskSize task_size ) { BATT_CHECK_GT ( task_size , 0u ); return TaskCount {( input_size + task_size - 1 ) / task_size }; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // An abstract plan for slicing up some amount of work into smaller tasks of roughly equal size that can // be executed in parallel. // struct WorkSlicePlan { explicit WorkSlicePlan ( const WorkSliceParams & params , InputSize input_size ) noexcept ; template < typename Iter > explicit WorkSlicePlan ( const WorkSliceParams & params , const Iter & first , const Iter & last ) noexcept ; // A metric on the total amount of work to be done. // InputSize input_size ; // The target amount of `input_size` to be apportioned to each task. // TaskSize task_size ; // The target number of tasks (slices) into which to divide the overall work. // TaskCount n_tasks ; }; std :: ostream & operator << ( std :: ostream & out , const WorkSlicePlan & t ); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Divide an input range into equal sized pieces and schedule work tasks for each by invoking the // WorkFnGenerator. The final task is run on the calling thread. // // `WorkFnGenerator`: auto(usize task_index, isize task_offset, isize task_size) -> void() // template < typename WorkFnGenerator > void slice_work ( WorkContext & context , const WorkSlicePlan & plan , WorkFnGenerator && gen_work_fn ) { if ( plan . input_size == 0 ) { return ; } BATT_CHECK_GT ( plan . n_tasks , 0 ); BATT_CHECK_GT ( plan . task_size , 0 ); usize task_index = 0 ; isize task_offset = 0 ; usize input_remaining = plan . input_size ; while ( input_remaining > 0 ) { const usize this_task_size = std :: min < usize > ( input_remaining , plan . task_size ); auto work_fn = gen_work_fn ( TaskIndex { task_index }, TaskOffset { task_offset }, TaskSize { this_task_size }); task_index += 1 ; task_offset += this_task_size ; input_remaining -= this_task_size ; if ( task_index == plan . n_tasks ) { work_fn (); } else { context . async_run ( BATT_FORWARD ( work_fn )); } } BATT_CHECK_EQ ( task_index , plan . n_tasks ); } } // namespace batt #include <batteries/async/slice_work_impl.hpp> #endif // BATTERIES_ASYNC_SLICE_WORK_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/slice_work.hpp"},{"location":"_autogen/Files/slice__work_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/slice__work_8hpp/#classes","text":"Name struct batt::WorkSliceParams struct batt::WorkSlicePlan","title":"Classes"},{"location":"_autogen/Files/slice__work_8hpp/#defines","text":"Name BATTERIES_ASYNC_SLICE_WORK_HPP","title":"Defines"},{"location":"_autogen/Files/slice__work_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/slice__work_8hpp/#batteries_async_slice_work_hpp","text":"1 #define BATTERIES_ASYNC_SLICE_WORK_HPP()","title":"BATTERIES_ASYNC_SLICE_WORK_HPP"},{"location":"_autogen/Files/slice__work_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_SLICE_WORK_HPP #define BATTERIES_ASYNC_SLICE_WORK_HPP #include <batteries/config.hpp> // #include <batteries/async/work_context.hpp> #include <batteries/async/worker_pool.hpp> #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/strong_typedef.hpp> #include <algorithm> namespace batt { BATT_STRONG_TYPEDEF ( usize , TaskCount ); BATT_STRONG_TYPEDEF ( usize , InputSize ); BATT_STRONG_TYPEDEF ( usize , TaskSize ); BATT_STRONG_TYPEDEF ( usize , TaskIndex ); BATT_STRONG_TYPEDEF ( isize , TaskOffset ); template < typename Iter > inline InputSize get_input_size ( const Iter & first , const Iter & last ) { BATT_CHECK_LE ( first , last ); return InputSize { static_cast < usize > ( std :: distance ( first , last ))}; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Parameters that control the formation of a work-slicing plan (WorkSlicePlan). // struct WorkSliceParams { // This isn't too meaningful, as it is a unitless quantity, but supposing it is number of bytes to be // loaded from memory, we define this as a half kilobyte as a \"safe\" lower bound on how small an amount of // data can be transferred to a CPU for processing, without being so small as to not be worth it. // static constexpr TaskSize kDefaultMinTaskSize { 512 }; // Returns reasonable defaults for slicing work to be performed by the given WorkerPool. // static WorkSliceParams from_worker_pool ( WorkerPool & worker_pool ) { return WorkSliceParams { . min_task_size = WorkSliceParams :: kDefaultMinTaskSize , . max_tasks = TaskCount { worker_pool . size () + 1 }, }; } // The minimum size to assign to a task (slice). This depends on the round-trip communication latency // within a WorkerPool and the cost of the computation to be performed on a given amount of input. Too // small and we spend more time transferring data than doing useful work (it would have been cheaper just // to do it locally); too large and we may under-utilize compute resources. // TaskSize min_task_size ; // The maximum number of slices (tasks) to create for parallel execution. This is informed by the amount // of independent execution resources available and the expected variance in cost between work slices. // TaskCount max_tasks ; }; std :: ostream & operator << ( std :: ostream & out , const WorkSliceParams & t ); // Apply the given WorkSliceParams to the given InputSize to produce a target TaskSize. // // The returned value must not be smaller than `params.min_task_size` and large enough so that `input_size / // task_size <= params.max_tasks`. // inline TaskSize get_task_size ( const WorkSliceParams & params , InputSize input_size ) { BATT_CHECK_GT ( params . max_tasks , 0u ); BATT_CHECK_GT ( params . min_task_size , 0u ); return TaskSize { std :: max < usize > ( params . min_task_size , ( input_size + params . max_tasks - 1 ) / params . max_tasks )}; } inline TaskCount get_task_count ( InputSize input_size , TaskSize task_size ) { BATT_CHECK_GT ( task_size , 0u ); return TaskCount {( input_size + task_size - 1 ) / task_size }; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // An abstract plan for slicing up some amount of work into smaller tasks of roughly equal size that can // be executed in parallel. // struct WorkSlicePlan { explicit WorkSlicePlan ( const WorkSliceParams & params , InputSize input_size ) noexcept ; template < typename Iter > explicit WorkSlicePlan ( const WorkSliceParams & params , const Iter & first , const Iter & last ) noexcept ; // A metric on the total amount of work to be done. // InputSize input_size ; // The target amount of `input_size` to be apportioned to each task. // TaskSize task_size ; // The target number of tasks (slices) into which to divide the overall work. // TaskCount n_tasks ; }; std :: ostream & operator << ( std :: ostream & out , const WorkSlicePlan & t ); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Divide an input range into equal sized pieces and schedule work tasks for each by invoking the // WorkFnGenerator. The final task is run on the calling thread. // // `WorkFnGenerator`: auto(usize task_index, isize task_offset, isize task_size) -> void() // template < typename WorkFnGenerator > void slice_work ( WorkContext & context , const WorkSlicePlan & plan , WorkFnGenerator && gen_work_fn ) { if ( plan . input_size == 0 ) { return ; } BATT_CHECK_GT ( plan . n_tasks , 0 ); BATT_CHECK_GT ( plan . task_size , 0 ); usize task_index = 0 ; isize task_offset = 0 ; usize input_remaining = plan . input_size ; while ( input_remaining > 0 ) { const usize this_task_size = std :: min < usize > ( input_remaining , plan . task_size ); auto work_fn = gen_work_fn ( TaskIndex { task_index }, TaskOffset { task_offset }, TaskSize { this_task_size }); task_index += 1 ; task_offset += this_task_size ; input_remaining -= this_task_size ; if ( task_index == plan . n_tasks ) { work_fn (); } else { context . async_run ( BATT_FORWARD ( work_fn )); } } BATT_CHECK_EQ ( task_index , plan . n_tasks ); } } // namespace batt #include <batteries/async/slice_work_impl.hpp> #endif // BATTERIES_ASYNC_SLICE_WORK_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/slice__work__impl_8hpp/","text":"batteries/async/slice_work_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP #define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP #include <batteries/config.hpp> #include <batteries/async/slice_work.hpp> #include <ostream> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const WorkSliceParams & t ) { return out << \"WorkSliceParams{.min_task_size=\" << t . min_task_size << \", .max_tasks=\" << t . max_tasks << \",}\" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ WorkSlicePlan :: WorkSlicePlan ( const WorkSliceParams & params , InputSize input_size ) noexcept : input_size { input_size } , task_size { get_task_size ( params , this -> input_size )} , n_tasks { get_task_count ( this -> input_size , this -> task_size )} { BATT_CHECK_GE ( this -> task_size , params . min_task_size ) << BATT_INSPECT ( * this ) << BATT_INSPECT ( params ); BATT_CHECK_LE ( this -> n_tasks , params . max_tasks ) << BATT_INSPECT ( * this ) << BATT_INSPECT ( params ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter > BATT_INLINE_IMPL /*explicit*/ WorkSlicePlan :: WorkSlicePlan ( const WorkSliceParams & params , const Iter & first , const Iter & last ) noexcept : WorkSlicePlan { params , get_input_size ( first , last )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const WorkSlicePlan & t ) { return out << \"WorkSlicePlan{.input_size=\" << t . input_size << \", .task_size=\" << t . task_size << \", .n_tasks=\" << t . n_tasks << \",}\" ; } } // namespace batt #endif // BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/slice_work_impl.hpp"},{"location":"_autogen/Files/slice__work__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/slice__work__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/slice__work__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/slice__work__impl_8hpp/#batteries_async_slice_work_impl_hpp","text":"1 #define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP()","title":"BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP"},{"location":"_autogen/Files/slice__work__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP #define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP #include <batteries/config.hpp> #include <batteries/async/slice_work.hpp> #include <ostream> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const WorkSliceParams & t ) { return out << \"WorkSliceParams{.min_task_size=\" << t . min_task_size << \", .max_tasks=\" << t . max_tasks << \",}\" ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ WorkSlicePlan :: WorkSlicePlan ( const WorkSliceParams & params , InputSize input_size ) noexcept : input_size { input_size } , task_size { get_task_size ( params , this -> input_size )} , n_tasks { get_task_count ( this -> input_size , this -> task_size )} { BATT_CHECK_GE ( this -> task_size , params . min_task_size ) << BATT_INSPECT ( * this ) << BATT_INSPECT ( params ); BATT_CHECK_LE ( this -> n_tasks , params . max_tasks ) << BATT_INSPECT ( * this ) << BATT_INSPECT ( params ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename Iter > BATT_INLINE_IMPL /*explicit*/ WorkSlicePlan :: WorkSlicePlan ( const WorkSliceParams & params , const Iter & first , const Iter & last ) noexcept : WorkSlicePlan { params , get_input_size ( first , last )} { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const WorkSlicePlan & t ) { return out << \"WorkSlicePlan{.input_size=\" << t . input_size << \", .task_size=\" << t . task_size << \", .n_tasks=\" << t . n_tasks << \",}\" ; } } // namespace batt #endif // BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/small__fn_8hpp/","text":"batteries/small_fn.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name class batt::SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. class batt::detail::AbstractMoveFn class batt::detail::AbstractCopyFn class batt::detail::MoveFnImpl class batt::detail::CopyFnImpl class batt::detail::AbstractMoveFn class batt::detail::AbstractCopyFn class batt::detail::MoveFnImpl class batt::detail::CopyFnImpl class batt::kMoveOnly Defines \ud83d\udd17 Name BATTERIES_SMALL_FUNCTION_HPP BATT_REQUIRE_COPYABLE BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY (cv_qual) BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY (cv_qual) Macro Documentation \ud83d\udd17 BATTERIES_SMALL_FUNCTION_HPP \ud83d\udd17 1 #define BATTERIES_SMALL_FUNCTION_HPP() BATT_REQUIRE_COPYABLE \ud83d\udd17 1 #define BATT_REQUIRE_COPYABLE() BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY \ud83d\udd17 1 #define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual) BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY \ud83d\udd17 1 #define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SMALL_FUNCTION_HPP #define BATTERIES_SMALL_FUNCTION_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/cpu_align.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <batteries/static_assert.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ), bool kMoveOnly = false > class SmallFn ; template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ) > using UniqueSmallFn = SmallFn < Signature , kMaxSize , /*kMoveOnly=*/ true > ; namespace detail { // Forward declare the abstract base class templates for function type erasure. // template < bool kMoveOnly , typename Result , typename ... Args > class AbstractMoveFn ; template < typename Result , typename ... Args > class AbstractCopyFn ; // Templated alias for the type-erased function interface; kMoveOnly controls // whether copy semantics are enabled. // template < bool kMoveOnly , typename Result , typename ... Args > using AbstractFn = std :: conditional_t < kMoveOnly , AbstractMoveFn < true , Result , Args ... > , AbstractCopyFn < Result , Args ... >> ; // Forward declare the implementation class templates for function type erasure. // template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > class MoveFnImpl ; template < typename Fn , typename Result , typename ... Args > class CopyFnImpl ; template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > using FnImpl = std :: conditional_t < kMoveOnly , MoveFnImpl < Fn , kMoveOnly , Result , Args ... > , CopyFnImpl < Fn , Result , Args ... >> ; // Base class for abstract function types. Defines the common // interface/concept for move-only and copyable functions: // - Invocable (with the signature `auto(Args...)->Result`) // - Move-Constructible/Assignable // - Destructible // template < bool kMoveOnly , typename Result , typename ... Args > class AbstractMoveFn { protected : AbstractMoveFn () = default ; public : AbstractMoveFn ( const AbstractMoveFn & ) = delete ; AbstractMoveFn & operator = ( const AbstractMoveFn & ) = delete ; virtual ~ AbstractMoveFn () = default ; virtual auto invoke ( Args ... args ) noexcept -> Result = 0 ; // Move construct from `this` into `storage`. `size` MUST be big enough to // fit the stored function, otherwise this method will assert-crash. // Invalidates `this`; `invoke` must not be called after `move`. // virtual auto move ( void * storage , usize size ) noexcept -> AbstractFn < kMoveOnly , Result , Args ... >* = 0 ; }; // Adds copy semantics to the basic type-erased concept. // template < typename Result , typename ... Args > class AbstractCopyFn : public AbstractMoveFn < false , Result , Args ... > { public : using AbstractMoveFn < false , Result , Args ... >:: AbstractMoveFn ; // Copy construct from `this` into `storage`. `size` MUST be big enough to // fit the stored function, otherwise this method will assert-crash. // virtual auto copy ( void * memory , usize size ) const noexcept -> AbstractFn < false , Result , Args ... >* = 0 ; // Same as `copy`, but the returned type-erased object drops the ability to // copy in favor of a move-only interface. // virtual auto copy_to_move_only ( void * memory , usize size ) const noexcept -> AbstractFn < true , Result , Args ... >* = 0 ; }; // Implements the basic concept; can be extended because `fn_` is protected, // not private. // template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > class MoveFnImpl : public AbstractFn < kMoveOnly , Result , Args ... > { public : using self_type = MoveFnImpl ; template < typename FnRef > explicit MoveFnImpl ( FnRef && ref ) : fn_ ( BATT_FORWARD ( ref )) { } Result invoke ( Args ... args ) noexcept override { return fn_ ( BATT_FORWARD ( args )...); } AbstractFn < kMoveOnly , Result , Args ... >* move ( void * memory , usize size ) noexcept override { BATT_CHECK_LE ( sizeof ( self_type ), size ); return new ( memory ) FnImpl < Fn , kMoveOnly , Result , Args ... > ( std :: move ( fn_ )); } protected : Fn fn_ ; }; // Extends MoveFnImpl to implement copy semantics in terms of the concrete // type `Fn`. // template < typename Fn , typename Result , typename ... Args > class CopyFnImpl : public MoveFnImpl < Fn , /*kMoveOnly=*/ false , Result , Args ... > { public : using self_type = CopyFnImpl ; using MoveFnImpl < Fn , /*kMoveOnly=*/ false , Result , Args ... >:: MoveFnImpl ; AbstractFn < false , Result , Args ... >* copy ( void * memory , usize size ) const noexcept override { BATT_CHECK_LE ( sizeof ( self_type ), size ); return new ( memory ) FnImpl < Fn , /*kMoveOnly=*/ false , Result , Args ... > ( this -> fn_ ); } AbstractFn < true , Result , Args ... >* copy_to_move_only ( void * memory , usize size ) const noexcept override { BATT_CHECK_LE ( sizeof ( self_type ), size ); return new ( memory ) FnImpl < Fn , /*kMoveOnly=*/ true , Result , Args ... > ( this -> fn_ ); } }; } // namespace detail template < typename ... Args , typename Result , usize kMaxSize , bool kMoveOnly > class SmallFn < auto ( Args ...) -> Result , kMaxSize , kMoveOnly > { template < typename , usize , bool > friend class SmallFn ; // The type-erased interface to use, depending on the value of `kMoveOnly`. // using AbstractFn = detail :: AbstractFn < kMoveOnly , Result , Args ... > ; // The concrete type erasure, depending on the value of `kMoveOnly`. // template < typename Fn > using FnImpl = detail :: FnImpl < Fn , kMoveOnly , Result , Args ... > ; #define BATT_REQUIRE_COPYABLE static_assert(!kMoveOnly, \"This kind of SmallFn is move-only!\") template < typename Fn > static auto check_fn_size ( Fn && fn ) -> Fn && { BATT_STATIC_ASSERT_LE ( sizeof ( FnImpl < std :: decay_t < Fn >> ), kMaxSize ); // \"Passed function is not small!\" return BATT_FORWARD ( fn ); } public : using self_type = SmallFn ; using result_type = Result ; SmallFn () = default ; template < typename Fn , typename = EnableIfNoShadow < SmallFn , Fn > , typename = std :: enable_if_t < IsCallable < Fn , Args ... > {} >> SmallFn ( Fn && fn ) noexcept : impl_ { new ( & storage_ ) FnImpl < std :: decay_t < Fn >> ( check_fn_size ( BATT_FORWARD ( fn )))} { } SmallFn ( self_type && that ) noexcept : impl_ {[ & ] { auto impl = BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> move ( & storage_ , kMaxSize ) : nullptr ; that . clear (); return impl ; }()} { } SmallFn ( const self_type & that ) noexcept : impl_ {[ & ] { BATT_REQUIRE_COPYABLE ; return BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> copy ( & storage_ , kMaxSize ) : nullptr ; }()} { } #define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual) \\ template <usize kThatSize, typename = std::enable_if_t<kThatSize <= kMaxSize && kMoveOnly>> \\ SmallFn(cv_qual SmallFn<Result(Args...), kThatSize, /*kMoveOnly=*/ false>& that) noexcept \\ : impl_{that.impl_->copy_to_move_only(&storage_, kMaxSize)} \\ { \\ } BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY () BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY ( const ) #undef BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY ~ SmallFn () noexcept { clear (); } auto clear () noexcept -> void { if ( BATT_HINT_TRUE ( impl_ != nullptr )) { impl_ ->~ AbstractFn (); impl_ = nullptr ; } } auto operator = ( std :: nullptr_t ) noexcept -> self_type & { this -> clear (); return * this ; } template < typename Fn , typename = EnableIfNoShadow < SmallFn , Fn >> auto operator = ( Fn && fn ) noexcept -> self_type & { clear (); impl_ = new ( & storage_ ) FnImpl < std :: decay_t < Fn >> ( std :: forward < Fn > ( fn )); return * this ; } auto operator = ( self_type && that ) noexcept -> self_type & { if ( BATT_HINT_TRUE ( this != & that )) { clear (); impl_ = BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> move ( & storage_ , kMaxSize ) : nullptr ; that . clear (); } return * this ; } auto operator = ( const self_type & that ) noexcept -> self_type & { BATT_REQUIRE_COPYABLE ; if ( BATT_HINT_TRUE ( this != & that )) { clear (); impl_ = BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> copy ( & storage_ , kMaxSize ) : nullptr ; } return * this ; } #define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual) \\ template <usize kThatSize, typename = std::enable_if_t<kThatSize <= kMaxSize && kMoveOnly>> \\ auto operator=(cv_qual SmallFn<Result(Args...), kThatSize, false>& that) noexcept->self_type& \\ { \\ clear(); \\ impl_ = that.impl_->copy_to_move_only(&storage_, kMaxSize); \\ \\ return *this; \\ } BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY () BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY ( const ) #undef BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY explicit operator bool () const noexcept { return impl_ != nullptr ; } auto operator ()( Args ... args ) const -> Result { BATT_ASSERT_NOT_NULLPTR ( impl_ ); return impl_ -> invoke ( BATT_FORWARD ( args )...); } private : std :: aligned_storage_t < kMaxSize > storage_ ; // must come before `impl_` AbstractFn * impl_ = nullptr ; #undef BATT_REQUIRE_COPYABLE }; // class SmallFn } // namespace batt #endif // BATTERIES_SMALL_FUNCTION_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/small_fn.hpp"},{"location":"_autogen/Files/small__fn_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/small__fn_8hpp/#classes","text":"Name class batt::SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. class batt::detail::AbstractMoveFn class batt::detail::AbstractCopyFn class batt::detail::MoveFnImpl class batt::detail::CopyFnImpl class batt::detail::AbstractMoveFn class batt::detail::AbstractCopyFn class batt::detail::MoveFnImpl class batt::detail::CopyFnImpl class batt::kMoveOnly","title":"Classes"},{"location":"_autogen/Files/small__fn_8hpp/#defines","text":"Name BATTERIES_SMALL_FUNCTION_HPP BATT_REQUIRE_COPYABLE BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY (cv_qual) BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY (cv_qual)","title":"Defines"},{"location":"_autogen/Files/small__fn_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/small__fn_8hpp/#batteries_small_function_hpp","text":"1 #define BATTERIES_SMALL_FUNCTION_HPP()","title":"BATTERIES_SMALL_FUNCTION_HPP"},{"location":"_autogen/Files/small__fn_8hpp/#batt_require_copyable","text":"1 #define BATT_REQUIRE_COPYABLE()","title":"BATT_REQUIRE_COPYABLE"},{"location":"_autogen/Files/small__fn_8hpp/#batt_small_fn_construct_move_only_from_copy","text":"1 #define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual)","title":"BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY"},{"location":"_autogen/Files/small__fn_8hpp/#batt_small_fn_assign_move_only_from_copy","text":"1 #define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual)","title":"BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY"},{"location":"_autogen/Files/small__fn_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SMALL_FUNCTION_HPP #define BATTERIES_SMALL_FUNCTION_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/cpu_align.hpp> #include <batteries/hint.hpp> #include <batteries/int_types.hpp> #include <batteries/static_assert.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ), bool kMoveOnly = false > class SmallFn ; template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ) > using UniqueSmallFn = SmallFn < Signature , kMaxSize , /*kMoveOnly=*/ true > ; namespace detail { // Forward declare the abstract base class templates for function type erasure. // template < bool kMoveOnly , typename Result , typename ... Args > class AbstractMoveFn ; template < typename Result , typename ... Args > class AbstractCopyFn ; // Templated alias for the type-erased function interface; kMoveOnly controls // whether copy semantics are enabled. // template < bool kMoveOnly , typename Result , typename ... Args > using AbstractFn = std :: conditional_t < kMoveOnly , AbstractMoveFn < true , Result , Args ... > , AbstractCopyFn < Result , Args ... >> ; // Forward declare the implementation class templates for function type erasure. // template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > class MoveFnImpl ; template < typename Fn , typename Result , typename ... Args > class CopyFnImpl ; template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > using FnImpl = std :: conditional_t < kMoveOnly , MoveFnImpl < Fn , kMoveOnly , Result , Args ... > , CopyFnImpl < Fn , Result , Args ... >> ; // Base class for abstract function types. Defines the common // interface/concept for move-only and copyable functions: // - Invocable (with the signature `auto(Args...)->Result`) // - Move-Constructible/Assignable // - Destructible // template < bool kMoveOnly , typename Result , typename ... Args > class AbstractMoveFn { protected : AbstractMoveFn () = default ; public : AbstractMoveFn ( const AbstractMoveFn & ) = delete ; AbstractMoveFn & operator = ( const AbstractMoveFn & ) = delete ; virtual ~ AbstractMoveFn () = default ; virtual auto invoke ( Args ... args ) noexcept -> Result = 0 ; // Move construct from `this` into `storage`. `size` MUST be big enough to // fit the stored function, otherwise this method will assert-crash. // Invalidates `this`; `invoke` must not be called after `move`. // virtual auto move ( void * storage , usize size ) noexcept -> AbstractFn < kMoveOnly , Result , Args ... >* = 0 ; }; // Adds copy semantics to the basic type-erased concept. // template < typename Result , typename ... Args > class AbstractCopyFn : public AbstractMoveFn < false , Result , Args ... > { public : using AbstractMoveFn < false , Result , Args ... >:: AbstractMoveFn ; // Copy construct from `this` into `storage`. `size` MUST be big enough to // fit the stored function, otherwise this method will assert-crash. // virtual auto copy ( void * memory , usize size ) const noexcept -> AbstractFn < false , Result , Args ... >* = 0 ; // Same as `copy`, but the returned type-erased object drops the ability to // copy in favor of a move-only interface. // virtual auto copy_to_move_only ( void * memory , usize size ) const noexcept -> AbstractFn < true , Result , Args ... >* = 0 ; }; // Implements the basic concept; can be extended because `fn_` is protected, // not private. // template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > class MoveFnImpl : public AbstractFn < kMoveOnly , Result , Args ... > { public : using self_type = MoveFnImpl ; template < typename FnRef > explicit MoveFnImpl ( FnRef && ref ) : fn_ ( BATT_FORWARD ( ref )) { } Result invoke ( Args ... args ) noexcept override { return fn_ ( BATT_FORWARD ( args )...); } AbstractFn < kMoveOnly , Result , Args ... >* move ( void * memory , usize size ) noexcept override { BATT_CHECK_LE ( sizeof ( self_type ), size ); return new ( memory ) FnImpl < Fn , kMoveOnly , Result , Args ... > ( std :: move ( fn_ )); } protected : Fn fn_ ; }; // Extends MoveFnImpl to implement copy semantics in terms of the concrete // type `Fn`. // template < typename Fn , typename Result , typename ... Args > class CopyFnImpl : public MoveFnImpl < Fn , /*kMoveOnly=*/ false , Result , Args ... > { public : using self_type = CopyFnImpl ; using MoveFnImpl < Fn , /*kMoveOnly=*/ false , Result , Args ... >:: MoveFnImpl ; AbstractFn < false , Result , Args ... >* copy ( void * memory , usize size ) const noexcept override { BATT_CHECK_LE ( sizeof ( self_type ), size ); return new ( memory ) FnImpl < Fn , /*kMoveOnly=*/ false , Result , Args ... > ( this -> fn_ ); } AbstractFn < true , Result , Args ... >* copy_to_move_only ( void * memory , usize size ) const noexcept override { BATT_CHECK_LE ( sizeof ( self_type ), size ); return new ( memory ) FnImpl < Fn , /*kMoveOnly=*/ true , Result , Args ... > ( this -> fn_ ); } }; } // namespace detail template < typename ... Args , typename Result , usize kMaxSize , bool kMoveOnly > class SmallFn < auto ( Args ...) -> Result , kMaxSize , kMoveOnly > { template < typename , usize , bool > friend class SmallFn ; // The type-erased interface to use, depending on the value of `kMoveOnly`. // using AbstractFn = detail :: AbstractFn < kMoveOnly , Result , Args ... > ; // The concrete type erasure, depending on the value of `kMoveOnly`. // template < typename Fn > using FnImpl = detail :: FnImpl < Fn , kMoveOnly , Result , Args ... > ; #define BATT_REQUIRE_COPYABLE static_assert(!kMoveOnly, \"This kind of SmallFn is move-only!\") template < typename Fn > static auto check_fn_size ( Fn && fn ) -> Fn && { BATT_STATIC_ASSERT_LE ( sizeof ( FnImpl < std :: decay_t < Fn >> ), kMaxSize ); // \"Passed function is not small!\" return BATT_FORWARD ( fn ); } public : using self_type = SmallFn ; using result_type = Result ; SmallFn () = default ; template < typename Fn , typename = EnableIfNoShadow < SmallFn , Fn > , typename = std :: enable_if_t < IsCallable < Fn , Args ... > {} >> SmallFn ( Fn && fn ) noexcept : impl_ { new ( & storage_ ) FnImpl < std :: decay_t < Fn >> ( check_fn_size ( BATT_FORWARD ( fn )))} { } SmallFn ( self_type && that ) noexcept : impl_ {[ & ] { auto impl = BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> move ( & storage_ , kMaxSize ) : nullptr ; that . clear (); return impl ; }()} { } SmallFn ( const self_type & that ) noexcept : impl_ {[ & ] { BATT_REQUIRE_COPYABLE ; return BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> copy ( & storage_ , kMaxSize ) : nullptr ; }()} { } #define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual) \\ template <usize kThatSize, typename = std::enable_if_t<kThatSize <= kMaxSize && kMoveOnly>> \\ SmallFn(cv_qual SmallFn<Result(Args...), kThatSize, /*kMoveOnly=*/ false>& that) noexcept \\ : impl_{that.impl_->copy_to_move_only(&storage_, kMaxSize)} \\ { \\ } BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY () BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY ( const ) #undef BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY ~ SmallFn () noexcept { clear (); } auto clear () noexcept -> void { if ( BATT_HINT_TRUE ( impl_ != nullptr )) { impl_ ->~ AbstractFn (); impl_ = nullptr ; } } auto operator = ( std :: nullptr_t ) noexcept -> self_type & { this -> clear (); return * this ; } template < typename Fn , typename = EnableIfNoShadow < SmallFn , Fn >> auto operator = ( Fn && fn ) noexcept -> self_type & { clear (); impl_ = new ( & storage_ ) FnImpl < std :: decay_t < Fn >> ( std :: forward < Fn > ( fn )); return * this ; } auto operator = ( self_type && that ) noexcept -> self_type & { if ( BATT_HINT_TRUE ( this != & that )) { clear (); impl_ = BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> move ( & storage_ , kMaxSize ) : nullptr ; that . clear (); } return * this ; } auto operator = ( const self_type & that ) noexcept -> self_type & { BATT_REQUIRE_COPYABLE ; if ( BATT_HINT_TRUE ( this != & that )) { clear (); impl_ = BATT_HINT_TRUE ( that . impl_ != nullptr ) ? that . impl_ -> copy ( & storage_ , kMaxSize ) : nullptr ; } return * this ; } #define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual) \\ template <usize kThatSize, typename = std::enable_if_t<kThatSize <= kMaxSize && kMoveOnly>> \\ auto operator=(cv_qual SmallFn<Result(Args...), kThatSize, false>& that) noexcept->self_type& \\ { \\ clear(); \\ impl_ = that.impl_->copy_to_move_only(&storage_, kMaxSize); \\ \\ return *this; \\ } BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY () BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY ( const ) #undef BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY explicit operator bool () const noexcept { return impl_ != nullptr ; } auto operator ()( Args ... args ) const -> Result { BATT_ASSERT_NOT_NULLPTR ( impl_ ); return impl_ -> invoke ( BATT_FORWARD ( args )...); } private : std :: aligned_storage_t < kMaxSize > storage_ ; // must come before `impl_` AbstractFn * impl_ = nullptr ; #undef BATT_REQUIRE_COPYABLE }; // class SmallFn } // namespace batt #endif // BATTERIES_SMALL_FUNCTION_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/small__vec_8hpp/","text":"batteries/small_vec.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_SMALL_VEC_HPP Macro Documentation \ud83d\udd17 BATTERIES_SMALL_VEC_HPP \ud83d\udd17 1 #define BATTERIES_SMALL_VEC_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SMALL_VEC_HPP #define BATTERIES_SMALL_VEC_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/suppress.hpp> //+++++++++++-+-+--+----- --- -- - - - - BATT_SUPPRESS_IF_GCC ( \"-Wmaybe-uninitialized\" ) // #include <boost/container/detail/advanced_insert_int.hpp> // BATT_UNSUPPRESS_IF_GCC () //+++++++++++-+-+--+----- --- -- - - - - #include <boost/container/small_vector.hpp> #include <string_view> namespace batt { constexpr usize kDefaultSmallVecSize = 4 ; template < typename T , usize kStaticSize = kDefaultSmallVecSize > using SmallVec = boost :: container :: small_vector < T , kStaticSize > ; template < typename T > using SmallVecBase = boost :: container :: small_vector_base < T > ; inline void copy_string ( SmallVecBase < char >& dst , const std :: string_view & src ) { dst . assign ( src . data (), src . data () + src . size ()); } inline std :: string_view as_str ( const SmallVecBase < char >& v ) { return std :: string_view { v . data (), v . size ()}; } } // namespace batt #endif // BATTERIES_SMALL_VEC_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/small_vec.hpp"},{"location":"_autogen/Files/small__vec_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/small__vec_8hpp/#defines","text":"Name BATTERIES_SMALL_VEC_HPP","title":"Defines"},{"location":"_autogen/Files/small__vec_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/small__vec_8hpp/#batteries_small_vec_hpp","text":"1 #define BATTERIES_SMALL_VEC_HPP()","title":"BATTERIES_SMALL_VEC_HPP"},{"location":"_autogen/Files/small__vec_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SMALL_VEC_HPP #define BATTERIES_SMALL_VEC_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/suppress.hpp> //+++++++++++-+-+--+----- --- -- - - - - BATT_SUPPRESS_IF_GCC ( \"-Wmaybe-uninitialized\" ) // #include <boost/container/detail/advanced_insert_int.hpp> // BATT_UNSUPPRESS_IF_GCC () //+++++++++++-+-+--+----- --- -- - - - - #include <boost/container/small_vector.hpp> #include <string_view> namespace batt { constexpr usize kDefaultSmallVecSize = 4 ; template < typename T , usize kStaticSize = kDefaultSmallVecSize > using SmallVec = boost :: container :: small_vector < T , kStaticSize > ; template < typename T > using SmallVecBase = boost :: container :: small_vector_base < T > ; inline void copy_string ( SmallVecBase < char >& dst , const std :: string_view & src ) { dst . assign ( src . data (), src . data () + src . size ()); } inline std :: string_view as_str ( const SmallVecBase < char >& v ) { return std :: string_view { v . data (), v . size ()}; } } // namespace batt #endif // BATTERIES_SMALL_VEC_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/state__machine__model_8hpp/","text":"batteries/state_machine_model.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::StateMachineModel Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_HPP #define BATTERIES_STATE_MACHINE_MODEL_HPP #include <batteries/config.hpp> // #include <batteries/state_machine_model/entropy_source.hpp> #include <batteries/state_machine_model/exhaustive_model_checker.hpp> #include <batteries/state_machine_model/parallel_model_check_state.hpp> #include <batteries/state_machine_model/state_machine_result.hpp> #include <batteries/state_machine_model/state_machine_traits.hpp> #include <batteries/state_machine_model/stochastic_model_checker.hpp> #include <batteries/state_machine_model/verbose.hpp> #include <batteries/async/debug_info.hpp> #include <batteries/async/mutex.hpp> #include <batteries/async/queue.hpp> #include <batteries/assert.hpp> #include <batteries/cpu_align.hpp> #include <batteries/hash.hpp> #include <batteries/int_types.hpp> #include <batteries/radix_queue.hpp> #include <batteries/static_dispatch.hpp> #include <batteries/strong_typedef.hpp> #include <array> #include <atomic> #include <bitset> #include <chrono> #include <deque> #include <unordered_map> #include <unordered_set> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename StateT , typename StateHash = std :: hash < StateT > , typename StateEqual = std :: equal_to < StateT >> class StateMachineModel { public : using state_type = StateT ; using state_hash_type = StateHash ; using state_equal_type = StateEqual ; using Base = StateMachineModel ; using Branch = StateMachineBranch < StateT , StateHash , StateEqual > ; using Result = StateMachineResult ; using AdvancedOptions = StateMachineModelCheckAdvancedOptions ; enum struct VisitResult { kFirstTime , kSeenBefore , }; //+++++++++++-+-+--+----- --- -- - - - - StateMachineModel ( const StateMachineModel & ) = delete ; StateMachineModel & operator = ( const StateMachineModel & ) = delete ; virtual ~ StateMachineModel () = default ; StateMachineModel () = default ; //+++++++++++-+-+--+----- --- -- - - - - template < typename Checker = ExhaustiveModelChecker < StateMachineModel >> Result check_model ( StaticType < Checker > = {}); bool state_visited ( const state_type & s ) const { return this -> visited_ . count ( s ) != 0 ; } std :: shared_ptr < std :: ostringstream > debug_out = std :: make_shared < std :: ostringstream > (); // Attach the passed entropy source to the model. This is used to return values from `pick_int`, etc. // during the model's `step()` function. // void set_entropy ( StateMachineEntropySource && entropy_source ) { this -> entropy_ = std :: move ( entropy_source ); } // Clears the set of states visited by the model. // void reset_visited_states () { this -> visited_ . clear (); } // Returns whether this is the first time visiting the passed state. // VisitResult visit ( const StateT & state , const Branch & src_branch ) { // We save a subgraph of the overall search so we can give somewhat meaningful information to help // users understand how a state machine got into a certain state, if things go wrong. // const auto & [ iter , inserted ] = this -> visited_ . emplace ( state , src_branch ); ( void ) iter ; if ( inserted ) { return VisitResult :: kFirstTime ; } return VisitResult :: kSeenBefore ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Derived classes must implemented these methods to define the state machine simulation. //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Returns the initial state value for the search. // virtual state_type initialize () = 0 ; // Invoked whenever a state is entered, prior to checking invariants and generating branches. // virtual void enter_state ( const state_type & ) = 0 ; // Should non-deterministically update the state machine using one or more calls to `pick_int` and/or // `do_one_of`. This defines the state transition space. Eventually all values of non-deterministic // variables will be searched. // virtual void step () = 0 ; // Invoked after step() to retrieve the serialized snapshot of the new state. // virtual state_type leave_state () = 0 ; // Verifies the invariants of the state machine that should hold after initialization and between each // step. Returns false if the check failed. // virtual bool check_invariants () = 0 ; // (Optional) Verifies any invariants that should hold across subsequent states. Returns false if the // check failed. // virtual bool check_stepwise_invariants () { return true ; } // (Optional) Maps symmetrical states onto a single normalized form; in many cases this can dramatically // reduce the overall state search space. // virtual state_type normalize ( const state_type & s ) { return s ; } // (Optional) How often to report progress during a model check. // virtual double progress_report_interval_seconds () const { return 5.0 ; } // (Optional) Report progress during a model check. // virtual void report_progress ( const Result & ) { } // (Optional) Should return > 1 if this model supports parallel execution via object cloning. // virtual usize max_concurrency () const { return 1 ; } // If the derived model implementation class returns `max_concurrency() > 1`, this method must return // non-nullptr. // virtual std :: unique_ptr < StateMachineModel > clone () const { return nullptr ; } // (Optional) Advanced tuning of model check algorithm. // virtual AdvancedOptions advanced_options () const { return AdvancedOptions :: with_default_values (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Returns an integer `i` non-deterministically, such that `i >= min_value && i <= max_value`. // usize pick_int ( usize min_value , usize max_value ) { return this -> entropy_ . pick_int ( min_value , max_value ); } // Returns false or true. // bool pick_branch () { return this -> entropy_ . pick_branch (); } // Returns one of the items in `values`, using `pick_int`. // template < typename T > T pick_one_of ( std :: initializer_list < T > values ) { return this -> entropy_ . pick_one_of ( values ); } // If there is at least one runnable completion handler in `context`, one such handler is selected (via // `pick_int`) and invoked, and this function returns true. Else false is returned. // bool run_one ( FakeExecutionContext & context ) { return this -> entropy_ . run_one ( context ); } // Performs one of the passed action functions. Each `Fn` in `actions...` must be callable with no // arguments and its return type must be ignorable. // template < typename ... Fn > void do_one_of ( Fn && ... actions ) { this -> entropy_ . do_one_of ( BATT_FORWARD ( actions )...); } // Returns a generic entropy source that can be passed around by state machine implementations to // implement modular simulations. No copy of the returned object may outlive `this`, or behavior is // undefined! // StateMachineEntropySource entropy () { return this -> entropy_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - private : using VisitedBranchMap = std :: unordered_map < state_type , Branch , StateHash , StateEqual > ; VisitedBranchMap visited_ ; StateMachineEntropySource entropy_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename StateT , typename StateHash , typename StateEqual > template < typename Checker > auto StateMachineModel < StateT , StateHash , StateEqual >:: check_model ( StaticType < Checker > ) -> Result { const usize n_shards = this -> max_concurrency (); BATT_CHECK_GT ( n_shards , 0u ); const auto print_summary = finally ([ & ] { BATT_STATE_MACHINE_VERBOSE () << \"Model check done; \" << BATT_INSPECT ( this -> visited_ . size ()); }); detail :: ParallelModelCheckState < Branch > mesh { /*shard_count=*/ n_shards }; if ( n_shards == 1 ) { Checker checker { * this , mesh , 0 }; return checker . run (); } // Set up a thread pool and process a shard per thread. // std :: vector < std :: unique_ptr < Latch < Result >>> shard_results ( n_shards ); std :: vector < VisitedBranchMap > shard_visited ( n_shards ); std :: vector < std :: unique_ptr < StateMachineModel >> shard_models ( n_shards ); std :: vector < std :: thread > threads ; const usize cpu_count = std :: thread :: hardware_concurrency (); // IMPORTANT: all of the latches must be created before we launch any of the threads. // for ( usize shard_i = 0 ; shard_i < n_shards ; ++ shard_i ) { shard_results [ shard_i ] = std :: make_unique < Latch < Result >> (); // Each thread gets its own copy of the model object. // shard_models [ shard_i ] = this -> clone (); BATT_CHECK_NOT_NULLPTR ( shard_models [ shard_i ]) << \"clone() MUST return non-nullptr if max_concurrency() is > 1\" ; } const bool pin_cpu = this -> advanced_options (). pin_shard_to_cpu ; // Launch threads, one per shard. Each thread will explore the model state space that hashes to its // portion of the hash space (i.e., its \"shard\") and then do O(log_2(N)) combine operations to collect the // results of other shards. These two stages are like Map and Reduce. // for ( usize shard_i = 0 ; shard_i < n_shards ; ++ shard_i ) { threads . emplace_back ([ shard_i , & shard_results , & shard_models , & shard_visited , & mesh , cpu_count , pin_cpu ] { boost :: asio :: io_context io ; batt :: Task shard_task { io . get_executor (), [ & ] { // Pin each thread to a different CPU to try to speed things up. // if ( pin_cpu ) { const usize cpu_i = shard_i % cpu_count ; BATT_CHECK_OK ( pin_thread_to_cpu ( cpu_i )); } // First step is to compute the shard-local result. // Checker checker { * shard_models [ shard_i ], mesh , shard_i }; Result tmp_result = checker . run (); tmp_result . shards . set ( shard_i , true ); shard_visited [ shard_i ] = std :: move ( shard_models [ shard_i ] -> visited_ ); // Combine sub-results until the merge mask collides with the least-significant 1 bit of // the shard index. // // Example: // // shard_i | merge_i values // ---------|--------------------------------- // 0b0000 | {0b0001, 0b0010, 0b0100, 0b1000} // 0b0001 | {} // 0b0010 | {0b0011} // 0b0011 | {} // 0b0100 | {0b0101, 0b0110} // 0b0101 | {} // 0b0110 | {0b0111} // 0b0111 | {} // 0b1000 | {0b1001, 0b1010, 0b1100} // 0b1001 | {} // 0b1010 | {0b1011} // 0b1011 | {} // 0b1100 | {0b1101, 0b1110} // 0b1101 | {} // 0b1110 | {0b1111} // 0b1111 | {} // for ( usize merge_mask = 1 ; ( merge_mask & shard_i ) == 0 ; merge_mask <<= 1 ) { const usize merge_i = ( shard_i | merge_mask ); if ( merge_i >= mesh . shard_count ) { // `merge_i` is only going to get bigger, so stop as soon as this happens. break ; } BATT_CHECK_LT ( shard_i , merge_i ); BATT_CHECK_LT ( merge_i , shard_results . size ()); const Result merge_result = BATT_OK_RESULT_OR_PANIC ( shard_results [ merge_i ] -> await ()); tmp_result = combine_results ( tmp_result , merge_result ); shard_visited [ shard_i ]. insert ( shard_visited [ merge_i ]. begin (), shard_visited [ merge_i ]. end ()); } BATT_CHECK ( shard_results [ shard_i ] -> set_value ( std :: move ( tmp_result ))); io . stop (); }}; io . run (); }); } for ( std :: thread & t : threads ) { t . join (); } { usize shard_i = 0 ; for ( auto & r : shard_results ) { * this -> debug_out << shard_i << \": \" << BATT_OK_RESULT_OR_PANIC ( r -> poll ()) << std :: endl ; ++ shard_i ; } } this -> visited_ = std :: move ( shard_visited [ 0 ]); Result result = BATT_OK_RESULT_OR_PANIC ( shard_results [ 0 ] -> poll ()); result . state_count = this -> visited_ . size (); return result ; } //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- /* TEMPLATE FOR NEW STATE MACHINE MODEL IMPLS: #include <batteries/state_machine_model.hpp> #include <boost/functional/hash.hpp> #include <boost/operators.hpp> struct $ImplState : boost::equality_comparable<$ImplState> { struct Hash { usize operator()(const $ImplState& s) const { return batt::hash(); } }; friend bool operator==(const $ImplState& l, const $ImplState& r) { return false; } bool is_terminal() const { return true; } }; class $ImplModel : public batt::StateMachineModel<$ImplState, $ImplState::Hash> { public: $ImplState initialize() override { return $ImplState{}; } void enter_state(const $ImplState& s) override { this->state_ = s; } void step() override { if (this->state_.is_terminal()) { return; } this->pick_int(min, max); this->do_one_of([]{ action1(); }, []{ action2(); }); } $ImplState leave_state() override { return this->state_; } bool check_invariants() override { return true; } $ImplState normalize(const $ImplState& s) override { return s; } private: $ImplState state_; }; TEST($ImplTest, StateMachineSimulation) { $ImplModel model; $ImplModel::Result result = model.check_model(); EXPECT_TRUE(result.ok()); } */ //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model.hpp"},{"location":"_autogen/Files/state__machine__model_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/state__machine__model_8hpp/#classes","text":"Name class batt::StateMachineModel","title":"Classes"},{"location":"_autogen/Files/state__machine__model_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_HPP","title":"Defines"},{"location":"_autogen/Files/state__machine__model_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/state__machine__model_8hpp/#batteries_state_machine_model_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_HPP"},{"location":"_autogen/Files/state__machine__model_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_HPP #define BATTERIES_STATE_MACHINE_MODEL_HPP #include <batteries/config.hpp> // #include <batteries/state_machine_model/entropy_source.hpp> #include <batteries/state_machine_model/exhaustive_model_checker.hpp> #include <batteries/state_machine_model/parallel_model_check_state.hpp> #include <batteries/state_machine_model/state_machine_result.hpp> #include <batteries/state_machine_model/state_machine_traits.hpp> #include <batteries/state_machine_model/stochastic_model_checker.hpp> #include <batteries/state_machine_model/verbose.hpp> #include <batteries/async/debug_info.hpp> #include <batteries/async/mutex.hpp> #include <batteries/async/queue.hpp> #include <batteries/assert.hpp> #include <batteries/cpu_align.hpp> #include <batteries/hash.hpp> #include <batteries/int_types.hpp> #include <batteries/radix_queue.hpp> #include <batteries/static_dispatch.hpp> #include <batteries/strong_typedef.hpp> #include <array> #include <atomic> #include <bitset> #include <chrono> #include <deque> #include <unordered_map> #include <unordered_set> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename StateT , typename StateHash = std :: hash < StateT > , typename StateEqual = std :: equal_to < StateT >> class StateMachineModel { public : using state_type = StateT ; using state_hash_type = StateHash ; using state_equal_type = StateEqual ; using Base = StateMachineModel ; using Branch = StateMachineBranch < StateT , StateHash , StateEqual > ; using Result = StateMachineResult ; using AdvancedOptions = StateMachineModelCheckAdvancedOptions ; enum struct VisitResult { kFirstTime , kSeenBefore , }; //+++++++++++-+-+--+----- --- -- - - - - StateMachineModel ( const StateMachineModel & ) = delete ; StateMachineModel & operator = ( const StateMachineModel & ) = delete ; virtual ~ StateMachineModel () = default ; StateMachineModel () = default ; //+++++++++++-+-+--+----- --- -- - - - - template < typename Checker = ExhaustiveModelChecker < StateMachineModel >> Result check_model ( StaticType < Checker > = {}); bool state_visited ( const state_type & s ) const { return this -> visited_ . count ( s ) != 0 ; } std :: shared_ptr < std :: ostringstream > debug_out = std :: make_shared < std :: ostringstream > (); // Attach the passed entropy source to the model. This is used to return values from `pick_int`, etc. // during the model's `step()` function. // void set_entropy ( StateMachineEntropySource && entropy_source ) { this -> entropy_ = std :: move ( entropy_source ); } // Clears the set of states visited by the model. // void reset_visited_states () { this -> visited_ . clear (); } // Returns whether this is the first time visiting the passed state. // VisitResult visit ( const StateT & state , const Branch & src_branch ) { // We save a subgraph of the overall search so we can give somewhat meaningful information to help // users understand how a state machine got into a certain state, if things go wrong. // const auto & [ iter , inserted ] = this -> visited_ . emplace ( state , src_branch ); ( void ) iter ; if ( inserted ) { return VisitResult :: kFirstTime ; } return VisitResult :: kSeenBefore ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Derived classes must implemented these methods to define the state machine simulation. //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Returns the initial state value for the search. // virtual state_type initialize () = 0 ; // Invoked whenever a state is entered, prior to checking invariants and generating branches. // virtual void enter_state ( const state_type & ) = 0 ; // Should non-deterministically update the state machine using one or more calls to `pick_int` and/or // `do_one_of`. This defines the state transition space. Eventually all values of non-deterministic // variables will be searched. // virtual void step () = 0 ; // Invoked after step() to retrieve the serialized snapshot of the new state. // virtual state_type leave_state () = 0 ; // Verifies the invariants of the state machine that should hold after initialization and between each // step. Returns false if the check failed. // virtual bool check_invariants () = 0 ; // (Optional) Verifies any invariants that should hold across subsequent states. Returns false if the // check failed. // virtual bool check_stepwise_invariants () { return true ; } // (Optional) Maps symmetrical states onto a single normalized form; in many cases this can dramatically // reduce the overall state search space. // virtual state_type normalize ( const state_type & s ) { return s ; } // (Optional) How often to report progress during a model check. // virtual double progress_report_interval_seconds () const { return 5.0 ; } // (Optional) Report progress during a model check. // virtual void report_progress ( const Result & ) { } // (Optional) Should return > 1 if this model supports parallel execution via object cloning. // virtual usize max_concurrency () const { return 1 ; } // If the derived model implementation class returns `max_concurrency() > 1`, this method must return // non-nullptr. // virtual std :: unique_ptr < StateMachineModel > clone () const { return nullptr ; } // (Optional) Advanced tuning of model check algorithm. // virtual AdvancedOptions advanced_options () const { return AdvancedOptions :: with_default_values (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Returns an integer `i` non-deterministically, such that `i >= min_value && i <= max_value`. // usize pick_int ( usize min_value , usize max_value ) { return this -> entropy_ . pick_int ( min_value , max_value ); } // Returns false or true. // bool pick_branch () { return this -> entropy_ . pick_branch (); } // Returns one of the items in `values`, using `pick_int`. // template < typename T > T pick_one_of ( std :: initializer_list < T > values ) { return this -> entropy_ . pick_one_of ( values ); } // If there is at least one runnable completion handler in `context`, one such handler is selected (via // `pick_int`) and invoked, and this function returns true. Else false is returned. // bool run_one ( FakeExecutionContext & context ) { return this -> entropy_ . run_one ( context ); } // Performs one of the passed action functions. Each `Fn` in `actions...` must be callable with no // arguments and its return type must be ignorable. // template < typename ... Fn > void do_one_of ( Fn && ... actions ) { this -> entropy_ . do_one_of ( BATT_FORWARD ( actions )...); } // Returns a generic entropy source that can be passed around by state machine implementations to // implement modular simulations. No copy of the returned object may outlive `this`, or behavior is // undefined! // StateMachineEntropySource entropy () { return this -> entropy_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - private : using VisitedBranchMap = std :: unordered_map < state_type , Branch , StateHash , StateEqual > ; VisitedBranchMap visited_ ; StateMachineEntropySource entropy_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename StateT , typename StateHash , typename StateEqual > template < typename Checker > auto StateMachineModel < StateT , StateHash , StateEqual >:: check_model ( StaticType < Checker > ) -> Result { const usize n_shards = this -> max_concurrency (); BATT_CHECK_GT ( n_shards , 0u ); const auto print_summary = finally ([ & ] { BATT_STATE_MACHINE_VERBOSE () << \"Model check done; \" << BATT_INSPECT ( this -> visited_ . size ()); }); detail :: ParallelModelCheckState < Branch > mesh { /*shard_count=*/ n_shards }; if ( n_shards == 1 ) { Checker checker { * this , mesh , 0 }; return checker . run (); } // Set up a thread pool and process a shard per thread. // std :: vector < std :: unique_ptr < Latch < Result >>> shard_results ( n_shards ); std :: vector < VisitedBranchMap > shard_visited ( n_shards ); std :: vector < std :: unique_ptr < StateMachineModel >> shard_models ( n_shards ); std :: vector < std :: thread > threads ; const usize cpu_count = std :: thread :: hardware_concurrency (); // IMPORTANT: all of the latches must be created before we launch any of the threads. // for ( usize shard_i = 0 ; shard_i < n_shards ; ++ shard_i ) { shard_results [ shard_i ] = std :: make_unique < Latch < Result >> (); // Each thread gets its own copy of the model object. // shard_models [ shard_i ] = this -> clone (); BATT_CHECK_NOT_NULLPTR ( shard_models [ shard_i ]) << \"clone() MUST return non-nullptr if max_concurrency() is > 1\" ; } const bool pin_cpu = this -> advanced_options (). pin_shard_to_cpu ; // Launch threads, one per shard. Each thread will explore the model state space that hashes to its // portion of the hash space (i.e., its \"shard\") and then do O(log_2(N)) combine operations to collect the // results of other shards. These two stages are like Map and Reduce. // for ( usize shard_i = 0 ; shard_i < n_shards ; ++ shard_i ) { threads . emplace_back ([ shard_i , & shard_results , & shard_models , & shard_visited , & mesh , cpu_count , pin_cpu ] { boost :: asio :: io_context io ; batt :: Task shard_task { io . get_executor (), [ & ] { // Pin each thread to a different CPU to try to speed things up. // if ( pin_cpu ) { const usize cpu_i = shard_i % cpu_count ; BATT_CHECK_OK ( pin_thread_to_cpu ( cpu_i )); } // First step is to compute the shard-local result. // Checker checker { * shard_models [ shard_i ], mesh , shard_i }; Result tmp_result = checker . run (); tmp_result . shards . set ( shard_i , true ); shard_visited [ shard_i ] = std :: move ( shard_models [ shard_i ] -> visited_ ); // Combine sub-results until the merge mask collides with the least-significant 1 bit of // the shard index. // // Example: // // shard_i | merge_i values // ---------|--------------------------------- // 0b0000 | {0b0001, 0b0010, 0b0100, 0b1000} // 0b0001 | {} // 0b0010 | {0b0011} // 0b0011 | {} // 0b0100 | {0b0101, 0b0110} // 0b0101 | {} // 0b0110 | {0b0111} // 0b0111 | {} // 0b1000 | {0b1001, 0b1010, 0b1100} // 0b1001 | {} // 0b1010 | {0b1011} // 0b1011 | {} // 0b1100 | {0b1101, 0b1110} // 0b1101 | {} // 0b1110 | {0b1111} // 0b1111 | {} // for ( usize merge_mask = 1 ; ( merge_mask & shard_i ) == 0 ; merge_mask <<= 1 ) { const usize merge_i = ( shard_i | merge_mask ); if ( merge_i >= mesh . shard_count ) { // `merge_i` is only going to get bigger, so stop as soon as this happens. break ; } BATT_CHECK_LT ( shard_i , merge_i ); BATT_CHECK_LT ( merge_i , shard_results . size ()); const Result merge_result = BATT_OK_RESULT_OR_PANIC ( shard_results [ merge_i ] -> await ()); tmp_result = combine_results ( tmp_result , merge_result ); shard_visited [ shard_i ]. insert ( shard_visited [ merge_i ]. begin (), shard_visited [ merge_i ]. end ()); } BATT_CHECK ( shard_results [ shard_i ] -> set_value ( std :: move ( tmp_result ))); io . stop (); }}; io . run (); }); } for ( std :: thread & t : threads ) { t . join (); } { usize shard_i = 0 ; for ( auto & r : shard_results ) { * this -> debug_out << shard_i << \": \" << BATT_OK_RESULT_OR_PANIC ( r -> poll ()) << std :: endl ; ++ shard_i ; } } this -> visited_ = std :: move ( shard_visited [ 0 ]); Result result = BATT_OK_RESULT_OR_PANIC ( shard_results [ 0 ] -> poll ()); result . state_count = this -> visited_ . size (); return result ; } //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- /* TEMPLATE FOR NEW STATE MACHINE MODEL IMPLS: #include <batteries/state_machine_model.hpp> #include <boost/functional/hash.hpp> #include <boost/operators.hpp> struct $ImplState : boost::equality_comparable<$ImplState> { struct Hash { usize operator()(const $ImplState& s) const { return batt::hash(); } }; friend bool operator==(const $ImplState& l, const $ImplState& r) { return false; } bool is_terminal() const { return true; } }; class $ImplModel : public batt::StateMachineModel<$ImplState, $ImplState::Hash> { public: $ImplState initialize() override { return $ImplState{}; } void enter_state(const $ImplState& s) override { this->state_ = s; } void step() override { if (this->state_.is_terminal()) { return; } this->pick_int(min, max); this->do_one_of([]{ action1(); }, []{ action2(); }); } $ImplState leave_state() override { return this->state_; } bool check_invariants() override { return true; } $ImplState normalize(const $ImplState& s) override { return s; } private: $ImplState state_; }; TEST($ImplTest, StateMachineSimulation) { $ImplModel model; $ImplModel::Result result = model.check_model(); EXPECT_TRUE(result.ok()); } */ //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/state__machine__result_8hpp/","text":"batteries/state_machine_model/state_machine_result.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::StateMachineResult Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <bitset> #include <chrono> #include <ostream> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // struct StateMachineResult { bool ok = false ; usize branch_push_count = 0 ; usize branch_pop_count = 0 ; usize branch_miss_count = 0 ; usize state_count = 0 ; usize self_branch_count = 0 ; std :: chrono :: steady_clock :: time_point start_time ; usize elapsed_ms = 0 ; double states_per_second = 0.0 ; double branch_pop_per_second = 0.0 ; double branch_push_per_second = 0.0 ; std :: bitset < 64 > shards { 0 }; Optional < usize > seed ; void update_elapsed_time () { this -> elapsed_ms = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( std :: chrono :: steady_clock :: now () - this -> start_time ) . count (); this -> update_rates (); } double compute_rate ( usize count ) const { return double ( count * 1000 + 1 ) / double ( this -> elapsed_ms + 1 ); } void update_rates () { this -> states_per_second = this -> compute_rate ( this -> state_count ); this -> branch_pop_per_second = this -> compute_rate ( this -> branch_pop_count ); this -> branch_push_per_second = this -> compute_rate ( this -> branch_push_count ); } }; inline StateMachineResult combine_results ( const StateMachineResult & a , const StateMachineResult & b ) { StateMachineResult c ; c . ok = a . ok && b . ok ; c . branch_push_count = a . branch_push_count + b . branch_push_count ; c . branch_pop_count = a . branch_pop_count + b . branch_pop_count ; c . branch_miss_count = a . branch_miss_count + b . branch_miss_count ; c . state_count = a . state_count + b . state_count ; c . self_branch_count = a . self_branch_count + b . self_branch_count ; c . elapsed_ms = std :: max ( a . elapsed_ms , b . elapsed_ms ); c . start_time = std :: chrono :: steady_clock :: now () - std :: chrono :: milliseconds ( c . elapsed_ms ); c . shards = a . shards | b . shards ; c . update_rates (); if ( a . seed ) { c . seed = a . seed ; } else { c . seed = b . seed ; } return c ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: ostream & operator << ( std :: ostream & out , const StateMachineResult & r ) { return out << \"StateMachineResult{\" // << \".ok=\" << r . ok // << \", .branch_push_count=\" << r . branch_push_count // << \", .branch_pop_count=\" << r . branch_pop_count // << \", .branch_miss_count=\" << r . branch_miss_count // << \", .state_count=\" << r . state_count // << \", .self_branch_count=\" << r . self_branch_count // << \", .states_per_second=\" << r . states_per_second // << \", .branch_push_per_second=\" << r . branch_push_per_second // << \", .branch_pop_per_second=\" << r . branch_pop_per_second // << \", .elapsed_ms=\" << r . elapsed_ms // << \", .shards=\" << r . shards // << \", .seed=\" << r . seed // << \",}\" ; } } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/state_machine_result.hpp"},{"location":"_autogen/Files/state__machine__result_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/state__machine__result_8hpp/#classes","text":"Name struct batt::StateMachineResult","title":"Classes"},{"location":"_autogen/Files/state__machine__result_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP","title":"Defines"},{"location":"_autogen/Files/state__machine__result_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/state__machine__result_8hpp/#batteries_state_machine_model_state_machine_result_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP"},{"location":"_autogen/Files/state__machine__result_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <bitset> #include <chrono> #include <ostream> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // struct StateMachineResult { bool ok = false ; usize branch_push_count = 0 ; usize branch_pop_count = 0 ; usize branch_miss_count = 0 ; usize state_count = 0 ; usize self_branch_count = 0 ; std :: chrono :: steady_clock :: time_point start_time ; usize elapsed_ms = 0 ; double states_per_second = 0.0 ; double branch_pop_per_second = 0.0 ; double branch_push_per_second = 0.0 ; std :: bitset < 64 > shards { 0 }; Optional < usize > seed ; void update_elapsed_time () { this -> elapsed_ms = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( std :: chrono :: steady_clock :: now () - this -> start_time ) . count (); this -> update_rates (); } double compute_rate ( usize count ) const { return double ( count * 1000 + 1 ) / double ( this -> elapsed_ms + 1 ); } void update_rates () { this -> states_per_second = this -> compute_rate ( this -> state_count ); this -> branch_pop_per_second = this -> compute_rate ( this -> branch_pop_count ); this -> branch_push_per_second = this -> compute_rate ( this -> branch_push_count ); } }; inline StateMachineResult combine_results ( const StateMachineResult & a , const StateMachineResult & b ) { StateMachineResult c ; c . ok = a . ok && b . ok ; c . branch_push_count = a . branch_push_count + b . branch_push_count ; c . branch_pop_count = a . branch_pop_count + b . branch_pop_count ; c . branch_miss_count = a . branch_miss_count + b . branch_miss_count ; c . state_count = a . state_count + b . state_count ; c . self_branch_count = a . self_branch_count + b . self_branch_count ; c . elapsed_ms = std :: max ( a . elapsed_ms , b . elapsed_ms ); c . start_time = std :: chrono :: steady_clock :: now () - std :: chrono :: milliseconds ( c . elapsed_ms ); c . shards = a . shards | b . shards ; c . update_rates (); if ( a . seed ) { c . seed = a . seed ; } else { c . seed = b . seed ; } return c ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: ostream & operator << ( std :: ostream & out , const StateMachineResult & r ) { return out << \"StateMachineResult{\" // << \".ok=\" << r . ok // << \", .branch_push_count=\" << r . branch_push_count // << \", .branch_pop_count=\" << r . branch_pop_count // << \", .branch_miss_count=\" << r . branch_miss_count // << \", .state_count=\" << r . state_count // << \", .self_branch_count=\" << r . self_branch_count // << \", .states_per_second=\" << r . states_per_second // << \", .branch_push_per_second=\" << r . branch_push_per_second // << \", .branch_pop_per_second=\" << r . branch_pop_per_second // << \", .elapsed_ms=\" << r . elapsed_ms // << \", .shards=\" << r . shards // << \", .seed=\" << r . seed // << \",}\" ; } } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/state__machine__traits_8hpp/","text":"batteries/state_machine_model/state_machine_traits.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::StateMachineTraits Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> namespace batt { template < typename StateT > struct StateMachineTraits { static constexpr usize kRadixQueueSize = 256 ; }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/state_machine_traits.hpp"},{"location":"_autogen/Files/state__machine__traits_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/state__machine__traits_8hpp/#classes","text":"Name struct batt::StateMachineTraits","title":"Classes"},{"location":"_autogen/Files/state__machine__traits_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP","title":"Defines"},{"location":"_autogen/Files/state__machine__traits_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/state__machine__traits_8hpp/#batteries_state_machine_model_state_machine_traits_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP"},{"location":"_autogen/Files/state__machine__traits_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP #define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> namespace batt { template < typename StateT > struct StateMachineTraits { static constexpr usize kRadixQueueSize = 256 ; }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/static__assert_8hpp/","text":"batteries/static_assert.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::StaticBinaryAssertion struct batt::StaticSameTypeAssertion Defines \ud83d\udd17 Name BATTERIES_STATIC_ASSERT_HPP BATT_STATIC_ASSERT_EQ (x, y) BATT_STATIC_ASSERT_NE (x, y) BATT_STATIC_ASSERT_LT (x, y) BATT_STATIC_ASSERT_LE (x, y) BATT_STATIC_ASSERT_GT (x, y) BATT_STATIC_ASSERT_GE (x, y) BATT_STATIC_ASSERT_TYPE_EQ (x, y) Macro Documentation \ud83d\udd17 BATTERIES_STATIC_ASSERT_HPP \ud83d\udd17 1 #define BATTERIES_STATIC_ASSERT_HPP() BATT_STATIC_ASSERT_EQ \ud83d\udd17 1 #define BATT_STATIC_ASSERT_EQ(x, y) BATT_STATIC_ASSERT_NE \ud83d\udd17 1 #define BATT_STATIC_ASSERT_NE(x, y) BATT_STATIC_ASSERT_LT \ud83d\udd17 1 #define BATT_STATIC_ASSERT_LT(x, y) BATT_STATIC_ASSERT_LE \ud83d\udd17 1 #define BATT_STATIC_ASSERT_LE(x, y) BATT_STATIC_ASSERT_GT \ud83d\udd17 1 #define BATT_STATIC_ASSERT_GT(x, y) BATT_STATIC_ASSERT_GE \ud83d\udd17 1 #define BATT_STATIC_ASSERT_GE(x, y) BATT_STATIC_ASSERT_TYPE_EQ \ud83d\udd17 1 #define BATT_STATIC_ASSERT_TYPE_EQ(x, y) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATIC_ASSERT_HPP #define BATTERIES_STATIC_ASSERT_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> #include <boost/preprocessor/cat.hpp> #include <type_traits> namespace batt { struct Eq ; struct Ne ; struct Lt ; struct Le ; struct Ge ; struct Gt ; template < typename T , typename U , T left , typename Op , U right , bool kCondition > struct StaticBinaryAssertion : std :: integral_constant < bool , kCondition > { static_assert ( kCondition == true , \"\" ); }; #define BATT_STATIC_ASSERT_EQ(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Eq, \\ (y), ((x) == (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_NE(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Ne, \\ (y), ((x) != (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_LT(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Lt, \\ (y), ((x) < (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_LE(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Le, \\ (y), ((x) <= (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_GT(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Gt, \\ (y), ((x) > (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_GE(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Ge, \\ (y), ((x) >= (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > struct StaticSameTypeAssertion { static_assert ( std :: is_same_v < T , U > , \"\" ); }; #define BATT_STATIC_ASSERT_TYPE_EQ(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticSameTypeAssertion<x, y> BOOST_PP_CAT( \\ BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) } // namespace batt #endif // BATTERIES_STATIC_ASSERT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/static_assert.hpp"},{"location":"_autogen/Files/static__assert_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/static__assert_8hpp/#classes","text":"Name struct batt::StaticBinaryAssertion struct batt::StaticSameTypeAssertion","title":"Classes"},{"location":"_autogen/Files/static__assert_8hpp/#defines","text":"Name BATTERIES_STATIC_ASSERT_HPP BATT_STATIC_ASSERT_EQ (x, y) BATT_STATIC_ASSERT_NE (x, y) BATT_STATIC_ASSERT_LT (x, y) BATT_STATIC_ASSERT_LE (x, y) BATT_STATIC_ASSERT_GT (x, y) BATT_STATIC_ASSERT_GE (x, y) BATT_STATIC_ASSERT_TYPE_EQ (x, y)","title":"Defines"},{"location":"_autogen/Files/static__assert_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/static__assert_8hpp/#batteries_static_assert_hpp","text":"1 #define BATTERIES_STATIC_ASSERT_HPP()","title":"BATTERIES_STATIC_ASSERT_HPP"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_eq","text":"1 #define BATT_STATIC_ASSERT_EQ(x, y)","title":"BATT_STATIC_ASSERT_EQ"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_ne","text":"1 #define BATT_STATIC_ASSERT_NE(x, y)","title":"BATT_STATIC_ASSERT_NE"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_lt","text":"1 #define BATT_STATIC_ASSERT_LT(x, y)","title":"BATT_STATIC_ASSERT_LT"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_le","text":"1 #define BATT_STATIC_ASSERT_LE(x, y)","title":"BATT_STATIC_ASSERT_LE"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_gt","text":"1 #define BATT_STATIC_ASSERT_GT(x, y)","title":"BATT_STATIC_ASSERT_GT"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_ge","text":"1 #define BATT_STATIC_ASSERT_GE(x, y)","title":"BATT_STATIC_ASSERT_GE"},{"location":"_autogen/Files/static__assert_8hpp/#batt_static_assert_type_eq","text":"1 #define BATT_STATIC_ASSERT_TYPE_EQ(x, y)","title":"BATT_STATIC_ASSERT_TYPE_EQ"},{"location":"_autogen/Files/static__assert_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATIC_ASSERT_HPP #define BATTERIES_STATIC_ASSERT_HPP #include <batteries/config.hpp> // #include <batteries/utility.hpp> #include <boost/preprocessor/cat.hpp> #include <type_traits> namespace batt { struct Eq ; struct Ne ; struct Lt ; struct Le ; struct Ge ; struct Gt ; template < typename T , typename U , T left , typename Op , U right , bool kCondition > struct StaticBinaryAssertion : std :: integral_constant < bool , kCondition > { static_assert ( kCondition == true , \"\" ); }; #define BATT_STATIC_ASSERT_EQ(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Eq, \\ (y), ((x) == (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_NE(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Ne, \\ (y), ((x) != (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_LT(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Lt, \\ (y), ((x) < (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_LE(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Le, \\ (y), ((x) <= (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_GT(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Gt, \\ (y), ((x) > (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) #define BATT_STATIC_ASSERT_GE(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion<decltype(x), decltype(y), (x), struct ::batt::Ge, \\ (y), ((x) >= (y))> \\ BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename U > struct StaticSameTypeAssertion { static_assert ( std :: is_same_v < T , U > , \"\" ); }; #define BATT_STATIC_ASSERT_TYPE_EQ(x, y) \\ static BATT_MAYBE_UNUSED ::batt::StaticSameTypeAssertion<x, y> BOOST_PP_CAT( \\ BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__) } // namespace batt #endif // BATTERIES_STATIC_ASSERT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/static__dispatch_8hpp/","text":"batteries/static_dispatch.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Defines \ud83d\udd17 Name BATTERIES_STATIC_DISPATCH_HPP BATT_CONST_T (i) BATT_CONST (i) Shortcut for: std::integral_constant<decltype(i), i>{} . Macro Documentation \ud83d\udd17 BATTERIES_STATIC_DISPATCH_HPP \ud83d\udd17 1 #define BATTERIES_STATIC_DISPATCH_HPP() BATT_CONST_T \ud83d\udd17 1 #define BATT_CONST_T(i) BATT_CONST \ud83d\udd17 1 #define BATT_CONST(i) Shortcut for: std::integral_constant<decltype(i), i>{} . Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATIC_DISPATCH_HPP #define BATTERIES_STATIC_DISPATCH_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> // #include <cstddef> #include <tuple> #include <type_traits> namespace batt { namespace detail { template < typename Arg , typename Result > using AbstractCaseHandler = Result ( * )( Arg ); template < typename IntT , IntT I , typename Fn , typename R > R CaseHandlerImpl ( Fn && fn ) { return BATT_FORWARD ( fn )( std :: integral_constant < IntT , I > {}); } template < typename IntT , IntT I , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , I > , std :: integral_constant < IntT , I > , AbstractCaseHandler < Fn , R >* /*begin*/ , AbstractCaseHandler < Fn , R >* /*end*/ ) { // Nothing to do; empty range. } template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , kBegin > , std :: integral_constant < IntT , kEnd > , AbstractCaseHandler < Fn , R >* begin , AbstractCaseHandler < Fn , R >* end ) { static_assert ( kEnd >= kBegin , \"\" ); BATT_CHECK_LE ( begin , end ); BATT_CHECK_EQ ( kEnd - kBegin , end - begin ); if ( begin == end - 1 ) { * begin = CaseHandlerImpl < IntT , kBegin , Fn , R > ; } else { constexpr IntT kMiddle = ( kBegin + kEnd ) / 2 ; AbstractCaseHandler < Fn , R >* middle = begin + ( end - begin ) / 2 ; initialize_case_handlers ( std :: integral_constant < IntT , kBegin > {}, std :: integral_constant < IntT , kMiddle > {}, begin , middle ); initialize_case_handlers ( std :: integral_constant < IntT , kMiddle > {}, std :: integral_constant < IntT , kEnd > {}, middle , end ); } } } // namespace detail template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R = decltype ( std :: declval < Fn > ()( std :: integral_constant < IntT , kBegin > {})) > R static_dispatch ( IntT i , Fn && fn ) { static const std :: array < detail :: AbstractCaseHandler < Fn && , R > , kEnd - kBegin > case_handlers = [ & ] { std :: array < detail :: AbstractCaseHandler < Fn && , R > , kEnd - kBegin > case_handlers ; detail :: initialize_case_handlers ( std :: integral_constant < IntT , kBegin > {}, std :: integral_constant < IntT , kEnd > {}, case_handlers . data (), case_handlers . data () + case_handlers . size ()); return case_handlers ; }(); BATT_CHECK_GE ( i , kBegin ); BATT_CHECK_LT ( i , kEnd ); return case_handlers [ i - kBegin ]( BATT_FORWARD ( fn )); } template < typename Fn > decltype ( auto ) static_dispatch ( bool b , Fn && fn ) { if ( b ) { return BATT_FORWARD ( fn )( std :: true_type {}); } else { return BATT_FORWARD ( fn )( std :: false_type {}); } } template < typename Tuple , typename Fn > decltype ( auto ) static_dispatch ( std :: size_t i , Fn && fn ) { return static_dispatch < std :: size_t , 0 , std :: tuple_size < Tuple >:: value > ( i , [ & fn ]( auto static_int ) mutable -> decltype ( auto ) { using T = std :: tuple_element_t < decltype ( static_int ) :: value , Tuple > ; return BATT_FORWARD ( fn )( StaticType < T > {}); }); } #define BATT_CONST_T(i) std::integral_constant<decltype(i), (i)> // clang-format off #define BATT_CONST(i) BATT_CONST_T(I){} // clang-format on } // namespace batt #endif // BATTERIES_STATIC_DISPATCH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/static_dispatch.hpp"},{"location":"_autogen/Files/static__dispatch_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/static__dispatch_8hpp/#defines","text":"Name BATTERIES_STATIC_DISPATCH_HPP BATT_CONST_T (i) BATT_CONST (i) Shortcut for: std::integral_constant<decltype(i), i>{} .","title":"Defines"},{"location":"_autogen/Files/static__dispatch_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/static__dispatch_8hpp/#batteries_static_dispatch_hpp","text":"1 #define BATTERIES_STATIC_DISPATCH_HPP()","title":"BATTERIES_STATIC_DISPATCH_HPP"},{"location":"_autogen/Files/static__dispatch_8hpp/#batt_const_t","text":"1 #define BATT_CONST_T(i)","title":"BATT_CONST_T"},{"location":"_autogen/Files/static__dispatch_8hpp/#batt_const","text":"1 #define BATT_CONST(i) Shortcut for: std::integral_constant<decltype(i), i>{} .","title":"BATT_CONST"},{"location":"_autogen/Files/static__dispatch_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATIC_DISPATCH_HPP #define BATTERIES_STATIC_DISPATCH_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> // #include <cstddef> #include <tuple> #include <type_traits> namespace batt { namespace detail { template < typename Arg , typename Result > using AbstractCaseHandler = Result ( * )( Arg ); template < typename IntT , IntT I , typename Fn , typename R > R CaseHandlerImpl ( Fn && fn ) { return BATT_FORWARD ( fn )( std :: integral_constant < IntT , I > {}); } template < typename IntT , IntT I , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , I > , std :: integral_constant < IntT , I > , AbstractCaseHandler < Fn , R >* /*begin*/ , AbstractCaseHandler < Fn , R >* /*end*/ ) { // Nothing to do; empty range. } template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , kBegin > , std :: integral_constant < IntT , kEnd > , AbstractCaseHandler < Fn , R >* begin , AbstractCaseHandler < Fn , R >* end ) { static_assert ( kEnd >= kBegin , \"\" ); BATT_CHECK_LE ( begin , end ); BATT_CHECK_EQ ( kEnd - kBegin , end - begin ); if ( begin == end - 1 ) { * begin = CaseHandlerImpl < IntT , kBegin , Fn , R > ; } else { constexpr IntT kMiddle = ( kBegin + kEnd ) / 2 ; AbstractCaseHandler < Fn , R >* middle = begin + ( end - begin ) / 2 ; initialize_case_handlers ( std :: integral_constant < IntT , kBegin > {}, std :: integral_constant < IntT , kMiddle > {}, begin , middle ); initialize_case_handlers ( std :: integral_constant < IntT , kMiddle > {}, std :: integral_constant < IntT , kEnd > {}, middle , end ); } } } // namespace detail template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R = decltype ( std :: declval < Fn > ()( std :: integral_constant < IntT , kBegin > {})) > R static_dispatch ( IntT i , Fn && fn ) { static const std :: array < detail :: AbstractCaseHandler < Fn && , R > , kEnd - kBegin > case_handlers = [ & ] { std :: array < detail :: AbstractCaseHandler < Fn && , R > , kEnd - kBegin > case_handlers ; detail :: initialize_case_handlers ( std :: integral_constant < IntT , kBegin > {}, std :: integral_constant < IntT , kEnd > {}, case_handlers . data (), case_handlers . data () + case_handlers . size ()); return case_handlers ; }(); BATT_CHECK_GE ( i , kBegin ); BATT_CHECK_LT ( i , kEnd ); return case_handlers [ i - kBegin ]( BATT_FORWARD ( fn )); } template < typename Fn > decltype ( auto ) static_dispatch ( bool b , Fn && fn ) { if ( b ) { return BATT_FORWARD ( fn )( std :: true_type {}); } else { return BATT_FORWARD ( fn )( std :: false_type {}); } } template < typename Tuple , typename Fn > decltype ( auto ) static_dispatch ( std :: size_t i , Fn && fn ) { return static_dispatch < std :: size_t , 0 , std :: tuple_size < Tuple >:: value > ( i , [ & fn ]( auto static_int ) mutable -> decltype ( auto ) { using T = std :: tuple_element_t < decltype ( static_int ) :: value , Tuple > ; return BATT_FORWARD ( fn )( StaticType < T > {}); }); } #define BATT_CONST_T(i) std::integral_constant<decltype(i), (i)> // clang-format off #define BATT_CONST(i) BATT_CONST_T(I){} // clang-format on } // namespace batt #endif // BATTERIES_STATIC_DISPATCH_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/status_8hpp/","text":"batteries/status.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name class batt::detail::StatusBase class batt::Status struct batt::Status::CodeEntry struct batt::Status::CodeGroup class batt::StatusOr class batt::detail::StatusOrValueContainer class batt::detail::StatusOrValueContainer< T & > class batt::StatusOr class batt::StatusOr< Status > class batt::StatusOr< StatusOr< T > > struct batt::detail::IsStatusOrImpl struct batt::detail::IsStatusOrImpl< StatusOr< T > > struct batt::RemoveStatusOrImpl struct batt::RemoveStatusOrImpl< StatusOr< T > > class batt::detail::NotOkStatusWrapper Defines \ud83d\udd17 Name BATTERIES_STATUS_HPP BATT_REQUIRE_OK (expr) BATT_ASSIGN_OK_RESULT (lvalue_expr, statusor_expr) BATT_OK_RESULT_OR_PANIC (expr) BATT_CHECK_OK (expr) Macro Documentation \ud83d\udd17 BATTERIES_STATUS_HPP \ud83d\udd17 1 #define BATTERIES_STATUS_HPP() BATT_REQUIRE_OK \ud83d\udd17 1 #define BATT_REQUIRE_OK(expr) BATT_ASSIGN_OK_RESULT \ud83d\udd17 1 #define BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr) BATT_OK_RESULT_OR_PANIC \ud83d\udd17 1 #define BATT_OK_RESULT_OR_PANIC(expr) BATT_CHECK_OK \ud83d\udd17 1 #define BATT_CHECK_OK(expr) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATUS_HPP #define BATTERIES_STATUS_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/stream_util.hpp> #include <batteries/strong_typedef.hpp> #include <batteries/utility.hpp> #include <boost/preprocessor/cat.hpp> #include <boost/system/error_code.hpp> #include <atomic> #include <cstring> #include <limits> #include <mutex> #include <string> #include <typeindex> #include <typeinfo> #include <vector> namespace batt { #ifdef BATT_STATUS_CUSTOM_MESSSAGES #error This feature is not ready yet! #endif namespace detail { class StatusBase { public : StatusBase () noexcept ; }; } // namespace detail // Intentionally value-compatible with Abseil's StatusCode. // enum class StatusCode : int { kOk = 0 , kCancelled = 1 , kUnknown = 2 , kInvalidArgument = 3 , kDeadlineExceeded = 4 , kNotFound = 5 , kAlreadyExists = 6 , kPermissionDenied = 7 , kResourceExhausted = 8 , kFailedPrecondition = 9 , kAborted = 10 , kOutOfRange = 11 , kUnimplemented = 12 , kInternal = 13 , kUnavailable = 14 , kDataLoss = 15 , kUnauthenticated = 16 , // ... // This range reserved for future allocation of Abseil status codes. // ... kClosed = 100 , kGrantUnavailable = 101 , kLoopBreak = 102 , kEndOfStream = 103 , kClosedBeforeEndOfStream = 104 , kGrantRevoked = 105 , }; enum ErrnoValue {}; class BATT_WARN_UNUSED_RESULT Status ; class Status : private detail :: StatusBase { public : using value_type = i32 ; //+++++++++++-+-+--+----- --- -- - - - - static constexpr i32 kGroupSizeBits = 12 /*-> 4096*/ ; static constexpr i32 kGroupSize = i32 { 1 } << kGroupSizeBits ; static constexpr i32 kMaxGroups = 0x7fffff00l - kGroupSize ; //+++++++++++-+-+--+----- --- -- - - - - struct CodeEntry { value_type code ; int enum_value ; std :: string message ; }; struct CodeGroup { std :: type_index enum_type_index { typeid ( int )}; usize index ; int min_enum_value ; std :: vector < usize > enum_value_to_code ; std :: vector < CodeEntry > entries ; }; //+++++++++++-+-+--+----- --- -- - - - - template < typename EnumT > static const CodeGroup & code_group_for_type () { return code_group_for_type_internal < EnumT > (); } static const std :: string & unknown_enum_value_message () { static const std :: string s = \"(Unknown enum value; not registered via batt::Status::register_codes)\" ; return s ; } template < typename EnumT > static bool register_codes ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ); static std :: string_view message_from_code ( value_type value ) { const usize index_of_group = get_index_of_group ( value ); const usize index_within_group = get_index_within_group ( value ); const auto & all_groups = registered_groups (); BATT_CHECK_LT ( index_of_group , all_groups . size ()); BATT_CHECK_LT ( index_within_group , all_groups [ index_of_group ] -> entries . size ()) << BATT_INSPECT ( index_of_group ) << BATT_INSPECT ( value ); return all_groups [ index_of_group ] -> entries [ index_within_group ]. message ; } //+++++++++++-+-+--+----- --- -- - - - - // Construct a no-error status object. // Status () : Status ( StatusCode :: kOk ) { } // This is a regular copyable value type. // Status ( const Status & ) = default ; Status & operator = ( const Status & ) = default ; // Implicitly convert enumerated types to Status. The given type `EnumT` must have been registered // via `Status::register_codes` prior to invoking this constructor. // template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> /*implicit*/ Status ( EnumT enum_value ) noexcept { const CodeGroup & group = code_group_for_type < EnumT > (); BATT_ASSERT_GE ( static_cast < int > ( enum_value ), group . min_enum_value ); const int index_within_enum = static_cast < int > ( enum_value ) - group . min_enum_value ; BATT_ASSERT_LT ( index_within_enum , static_cast < int > ( group . enum_value_to_code . size ())) << BATT_INSPECT ( group . index ) << BATT_INSPECT ( group . enum_type_index . name ()); this -> value_ = group . enum_value_to_code [ index_within_enum ]; BATT_ASSERT_NOT_NULLPTR ( message_from_code ( this -> value_ ). data ()); #ifdef BATT_ASSERT_CUSTOM_MESSSAGES const usize index_within_group = get_index_within_group ( this -> value_ ); this -> message_ = group . entries [ index_within_group ]. message ; #endif } #ifdef BATT_STATUS_CUSTOM_MESSSAGES template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> explicit Status ( EnumT enum_value , const std :: string_view & custom_message ) noexcept : Status { enum_value } { this -> message_ = custom_message ; } #endif bool ok () const noexcept BATT_WARN_UNUSED_RESULT { return ( this -> value_ & kLocalMask ) == 0 ; } value_type code () const noexcept { return this -> value_ ; } std :: string_view message () const noexcept { #ifdef BATT_STATUS_CUSTOM_MESSSAGES return this -> message_ ; #else return message_from_code ( this -> value_ ); #endif } const CodeGroup & group () const { const usize index_of_group = get_index_of_group ( this -> value_ ); const auto & all_groups = registered_groups (); BATT_ASSERT_LT ( index_of_group , all_groups . size ()); BATT_ASSERT_NOT_NULLPTR ( all_groups [ index_of_group ]); return * all_groups [ index_of_group ]; } void IgnoreError () const noexcept { // do nothing } void Update ( const Status & new_status ); private : //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - friend class detail :: StatusBase ; static constexpr usize kMaxGroupCount = 256 ; static constexpr i32 kMaxCodeNumericRange = 0xffff ; static constexpr i32 kLocalMask = ( i32 { 1 } << kGroupSizeBits ) - 1 ; static constexpr i32 kGroupMask = ~ kLocalMask ; //+++++++++++-+-+--+----- --- -- - - - - static usize next_group_index () { static std :: atomic < i32 > next_index { 0 }; const usize i = next_index . fetch_add ( 1 ); BATT_CHECK_LT ( i , kMaxGroupCount ); return i ; } static std :: array < CodeGroup * , kMaxGroupCount >& registered_groups () { static std :: array < CodeGroup * , kMaxGroupCount > all_groups ; return all_groups ; } template < typename EnumT > static CodeGroup & code_group_for_type_internal () { static CodeGroup group ; return group ; } static usize get_index_of_group ( value_type value ) { return ( value & kGroupMask ) >> kGroupSizeBits ; } static usize get_index_within_group ( value_type value ) { return value & kLocalMask ; } template < typename EnumT > static bool register_codes_internal ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ); //+++++++++++-+-+--+----- --- -- - - - - // Unique error code; // value_type value_ ; #ifdef BATT_STATUS_CUSTOM_MESSSAGES std :: string_view message_ ; #endif }; static_assert ( sizeof ( Status ) <= sizeof ( void * ), \"\" ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Print human-friendly representation of a Status. // std :: ostream & operator << ( std :: ostream & out , const Status & t ); // Equality comparison of `Status` values. // bool operator == ( const Status & l , const Status & r ); bool operator != ( const Status & l , const Status & r ); // Returns a Status value `s` for which `s.ok() == true`. // Status OkStatus (); inline void Status::Update ( const Status & new_status ) { if ( this -> ok () || * this == Status { StatusCode :: kUnknown }) { * this = new_status ; } } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T > class BATT_WARN_UNUSED_RESULT StatusOr ; namespace detail { template < typename T > class StatusOrValueContainer { public : template < typename ... Args > void construct ( Args && ... args ) { new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); } T * pointer () noexcept { return reinterpret_cast < T *> ( & this -> storage_ ); } const T * pointer () const noexcept { return reinterpret_cast < const T *> ( & this -> storage_ ); } T & reference () noexcept { return * this -> pointer (); } const T & reference () const noexcept { return * this -> pointer (); } void destroy () { this -> reference (). ~ T (); } private : std :: aligned_storage_t < sizeof ( T ), alignof ( T ) > storage_ ; }; template < typename T > class StatusOrValueContainer < T &> { public : void construct ( T & obj ) { this -> ptr_ = & obj ; } T * pointer () const noexcept { return this -> ptr_ ; } T & reference () const noexcept { return * this -> pointer (); } void destroy () noexcept { this -> ptr_ = nullptr ; } private : T * ptr_ = nullptr ; }; } // namespace detail template < typename T > class StatusOr { template < typename U > friend class StatusOr ; public : using value_type = T ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Constructors explicit StatusOr () noexcept : status_ { StatusCode :: kUnknown } { BATT_ASSERT ( ! this -> ok ()); } /*implicit*/ StatusOr ( const Status & s ) : status_ { s } { BATT_CHECK ( ! this -> ok ()) << \"StatusOr must not be constructed with an Ok Status value.\" ; } StatusOr ( StatusOr && that ) : status_ { StatusCode :: kUnknown } { if ( that . ok ()) { this -> value_ . construct ( std :: move ( that . value ())); this -> status_ = OkStatus (); that . value_ . destroy (); that . status_ = StatusCode :: kUnknown ; } else { this -> status_ = std :: move ( that . status_ ); } } StatusOr ( const StatusOr & that ) : status_ { that . status_ } { if ( this -> ok ()) { this -> value_ . construct ( that . value ()); } } /*implicit*/ StatusOr ( const std :: decay_t < T >& obj ) noexcept ( noexcept ( T ( std :: declval < const std :: decay_t < T >&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( obj ); } /*implicit*/ StatusOr ( std :: decay_t < T >& obj ) noexcept ( noexcept ( T ( std :: declval < std :: decay_t < T >&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( obj ); } /*implicit*/ StatusOr ( std :: decay_t < T >&& obj ) noexcept ( noexcept ( T ( std :: declval < std :: decay_t < T >&&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( std :: move ( obj )); } template < typename U , typename = EnableIfNoShadow < StatusOr , U &&> , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>> , typename = void > /*implicit*/ StatusOr ( U && obj ) noexcept ( noexcept ( T ( std :: declval < U &&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( BATT_FORWARD ( obj )); } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> /*implicit*/ StatusOr ( StatusOr < U >&& that ) noexcept ( noexcept ( T ( std :: declval < U &&> ()))) : status_ { StatusCode :: kUnknown } { if ( that . status_ . ok ()) { this -> value_ . construct ( std :: move ( that . value ())); this -> status_ = OkStatus (); that . value_ . destroy (); that . status_ = StatusCode :: kUnknown ; } else { this -> status_ = std :: move ( that ). status (); } } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , const U &>>> /*implicit*/ StatusOr ( const StatusOr < U >& that ) noexcept ( noexcept ( T ( std :: declval < const U &> ()))) : status_ { StatusCode :: kUnknown } { if ( that . status_ . ok ()) { new ( & this -> storage_ ) T ( that . value ()); this -> status_ = OkStatus (); } else { this -> status_ = that . status_ ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Destructor ~ StatusOr () { if ( this -> ok ()) { this -> value_ . destroy (); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Assignment operator overloads StatusOr & operator = ( std :: decay_t < T >&& obj ) { static_assert ( std :: is_same_v < T , std :: decay_t < T >> , \"\" ); if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = OkStatus (); this -> value_ . construct ( std :: move ( obj )); return * this ; } StatusOr & operator = ( const T & obj ) { if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = OkStatus (); this -> value_ . construct ( obj ); return * this ; } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> StatusOr & operator = ( U && obj ) noexcept ( noexcept ( T ( std :: declval < U &&> ()))) { if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = OkStatus (); this -> value_ . construct ( BATT_FORWARD ( obj )); return * this ; } StatusOr & operator = ( const StatusOr & that ) noexcept ( noexcept ( T ( std :: declval < const T &> ())) && noexcept ( std :: declval < T &> () = std :: declval < const T &> ())) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> ok ()) { if ( that . ok ()) { this -> value () = that . value (); } else { this -> value_ . destroy (); } } else { if ( that . ok ()) { this -> value_ . construct ( that . value ()); } } this -> status_ = that . status_ ; } return * this ; } StatusOr & operator = ( StatusOr && that ) noexcept ( noexcept ( T ( std :: declval < T &&> ())) && noexcept ( std :: declval < T &> () = std :: move ( std :: declval < T &> ()))) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> ok ()) { if ( that . ok ()) { this -> value () = std :: move ( that . value ()); } else { this -> value_ . destroy (); } } else { if ( that . ok ()) { this -> value_ . construct ( std :: move ( that . value ())); } } this -> status_ = that . status_ ; } return * this ; } StatusOr & operator = ( const Status & new_status ) noexcept { BATT_CHECK ( ! new_status . ok ()) << \"StatusOr must not be constructed with an Ok Status value.\" ; if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = new_status ; return * this ; } template < typename ... Args > void emplace ( Args && ... args ) { if ( this -> ok ()) { this -> value_ . destroy (); } this -> value_ . construct ( BATT_FORWARD ( args )...); this -> status_ = OkStatus (); } template < typename U > void emplace ( StatusOr < U >&& that ) { if ( this -> ok ()) { this -> value_ . destroy (); this -> status_ = StatusCode :: kUnknown ; } if ( that . ok ()) { this -> value_ . construct ( std :: move ( * that )); } this -> status_ = that . status (); } template < typename U > void emplace ( const StatusOr < U >& that ) { if ( this -> ok ()) { this -> value_ . destroy (); this -> status_ = StatusCode :: kUnknown ; } if ( that . ok ()) { this -> value_ . construct ( * that ); } this -> status_ = that . status (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - void IgnoreError () const noexcept { // do nothing } bool ok () const noexcept { return this -> status_ . ok (); } const Status & status () const & { return this -> status_ ; } T & value () noexcept { BATT_ASSERT ( this -> status_ . ok ()) << BATT_INSPECT ( this -> status_ ); return this -> value_ . reference (); } const T & value () const noexcept { BATT_ASSERT ( this -> status_ . ok ()) << BATT_INSPECT ( this -> status_ ); return this -> value_ . reference (); } T & operator * () & noexcept { return this -> value (); } const T & operator * () const & noexcept { return this -> value (); } T operator * () && noexcept { return std :: move ( this -> value ()); } const std :: decay_t < T >* operator -> () const noexcept { return & ( this -> value ()); } std :: decay_t < T >* operator -> () noexcept { return & ( this -> value ()); } private : Status status_ ; detail :: StatusOrValueContainer < T > value_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // StatusOr<Status> == Status. // template <> class StatusOr < Status > : public Status { public : using Status :: Status ; /*implicit*/ StatusOr ( const Status & status ) : Status { status } { } /*implicit*/ StatusOr ( Status && status ) : Status { std :: move ( status )} { } }; static_assert ( sizeof ( Status ) == sizeof ( StatusOr < Status > ), \"\" ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // StatusOr<StatusOr<T>> == StatusOr<T> // template < typename T > class StatusOr < StatusOr < T >> : public StatusOr < T > { public : using StatusOr < T >:: StatusOr ; /*implicit*/ StatusOr ( const StatusOr < T >& status_or ) : StatusOr < T > { status_or } { } /*implicit*/ StatusOr ( StatusOr < T >&& status_or ) : StatusOr < T > { std :: move ( status_or )} { } }; static_assert ( sizeof ( StatusOr < StatusOr < int >> ) == sizeof ( StatusOr < int > ), \"\" ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T , typename U , typename = std :: enable_if_t < CanBeEqCompared < T , U > {} >> inline bool operator == ( const StatusOr < T >& l , const StatusOr < U >& r ) { return ( l . ok () && r . ok () && l . value () == r . value ()) || ( ! l . ok () && ! r . ok () && l . status () == r . status ()); } // If `T` (and `U`) can't be equality-compared, then we define StatusOr<T> to be equal iff the non-ok status // values are equal. // template < typename T , typename U , typename = std :: enable_if_t <! CanBeEqCompared < T , U > {} > , typename = void > inline bool operator == ( const StatusOr < T >& l , const StatusOr < U >& r ) { return ( ! l . ok () && ! r . ok () && l . status () == r . status ()); } template < typename T , typename U > inline bool operator != ( const StatusOr < T >& l , const StatusOr < U >& r ) { return ! ( l == r ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace detail { template < typename T > struct IsStatusOrImpl : std :: false_type { }; template < typename T > struct IsStatusOrImpl < StatusOr < T >> : std :: true_type { }; } // namespace detail template < typename T > using IsStatusOr = detail :: IsStatusOrImpl < std :: decay_t < T >> ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > struct RemoveStatusOrImpl ; template < typename T > struct RemoveStatusOrImpl < StatusOr < T >> : batt :: StaticType < T > { }; template < typename T > using RemoveStatusOr = typename RemoveStatusOrImpl < T >:: type ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - inline bool is_ok_status ( const std :: error_code & ec ) { return ! ec ; } template < typename T > bool is_ok_status ( const T & val ) { return val . ok (); } enum struct LogLevel { kFatal , kError , kWarning , kInfo , kDebug , kVerbose }; inline LogLevel & require_fail_thread_default_log_level () { thread_local LogLevel log_level_ = LogLevel :: kVerbose ; return log_level_ ; } namespace detail { class NotOkStatusWrapper { public : explicit NotOkStatusWrapper ( const char * file , int line , Status && status ) noexcept : file_ { file } , line_ { line } , status_ ( std :: move ( status )) { * this << this -> status_ << \"; \" ; } explicit NotOkStatusWrapper ( const char * file , int line , const Status & status ) noexcept : file_ { file } , line_ { line } , status_ ( status ) { #ifndef BATT_GLOG_AVAILABLE * this << \"(\" << this -> file_ << \":\" << this -> line_ << \") \" ; #endif // BATT_GLOG_AVAILALBE * this << this -> status_ << \"; \" ; } ~ NotOkStatusWrapper () noexcept { #ifdef BATT_GLOG_AVAILABLE switch ( this -> level_ ) { case LogLevel :: kFatal : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_FATAL ). stream () << this -> output_ . str (); break ; case LogLevel :: kError : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_ERROR ). stream () << this -> output_ . str (); break ; case LogLevel :: kWarning : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_WARNING ). stream () << this -> output_ . str (); break ; case LogLevel :: kInfo : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_INFO ). stream () << this -> output_ . str (); break ; case LogLevel :: kDebug : DLOG ( INFO ) << \" [\" << this -> file_ << \":\" << this -> line_ << \"] \" << this -> output_ . str (); break ; case LogLevel :: kVerbose : VLOG ( 1 ) << \" [\" << this -> file_ << \":\" << this -> line_ << \"] \" << this -> output_ . str (); break ; } #endif // BATT_GLOG_AVAILABLE } operator Status () noexcept { return std :: move ( this -> status_ ); } template < typename T > operator StatusOr < T > () noexcept { return StatusOr < T > { std :: move ( this -> status_ )}; } NotOkStatusWrapper & operator << ( LogLevel new_level ) { this -> level_ = new_level ; return * this ; } template < typename T > NotOkStatusWrapper & operator << ( T && val ) { this -> output_ << BATT_FORWARD ( val ); return * this ; } private : const char * file_ ; int line_ ; Status status_ ; LogLevel level_ { require_fail_thread_default_log_level ()}; std :: ostringstream output_ ; }; } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename = std :: enable_if_t < IsStatusOr < T > {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> inline decltype ( auto ) to_status ( T && v ) { return BATT_FORWARD ( v ). status (); } template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , Status > || std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>> , typename = void > inline decltype ( auto ) to_status ( T && s ) { return BATT_FORWARD ( s ); } template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , boost :: system :: error_code > || std :: is_same_v < std :: decay_t < T > , std :: error_code >> , typename = void , typename = void > inline Status to_status ( const T & ec ) { // TODO [tastolfi 2021-10-13] support these so we don't lose information. if ( ! ec ) { return OkStatus (); } return Status { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_REQUIRE_OK(expr) \\ for (decltype(auto) BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__) = (expr); \\ !::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__));) \\ return ::batt::detail::NotOkStatusWrapper \\ { \\ __FILE__, __LINE__, \\ ::batt::to_status(BATT_FORWARD(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__))) \\ } #define BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr) \\ auto BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__) = statusor_expr; \\ BATT_REQUIRE_OK(BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__)); \\ lvalue_expr = std::move(*BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__)) #define BATT_OK_RESULT_OR_PANIC(expr) \\ [&](auto&& expr_value) { \\ BATT_CHECK(::batt::is_ok_status(expr_value)) \\ << BOOST_PP_STRINGIZE(expr) << \".status == \" << ::batt::to_status(expr_value); \\ return std::move(*BATT_FORWARD(expr_value)); \\ }((expr)) #define BATT_CHECK_OK(expr) \\ if (bool BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__) = true) \\ for (decltype(auto) BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__) = (expr); \\ BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__); \\ BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__) = false) \\ for (; !BATT_HINT_TRUE( \\ ::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__))) && \\ BATT_HINT_TRUE(::batt::lock_fail_check_mutex()); \\ ::batt::fail_check_exit()) \\ BATT_FAIL_CHECK_MESSAGE(\"batt::to_status(\" BOOST_PP_STRINGIZE(expr) \")\", ::batt::to_status(BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__)), \\ \"==\", \"batt::OkStatus()\", ::batt::OkStatus(), __FILE__, __LINE__, __PRETTY_FUNCTION__) inline Status status_from_errno ( int code ) { return static_cast < ErrnoValue > ( code ); } template < typename T > inline Status status_from_retval ( T retval ) { if ( retval >= 0 ) { return OkStatus (); } return status_from_errno ( errno ); } template < typename T > inline T && ok_result_or_panic ( StatusOr < T >&& result ) { BATT_CHECK ( result . ok ()) << result . status (); return std :: move ( * result ); } template < typename T , typename = std :: enable_if_t < IsStatusOr < std :: decay_t < T >> {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> std :: ostream & operator << ( std :: ostream & out , T && status_or ) { if ( ! status_or . ok ()) { return out << \"Status{\" << status_or . status () << \"}\" ; } return out << \"Ok{\" << make_printable ( * status_or ) << \"}\" ; } inline bool status_is_retryable ( const Status & s ) { return s == StatusCode :: kUnavailable // || s == static_cast < ErrnoValue > ( EAGAIN ) // || s == static_cast < ErrnoValue > ( EINTR ) // ; } //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ template < typename EnumT > inline bool Status :: register_codes ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ) { static detail :: StatusBase base ; return register_codes_internal < EnumT > ( codes ); } template < typename EnumT > inline bool Status :: register_codes_internal ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ) { static bool exactly_once = [ & ]() -> bool { [ & ] { CodeGroup group ; group . enum_type_index = std :: type_index { typeid ( EnumT )}; group . index = next_group_index (); BATT_CHECK_LT ( group . index , kMaxGroups ) << \"Status::register_codes called too many times!\" ; if ( codes . empty ()) { return ; } int min_enum_value = std :: numeric_limits < int >:: max (); int max_enum_value = std :: numeric_limits < int >:: min (); Status :: value_type next_code = group . index * kGroupSize ; for ( auto & [ value , message ] : codes ) { const int enum_value = static_cast < int > ( value ); min_enum_value = std :: min ( min_enum_value , enum_value ); max_enum_value = std :: max ( max_enum_value , enum_value ); group . entries . emplace_back ( CodeEntry { next_code , enum_value , std :: move ( message ), }); next_code += 1 ; } BATT_CHECK_LE ( max_enum_value - min_enum_value , kMaxCodeNumericRange ) << \"The maximum numeric range of codes was exceeded. min_enum_value=\" << min_enum_value << \" max_enum_value=\" << max_enum_value ; group . min_enum_value = min_enum_value ; group . enum_value_to_code . resize ( max_enum_value - min_enum_value + 1 ); std :: fill ( group . enum_value_to_code . begin (), group . enum_value_to_code . end (), next_code ); for ( const CodeEntry & e : group . entries ) { group . enum_value_to_code [ e . enum_value - group . min_enum_value ] = e . code ; } // Insert an entry at the end of the group for all unknown values. // group . entries . emplace_back ( CodeEntry { next_code , max_enum_value + 1 , unknown_enum_value_message ()}); // Atomically insert the new code group. // CodeGroup & global_group = Status :: code_group_for_type_internal < EnumT > (); BATT_CHECK ( global_group . entries . empty ()) << \"A status code group may only be registered once!\" ; global_group = std :: move ( group ); /*std::array<CodeGroup*, ...>*/ auto & all_groups = Status :: registered_groups (); BATT_CHECK_LT ( global_group . index , all_groups . size ()); all_groups [ global_group . index ] = & global_group ; // Done! }(); return true ; }(); return exactly_once ; } } // namespace batt #endif // BATTERIES_STATUS_HPP #if BATT_HEADER_ONLY #include <batteries/status_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/status.hpp"},{"location":"_autogen/Files/status_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/status_8hpp/#classes","text":"Name class batt::detail::StatusBase class batt::Status struct batt::Status::CodeEntry struct batt::Status::CodeGroup class batt::StatusOr class batt::detail::StatusOrValueContainer class batt::detail::StatusOrValueContainer< T & > class batt::StatusOr class batt::StatusOr< Status > class batt::StatusOr< StatusOr< T > > struct batt::detail::IsStatusOrImpl struct batt::detail::IsStatusOrImpl< StatusOr< T > > struct batt::RemoveStatusOrImpl struct batt::RemoveStatusOrImpl< StatusOr< T > > class batt::detail::NotOkStatusWrapper","title":"Classes"},{"location":"_autogen/Files/status_8hpp/#defines","text":"Name BATTERIES_STATUS_HPP BATT_REQUIRE_OK (expr) BATT_ASSIGN_OK_RESULT (lvalue_expr, statusor_expr) BATT_OK_RESULT_OR_PANIC (expr) BATT_CHECK_OK (expr)","title":"Defines"},{"location":"_autogen/Files/status_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/status_8hpp/#batteries_status_hpp","text":"1 #define BATTERIES_STATUS_HPP()","title":"BATTERIES_STATUS_HPP"},{"location":"_autogen/Files/status_8hpp/#batt_require_ok","text":"1 #define BATT_REQUIRE_OK(expr)","title":"BATT_REQUIRE_OK"},{"location":"_autogen/Files/status_8hpp/#batt_assign_ok_result","text":"1 #define BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr)","title":"BATT_ASSIGN_OK_RESULT"},{"location":"_autogen/Files/status_8hpp/#batt_ok_result_or_panic","text":"1 #define BATT_OK_RESULT_OR_PANIC(expr)","title":"BATT_OK_RESULT_OR_PANIC"},{"location":"_autogen/Files/status_8hpp/#batt_check_ok","text":"1 #define BATT_CHECK_OK(expr)","title":"BATT_CHECK_OK"},{"location":"_autogen/Files/status_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATUS_HPP #define BATTERIES_STATUS_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/stream_util.hpp> #include <batteries/strong_typedef.hpp> #include <batteries/utility.hpp> #include <boost/preprocessor/cat.hpp> #include <boost/system/error_code.hpp> #include <atomic> #include <cstring> #include <limits> #include <mutex> #include <string> #include <typeindex> #include <typeinfo> #include <vector> namespace batt { #ifdef BATT_STATUS_CUSTOM_MESSSAGES #error This feature is not ready yet! #endif namespace detail { class StatusBase { public : StatusBase () noexcept ; }; } // namespace detail // Intentionally value-compatible with Abseil's StatusCode. // enum class StatusCode : int { kOk = 0 , kCancelled = 1 , kUnknown = 2 , kInvalidArgument = 3 , kDeadlineExceeded = 4 , kNotFound = 5 , kAlreadyExists = 6 , kPermissionDenied = 7 , kResourceExhausted = 8 , kFailedPrecondition = 9 , kAborted = 10 , kOutOfRange = 11 , kUnimplemented = 12 , kInternal = 13 , kUnavailable = 14 , kDataLoss = 15 , kUnauthenticated = 16 , // ... // This range reserved for future allocation of Abseil status codes. // ... kClosed = 100 , kGrantUnavailable = 101 , kLoopBreak = 102 , kEndOfStream = 103 , kClosedBeforeEndOfStream = 104 , kGrantRevoked = 105 , }; enum ErrnoValue {}; class BATT_WARN_UNUSED_RESULT Status ; class Status : private detail :: StatusBase { public : using value_type = i32 ; //+++++++++++-+-+--+----- --- -- - - - - static constexpr i32 kGroupSizeBits = 12 /*-> 4096*/ ; static constexpr i32 kGroupSize = i32 { 1 } << kGroupSizeBits ; static constexpr i32 kMaxGroups = 0x7fffff00l - kGroupSize ; //+++++++++++-+-+--+----- --- -- - - - - struct CodeEntry { value_type code ; int enum_value ; std :: string message ; }; struct CodeGroup { std :: type_index enum_type_index { typeid ( int )}; usize index ; int min_enum_value ; std :: vector < usize > enum_value_to_code ; std :: vector < CodeEntry > entries ; }; //+++++++++++-+-+--+----- --- -- - - - - template < typename EnumT > static const CodeGroup & code_group_for_type () { return code_group_for_type_internal < EnumT > (); } static const std :: string & unknown_enum_value_message () { static const std :: string s = \"(Unknown enum value; not registered via batt::Status::register_codes)\" ; return s ; } template < typename EnumT > static bool register_codes ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ); static std :: string_view message_from_code ( value_type value ) { const usize index_of_group = get_index_of_group ( value ); const usize index_within_group = get_index_within_group ( value ); const auto & all_groups = registered_groups (); BATT_CHECK_LT ( index_of_group , all_groups . size ()); BATT_CHECK_LT ( index_within_group , all_groups [ index_of_group ] -> entries . size ()) << BATT_INSPECT ( index_of_group ) << BATT_INSPECT ( value ); return all_groups [ index_of_group ] -> entries [ index_within_group ]. message ; } //+++++++++++-+-+--+----- --- -- - - - - // Construct a no-error status object. // Status () : Status ( StatusCode :: kOk ) { } // This is a regular copyable value type. // Status ( const Status & ) = default ; Status & operator = ( const Status & ) = default ; // Implicitly convert enumerated types to Status. The given type `EnumT` must have been registered // via `Status::register_codes` prior to invoking this constructor. // template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> /*implicit*/ Status ( EnumT enum_value ) noexcept { const CodeGroup & group = code_group_for_type < EnumT > (); BATT_ASSERT_GE ( static_cast < int > ( enum_value ), group . min_enum_value ); const int index_within_enum = static_cast < int > ( enum_value ) - group . min_enum_value ; BATT_ASSERT_LT ( index_within_enum , static_cast < int > ( group . enum_value_to_code . size ())) << BATT_INSPECT ( group . index ) << BATT_INSPECT ( group . enum_type_index . name ()); this -> value_ = group . enum_value_to_code [ index_within_enum ]; BATT_ASSERT_NOT_NULLPTR ( message_from_code ( this -> value_ ). data ()); #ifdef BATT_ASSERT_CUSTOM_MESSSAGES const usize index_within_group = get_index_within_group ( this -> value_ ); this -> message_ = group . entries [ index_within_group ]. message ; #endif } #ifdef BATT_STATUS_CUSTOM_MESSSAGES template < typename EnumT , typename = std :: enable_if_t < std :: is_enum_v < EnumT >>> explicit Status ( EnumT enum_value , const std :: string_view & custom_message ) noexcept : Status { enum_value } { this -> message_ = custom_message ; } #endif bool ok () const noexcept BATT_WARN_UNUSED_RESULT { return ( this -> value_ & kLocalMask ) == 0 ; } value_type code () const noexcept { return this -> value_ ; } std :: string_view message () const noexcept { #ifdef BATT_STATUS_CUSTOM_MESSSAGES return this -> message_ ; #else return message_from_code ( this -> value_ ); #endif } const CodeGroup & group () const { const usize index_of_group = get_index_of_group ( this -> value_ ); const auto & all_groups = registered_groups (); BATT_ASSERT_LT ( index_of_group , all_groups . size ()); BATT_ASSERT_NOT_NULLPTR ( all_groups [ index_of_group ]); return * all_groups [ index_of_group ]; } void IgnoreError () const noexcept { // do nothing } void Update ( const Status & new_status ); private : //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - friend class detail :: StatusBase ; static constexpr usize kMaxGroupCount = 256 ; static constexpr i32 kMaxCodeNumericRange = 0xffff ; static constexpr i32 kLocalMask = ( i32 { 1 } << kGroupSizeBits ) - 1 ; static constexpr i32 kGroupMask = ~ kLocalMask ; //+++++++++++-+-+--+----- --- -- - - - - static usize next_group_index () { static std :: atomic < i32 > next_index { 0 }; const usize i = next_index . fetch_add ( 1 ); BATT_CHECK_LT ( i , kMaxGroupCount ); return i ; } static std :: array < CodeGroup * , kMaxGroupCount >& registered_groups () { static std :: array < CodeGroup * , kMaxGroupCount > all_groups ; return all_groups ; } template < typename EnumT > static CodeGroup & code_group_for_type_internal () { static CodeGroup group ; return group ; } static usize get_index_of_group ( value_type value ) { return ( value & kGroupMask ) >> kGroupSizeBits ; } static usize get_index_within_group ( value_type value ) { return value & kLocalMask ; } template < typename EnumT > static bool register_codes_internal ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ); //+++++++++++-+-+--+----- --- -- - - - - // Unique error code; // value_type value_ ; #ifdef BATT_STATUS_CUSTOM_MESSSAGES std :: string_view message_ ; #endif }; static_assert ( sizeof ( Status ) <= sizeof ( void * ), \"\" ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Print human-friendly representation of a Status. // std :: ostream & operator << ( std :: ostream & out , const Status & t ); // Equality comparison of `Status` values. // bool operator == ( const Status & l , const Status & r ); bool operator != ( const Status & l , const Status & r ); // Returns a Status value `s` for which `s.ok() == true`. // Status OkStatus (); inline void Status::Update ( const Status & new_status ) { if ( this -> ok () || * this == Status { StatusCode :: kUnknown }) { * this = new_status ; } } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T > class BATT_WARN_UNUSED_RESULT StatusOr ; namespace detail { template < typename T > class StatusOrValueContainer { public : template < typename ... Args > void construct ( Args && ... args ) { new ( & this -> storage_ ) T ( BATT_FORWARD ( args )...); } T * pointer () noexcept { return reinterpret_cast < T *> ( & this -> storage_ ); } const T * pointer () const noexcept { return reinterpret_cast < const T *> ( & this -> storage_ ); } T & reference () noexcept { return * this -> pointer (); } const T & reference () const noexcept { return * this -> pointer (); } void destroy () { this -> reference (). ~ T (); } private : std :: aligned_storage_t < sizeof ( T ), alignof ( T ) > storage_ ; }; template < typename T > class StatusOrValueContainer < T &> { public : void construct ( T & obj ) { this -> ptr_ = & obj ; } T * pointer () const noexcept { return this -> ptr_ ; } T & reference () const noexcept { return * this -> pointer (); } void destroy () noexcept { this -> ptr_ = nullptr ; } private : T * ptr_ = nullptr ; }; } // namespace detail template < typename T > class StatusOr { template < typename U > friend class StatusOr ; public : using value_type = T ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Constructors explicit StatusOr () noexcept : status_ { StatusCode :: kUnknown } { BATT_ASSERT ( ! this -> ok ()); } /*implicit*/ StatusOr ( const Status & s ) : status_ { s } { BATT_CHECK ( ! this -> ok ()) << \"StatusOr must not be constructed with an Ok Status value.\" ; } StatusOr ( StatusOr && that ) : status_ { StatusCode :: kUnknown } { if ( that . ok ()) { this -> value_ . construct ( std :: move ( that . value ())); this -> status_ = OkStatus (); that . value_ . destroy (); that . status_ = StatusCode :: kUnknown ; } else { this -> status_ = std :: move ( that . status_ ); } } StatusOr ( const StatusOr & that ) : status_ { that . status_ } { if ( this -> ok ()) { this -> value_ . construct ( that . value ()); } } /*implicit*/ StatusOr ( const std :: decay_t < T >& obj ) noexcept ( noexcept ( T ( std :: declval < const std :: decay_t < T >&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( obj ); } /*implicit*/ StatusOr ( std :: decay_t < T >& obj ) noexcept ( noexcept ( T ( std :: declval < std :: decay_t < T >&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( obj ); } /*implicit*/ StatusOr ( std :: decay_t < T >&& obj ) noexcept ( noexcept ( T ( std :: declval < std :: decay_t < T >&&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( std :: move ( obj )); } template < typename U , typename = EnableIfNoShadow < StatusOr , U &&> , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>> , typename = void > /*implicit*/ StatusOr ( U && obj ) noexcept ( noexcept ( T ( std :: declval < U &&> ()))) : status_ { OkStatus ()} { this -> value_ . construct ( BATT_FORWARD ( obj )); } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> /*implicit*/ StatusOr ( StatusOr < U >&& that ) noexcept ( noexcept ( T ( std :: declval < U &&> ()))) : status_ { StatusCode :: kUnknown } { if ( that . status_ . ok ()) { this -> value_ . construct ( std :: move ( that . value ())); this -> status_ = OkStatus (); that . value_ . destroy (); that . status_ = StatusCode :: kUnknown ; } else { this -> status_ = std :: move ( that ). status (); } } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , const U &>>> /*implicit*/ StatusOr ( const StatusOr < U >& that ) noexcept ( noexcept ( T ( std :: declval < const U &> ()))) : status_ { StatusCode :: kUnknown } { if ( that . status_ . ok ()) { new ( & this -> storage_ ) T ( that . value ()); this -> status_ = OkStatus (); } else { this -> status_ = that . status_ ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Destructor ~ StatusOr () { if ( this -> ok ()) { this -> value_ . destroy (); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Assignment operator overloads StatusOr & operator = ( std :: decay_t < T >&& obj ) { static_assert ( std :: is_same_v < T , std :: decay_t < T >> , \"\" ); if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = OkStatus (); this -> value_ . construct ( std :: move ( obj )); return * this ; } StatusOr & operator = ( const T & obj ) { if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = OkStatus (); this -> value_ . construct ( obj ); return * this ; } template < typename U , typename = std :: enable_if_t <! std :: is_same_v < std :: decay_t < U > , T > && std :: is_constructible_v < T , U &&>>> StatusOr & operator = ( U && obj ) noexcept ( noexcept ( T ( std :: declval < U &&> ()))) { if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = OkStatus (); this -> value_ . construct ( BATT_FORWARD ( obj )); return * this ; } StatusOr & operator = ( const StatusOr & that ) noexcept ( noexcept ( T ( std :: declval < const T &> ())) && noexcept ( std :: declval < T &> () = std :: declval < const T &> ())) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> ok ()) { if ( that . ok ()) { this -> value () = that . value (); } else { this -> value_ . destroy (); } } else { if ( that . ok ()) { this -> value_ . construct ( that . value ()); } } this -> status_ = that . status_ ; } return * this ; } StatusOr & operator = ( StatusOr && that ) noexcept ( noexcept ( T ( std :: declval < T &&> ())) && noexcept ( std :: declval < T &> () = std :: move ( std :: declval < T &> ()))) { if ( BATT_HINT_TRUE ( this != & that )) { if ( this -> ok ()) { if ( that . ok ()) { this -> value () = std :: move ( that . value ()); } else { this -> value_ . destroy (); } } else { if ( that . ok ()) { this -> value_ . construct ( std :: move ( that . value ())); } } this -> status_ = that . status_ ; } return * this ; } StatusOr & operator = ( const Status & new_status ) noexcept { BATT_CHECK ( ! new_status . ok ()) << \"StatusOr must not be constructed with an Ok Status value.\" ; if ( this -> ok ()) { this -> value_ . destroy (); } this -> status_ = new_status ; return * this ; } template < typename ... Args > void emplace ( Args && ... args ) { if ( this -> ok ()) { this -> value_ . destroy (); } this -> value_ . construct ( BATT_FORWARD ( args )...); this -> status_ = OkStatus (); } template < typename U > void emplace ( StatusOr < U >&& that ) { if ( this -> ok ()) { this -> value_ . destroy (); this -> status_ = StatusCode :: kUnknown ; } if ( that . ok ()) { this -> value_ . construct ( std :: move ( * that )); } this -> status_ = that . status (); } template < typename U > void emplace ( const StatusOr < U >& that ) { if ( this -> ok ()) { this -> value_ . destroy (); this -> status_ = StatusCode :: kUnknown ; } if ( that . ok ()) { this -> value_ . construct ( * that ); } this -> status_ = that . status (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - void IgnoreError () const noexcept { // do nothing } bool ok () const noexcept { return this -> status_ . ok (); } const Status & status () const & { return this -> status_ ; } T & value () noexcept { BATT_ASSERT ( this -> status_ . ok ()) << BATT_INSPECT ( this -> status_ ); return this -> value_ . reference (); } const T & value () const noexcept { BATT_ASSERT ( this -> status_ . ok ()) << BATT_INSPECT ( this -> status_ ); return this -> value_ . reference (); } T & operator * () & noexcept { return this -> value (); } const T & operator * () const & noexcept { return this -> value (); } T operator * () && noexcept { return std :: move ( this -> value ()); } const std :: decay_t < T >* operator -> () const noexcept { return & ( this -> value ()); } std :: decay_t < T >* operator -> () noexcept { return & ( this -> value ()); } private : Status status_ ; detail :: StatusOrValueContainer < T > value_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // StatusOr<Status> == Status. // template <> class StatusOr < Status > : public Status { public : using Status :: Status ; /*implicit*/ StatusOr ( const Status & status ) : Status { status } { } /*implicit*/ StatusOr ( Status && status ) : Status { std :: move ( status )} { } }; static_assert ( sizeof ( Status ) == sizeof ( StatusOr < Status > ), \"\" ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // StatusOr<StatusOr<T>> == StatusOr<T> // template < typename T > class StatusOr < StatusOr < T >> : public StatusOr < T > { public : using StatusOr < T >:: StatusOr ; /*implicit*/ StatusOr ( const StatusOr < T >& status_or ) : StatusOr < T > { status_or } { } /*implicit*/ StatusOr ( StatusOr < T >&& status_or ) : StatusOr < T > { std :: move ( status_or )} { } }; static_assert ( sizeof ( StatusOr < StatusOr < int >> ) == sizeof ( StatusOr < int > ), \"\" ); //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- template < typename T , typename U , typename = std :: enable_if_t < CanBeEqCompared < T , U > {} >> inline bool operator == ( const StatusOr < T >& l , const StatusOr < U >& r ) { return ( l . ok () && r . ok () && l . value () == r . value ()) || ( ! l . ok () && ! r . ok () && l . status () == r . status ()); } // If `T` (and `U`) can't be equality-compared, then we define StatusOr<T> to be equal iff the non-ok status // values are equal. // template < typename T , typename U , typename = std :: enable_if_t <! CanBeEqCompared < T , U > {} > , typename = void > inline bool operator == ( const StatusOr < T >& l , const StatusOr < U >& r ) { return ( ! l . ok () && ! r . ok () && l . status () == r . status ()); } template < typename T , typename U > inline bool operator != ( const StatusOr < T >& l , const StatusOr < U >& r ) { return ! ( l == r ); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- namespace detail { template < typename T > struct IsStatusOrImpl : std :: false_type { }; template < typename T > struct IsStatusOrImpl < StatusOr < T >> : std :: true_type { }; } // namespace detail template < typename T > using IsStatusOr = detail :: IsStatusOrImpl < std :: decay_t < T >> ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > struct RemoveStatusOrImpl ; template < typename T > struct RemoveStatusOrImpl < StatusOr < T >> : batt :: StaticType < T > { }; template < typename T > using RemoveStatusOr = typename RemoveStatusOrImpl < T >:: type ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - inline bool is_ok_status ( const std :: error_code & ec ) { return ! ec ; } template < typename T > bool is_ok_status ( const T & val ) { return val . ok (); } enum struct LogLevel { kFatal , kError , kWarning , kInfo , kDebug , kVerbose }; inline LogLevel & require_fail_thread_default_log_level () { thread_local LogLevel log_level_ = LogLevel :: kVerbose ; return log_level_ ; } namespace detail { class NotOkStatusWrapper { public : explicit NotOkStatusWrapper ( const char * file , int line , Status && status ) noexcept : file_ { file } , line_ { line } , status_ ( std :: move ( status )) { * this << this -> status_ << \"; \" ; } explicit NotOkStatusWrapper ( const char * file , int line , const Status & status ) noexcept : file_ { file } , line_ { line } , status_ ( status ) { #ifndef BATT_GLOG_AVAILABLE * this << \"(\" << this -> file_ << \":\" << this -> line_ << \") \" ; #endif // BATT_GLOG_AVAILALBE * this << this -> status_ << \"; \" ; } ~ NotOkStatusWrapper () noexcept { #ifdef BATT_GLOG_AVAILABLE switch ( this -> level_ ) { case LogLevel :: kFatal : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_FATAL ). stream () << this -> output_ . str (); break ; case LogLevel :: kError : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_ERROR ). stream () << this -> output_ . str (); break ; case LogLevel :: kWarning : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_WARNING ). stream () << this -> output_ . str (); break ; case LogLevel :: kInfo : :: google :: LogMessage ( this -> file_ , this -> line_ , google :: GLOG_INFO ). stream () << this -> output_ . str (); break ; case LogLevel :: kDebug : DLOG ( INFO ) << \" [\" << this -> file_ << \":\" << this -> line_ << \"] \" << this -> output_ . str (); break ; case LogLevel :: kVerbose : VLOG ( 1 ) << \" [\" << this -> file_ << \":\" << this -> line_ << \"] \" << this -> output_ . str (); break ; } #endif // BATT_GLOG_AVAILABLE } operator Status () noexcept { return std :: move ( this -> status_ ); } template < typename T > operator StatusOr < T > () noexcept { return StatusOr < T > { std :: move ( this -> status_ )}; } NotOkStatusWrapper & operator << ( LogLevel new_level ) { this -> level_ = new_level ; return * this ; } template < typename T > NotOkStatusWrapper & operator << ( T && val ) { this -> output_ << BATT_FORWARD ( val ); return * this ; } private : const char * file_ ; int line_ ; Status status_ ; LogLevel level_ { require_fail_thread_default_log_level ()}; std :: ostringstream output_ ; }; } // namespace detail //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename = std :: enable_if_t < IsStatusOr < T > {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> inline decltype ( auto ) to_status ( T && v ) { return BATT_FORWARD ( v ). status (); } template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , Status > || std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>> , typename = void > inline decltype ( auto ) to_status ( T && s ) { return BATT_FORWARD ( s ); } template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , boost :: system :: error_code > || std :: is_same_v < std :: decay_t < T > , std :: error_code >> , typename = void , typename = void > inline Status to_status ( const T & ec ) { // TODO [tastolfi 2021-10-13] support these so we don't lose information. if ( ! ec ) { return OkStatus (); } return Status { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - #define BATT_REQUIRE_OK(expr) \\ for (decltype(auto) BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__) = (expr); \\ !::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__));) \\ return ::batt::detail::NotOkStatusWrapper \\ { \\ __FILE__, __LINE__, \\ ::batt::to_status(BATT_FORWARD(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__))) \\ } #define BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr) \\ auto BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__) = statusor_expr; \\ BATT_REQUIRE_OK(BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__)); \\ lvalue_expr = std::move(*BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__)) #define BATT_OK_RESULT_OR_PANIC(expr) \\ [&](auto&& expr_value) { \\ BATT_CHECK(::batt::is_ok_status(expr_value)) \\ << BOOST_PP_STRINGIZE(expr) << \".status == \" << ::batt::to_status(expr_value); \\ return std::move(*BATT_FORWARD(expr_value)); \\ }((expr)) #define BATT_CHECK_OK(expr) \\ if (bool BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__) = true) \\ for (decltype(auto) BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__) = (expr); \\ BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__); \\ BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__) = false) \\ for (; !BATT_HINT_TRUE( \\ ::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__))) && \\ BATT_HINT_TRUE(::batt::lock_fail_check_mutex()); \\ ::batt::fail_check_exit()) \\ BATT_FAIL_CHECK_MESSAGE(\"batt::to_status(\" BOOST_PP_STRINGIZE(expr) \")\", ::batt::to_status(BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__)), \\ \"==\", \"batt::OkStatus()\", ::batt::OkStatus(), __FILE__, __LINE__, __PRETTY_FUNCTION__) inline Status status_from_errno ( int code ) { return static_cast < ErrnoValue > ( code ); } template < typename T > inline Status status_from_retval ( T retval ) { if ( retval >= 0 ) { return OkStatus (); } return status_from_errno ( errno ); } template < typename T > inline T && ok_result_or_panic ( StatusOr < T >&& result ) { BATT_CHECK ( result . ok ()) << result . status (); return std :: move ( * result ); } template < typename T , typename = std :: enable_if_t < IsStatusOr < std :: decay_t < T >> {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> std :: ostream & operator << ( std :: ostream & out , T && status_or ) { if ( ! status_or . ok ()) { return out << \"Status{\" << status_or . status () << \"}\" ; } return out << \"Ok{\" << make_printable ( * status_or ) << \"}\" ; } inline bool status_is_retryable ( const Status & s ) { return s == StatusCode :: kUnavailable // || s == static_cast < ErrnoValue > ( EAGAIN ) // || s == static_cast < ErrnoValue > ( EINTR ) // ; } //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ template < typename EnumT > inline bool Status :: register_codes ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ) { static detail :: StatusBase base ; return register_codes_internal < EnumT > ( codes ); } template < typename EnumT > inline bool Status :: register_codes_internal ( const std :: vector < std :: pair < EnumT , std :: string >>& codes ) { static bool exactly_once = [ & ]() -> bool { [ & ] { CodeGroup group ; group . enum_type_index = std :: type_index { typeid ( EnumT )}; group . index = next_group_index (); BATT_CHECK_LT ( group . index , kMaxGroups ) << \"Status::register_codes called too many times!\" ; if ( codes . empty ()) { return ; } int min_enum_value = std :: numeric_limits < int >:: max (); int max_enum_value = std :: numeric_limits < int >:: min (); Status :: value_type next_code = group . index * kGroupSize ; for ( auto & [ value , message ] : codes ) { const int enum_value = static_cast < int > ( value ); min_enum_value = std :: min ( min_enum_value , enum_value ); max_enum_value = std :: max ( max_enum_value , enum_value ); group . entries . emplace_back ( CodeEntry { next_code , enum_value , std :: move ( message ), }); next_code += 1 ; } BATT_CHECK_LE ( max_enum_value - min_enum_value , kMaxCodeNumericRange ) << \"The maximum numeric range of codes was exceeded. min_enum_value=\" << min_enum_value << \" max_enum_value=\" << max_enum_value ; group . min_enum_value = min_enum_value ; group . enum_value_to_code . resize ( max_enum_value - min_enum_value + 1 ); std :: fill ( group . enum_value_to_code . begin (), group . enum_value_to_code . end (), next_code ); for ( const CodeEntry & e : group . entries ) { group . enum_value_to_code [ e . enum_value - group . min_enum_value ] = e . code ; } // Insert an entry at the end of the group for all unknown values. // group . entries . emplace_back ( CodeEntry { next_code , max_enum_value + 1 , unknown_enum_value_message ()}); // Atomically insert the new code group. // CodeGroup & global_group = Status :: code_group_for_type_internal < EnumT > (); BATT_CHECK ( global_group . entries . empty ()) << \"A status code group may only be registered once!\" ; global_group = std :: move ( group ); /*std::array<CodeGroup*, ...>*/ auto & all_groups = Status :: registered_groups (); BATT_CHECK_LT ( global_group . index , all_groups . size ()); all_groups [ global_group . index ] = & global_group ; // Done! }(); return true ; }(); return exactly_once ; } } // namespace batt #endif // BATTERIES_STATUS_HPP #if BATT_HEADER_ONLY #include <batteries/status_impl.hpp> #endif // BATT_HEADER_ONLY Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/status__impl_8hpp/","text":"batteries/status_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_STATUS_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATUS_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_STATUS_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATUS_IMPL_HPP #define BATTERIES_STATUS_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/config.hpp> #include <utility> #include <vector> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const Status & t ) { return out << t . code () << \":\" << t . message (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool operator == ( const Status & l , const Status & r ) { return l . code () == r . code () || ( l . ok () && r . ok ()); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool operator != ( const Status & l , const Status & r ) { return ! ( l == r ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status OkStatus () { return Status {}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL detail :: StatusBase :: StatusBase () noexcept { [[ maybe_unused ]] static bool initialized = [] { Status :: register_codes_internal < StatusCode > ({ { StatusCode :: kOk , \"Ok\" }, { StatusCode :: kCancelled , \"Cancelled\" }, { StatusCode :: kUnknown , \"Unknown\" }, { StatusCode :: kInvalidArgument , \"Invalid Argument\" }, { StatusCode :: kDeadlineExceeded , \"Deadline Exceeded\" }, { StatusCode :: kNotFound , \"Not Found\" }, { StatusCode :: kAlreadyExists , \"Already Exists\" }, { StatusCode :: kPermissionDenied , \"Permission Denied\" }, { StatusCode :: kResourceExhausted , \"Resource Exhausted\" }, { StatusCode :: kFailedPrecondition , \"Failed Precondition\" }, { StatusCode :: kAborted , \"Aborted\" }, { StatusCode :: kOutOfRange , \"Out of Range\" }, { StatusCode :: kUnimplemented , \"Unimplemented\" }, { StatusCode :: kInternal , \"Internal\" }, { StatusCode :: kUnavailable , \"Unavailable\" }, { StatusCode :: kDataLoss , \"Data Loss\" }, { StatusCode :: kUnauthenticated , \"Unauthenticated\" }, // { StatusCode :: kClosed , \"Closed\" }, { StatusCode :: kGrantUnavailable , \"The requested grant count exceeds available count\" }, { StatusCode :: kLoopBreak , \"Loop break\" }, { StatusCode :: kEndOfStream , \"End of stream\" }, { StatusCode :: kClosedBeforeEndOfStream , \"The stream was closed before the end of data\" }, { StatusCode :: kGrantRevoked , \"The Grant was revoked\" }, }); std :: vector < std :: pair < ErrnoValue , std :: string >> errno_codes ; for ( int code = 0 ; code < Status :: kGroupSize ; ++ code ) { const char * msg = std :: strerror ( code ); if ( msg ) { errno_codes . emplace_back ( static_cast < ErrnoValue > ( code ), std :: string ( msg )); } else { errno_codes . emplace_back ( static_cast < ErrnoValue > ( code ), std :: string ( \"(unknown)\" )); } } return Status :: register_codes_internal < ErrnoValue > ( errno_codes ); }(); } } // namespace batt #endif // BATTERIES_STATUS_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/status_impl.hpp"},{"location":"_autogen/Files/status__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/status__impl_8hpp/#defines","text":"Name BATTERIES_STATUS_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/status__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/status__impl_8hpp/#batteries_status_impl_hpp","text":"1 #define BATTERIES_STATUS_IMPL_HPP()","title":"BATTERIES_STATUS_IMPL_HPP"},{"location":"_autogen/Files/status__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATUS_IMPL_HPP #define BATTERIES_STATUS_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/config.hpp> #include <utility> #include <vector> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: ostream & operator << ( std :: ostream & out , const Status & t ) { return out << t . code () << \":\" << t . message (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool operator == ( const Status & l , const Status & r ) { return l . code () == r . code () || ( l . ok () && r . ok ()); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool operator != ( const Status & l , const Status & r ) { return ! ( l == r ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status OkStatus () { return Status {}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL detail :: StatusBase :: StatusBase () noexcept { [[ maybe_unused ]] static bool initialized = [] { Status :: register_codes_internal < StatusCode > ({ { StatusCode :: kOk , \"Ok\" }, { StatusCode :: kCancelled , \"Cancelled\" }, { StatusCode :: kUnknown , \"Unknown\" }, { StatusCode :: kInvalidArgument , \"Invalid Argument\" }, { StatusCode :: kDeadlineExceeded , \"Deadline Exceeded\" }, { StatusCode :: kNotFound , \"Not Found\" }, { StatusCode :: kAlreadyExists , \"Already Exists\" }, { StatusCode :: kPermissionDenied , \"Permission Denied\" }, { StatusCode :: kResourceExhausted , \"Resource Exhausted\" }, { StatusCode :: kFailedPrecondition , \"Failed Precondition\" }, { StatusCode :: kAborted , \"Aborted\" }, { StatusCode :: kOutOfRange , \"Out of Range\" }, { StatusCode :: kUnimplemented , \"Unimplemented\" }, { StatusCode :: kInternal , \"Internal\" }, { StatusCode :: kUnavailable , \"Unavailable\" }, { StatusCode :: kDataLoss , \"Data Loss\" }, { StatusCode :: kUnauthenticated , \"Unauthenticated\" }, // { StatusCode :: kClosed , \"Closed\" }, { StatusCode :: kGrantUnavailable , \"The requested grant count exceeds available count\" }, { StatusCode :: kLoopBreak , \"Loop break\" }, { StatusCode :: kEndOfStream , \"End of stream\" }, { StatusCode :: kClosedBeforeEndOfStream , \"The stream was closed before the end of data\" }, { StatusCode :: kGrantRevoked , \"The Grant was revoked\" }, }); std :: vector < std :: pair < ErrnoValue , std :: string >> errno_codes ; for ( int code = 0 ; code < Status :: kGroupSize ; ++ code ) { const char * msg = std :: strerror ( code ); if ( msg ) { errno_codes . emplace_back ( static_cast < ErrnoValue > ( code ), std :: string ( msg )); } else { errno_codes . emplace_back ( static_cast < ErrnoValue > ( code ), std :: string ( \"(unknown)\" )); } } return Status :: register_codes_internal < ErrnoValue > ( errno_codes ); }(); } } // namespace batt #endif // BATTERIES_STATUS_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/status__ok_8hpp/","text":"batteries/seq/status_ok.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::StatusOk struct batt::seq::StatusOkBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_STATUS_OK_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_STATUS_OK_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_STATUS_OK_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_STATUS_OK_HPP #define BATTERIES_SEQ_STATUS_OK_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { template < typename SeqT > class StatusOk { public : using Item = std :: decay_t < RemoveStatusOr < SeqItem < SeqT >>> ; template < typename ... Args , typename = batt :: EnableIfNoShadow < StatusOk , Args ... >> explicit StatusOk ( Args && ... args ) noexcept : seq_ ( BATT_FORWARD ( args )...) { } bool ok () const { return this -> status_ . ok (); } const Status & status () const & { return this -> status_ ; } Status status () && { return std :: move ( this -> status_ ); } Optional < Item > peek () { return this -> unwrap_item ( this -> seq_ . peek ()); } Optional < Item > next () { return this -> unwrap_item ( this -> seq_ . next ()); } private : Optional < Item > unwrap_item ( Optional < SeqItem < SeqT >>&& item ) { if ( ! item ) { return None ; } if ( ! item -> ok ()) { this -> status_ . Update ( item -> status ()); return None ; } return ** item ; } SeqT seq_ ; Status status_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - struct StatusOkBinder { }; inline auto status_ok () { return StatusOkBinder {}; } template < typename SeqT > inline StatusOk < SeqT > operator | ( SeqT && seq , StatusOkBinder ) { static_assert ( std :: is_same_v < SeqT , std :: decay_t < SeqT >> , \"status_ok() must not be used with an lvalue reference\" ); return StatusOk < SeqT > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_STATUS_OK_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/status_ok.hpp"},{"location":"_autogen/Files/status__ok_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/status__ok_8hpp/#classes","text":"Name class batt::seq::StatusOk struct batt::seq::StatusOkBinder","title":"Classes"},{"location":"_autogen/Files/status__ok_8hpp/#defines","text":"Name BATTERIES_SEQ_STATUS_OK_HPP","title":"Defines"},{"location":"_autogen/Files/status__ok_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/status__ok_8hpp/#batteries_seq_status_ok_hpp","text":"1 #define BATTERIES_SEQ_STATUS_OK_HPP()","title":"BATTERIES_SEQ_STATUS_OK_HPP"},{"location":"_autogen/Files/status__ok_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_STATUS_OK_HPP #define BATTERIES_SEQ_STATUS_OK_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { template < typename SeqT > class StatusOk { public : using Item = std :: decay_t < RemoveStatusOr < SeqItem < SeqT >>> ; template < typename ... Args , typename = batt :: EnableIfNoShadow < StatusOk , Args ... >> explicit StatusOk ( Args && ... args ) noexcept : seq_ ( BATT_FORWARD ( args )...) { } bool ok () const { return this -> status_ . ok (); } const Status & status () const & { return this -> status_ ; } Status status () && { return std :: move ( this -> status_ ); } Optional < Item > peek () { return this -> unwrap_item ( this -> seq_ . peek ()); } Optional < Item > next () { return this -> unwrap_item ( this -> seq_ . next ()); } private : Optional < Item > unwrap_item ( Optional < SeqItem < SeqT >>&& item ) { if ( ! item ) { return None ; } if ( ! item -> ok ()) { this -> status_ . Update ( item -> status ()); return None ; } return ** item ; } SeqT seq_ ; Status status_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - struct StatusOkBinder { }; inline auto status_ok () { return StatusOkBinder {}; } template < typename SeqT > inline StatusOk < SeqT > operator | ( SeqT && seq , StatusOkBinder ) { static_assert ( std :: is_same_v < SeqT , std :: decay_t < SeqT >> , \"status_ok() must not be used with an lvalue reference\" ); return StatusOk < SeqT > { BATT_FORWARD ( seq )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_STATUS_OK_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/","text":"batteries/state_machine_model/stochastic_model_checker.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::StochasticModelChecker Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP #define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP #include <batteries/config.hpp> // #include <batteries/state_machine_model/parallel_model_check_state.hpp> #include <batteries/state_machine_model/verbose.hpp> #include <chrono> #include <random> namespace batt { template < typename ModelT > class StochasticModelChecker { public : using Branch = typename ModelT :: Branch ; using BranchDelta = typename Branch :: delta_type ; using VisitResult = typename ModelT :: VisitResult ; explicit StochasticModelChecker ( typename ModelT :: Base & model , detail :: ParallelModelCheckState < Branch >& mesh , usize shard_i ) noexcept : model_ { model } , n_shards_ { mesh . shard_count } , shard_i_ { shard_i } , starting_seed_ { model . advanced_options (). starting_seed . value_or ( shard_i )} { this -> model_ . set_entropy ( StateMachineEntropySource {[ this ]( usize min_value , usize max_value ) -> usize { if ( min_value == max_value ) { return min_value ; } BATT_CHECK_LT ( min_value , max_value ); std :: uniform_int_distribution < usize > pick_random_value { min_value , max_value }; const usize value = pick_random_value ( this -> rng_ ); const usize radix = max_value - min_value + 1 ; this -> branch_delta_ . push ( radix , value - min_value ); return value ; }}); } ~ StochasticModelChecker () noexcept { } StateMachineResult run () { auto start_time = std :: chrono :: steady_clock :: now (); const i64 min_running_time_ms = this -> model_ . advanced_options (). min_running_time_ms ; auto running_time_sufficient = [ & ] { const auto elapsed_ms = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( std :: chrono :: steady_clock :: now () - start_time ) . count (); BATT_STATE_MACHINE_VERBOSE () << BATT_INSPECT ( elapsed_ms ); return elapsed_ms >= min_running_time_ms ; }; usize seed = this -> starting_seed_ ; this -> rng_ . seed ( seed ); StateMachineResult result ; result . start_time = start_time ; result . ok = true ; const auto initial_state = this -> model_ . normalize ( this -> model_ . initialize ()); auto current_state = initial_state ; this -> model_ . visit ( initial_state , /*src_branch=*/ Branch { . snapshot = initial_state , . delta = BranchDelta {}, }); result . state_count += 1 ; // We keep exploring random states until we reach the minimum time limit. // while ( ! running_time_sufficient ()) { // Tell the model we are entering the current state. // this -> model_ . enter_state ( current_state ); this -> branch_delta_ = BranchDelta {}; BATT_CHECK ( this -> branch_delta_ . empty ()); // Step the model. // this -> model_ . step (); // Make sure invariants are OK. // if ( ! this -> model_ . check_invariants ()) { result . seed = seed ; result . ok = false ; break ; } // Retrieve the next state. // const auto next_state = this -> model_ . normalize ( this -> model_ . leave_state ()); // If this state is novel, record that fact. // if ( this -> model_ . visit ( next_state , /*src_branch=*/ Branch { . snapshot = current_state , . delta = this -> branch_delta_ , }) == VisitResult :: kFirstTime ) { BATT_STATE_MACHINE_VERBOSE () << BATT_INSPECT ( this -> n_shards_ ) << BATT_INSPECT ( min_running_time_ms ) << BATT_INSPECT ( seed ) << BATT_INSPECT ( make_printable ( next_state )); result . state_count += 1 ; } // If the current state is terminal (i.e., the branch delta is empty), then go back to the initial // state and continue with a new seed value. // const bool terminal_state_reached = ( this -> branch_delta_ == BranchDelta {}) || ( current_state == next_state ); BATT_CHECK_EQ ( this -> branch_delta_ == BranchDelta {}, this -> branch_delta_ . empty ()); BATT_CHECK_IMPLIES ( this -> branch_delta_ . empty (), current_state == next_state ) << BATT_INSPECT ( make_printable ( next_state )) << BATT_INSPECT ( make_printable ( current_state )); if ( terminal_state_reached ) { current_state = initial_state ; seed += this -> n_shards_ ; this -> rng_ . seed ( seed ); } else { current_state = next_state ; result . branch_push_count += 1 ; result . branch_pop_count += 1 ; result . self_branch_count += 1 ; } } result . update_elapsed_time (); return result ; } private : typename ModelT :: Base & model_ ; usize n_shards_ ; usize shard_i_ ; usize starting_seed_ ; BranchDelta branch_delta_ ; std :: default_random_engine rng_ { this -> shard_i_ }; }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/stochastic_model_checker.hpp"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#classes","text":"Name class batt::StochasticModelChecker","title":"Classes"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP","title":"Defines"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#batteries_state_machine_model_stochastic_model_checker_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP #define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP #include <batteries/config.hpp> // #include <batteries/state_machine_model/parallel_model_check_state.hpp> #include <batteries/state_machine_model/verbose.hpp> #include <chrono> #include <random> namespace batt { template < typename ModelT > class StochasticModelChecker { public : using Branch = typename ModelT :: Branch ; using BranchDelta = typename Branch :: delta_type ; using VisitResult = typename ModelT :: VisitResult ; explicit StochasticModelChecker ( typename ModelT :: Base & model , detail :: ParallelModelCheckState < Branch >& mesh , usize shard_i ) noexcept : model_ { model } , n_shards_ { mesh . shard_count } , shard_i_ { shard_i } , starting_seed_ { model . advanced_options (). starting_seed . value_or ( shard_i )} { this -> model_ . set_entropy ( StateMachineEntropySource {[ this ]( usize min_value , usize max_value ) -> usize { if ( min_value == max_value ) { return min_value ; } BATT_CHECK_LT ( min_value , max_value ); std :: uniform_int_distribution < usize > pick_random_value { min_value , max_value }; const usize value = pick_random_value ( this -> rng_ ); const usize radix = max_value - min_value + 1 ; this -> branch_delta_ . push ( radix , value - min_value ); return value ; }}); } ~ StochasticModelChecker () noexcept { } StateMachineResult run () { auto start_time = std :: chrono :: steady_clock :: now (); const i64 min_running_time_ms = this -> model_ . advanced_options (). min_running_time_ms ; auto running_time_sufficient = [ & ] { const auto elapsed_ms = std :: chrono :: duration_cast < std :: chrono :: milliseconds > ( std :: chrono :: steady_clock :: now () - start_time ) . count (); BATT_STATE_MACHINE_VERBOSE () << BATT_INSPECT ( elapsed_ms ); return elapsed_ms >= min_running_time_ms ; }; usize seed = this -> starting_seed_ ; this -> rng_ . seed ( seed ); StateMachineResult result ; result . start_time = start_time ; result . ok = true ; const auto initial_state = this -> model_ . normalize ( this -> model_ . initialize ()); auto current_state = initial_state ; this -> model_ . visit ( initial_state , /*src_branch=*/ Branch { . snapshot = initial_state , . delta = BranchDelta {}, }); result . state_count += 1 ; // We keep exploring random states until we reach the minimum time limit. // while ( ! running_time_sufficient ()) { // Tell the model we are entering the current state. // this -> model_ . enter_state ( current_state ); this -> branch_delta_ = BranchDelta {}; BATT_CHECK ( this -> branch_delta_ . empty ()); // Step the model. // this -> model_ . step (); // Make sure invariants are OK. // if ( ! this -> model_ . check_invariants ()) { result . seed = seed ; result . ok = false ; break ; } // Retrieve the next state. // const auto next_state = this -> model_ . normalize ( this -> model_ . leave_state ()); // If this state is novel, record that fact. // if ( this -> model_ . visit ( next_state , /*src_branch=*/ Branch { . snapshot = current_state , . delta = this -> branch_delta_ , }) == VisitResult :: kFirstTime ) { BATT_STATE_MACHINE_VERBOSE () << BATT_INSPECT ( this -> n_shards_ ) << BATT_INSPECT ( min_running_time_ms ) << BATT_INSPECT ( seed ) << BATT_INSPECT ( make_printable ( next_state )); result . state_count += 1 ; } // If the current state is terminal (i.e., the branch delta is empty), then go back to the initial // state and continue with a new seed value. // const bool terminal_state_reached = ( this -> branch_delta_ == BranchDelta {}) || ( current_state == next_state ); BATT_CHECK_EQ ( this -> branch_delta_ == BranchDelta {}, this -> branch_delta_ . empty ()); BATT_CHECK_IMPLIES ( this -> branch_delta_ . empty (), current_state == next_state ) << BATT_INSPECT ( make_printable ( next_state )) << BATT_INSPECT ( make_printable ( current_state )); if ( terminal_state_reached ) { current_state = initial_state ; seed += this -> n_shards_ ; this -> rng_ . seed ( seed ); } else { current_state = next_state ; result . branch_push_count += 1 ; result . branch_pop_count += 1 ; result . self_branch_count += 1 ; } } result . update_elapsed_time (); return result ; } private : typename ModelT :: Base & model_ ; usize n_shards_ ; usize shard_i_ ; usize starting_seed_ ; BranchDelta branch_delta_ ; std :: default_random_engine rng_ { this -> shard_i_ }; }; } // namespace batt #endif // BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/stream__buffer_8hpp/","text":"batteries/async/stream_buffer.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::StreamBuffer Defines \ud83d\udd17 Name BATTERIES_ASYNC_STREAM_BUFFER_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_STREAM_BUFFER_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_STREAM_BUFFER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_STREAM_BUFFER_HPP #define BATTERIES_ASYNC_STREAM_BUFFER_HPP #include <batteries/config.hpp> // #include <batteries/async/io_result.hpp> #include <batteries/async/types.hpp> #include <batteries/async/watch.hpp> #include <batteries/assert.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/finally.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #include <boost/asio/system_executor.hpp> #include <functional> #include <memory> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class StreamBuffer { public : static constexpr usize kTempBufferSize = 512 ; using executor_type = boost :: asio :: any_io_executor ; // Creates a new stream buffer large enough to hold `capacity` bytes of data. // explicit StreamBuffer ( usize capacity ) noexcept ; // Calls `this->close()`. // ~ StreamBuffer () noexcept ; // The maximum number of bytes that this buffer can hold. // usize capacity () const ; // The current number of bytes available as consumable data. // usize size () const ; // The current number of bytes available as committable buffer space. // usize space () const ; // The executor associated with this stream buffer. // executor_type get_executor () const { return this -> executor_ ; } // Returns a MutableBufferSequence that is exactly `exact_count` bytes large. // // This method may block the current task if buffer space is not available to satisfy the request. It // will unblock once enough data has been trimmed from the buffer via `consume()`, or if this object is // closed for reading. // // If an `exact_count` that exceeds `this->capacity()` is passed, then this method will immediately return // a StatusCode::kInvalidArgument result. // StatusOr < SmallVec < MutableBuffer , 2 >> prepare_exactly ( i64 exact_count ); // Like `prepare_exactly`, except that this method will return as soon as `this->space()` is at least // `min_count` bytes, and the returned MutableBufferSequence will be as large as possible. // StatusOr < SmallVec < MutableBuffer , 2 >> prepare_at_least ( i64 min_count ); // Invokes the passed handler with a MutableBufferSequence as soon as at least `min_count` free bytes can // be allocated within the buffer. // template < typename Handler = void ( const ErrorCode & ec , SmallVec < MutableBuffer , 2 > ) > void async_prepare_at_least ( i64 min_count , Handler && handler ); // Logically transfer `count` bytes of data from the \"prepared\" region of the buffer to the \"committed\" // region, by advancing the commit offset pointer. This method does not literally copy data. Behavior is // undefined if `count > this->space()`. // void commit ( i64 count ); // Prepare enough space in the buffer to make a byte-for-byte copy of `value` in the buffer, copy the // value, and do the equivalent of `this->commit(sizeof(T))`. `T` must be safe to copy via `memcpy`, // otherwise behavior is undefined. // template < typename T > Status write_type ( StaticType < T > , const T & value ); // Copy at least 1 byte of the passed data to the buffer and then invoke the handler with the number of // bytes written. // template < typename ConstBuffers , typename Handler = void ( const ErrorCode & ec , usize n_bytes_written ) > void async_write_some ( ConstBuffers && buffers , Handler && handler ); // Convenience shortcut for `prepare_exactly`, copy the data, then `commit`. // Status write_all ( ConstBuffer buffer ); // Unblocks any current and future calls to `fetch_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be // written/committed. // void close_for_write (); // Returns a ConstBufferSequence containing at least `min_count` bytes of data. // // This method may block the current task if there isn't enough committed data in the buffer to satisfy // the request (i.e., if `this->size() < min_count`). // // If `min_count` that exceeds `this->capacity()` is passed, then this method will immediately return // a StatusCode::kInvalidArgument result. // StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ); // Frees the specified number of bytes at the beginning of the \"committed\" region of the buffer, making // that buffer space available for current or future calls to `prepare_exactly` or `prepare_at_least`. // void consume ( i64 count ); // Returns the next sizeof(T) bytes of the stream as a reference to `const T`. If the stream forces T to // be split over the end of the buffer, then a reference to a copy of the data is returned. The // referenced data is valid until the next call to `fetch_type` or `consume`. // template < typename T > StatusOr < std :: reference_wrapper < const T >> fetch_type ( StaticType < T > = {}); // Consumes sizeof(T) bytes from the stream. // template < typename T > void consume_type ( StaticType < T > = {}); // Reads and returns a single value of type T from the stream, copying byte-for-byte as if by memcpy. // // Behavior is undefined if it is unsafe to copy values of type T in this manner. // template < typename T > StatusOr < T > read_type ( StaticType < T > = {}); // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be read/consumed. // void close_for_read (); // Shortcut for `this->close_for_read()` and `this->close_for_write()`. // void close (); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - private : //+++++++++++-+-+--+----- --- -- - - - - template < typename BufferType > SmallVec < BufferType , 2 > get_buffers ( i64 offset , i64 count , StaticType < BufferType > buffer_type = {}); template < typename BufferType , typename GetMaxCount > StatusOr < SmallVec < BufferType , 2 >> pre_transfer ( i64 min_count , Watch < i64 >& fixed_pos , Watch < i64 >& moving_pos , i64 min_delta , const GetMaxCount & get_max_count , WaitForResource wait_for_resource , StaticType < BufferType > buffer_type = {}, i64 * moving_pos_observed = nullptr ); //+++++++++++-+-+--+----- --- -- - - - - executor_type executor_ = boost :: asio :: system_executor (); // The size in bytes of the array pointed to by `buffer_`. // i64 capacity_ ; // Points to the buffer for this object. // std :: unique_ptr < u8 [] > buffer_ ; // A temporary buffer so that we can make sure the first buffer always holds at least the min_count. // SmallVec < u8 , kTempBufferSize > tmp_buffer_ ; // The offset from the beginning of the stream that represents the upper bound of read data. This value // increases monotonically beyond `this->capacity_`; the implementation must find the true consume // position within the buffer by taking this value modulo `this->capacity_`. // Watch < i64 > consume_pos_ ; // The offset from the beginning of the stream that represents the upper bound of written data. This // value increases monotonically beyond `this->capacity_`; the implementation must find the true commit // position within the buffer by taking this value modulo `this->capacity_`. // Watch < i64 > commit_pos_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > StatusOr < std :: reference_wrapper < StreamBuffer >> operator << ( StatusOr < std :: reference_wrapper < StreamBuffer >> stream_buffer , T && obj ); } // namespace batt #endif // BATTERIES_ASYNC_STREAM_BUFFER_HPP #if BATT_HEADER_ONLY #include <batteries/async/stream_buffer_impl.hpp> #endif #include <batteries/async/stream_buffer.ipp> Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/stream_buffer.hpp"},{"location":"_autogen/Files/stream__buffer_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/stream__buffer_8hpp/#classes","text":"Name class batt::StreamBuffer","title":"Classes"},{"location":"_autogen/Files/stream__buffer_8hpp/#defines","text":"Name BATTERIES_ASYNC_STREAM_BUFFER_HPP","title":"Defines"},{"location":"_autogen/Files/stream__buffer_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/stream__buffer_8hpp/#batteries_async_stream_buffer_hpp","text":"1 #define BATTERIES_ASYNC_STREAM_BUFFER_HPP()","title":"BATTERIES_ASYNC_STREAM_BUFFER_HPP"},{"location":"_autogen/Files/stream__buffer_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_STREAM_BUFFER_HPP #define BATTERIES_ASYNC_STREAM_BUFFER_HPP #include <batteries/config.hpp> // #include <batteries/async/io_result.hpp> #include <batteries/async/types.hpp> #include <batteries/async/watch.hpp> #include <batteries/assert.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/finally.hpp> #include <batteries/int_types.hpp> #include <batteries/small_vec.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #include <boost/asio/system_executor.hpp> #include <functional> #include <memory> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class StreamBuffer { public : static constexpr usize kTempBufferSize = 512 ; using executor_type = boost :: asio :: any_io_executor ; // Creates a new stream buffer large enough to hold `capacity` bytes of data. // explicit StreamBuffer ( usize capacity ) noexcept ; // Calls `this->close()`. // ~ StreamBuffer () noexcept ; // The maximum number of bytes that this buffer can hold. // usize capacity () const ; // The current number of bytes available as consumable data. // usize size () const ; // The current number of bytes available as committable buffer space. // usize space () const ; // The executor associated with this stream buffer. // executor_type get_executor () const { return this -> executor_ ; } // Returns a MutableBufferSequence that is exactly `exact_count` bytes large. // // This method may block the current task if buffer space is not available to satisfy the request. It // will unblock once enough data has been trimmed from the buffer via `consume()`, or if this object is // closed for reading. // // If an `exact_count` that exceeds `this->capacity()` is passed, then this method will immediately return // a StatusCode::kInvalidArgument result. // StatusOr < SmallVec < MutableBuffer , 2 >> prepare_exactly ( i64 exact_count ); // Like `prepare_exactly`, except that this method will return as soon as `this->space()` is at least // `min_count` bytes, and the returned MutableBufferSequence will be as large as possible. // StatusOr < SmallVec < MutableBuffer , 2 >> prepare_at_least ( i64 min_count ); // Invokes the passed handler with a MutableBufferSequence as soon as at least `min_count` free bytes can // be allocated within the buffer. // template < typename Handler = void ( const ErrorCode & ec , SmallVec < MutableBuffer , 2 > ) > void async_prepare_at_least ( i64 min_count , Handler && handler ); // Logically transfer `count` bytes of data from the \"prepared\" region of the buffer to the \"committed\" // region, by advancing the commit offset pointer. This method does not literally copy data. Behavior is // undefined if `count > this->space()`. // void commit ( i64 count ); // Prepare enough space in the buffer to make a byte-for-byte copy of `value` in the buffer, copy the // value, and do the equivalent of `this->commit(sizeof(T))`. `T` must be safe to copy via `memcpy`, // otherwise behavior is undefined. // template < typename T > Status write_type ( StaticType < T > , const T & value ); // Copy at least 1 byte of the passed data to the buffer and then invoke the handler with the number of // bytes written. // template < typename ConstBuffers , typename Handler = void ( const ErrorCode & ec , usize n_bytes_written ) > void async_write_some ( ConstBuffers && buffers , Handler && handler ); // Convenience shortcut for `prepare_exactly`, copy the data, then `commit`. // Status write_all ( ConstBuffer buffer ); // Unblocks any current and future calls to `fetch_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be // written/committed. // void close_for_write (); // Returns a ConstBufferSequence containing at least `min_count` bytes of data. // // This method may block the current task if there isn't enough committed data in the buffer to satisfy // the request (i.e., if `this->size() < min_count`). // // If `min_count` that exceeds `this->capacity()` is passed, then this method will immediately return // a StatusCode::kInvalidArgument result. // StatusOr < SmallVec < ConstBuffer , 2 >> fetch_at_least ( i64 min_count ); // Frees the specified number of bytes at the beginning of the \"committed\" region of the buffer, making // that buffer space available for current or future calls to `prepare_exactly` or `prepare_at_least`. // void consume ( i64 count ); // Returns the next sizeof(T) bytes of the stream as a reference to `const T`. If the stream forces T to // be split over the end of the buffer, then a reference to a copy of the data is returned. The // referenced data is valid until the next call to `fetch_type` or `consume`. // template < typename T > StatusOr < std :: reference_wrapper < const T >> fetch_type ( StaticType < T > = {}); // Consumes sizeof(T) bytes from the stream. // template < typename T > void consume_type ( StaticType < T > = {}); // Reads and returns a single value of type T from the stream, copying byte-for-byte as if by memcpy. // // Behavior is undefined if it is unsafe to copy values of type T in this manner. // template < typename T > StatusOr < T > read_type ( StaticType < T > = {}); // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods). This // signals to the buffer (and all other clients of this object) that no more data will be read/consumed. // void close_for_read (); // Shortcut for `this->close_for_read()` and `this->close_for_write()`. // void close (); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - private : //+++++++++++-+-+--+----- --- -- - - - - template < typename BufferType > SmallVec < BufferType , 2 > get_buffers ( i64 offset , i64 count , StaticType < BufferType > buffer_type = {}); template < typename BufferType , typename GetMaxCount > StatusOr < SmallVec < BufferType , 2 >> pre_transfer ( i64 min_count , Watch < i64 >& fixed_pos , Watch < i64 >& moving_pos , i64 min_delta , const GetMaxCount & get_max_count , WaitForResource wait_for_resource , StaticType < BufferType > buffer_type = {}, i64 * moving_pos_observed = nullptr ); //+++++++++++-+-+--+----- --- -- - - - - executor_type executor_ = boost :: asio :: system_executor (); // The size in bytes of the array pointed to by `buffer_`. // i64 capacity_ ; // Points to the buffer for this object. // std :: unique_ptr < u8 [] > buffer_ ; // A temporary buffer so that we can make sure the first buffer always holds at least the min_count. // SmallVec < u8 , kTempBufferSize > tmp_buffer_ ; // The offset from the beginning of the stream that represents the upper bound of read data. This value // increases monotonically beyond `this->capacity_`; the implementation must find the true consume // position within the buffer by taking this value modulo `this->capacity_`. // Watch < i64 > consume_pos_ ; // The offset from the beginning of the stream that represents the upper bound of written data. This // value increases monotonically beyond `this->capacity_`; the implementation must find the true commit // position within the buffer by taking this value modulo `this->capacity_`. // Watch < i64 > commit_pos_ ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > StatusOr < std :: reference_wrapper < StreamBuffer >> operator << ( StatusOr < std :: reference_wrapper < StreamBuffer >> stream_buffer , T && obj ); } // namespace batt #endif // BATTERIES_ASYNC_STREAM_BUFFER_HPP #if BATT_HEADER_ONLY #include <batteries/async/stream_buffer_impl.hpp> #endif #include <batteries/async/stream_buffer.ipp> Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/","text":"batteries/async/stream_buffer_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP #define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP #include <batteries/config.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ StreamBuffer::StreamBuffer ( usize capacity ) noexcept : capacity_ { BATT_CHECKED_CAST ( i64 , capacity )} , buffer_ { new u8 [ capacity ]} , consume_pos_ { 0 } , commit_pos_ { 0 } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StreamBuffer ::~ StreamBuffer () noexcept { this -> close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize StreamBuffer :: capacity () const { return static_cast < usize > ( this -> capacity_ ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize StreamBuffer :: size () const { return BATT_CHECKED_CAST ( usize , this -> commit_pos_ . get_value () - this -> consume_pos_ . get_value ()); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize StreamBuffer :: space () const { return this -> capacity () - this -> size (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < MutableBuffer , 2 >> StreamBuffer :: prepare_exactly ( i64 exact_count ) { return this -> pre_transfer ( /*min_count=*/ exact_count , /*fixed_pos=*/ this -> commit_pos_ , /*moving_pos=*/ this -> consume_pos_ , /*min_delta=*/ exact_count - this -> capacity (), /*get_max_count=*/ [ exact_count ] { return exact_count ; }, WaitForResource :: kTrue , // StaticType < MutableBuffer > {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < MutableBuffer , 2 >> StreamBuffer :: prepare_at_least ( i64 min_count ) { return this -> pre_transfer ( /*min_count=*/ min_count , /*fixed_pos=*/ this -> commit_pos_ , /*moving_pos=*/ this -> consume_pos_ , /*min_delta=*/ min_count - this -> capacity (), /*get_max_count=*/ [ this ] { return BATT_CHECKED_CAST ( i64 , this -> space ()); }, WaitForResource :: kTrue , // StaticType < MutableBuffer > {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: commit ( i64 count ) { this -> commit_pos_ . fetch_add ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status StreamBuffer :: write_all ( ConstBuffer buffer ) { while ( buffer . size () > 0 ) { StatusOr < SmallVec < MutableBuffer , 2 >> prepared = this -> prepare_at_least ( 1 ); BATT_REQUIRE_OK ( prepared ); const usize n_copied = boost :: asio :: buffer_copy ( * prepared , buffer ); this -> commit ( n_copied ); buffer += n_copied ; } return OkStatus (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: close_for_write () { this -> commit_pos_ . close ( StatusCode :: kEndOfStream ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < ConstBuffer , 2 >> StreamBuffer :: fetch_at_least ( i64 min_count ) { const usize min_count_z = BATT_CHECKED_CAST ( usize , min_count ); StatusOr < SmallVec < ConstBuffer , 2 >> buffers = this -> pre_transfer ( /*min_count=*/ min_count , /*fixed_pos=*/ this -> consume_pos_ , /*moving_pos=*/ this -> commit_pos_ , /*min_delta=*/ min_count , /*get_max_count=*/ [ this ] { return BATT_CHECKED_CAST ( i64 , this -> size ()); }, WaitForResource :: kTrue , // StaticType < ConstBuffer > {}); BATT_REQUIRE_OK ( buffers ); // Guarantee that the first buffer contains at least `min_count` bytes. This is done so that retry-style // parsers don't have to implement this themselves. // if ( buffers -> size () > 1 && buffers -> front (). size () < min_count_z ) { this -> tmp_buffer_ . reserve ( min_count_z ); const usize n_copied = boost :: asio :: buffer_copy ( MutableBuffer { this -> tmp_buffer_ . data (), min_count_z }, * buffers ); BATT_CHECK_EQ ( n_copied , min_count_z ); BATT_CHECK_EQ ( buffers -> size (), 2u ); buffers -> back () += min_count - buffers -> front (). size (); if ( buffers -> back (). size () == 0 ) { buffers -> pop_back (); } buffers -> front () = ConstBuffer { this -> tmp_buffer_ . data (), n_copied }; } return buffers ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: consume ( i64 count ) { this -> consume_pos_ . fetch_add ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: close_for_read () { this -> consume_pos_ . close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: close () { this -> close_for_read (); this -> close_for_write (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename BufferType > SmallVec < BufferType , 2 > StreamBuffer :: get_buffers ( i64 offset , i64 count , StaticType < BufferType > ) { BATT_CHECK_GE ( offset , 0 ); u8 * const buffer_begin = this -> buffer_ . get (); u8 * const buffer_end = buffer_begin + this -> capacity_ ; u8 * const first_begin = buffer_begin + ( offset % this -> capacity_ ); BATT_CHECK_LT ( first_begin , buffer_end ); const i64 first_to_end = buffer_end - first_begin ; if ( count <= first_to_end ) { return { BufferType { first_begin , BATT_CHECKED_CAST ( usize , count )}, }; } else { return { BufferType { first_begin , BATT_CHECKED_CAST ( usize , first_to_end )}, BufferType { buffer_begin , BATT_CHECKED_CAST ( usize , count - first_to_end )}, }; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename BufferType , typename GetMaxCount > StatusOr < SmallVec < BufferType , 2 >> StreamBuffer :: pre_transfer ( i64 min_count , Watch < i64 >& fixed_pos , Watch < i64 >& moving_pos , i64 min_delta , const GetMaxCount & get_max_count , WaitForResource wait_for_resource , StaticType < BufferType > buffer_type , i64 * moving_pos_observed ) { if ( min_count > this -> capacity_ ) { return { StatusCode :: kInvalidArgument }; } const i64 min_target = fixed_pos . get_value () + min_delta ; if ( wait_for_resource == WaitForResource :: kFalse ) { i64 tmp = 0 ; if ( BATT_HINT_FALSE ( moving_pos_observed == nullptr )) { moving_pos_observed = & tmp ; } * moving_pos_observed = moving_pos . get_value (); if ( * moving_pos_observed < min_target ) { return { StatusCode :: kUnavailable }; } } else { const StatusOr < i64 > result = moving_pos . await_true ([ min_target ]( i64 observed ) { // return observed >= min_target ; }); if ( ! result . ok ()) { if ( result . status () != StatusCode :: kEndOfStream || moving_pos . get_value () < min_target ) { return result . status (); } } if ( BATT_HINT_FALSE ( moving_pos_observed != nullptr )) { * moving_pos_observed = * result ; } } return this -> get_buffers ( fixed_pos . get_value (), get_max_count (), buffer_type ); } } // namespace batt #endif // BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/stream_buffer_impl.hpp"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#batteries_async_stream_buffer_impl_hpp","text":"1 #define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP()","title":"BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP #define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP #include <batteries/config.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*explicit*/ StreamBuffer::StreamBuffer ( usize capacity ) noexcept : capacity_ { BATT_CHECKED_CAST ( i64 , capacity )} , buffer_ { new u8 [ capacity ]} , consume_pos_ { 0 } , commit_pos_ { 0 } { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StreamBuffer ::~ StreamBuffer () noexcept { this -> close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize StreamBuffer :: capacity () const { return static_cast < usize > ( this -> capacity_ ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize StreamBuffer :: size () const { return BATT_CHECKED_CAST ( usize , this -> commit_pos_ . get_value () - this -> consume_pos_ . get_value ()); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize StreamBuffer :: space () const { return this -> capacity () - this -> size (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < MutableBuffer , 2 >> StreamBuffer :: prepare_exactly ( i64 exact_count ) { return this -> pre_transfer ( /*min_count=*/ exact_count , /*fixed_pos=*/ this -> commit_pos_ , /*moving_pos=*/ this -> consume_pos_ , /*min_delta=*/ exact_count - this -> capacity (), /*get_max_count=*/ [ exact_count ] { return exact_count ; }, WaitForResource :: kTrue , // StaticType < MutableBuffer > {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < MutableBuffer , 2 >> StreamBuffer :: prepare_at_least ( i64 min_count ) { return this -> pre_transfer ( /*min_count=*/ min_count , /*fixed_pos=*/ this -> commit_pos_ , /*moving_pos=*/ this -> consume_pos_ , /*min_delta=*/ min_count - this -> capacity (), /*get_max_count=*/ [ this ] { return BATT_CHECKED_CAST ( i64 , this -> space ()); }, WaitForResource :: kTrue , // StaticType < MutableBuffer > {}); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: commit ( i64 count ) { this -> commit_pos_ . fetch_add ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Status StreamBuffer :: write_all ( ConstBuffer buffer ) { while ( buffer . size () > 0 ) { StatusOr < SmallVec < MutableBuffer , 2 >> prepared = this -> prepare_at_least ( 1 ); BATT_REQUIRE_OK ( prepared ); const usize n_copied = boost :: asio :: buffer_copy ( * prepared , buffer ); this -> commit ( n_copied ); buffer += n_copied ; } return OkStatus (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: close_for_write () { this -> commit_pos_ . close ( StatusCode :: kEndOfStream ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL StatusOr < SmallVec < ConstBuffer , 2 >> StreamBuffer :: fetch_at_least ( i64 min_count ) { const usize min_count_z = BATT_CHECKED_CAST ( usize , min_count ); StatusOr < SmallVec < ConstBuffer , 2 >> buffers = this -> pre_transfer ( /*min_count=*/ min_count , /*fixed_pos=*/ this -> consume_pos_ , /*moving_pos=*/ this -> commit_pos_ , /*min_delta=*/ min_count , /*get_max_count=*/ [ this ] { return BATT_CHECKED_CAST ( i64 , this -> size ()); }, WaitForResource :: kTrue , // StaticType < ConstBuffer > {}); BATT_REQUIRE_OK ( buffers ); // Guarantee that the first buffer contains at least `min_count` bytes. This is done so that retry-style // parsers don't have to implement this themselves. // if ( buffers -> size () > 1 && buffers -> front (). size () < min_count_z ) { this -> tmp_buffer_ . reserve ( min_count_z ); const usize n_copied = boost :: asio :: buffer_copy ( MutableBuffer { this -> tmp_buffer_ . data (), min_count_z }, * buffers ); BATT_CHECK_EQ ( n_copied , min_count_z ); BATT_CHECK_EQ ( buffers -> size (), 2u ); buffers -> back () += min_count - buffers -> front (). size (); if ( buffers -> back (). size () == 0 ) { buffers -> pop_back (); } buffers -> front () = ConstBuffer { this -> tmp_buffer_ . data (), n_copied }; } return buffers ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: consume ( i64 count ) { this -> consume_pos_ . fetch_add ( count ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: close_for_read () { this -> consume_pos_ . close (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void StreamBuffer :: close () { this -> close_for_read (); this -> close_for_write (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename BufferType > SmallVec < BufferType , 2 > StreamBuffer :: get_buffers ( i64 offset , i64 count , StaticType < BufferType > ) { BATT_CHECK_GE ( offset , 0 ); u8 * const buffer_begin = this -> buffer_ . get (); u8 * const buffer_end = buffer_begin + this -> capacity_ ; u8 * const first_begin = buffer_begin + ( offset % this -> capacity_ ); BATT_CHECK_LT ( first_begin , buffer_end ); const i64 first_to_end = buffer_end - first_begin ; if ( count <= first_to_end ) { return { BufferType { first_begin , BATT_CHECKED_CAST ( usize , count )}, }; } else { return { BufferType { first_begin , BATT_CHECKED_CAST ( usize , first_to_end )}, BufferType { buffer_begin , BATT_CHECKED_CAST ( usize , count - first_to_end )}, }; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename BufferType , typename GetMaxCount > StatusOr < SmallVec < BufferType , 2 >> StreamBuffer :: pre_transfer ( i64 min_count , Watch < i64 >& fixed_pos , Watch < i64 >& moving_pos , i64 min_delta , const GetMaxCount & get_max_count , WaitForResource wait_for_resource , StaticType < BufferType > buffer_type , i64 * moving_pos_observed ) { if ( min_count > this -> capacity_ ) { return { StatusCode :: kInvalidArgument }; } const i64 min_target = fixed_pos . get_value () + min_delta ; if ( wait_for_resource == WaitForResource :: kFalse ) { i64 tmp = 0 ; if ( BATT_HINT_FALSE ( moving_pos_observed == nullptr )) { moving_pos_observed = & tmp ; } * moving_pos_observed = moving_pos . get_value (); if ( * moving_pos_observed < min_target ) { return { StatusCode :: kUnavailable }; } } else { const StatusOr < i64 > result = moving_pos . await_true ([ min_target ]( i64 observed ) { // return observed >= min_target ; }); if ( ! result . ok ()) { if ( result . status () != StatusCode :: kEndOfStream || moving_pos . get_value () < min_target ) { return result . status (); } } if ( BATT_HINT_FALSE ( moving_pos_observed != nullptr )) { * moving_pos_observed = * result ; } } return this -> get_buffers ( fixed_pos . get_value (), get_max_count (), buffer_type ); } } // namespace batt #endif // BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/","text":"batteries/protobuf/stream_buffer_input_stream.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP Macro Documentation \ud83d\udd17 BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP \ud83d\udd17 1 #define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP #define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP #include <batteries/config.hpp> #ifndef BATT_PROTOBUF_AVAILABLE #error This header may only be included if BATT_PROTOBUF_AVAILABLE is defined #else #include <google/protobuf/io/zero_copy_stream.h> #include <batteries/assert.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <algorithm> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class StreamBufferInputStream : public google :: protobuf :: io :: ZeroCopyInputStream { public : explicit StreamBufferInputStream ( StreamBuffer & buffer ) noexcept : buffer_ { buffer } { } ~ StreamBufferInputStream () noexcept { this -> consume_data (); } // Obtains a chunk of data from the stream. // bool Next ( const void ** data , int * size ) override { BATT_ASSERT_NOT_NULLPTR ( data ); BATT_ASSERT_NOT_NULLPTR ( size ); Optional < ConstBuffer > next = this -> fetch_next (); if ( ! next ) { return false ; } * data = next -> data (); * size = BATT_CHECKED_CAST ( int , next -> size ()); return true ; } // Backs up a number of bytes, so that the next call to Next() returns data again that was already // returned by the last call to Next(). // void BackUp ( int count ) override { BATT_CHECK_LE ( count , this -> n_to_consume_ ); this -> n_to_consume_ -= count ; this -> byte_count_ -= count ; } // Skips a number of bytes. // bool Skip ( int count ) override { while ( count > 0 ) { const void * data = nullptr ; int size = 0 ; bool result = this -> Next ( & data , & size ); if ( ! result || size == 0 ) { return false ; } if ( size > count ) { this -> BackUp ( size - count ); count = 0 ; } else { count -= size ; } } return true ; } // Returns the total number of bytes read since this object was created. // i64 ByteCount () const override { return this -> byte_count_ ; } //+++++++++++-+-+--+----- --- -- - - - - void consume_data () { if ( this -> n_to_consume_ > 0 ) { i64 n = 0 ; std :: swap ( n , this -> n_to_consume_ ); this -> buffer_ . consume ( n ); } } private : //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Optional < ConstBuffer > fetch_next () { this -> consume_data (); StatusOr < SmallVec < ConstBuffer , 2 > > fetched = this -> buffer_ . fetch_at_least ( 1 ); if ( ! fetched . ok ()) { return None ; } ConstBuffer & next = fetched -> front (); this -> n_to_consume_ = next . size (); this -> byte_count_ += next . size (); return next ; } //+++++++++++-+-+--+----- --- -- - - - - StreamBuffer & buffer_ ; i64 byte_count_ = 0 ; i64 n_to_consume_ = 0 ; }; } // namespace batt #endif // BATT_PROTOBUF_AVAILABLE #endif // BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/protobuf/stream_buffer_input_stream.hpp"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#defines","text":"Name BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP","title":"Defines"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#batteries_protobuf_stream_buffer_input_stream_hpp","text":"1 #define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP()","title":"BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP #define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP #include <batteries/config.hpp> #ifndef BATT_PROTOBUF_AVAILABLE #error This header may only be included if BATT_PROTOBUF_AVAILABLE is defined #else #include <google/protobuf/io/zero_copy_stream.h> #include <batteries/assert.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <algorithm> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class StreamBufferInputStream : public google :: protobuf :: io :: ZeroCopyInputStream { public : explicit StreamBufferInputStream ( StreamBuffer & buffer ) noexcept : buffer_ { buffer } { } ~ StreamBufferInputStream () noexcept { this -> consume_data (); } // Obtains a chunk of data from the stream. // bool Next ( const void ** data , int * size ) override { BATT_ASSERT_NOT_NULLPTR ( data ); BATT_ASSERT_NOT_NULLPTR ( size ); Optional < ConstBuffer > next = this -> fetch_next (); if ( ! next ) { return false ; } * data = next -> data (); * size = BATT_CHECKED_CAST ( int , next -> size ()); return true ; } // Backs up a number of bytes, so that the next call to Next() returns data again that was already // returned by the last call to Next(). // void BackUp ( int count ) override { BATT_CHECK_LE ( count , this -> n_to_consume_ ); this -> n_to_consume_ -= count ; this -> byte_count_ -= count ; } // Skips a number of bytes. // bool Skip ( int count ) override { while ( count > 0 ) { const void * data = nullptr ; int size = 0 ; bool result = this -> Next ( & data , & size ); if ( ! result || size == 0 ) { return false ; } if ( size > count ) { this -> BackUp ( size - count ); count = 0 ; } else { count -= size ; } } return true ; } // Returns the total number of bytes read since this object was created. // i64 ByteCount () const override { return this -> byte_count_ ; } //+++++++++++-+-+--+----- --- -- - - - - void consume_data () { if ( this -> n_to_consume_ > 0 ) { i64 n = 0 ; std :: swap ( n , this -> n_to_consume_ ); this -> buffer_ . consume ( n ); } } private : //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Optional < ConstBuffer > fetch_next () { this -> consume_data (); StatusOr < SmallVec < ConstBuffer , 2 > > fetched = this -> buffer_ . fetch_at_least ( 1 ); if ( ! fetched . ok ()) { return None ; } ConstBuffer & next = fetched -> front (); this -> n_to_consume_ = next . size (); this -> byte_count_ += next . size (); return next ; } //+++++++++++-+-+--+----- --- -- - - - - StreamBuffer & buffer_ ; i64 byte_count_ = 0 ; i64 n_to_consume_ = 0 ; }; } // namespace batt #endif // BATT_PROTOBUF_AVAILABLE #endif // BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/","text":"batteries/protobuf/stream_buffer_output_stream.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP Macro Documentation \ud83d\udd17 BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP \ud83d\udd17 1 #define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP #define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP #include <batteries/config.hpp> #ifndef BATT_PROTOBUF_AVAILABLE #error This header may only be included if BATT_PROTOBUF_AVAILABLE is defined #else #include <google/protobuf/io/zero_copy_stream.h> #include <batteries/assert.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <algorithm> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class StreamBufferOutputStream : public google :: protobuf :: io :: ZeroCopyOutputStream { public : explicit StreamBufferOutputStream ( StreamBuffer & buffer ) noexcept : buffer_ { buffer } { } ~ StreamBufferOutputStream () noexcept { this -> commit_data (); } // Obtains a buffer into which data can be written. // bool Next ( void ** data , int * size ) override { BATT_ASSERT_NOT_NULLPTR ( data ); BATT_ASSERT_NOT_NULLPTR ( size ); Optional < MutableBuffer > next = this -> prepare_next (); if ( ! next ) { return false ; } * data = next -> data (); * size = BATT_CHECKED_CAST ( int , next -> size ()); return true ; } // Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually // written. // void BackUp ( int count ) override { BATT_CHECK_LE ( count , this -> n_to_commit_ ); this -> n_to_commit_ -= count ; this -> byte_count_ -= count ; } // Returns the total number of bytes written since this object was created. // i64 ByteCount () const override { return this -> byte_count_ ; } // Write a given chunk of data to the output. // bool WriteAliasedRaw ( const void * /*data*/ , int /*size*/ ) override { BATT_PANIC () << \"Not supported\" ; return false ; } bool AllowsAliasing () const override { // TODO [tastolfi 2022-02-24] support this. return false ; } //+++++++++++-+-+--+----- --- -- - - - - void commit_data () { if ( this -> n_to_commit_ > 0 ) { i64 n = 0 ; std :: swap ( n , this -> n_to_commit_ ); this -> buffer_ . commit ( n ); } } private : //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Optional < MutableBuffer > prepare_next () { this -> commit_data (); StatusOr < SmallVec < MutableBuffer , 2 > > prepared = this -> buffer_ . prepare_at_least ( 1 ); if ( ! prepared . ok ()) { return None ; } MutableBuffer & next = prepared -> front (); this -> n_to_commit_ = next . size (); this -> byte_count_ += next . size (); return next ; } //+++++++++++-+-+--+----- --- -- - - - - StreamBuffer & buffer_ ; i64 byte_count_ = 0 ; i64 n_to_commit_ = 0 ; }; } // namespace batt #endif // BATT_PROTOBUF_AVAILABLE #endif // BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/protobuf/stream_buffer_output_stream.hpp"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#defines","text":"Name BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP","title":"Defines"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#batteries_protobuf_stream_buffer_output_stream_hpp","text":"1 #define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP()","title":"BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP #define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP #include <batteries/config.hpp> #ifndef BATT_PROTOBUF_AVAILABLE #error This header may only be included if BATT_PROTOBUF_AVAILABLE is defined #else #include <google/protobuf/io/zero_copy_stream.h> #include <batteries/assert.hpp> #include <batteries/async/stream_buffer.hpp> #include <batteries/buffer.hpp> #include <batteries/checked_cast.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/small_vec.hpp> #include <algorithm> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class StreamBufferOutputStream : public google :: protobuf :: io :: ZeroCopyOutputStream { public : explicit StreamBufferOutputStream ( StreamBuffer & buffer ) noexcept : buffer_ { buffer } { } ~ StreamBufferOutputStream () noexcept { this -> commit_data (); } // Obtains a buffer into which data can be written. // bool Next ( void ** data , int * size ) override { BATT_ASSERT_NOT_NULLPTR ( data ); BATT_ASSERT_NOT_NULLPTR ( size ); Optional < MutableBuffer > next = this -> prepare_next (); if ( ! next ) { return false ; } * data = next -> data (); * size = BATT_CHECKED_CAST ( int , next -> size ()); return true ; } // Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually // written. // void BackUp ( int count ) override { BATT_CHECK_LE ( count , this -> n_to_commit_ ); this -> n_to_commit_ -= count ; this -> byte_count_ -= count ; } // Returns the total number of bytes written since this object was created. // i64 ByteCount () const override { return this -> byte_count_ ; } // Write a given chunk of data to the output. // bool WriteAliasedRaw ( const void * /*data*/ , int /*size*/ ) override { BATT_PANIC () << \"Not supported\" ; return false ; } bool AllowsAliasing () const override { // TODO [tastolfi 2022-02-24] support this. return false ; } //+++++++++++-+-+--+----- --- -- - - - - void commit_data () { if ( this -> n_to_commit_ > 0 ) { i64 n = 0 ; std :: swap ( n , this -> n_to_commit_ ); this -> buffer_ . commit ( n ); } } private : //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Optional < MutableBuffer > prepare_next () { this -> commit_data (); StatusOr < SmallVec < MutableBuffer , 2 > > prepared = this -> buffer_ . prepare_at_least ( 1 ); if ( ! prepared . ok ()) { return None ; } MutableBuffer & next = prepared -> front (); this -> n_to_commit_ = next . size (); this -> byte_count_ += next . size (); return next ; } //+++++++++++-+-+--+----- --- -- - - - - StreamBuffer & buffer_ ; i64 byte_count_ = 0 ; i64 n_to_commit_ = 0 ; }; } // namespace batt #endif // BATT_PROTOBUF_AVAILABLE #endif // BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/stream__util_8hpp/","text":"batteries/stream_util.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name std batt batt::detail Classes \ud83d\udd17 Name struct batt::EscapedStringLiteral struct batt::HexByteDumper class batt::RangeDumper class batt::RangeDumper Defines \ud83d\udd17 Name BATT_DETAIL_OVERLOAD_STRING_PRINTABLE (type) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE (type) BATT_INSPECT_STR (expr) BATT_INSPECT_RANGE (expr) BATT_INSPECT_RANGE_PRETTY (expr) BATT_PRINT_OBJECT_FIELD (r, obj, fieldname) BATT_PRINT_OBJECT_IMPL (type, fields_seq) Macro Documentation \ud83d\udd17 BATT_DETAIL_OVERLOAD_STRING_PRINTABLE \ud83d\udd17 1 #define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE \ud83d\udd17 1 #define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type) BATT_INSPECT_STR \ud83d\udd17 1 #define BATT_INSPECT_STR(expr) BATT_INSPECT_RANGE \ud83d\udd17 1 #define BATT_INSPECT_RANGE(expr) BATT_INSPECT_RANGE_PRETTY \ud83d\udd17 1 #define BATT_INSPECT_RANGE_PRETTY(expr) BATT_PRINT_OBJECT_FIELD \ud83d\udd17 1 #define BATT_PRINT_OBJECT_FIELD(r, obj, fieldname) BATT_PRINT_OBJECT_IMPL \ud83d\udd17 1 #define BATT_PRINT_OBJECT_IMPL(type, fields_seq) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <batteries/finally.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/suppress.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/algorithm/string.hpp> #include <boost/io/ios_state.hpp> #include <boost/preprocessor/seq/for_each.hpp> #include <atomic> #include <iomanip> #include <optional> #include <ostream> #include <sstream> namespace std { // ============================================================================= // Support printing for std::optional<T>. // template < typename T > inline ostream & operator << ( ostream & out , const optional < T >& t ) { if ( t ) { return out << * t ; } return out << \"{}\" ; } // ============================================================================= // Support insertion of lambdas and other callables that take a std::ostream&. // template < typename Fn , typename = enable_if_t <:: batt :: IsCallable < Fn , ostream &> {} >> inline ostream & operator << ( ostream & out , Fn && fn ) { fn ( out ); return out ; } } // namespace std namespace batt { // ============================================================================= // print_all - insert all arguments to the stream. // inline std :: ostream & print_all ( std :: ostream & out ) { return out ; } template < typename First , typename ... Rest > std :: ostream & print_all ( std :: ostream & out , First && first , Rest && ... rest ) { return print_all ( out << BATT_FORWARD ( first ), BATT_FORWARD ( rest )...); } // ============================================================================= // extract_all - extract all arguments to the stream. // inline std :: istream & extract_all ( std :: istream & in ) { return in ; } template < typename First , typename ... Rest > std :: istream & extract_all ( std :: istream & in , First && first , Rest && ... rest ) { return extract_all ( in >> BATT_FORWARD ( first ), BATT_FORWARD ( rest )...); } // ============================================================================= // to_string - use ostream insertion to convert any object to a string. // template < typename ... Args > std :: string to_string ( Args && ... args ) { std :: ostringstream oss ; print_all ( oss , BATT_FORWARD ( args )...); return std :: move ( oss ). str (); } #if defined(__GNUC__) && !defined(__clang__) BATT_SUPPRESS ( \"-Wmaybe-uninitialized\" ) #endif // ============================================================================= // from_string - use istream extraction to parse any object from a string. // namespace detail { // General case. // template < typename T , typename ... FormatArgs > std :: optional < T > from_string_impl ( StaticType < T > , const std :: string & str , FormatArgs && ... format_args ) { T val ; std :: istringstream iss { str }; extract_all ( iss , BATT_FORWARD ( format_args )..., val ); if ( iss . good () || iss . eof ()) { return val ; } return std :: nullopt ; } // Special case for bool. // template < typename ... FormatArgs > std :: optional < bool > from_string_impl ( StaticType < bool > , const std :: string & str , FormatArgs && ... /*format_args*/ ) { return boost :: algorithm :: to_lower_copy ( str ) == \"true\" || from_string_impl ( StaticType < int > {}, str ) != 0 ; } } // namespace detail template < typename T , typename ... FormatArgs > std :: optional < T > from_string ( const std :: string & str , FormatArgs && ... format_args ) { return detail :: from_string_impl ( StaticType < T > {}, str , BATT_FORWARD ( format_args )...); } #if defined(__GNUC__) && !defined(__clang__) BATT_UNSUPPRESS () #endif // ============================================================================= // c_str_literal(str) - escape a C string. // struct EscapedStringLiteral { static std :: atomic < usize >& max_show_length () { static std :: atomic < usize > len { std :: numeric_limits < usize >:: max ()}; return len ; } std :: string_view str ; }; inline EscapedStringLiteral c_str_literal ( const std :: string_view & str ) { return EscapedStringLiteral { str }; } template < typename T , typename = std :: enable_if_t < std :: is_convertible_v < T , std :: string_view >>> inline Optional < EscapedStringLiteral > c_str_literal ( const Optional < T >& maybe_str ) { if ( maybe_str ) { return { c_str_literal ( * maybe_str )}; } return None ; } inline Optional < EscapedStringLiteral > c_str_literal ( const NoneType & ) { return None ; } #define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type) \\ inline decltype(auto) make_printable(type str) \\ { \\ return c_str_literal(str); \\ } #define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type&) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type&&) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(const type&) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(const type&&) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE ( std :: string ) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE ( std :: string_view ) #undef BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE #undef BATT_DETAIL_OVERLOAD_STRING_PRINTABLE #define BATT_INSPECT_STR(expr) \" \" << #expr << \" == \" << ::batt::c_str_literal((expr)) inline const std :: string_view & StringUpperBound () { static const std :: string_view s = [] { static std :: array < char , 4096 > s ; s . fill ( 0xff ); return std :: string_view { s . data (), s . size ()}; }(); return s ; } inline std :: ostream & operator << ( std :: ostream & out , const EscapedStringLiteral & t ) { if ( t . str . data () == StringUpperBound (). data ()) { return out << \" \\\"\\\\ xff \\\" ...\" ; } static const char xdigit [ 16 ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; const auto emit_hex_ascii = [ & ]( char ch ) { out << \" \\\\ x\" << xdigit [( ch >> 4 ) & 0xf ] << xdigit [ ch & 0xf ]; }; out << '\"' ; usize i = 0 ; for ( char ch : t . str ) { if ( i > EscapedStringLiteral :: max_show_length ()) { return out << \" \\\" ...(\" << t . str . length () - i << \" skipped chars)\" ; } ++ i ; if ( ch & 0b10000000 ) { emit_hex_ascii ( ch ); continue ; } switch ( ch & 0b1110000 ) { case 0b0000000 : switch ( ch & 0b1111 ) { case 0b0000 : out << \" \\\\ 0\" ; break ; case 0b0111 : out << \" \\\\ a\" ; break ; case 0b1000 : out << \" \\\\ b\" ; break ; case 0b1001 : out << \" \\\\ t\" ; break ; case 0b1010 : out << \" \\\\ n\" ; break ; case 0b1011 : out << \" \\\\ v\" ; break ; case 0b1100 : out << \" \\\\ f\" ; break ; case 0b1101 : out << \" \\\\ r\" ; break ; default : emit_hex_ascii ( ch ); break ; } break ; case 0b0010000 : switch ( ch & 0b1111 ) { case 0b1011 : out << \" \\\\ e\" ; break ; default : emit_hex_ascii ( ch ); break ; } break ; case 0b0100000 : switch ( ch & 0b1111 ) { case 0b0010 : out << \" \\\\\\\" \" ; break ; default : out << ch ; break ; } break ; case 0b1010000 : switch ( ch & 0b1111 ) { case 0b1100 : out << \" \\\\\\\\ \" ; break ; default : out << ch ; break ; } break ; case 0b1110000 : switch ( ch & 0b1111 ) { case 0b1111 : out << \" \\\\ x7f\" ; break ; default : out << ch ; break ; } break ; default : out << ch ; break ; } } return out << '\"' ; } struct HexByteDumper { std :: string_view bytes ; }; inline std :: ostream & operator << ( std :: ostream & out , const HexByteDumper & t ) { out << std :: endl ; boost :: io :: ios_flags_saver saver { out }; const char * const bytes = t . bytes . data (); const usize len = t . bytes . size (); for ( usize i = 0 ; i < len ; ++ i ) { if ( i % 16 == 0 ) { out << std :: hex << std :: setw ( 8 ) << std :: setfill ( '0' ) << i << \": \" ; } out << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ((( unsigned ) bytes [ i ]) & 0xfful ); if ( i % 16 == 15 ) { out << std :: endl ; } else if ( i % 2 == 1 ) { out << \" \" ; } } return out ; } inline HexByteDumper dump_hex ( const void * ptr , usize size ) { return HexByteDumper { std :: string_view { static_cast < const char *> ( ptr ), size }}; } // ============================================================================= // dump_range(x) - make range `x` printable to std::ostream. Will also print any nested ranges // (e.g., `std::vector<std::vector<int>>`). // // Example: // // ``` // std::vector<int> nums; // // std::cout << batt::dump_range(nums); // ``` // // Example (Pretty-printing): // ``` // std::vector<int> nums; // // std::cout << batt::dump_range(nums, batt::Pretty::True); // ``` // enum struct Pretty { True , False , Default }; template < typename T > class RangeDumper ; template < typename T > RangeDumper < const T &> dump_range ( const T & value , Pretty pretty = Pretty :: Default ); namespace detail { inline Pretty & range_dump_pretty () { thread_local Pretty p = Pretty :: False ; return p ; } inline int & range_dump_depth () { thread_local int depth = 0 ; return depth ; } template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , u8 > {} > , typename = std :: enable_if_t <! IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item ) { return out << BATT_FORWARD ( item ); } inline std :: ostream & dump_item ( std :: ostream & out , const std :: string & s ) { return out << c_str_literal ( s ); } inline std :: ostream & dump_item ( std :: ostream & out , const std :: string_view & s ) { return out << c_str_literal ( s ); } template < typename T , typename = std :: enable_if_t < IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item ) { return out << dump_range ( item ); } inline std :: ostream & dump_item ( std :: ostream & out , u8 byte_val ) { return out << \"0x\" << std :: hex << std :: setfill ( '0' ) << std :: setw ( 2 ) << unsigned ( byte_val ); } template < typename FirstT , typename SecondT > inline std :: ostream & dump_item ( std :: ostream & out , const std :: pair < FirstT , SecondT >& p ) { out << \"{\" ; dump_item ( out , p . first ); out << \", \" ; dump_item ( out , p . second ); return out << \"}\" ; } } // namespace detail inline auto pretty_print_indent () { return std :: string ( detail :: range_dump_depth () * 2 , ' ' ); } template < typename T > class RangeDumper { private : T value_ ; Pretty pretty_ ; public : template < typename Arg > explicit RangeDumper ( Arg && arg , Pretty pretty ) noexcept : value_ { BATT_FORWARD ( arg )} , pretty_ { pretty } { } friend inline std :: ostream & operator << ( std :: ostream & out , const RangeDumper & t ) noexcept { boost :: io :: ios_flags_saver flags_saver ( out ); const Pretty save_pretty = detail :: range_dump_pretty (); bool pretty = [ & ] { if ( t . pretty_ == Pretty :: Default ) { return save_pretty == Pretty :: True ; } return t . pretty_ == Pretty :: True ; }(); detail :: range_dump_pretty () = pretty ? Pretty :: True : Pretty :: False ; std :: string indent = pretty_print_indent (); ++ detail :: range_dump_depth (); const auto leave_indent_level = finally ([ & ] { -- detail :: range_dump_depth (); detail :: range_dump_pretty () = save_pretty ; }); out << \"{ \" ; if ( pretty && std :: begin ( t . value_ ) != std :: end ( t . value_ )) { out << std :: endl << indent ; } for ( const auto & item : t . value_ ) { if ( pretty ) { out << \" \" ; } detail :: dump_item ( out , item ) << \", \" ; if ( pretty ) { out << std :: endl << indent ; } } return out << \"}\" ; } }; template < typename T > RangeDumper < const T &> dump_range ( const T & value , Pretty pretty ) { return RangeDumper < const T &> { value , pretty }; } #define BATT_INSPECT_RANGE(expr) \" \" << #expr << \" == \" << ::batt::dump_range((expr)) #define BATT_INSPECT_RANGE_PRETTY(expr) \\ \" \" << #expr << \" == \" << ::batt::dump_range((expr), ::batt::Pretty::True) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #define BATT_PRINT_OBJECT_FIELD(r, obj, fieldname) \\ << \" .\" << BOOST_PP_STRINGIZE(fieldname) << \"=\" << ::batt::make_printable(obj.fieldname) << \",\" #define BATT_PRINT_OBJECT_IMPL(type, fields_seq) \\ std::ostream& operator<<(std::ostream& out, const type& t) \\ { \\ return out << ::batt::name_of<type>() \\ << \"{\" BOOST_PP_SEQ_FOR_EACH(BATT_PRINT_OBJECT_FIELD, (t), fields_seq) << \"}\"; \\ } } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/stream_util.hpp"},{"location":"_autogen/Files/stream__util_8hpp/#namespaces","text":"Name std batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/stream__util_8hpp/#classes","text":"Name struct batt::EscapedStringLiteral struct batt::HexByteDumper class batt::RangeDumper class batt::RangeDumper","title":"Classes"},{"location":"_autogen/Files/stream__util_8hpp/#defines","text":"Name BATT_DETAIL_OVERLOAD_STRING_PRINTABLE (type) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE (type) BATT_INSPECT_STR (expr) BATT_INSPECT_RANGE (expr) BATT_INSPECT_RANGE_PRETTY (expr) BATT_PRINT_OBJECT_FIELD (r, obj, fieldname) BATT_PRINT_OBJECT_IMPL (type, fields_seq)","title":"Defines"},{"location":"_autogen/Files/stream__util_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/stream__util_8hpp/#batt_detail_overload_string_printable","text":"1 #define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type)","title":"BATT_DETAIL_OVERLOAD_STRING_PRINTABLE"},{"location":"_autogen/Files/stream__util_8hpp/#batt_detail_specialize_string_printable","text":"1 #define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type)","title":"BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE"},{"location":"_autogen/Files/stream__util_8hpp/#batt_inspect_str","text":"1 #define BATT_INSPECT_STR(expr)","title":"BATT_INSPECT_STR"},{"location":"_autogen/Files/stream__util_8hpp/#batt_inspect_range","text":"1 #define BATT_INSPECT_RANGE(expr)","title":"BATT_INSPECT_RANGE"},{"location":"_autogen/Files/stream__util_8hpp/#batt_inspect_range_pretty","text":"1 #define BATT_INSPECT_RANGE_PRETTY(expr)","title":"BATT_INSPECT_RANGE_PRETTY"},{"location":"_autogen/Files/stream__util_8hpp/#batt_print_object_field","text":"1 #define BATT_PRINT_OBJECT_FIELD(r, obj, fieldname)","title":"BATT_PRINT_OBJECT_FIELD"},{"location":"_autogen/Files/stream__util_8hpp/#batt_print_object_impl","text":"1 #define BATT_PRINT_OBJECT_IMPL(type, fields_seq)","title":"BATT_PRINT_OBJECT_IMPL"},{"location":"_autogen/Files/stream__util_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <batteries/finally.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/suppress.hpp> #include <batteries/type_traits.hpp> #include <batteries/utility.hpp> #include <boost/algorithm/string.hpp> #include <boost/io/ios_state.hpp> #include <boost/preprocessor/seq/for_each.hpp> #include <atomic> #include <iomanip> #include <optional> #include <ostream> #include <sstream> namespace std { // ============================================================================= // Support printing for std::optional<T>. // template < typename T > inline ostream & operator << ( ostream & out , const optional < T >& t ) { if ( t ) { return out << * t ; } return out << \"{}\" ; } // ============================================================================= // Support insertion of lambdas and other callables that take a std::ostream&. // template < typename Fn , typename = enable_if_t <:: batt :: IsCallable < Fn , ostream &> {} >> inline ostream & operator << ( ostream & out , Fn && fn ) { fn ( out ); return out ; } } // namespace std namespace batt { // ============================================================================= // print_all - insert all arguments to the stream. // inline std :: ostream & print_all ( std :: ostream & out ) { return out ; } template < typename First , typename ... Rest > std :: ostream & print_all ( std :: ostream & out , First && first , Rest && ... rest ) { return print_all ( out << BATT_FORWARD ( first ), BATT_FORWARD ( rest )...); } // ============================================================================= // extract_all - extract all arguments to the stream. // inline std :: istream & extract_all ( std :: istream & in ) { return in ; } template < typename First , typename ... Rest > std :: istream & extract_all ( std :: istream & in , First && first , Rest && ... rest ) { return extract_all ( in >> BATT_FORWARD ( first ), BATT_FORWARD ( rest )...); } // ============================================================================= // to_string - use ostream insertion to convert any object to a string. // template < typename ... Args > std :: string to_string ( Args && ... args ) { std :: ostringstream oss ; print_all ( oss , BATT_FORWARD ( args )...); return std :: move ( oss ). str (); } #if defined(__GNUC__) && !defined(__clang__) BATT_SUPPRESS ( \"-Wmaybe-uninitialized\" ) #endif // ============================================================================= // from_string - use istream extraction to parse any object from a string. // namespace detail { // General case. // template < typename T , typename ... FormatArgs > std :: optional < T > from_string_impl ( StaticType < T > , const std :: string & str , FormatArgs && ... format_args ) { T val ; std :: istringstream iss { str }; extract_all ( iss , BATT_FORWARD ( format_args )..., val ); if ( iss . good () || iss . eof ()) { return val ; } return std :: nullopt ; } // Special case for bool. // template < typename ... FormatArgs > std :: optional < bool > from_string_impl ( StaticType < bool > , const std :: string & str , FormatArgs && ... /*format_args*/ ) { return boost :: algorithm :: to_lower_copy ( str ) == \"true\" || from_string_impl ( StaticType < int > {}, str ) != 0 ; } } // namespace detail template < typename T , typename ... FormatArgs > std :: optional < T > from_string ( const std :: string & str , FormatArgs && ... format_args ) { return detail :: from_string_impl ( StaticType < T > {}, str , BATT_FORWARD ( format_args )...); } #if defined(__GNUC__) && !defined(__clang__) BATT_UNSUPPRESS () #endif // ============================================================================= // c_str_literal(str) - escape a C string. // struct EscapedStringLiteral { static std :: atomic < usize >& max_show_length () { static std :: atomic < usize > len { std :: numeric_limits < usize >:: max ()}; return len ; } std :: string_view str ; }; inline EscapedStringLiteral c_str_literal ( const std :: string_view & str ) { return EscapedStringLiteral { str }; } template < typename T , typename = std :: enable_if_t < std :: is_convertible_v < T , std :: string_view >>> inline Optional < EscapedStringLiteral > c_str_literal ( const Optional < T >& maybe_str ) { if ( maybe_str ) { return { c_str_literal ( * maybe_str )}; } return None ; } inline Optional < EscapedStringLiteral > c_str_literal ( const NoneType & ) { return None ; } #define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type) \\ inline decltype(auto) make_printable(type str) \\ { \\ return c_str_literal(str); \\ } #define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type&) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type&&) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(const type&) \\ BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(const type&&) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE ( std :: string ) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE ( std :: string_view ) #undef BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE #undef BATT_DETAIL_OVERLOAD_STRING_PRINTABLE #define BATT_INSPECT_STR(expr) \" \" << #expr << \" == \" << ::batt::c_str_literal((expr)) inline const std :: string_view & StringUpperBound () { static const std :: string_view s = [] { static std :: array < char , 4096 > s ; s . fill ( 0xff ); return std :: string_view { s . data (), s . size ()}; }(); return s ; } inline std :: ostream & operator << ( std :: ostream & out , const EscapedStringLiteral & t ) { if ( t . str . data () == StringUpperBound (). data ()) { return out << \" \\\"\\\\ xff \\\" ...\" ; } static const char xdigit [ 16 ] = { '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'a' , 'b' , 'c' , 'd' , 'e' , 'f' }; const auto emit_hex_ascii = [ & ]( char ch ) { out << \" \\\\ x\" << xdigit [( ch >> 4 ) & 0xf ] << xdigit [ ch & 0xf ]; }; out << '\"' ; usize i = 0 ; for ( char ch : t . str ) { if ( i > EscapedStringLiteral :: max_show_length ()) { return out << \" \\\" ...(\" << t . str . length () - i << \" skipped chars)\" ; } ++ i ; if ( ch & 0b10000000 ) { emit_hex_ascii ( ch ); continue ; } switch ( ch & 0b1110000 ) { case 0b0000000 : switch ( ch & 0b1111 ) { case 0b0000 : out << \" \\\\ 0\" ; break ; case 0b0111 : out << \" \\\\ a\" ; break ; case 0b1000 : out << \" \\\\ b\" ; break ; case 0b1001 : out << \" \\\\ t\" ; break ; case 0b1010 : out << \" \\\\ n\" ; break ; case 0b1011 : out << \" \\\\ v\" ; break ; case 0b1100 : out << \" \\\\ f\" ; break ; case 0b1101 : out << \" \\\\ r\" ; break ; default : emit_hex_ascii ( ch ); break ; } break ; case 0b0010000 : switch ( ch & 0b1111 ) { case 0b1011 : out << \" \\\\ e\" ; break ; default : emit_hex_ascii ( ch ); break ; } break ; case 0b0100000 : switch ( ch & 0b1111 ) { case 0b0010 : out << \" \\\\\\\" \" ; break ; default : out << ch ; break ; } break ; case 0b1010000 : switch ( ch & 0b1111 ) { case 0b1100 : out << \" \\\\\\\\ \" ; break ; default : out << ch ; break ; } break ; case 0b1110000 : switch ( ch & 0b1111 ) { case 0b1111 : out << \" \\\\ x7f\" ; break ; default : out << ch ; break ; } break ; default : out << ch ; break ; } } return out << '\"' ; } struct HexByteDumper { std :: string_view bytes ; }; inline std :: ostream & operator << ( std :: ostream & out , const HexByteDumper & t ) { out << std :: endl ; boost :: io :: ios_flags_saver saver { out }; const char * const bytes = t . bytes . data (); const usize len = t . bytes . size (); for ( usize i = 0 ; i < len ; ++ i ) { if ( i % 16 == 0 ) { out << std :: hex << std :: setw ( 8 ) << std :: setfill ( '0' ) << i << \": \" ; } out << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ((( unsigned ) bytes [ i ]) & 0xfful ); if ( i % 16 == 15 ) { out << std :: endl ; } else if ( i % 2 == 1 ) { out << \" \" ; } } return out ; } inline HexByteDumper dump_hex ( const void * ptr , usize size ) { return HexByteDumper { std :: string_view { static_cast < const char *> ( ptr ), size }}; } // ============================================================================= // dump_range(x) - make range `x` printable to std::ostream. Will also print any nested ranges // (e.g., `std::vector<std::vector<int>>`). // // Example: // // ``` // std::vector<int> nums; // // std::cout << batt::dump_range(nums); // ``` // // Example (Pretty-printing): // ``` // std::vector<int> nums; // // std::cout << batt::dump_range(nums, batt::Pretty::True); // ``` // enum struct Pretty { True , False , Default }; template < typename T > class RangeDumper ; template < typename T > RangeDumper < const T &> dump_range ( const T & value , Pretty pretty = Pretty :: Default ); namespace detail { inline Pretty & range_dump_pretty () { thread_local Pretty p = Pretty :: False ; return p ; } inline int & range_dump_depth () { thread_local int depth = 0 ; return depth ; } template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , u8 > {} > , typename = std :: enable_if_t <! IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item ) { return out << BATT_FORWARD ( item ); } inline std :: ostream & dump_item ( std :: ostream & out , const std :: string & s ) { return out << c_str_literal ( s ); } inline std :: ostream & dump_item ( std :: ostream & out , const std :: string_view & s ) { return out << c_str_literal ( s ); } template < typename T , typename = std :: enable_if_t < IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item ) { return out << dump_range ( item ); } inline std :: ostream & dump_item ( std :: ostream & out , u8 byte_val ) { return out << \"0x\" << std :: hex << std :: setfill ( '0' ) << std :: setw ( 2 ) << unsigned ( byte_val ); } template < typename FirstT , typename SecondT > inline std :: ostream & dump_item ( std :: ostream & out , const std :: pair < FirstT , SecondT >& p ) { out << \"{\" ; dump_item ( out , p . first ); out << \", \" ; dump_item ( out , p . second ); return out << \"}\" ; } } // namespace detail inline auto pretty_print_indent () { return std :: string ( detail :: range_dump_depth () * 2 , ' ' ); } template < typename T > class RangeDumper { private : T value_ ; Pretty pretty_ ; public : template < typename Arg > explicit RangeDumper ( Arg && arg , Pretty pretty ) noexcept : value_ { BATT_FORWARD ( arg )} , pretty_ { pretty } { } friend inline std :: ostream & operator << ( std :: ostream & out , const RangeDumper & t ) noexcept { boost :: io :: ios_flags_saver flags_saver ( out ); const Pretty save_pretty = detail :: range_dump_pretty (); bool pretty = [ & ] { if ( t . pretty_ == Pretty :: Default ) { return save_pretty == Pretty :: True ; } return t . pretty_ == Pretty :: True ; }(); detail :: range_dump_pretty () = pretty ? Pretty :: True : Pretty :: False ; std :: string indent = pretty_print_indent (); ++ detail :: range_dump_depth (); const auto leave_indent_level = finally ([ & ] { -- detail :: range_dump_depth (); detail :: range_dump_pretty () = save_pretty ; }); out << \"{ \" ; if ( pretty && std :: begin ( t . value_ ) != std :: end ( t . value_ )) { out << std :: endl << indent ; } for ( const auto & item : t . value_ ) { if ( pretty ) { out << \" \" ; } detail :: dump_item ( out , item ) << \", \" ; if ( pretty ) { out << std :: endl << indent ; } } return out << \"}\" ; } }; template < typename T > RangeDumper < const T &> dump_range ( const T & value , Pretty pretty ) { return RangeDumper < const T &> { value , pretty }; } #define BATT_INSPECT_RANGE(expr) \" \" << #expr << \" == \" << ::batt::dump_range((expr)) #define BATT_INSPECT_RANGE_PRETTY(expr) \\ \" \" << #expr << \" == \" << ::batt::dump_range((expr), ::batt::Pretty::True) //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #define BATT_PRINT_OBJECT_FIELD(r, obj, fieldname) \\ << \" .\" << BOOST_PP_STRINGIZE(fieldname) << \"=\" << ::batt::make_printable(obj.fieldname) << \",\" #define BATT_PRINT_OBJECT_IMPL(type, fields_seq) \\ std::ostream& operator<<(std::ostream& out, const type& t) \\ { \\ return out << ::batt::name_of<type>() \\ << \"{\" BOOST_PP_SEQ_FOR_EACH(BATT_PRINT_OBJECT_FIELD, (t), fields_seq) << \"}\"; \\ } } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/strict_8hpp/","text":"batteries/strict.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #ifndef BATT_NO_STRICT #pragma GCC diagnostic error \"-Wall\" #pragma GCC diagnostic error \"-Wextra\" #endif // BATT_NO_STRICT Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/strict.hpp"},{"location":"_autogen/Files/strict_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #ifndef BATT_NO_STRICT #pragma GCC diagnostic error \"-Wall\" #pragma GCC diagnostic error \"-Wextra\" #endif // BATT_NO_STRICT Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/strong__typedef_8hpp/","text":"batteries/strong_typedef.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::StrongType class batt::StrongType struct batt::StrongType::Hash struct batt::StrongType::Delta Functions \ud83d\udd17 Name constexpr std::false_type batt_strong_typedef_supports_numerics (... ) Defines \ud83d\udd17 Name BATT_STRONG_TYPEDEF_PASTE_2_ (a, b) BATT_STRONG_TYPEDEF_PASTE_ (a, b) BATT_STRONG_TYPEDEF (TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT (TYPE, NAME, VALUE) BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS (NAME) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN (op_long, op_short) Functions Documentation \ud83d\udd17 function batt_strong_typedef_supports_numerics \ud83d\udd17 1 2 3 inline constexpr std :: false_type batt_strong_typedef_supports_numerics ( ... ) Macro Documentation \ud83d\udd17 BATT_STRONG_TYPEDEF_PASTE_2_ \ud83d\udd17 1 #define BATT_STRONG_TYPEDEF_PASTE_2_(a, b) BATT_STRONG_TYPEDEF_PASTE_ \ud83d\udd17 1 #define BATT_STRONG_TYPEDEF_PASTE_(a, b) BATT_STRONG_TYPEDEF \ud83d\udd17 1 #define BATT_STRONG_TYPEDEF(TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT \ud83d\udd17 1 #define BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE) BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS \ud83d\udd17 1 #define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN \ud83d\udd17 1 #define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #ifndef BATT_STRONG_TYPEDEF_HPP #define BATT_STRONG_TYPEDEF_HPP #include <batteries/config.hpp> // #include <functional> #include <type_traits> // Must be outside namespace batt so we can do ADL. // inline constexpr std :: false_type batt_strong_typedef_supports_numerics (...) { return {}; } namespace batt { template < typename T , typename Tag > class StrongType ; template < typename T , typename Tag > class StrongType { static_assert ( std :: is_pod < T > {}, \"`T` must be a POD type.\" ); public : using value_type = T ; using tag_type = Tag ; constexpr StrongType () noexcept : value_ { strong_typedef_default_value (( Tag * ) nullptr )} { } explicit constexpr StrongType ( T init_value ) noexcept : value_ { init_value } { } constexpr T value () const { return value_ ; } constexpr operator T () const { return value (); } struct Delta ; StrongType & operator += ( Delta d ); StrongType & operator -= ( Delta d ); struct Hash { using result_type = typename std :: hash < T >:: result_type ; result_type operator ()( const StrongType & obj ) const { return impl_ ( obj . value ()); } private : std :: hash < T > impl_ ; }; private : T value_ ; }; template < typename T , typename Tag > struct StrongType < T , Tag >:: Delta : StrongType < T , Tag > { using StrongType :: StrongType ; /*implicit*/ Delta ( StrongType value ) noexcept : StrongType { value } { } }; #define BATT_STRONG_TYPEDEF_PASTE_2_(a, b) a##b #define BATT_STRONG_TYPEDEF_PASTE_(a, b) BATT_STRONG_TYPEDEF_PASTE_2_(a, b) #define BATT_STRONG_TYPEDEF(TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, TYPE{}) #define BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE) \\ struct BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG); \\ inline constexpr TYPE strong_typedef_default_value(BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)*) \\ { \\ return VALUE; \\ } \\ using NAME = ::batt::StrongType<TYPE, BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)> #define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME) \\ inline constexpr std::true_type batt_strong_typedef_supports_numerics( \\ BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)*) \\ { \\ return {}; \\ } #define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short) \\ template <typename T, typename Tag, \\ typename = std::enable_if_t<batt_strong_typedef_supports_numerics((Tag*)nullptr)>> \\ constexpr StrongType<T, Tag> op_long(StrongType<T, Tag> a, StrongType<T, Tag> b) \\ { \\ return StrongType<T, Tag>{a.value() op_short b.value()}; \\ } BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator + , + ) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator - , - ) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator * , * ) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator / , / ) template < typename T , typename Tag > inline StrongType < T , Tag >& StrongType < T , Tag >:: operator += ( Delta d ) { static_assert ( batt_strong_typedef_supports_numerics (( Tag * ) nullptr ), \"This StrongType does not support numeric operations; see \" \"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS\" ); value_ += d ; return * this ; } template < typename T , typename Tag > inline StrongType < T , Tag >& StrongType < T , Tag >:: operator -= ( Delta d ) { static_assert ( batt_strong_typedef_supports_numerics (( Tag * ) nullptr ), \"This StrongType does not support numeric operations; see \" \"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS\" ); value_ -= d ; return * this ; } } // namespace batt #endif // BATT_STRONG_TYPEDEF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/strong_typedef.hpp"},{"location":"_autogen/Files/strong__typedef_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/strong__typedef_8hpp/#classes","text":"Name class batt::StrongType class batt::StrongType struct batt::StrongType::Hash struct batt::StrongType::Delta","title":"Classes"},{"location":"_autogen/Files/strong__typedef_8hpp/#functions","text":"Name constexpr std::false_type batt_strong_typedef_supports_numerics (... )","title":"Functions"},{"location":"_autogen/Files/strong__typedef_8hpp/#defines","text":"Name BATT_STRONG_TYPEDEF_PASTE_2_ (a, b) BATT_STRONG_TYPEDEF_PASTE_ (a, b) BATT_STRONG_TYPEDEF (TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT (TYPE, NAME, VALUE) BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS (NAME) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN (op_long, op_short)","title":"Defines"},{"location":"_autogen/Files/strong__typedef_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Files/strong__typedef_8hpp/#function-batt_strong_typedef_supports_numerics","text":"1 2 3 inline constexpr std :: false_type batt_strong_typedef_supports_numerics ( ... )","title":"function batt_strong_typedef_supports_numerics"},{"location":"_autogen/Files/strong__typedef_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/strong__typedef_8hpp/#batt_strong_typedef_paste_2_","text":"1 #define BATT_STRONG_TYPEDEF_PASTE_2_(a, b)","title":"BATT_STRONG_TYPEDEF_PASTE_2_"},{"location":"_autogen/Files/strong__typedef_8hpp/#batt_strong_typedef_paste_","text":"1 #define BATT_STRONG_TYPEDEF_PASTE_(a, b)","title":"BATT_STRONG_TYPEDEF_PASTE_"},{"location":"_autogen/Files/strong__typedef_8hpp/#batt_strong_typedef","text":"1 #define BATT_STRONG_TYPEDEF(TYPE, NAME)","title":"BATT_STRONG_TYPEDEF"},{"location":"_autogen/Files/strong__typedef_8hpp/#batt_strong_typedef_with_default","text":"1 #define BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE)","title":"BATT_STRONG_TYPEDEF_WITH_DEFAULT"},{"location":"_autogen/Files/strong__typedef_8hpp/#batt_strong_typedef_supports_numerics","text":"1 #define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME)","title":"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS"},{"location":"_autogen/Files/strong__typedef_8hpp/#batt_strong_typedef_numeric_operator_defn","text":"1 #define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short)","title":"BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN"},{"location":"_autogen/Files/strong__typedef_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #ifndef BATT_STRONG_TYPEDEF_HPP #define BATT_STRONG_TYPEDEF_HPP #include <batteries/config.hpp> // #include <functional> #include <type_traits> // Must be outside namespace batt so we can do ADL. // inline constexpr std :: false_type batt_strong_typedef_supports_numerics (...) { return {}; } namespace batt { template < typename T , typename Tag > class StrongType ; template < typename T , typename Tag > class StrongType { static_assert ( std :: is_pod < T > {}, \"`T` must be a POD type.\" ); public : using value_type = T ; using tag_type = Tag ; constexpr StrongType () noexcept : value_ { strong_typedef_default_value (( Tag * ) nullptr )} { } explicit constexpr StrongType ( T init_value ) noexcept : value_ { init_value } { } constexpr T value () const { return value_ ; } constexpr operator T () const { return value (); } struct Delta ; StrongType & operator += ( Delta d ); StrongType & operator -= ( Delta d ); struct Hash { using result_type = typename std :: hash < T >:: result_type ; result_type operator ()( const StrongType & obj ) const { return impl_ ( obj . value ()); } private : std :: hash < T > impl_ ; }; private : T value_ ; }; template < typename T , typename Tag > struct StrongType < T , Tag >:: Delta : StrongType < T , Tag > { using StrongType :: StrongType ; /*implicit*/ Delta ( StrongType value ) noexcept : StrongType { value } { } }; #define BATT_STRONG_TYPEDEF_PASTE_2_(a, b) a##b #define BATT_STRONG_TYPEDEF_PASTE_(a, b) BATT_STRONG_TYPEDEF_PASTE_2_(a, b) #define BATT_STRONG_TYPEDEF(TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, TYPE{}) #define BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE) \\ struct BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG); \\ inline constexpr TYPE strong_typedef_default_value(BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)*) \\ { \\ return VALUE; \\ } \\ using NAME = ::batt::StrongType<TYPE, BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)> #define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME) \\ inline constexpr std::true_type batt_strong_typedef_supports_numerics( \\ BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)*) \\ { \\ return {}; \\ } #define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short) \\ template <typename T, typename Tag, \\ typename = std::enable_if_t<batt_strong_typedef_supports_numerics((Tag*)nullptr)>> \\ constexpr StrongType<T, Tag> op_long(StrongType<T, Tag> a, StrongType<T, Tag> b) \\ { \\ return StrongType<T, Tag>{a.value() op_short b.value()}; \\ } BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator + , + ) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator - , - ) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator * , * ) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN ( operator / , / ) template < typename T , typename Tag > inline StrongType < T , Tag >& StrongType < T , Tag >:: operator += ( Delta d ) { static_assert ( batt_strong_typedef_supports_numerics (( Tag * ) nullptr ), \"This StrongType does not support numeric operations; see \" \"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS\" ); value_ += d ; return * this ; } template < typename T , typename Tag > inline StrongType < T , Tag >& StrongType < T , Tag >:: operator -= ( Delta d ) { static_assert ( batt_strong_typedef_supports_numerics (( Tag * ) nullptr ), \"This StrongType does not support numeric operations; see \" \"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS\" ); value_ -= d ; return * this ; } } // namespace batt #endif // BATT_STRONG_TYPEDEF_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/sub__range__seq_8hpp/","text":"batteries/seq/sub_range_seq.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::SubRangeSeq Defines \ud83d\udd17 Name BATTERIES_SEQ_SUB_RANGE_SEQ_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_SUB_RANGE_SEQ_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_SUB_RANGE_SEQ_HPP #define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/count.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { template < typename T > class SubRangeSeq { public : using Item = decltype ( std :: declval < T > (). front ()); explicit SubRangeSeq ( T && sub_range ) noexcept : sub_range_ { BATT_FORWARD ( sub_range )} { } Optional < Item > peek () { if ( sub_range_ . empty ()) { return None ; } return { sub_range_ . front ()}; } Optional < Item > next () { auto n = this -> peek (); if ( n ) { sub_range_ . drop_front (); } return n ; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename T_ > friend std :: size_t operator | ( const SubRangeSeq < T_ >& , seq :: CountBinder ); template < typename T_ , typename Fn > friend seq :: LoopControl operator | ( const SubRangeSeq < T_ >& , seq :: ForEachBinder < Fn >&& ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : T sub_range_ ; }; template < typename T , // typename = decltype ( std :: declval < T > (). front ()), typename = decltype ( std :: declval < T > (). drop_front ()) > SubRangeSeq < T > as_seq ( T && sub_range ) { return SubRangeSeq < T > { BATT_FORWARD ( sub_range )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > [[ nodiscard ]] std :: size_t operator | ( const SubRangeSeq < T >& sub_range_seq , seq :: CountBinder ) { return sub_range_seq . sub_range_ . size (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename Fn > seq :: LoopControl operator | ( const SubRangeSeq < T >& sub_range_seq , seq :: ForEachBinder < Fn >&& binder ) { for ( const auto & item : sub_range_seq . sub_range_ ) { if ( BATT_HINT_FALSE ( seq :: run_loop_fn ( binder . fn , item ) == seq :: kBreak )) { return seq :: kBreak ; } } return seq :: kContinue ; } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace batt #endif // BATTERIES_SEQ_SUB_RANGE_SEQ_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/sub_range_seq.hpp"},{"location":"_autogen/Files/sub__range__seq_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/sub__range__seq_8hpp/#classes","text":"Name class batt::SubRangeSeq","title":"Classes"},{"location":"_autogen/Files/sub__range__seq_8hpp/#defines","text":"Name BATTERIES_SEQ_SUB_RANGE_SEQ_HPP","title":"Defines"},{"location":"_autogen/Files/sub__range__seq_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/sub__range__seq_8hpp/#batteries_seq_sub_range_seq_hpp","text":"1 #define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP()","title":"BATTERIES_SEQ_SUB_RANGE_SEQ_HPP"},{"location":"_autogen/Files/sub__range__seq_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_SUB_RANGE_SEQ_HPP #define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP #include <batteries/config.hpp> // #include <batteries/optional.hpp> #include <batteries/seq/count.hpp> #include <batteries/seq/for_each.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { template < typename T > class SubRangeSeq { public : using Item = decltype ( std :: declval < T > (). front ()); explicit SubRangeSeq ( T && sub_range ) noexcept : sub_range_ { BATT_FORWARD ( sub_range )} { } Optional < Item > peek () { if ( sub_range_ . empty ()) { return None ; } return { sub_range_ . front ()}; } Optional < Item > next () { auto n = this -> peek (); if ( n ) { sub_range_ . drop_front (); } return n ; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS template < typename T_ > friend std :: size_t operator | ( const SubRangeSeq < T_ >& , seq :: CountBinder ); template < typename T_ , typename Fn > friend seq :: LoopControl operator | ( const SubRangeSeq < T_ >& , seq :: ForEachBinder < Fn >&& ); #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS private : T sub_range_ ; }; template < typename T , // typename = decltype ( std :: declval < T > (). front ()), typename = decltype ( std :: declval < T > (). drop_front ()) > SubRangeSeq < T > as_seq ( T && sub_range ) { return SubRangeSeq < T > { BATT_FORWARD ( sub_range )}; } #if BATT_SEQ_SPECIALIZE_ALGORITHMS //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T > [[ nodiscard ]] std :: size_t operator | ( const SubRangeSeq < T >& sub_range_seq , seq :: CountBinder ) { return sub_range_seq . sub_range_ . size (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename Fn > seq :: LoopControl operator | ( const SubRangeSeq < T >& sub_range_seq , seq :: ForEachBinder < Fn >&& binder ) { for ( const auto & item : sub_range_seq . sub_range_ ) { if ( BATT_HINT_FALSE ( seq :: run_loop_fn ( binder . fn , item ) == seq :: kBreak )) { return seq :: kBreak ; } } return seq :: kContinue ; } #endif // BATT_SEQ_SPECIALIZE_ALGORITHMS } // namespace batt #endif // BATTERIES_SEQ_SUB_RANGE_SEQ_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/suppress_8hpp/","text":"batteries/suppress.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATT_DO_PRAGMA (x) BATT_SUPPRESS (warn_id) Disables specific compiler warnings (by id). BATT_UNSUPPRESS () BATT_NO_OPTIMIZE Disables optimization for a single function. BATT_SUPPRESS_IF_GCC (warn_id) BATT_UNSUPPRESS_IF_GCC () BATT_SUPPRESS_IF_CLANG (warn_id) BATT_UNSUPPRESS_IF_CLANG () Macro Documentation \ud83d\udd17 BATT_DO_PRAGMA \ud83d\udd17 1 #define BATT_DO_PRAGMA(x) BATT_SUPPRESS \ud83d\udd17 1 #define BATT_SUPPRESS(warn_id) Disables specific compiler warnings (by id). Nests with BATT_UNSUPPRESS(). Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <batteries/strict.hpp> #include <batteries/suppress.hpp> // Ordinarily the function below would fail to compile because: // - foo() is declared as returning int, but never returns anything // - foo() is never used // BATT_SUPPRESS ( \"-Wreturn-type\" ) BATT_SUPPRESS ( \"-Wunused-function\" ) int foo () {} BATT_UNSUPPRESS () BATT_UNSUPPRESS () BATT_UNSUPPRESS \ud83d\udd17 1 #define BATT_UNSUPPRESS() See : BATT_SUPPRESS BATT_NO_OPTIMIZE \ud83d\udd17 1 #define BATT_NO_OPTIMIZE() Disables optimization for a single function. Example: 1 void BATT_NO_OPTIMIZE empty_function () {} BATT_SUPPRESS_IF_GCC \ud83d\udd17 1 #define BATT_SUPPRESS_IF_GCC(warn_id) BATT_UNSUPPRESS_IF_GCC \ud83d\udd17 1 #define BATT_UNSUPPRESS_IF_GCC() BATT_SUPPRESS_IF_CLANG \ud83d\udd17 1 #define BATT_SUPPRESS_IF_CLANG(warn_id) BATT_UNSUPPRESS_IF_CLANG \ud83d\udd17 1 #define BATT_UNSUPPRESS_IF_CLANG() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Copyright 2021 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> #define BATT_DO_PRAGMA(x) _Pragma(#x) // ============================================================================= // clang-format off #define BATT_SUPPRESS(warn_id) \\ _Pragma(\"GCC diagnostic push\") BATT_DO_PRAGMA(GCC diagnostic ignored warn_id) // clang-format on #define BATT_UNSUPPRESS() _Pragma(\"GCC diagnostic pop\") // ============================================================================= #if defined(__clang__) #define BATT_NO_OPTIMIZE __attribute__((optnone)) #else #define BATT_NO_OPTIMIZE __attribute__((optimize(\"O0\"))) #endif //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #if BATT_COMPILER_IS_GCC #define BATT_SUPPRESS_IF_GCC(warn_id) BATT_SUPPRESS(warn_id) #define BATT_UNSUPPRESS_IF_GCC() BATT_UNSUPPRESS() #else // BATT_COMPILER_IS_GCC #define BATT_SUPPRESS_IF_GCC(warn_id) #define BATT_UNSUPPRESS_IF_GCC() #endif // BATT_COMPILER_IS_GCC //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #if BATT_COMPILER_IS_CLANG #define BATT_SUPPRESS_IF_CLANG(warn_id) BATT_SUPPRESS(warn_id) #define BATT_UNSUPPRESS_IF_CLANG() BATT_UNSUPPRESS() #else // BATT_COMPILER_IS_CLANG #define BATT_SUPPRESS_IF_CLANG(warn_id) #define BATT_UNSUPPRESS_IF_CLANG() #endif // BATT_COMPILER_IS_CLANG Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/suppress.hpp"},{"location":"_autogen/Files/suppress_8hpp/#defines","text":"Name BATT_DO_PRAGMA (x) BATT_SUPPRESS (warn_id) Disables specific compiler warnings (by id). BATT_UNSUPPRESS () BATT_NO_OPTIMIZE Disables optimization for a single function. BATT_SUPPRESS_IF_GCC (warn_id) BATT_UNSUPPRESS_IF_GCC () BATT_SUPPRESS_IF_CLANG (warn_id) BATT_UNSUPPRESS_IF_CLANG ()","title":"Defines"},{"location":"_autogen/Files/suppress_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/suppress_8hpp/#batt_do_pragma","text":"1 #define BATT_DO_PRAGMA(x)","title":"BATT_DO_PRAGMA"},{"location":"_autogen/Files/suppress_8hpp/#batt_suppress","text":"1 #define BATT_SUPPRESS(warn_id) Disables specific compiler warnings (by id). Nests with BATT_UNSUPPRESS(). Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <batteries/strict.hpp> #include <batteries/suppress.hpp> // Ordinarily the function below would fail to compile because: // - foo() is declared as returning int, but never returns anything // - foo() is never used // BATT_SUPPRESS ( \"-Wreturn-type\" ) BATT_SUPPRESS ( \"-Wunused-function\" ) int foo () {} BATT_UNSUPPRESS () BATT_UNSUPPRESS ()","title":"BATT_SUPPRESS"},{"location":"_autogen/Files/suppress_8hpp/#batt_unsuppress","text":"1 #define BATT_UNSUPPRESS() See : BATT_SUPPRESS","title":"BATT_UNSUPPRESS"},{"location":"_autogen/Files/suppress_8hpp/#batt_no_optimize","text":"1 #define BATT_NO_OPTIMIZE() Disables optimization for a single function. Example: 1 void BATT_NO_OPTIMIZE empty_function () {}","title":"BATT_NO_OPTIMIZE"},{"location":"_autogen/Files/suppress_8hpp/#batt_suppress_if_gcc","text":"1 #define BATT_SUPPRESS_IF_GCC(warn_id)","title":"BATT_SUPPRESS_IF_GCC"},{"location":"_autogen/Files/suppress_8hpp/#batt_unsuppress_if_gcc","text":"1 #define BATT_UNSUPPRESS_IF_GCC()","title":"BATT_UNSUPPRESS_IF_GCC"},{"location":"_autogen/Files/suppress_8hpp/#batt_suppress_if_clang","text":"1 #define BATT_SUPPRESS_IF_CLANG(warn_id)","title":"BATT_SUPPRESS_IF_CLANG"},{"location":"_autogen/Files/suppress_8hpp/#batt_unsuppress_if_clang","text":"1 #define BATT_UNSUPPRESS_IF_CLANG()","title":"BATT_UNSUPPRESS_IF_CLANG"},{"location":"_autogen/Files/suppress_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // Copyright 2021 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> #define BATT_DO_PRAGMA(x) _Pragma(#x) // ============================================================================= // clang-format off #define BATT_SUPPRESS(warn_id) \\ _Pragma(\"GCC diagnostic push\") BATT_DO_PRAGMA(GCC diagnostic ignored warn_id) // clang-format on #define BATT_UNSUPPRESS() _Pragma(\"GCC diagnostic pop\") // ============================================================================= #if defined(__clang__) #define BATT_NO_OPTIMIZE __attribute__((optnone)) #else #define BATT_NO_OPTIMIZE __attribute__((optimize(\"O0\"))) #endif //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #if BATT_COMPILER_IS_GCC #define BATT_SUPPRESS_IF_GCC(warn_id) BATT_SUPPRESS(warn_id) #define BATT_UNSUPPRESS_IF_GCC() BATT_UNSUPPRESS() #else // BATT_COMPILER_IS_GCC #define BATT_SUPPRESS_IF_GCC(warn_id) #define BATT_UNSUPPRESS_IF_GCC() #endif // BATT_COMPILER_IS_GCC //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- #if BATT_COMPILER_IS_CLANG #define BATT_SUPPRESS_IF_CLANG(warn_id) BATT_SUPPRESS(warn_id) #define BATT_UNSUPPRESS_IF_CLANG() BATT_UNSUPPRESS() #else // BATT_COMPILER_IS_CLANG #define BATT_SUPPRESS_IF_CLANG(warn_id) #define BATT_UNSUPPRESS_IF_CLANG() #endif // BATT_COMPILER_IS_CLANG Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/syscall__retry_8hpp/","text":"batteries/syscall_retry.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_SYSCALL_RETRY_HPP Macro Documentation \ud83d\udd17 BATTERIES_SYSCALL_RETRY_HPP \ud83d\udd17 1 #define BATTERIES_SYSCALL_RETRY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SYSCALL_RETRY_HPP #define BATTERIES_SYSCALL_RETRY_HPP #include <batteries/config.hpp> // #include <unistd.h> namespace batt { // Executes the passed op repeatedly it doesn't fail with EINTR. // template < typename Op > auto syscall_retry ( Op && op ) { for (;;) { const auto result = op (); if ( result != -1 || errno != EINTR ) { return result ; } } } } // namespace batt #endif // BATTERIES_SYSCALL_RETRY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/syscall_retry.hpp"},{"location":"_autogen/Files/syscall__retry_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/syscall__retry_8hpp/#defines","text":"Name BATTERIES_SYSCALL_RETRY_HPP","title":"Defines"},{"location":"_autogen/Files/syscall__retry_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/syscall__retry_8hpp/#batteries_syscall_retry_hpp","text":"1 #define BATTERIES_SYSCALL_RETRY_HPP()","title":"BATTERIES_SYSCALL_RETRY_HPP"},{"location":"_autogen/Files/syscall__retry_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SYSCALL_RETRY_HPP #define BATTERIES_SYSCALL_RETRY_HPP #include <batteries/config.hpp> // #include <unistd.h> namespace batt { // Executes the passed op repeatedly it doesn't fail with EINTR. // template < typename Op > auto syscall_retry ( Op && op ) { for (;;) { const auto result = op (); if ( result != -1 || errno != EINTR ) { return result ; } } } } // namespace batt #endif // BATTERIES_SYSCALL_RETRY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/take__n_8hpp/","text":"batteries/seq/take_n.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name struct batt::seq::TakeNBinder class batt::seq::TakeN Defines \ud83d\udd17 Name BATTERIES_SEQ_TAKE_N_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_TAKE_N_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_TAKE_N_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_TAKE_N_HPP #define BATTERIES_SEQ_TAKE_N_HPP #include <batteries/config.hpp> // #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // take(n) // struct TakeNBinder { usize n ; }; inline TakeNBinder take_n ( usize n ) { return { n }; } template < typename Seq > class TakeN { public : using Item = SeqItem < Seq > ; explicit TakeN ( Seq && seq , usize n ) noexcept : seq_ ( BATT_FORWARD ( seq )), n_ { n } { } Optional < Item > peek () { if ( n_ == 0 ) { return None ; } return seq_ . peek (); } Optional < Item > next () { if ( n_ == 0 ) { return None ; } -- n_ ; return seq_ . next (); } private : Seq seq_ ; usize n_ ; }; template < typename Seq , typename = EnableIfSeq < Seq >> [[ nodiscard ]] TakeN < Seq > operator | ( Seq && seq , const TakeNBinder & binder ) { return TakeN < Seq > { BATT_FORWARD ( seq ), binder . n }; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_TAKE_N_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/take_n.hpp"},{"location":"_autogen/Files/take__n_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/take__n_8hpp/#classes","text":"Name struct batt::seq::TakeNBinder class batt::seq::TakeN","title":"Classes"},{"location":"_autogen/Files/take__n_8hpp/#defines","text":"Name BATTERIES_SEQ_TAKE_N_HPP","title":"Defines"},{"location":"_autogen/Files/take__n_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/take__n_8hpp/#batteries_seq_take_n_hpp","text":"1 #define BATTERIES_SEQ_TAKE_N_HPP()","title":"BATTERIES_SEQ_TAKE_N_HPP"},{"location":"_autogen/Files/take__n_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_TAKE_N_HPP #define BATTERIES_SEQ_TAKE_N_HPP #include <batteries/config.hpp> // #include <batteries/seq/requirements.hpp> #include <batteries/seq/seq_item.hpp> #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/utility.hpp> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // take(n) // struct TakeNBinder { usize n ; }; inline TakeNBinder take_n ( usize n ) { return { n }; } template < typename Seq > class TakeN { public : using Item = SeqItem < Seq > ; explicit TakeN ( Seq && seq , usize n ) noexcept : seq_ ( BATT_FORWARD ( seq )), n_ { n } { } Optional < Item > peek () { if ( n_ == 0 ) { return None ; } return seq_ . peek (); } Optional < Item > next () { if ( n_ == 0 ) { return None ; } -- n_ ; return seq_ . next (); } private : Seq seq_ ; usize n_ ; }; template < typename Seq , typename = EnableIfSeq < Seq >> [[ nodiscard ]] TakeN < Seq > operator | ( Seq && seq , const TakeNBinder & binder ) { return TakeN < Seq > { BATT_FORWARD ( seq ), binder . n }; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_TAKE_N_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/take__while_8hpp/","text":"batteries/seq/take_while.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::seq Classes \ud83d\udd17 Name class batt::seq::TakeWhile struct batt::seq::TakeWhileBinder Defines \ud83d\udd17 Name BATTERIES_SEQ_TAKE_WHILE_HPP Macro Documentation \ud83d\udd17 BATTERIES_SEQ_TAKE_WHILE_HPP \ud83d\udd17 1 #define BATTERIES_SEQ_TAKE_WHILE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_TAKE_WHILE_HPP #define BATTERIES_SEQ_TAKE_WHILE_HPP #include <batteries/config.hpp> // #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // take_while // template < typename Seq , typename Predicate > class TakeWhile { public : using Item = SeqItem < Seq > ; explicit TakeWhile ( Seq && seq , Predicate && predicate ) noexcept : seq_ ( BATT_FORWARD ( seq )) , predicate_ ( BATT_FORWARD ( predicate )) { } Optional < Item > peek () { auto v = seq_ . peek (); if ( v && predicate_ ( * v )) { return v ; } return None ; } Optional < Item > next () { auto v = peek (); if ( v ) { ( void ) seq_ . next (); return v ; } return None ; } private : Seq seq_ ; Predicate predicate_ ; }; template < typename Predicate > struct TakeWhileBinder { Predicate predicate ; }; template < typename Predicate > TakeWhileBinder < Predicate > take_while ( Predicate && predicate ) { return { BATT_FORWARD ( predicate )}; } template < typename Seq , typename Predicate > [[ nodiscard ]] TakeWhile < Seq , Predicate > operator | ( Seq && seq , TakeWhileBinder < Predicate >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Predicate , std :: decay_t < Predicate >> , \"Predicate functions may not be captured implicitly by reference.\" ); return TakeWhile < Seq , Predicate > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . predicate )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_TAKE_WHILE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/seq/take_while.hpp"},{"location":"_autogen/Files/take__while_8hpp/#namespaces","text":"Name batt batt::seq","title":"Namespaces"},{"location":"_autogen/Files/take__while_8hpp/#classes","text":"Name class batt::seq::TakeWhile struct batt::seq::TakeWhileBinder","title":"Classes"},{"location":"_autogen/Files/take__while_8hpp/#defines","text":"Name BATTERIES_SEQ_TAKE_WHILE_HPP","title":"Defines"},{"location":"_autogen/Files/take__while_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/take__while_8hpp/#batteries_seq_take_while_hpp","text":"1 #define BATTERIES_SEQ_TAKE_WHILE_HPP()","title":"BATTERIES_SEQ_TAKE_WHILE_HPP"},{"location":"_autogen/Files/take__while_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_SEQ_TAKE_WHILE_HPP #define BATTERIES_SEQ_TAKE_WHILE_HPP #include <batteries/config.hpp> // #include <batteries/seq/seq_item.hpp> #include <batteries/utility.hpp> #include <type_traits> namespace batt { namespace seq { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // take_while // template < typename Seq , typename Predicate > class TakeWhile { public : using Item = SeqItem < Seq > ; explicit TakeWhile ( Seq && seq , Predicate && predicate ) noexcept : seq_ ( BATT_FORWARD ( seq )) , predicate_ ( BATT_FORWARD ( predicate )) { } Optional < Item > peek () { auto v = seq_ . peek (); if ( v && predicate_ ( * v )) { return v ; } return None ; } Optional < Item > next () { auto v = peek (); if ( v ) { ( void ) seq_ . next (); return v ; } return None ; } private : Seq seq_ ; Predicate predicate_ ; }; template < typename Predicate > struct TakeWhileBinder { Predicate predicate ; }; template < typename Predicate > TakeWhileBinder < Predicate > take_while ( Predicate && predicate ) { return { BATT_FORWARD ( predicate )}; } template < typename Seq , typename Predicate > [[ nodiscard ]] TakeWhile < Seq , Predicate > operator | ( Seq && seq , TakeWhileBinder < Predicate >&& binder ) { static_assert ( std :: is_same_v < Seq , std :: decay_t < Seq >> , \"Mapped sequences may not be captured implicitly by reference.\" ); static_assert ( std :: is_same_v < Predicate , std :: decay_t < Predicate >> , \"Predicate functions may not be captured implicitly by reference.\" ); return TakeWhile < Seq , Predicate > { BATT_FORWARD ( seq ), BATT_FORWARD ( binder . predicate )}; } } // namespace seq } // namespace batt #endif // BATTERIES_SEQ_TAKE_WHILE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/task_8hpp/","text":"batteries/async/task.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/task_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/task_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/task.hpp"},{"location":"_autogen/Files/task_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/task_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/task_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/task__decl_8hpp/","text":"batteries/async/task_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Task struct batt::Task::DebugTrace Defines \ud83d\udd17 Name BATTERIES_ASYNC_TASK_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_TASK_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_TASK_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TASK_HPP #define BATTERIES_ASYNC_TASK_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/continuation.hpp> #include <batteries/async/debug_info_decl.hpp> #include <batteries/async/future_decl.hpp> #include <batteries/async/handler.hpp> #include <batteries/async/io_result.hpp> #include <batteries/case_of.hpp> #include <batteries/finally.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/optional.hpp> #include <batteries/segv.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> #ifdef __clang__ #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wswitch-enum\" #pragma clang diagnostic ignored \"-Wunused-variable\" #elif defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wswitch-enum\" #endif // __clang__ #include <boost/asio/deadline_timer.hpp> #include <boost/asio/defer.hpp> #include <boost/asio/dispatch.hpp> #include <boost/asio/executor.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/post.hpp> #include <boost/asio/read.hpp> #include <boost/asio/write.hpp> #include <boost/exception/diagnostic_information.hpp> #include <boost/preprocessor/cat.hpp> #ifdef __clang__ #pragma clang diagnostic pop #elif defined(__GNUC__) #pragma GCC diagnostic pop #endif // __clang__ #include <atomic> #include <bitset> #include <functional> #include <future> #include <utility> namespace batt { // Returns the lowest unused global thread id number; repeated calls to `next_thread_id()` will return // monotonically increasing values. // i32 next_thread_id (); // Returns a reference to the thread-local id for the current thread. // i32 & this_thread_id (); // A user-space cooperatively scheduled thread of control. // class Task : public boost :: intrusive :: list_base_hook < boost :: intrusive :: link_mode < boost :: intrusive :: auto_unlink >> { friend class DebugInfoFrame ; friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); public : using state_type = u32 ; BATT_STRONG_TYPEDEF_WITH_DEFAULT ( i32 , Priority , 0 ); BATT_STRONG_TYPEDEF ( bool , IsDone ); using executor_type = boost :: asio :: any_io_executor ; using AllTaskList = boost :: intrusive :: list < Task , boost :: intrusive :: constant_time_size < false >> ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Thread-local counter that limits stack growth while running Tasks via `dispatch`. // static usize & nesting_depth (); // The upper bound on `nesting_depth()`. When scheduling a task to run via `dispatch` would increase the // nesting depth on the current thread to greater than `kMaxNestingDepth`, `post` is used instead. // static constexpr usize kMaxNestingDepth = 8 ; // The number of bytes to statically allocate for handler memory buffers. // static constexpr usize kHandlerMemoryBytes = 128 ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Set when code within the task requests a signal, because it is awaiting some external async event. // static constexpr state_type kNeedSignal = state_type { 1 } << 0 ; // Set when the continuation generated by an `await` is invoked. // static constexpr state_type kHaveSignal = state_type { 1 } << 1 ; // Set when the task is not currently running. // static constexpr state_type kSuspended = state_type { 1 } << 2 ; // Indicates the task has finished execution. // static constexpr state_type kTerminated = state_type { 1 } << 3 ; // Set to request that the task collect a stack trace the next time it resumes. // static constexpr state_type kStackTrace = state_type { 1 } << 4 ; // Spin-lock bit to serialize access to the sleep timer member of the Task. // static constexpr state_type kSleepTimerLock = state_type { 1 } << 5 ; // Spin-lock bit to serialize access to the completions handlers list. // static constexpr state_type kCompletionHandlersLock = state_type { 1 } << 6 ; // Used to save the value of the `kSleepTimerLock` bit when the Task is suspended (e.g., in `await` or // `yield`). The Task should not hold any spinlocks while it is suspended, so we don't deadlock. Rather, // the sleep timer lock is temporarily released while suspended and then re-acquired when the task is // resumed. // static constexpr state_type kSleepTimerLockSuspend = state_type { 1 } << 7 ; // State bit to indicate that completion handlers should not be added to the list, but called immediately. // static constexpr state_type kCompletionHandlersClosed = state_type { 1 } << 8 ; // The number of state flags defined above. // static constexpr usize kNumStateFlags = 9 ; // The bitset type for a state. // using StateBitset = std :: bitset < kNumStateFlags > ; // Returns true iff the given state is *not* a suspended state. // static constexpr bool is_running_state ( state_type state ) { return ( state & kSuspended ) == 0 ; } // Returns true iff the task is not currently running, but is ready to be resumed. // static constexpr bool is_ready_state ( state_type state ) { return // The task must be suspended but not terminated. // (( state & ( kSuspended | kTerminated )) == kSuspended ) && ( // *Either* task is not waiting for a signal... // ( state & ( kNeedSignal | kHaveSignal )) == 0 || // ...*Or* task was waiting for a signal, and it received one. // ( state & ( kNeedSignal | kHaveSignal )) == ( kNeedSignal | kHaveSignal ) // ) // The stack trace flag is not set. // && (( state & kStackTrace ) == 0 ); } // Returns true if the passed state represents a fully terminated task. // static constexpr bool is_terminal_state ( state_type state ) { return ( state & ( kSuspended | kTerminated )) == ( kSuspended | kTerminated ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - struct DebugTrace { boost :: stacktrace :: stacktrace stack_trace ; std :: string debug_info ; StateBitset state_bits ; isize stack_growth_bytes ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Returns a reference to the global mutex that protects the global task list. // static std :: mutex & global_mutex (); // Returns a reference to the global task list. Must only be accessed while holding a lock on // `Task::global_mutex()`. // static AllTaskList & all_tasks (); // Returns a reference to the currently running Task, if there is one. // static Task & current (); // Returns the current task name, or \"\" if there is no current task. // static std :: string_view current_name () { auto ptr = Task :: current_ptr (); if ( ptr ) { return ptr -> name (); } return \"\" ; } static i32 current_id () { auto ptr = Task :: current_ptr (); if ( ptr ) { return ptr -> id (); } thread_local const i32 id_ = Task :: next_id (); return id_ ; } // Returns the current stack position, if currently inside a task. // static Optional < usize > current_stack_pos (); // Returns the stack position of `ptr` relative to the current stack base, if currently inside a task. // static Optional < usize > current_stack_pos_of ( const volatile void * ptr ); // Dumps stack traces and debug info from all Tasks and threads to stderr. // static i32 backtrace_all ( bool force ); // Yield control from the current Task/thread, allowing other tasks to run. // static void yield (); // Put the current Task/thread to sleep for the specified duration. // template < typename Duration = boost :: posix_time :: ptime > static ErrorCode sleep ( const Duration & duration ) { Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> sleep_impl ( duration ); } std :: this_thread :: sleep_for ( std :: chrono :: nanoseconds ( duration . total_nanoseconds ())); return ErrorCode {}; } // Suspend the current thread/Task until an asynchronous event occurs. // // The param `fn` is passed a continuation handler that will cause this Task to wake up, causing `await` // to return an instance of type `R` constructed from the arguments passed to the handler. For example, // `await` can be used to turn an async socket read into a synchronous call: // // ``` // boost::asio::ip::tcp::socket s; // // using ReadResult = std::pair<boost::system::error_code, std::size_t>; // // ReadResult r = Task::await<ReadResult>([&](auto&& handler) { // s.async_read_some(buffers, BATT_FORWARD(handler)); // }); // // if (r.first) { // std::cout << \"Error! ec=\" << r.first; // } else { // std::cout << r.second << \" bytes were read.\"; // } // ``` // template < typename R , typename Fn > static R await ( Fn && fn ) { // If there is a Task active on the current thread, use the Task impl of await. // Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> template await_impl < R > ( BATT_FORWARD ( fn )); } //--------------- // This is the generic thread (non-Task) implementation: // HandlerMemory < kHandlerMemoryBytes > handler_memory ; std :: promise < R > prom ; std :: atomic < bool > ok_to_exit { false }; BATT_FORWARD ( fn ) ( make_custom_alloc_handler ( handler_memory , [ & prom , & ok_to_exit ]( auto && ... args ) { prom . set_value ( R { BATT_FORWARD ( args )...}); ok_to_exit . store ( true ); })); auto wait_for_promise = batt :: finally ([ & ] { while ( ! ok_to_exit . load ()) { std :: this_thread :: yield (); } }); // TODO [tastolfi 2020-12-01] - detect deadlock here return prom . get_future (). get (); } // TODO [tastolfi 2021-12-22] - Implement await_with_timeout // template < typename R , typename Fn > static R await ( batt :: StaticType < R > , Fn && fn ) { return Task :: await < R > ( BATT_FORWARD ( fn )); } template < typename T > static StatusOr < T > await ( const Future < T >& future_result ) { return Task :: await < StatusOr < T >> ([ & ]( auto && handler ) { future_result . async_wait ( BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_read_some ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { s . async_read_some ( BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_read ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { boost :: asio :: async_read ( s , BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_write_some ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { s . async_write_some ( BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_write ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { boost :: asio :: async_write ( s , BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename Endpoint > static ErrorCode await_connect ( AsyncStream & s , const Endpoint & endpoint ) { return Task :: await < ErrorCode > ([ & ]( auto && handler ) { s . async_connect ( BATT_FORWARD ( endpoint ), BATT_FORWARD ( handler )); }); } template < typename AsyncAcceptor , // typename ProtocolT = typename AsyncAcceptor :: protocol_type , // typename StreamT = typename ProtocolT :: socket > static IOResult < StreamT > await_accept ( AsyncAcceptor & a ) { return Task :: await < IOResult < StreamT >> ([ & ]( auto && handler ) { a . async_accept ( BATT_FORWARD ( handler )); }); } static std :: string default_name () { return \"(anonymous)\" ; } static Priority current_priority () { Task * current_task = Task :: current_ptr (); if ( current_task == nullptr ) { return Priority { 0 }; } return current_task -> get_priority (); } static bool & inside_work_fn () { auto ptr = Task :: current_ptr (); if ( ptr ) { return ptr -> is_inside_work_fn_ ; } thread_local bool b_ = false ; return b_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Task ( const Task & ) = delete ; Task & operator = ( const Task & ) = delete ; template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , StackSize stack_size , BodyFn && body_fn ) noexcept : Task { ex , BATT_FORWARD ( body_fn ), /*name=*/ default_name (), stack_size } { } template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , BodyFn && body_fn , std :: string && name = default_name (), StackSize stack_size = StackSize { 512 * 1024 }, StackType stack_type = StackType :: kFixedSize , Optional < Priority > priority = None ) noexcept : name_ ( std :: move ( name )) , ex_ ( ex ) , priority_ { priority . value_or ( Task :: current_priority () + 100 )} { this -> self_ = callcc ( // stack_size , stack_type , [ body_fn = :: batt :: make_optional ( BATT_FORWARD ( body_fn )), this ]( Continuation && parent ) mutable { auto work_guard = boost :: asio :: make_work_guard ( this -> ex_ ); this -> pre_body_fn_entry ( std :: move ( parent )); try { ( * body_fn )(); } catch (...) { BATT_LOG ( WARNING ) << \"task fn exited via unhandled exception [task='\" << this -> name_ << \"']: \" << boost :: current_exception_diagnostic_information (); } body_fn = None ; return this -> post_body_fn_exit (); }); { std :: unique_lock < std :: mutex > lock { global_mutex ()}; all_tasks (). push_back ( * this ); } this -> handle_event ( kSuspended | kHaveSignal ); } ~ Task () noexcept ; i32 id () const { return this -> id_ ; } std :: string_view name () const { return this -> name_ ; } Priority get_priority () const { return Priority { this -> priority_ . load ()}; } void set_priority ( Priority new_priority ) { this -> priority_ . store ( new_priority ); } usize stack_pos () const ; usize stack_pos_of ( const volatile void * ptr ) const ; void join (); IsDone try_join (); bool wake (); executor_type get_executor () const { return this -> ex_ ; } IsDone is_done () const ; template < typename F = void () > void call_when_done ( F && handler ) { for (;;) { if ( this -> is_done ()) { BATT_FORWARD ( handler )(); return ; } SpinLockGuard lock { this , kCompletionHandlersLock }; if ( Task :: is_terminal_state ( lock . prior_state ()) || ( lock . prior_state () & kCompletionHandlersClosed ) != 0 ) { // It's possible that the completion handlers list was cleared out after the call to // `is_done()` above, but before we grab the spin lock. If so, keep retrying until we resolve // the race. // continue ; } push_handler ( & this -> completion_handlers_ , BATT_FORWARD ( handler )); return ; } } // =#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- DebugInfoFrame * debug_info = nullptr ; // =#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- private : //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class SpinLockGuard { public : explicit SpinLockGuard ( Task * task , state_type mask ) noexcept : task_ { task }, mask_ { mask } { this -> prior_state_ = task_ -> spin_lock ( mask ); } SpinLockGuard ( const SpinLockGuard & ) = delete ; SpinLockGuard & operator = ( const SpinLockGuard & ) = delete ; ~ SpinLockGuard () noexcept { task_ -> spin_unlock ( mask_ ); } state_type prior_state () const { return this -> prior_state_ ; } private : Task * const task_ ; const state_type mask_ ; state_type prior_state_ ; }; class Trampoline { public : static void activate_task ( Task * t ); static Task * get_current_task (); private : static Trampoline & per_thread_instance (); Task * next_to_run_ = nullptr ; Task * current_task_ = nullptr ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - static i32 next_id (); static Task * current_ptr (); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Invoked in the task's context prior to entering the task function; yields control back to the parent // context, ensuring that the task function is invoked via the executor. // void pre_body_fn_entry ( Continuation && parent ) noexcept ; // Invoked in the task's context after the task function returns. // Continuation post_body_fn_exit () noexcept ; // Suspend the task, resuming the parent context. // void yield_impl (); // Set the timer to expire after the given duration, suspending the task in a manner identical to // `await_impl`. // ErrorCode sleep_impl ( const boost :: posix_time :: time_duration & duration ); // Clears state flags kSuspended|kNeedSignal|kHaveSignal and resumes the task via its executor. If // `force_post` is true, the resume is always scheduled via boost::asio::post. Otherwise, if // Task::nesting_depth() is below the limit, boost::asio::dispatch is used instead. `observed_state` is // the last observed value of `Task::state_`. // void schedule_to_run ( state_type observed_state , bool force_post = false ); // Resumes execution of the task on the current thread; this is the normal code path, when the task // receives a signal or is ready to run. Stack traces collected on the task do not use this method; // rather they directly call resume_impl after atomically setting the kStackTrace bit (conditional on the // thread *not* being in a running, ready-to-run, or terminal state). // IsDone run (); // Switch the current thread context to the task and resume execution. // void resume_impl (); // `fn` is passed a callable acting as the continutation of the suspended Task. This continuation may // receive any set of arguments from which the await operation's result type `R` can be constructed. // template < typename R , typename Fn > R await_impl ( Fn && fn ) { Optional < R > result ; HandlerMemory < kHandlerMemoryBytes > handler_memory ; const state_type prior_state = this -> state_ . fetch_or ( kNeedSignal ); BATT_CHECK_NE (( prior_state & kHaveSignal ), kHaveSignal ) << \"prior_state=\" << StateBitset { prior_state }; BATT_FORWARD ( fn ) ( /*callback handler=*/ make_custom_alloc_handler ( handler_memory , [ this , & result ]( auto && ... args ) -> std :: enable_if_t < std :: is_constructible_v < R , decltype ( args ) && ... >> { result . emplace ( BATT_FORWARD ( args )...); this -> handle_event ( kHaveSignal ); })); // Suspend this Task. It will not be in a ready state until the kHaveSignal event has been handled. // this -> yield_impl (); return std :: move ( * result ); } // Tells the task to handle events which may affect its running/suspended state. This function is safe to // invoke inside the task or outside. `event_mask` *must* be one of: // // - kHaveSignal // - kSuspended // - kTerminated // void handle_event ( state_type event_mask ); // Acquire a spin lock on the given state bit mask. `lock_mask` must be one of: // // - kSleepTimerLock // - kCompletionHandlersLock // // Locks acquired via this function are not recursive. // state_type spin_lock ( state_type lock_mask ); // Same as `spin_lock`, except only try once to acquire the lock. Returns `true` iff the lock was // acquired. Sets `prior_state` equal to the last observed value of `state_`. // bool try_spin_lock ( state_type lock_mask , state_type & prior_state ); // Release the given spin lock bit. `lock_mask` must be a legal value passed to // `spin_lock`/`try_spin_lock`, and the calling thread must currently hold a lock on the given bit // (acquired via `spin_lock`/`try_spin_lock`). // void spin_unlock ( state_type lock_mask ); // Attempt to collect a stack trace from the task, dumping it to stderr if successful. This will fail if // the task is running, ready-to-run, or terminated. Returns true iff successful. // bool try_dump_stack_trace ( bool force ); // Activate this task via boost::asio::post. // void activate_via_post (); // Activate this task via boost::asio::dispatch. // void activate_via_dispatch (); // Create an activation completion handler for use inside `activate_via_post`, `activate_via_dispatch`, // etc. // auto make_activation_handler ( bool via_post ); // Unconditionally removes completion handlers from `this` and runs them on the current thread/task. // void run_completion_handlers (); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Process-unique serial id number for this Task; automatically assigned at construction time. // const i32 id_ = next_id (); // Human-readable (non-unique) name for this Task; passed in at construction time. // const std :: string name_ ; // The (Boost.Async) Executor used to activate/schedule this task. // executor_type ex_ ; // The most recent context from which this Task was activated/scheduled. If this is non-empty, then the // task is active/running. At most one of `scheduler_` and `self_` are non-empty at any given time. // Continuation scheduler_ ; // The current (suspended) context of this Task. If this is non-copy, then the task is suspended/waiting. // At most one of `scheduler_` and `self_` are non-empty at any given time. // Continuation self_ ; // Contains all spin lock bits and run-state information for this task. Initially set to `kNeedSignal` // because the task must receive the \"go\" signal before it can enter normal operation. // std :: atomic < state_type > state_ { kNeedSignal }; // The current advisory priority for this task. Higher numeric values signify more urgent priority. // std :: atomic < Priority :: value_type > priority_ ; Optional < boost :: asio :: deadline_timer > sleep_timer_ ; Optional < boost :: stacktrace :: stacktrace > stack_trace_ ; HandlerList <> completion_handlers_ ; HandlerMemory < kHandlerMemoryBytes > activate_memory_ ; const volatile u8 * stack_base_ = nullptr ; bool is_preempted_ = false ; bool is_inside_work_fn_ = false ; }; } // namespace batt #endif // BATTERIES_ASYNC_TASK_HPP #if BATT_HEADER_ONLY #include \"task_impl.hpp\" #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/task_decl.hpp"},{"location":"_autogen/Files/task__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/task__decl_8hpp/#classes","text":"Name class batt::Task struct batt::Task::DebugTrace","title":"Classes"},{"location":"_autogen/Files/task__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_TASK_HPP","title":"Defines"},{"location":"_autogen/Files/task__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/task__decl_8hpp/#batteries_async_task_hpp","text":"1 #define BATTERIES_ASYNC_TASK_HPP()","title":"BATTERIES_ASYNC_TASK_HPP"},{"location":"_autogen/Files/task__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TASK_HPP #define BATTERIES_ASYNC_TASK_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/async/continuation.hpp> #include <batteries/async/debug_info_decl.hpp> #include <batteries/async/future_decl.hpp> #include <batteries/async/handler.hpp> #include <batteries/async/io_result.hpp> #include <batteries/case_of.hpp> #include <batteries/finally.hpp> #include <batteries/int_types.hpp> #include <batteries/logging.hpp> #include <batteries/optional.hpp> #include <batteries/segv.hpp> #include <batteries/status.hpp> #include <batteries/utility.hpp> #ifdef __clang__ #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wswitch-enum\" #pragma clang diagnostic ignored \"-Wunused-variable\" #elif defined(__GNUC__) #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wswitch-enum\" #endif // __clang__ #include <boost/asio/deadline_timer.hpp> #include <boost/asio/defer.hpp> #include <boost/asio/dispatch.hpp> #include <boost/asio/executor.hpp> #include <boost/asio/executor_work_guard.hpp> #include <boost/asio/post.hpp> #include <boost/asio/read.hpp> #include <boost/asio/write.hpp> #include <boost/exception/diagnostic_information.hpp> #include <boost/preprocessor/cat.hpp> #ifdef __clang__ #pragma clang diagnostic pop #elif defined(__GNUC__) #pragma GCC diagnostic pop #endif // __clang__ #include <atomic> #include <bitset> #include <functional> #include <future> #include <utility> namespace batt { // Returns the lowest unused global thread id number; repeated calls to `next_thread_id()` will return // monotonically increasing values. // i32 next_thread_id (); // Returns a reference to the thread-local id for the current thread. // i32 & this_thread_id (); // A user-space cooperatively scheduled thread of control. // class Task : public boost :: intrusive :: list_base_hook < boost :: intrusive :: link_mode < boost :: intrusive :: auto_unlink >> { friend class DebugInfoFrame ; friend void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ); public : using state_type = u32 ; BATT_STRONG_TYPEDEF_WITH_DEFAULT ( i32 , Priority , 0 ); BATT_STRONG_TYPEDEF ( bool , IsDone ); using executor_type = boost :: asio :: any_io_executor ; using AllTaskList = boost :: intrusive :: list < Task , boost :: intrusive :: constant_time_size < false >> ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Thread-local counter that limits stack growth while running Tasks via `dispatch`. // static usize & nesting_depth (); // The upper bound on `nesting_depth()`. When scheduling a task to run via `dispatch` would increase the // nesting depth on the current thread to greater than `kMaxNestingDepth`, `post` is used instead. // static constexpr usize kMaxNestingDepth = 8 ; // The number of bytes to statically allocate for handler memory buffers. // static constexpr usize kHandlerMemoryBytes = 128 ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Set when code within the task requests a signal, because it is awaiting some external async event. // static constexpr state_type kNeedSignal = state_type { 1 } << 0 ; // Set when the continuation generated by an `await` is invoked. // static constexpr state_type kHaveSignal = state_type { 1 } << 1 ; // Set when the task is not currently running. // static constexpr state_type kSuspended = state_type { 1 } << 2 ; // Indicates the task has finished execution. // static constexpr state_type kTerminated = state_type { 1 } << 3 ; // Set to request that the task collect a stack trace the next time it resumes. // static constexpr state_type kStackTrace = state_type { 1 } << 4 ; // Spin-lock bit to serialize access to the sleep timer member of the Task. // static constexpr state_type kSleepTimerLock = state_type { 1 } << 5 ; // Spin-lock bit to serialize access to the completions handlers list. // static constexpr state_type kCompletionHandlersLock = state_type { 1 } << 6 ; // Used to save the value of the `kSleepTimerLock` bit when the Task is suspended (e.g., in `await` or // `yield`). The Task should not hold any spinlocks while it is suspended, so we don't deadlock. Rather, // the sleep timer lock is temporarily released while suspended and then re-acquired when the task is // resumed. // static constexpr state_type kSleepTimerLockSuspend = state_type { 1 } << 7 ; // State bit to indicate that completion handlers should not be added to the list, but called immediately. // static constexpr state_type kCompletionHandlersClosed = state_type { 1 } << 8 ; // The number of state flags defined above. // static constexpr usize kNumStateFlags = 9 ; // The bitset type for a state. // using StateBitset = std :: bitset < kNumStateFlags > ; // Returns true iff the given state is *not* a suspended state. // static constexpr bool is_running_state ( state_type state ) { return ( state & kSuspended ) == 0 ; } // Returns true iff the task is not currently running, but is ready to be resumed. // static constexpr bool is_ready_state ( state_type state ) { return // The task must be suspended but not terminated. // (( state & ( kSuspended | kTerminated )) == kSuspended ) && ( // *Either* task is not waiting for a signal... // ( state & ( kNeedSignal | kHaveSignal )) == 0 || // ...*Or* task was waiting for a signal, and it received one. // ( state & ( kNeedSignal | kHaveSignal )) == ( kNeedSignal | kHaveSignal ) // ) // The stack trace flag is not set. // && (( state & kStackTrace ) == 0 ); } // Returns true if the passed state represents a fully terminated task. // static constexpr bool is_terminal_state ( state_type state ) { return ( state & ( kSuspended | kTerminated )) == ( kSuspended | kTerminated ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - struct DebugTrace { boost :: stacktrace :: stacktrace stack_trace ; std :: string debug_info ; StateBitset state_bits ; isize stack_growth_bytes ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Returns a reference to the global mutex that protects the global task list. // static std :: mutex & global_mutex (); // Returns a reference to the global task list. Must only be accessed while holding a lock on // `Task::global_mutex()`. // static AllTaskList & all_tasks (); // Returns a reference to the currently running Task, if there is one. // static Task & current (); // Returns the current task name, or \"\" if there is no current task. // static std :: string_view current_name () { auto ptr = Task :: current_ptr (); if ( ptr ) { return ptr -> name (); } return \"\" ; } static i32 current_id () { auto ptr = Task :: current_ptr (); if ( ptr ) { return ptr -> id (); } thread_local const i32 id_ = Task :: next_id (); return id_ ; } // Returns the current stack position, if currently inside a task. // static Optional < usize > current_stack_pos (); // Returns the stack position of `ptr` relative to the current stack base, if currently inside a task. // static Optional < usize > current_stack_pos_of ( const volatile void * ptr ); // Dumps stack traces and debug info from all Tasks and threads to stderr. // static i32 backtrace_all ( bool force ); // Yield control from the current Task/thread, allowing other tasks to run. // static void yield (); // Put the current Task/thread to sleep for the specified duration. // template < typename Duration = boost :: posix_time :: ptime > static ErrorCode sleep ( const Duration & duration ) { Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> sleep_impl ( duration ); } std :: this_thread :: sleep_for ( std :: chrono :: nanoseconds ( duration . total_nanoseconds ())); return ErrorCode {}; } // Suspend the current thread/Task until an asynchronous event occurs. // // The param `fn` is passed a continuation handler that will cause this Task to wake up, causing `await` // to return an instance of type `R` constructed from the arguments passed to the handler. For example, // `await` can be used to turn an async socket read into a synchronous call: // // ``` // boost::asio::ip::tcp::socket s; // // using ReadResult = std::pair<boost::system::error_code, std::size_t>; // // ReadResult r = Task::await<ReadResult>([&](auto&& handler) { // s.async_read_some(buffers, BATT_FORWARD(handler)); // }); // // if (r.first) { // std::cout << \"Error! ec=\" << r.first; // } else { // std::cout << r.second << \" bytes were read.\"; // } // ``` // template < typename R , typename Fn > static R await ( Fn && fn ) { // If there is a Task active on the current thread, use the Task impl of await. // Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> template await_impl < R > ( BATT_FORWARD ( fn )); } //--------------- // This is the generic thread (non-Task) implementation: // HandlerMemory < kHandlerMemoryBytes > handler_memory ; std :: promise < R > prom ; std :: atomic < bool > ok_to_exit { false }; BATT_FORWARD ( fn ) ( make_custom_alloc_handler ( handler_memory , [ & prom , & ok_to_exit ]( auto && ... args ) { prom . set_value ( R { BATT_FORWARD ( args )...}); ok_to_exit . store ( true ); })); auto wait_for_promise = batt :: finally ([ & ] { while ( ! ok_to_exit . load ()) { std :: this_thread :: yield (); } }); // TODO [tastolfi 2020-12-01] - detect deadlock here return prom . get_future (). get (); } // TODO [tastolfi 2021-12-22] - Implement await_with_timeout // template < typename R , typename Fn > static R await ( batt :: StaticType < R > , Fn && fn ) { return Task :: await < R > ( BATT_FORWARD ( fn )); } template < typename T > static StatusOr < T > await ( const Future < T >& future_result ) { return Task :: await < StatusOr < T >> ([ & ]( auto && handler ) { future_result . async_wait ( BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_read_some ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { s . async_read_some ( BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_read ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { boost :: asio :: async_read ( s , BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_write_some ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { s . async_write_some ( BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename BufferSequence > static IOResult < usize > await_write ( AsyncStream & s , BufferSequence && buffers ) { return Task :: await < IOResult < usize >> ([ & ]( auto && handler ) { boost :: asio :: async_write ( s , BATT_FORWARD ( buffers ), BATT_FORWARD ( handler )); }); } template < typename AsyncStream , typename Endpoint > static ErrorCode await_connect ( AsyncStream & s , const Endpoint & endpoint ) { return Task :: await < ErrorCode > ([ & ]( auto && handler ) { s . async_connect ( BATT_FORWARD ( endpoint ), BATT_FORWARD ( handler )); }); } template < typename AsyncAcceptor , // typename ProtocolT = typename AsyncAcceptor :: protocol_type , // typename StreamT = typename ProtocolT :: socket > static IOResult < StreamT > await_accept ( AsyncAcceptor & a ) { return Task :: await < IOResult < StreamT >> ([ & ]( auto && handler ) { a . async_accept ( BATT_FORWARD ( handler )); }); } static std :: string default_name () { return \"(anonymous)\" ; } static Priority current_priority () { Task * current_task = Task :: current_ptr (); if ( current_task == nullptr ) { return Priority { 0 }; } return current_task -> get_priority (); } static bool & inside_work_fn () { auto ptr = Task :: current_ptr (); if ( ptr ) { return ptr -> is_inside_work_fn_ ; } thread_local bool b_ = false ; return b_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - Task ( const Task & ) = delete ; Task & operator = ( const Task & ) = delete ; template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , StackSize stack_size , BodyFn && body_fn ) noexcept : Task { ex , BATT_FORWARD ( body_fn ), /*name=*/ default_name (), stack_size } { } template < typename BodyFn = void () > explicit Task ( const boost :: asio :: any_io_executor & ex , BodyFn && body_fn , std :: string && name = default_name (), StackSize stack_size = StackSize { 512 * 1024 }, StackType stack_type = StackType :: kFixedSize , Optional < Priority > priority = None ) noexcept : name_ ( std :: move ( name )) , ex_ ( ex ) , priority_ { priority . value_or ( Task :: current_priority () + 100 )} { this -> self_ = callcc ( // stack_size , stack_type , [ body_fn = :: batt :: make_optional ( BATT_FORWARD ( body_fn )), this ]( Continuation && parent ) mutable { auto work_guard = boost :: asio :: make_work_guard ( this -> ex_ ); this -> pre_body_fn_entry ( std :: move ( parent )); try { ( * body_fn )(); } catch (...) { BATT_LOG ( WARNING ) << \"task fn exited via unhandled exception [task='\" << this -> name_ << \"']: \" << boost :: current_exception_diagnostic_information (); } body_fn = None ; return this -> post_body_fn_exit (); }); { std :: unique_lock < std :: mutex > lock { global_mutex ()}; all_tasks (). push_back ( * this ); } this -> handle_event ( kSuspended | kHaveSignal ); } ~ Task () noexcept ; i32 id () const { return this -> id_ ; } std :: string_view name () const { return this -> name_ ; } Priority get_priority () const { return Priority { this -> priority_ . load ()}; } void set_priority ( Priority new_priority ) { this -> priority_ . store ( new_priority ); } usize stack_pos () const ; usize stack_pos_of ( const volatile void * ptr ) const ; void join (); IsDone try_join (); bool wake (); executor_type get_executor () const { return this -> ex_ ; } IsDone is_done () const ; template < typename F = void () > void call_when_done ( F && handler ) { for (;;) { if ( this -> is_done ()) { BATT_FORWARD ( handler )(); return ; } SpinLockGuard lock { this , kCompletionHandlersLock }; if ( Task :: is_terminal_state ( lock . prior_state ()) || ( lock . prior_state () & kCompletionHandlersClosed ) != 0 ) { // It's possible that the completion handlers list was cleared out after the call to // `is_done()` above, but before we grab the spin lock. If so, keep retrying until we resolve // the race. // continue ; } push_handler ( & this -> completion_handlers_ , BATT_FORWARD ( handler )); return ; } } // =#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- DebugInfoFrame * debug_info = nullptr ; // =#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- private : //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class SpinLockGuard { public : explicit SpinLockGuard ( Task * task , state_type mask ) noexcept : task_ { task }, mask_ { mask } { this -> prior_state_ = task_ -> spin_lock ( mask ); } SpinLockGuard ( const SpinLockGuard & ) = delete ; SpinLockGuard & operator = ( const SpinLockGuard & ) = delete ; ~ SpinLockGuard () noexcept { task_ -> spin_unlock ( mask_ ); } state_type prior_state () const { return this -> prior_state_ ; } private : Task * const task_ ; const state_type mask_ ; state_type prior_state_ ; }; class Trampoline { public : static void activate_task ( Task * t ); static Task * get_current_task (); private : static Trampoline & per_thread_instance (); Task * next_to_run_ = nullptr ; Task * current_task_ = nullptr ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - static i32 next_id (); static Task * current_ptr (); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Invoked in the task's context prior to entering the task function; yields control back to the parent // context, ensuring that the task function is invoked via the executor. // void pre_body_fn_entry ( Continuation && parent ) noexcept ; // Invoked in the task's context after the task function returns. // Continuation post_body_fn_exit () noexcept ; // Suspend the task, resuming the parent context. // void yield_impl (); // Set the timer to expire after the given duration, suspending the task in a manner identical to // `await_impl`. // ErrorCode sleep_impl ( const boost :: posix_time :: time_duration & duration ); // Clears state flags kSuspended|kNeedSignal|kHaveSignal and resumes the task via its executor. If // `force_post` is true, the resume is always scheduled via boost::asio::post. Otherwise, if // Task::nesting_depth() is below the limit, boost::asio::dispatch is used instead. `observed_state` is // the last observed value of `Task::state_`. // void schedule_to_run ( state_type observed_state , bool force_post = false ); // Resumes execution of the task on the current thread; this is the normal code path, when the task // receives a signal or is ready to run. Stack traces collected on the task do not use this method; // rather they directly call resume_impl after atomically setting the kStackTrace bit (conditional on the // thread *not* being in a running, ready-to-run, or terminal state). // IsDone run (); // Switch the current thread context to the task and resume execution. // void resume_impl (); // `fn` is passed a callable acting as the continutation of the suspended Task. This continuation may // receive any set of arguments from which the await operation's result type `R` can be constructed. // template < typename R , typename Fn > R await_impl ( Fn && fn ) { Optional < R > result ; HandlerMemory < kHandlerMemoryBytes > handler_memory ; const state_type prior_state = this -> state_ . fetch_or ( kNeedSignal ); BATT_CHECK_NE (( prior_state & kHaveSignal ), kHaveSignal ) << \"prior_state=\" << StateBitset { prior_state }; BATT_FORWARD ( fn ) ( /*callback handler=*/ make_custom_alloc_handler ( handler_memory , [ this , & result ]( auto && ... args ) -> std :: enable_if_t < std :: is_constructible_v < R , decltype ( args ) && ... >> { result . emplace ( BATT_FORWARD ( args )...); this -> handle_event ( kHaveSignal ); })); // Suspend this Task. It will not be in a ready state until the kHaveSignal event has been handled. // this -> yield_impl (); return std :: move ( * result ); } // Tells the task to handle events which may affect its running/suspended state. This function is safe to // invoke inside the task or outside. `event_mask` *must* be one of: // // - kHaveSignal // - kSuspended // - kTerminated // void handle_event ( state_type event_mask ); // Acquire a spin lock on the given state bit mask. `lock_mask` must be one of: // // - kSleepTimerLock // - kCompletionHandlersLock // // Locks acquired via this function are not recursive. // state_type spin_lock ( state_type lock_mask ); // Same as `spin_lock`, except only try once to acquire the lock. Returns `true` iff the lock was // acquired. Sets `prior_state` equal to the last observed value of `state_`. // bool try_spin_lock ( state_type lock_mask , state_type & prior_state ); // Release the given spin lock bit. `lock_mask` must be a legal value passed to // `spin_lock`/`try_spin_lock`, and the calling thread must currently hold a lock on the given bit // (acquired via `spin_lock`/`try_spin_lock`). // void spin_unlock ( state_type lock_mask ); // Attempt to collect a stack trace from the task, dumping it to stderr if successful. This will fail if // the task is running, ready-to-run, or terminated. Returns true iff successful. // bool try_dump_stack_trace ( bool force ); // Activate this task via boost::asio::post. // void activate_via_post (); // Activate this task via boost::asio::dispatch. // void activate_via_dispatch (); // Create an activation completion handler for use inside `activate_via_post`, `activate_via_dispatch`, // etc. // auto make_activation_handler ( bool via_post ); // Unconditionally removes completion handlers from `this` and runs them on the current thread/task. // void run_completion_handlers (); //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Process-unique serial id number for this Task; automatically assigned at construction time. // const i32 id_ = next_id (); // Human-readable (non-unique) name for this Task; passed in at construction time. // const std :: string name_ ; // The (Boost.Async) Executor used to activate/schedule this task. // executor_type ex_ ; // The most recent context from which this Task was activated/scheduled. If this is non-empty, then the // task is active/running. At most one of `scheduler_` and `self_` are non-empty at any given time. // Continuation scheduler_ ; // The current (suspended) context of this Task. If this is non-copy, then the task is suspended/waiting. // At most one of `scheduler_` and `self_` are non-empty at any given time. // Continuation self_ ; // Contains all spin lock bits and run-state information for this task. Initially set to `kNeedSignal` // because the task must receive the \"go\" signal before it can enter normal operation. // std :: atomic < state_type > state_ { kNeedSignal }; // The current advisory priority for this task. Higher numeric values signify more urgent priority. // std :: atomic < Priority :: value_type > priority_ ; Optional < boost :: asio :: deadline_timer > sleep_timer_ ; Optional < boost :: stacktrace :: stacktrace > stack_trace_ ; HandlerList <> completion_handlers_ ; HandlerMemory < kHandlerMemoryBytes > activate_memory_ ; const volatile u8 * stack_base_ = nullptr ; bool is_preempted_ = false ; bool is_inside_work_fn_ = false ; }; } // namespace batt #endif // BATTERIES_ASYNC_TASK_HPP #if BATT_HEADER_ONLY #include \"task_impl.hpp\" #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/task__impl_8hpp/","text":"batteries/async/task_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_TASK_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_TASK_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_TASK_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TASK_IMPL_HPP #define BATTERIES_ASYNC_TASK_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> // #include <batteries/async/debug_info.hpp> #include <batteries/async/fake_time_service.hpp> #include <batteries/async/future.hpp> #include <batteries/async/watch.hpp> #include <batteries/config.hpp> #include <batteries/logging.hpp> #include <batteries/stream_util.hpp> namespace batt { BATT_INLINE_IMPL i32 next_thread_id () { static std :: atomic < i32 > id_ { 1000 }; return id_ . fetch_add ( 1 ); } BATT_INLINE_IMPL i32 & this_thread_id () { thread_local i32 id_ = next_thread_id (); return id_ ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Task static methods. //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize & Task :: nesting_depth () { thread_local usize depth_ = 0 ; return depth_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL i32 Task :: next_id () { static std :: atomic < i32 > id_ { 1 }; return id_ . fetch_add ( 1 ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task * Task :: current_ptr () { return Trampoline :: get_current_task (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task & Task :: current () { return * current_ptr (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: mutex & Task :: global_mutex () { static std :: mutex m_ ; return m_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto Task :: all_tasks () -> AllTaskList & { static AllTaskList l_ ; return l_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: yield () { Task * current_task = Task :: current_ptr (); if ( current_task ) { current_task -> yield_impl (); return ; } std :: this_thread :: yield (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ Optional < usize > Task :: current_stack_pos () { Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> stack_pos (); } return None ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ Optional < usize > Task :: current_stack_pos_of ( const volatile void * ptr ) { Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> stack_pos_of ( ptr ); } return None ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Task instance methods. //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task ::~ Task () noexcept { BATT_CHECK ( ! this -> scheduler_ ); BATT_CHECK ( ! this -> self_ ); BATT_CHECK ( is_terminal_state ( this -> state_ . load ())) << \"state=\" << StateBitset { this -> state_ . load ()}; { std :: unique_lock < std :: mutex > lock { global_mutex ()}; this -> unlink (); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: pre_body_fn_entry ( Continuation && scheduler ) noexcept { BATT_VLOG ( 1 ) << \"Task{.name=\" << this -> name_ << \",} created on thread \" << this_thread_id (); // Save the base address of the call stack. // volatile u8 base = 0 ; this -> stack_base_ = & base ; // Transfer control back to the Task ctor. This Task will be scheduled to run (activated) at the end of // the ctor. // this -> scheduler_ = scheduler . resume (); BATT_VLOG ( 1 ) << \"Task{.name=\" << this -> name_ << \",} started on thread \" << this_thread_id (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Continuation Task :: post_body_fn_exit () noexcept { Continuation parent = std :: move ( this -> scheduler_ ); this -> handle_event ( kTerminated ); return parent ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: run_completion_handlers () { BATT_CHECK ( this -> is_done ()); BATT_CHECK ( ! this -> scheduler_ ); BATT_CHECK ( ! this -> self_ ); HandlerList <> local_handlers = [ & ] { SpinLockGuard lock { this , kCompletionHandlersLock }; { // Set a state bit to make sure that there is no window of time where it is possible to add a new // handler after this lambda executes, but before `this->is_done()` returns true. // const state_type prior_state = this -> state_ . fetch_or ( kCompletionHandlersClosed ); BATT_CHECK_EQ ( prior_state & kCompletionHandlersClosed , state_type ( 0 )) << BATT_INSPECT ( Task :: StateBitset { prior_state }); } return std :: move ( this -> completion_handlers_ ); }(); invoke_all_handlers ( & local_handlers ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL ErrorCode Task :: sleep_impl ( const boost :: posix_time :: time_duration & duration ) { SpinLockGuard lock { this , kSleepTimerLock }; // The deadline_timer is lazily constructed. // if ( ! this -> sleep_timer_ ) { // First check to see if this Task's executor is configured to use the FakeTimeService. If so, do a // fake wait instead of a real one. // boost :: asio :: execution_context & context = this -> ex_ . context (); if ( boost :: asio :: has_service < FakeTimeService > ( context )) { FakeTimeService & fake_time = boost :: asio :: use_service < FakeTimeService > ( context ); const FakeTimeService :: TimePoint expires_at = fake_time . now () + duration ; return this -> await_impl < ErrorCode > ([ this , & fake_time , expires_at ]( auto && handler ) { fake_time . async_wait ( this -> ex_ , expires_at , BATT_FORWARD ( handler )); }); } this -> sleep_timer_ . emplace ( this -> ex_ ); } this -> sleep_timer_ -> expires_from_now ( duration ); return this -> await_impl < ErrorCode > ([ & ]( auto && handler ) { this -> sleep_timer_ -> async_wait ( BATT_FORWARD ( handler )); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize Task :: stack_pos () const { volatile u8 pos = 0 ; return this -> stack_pos_of ( & pos ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize Task :: stack_pos_of ( const volatile void * ptr ) const { const u8 * pos = ( const u8 * ) ptr ; if ( pos < this -> stack_base_ ) { return this -> stack_base_ - pos ; } else { return pos - this -> stack_base_ ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: join () { NoneType ignored = Task :: await < NoneType > ([ this ]( auto && handler ) { this -> call_when_done ( bind_handler ( BATT_FORWARD ( handler ), []( auto && handler ) { BATT_FORWARD ( handler )( None ); })); }); ( void ) ignored ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task :: IsDone Task :: try_join () { return this -> is_done (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task :: IsDone Task :: is_done () const { return IsDone { Task :: is_terminal_state ( this -> state_ . load ())}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool Task :: wake () { SpinLockGuard lock { this , kSleepTimerLock }; if ( this -> sleep_timer_ ) { ErrorCode ec ; this -> sleep_timer_ -> cancel ( ec ); if ( ! ec ) { return true ; } } return false ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: handle_event ( u32 event_mask ) { const u32 new_state = this -> state_ . fetch_or ( event_mask ) | event_mask ; if ( is_ready_state ( new_state )) { const bool force_post = this -> is_preempted_ ; this -> is_preempted_ = false ; this -> schedule_to_run ( new_state , force_post ); // } else if ( is_terminal_state ( new_state )) { BATT_CHECK_EQ ( Task :: current_ptr (), nullptr ); BATT_CHECK ( ! this -> self_ ); BATT_CHECK ( ! this -> scheduler_ ); BATT_VLOG ( 1 ) << \"[Task] \" << this -> name_ << \" exiting\" ; this -> run_completion_handlers (); // // IMPORTANT: there must be no access of `this` after `run_completion_handlers()`, since one of the // completion handlers may have deleted the Task object. } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: schedule_to_run ( u32 observed_state , bool force_post ) { for (;;) { if ( ! is_ready_state ( observed_state )) { return ; } const u32 target_state = observed_state & ~ ( kSuspended | kNeedSignal | kHaveSignal ); if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } BATT_CHECK ( is_ready_state ( observed_state )); BATT_CHECK ( this -> self_ ); if ( ! force_post && Task :: nesting_depth () < kMaxNestingDepth ) { ++ Task :: nesting_depth (); auto on_scope_exit = batt :: finally ([] { -- Task :: nesting_depth (); }); this -> activate_via_dispatch (); } else { this -> activate_via_post (); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task :: IsDone Task :: run () { // If the sleep timer lock was held *the last time* we yielded control, then re-acquire it now. // u32 observed_state = this -> state_ . load (); if ( observed_state & kSleepTimerLockSuspend ) { for (;;) { if ( observed_state & kSleepTimerLock ) { observed_state = this -> state_ . load (); continue ; } const u32 target_state = ( observed_state & ~ kSleepTimerLockSuspend ) | kSleepTimerLock ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } } this -> resume_impl (); // If the sleep timer lock was held *this time* when we yielded, then atomically release it and set the // kSleepTimerLockSuspend bit so we re-acquire it next time. // observed_state = this -> state_ . load (); if ( observed_state & kSleepTimerLock ) { for (;;) { const u32 target_state = ( observed_state & ~ kSleepTimerLock ) | kSleepTimerLockSuspend ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } } return IsDone {( observed_state & kTerminated ) == kTerminated }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: resume_impl () { BATT_CHECK ( this -> self_ ) << StateBitset { this -> state_ . load ()}; this -> self_ = this -> self_ . resume (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: yield_impl () { BATT_CHECK ( this -> scheduler_ ) << StateBitset { this -> state_ . load ()}; for (;;) { this -> scheduler_ = this -> scheduler_ . resume (); // If a stack trace has been requested, print it and suspend. // if ( this -> state_ & kStackTrace ) { this -> stack_trace_ . emplace (); continue ; } break ; } BATT_CHECK_EQ ( Task :: current_ptr (), this ); BATT_CHECK ( this -> scheduler_ ) << StateBitset { this -> state_ . load ()}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL u32 Task :: spin_lock ( u32 lock_mask ) { u32 prior_state = 0 ; if ( ! this -> try_spin_lock ( lock_mask , prior_state )) { for (;;) { std :: this_thread :: yield (); if ( this -> try_spin_lock ( lock_mask , prior_state )) { break ; } } } return prior_state ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool Task :: try_spin_lock ( u32 lock_mask , u32 & prior_state ) { prior_state = this -> state_ . fetch_or ( lock_mask ); return ( prior_state & lock_mask ) == 0 ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: spin_unlock ( u32 lock_mask ) { this -> state_ . fetch_and ( ~ lock_mask ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL i32 Task :: backtrace_all ( bool force ) { i32 i = 0 ; std :: unique_lock < std :: mutex > lock { global_mutex ()}; std :: cerr << std :: endl ; for ( auto & t : all_tasks ()) { std :: cerr << \"-- Task{id=\" << t . id () << \", name=\" << t . name_ << \"} -------------\" << std :: endl ; if ( ! t . try_dump_stack_trace ( force )) { std :: cerr << \" <no stack available>\" << std :: endl ; } std :: cerr << std :: endl ; ++ i ; } std :: cerr << i << \" Tasks are active\" << std :: endl ; print_all_threads_debug_info ( std :: cerr ); return i ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool Task :: try_dump_stack_trace ( bool force ) { const auto dump_debug_info = [ & ] { if ( this -> debug_info ) { std :: cerr << \"DEBUG:\" << std :: endl ; print_debug_info ( this -> debug_info , std :: cerr ); std :: cerr << std :: endl ; } }; u32 observed_state = this -> state_ . load (); const auto dump_state_bits = [ & ]( std :: ostream & out ) { if ( is_terminal_state ( observed_state )) { out << \"(terminated) \" ; } else if ( is_running_state ( observed_state )) { out << \"(running) \" ; } else if ( is_ready_state ( observed_state )) { out << \"(ready) \" ; } else if ( observed_state & kStackTrace ) { out << \"(busy) \" ; } else { out << \"(suspended) \" ; } out << \"state=\" << StateBitset { this -> state_ } << \" tims,hdlr,timr,dump,term,susp,have,need (0==running)\" ; }; for (;;) { if ( is_running_state ( observed_state ) || is_ready_state ( observed_state ) || is_terminal_state ( observed_state ) || ( observed_state & kStackTrace )) { std :: cerr << dump_state_bits << std :: endl ; if ( force ) { // This is dangerous, but sometimes you just need a clue about what is happening! // dump_debug_info (); } return false ; } const state_type target_state = observed_state | kStackTrace ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } std :: cerr << dump_state_bits << std :: endl ; dump_debug_info (); this -> resume_impl (); BATT_CHECK ( this -> stack_trace_ ); std :: cerr << * this -> stack_trace_ << std :: endl ; this -> stack_trace_ = None ; observed_state = this -> state_ . load (); for (;;) { const state_type target_state = ( observed_state & ~ kStackTrace ) | kSuspended ; BATT_CHECK ( ! is_terminal_state ( target_state )) << \"This should never happen because we check for terminal state above and calling \" \"Task::resume_impl with the StackTrace bit set should never terminate the task.\" ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { observed_state = target_state ; break ; } } if ( is_ready_state ( observed_state )) { this -> schedule_to_run ( observed_state , /*force_post=*/ true ); } return true ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto Task :: make_activation_handler ( bool via_post ) { return make_custom_alloc_handler ( this -> activate_memory_ , [ this , via_post ] { if ( via_post ) { BATT_CHECK_EQ ( Task :: current_ptr (), nullptr ); } Trampoline :: activate_task ( this ); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: activate_via_post () { boost :: asio :: post ( this -> ex_ , this -> make_activation_handler ( /*via_post=*/ true )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: activate_via_dispatch () { boost :: asio :: dispatch ( this -> ex_ , this -> make_activation_handler ( /*via_post=*/ false )); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: Trampoline :: activate_task ( Task * task_to_activate ) { auto & self = per_thread_instance (); while ( task_to_activate != nullptr ) { // If there is a task currently active on the current thread, then we will either soft-preempt it and // reschedule the current task, or queue a deferred activation of `task_to_activate` via post. // if ( self . current_task_ != nullptr ) { if ( self . current_task_ -> get_priority () >= task_to_activate -> get_priority ()) { // In this case, the current task gets to keep running on this thread because it has equal or // higher priority. // task_to_activate -> activate_via_post (); } else { // In this case, we're going to force the current task to yield and re-activate it via post. // By setting the Trampoline's `next_to_run_` to the task that has preempted it, we arrange // for `task_to_activate` to be run after the current task yields. Because there is a current // task and Task::run() may only be called from Trampoline::activate_task, there must be a // call to `activate_task` in the current task's scheduling context, so by yielding, we allow // that call to run `task_to_activate`. // BATT_CHECK_EQ ( self . next_to_run_ , nullptr ); self . next_to_run_ = task_to_activate ; self . current_task_ -> is_preempted_ = true ; self . current_task_ -> yield_impl (); } return ; // continue running `current_task`. } // else (self.current_task_ == nullptr) { BATT_CHECK_EQ ( self . current_task_ , nullptr ); self . current_task_ = task_to_activate ; auto on_scope_exit = finally ([ & self , activated_task = task_to_activate ] { BATT_CHECK_EQ ( self . current_task_ , activated_task ); self . current_task_ = nullptr ; activated_task -> handle_event ( kSuspended ); }); task_to_activate -> run (); } task_to_activate = self . next_to_run_ ; self . next_to_run_ = nullptr ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task * Task :: Trampoline :: get_current_task () { return Task :: Trampoline :: per_thread_instance (). current_task_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto Task :: Trampoline :: per_thread_instance () -> Trampoline & { thread_local Trampoline instance ; return instance ; } } // namespace batt #endif // BATTERIES_ASYNC_TASK_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/task_impl.hpp"},{"location":"_autogen/Files/task__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/task__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_TASK_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/task__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/task__impl_8hpp/#batteries_async_task_impl_hpp","text":"1 #define BATTERIES_ASYNC_TASK_IMPL_HPP()","title":"BATTERIES_ASYNC_TASK_IMPL_HPP"},{"location":"_autogen/Files/task__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TASK_IMPL_HPP #define BATTERIES_ASYNC_TASK_IMPL_HPP #include <batteries/config.hpp> // #include <batteries/async/task.hpp> // #include <batteries/async/debug_info.hpp> #include <batteries/async/fake_time_service.hpp> #include <batteries/async/future.hpp> #include <batteries/async/watch.hpp> #include <batteries/config.hpp> #include <batteries/logging.hpp> #include <batteries/stream_util.hpp> namespace batt { BATT_INLINE_IMPL i32 next_thread_id () { static std :: atomic < i32 > id_ { 1000 }; return id_ . fetch_add ( 1 ); } BATT_INLINE_IMPL i32 & this_thread_id () { thread_local i32 id_ = next_thread_id (); return id_ ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Task static methods. //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize & Task :: nesting_depth () { thread_local usize depth_ = 0 ; return depth_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL i32 Task :: next_id () { static std :: atomic < i32 > id_ { 1 }; return id_ . fetch_add ( 1 ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task * Task :: current_ptr () { return Trampoline :: get_current_task (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task & Task :: current () { return * current_ptr (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL std :: mutex & Task :: global_mutex () { static std :: mutex m_ ; return m_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto Task :: all_tasks () -> AllTaskList & { static AllTaskList l_ ; return l_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: yield () { Task * current_task = Task :: current_ptr (); if ( current_task ) { current_task -> yield_impl (); return ; } std :: this_thread :: yield (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ Optional < usize > Task :: current_stack_pos () { Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> stack_pos (); } return None ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ Optional < usize > Task :: current_stack_pos_of ( const volatile void * ptr ) { Task * current_task = Task :: current_ptr (); if ( current_task ) { return current_task -> stack_pos_of ( ptr ); } return None ; } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // Task instance methods. //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task ::~ Task () noexcept { BATT_CHECK ( ! this -> scheduler_ ); BATT_CHECK ( ! this -> self_ ); BATT_CHECK ( is_terminal_state ( this -> state_ . load ())) << \"state=\" << StateBitset { this -> state_ . load ()}; { std :: unique_lock < std :: mutex > lock { global_mutex ()}; this -> unlink (); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: pre_body_fn_entry ( Continuation && scheduler ) noexcept { BATT_VLOG ( 1 ) << \"Task{.name=\" << this -> name_ << \",} created on thread \" << this_thread_id (); // Save the base address of the call stack. // volatile u8 base = 0 ; this -> stack_base_ = & base ; // Transfer control back to the Task ctor. This Task will be scheduled to run (activated) at the end of // the ctor. // this -> scheduler_ = scheduler . resume (); BATT_VLOG ( 1 ) << \"Task{.name=\" << this -> name_ << \",} started on thread \" << this_thread_id (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Continuation Task :: post_body_fn_exit () noexcept { Continuation parent = std :: move ( this -> scheduler_ ); this -> handle_event ( kTerminated ); return parent ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: run_completion_handlers () { BATT_CHECK ( this -> is_done ()); BATT_CHECK ( ! this -> scheduler_ ); BATT_CHECK ( ! this -> self_ ); HandlerList <> local_handlers = [ & ] { SpinLockGuard lock { this , kCompletionHandlersLock }; { // Set a state bit to make sure that there is no window of time where it is possible to add a new // handler after this lambda executes, but before `this->is_done()` returns true. // const state_type prior_state = this -> state_ . fetch_or ( kCompletionHandlersClosed ); BATT_CHECK_EQ ( prior_state & kCompletionHandlersClosed , state_type ( 0 )) << BATT_INSPECT ( Task :: StateBitset { prior_state }); } return std :: move ( this -> completion_handlers_ ); }(); invoke_all_handlers ( & local_handlers ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL ErrorCode Task :: sleep_impl ( const boost :: posix_time :: time_duration & duration ) { SpinLockGuard lock { this , kSleepTimerLock }; // The deadline_timer is lazily constructed. // if ( ! this -> sleep_timer_ ) { // First check to see if this Task's executor is configured to use the FakeTimeService. If so, do a // fake wait instead of a real one. // boost :: asio :: execution_context & context = this -> ex_ . context (); if ( boost :: asio :: has_service < FakeTimeService > ( context )) { FakeTimeService & fake_time = boost :: asio :: use_service < FakeTimeService > ( context ); const FakeTimeService :: TimePoint expires_at = fake_time . now () + duration ; return this -> await_impl < ErrorCode > ([ this , & fake_time , expires_at ]( auto && handler ) { fake_time . async_wait ( this -> ex_ , expires_at , BATT_FORWARD ( handler )); }); } this -> sleep_timer_ . emplace ( this -> ex_ ); } this -> sleep_timer_ -> expires_from_now ( duration ); return this -> await_impl < ErrorCode > ([ & ]( auto && handler ) { this -> sleep_timer_ -> async_wait ( BATT_FORWARD ( handler )); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize Task :: stack_pos () const { volatile u8 pos = 0 ; return this -> stack_pos_of ( & pos ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL usize Task :: stack_pos_of ( const volatile void * ptr ) const { const u8 * pos = ( const u8 * ) ptr ; if ( pos < this -> stack_base_ ) { return this -> stack_base_ - pos ; } else { return pos - this -> stack_base_ ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: join () { NoneType ignored = Task :: await < NoneType > ([ this ]( auto && handler ) { this -> call_when_done ( bind_handler ( BATT_FORWARD ( handler ), []( auto && handler ) { BATT_FORWARD ( handler )( None ); })); }); ( void ) ignored ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task :: IsDone Task :: try_join () { return this -> is_done (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task :: IsDone Task :: is_done () const { return IsDone { Task :: is_terminal_state ( this -> state_ . load ())}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool Task :: wake () { SpinLockGuard lock { this , kSleepTimerLock }; if ( this -> sleep_timer_ ) { ErrorCode ec ; this -> sleep_timer_ -> cancel ( ec ); if ( ! ec ) { return true ; } } return false ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: handle_event ( u32 event_mask ) { const u32 new_state = this -> state_ . fetch_or ( event_mask ) | event_mask ; if ( is_ready_state ( new_state )) { const bool force_post = this -> is_preempted_ ; this -> is_preempted_ = false ; this -> schedule_to_run ( new_state , force_post ); // } else if ( is_terminal_state ( new_state )) { BATT_CHECK_EQ ( Task :: current_ptr (), nullptr ); BATT_CHECK ( ! this -> self_ ); BATT_CHECK ( ! this -> scheduler_ ); BATT_VLOG ( 1 ) << \"[Task] \" << this -> name_ << \" exiting\" ; this -> run_completion_handlers (); // // IMPORTANT: there must be no access of `this` after `run_completion_handlers()`, since one of the // completion handlers may have deleted the Task object. } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: schedule_to_run ( u32 observed_state , bool force_post ) { for (;;) { if ( ! is_ready_state ( observed_state )) { return ; } const u32 target_state = observed_state & ~ ( kSuspended | kNeedSignal | kHaveSignal ); if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } BATT_CHECK ( is_ready_state ( observed_state )); BATT_CHECK ( this -> self_ ); if ( ! force_post && Task :: nesting_depth () < kMaxNestingDepth ) { ++ Task :: nesting_depth (); auto on_scope_exit = batt :: finally ([] { -- Task :: nesting_depth (); }); this -> activate_via_dispatch (); } else { this -> activate_via_post (); } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task :: IsDone Task :: run () { // If the sleep timer lock was held *the last time* we yielded control, then re-acquire it now. // u32 observed_state = this -> state_ . load (); if ( observed_state & kSleepTimerLockSuspend ) { for (;;) { if ( observed_state & kSleepTimerLock ) { observed_state = this -> state_ . load (); continue ; } const u32 target_state = ( observed_state & ~ kSleepTimerLockSuspend ) | kSleepTimerLock ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } } this -> resume_impl (); // If the sleep timer lock was held *this time* when we yielded, then atomically release it and set the // kSleepTimerLockSuspend bit so we re-acquire it next time. // observed_state = this -> state_ . load (); if ( observed_state & kSleepTimerLock ) { for (;;) { const u32 target_state = ( observed_state & ~ kSleepTimerLock ) | kSleepTimerLockSuspend ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } } return IsDone {( observed_state & kTerminated ) == kTerminated }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: resume_impl () { BATT_CHECK ( this -> self_ ) << StateBitset { this -> state_ . load ()}; this -> self_ = this -> self_ . resume (); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: yield_impl () { BATT_CHECK ( this -> scheduler_ ) << StateBitset { this -> state_ . load ()}; for (;;) { this -> scheduler_ = this -> scheduler_ . resume (); // If a stack trace has been requested, print it and suspend. // if ( this -> state_ & kStackTrace ) { this -> stack_trace_ . emplace (); continue ; } break ; } BATT_CHECK_EQ ( Task :: current_ptr (), this ); BATT_CHECK ( this -> scheduler_ ) << StateBitset { this -> state_ . load ()}; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL u32 Task :: spin_lock ( u32 lock_mask ) { u32 prior_state = 0 ; if ( ! this -> try_spin_lock ( lock_mask , prior_state )) { for (;;) { std :: this_thread :: yield (); if ( this -> try_spin_lock ( lock_mask , prior_state )) { break ; } } } return prior_state ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool Task :: try_spin_lock ( u32 lock_mask , u32 & prior_state ) { prior_state = this -> state_ . fetch_or ( lock_mask ); return ( prior_state & lock_mask ) == 0 ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: spin_unlock ( u32 lock_mask ) { this -> state_ . fetch_and ( ~ lock_mask ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL i32 Task :: backtrace_all ( bool force ) { i32 i = 0 ; std :: unique_lock < std :: mutex > lock { global_mutex ()}; std :: cerr << std :: endl ; for ( auto & t : all_tasks ()) { std :: cerr << \"-- Task{id=\" << t . id () << \", name=\" << t . name_ << \"} -------------\" << std :: endl ; if ( ! t . try_dump_stack_trace ( force )) { std :: cerr << \" <no stack available>\" << std :: endl ; } std :: cerr << std :: endl ; ++ i ; } std :: cerr << i << \" Tasks are active\" << std :: endl ; print_all_threads_debug_info ( std :: cerr ); return i ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL bool Task :: try_dump_stack_trace ( bool force ) { const auto dump_debug_info = [ & ] { if ( this -> debug_info ) { std :: cerr << \"DEBUG:\" << std :: endl ; print_debug_info ( this -> debug_info , std :: cerr ); std :: cerr << std :: endl ; } }; u32 observed_state = this -> state_ . load (); const auto dump_state_bits = [ & ]( std :: ostream & out ) { if ( is_terminal_state ( observed_state )) { out << \"(terminated) \" ; } else if ( is_running_state ( observed_state )) { out << \"(running) \" ; } else if ( is_ready_state ( observed_state )) { out << \"(ready) \" ; } else if ( observed_state & kStackTrace ) { out << \"(busy) \" ; } else { out << \"(suspended) \" ; } out << \"state=\" << StateBitset { this -> state_ } << \" tims,hdlr,timr,dump,term,susp,have,need (0==running)\" ; }; for (;;) { if ( is_running_state ( observed_state ) || is_ready_state ( observed_state ) || is_terminal_state ( observed_state ) || ( observed_state & kStackTrace )) { std :: cerr << dump_state_bits << std :: endl ; if ( force ) { // This is dangerous, but sometimes you just need a clue about what is happening! // dump_debug_info (); } return false ; } const state_type target_state = observed_state | kStackTrace ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { break ; } } std :: cerr << dump_state_bits << std :: endl ; dump_debug_info (); this -> resume_impl (); BATT_CHECK ( this -> stack_trace_ ); std :: cerr << * this -> stack_trace_ << std :: endl ; this -> stack_trace_ = None ; observed_state = this -> state_ . load (); for (;;) { const state_type target_state = ( observed_state & ~ kStackTrace ) | kSuspended ; BATT_CHECK ( ! is_terminal_state ( target_state )) << \"This should never happen because we check for terminal state above and calling \" \"Task::resume_impl with the StackTrace bit set should never terminate the task.\" ; if ( this -> state_ . compare_exchange_weak ( observed_state , target_state )) { observed_state = target_state ; break ; } } if ( is_ready_state ( observed_state )) { this -> schedule_to_run ( observed_state , /*force_post=*/ true ); } return true ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto Task :: make_activation_handler ( bool via_post ) { return make_custom_alloc_handler ( this -> activate_memory_ , [ this , via_post ] { if ( via_post ) { BATT_CHECK_EQ ( Task :: current_ptr (), nullptr ); } Trampoline :: activate_task ( this ); }); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: activate_via_post () { boost :: asio :: post ( this -> ex_ , this -> make_activation_handler ( /*via_post=*/ true )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: activate_via_dispatch () { boost :: asio :: dispatch ( this -> ex_ , this -> make_activation_handler ( /*via_post=*/ false )); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL void Task :: Trampoline :: activate_task ( Task * task_to_activate ) { auto & self = per_thread_instance (); while ( task_to_activate != nullptr ) { // If there is a task currently active on the current thread, then we will either soft-preempt it and // reschedule the current task, or queue a deferred activation of `task_to_activate` via post. // if ( self . current_task_ != nullptr ) { if ( self . current_task_ -> get_priority () >= task_to_activate -> get_priority ()) { // In this case, the current task gets to keep running on this thread because it has equal or // higher priority. // task_to_activate -> activate_via_post (); } else { // In this case, we're going to force the current task to yield and re-activate it via post. // By setting the Trampoline's `next_to_run_` to the task that has preempted it, we arrange // for `task_to_activate` to be run after the current task yields. Because there is a current // task and Task::run() may only be called from Trampoline::activate_task, there must be a // call to `activate_task` in the current task's scheduling context, so by yielding, we allow // that call to run `task_to_activate`. // BATT_CHECK_EQ ( self . next_to_run_ , nullptr ); self . next_to_run_ = task_to_activate ; self . current_task_ -> is_preempted_ = true ; self . current_task_ -> yield_impl (); } return ; // continue running `current_task`. } // else (self.current_task_ == nullptr) { BATT_CHECK_EQ ( self . current_task_ , nullptr ); self . current_task_ = task_to_activate ; auto on_scope_exit = finally ([ & self , activated_task = task_to_activate ] { BATT_CHECK_EQ ( self . current_task_ , activated_task ); self . current_task_ = nullptr ; activated_task -> handle_event ( kSuspended ); }); task_to_activate -> run (); } task_to_activate = self . next_to_run_ ; self . next_to_run_ = nullptr ; } } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL Task * Task :: Trampoline :: get_current_task () { return Task :: Trampoline :: per_thread_instance (). current_task_ ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL auto Task :: Trampoline :: per_thread_instance () -> Trampoline & { thread_local Trampoline instance ; return instance ; } } // namespace batt #endif // BATTERIES_ASYNC_TASK_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/task__scheduler_8hpp/","text":"batteries/async/task_scheduler.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::TaskScheduler class batt::NullTaskScheduler Defines \ud83d\udd17 Name BATTERIES_ASYNC_TASK_SCHEDULER_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_TASK_SCHEDULER_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_TASK_SCHEDULER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TASK_SCHEDULER_HPP #define BATTERIES_ASYNC_TASK_SCHEDULER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <boost/asio/any_io_executor.hpp> namespace batt { class TaskScheduler { public : TaskScheduler ( const TaskScheduler & ) = delete ; TaskScheduler & operator = ( const TaskScheduler & ) = delete ; virtual ~ TaskScheduler () = default ; // Select an executor to run a new task. // virtual boost :: asio :: any_io_executor schedule_task () = 0 ; // Request shutdown of all threads/executors owned by this scheduler. Does not wait for shutdown // to complete; see TaskScheduler::join(). // virtual void halt () = 0 ; // Wait for shutdown of all threads/executors owned by this scheduler. Does not initiate shutdown // per se, just waits for shutdown to complete. See TaskScheduler::halt(). // virtual void join () = 0 ; protected : TaskScheduler () = default ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // TaskScheduler implementation that does not schedule anything (`schedule_task` panics). // class NullTaskScheduler : public TaskScheduler { public : static NullTaskScheduler & instance () { static NullTaskScheduler instance_ ; return instance_ ; } NullTaskScheduler () { } boost :: asio :: any_io_executor schedule_task () override { BATT_PANIC () << \"The NullTaskScheduler can not schedule anything! Use a different implementation.\" ; BATT_UNREACHABLE (); } void halt () override { } void join () override { } }; } // namespace batt #endif // BATTERIES_ASYNC_TASK_SCHEDULER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/task_scheduler.hpp"},{"location":"_autogen/Files/task__scheduler_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/task__scheduler_8hpp/#classes","text":"Name class batt::TaskScheduler class batt::NullTaskScheduler","title":"Classes"},{"location":"_autogen/Files/task__scheduler_8hpp/#defines","text":"Name BATTERIES_ASYNC_TASK_SCHEDULER_HPP","title":"Defines"},{"location":"_autogen/Files/task__scheduler_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/task__scheduler_8hpp/#batteries_async_task_scheduler_hpp","text":"1 #define BATTERIES_ASYNC_TASK_SCHEDULER_HPP()","title":"BATTERIES_ASYNC_TASK_SCHEDULER_HPP"},{"location":"_autogen/Files/task__scheduler_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TASK_SCHEDULER_HPP #define BATTERIES_ASYNC_TASK_SCHEDULER_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <boost/asio/any_io_executor.hpp> namespace batt { class TaskScheduler { public : TaskScheduler ( const TaskScheduler & ) = delete ; TaskScheduler & operator = ( const TaskScheduler & ) = delete ; virtual ~ TaskScheduler () = default ; // Select an executor to run a new task. // virtual boost :: asio :: any_io_executor schedule_task () = 0 ; // Request shutdown of all threads/executors owned by this scheduler. Does not wait for shutdown // to complete; see TaskScheduler::join(). // virtual void halt () = 0 ; // Wait for shutdown of all threads/executors owned by this scheduler. Does not initiate shutdown // per se, just waits for shutdown to complete. See TaskScheduler::halt(). // virtual void join () = 0 ; protected : TaskScheduler () = default ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // TaskScheduler implementation that does not schedule anything (`schedule_task` panics). // class NullTaskScheduler : public TaskScheduler { public : static NullTaskScheduler & instance () { static NullTaskScheduler instance_ ; return instance_ ; } NullTaskScheduler () { } boost :: asio :: any_io_executor schedule_task () override { BATT_PANIC () << \"The NullTaskScheduler can not schedule anything! Use a different implementation.\" ; BATT_UNREACHABLE (); } void halt () override { } void join () override { } }; } // namespace batt #endif // BATTERIES_ASYNC_TASK_SCHEDULER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/token_8hpp/","text":"batteries/token.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_TOKEN_HPP Macro Documentation \ud83d\udd17 BATTERIES_TOKEN_HPP \ud83d\udd17 1 #define BATTERIES_TOKEN_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_TOKEN_HPP #define BATTERIES_TOKEN_HPP #include <batteries/config.hpp> // #include <boost/flyweight.hpp> #include <boost/flyweight/no_tracking.hpp> namespace batt { using Token = boost :: flyweights :: flyweight < std :: string , boost :: flyweights :: no_tracking > ; } // namespace batt #endif // BATTERIES_TOKEN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/token.hpp"},{"location":"_autogen/Files/token_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/token_8hpp/#defines","text":"Name BATTERIES_TOKEN_HPP","title":"Defines"},{"location":"_autogen/Files/token_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/token_8hpp/#batteries_token_hpp","text":"1 #define BATTERIES_TOKEN_HPP()","title":"BATTERIES_TOKEN_HPP"},{"location":"_autogen/Files/token_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_TOKEN_HPP #define BATTERIES_TOKEN_HPP #include <batteries/config.hpp> // #include <boost/flyweight.hpp> #include <boost/flyweight/no_tracking.hpp> namespace batt { using Token = boost :: flyweights :: flyweight < std :: string , boost :: flyweights :: no_tracking > ; } // namespace batt #endif // BATTERIES_TOKEN_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/tuples_8hpp/","text":"batteries/tuples.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name struct batt::MorphTuple struct batt::MorphTuple< TemplateT, std::tuple< Ts... > > struct batt::TupleIndexOf struct batt::TupleIndexOf< std::tuple<>, T > struct batt::TupleIndexOf< std::tuple< T, Rest... >, T > struct batt::TupleIndexOf< std::tuple< First, Rest... >, T > struct batt::MapTuple struct batt::MapTuple< PerTypeT, std::tuple< Ts... > > Defines \ud83d\udd17 Name BATTERIES_TUPLES_HPP Macro Documentation \ud83d\udd17 BATTERIES_TUPLES_HPP \ud83d\udd17 1 #define BATTERIES_TUPLES_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_TUPLES_HPP #define BATTERIES_TUPLES_HPP #include <batteries/config.hpp> // #include <batteries/type_traits.hpp> #include <tuple> #include <type_traits> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Take the element types of a tuple and apply them as the args to some other // template to produce a new type. // // Example: // ```c++ // using MyTypes = std::tuple<int, char, std::string>; // using Morphed = batt::MorphTuple_t<std::variant, MyTypes>; // // static_assert(std::is_same_v<Morphed, std::variant<int, char, std::string>>, \"\"); // ``` // template < template < typename ... > class TemplateT , typename TupleT > struct MorphTuple ; template < template < typename ... > class TemplateT , typename ... Ts > struct MorphTuple < TemplateT , std :: tuple < Ts ... >> : StaticType < TemplateT < Ts ... >> { }; template < template < typename ... > class TemplateT , typename TupleT > using MorphTuple_t = typename MorphTuple < TemplateT , std :: decay_t < TupleT >>:: type ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename TupleT , typename T > struct TupleIndexOf ; template < typename T > struct TupleIndexOf < std :: tuple <> , T > : BATT_STATIC_VALUE ( 0u ) { }; template < typename T , typename ... Rest > struct TupleIndexOf < std :: tuple < T , Rest ... > , T > : BATT_STATIC_VALUE ( 0u ) { }; template < typename T , typename First , typename ... Rest > struct TupleIndexOf < std :: tuple < First , Rest ... > , T > : BATT_STATIC_VALUE (( 1u + TupleIndexOf < std :: tuple < Rest ... > , T >:: value )) { }; template < typename TupleT , typename T > constexpr auto TupleIndexOf_v = TupleIndexOf < std :: decay_t < TupleT > , T >:: value ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < template < typename > class PerTypeT , typename TupleT > struct MapTuple ; template < template < typename > class PerTypeT , typename ... Ts > struct MapTuple < PerTypeT , std :: tuple < Ts ... >> : StaticType < std :: tuple < PerTypeT < Ts > ... >> { }; template < template < typename > class PerTypeT , typename TupleT > using MapTuple_t = typename MapTuple < PerTypeT , std :: decay_t < TupleT >>:: type ; } // namespace batt #endif // BATTERIES_TUPLES_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/tuples.hpp"},{"location":"_autogen/Files/tuples_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/tuples_8hpp/#classes","text":"Name struct batt::MorphTuple struct batt::MorphTuple< TemplateT, std::tuple< Ts... > > struct batt::TupleIndexOf struct batt::TupleIndexOf< std::tuple<>, T > struct batt::TupleIndexOf< std::tuple< T, Rest... >, T > struct batt::TupleIndexOf< std::tuple< First, Rest... >, T > struct batt::MapTuple struct batt::MapTuple< PerTypeT, std::tuple< Ts... > >","title":"Classes"},{"location":"_autogen/Files/tuples_8hpp/#defines","text":"Name BATTERIES_TUPLES_HPP","title":"Defines"},{"location":"_autogen/Files/tuples_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/tuples_8hpp/#batteries_tuples_hpp","text":"1 #define BATTERIES_TUPLES_HPP()","title":"BATTERIES_TUPLES_HPP"},{"location":"_autogen/Files/tuples_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_TUPLES_HPP #define BATTERIES_TUPLES_HPP #include <batteries/config.hpp> // #include <batteries/type_traits.hpp> #include <tuple> #include <type_traits> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // Take the element types of a tuple and apply them as the args to some other // template to produce a new type. // // Example: // ```c++ // using MyTypes = std::tuple<int, char, std::string>; // using Morphed = batt::MorphTuple_t<std::variant, MyTypes>; // // static_assert(std::is_same_v<Morphed, std::variant<int, char, std::string>>, \"\"); // ``` // template < template < typename ... > class TemplateT , typename TupleT > struct MorphTuple ; template < template < typename ... > class TemplateT , typename ... Ts > struct MorphTuple < TemplateT , std :: tuple < Ts ... >> : StaticType < TemplateT < Ts ... >> { }; template < template < typename ... > class TemplateT , typename TupleT > using MorphTuple_t = typename MorphTuple < TemplateT , std :: decay_t < TupleT >>:: type ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < typename TupleT , typename T > struct TupleIndexOf ; template < typename T > struct TupleIndexOf < std :: tuple <> , T > : BATT_STATIC_VALUE ( 0u ) { }; template < typename T , typename ... Rest > struct TupleIndexOf < std :: tuple < T , Rest ... > , T > : BATT_STATIC_VALUE ( 0u ) { }; template < typename T , typename First , typename ... Rest > struct TupleIndexOf < std :: tuple < First , Rest ... > , T > : BATT_STATIC_VALUE (( 1u + TupleIndexOf < std :: tuple < Rest ... > , T >:: value )) { }; template < typename TupleT , typename T > constexpr auto TupleIndexOf_v = TupleIndexOf < std :: decay_t < TupleT > , T >:: value ; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - template < template < typename > class PerTypeT , typename TupleT > struct MapTuple ; template < template < typename > class PerTypeT , typename ... Ts > struct MapTuple < PerTypeT , std :: tuple < Ts ... >> : StaticType < std :: tuple < PerTypeT < Ts > ... >> { }; template < template < typename > class PerTypeT , typename TupleT > using MapTuple_t = typename MapTuple < PerTypeT , std :: decay_t < TupleT >>:: type ; } // namespace batt #endif // BATTERIES_TUPLES_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/type__erasure_8hpp/","text":"batteries/type_erasure.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::AbstractValue class batt::AbstractValuePointer class batt::TypeErasedStorageBase class batt::TypeErasedStorage class batt::AbstractValueImpl Defines \ud83d\udd17 Name BATTERIES_TYPE_ERASURE_HPP Macro Documentation \ud83d\udd17 BATTERIES_TYPE_ERASURE_HPP \ud83d\udd17 1 #define BATTERIES_TYPE_ERASURE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_TYPE_ERASURE_HPP #define BATTERIES_TYPE_ERASURE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/buffer.hpp> #include <batteries/cpu_align.hpp> #include <batteries/type_traits.hpp> #include <memory> #include <utility> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > class AbstractValue { public : AbstractValue ( const AbstractValue & ) = delete ; AbstractValue & operator = ( const AbstractValue & ) = delete ; virtual ~ AbstractValue () = default ; virtual T * copy_to ( MutableBuffer memory ) = 0 ; virtual T * move_to ( MutableBuffer memory ) = 0 ; protected : AbstractValue () = default ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > class AbstractValuePointer : public AbstractValue < T > { public : explicit AbstractValuePointer ( std :: unique_ptr < T > ptr ) noexcept : ptr_ { std :: move ( ptr )} { } T * copy_to ( MutableBuffer memory ) override { return this -> ptr_ -> copy_to ( memory ); } T * move_to ( MutableBuffer memory ) override { BATT_CHECK_GE ( memory . size (), sizeof ( AbstractValuePointer )); auto * copy_of_this = new ( memory . data ()) AbstractValuePointer { std :: move ( this -> ptr_ )}; return copy_of_this -> ptr_ . get (); } private : std :: unique_ptr < T > ptr_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename AbstractType , template < typename > class TypedImpl > class TypeErasedStorageBase { public : template < typename T , typename ... Args > static AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf , Args && ... args ) { static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"Use std::reference_wrapper (std::ref) to wrap a reference.\" ); // If the impl will fit in the inline buffer, then just use placement new. // if ( sizeof ( TypedImpl < T > ) <= buf . size ()) { return new ( buf . data ()) TypedImpl < T > { BATT_FORWARD ( args )...}; } auto p_impl = std :: make_unique < TypedImpl < T >> ( BATT_FORWARD ( args )...); AbstractType * retval = p_impl . get (); new ( buf . data ()) AbstractValuePointer < AbstractType > { std :: move ( p_impl )}; return retval ; } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename AbstractType , template < typename > class TypedImpl , usize kReservedSize = kCpuCacheLineSize - sizeof ( void * ), usize kAlignment = kCpuCacheLineSize > class TypeErasedStorage : public TypeErasedStorageBase < AbstractType , TypedImpl > { public : static_assert ( kReservedSize >= sizeof ( AbstractValuePointer < AbstractType > ), \"kReservedSize must be large enough to fit a pointer\" ); static constexpr usize reserved_size = kReservedSize ; //+++++++++++-+-+--+----- --- -- - - - - TypeErasedStorage () noexcept : impl_ { nullptr } { } template < typename T , typename ... Args > /*implicit*/ TypeErasedStorage ( StaticType < T > static_type , Args && ... args ) noexcept : impl_ { nullptr } { this -> emplace ( static_type , BATT_FORWARD ( args )...); } TypeErasedStorage ( const TypeErasedStorage & other ) : impl_ { other . impl_ -> copy_to ( this -> memory ())} { } TypeErasedStorage ( TypeErasedStorage && other ) : impl_ { other . get_abstract () -> move_to ( this -> memory ())} { other . clear (); } ~ TypeErasedStorage () noexcept { this -> clear (); } //+++++++++++-+-+--+----- --- -- - - - - TypeErasedStorage & operator = ( TypeErasedStorage && other ) { if ( BATT_HINT_TRUE ( this != & other )) { this -> clear (); this -> impl_ = other . get_abstract () -> move_to ( this -> memory ()); other . clear (); } return * this ; } TypeErasedStorage & operator = ( const TypeErasedStorage & other ) { if ( BATT_HINT_TRUE ( this != & other )) { this -> clear (); this -> impl_ = other . impl_ -> copy_to ( this -> memory ()); } return * this ; } //+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename ... Args > AbstractType * emplace ( StaticType < T > static_type , Args && ... args ) { this -> clear (); return this -> construct ( static_type , BATT_FORWARD ( args )...); } template < typename T , typename U , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < U > , std :: reference_wrapper < T >>>> AbstractType * emplace ( StaticType < U > , const std :: reference_wrapper < T >& ref ) { this -> clear (); return this -> construct ( StaticType < std :: reference_wrapper < T >> {}, make_copy ( ref )); } void clear () { if ( this -> impl_ ) { this -> get_abstract () ->~ AbstractValue < AbstractType > (); this -> impl_ = nullptr ; } } MutableBuffer memory () { return MutableBuffer { & this -> storage_ , sizeof ( this -> storage_ )}; } AbstractType * get () const { return this -> impl_ ; } AbstractValue < AbstractType >* get_abstract () { return reinterpret_cast < AbstractValue < AbstractType >*> ( & this -> storage_ ); } bool is_valid () const { return this -> impl_ != nullptr ; } explicit operator bool () const { return this -> is_valid (); } AbstractType * operator -> () const { return this -> get (); } AbstractType & operator * () const { BATT_ASSERT_NOT_NULLTPR ( this -> get ()); return * this -> get (); } private : template < typename T , typename ... Args > AbstractType * construct ( StaticType < T > static_type , Args && ... args ) { static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"Use std::reference_wrapper (std::ref) to wrap a reference.\" ); this -> impl_ = TypeErasedStorage :: construct_impl ( static_type , this -> memory (), BATT_FORWARD ( args )...); return this -> impl_ ; } std :: aligned_storage_t < kReservedSize , kAlignment > storage_ ; AbstractType * impl_ = nullptr ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename AbstractType , template < typename > class TypedImpl , typename T > class AbstractValueImpl : public AbstractType { public : //+++++++++++-+-+--+----- --- -- - - - - explicit AbstractValueImpl ( T && obj ) : obj_ { BATT_FORWARD ( obj )} { static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"Use std::reference_wrapper (std::ref) to wrap a reference.\" ); static_assert ( std :: is_base_of_v < AbstractValue < AbstractType > , AbstractType > , \"AbstractType must be derived from AbstractValue<AbstractType>.\" ); static_assert ( std :: is_base_of_v < AbstractValueImpl , TypedImpl < T >> , \"TypedImpl<T> must be derived from AbstractValueImpl.\" ); } //+++++++++++-+-+--+----- --- -- - - - - // AbstractValue interface AbstractType * copy_to ( MutableBuffer memory ) override { return TypeErasedStorageBase < AbstractType , TypedImpl >:: construct_impl ( StaticType < T > {}, memory , batt :: make_copy ( this -> obj_ )); } AbstractType * move_to ( MutableBuffer memory ) override { return TypeErasedStorageBase < AbstractType , TypedImpl >:: construct_impl ( StaticType < T > {}, memory , std :: move ( this -> obj_ )); } //+++++++++++-+-+--+----- --- -- - - - - protected : T obj_ ; }; } // namespace batt #endif // BATTERIES_TYPE_ERASURE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/type_erasure.hpp"},{"location":"_autogen/Files/type__erasure_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/type__erasure_8hpp/#classes","text":"Name class batt::AbstractValue class batt::AbstractValuePointer class batt::TypeErasedStorageBase class batt::TypeErasedStorage class batt::AbstractValueImpl","title":"Classes"},{"location":"_autogen/Files/type__erasure_8hpp/#defines","text":"Name BATTERIES_TYPE_ERASURE_HPP","title":"Defines"},{"location":"_autogen/Files/type__erasure_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/type__erasure_8hpp/#batteries_type_erasure_hpp","text":"1 #define BATTERIES_TYPE_ERASURE_HPP()","title":"BATTERIES_TYPE_ERASURE_HPP"},{"location":"_autogen/Files/type__erasure_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_TYPE_ERASURE_HPP #define BATTERIES_TYPE_ERASURE_HPP #include <batteries/config.hpp> // #include <batteries/assert.hpp> #include <batteries/buffer.hpp> #include <batteries/cpu_align.hpp> #include <batteries/type_traits.hpp> #include <memory> #include <utility> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > class AbstractValue { public : AbstractValue ( const AbstractValue & ) = delete ; AbstractValue & operator = ( const AbstractValue & ) = delete ; virtual ~ AbstractValue () = default ; virtual T * copy_to ( MutableBuffer memory ) = 0 ; virtual T * move_to ( MutableBuffer memory ) = 0 ; protected : AbstractValue () = default ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename T > class AbstractValuePointer : public AbstractValue < T > { public : explicit AbstractValuePointer ( std :: unique_ptr < T > ptr ) noexcept : ptr_ { std :: move ( ptr )} { } T * copy_to ( MutableBuffer memory ) override { return this -> ptr_ -> copy_to ( memory ); } T * move_to ( MutableBuffer memory ) override { BATT_CHECK_GE ( memory . size (), sizeof ( AbstractValuePointer )); auto * copy_of_this = new ( memory . data ()) AbstractValuePointer { std :: move ( this -> ptr_ )}; return copy_of_this -> ptr_ . get (); } private : std :: unique_ptr < T > ptr_ ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename AbstractType , template < typename > class TypedImpl > class TypeErasedStorageBase { public : template < typename T , typename ... Args > static AbstractType * construct_impl ( StaticType < T > , MutableBuffer buf , Args && ... args ) { static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"Use std::reference_wrapper (std::ref) to wrap a reference.\" ); // If the impl will fit in the inline buffer, then just use placement new. // if ( sizeof ( TypedImpl < T > ) <= buf . size ()) { return new ( buf . data ()) TypedImpl < T > { BATT_FORWARD ( args )...}; } auto p_impl = std :: make_unique < TypedImpl < T >> ( BATT_FORWARD ( args )...); AbstractType * retval = p_impl . get (); new ( buf . data ()) AbstractValuePointer < AbstractType > { std :: move ( p_impl )}; return retval ; } }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename AbstractType , template < typename > class TypedImpl , usize kReservedSize = kCpuCacheLineSize - sizeof ( void * ), usize kAlignment = kCpuCacheLineSize > class TypeErasedStorage : public TypeErasedStorageBase < AbstractType , TypedImpl > { public : static_assert ( kReservedSize >= sizeof ( AbstractValuePointer < AbstractType > ), \"kReservedSize must be large enough to fit a pointer\" ); static constexpr usize reserved_size = kReservedSize ; //+++++++++++-+-+--+----- --- -- - - - - TypeErasedStorage () noexcept : impl_ { nullptr } { } template < typename T , typename ... Args > /*implicit*/ TypeErasedStorage ( StaticType < T > static_type , Args && ... args ) noexcept : impl_ { nullptr } { this -> emplace ( static_type , BATT_FORWARD ( args )...); } TypeErasedStorage ( const TypeErasedStorage & other ) : impl_ { other . impl_ -> copy_to ( this -> memory ())} { } TypeErasedStorage ( TypeErasedStorage && other ) : impl_ { other . get_abstract () -> move_to ( this -> memory ())} { other . clear (); } ~ TypeErasedStorage () noexcept { this -> clear (); } //+++++++++++-+-+--+----- --- -- - - - - TypeErasedStorage & operator = ( TypeErasedStorage && other ) { if ( BATT_HINT_TRUE ( this != & other )) { this -> clear (); this -> impl_ = other . get_abstract () -> move_to ( this -> memory ()); other . clear (); } return * this ; } TypeErasedStorage & operator = ( const TypeErasedStorage & other ) { if ( BATT_HINT_TRUE ( this != & other )) { this -> clear (); this -> impl_ = other . impl_ -> copy_to ( this -> memory ()); } return * this ; } //+++++++++++-+-+--+----- --- -- - - - - template < typename T , typename ... Args > AbstractType * emplace ( StaticType < T > static_type , Args && ... args ) { this -> clear (); return this -> construct ( static_type , BATT_FORWARD ( args )...); } template < typename T , typename U , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < U > , std :: reference_wrapper < T >>>> AbstractType * emplace ( StaticType < U > , const std :: reference_wrapper < T >& ref ) { this -> clear (); return this -> construct ( StaticType < std :: reference_wrapper < T >> {}, make_copy ( ref )); } void clear () { if ( this -> impl_ ) { this -> get_abstract () ->~ AbstractValue < AbstractType > (); this -> impl_ = nullptr ; } } MutableBuffer memory () { return MutableBuffer { & this -> storage_ , sizeof ( this -> storage_ )}; } AbstractType * get () const { return this -> impl_ ; } AbstractValue < AbstractType >* get_abstract () { return reinterpret_cast < AbstractValue < AbstractType >*> ( & this -> storage_ ); } bool is_valid () const { return this -> impl_ != nullptr ; } explicit operator bool () const { return this -> is_valid (); } AbstractType * operator -> () const { return this -> get (); } AbstractType & operator * () const { BATT_ASSERT_NOT_NULLTPR ( this -> get ()); return * this -> get (); } private : template < typename T , typename ... Args > AbstractType * construct ( StaticType < T > static_type , Args && ... args ) { static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"Use std::reference_wrapper (std::ref) to wrap a reference.\" ); this -> impl_ = TypeErasedStorage :: construct_impl ( static_type , this -> memory (), BATT_FORWARD ( args )...); return this -> impl_ ; } std :: aligned_storage_t < kReservedSize , kAlignment > storage_ ; AbstractType * impl_ = nullptr ; }; //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // template < typename AbstractType , template < typename > class TypedImpl , typename T > class AbstractValueImpl : public AbstractType { public : //+++++++++++-+-+--+----- --- -- - - - - explicit AbstractValueImpl ( T && obj ) : obj_ { BATT_FORWARD ( obj )} { static_assert ( std :: is_same_v < std :: decay_t < T > , T > , \"Use std::reference_wrapper (std::ref) to wrap a reference.\" ); static_assert ( std :: is_base_of_v < AbstractValue < AbstractType > , AbstractType > , \"AbstractType must be derived from AbstractValue<AbstractType>.\" ); static_assert ( std :: is_base_of_v < AbstractValueImpl , TypedImpl < T >> , \"TypedImpl<T> must be derived from AbstractValueImpl.\" ); } //+++++++++++-+-+--+----- --- -- - - - - // AbstractValue interface AbstractType * copy_to ( MutableBuffer memory ) override { return TypeErasedStorageBase < AbstractType , TypedImpl >:: construct_impl ( StaticType < T > {}, memory , batt :: make_copy ( this -> obj_ )); } AbstractType * move_to ( MutableBuffer memory ) override { return TypeErasedStorageBase < AbstractType , TypedImpl >:: construct_impl ( StaticType < T > {}, memory , std :: move ( this -> obj_ )); } //+++++++++++-+-+--+----- --- -- - - - - protected : T obj_ ; }; } // namespace batt #endif // BATTERIES_TYPE_ERASURE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/type__traits_8hpp/","text":"batteries/type_traits.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::IsVariant struct batt::IsVariant< std::variant< Ts... > > struct batt::IsTuple struct batt::IsTuple< std::tuple< Ts... > > struct batt::StaticType struct batt::StaticValue struct batt::DecayRValueRefImpl Defines \ud83d\udd17 Name BATT_STATIC_VALUE (expr) Macro Documentation \ud83d\udd17 BATT_STATIC_VALUE \ud83d\udd17 1 #define BATT_STATIC_VALUE(expr) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <cxxabi.h> #include <iterator> #include <tuple> #include <type_traits> #include <variant> namespace batt { // ============================================================================= // IsCallable<Fn, Args...> // // Type alias for std::true_type if `Fn` is callable with `Args...`. // Type alias for std::false_type otherwise. // namespace detail { template < typename Fn , typename ... Args , typename Result = std :: result_of_t < Fn ( Args ...) >> std :: true_type is_callable_impl ( void * ); template < typename Fn , typename ... Args > std :: false_type is_callable_impl (...); } // namespace detail template < typename Fn , typename ... Args > using IsCallable = decltype ( detail :: is_callable_impl < Fn , Args ... > ( nullptr )); // ============================================================================= // IsPrintable<T> // namespace detail { template < typename T , typename Result = decltype ( std :: declval < std :: ostream &> () << std :: declval < T > ()) > std :: true_type is_printable_impl ( void * ); template < typename Fn , typename ... Args > std :: false_type is_printable_impl (...); } // namespace detail template < typename T > using IsPrintable = decltype ( detail :: is_printable_impl < T > ( nullptr )); // ============================================================================= // IsRange<T> // // Type alias for std::true_type if `T` is a range type. // Type alias for std::false_type otherwise. // namespace detail { template < typename T , typename BeginIter = decltype ( std :: begin ( std :: declval < T > ())), typename EndIter = decltype ( std :: end ( std :: declval < T > ())), typename = std :: enable_if_t < std :: is_same < BeginIter , EndIter > {} >> std :: true_type is_range_impl ( void * ); template < typename T > std :: false_type is_range_impl (...); } // namespace detail template < typename T > using IsRange = decltype ( detail :: is_range_impl < T > ( nullptr )); // ============================================================================= // IsVariant<T> // // Derives std::true_type if `T` is a std::variant type. // Derives std::false_type otherwise. // template < typename T > struct IsVariant : std :: false_type { }; template < typename ... Ts > struct IsVariant < std :: variant < Ts ... >> : std :: true_type { }; // ============================================================================= // IsTuple<T> // // Derives std::true_type if `T` is a std::tuple type. // Derives std::false_type otherwise. // template < typename T > struct IsTuple : std :: false_type { }; template < typename ... Ts > struct IsTuple < std :: tuple < Ts ... >> : std :: true_type { }; // ============================================================================= // StaticType<T> // template < typename T > struct StaticType { using type = T ; }; template < typename L , typename R > inline constexpr bool operator == ( StaticType < L > , StaticType < R > ) { return std :: is_same_v < L , R > ; } template < typename L , typename R > inline constexpr bool operator != ( StaticType < L > , StaticType < R > ) { return ! std :: is_same_v < L , R > ; } static_assert ( StaticType < int > {} == StaticType < int > {}, \"\" ); static_assert ( StaticType < int > {} != StaticType < unsigned > {}, \"\" ); // ============================================================================= // template < typename T , T kValue > struct StaticValue { static constexpr T value = kValue ; constexpr StaticValue () = default ; constexpr operator T () const { return value ; } }; #define BATT_STATIC_VALUE(expr) ::batt::StaticValue<decltype(expr), (expr)> // ============================================================================= // Enables/disables a constructor template when the argments do not cause it to // shadow a built-in method. // // Usage: // // ``` // class MyType { // public: // template <typename... Args, typename = batt::EnableIfNoShadow<MyType, Args...>> // MyType(Args&&... args) { /* something other than copy/move/default */ } // }; // ``` // template < typename T , typename ... Args > using EnableIfNoShadow = std :: enable_if_t <! std :: is_same < std :: tuple < std :: decay_t < T >*> , std :: tuple < std :: decay_t < Args >* ... >> {} // Copy or move ctor && ! std :: is_same < std :: tuple <> , std :: tuple < std :: decay_t < Args >* ... >> {} // Default ctor > ; // ============================================================================= // Decays T iff it is an rvalue reference type. // template < typename T > struct DecayRValueRefImpl : std :: conditional_t < // /*if */ std :: is_rvalue_reference_v < T > , /* then */ std :: decay < T > , /* else */ batt :: StaticType < T >> { }; template < typename T > using DecayRValueRef = typename DecayRValueRefImpl < T >:: type ; // ============================================================================= // CanBeEqCompared<T, U> - std::true_type or std::false_type depending on whether types `T` and `U` can be // equality-compared. // namespace detail { template < typename T , typename U , typename = decltype ( std :: declval < const T &> () == std :: declval < const U &> ()) > std :: true_type can_be_eq_compared_helper ( const T * , const U * ) { return {}; } template < typename T , typename U > std :: false_type can_be_eq_compared_helper (...) { return {}; } } // namespace detail template < typename T , typename U = T > using CanBeEqCompared = decltype ( detail :: can_be_eq_compared_helper < T , U > ( nullptr , nullptr )); // ============================================================================= template < typename T > auto name_of ( batt :: StaticType < T > = {}) { int status = -1 ; return abi :: __cxa_demangle ( typeid ( T ). name (), NULL , NULL , & status ); } // ============================================================================= } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/type_traits.hpp"},{"location":"_autogen/Files/type__traits_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/type__traits_8hpp/#classes","text":"Name struct batt::IsVariant struct batt::IsVariant< std::variant< Ts... > > struct batt::IsTuple struct batt::IsTuple< std::tuple< Ts... > > struct batt::StaticType struct batt::StaticValue struct batt::DecayRValueRefImpl","title":"Classes"},{"location":"_autogen/Files/type__traits_8hpp/#defines","text":"Name BATT_STATIC_VALUE (expr)","title":"Defines"},{"location":"_autogen/Files/type__traits_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/type__traits_8hpp/#batt_static_value","text":"1 #define BATT_STATIC_VALUE(expr)","title":"BATT_STATIC_VALUE"},{"location":"_autogen/Files/type__traits_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <cxxabi.h> #include <iterator> #include <tuple> #include <type_traits> #include <variant> namespace batt { // ============================================================================= // IsCallable<Fn, Args...> // // Type alias for std::true_type if `Fn` is callable with `Args...`. // Type alias for std::false_type otherwise. // namespace detail { template < typename Fn , typename ... Args , typename Result = std :: result_of_t < Fn ( Args ...) >> std :: true_type is_callable_impl ( void * ); template < typename Fn , typename ... Args > std :: false_type is_callable_impl (...); } // namespace detail template < typename Fn , typename ... Args > using IsCallable = decltype ( detail :: is_callable_impl < Fn , Args ... > ( nullptr )); // ============================================================================= // IsPrintable<T> // namespace detail { template < typename T , typename Result = decltype ( std :: declval < std :: ostream &> () << std :: declval < T > ()) > std :: true_type is_printable_impl ( void * ); template < typename Fn , typename ... Args > std :: false_type is_printable_impl (...); } // namespace detail template < typename T > using IsPrintable = decltype ( detail :: is_printable_impl < T > ( nullptr )); // ============================================================================= // IsRange<T> // // Type alias for std::true_type if `T` is a range type. // Type alias for std::false_type otherwise. // namespace detail { template < typename T , typename BeginIter = decltype ( std :: begin ( std :: declval < T > ())), typename EndIter = decltype ( std :: end ( std :: declval < T > ())), typename = std :: enable_if_t < std :: is_same < BeginIter , EndIter > {} >> std :: true_type is_range_impl ( void * ); template < typename T > std :: false_type is_range_impl (...); } // namespace detail template < typename T > using IsRange = decltype ( detail :: is_range_impl < T > ( nullptr )); // ============================================================================= // IsVariant<T> // // Derives std::true_type if `T` is a std::variant type. // Derives std::false_type otherwise. // template < typename T > struct IsVariant : std :: false_type { }; template < typename ... Ts > struct IsVariant < std :: variant < Ts ... >> : std :: true_type { }; // ============================================================================= // IsTuple<T> // // Derives std::true_type if `T` is a std::tuple type. // Derives std::false_type otherwise. // template < typename T > struct IsTuple : std :: false_type { }; template < typename ... Ts > struct IsTuple < std :: tuple < Ts ... >> : std :: true_type { }; // ============================================================================= // StaticType<T> // template < typename T > struct StaticType { using type = T ; }; template < typename L , typename R > inline constexpr bool operator == ( StaticType < L > , StaticType < R > ) { return std :: is_same_v < L , R > ; } template < typename L , typename R > inline constexpr bool operator != ( StaticType < L > , StaticType < R > ) { return ! std :: is_same_v < L , R > ; } static_assert ( StaticType < int > {} == StaticType < int > {}, \"\" ); static_assert ( StaticType < int > {} != StaticType < unsigned > {}, \"\" ); // ============================================================================= // template < typename T , T kValue > struct StaticValue { static constexpr T value = kValue ; constexpr StaticValue () = default ; constexpr operator T () const { return value ; } }; #define BATT_STATIC_VALUE(expr) ::batt::StaticValue<decltype(expr), (expr)> // ============================================================================= // Enables/disables a constructor template when the argments do not cause it to // shadow a built-in method. // // Usage: // // ``` // class MyType { // public: // template <typename... Args, typename = batt::EnableIfNoShadow<MyType, Args...>> // MyType(Args&&... args) { /* something other than copy/move/default */ } // }; // ``` // template < typename T , typename ... Args > using EnableIfNoShadow = std :: enable_if_t <! std :: is_same < std :: tuple < std :: decay_t < T >*> , std :: tuple < std :: decay_t < Args >* ... >> {} // Copy or move ctor && ! std :: is_same < std :: tuple <> , std :: tuple < std :: decay_t < Args >* ... >> {} // Default ctor > ; // ============================================================================= // Decays T iff it is an rvalue reference type. // template < typename T > struct DecayRValueRefImpl : std :: conditional_t < // /*if */ std :: is_rvalue_reference_v < T > , /* then */ std :: decay < T > , /* else */ batt :: StaticType < T >> { }; template < typename T > using DecayRValueRef = typename DecayRValueRefImpl < T >:: type ; // ============================================================================= // CanBeEqCompared<T, U> - std::true_type or std::false_type depending on whether types `T` and `U` can be // equality-compared. // namespace detail { template < typename T , typename U , typename = decltype ( std :: declval < const T &> () == std :: declval < const U &> ()) > std :: true_type can_be_eq_compared_helper ( const T * , const U * ) { return {}; } template < typename T , typename U > std :: false_type can_be_eq_compared_helper (...) { return {}; } } // namespace detail template < typename T , typename U = T > using CanBeEqCompared = decltype ( detail :: can_be_eq_compared_helper < T , U > ( nullptr , nullptr )); // ============================================================================= template < typename T > auto name_of ( batt :: StaticType < T > = {}) { int status = -1 ; return abi :: __cxa_demangle ( typeid ( T ). name (), NULL , NULL , & status ); } // ============================================================================= } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/types_8hpp/","text":"batteries/async/types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_TYPES_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_TYPES_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_TYPES_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TYPES_HPP #define BATTERIES_ASYNC_TYPES_HPP namespace batt { enum struct WaitForResource : bool { kFalse = false , kTrue = true , }; } // namespace batt #endif // BATTERIES_ASYNC_TYPES_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/types.hpp"},{"location":"_autogen/Files/types_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/types_8hpp/#defines","text":"Name BATTERIES_ASYNC_TYPES_HPP","title":"Defines"},{"location":"_autogen/Files/types_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/types_8hpp/#batteries_async_types_hpp","text":"1 #define BATTERIES_ASYNC_TYPES_HPP()","title":"BATTERIES_ASYNC_TYPES_HPP"},{"location":"_autogen/Files/types_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_TYPES_HPP #define BATTERIES_ASYNC_TYPES_HPP namespace batt { enum struct WaitForResource : bool { kFalse = false , kTrue = true , }; } // namespace batt #endif // BATTERIES_ASYNC_TYPES_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/url__parse_8hpp/","text":"batteries/url_parse.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt batt::detail Classes \ud83d\udd17 Name struct batt::UrlParse Defines \ud83d\udd17 Name BATTERIES_URL_PARSE_HPP Macro Documentation \ud83d\udd17 BATTERIES_URL_PARSE_HPP \ud83d\udd17 1 #define BATTERIES_URL_PARSE_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_URL_PARSE_HPP #define BATTERIES_URL_PARSE_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/status.hpp> #include <batteries/stream_util.hpp> #include <string_view> namespace batt { struct UrlParse { std :: string_view scheme ; std :: string_view user ; std :: string_view host ; Optional < i64 > port ; std :: string_view path ; std :: string_view query ; std :: string_view fragment ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator == ( const UrlParse & left , const UrlParse & right ) { return left . scheme == right . scheme // && left . user == right . user // && left . host == right . host // && left . port == right . port // && left . path == right . path // && left . query == right . query // && left . fragment == right . fragment ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator != ( const UrlParse & left , const UrlParse & right ) { return ! ( left == right ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: ostream & operator << ( std :: ostream & out , const UrlParse & t ) { return out << \"UrlParse{.scheme=\" << t . scheme // << \", .user=\" << t . user // << \", .host=\" << t . host // << \", .port=\" << t . port // << \", .path=\" << t . path // << \", .query=\" << t . query // << \", .fragment=\" << t . fragment // << \",}\" ; } namespace detail { StatusOr < UrlParse > parse_url_auth ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_host ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_port ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_path ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_query ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_fragment ( std :: string_view url , UrlParse && parse ); } // namespace detail inline StatusOr < UrlParse > parse_url ( std :: string_view url ) { UrlParse parse ; if ( BATT_HINT_FALSE ( url . empty ())) { return parse ; } if ( url . front () == '/' ) { return detail :: parse_url_path ( url , std :: move ( parse )); } const usize scheme_delim = url . find ( ':' ); if ( scheme_delim == std :: string_view :: npos ) { parse . scheme = url ; return parse ; } parse . scheme = url . substr ( 0 , scheme_delim ); url . remove_prefix ( scheme_delim + 1 ); if ( url . size () > 1 && url [ 0 ] == '/' && url [ 1 ] == '/' ) { url . remove_prefix ( 2 ); return detail :: parse_url_auth ( url , std :: move ( parse )); } return detail :: parse_url_path ( url , std :: move ( parse )); } //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ namespace detail { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_auth ( std :: string_view url , UrlParse && parse ) { if ( ! url . empty () && url . front () == '[' ) { return parse_url_host ( url , std :: move ( parse )); } const usize auth_first_delim = url . find_first_of ( \"@:/\" ); if ( auth_first_delim == std :: string_view :: npos ) { parse . host = url ; return std :: move ( parse ); } switch ( url [ auth_first_delim ]) { case '@' : parse . user = url . substr ( 0 , auth_first_delim ); url . remove_prefix ( parse . user . size () + /*strlen(\"@\")=*/ 1 ); return parse_url_host ( url , std :: move ( parse )); case ':' : parse . user = {}; parse . host = url . substr ( 0 , auth_first_delim ); url . remove_prefix ( parse . host . size () + /*strlen(\":\")=*/ 1 ); return parse_url_port ( url , std :: move ( parse )); case '/' : parse . user = {}; parse . host = url . substr ( 0 , auth_first_delim ); parse . port = None ; url . remove_prefix ( parse . host . size ()); return parse_url_path ( url , std :: move ( parse )); default : BATT_PANIC () << \"This should not be possible!\" ; } return { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_host ( std :: string_view url , UrlParse && parse ) { if ( url . empty ()) { return std :: move ( parse ); } if ( url . front () == '[' ) { url . remove_prefix ( /*strlen(\"[\")=*/ 1 ); const usize host_delim = url . find_first_of ( \"]\" ); if ( host_delim == std :: string_view :: npos ) { return { StatusCode :: kInvalidArgument }; } parse . host = url . substr ( 0 , host_delim ); url . remove_prefix ( host_delim + /*strlen(\"]\")=*/ 1 ); } else { const usize host_delim = url . find_first_of ( \":/\" ); if ( host_delim == std :: string_view :: npos ) { parse . host = url ; return std :: move ( parse ); } parse . host = url . substr ( 0 , host_delim ); url . remove_prefix ( host_delim ); } if ( url . empty ()) { return std :: move ( parse ); } switch ( url . front ()) { case ':' : url . remove_prefix ( 1 ); return parse_url_port ( url , std :: move ( parse )); case '/' : return parse_url_path ( url , std :: move ( parse )); default : BATT_PANIC () << \"This should not be possible!\" ; } return { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_port ( std :: string_view url , UrlParse && parse ) { const std :: string_view port_str = url . substr ( 0 , url . find ( '/' )); parse . port = from_string < i64 > ( std :: string { port_str }); if ( ! parse . port ) { return { StatusCode :: kInvalidArgument }; } url . remove_prefix ( port_str . size ()); return parse_url_path ( url , std :: move ( parse )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_path ( std :: string_view url , UrlParse && parse ) { const usize path_delim = url . find_first_of ( \"?#\" ); if ( path_delim == std :: string_view :: npos ) { parse . path = url ; return std :: move ( parse ); } parse . path = std :: string_view { url . data (), path_delim }; url . remove_prefix ( path_delim ); switch ( url . front ()) { case '?' : url . remove_prefix ( 1 ); return parse_url_query ( url , std :: move ( parse )); case '#' : url . remove_prefix ( 1 ); parse . fragment = url ; return std :: move ( parse ); default : BATT_PANIC () << \"This should not be possible!\" ; } return { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_query ( std :: string_view url , UrlParse && parse ) { const usize query_delim = url . find ( '#' ); if ( query_delim == std :: string_view :: npos ) { parse . query = url ; } else { parse . query = url . substr ( 0 , query_delim ); parse . fragment = url . substr ( query_delim + 1 ); } return std :: move ( parse ); } } // namespace detail } // namespace batt #endif // BATTERIES_URL_PARSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/url_parse.hpp"},{"location":"_autogen/Files/url__parse_8hpp/#namespaces","text":"Name batt batt::detail","title":"Namespaces"},{"location":"_autogen/Files/url__parse_8hpp/#classes","text":"Name struct batt::UrlParse","title":"Classes"},{"location":"_autogen/Files/url__parse_8hpp/#defines","text":"Name BATTERIES_URL_PARSE_HPP","title":"Defines"},{"location":"_autogen/Files/url__parse_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/url__parse_8hpp/#batteries_url_parse_hpp","text":"1 #define BATTERIES_URL_PARSE_HPP()","title":"BATTERIES_URL_PARSE_HPP"},{"location":"_autogen/Files/url__parse_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_URL_PARSE_HPP #define BATTERIES_URL_PARSE_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <batteries/optional.hpp> #include <batteries/status.hpp> #include <batteries/stream_util.hpp> #include <string_view> namespace batt { struct UrlParse { std :: string_view scheme ; std :: string_view user ; std :: string_view host ; Optional < i64 > port ; std :: string_view path ; std :: string_view query ; std :: string_view fragment ; }; //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator == ( const UrlParse & left , const UrlParse & right ) { return left . scheme == right . scheme // && left . user == right . user // && left . host == right . host // && left . port == right . port // && left . path == right . path // && left . query == right . query // && left . fragment == right . fragment ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline bool operator != ( const UrlParse & left , const UrlParse & right ) { return ! ( left == right ); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline std :: ostream & operator << ( std :: ostream & out , const UrlParse & t ) { return out << \"UrlParse{.scheme=\" << t . scheme // << \", .user=\" << t . user // << \", .host=\" << t . host // << \", .port=\" << t . port // << \", .path=\" << t . path // << \", .query=\" << t . query // << \", .fragment=\" << t . fragment // << \",}\" ; } namespace detail { StatusOr < UrlParse > parse_url_auth ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_host ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_port ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_path ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_query ( std :: string_view url , UrlParse && parse ); StatusOr < UrlParse > parse_url_fragment ( std :: string_view url , UrlParse && parse ); } // namespace detail inline StatusOr < UrlParse > parse_url ( std :: string_view url ) { UrlParse parse ; if ( BATT_HINT_FALSE ( url . empty ())) { return parse ; } if ( url . front () == '/' ) { return detail :: parse_url_path ( url , std :: move ( parse )); } const usize scheme_delim = url . find ( ':' ); if ( scheme_delim == std :: string_view :: npos ) { parse . scheme = url ; return parse ; } parse . scheme = url . substr ( 0 , scheme_delim ); url . remove_prefix ( scheme_delim + 1 ); if ( url . size () > 1 && url [ 0 ] == '/' && url [ 1 ] == '/' ) { url . remove_prefix ( 2 ); return detail :: parse_url_auth ( url , std :: move ( parse )); } return detail :: parse_url_path ( url , std :: move ( parse )); } //#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++ namespace detail { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_auth ( std :: string_view url , UrlParse && parse ) { if ( ! url . empty () && url . front () == '[' ) { return parse_url_host ( url , std :: move ( parse )); } const usize auth_first_delim = url . find_first_of ( \"@:/\" ); if ( auth_first_delim == std :: string_view :: npos ) { parse . host = url ; return std :: move ( parse ); } switch ( url [ auth_first_delim ]) { case '@' : parse . user = url . substr ( 0 , auth_first_delim ); url . remove_prefix ( parse . user . size () + /*strlen(\"@\")=*/ 1 ); return parse_url_host ( url , std :: move ( parse )); case ':' : parse . user = {}; parse . host = url . substr ( 0 , auth_first_delim ); url . remove_prefix ( parse . host . size () + /*strlen(\":\")=*/ 1 ); return parse_url_port ( url , std :: move ( parse )); case '/' : parse . user = {}; parse . host = url . substr ( 0 , auth_first_delim ); parse . port = None ; url . remove_prefix ( parse . host . size ()); return parse_url_path ( url , std :: move ( parse )); default : BATT_PANIC () << \"This should not be possible!\" ; } return { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_host ( std :: string_view url , UrlParse && parse ) { if ( url . empty ()) { return std :: move ( parse ); } if ( url . front () == '[' ) { url . remove_prefix ( /*strlen(\"[\")=*/ 1 ); const usize host_delim = url . find_first_of ( \"]\" ); if ( host_delim == std :: string_view :: npos ) { return { StatusCode :: kInvalidArgument }; } parse . host = url . substr ( 0 , host_delim ); url . remove_prefix ( host_delim + /*strlen(\"]\")=*/ 1 ); } else { const usize host_delim = url . find_first_of ( \":/\" ); if ( host_delim == std :: string_view :: npos ) { parse . host = url ; return std :: move ( parse ); } parse . host = url . substr ( 0 , host_delim ); url . remove_prefix ( host_delim ); } if ( url . empty ()) { return std :: move ( parse ); } switch ( url . front ()) { case ':' : url . remove_prefix ( 1 ); return parse_url_port ( url , std :: move ( parse )); case '/' : return parse_url_path ( url , std :: move ( parse )); default : BATT_PANIC () << \"This should not be possible!\" ; } return { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_port ( std :: string_view url , UrlParse && parse ) { const std :: string_view port_str = url . substr ( 0 , url . find ( '/' )); parse . port = from_string < i64 > ( std :: string { port_str }); if ( ! parse . port ) { return { StatusCode :: kInvalidArgument }; } url . remove_prefix ( port_str . size ()); return parse_url_path ( url , std :: move ( parse )); } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_path ( std :: string_view url , UrlParse && parse ) { const usize path_delim = url . find_first_of ( \"?#\" ); if ( path_delim == std :: string_view :: npos ) { parse . path = url ; return std :: move ( parse ); } parse . path = std :: string_view { url . data (), path_delim }; url . remove_prefix ( path_delim ); switch ( url . front ()) { case '?' : url . remove_prefix ( 1 ); return parse_url_query ( url , std :: move ( parse )); case '#' : url . remove_prefix ( 1 ); parse . fragment = url ; return std :: move ( parse ); default : BATT_PANIC () << \"This should not be possible!\" ; } return { StatusCode :: kInternal }; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // inline StatusOr < UrlParse > parse_url_query ( std :: string_view url , UrlParse && parse ) { const usize query_delim = url . find ( '#' ); if ( query_delim == std :: string_view :: npos ) { parse . query = url ; } else { parse . query = url . substr ( 0 , query_delim ); parse . fragment = url . substr ( query_delim + 1 ); } return std :: move ( parse ); } } // namespace detail } // namespace batt #endif // BATTERIES_URL_PARSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/utility_8hpp/","text":"batteries/utility.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATT_FORWARD (x) Perfectly forward x . BATT_SINK (expr) BATT_WARN_UNUSED_RESULT Warn/error if a function's return value is ignored: BATT_OVERLOADS_OF (name) Roughly approximates the ability to treat a named overload set as though it were an actual callable function. Macro Documentation \ud83d\udd17 BATT_FORWARD \ud83d\udd17 1 #define BATT_FORWARD(x) Perfectly forward x . Avoids having to include redundant information in a std::forward expression. BATT_SINK \ud83d\udd17 1 #define BATT_SINK(expr) BATT_WARN_UNUSED_RESULT \ud83d\udd17 1 #define BATT_WARN_UNUSED_RESULT() Warn/error if a function's return value is ignored: 1 int fn_returning_status_code () BATT_WARN_UNUSED_RESULT ; BATT_OVERLOADS_OF \ud83d\udd17 1 #define BATT_OVERLOADS_OF(name) Roughly approximates the ability to treat a named overload set as though it were an actual callable function. Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <utility> namespace batt { // ============================================================================= #define BATT_FORWARD(x) std::forward<decltype(x)>(x) template < typename T > T make_copy ( const T & value ) { return value ; } // BATT_SINK(val) - turns into BATT_FORWARD(val) if val is an rvalue-expression; otherwise, turns into // batt::make_copy(val). // template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , std :: decay_t < T >>>> T && sink ( T && value ) { return std :: forward < T > ( value ); } template < typename T > T sink ( const T & value ) { return make_copy ( value ); } #define BATT_SINK(expr) ::batt::sink(BATT_FORWARD(expr)) #if defined(__has_attribute) && __has_attribute(nodiscard) #define BATT_WARN_UNUSED_RESULT [[nodiscard]] #elif defined(__has_attribute) && __has_attribute(nodiscard) #define BATT_WARN_UNUSED_RESULT __attribute__((warn_unused_result)) #else #define BATT_WARN_UNUSED_RESULT #endif #define BATT_OVERLOADS_OF(name) \\ [](auto&&... args) noexcept(noexcept(name(BATT_FORWARD(args)...))) -> decltype(auto) { \\ return name(BATT_FORWARD(args)...); \\ } #ifdef __clang__ #define BATT_MAYBE_UNUSED __attribute__((unused)) //#define BATT_MAYBE_UNUSED [[maybe_unused]] #elif defined(__GNUC__) #define BATT_MAYBE_UNUSED __attribute__((unused)) #pragma GCC diagnostic ignored \"-Wattributes\" #endif template < typename T , typename = std :: enable_if_t <! std :: is_same_v < T , void >>> T make_default () { return T {}; } template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , void >> , typename = void > void make_default () { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > T && unwrap_ref ( T && obj ) { return BATT_FORWARD ( obj ); } template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T >& wrapper ) { return wrapper . get (); } template < typename T > T & unwrap_ref ( std :: reference_wrapper < T >&& wrapper ) { return wrapper . get (); } template < typename T > T & unwrap_ref ( std :: reference_wrapper < T >& wrapper ) { return wrapper . get (); } template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T >&& wrapper ) { return wrapper . get (); } template < typename T > using UnwrapRefType = decltype ( unwrap_ref ( std :: declval < T > ())); } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/utility.hpp"},{"location":"_autogen/Files/utility_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/utility_8hpp/#defines","text":"Name BATT_FORWARD (x) Perfectly forward x . BATT_SINK (expr) BATT_WARN_UNUSED_RESULT Warn/error if a function's return value is ignored: BATT_OVERLOADS_OF (name) Roughly approximates the ability to treat a named overload set as though it were an actual callable function.","title":"Defines"},{"location":"_autogen/Files/utility_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/utility_8hpp/#batt_forward","text":"1 #define BATT_FORWARD(x) Perfectly forward x . Avoids having to include redundant information in a std::forward expression.","title":"BATT_FORWARD"},{"location":"_autogen/Files/utility_8hpp/#batt_sink","text":"1 #define BATT_SINK(expr)","title":"BATT_SINK"},{"location":"_autogen/Files/utility_8hpp/#batt_warn_unused_result","text":"1 #define BATT_WARN_UNUSED_RESULT() Warn/error if a function's return value is ignored: 1 int fn_returning_status_code () BATT_WARN_UNUSED_RESULT ;","title":"BATT_WARN_UNUSED_RESULT"},{"location":"_autogen/Files/utility_8hpp/#batt_overloads_of","text":"1 #define BATT_OVERLOADS_OF(name) Roughly approximates the ability to treat a named overload set as though it were an actual callable function.","title":"BATT_OVERLOADS_OF"},{"location":"_autogen/Files/utility_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #include <batteries/config.hpp> // #include <utility> namespace batt { // ============================================================================= #define BATT_FORWARD(x) std::forward<decltype(x)>(x) template < typename T > T make_copy ( const T & value ) { return value ; } // BATT_SINK(val) - turns into BATT_FORWARD(val) if val is an rvalue-expression; otherwise, turns into // batt::make_copy(val). // template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , std :: decay_t < T >>>> T && sink ( T && value ) { return std :: forward < T > ( value ); } template < typename T > T sink ( const T & value ) { return make_copy ( value ); } #define BATT_SINK(expr) ::batt::sink(BATT_FORWARD(expr)) #if defined(__has_attribute) && __has_attribute(nodiscard) #define BATT_WARN_UNUSED_RESULT [[nodiscard]] #elif defined(__has_attribute) && __has_attribute(nodiscard) #define BATT_WARN_UNUSED_RESULT __attribute__((warn_unused_result)) #else #define BATT_WARN_UNUSED_RESULT #endif #define BATT_OVERLOADS_OF(name) \\ [](auto&&... args) noexcept(noexcept(name(BATT_FORWARD(args)...))) -> decltype(auto) { \\ return name(BATT_FORWARD(args)...); \\ } #ifdef __clang__ #define BATT_MAYBE_UNUSED __attribute__((unused)) //#define BATT_MAYBE_UNUSED [[maybe_unused]] #elif defined(__GNUC__) #define BATT_MAYBE_UNUSED __attribute__((unused)) #pragma GCC diagnostic ignored \"-Wattributes\" #endif template < typename T , typename = std :: enable_if_t <! std :: is_same_v < T , void >>> T make_default () { return T {}; } template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , void >> , typename = void > void make_default () { } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > T && unwrap_ref ( T && obj ) { return BATT_FORWARD ( obj ); } template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T >& wrapper ) { return wrapper . get (); } template < typename T > T & unwrap_ref ( std :: reference_wrapper < T >&& wrapper ) { return wrapper . get (); } template < typename T > T & unwrap_ref ( std :: reference_wrapper < T >& wrapper ) { return wrapper . get (); } template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T >&& wrapper ) { return wrapper . get (); } template < typename T > using UnwrapRefType = decltype ( unwrap_ref ( std :: declval < T > ())); } // namespace batt Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/var__size__array_8hpp/","text":"batteries/var_size_array.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::VarSizeArray Defines \ud83d\udd17 Name BATTERIES_VAR_SIZE_ARRAY_HPP Macro Documentation \ud83d\udd17 BATTERIES_VAR_SIZE_ARRAY_HPP \ud83d\udd17 1 #define BATTERIES_VAR_SIZE_ARRAY_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_VAR_SIZE_ARRAY_HPP #define BATTERIES_VAR_SIZE_ARRAY_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <memory> #include <type_traits> namespace batt { template < typename T , usize kStaticAlloc = 1 > class VarSizeArray { public : using size_type = usize ; using value_type = T ; using reference = T & ; using const_reference = const T & ; using iterator = T * ; using const_iterator = const T * ; template < typename ... Args > VarSizeArray ( usize size , Args && ... args ) : size_ { size } { if ( size > kStaticAlloc ) { this -> dynamic_storage_ = std :: make_unique < std :: aligned_storage_t < sizeof ( T ) > [] > ( size ); this -> array_ = reinterpret_cast < T *> ( this -> dynamic_storage_ . get ()); } else { this -> array_ = reinterpret_cast < T *> ( & this -> static_storage_ ); } for ( usize i = 0 ; i < this -> size_ ; ++ i ) { new ( & this -> array_ [ i ]) T ( args ...); } } ~ VarSizeArray () { for ( T & elem : * this ) { elem . ~ T (); } } // TODO [tastolfi 2021-05-10] - implement copy/move semantics. // VarSizeArray ( const VarSizeArray & ) = delete ; VarSizeArray & operator = ( const VarSizeArray & ) = delete ; usize size () const { return this -> size_ ; } iterator begin () { return & this -> array_ [ 0 ]; } iterator end () { return & this -> array_ [ this -> size_ ]; } const_iterator cbegin () const { return & this -> array_ [ 0 ]; } const_iterator cend () const { return & this -> array_ [ this -> size_ ]; } const_iterator begin () const { return this -> cbegin (); } const_iterator end () const { return this -> cend (); } T * data () { return this -> array_ ; } const T * data () const { return this -> array_ ; } reference operator []( isize i ) { return this -> array_ [ i ]; } const_reference operator []( isize i ) const { return this -> array_ [ i ]; } bool is_dynamic () const { return ( const void * ) this -> array_ == ( const void * ) this -> dynamic_storage_ . get (); } private : std :: unique_ptr < std :: aligned_storage_t < sizeof ( T ) > [] > dynamic_storage_ ; std :: aligned_storage_t < sizeof ( T ) * kStaticAlloc > static_storage_ ; T * array_ ; const usize size_ ; }; } // namespace batt #endif // BATTERIES_VAR_SIZE_ARRAY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/var_size_array.hpp"},{"location":"_autogen/Files/var__size__array_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/var__size__array_8hpp/#classes","text":"Name class batt::VarSizeArray","title":"Classes"},{"location":"_autogen/Files/var__size__array_8hpp/#defines","text":"Name BATTERIES_VAR_SIZE_ARRAY_HPP","title":"Defines"},{"location":"_autogen/Files/var__size__array_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/var__size__array_8hpp/#batteries_var_size_array_hpp","text":"1 #define BATTERIES_VAR_SIZE_ARRAY_HPP()","title":"BATTERIES_VAR_SIZE_ARRAY_HPP"},{"location":"_autogen/Files/var__size__array_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 // Copyright 2021-2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_VAR_SIZE_ARRAY_HPP #define BATTERIES_VAR_SIZE_ARRAY_HPP #include <batteries/config.hpp> // #include <batteries/int_types.hpp> #include <memory> #include <type_traits> namespace batt { template < typename T , usize kStaticAlloc = 1 > class VarSizeArray { public : using size_type = usize ; using value_type = T ; using reference = T & ; using const_reference = const T & ; using iterator = T * ; using const_iterator = const T * ; template < typename ... Args > VarSizeArray ( usize size , Args && ... args ) : size_ { size } { if ( size > kStaticAlloc ) { this -> dynamic_storage_ = std :: make_unique < std :: aligned_storage_t < sizeof ( T ) > [] > ( size ); this -> array_ = reinterpret_cast < T *> ( this -> dynamic_storage_ . get ()); } else { this -> array_ = reinterpret_cast < T *> ( & this -> static_storage_ ); } for ( usize i = 0 ; i < this -> size_ ; ++ i ) { new ( & this -> array_ [ i ]) T ( args ...); } } ~ VarSizeArray () { for ( T & elem : * this ) { elem . ~ T (); } } // TODO [tastolfi 2021-05-10] - implement copy/move semantics. // VarSizeArray ( const VarSizeArray & ) = delete ; VarSizeArray & operator = ( const VarSizeArray & ) = delete ; usize size () const { return this -> size_ ; } iterator begin () { return & this -> array_ [ 0 ]; } iterator end () { return & this -> array_ [ this -> size_ ]; } const_iterator cbegin () const { return & this -> array_ [ 0 ]; } const_iterator cend () const { return & this -> array_ [ this -> size_ ]; } const_iterator begin () const { return this -> cbegin (); } const_iterator end () const { return this -> cend (); } T * data () { return this -> array_ ; } const T * data () const { return this -> array_ ; } reference operator []( isize i ) { return this -> array_ [ i ]; } const_reference operator []( isize i ) const { return this -> array_ [ i ]; } bool is_dynamic () const { return ( const void * ) this -> array_ == ( const void * ) this -> dynamic_storage_ . get (); } private : std :: unique_ptr < std :: aligned_storage_t < sizeof ( T ) > [] > dynamic_storage_ ; std :: aligned_storage_t < sizeof ( T ) * kStaticAlloc > static_storage_ ; T * array_ ; const usize size_ ; }; } // namespace batt #endif // BATTERIES_VAR_SIZE_ARRAY_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/verbose_8hpp/","text":"batteries/state_machine_model/verbose.hpp \ud83d\udd17 Defines \ud83d\udd17 Name BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP BATT_STATE_MACHINE_VERBOSE () Macro Documentation \ud83d\udd17 BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP \ud83d\udd17 1 #define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP() BATT_STATE_MACHINE_VERBOSE \ud83d\udd17 1 #define BATT_STATE_MACHINE_VERBOSE() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP #define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP #include <iostream> #if 0 #define BATT_STATE_MACHINE_VERBOSE() for (bool b_VerBOSe_vAR = true; b_VerBOSe_vAR; std::cout << std::endl, b_VerBOSe_vAR = false) \\ std::cout #else #define BATT_STATE_MACHINE_VERBOSE() \\ for (; false;) \\ std::cout #endif #endif // BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/state_machine_model/verbose.hpp"},{"location":"_autogen/Files/verbose_8hpp/#defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP BATT_STATE_MACHINE_VERBOSE ()","title":"Defines"},{"location":"_autogen/Files/verbose_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/verbose_8hpp/#batteries_state_machine_model_verbose_hpp","text":"1 #define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP()","title":"BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP"},{"location":"_autogen/Files/verbose_8hpp/#batt_state_machine_verbose","text":"1 #define BATT_STATE_MACHINE_VERBOSE()","title":"BATT_STATE_MACHINE_VERBOSE"},{"location":"_autogen/Files/verbose_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP #define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP #include <iostream> #if 0 #define BATT_STATE_MACHINE_VERBOSE() for (bool b_VerBOSe_vAR = true; b_VerBOSe_vAR; std::cout << std::endl, b_VerBOSe_vAR = false) \\ std::cout #else #define BATT_STATE_MACHINE_VERBOSE() \\ for (; false;) \\ std::cout #endif #endif // BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/watch_8hpp/","text":"batteries/async/watch.hpp \ud83d\udd17 Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/watch_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/watch_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/watch.hpp"},{"location":"_autogen/Files/watch_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2021-2022 Anthony Paul Astolfi // #include <batteries/config.hpp> #include <batteries/async/watch_decl.hpp> #if BATT_HEADER_ONLY #include <batteries/async/watch_impl.hpp> #endif Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/watch__decl_8hpp/","text":"batteries/async/watch_decl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Watch class batt::WatchAtomic class batt::Watch< bool > class batt::Watch< i8 > class batt::Watch< i16 > class batt::Watch< i32 > class batt::Watch< i64 > class batt::Watch< u8 > class batt::Watch< u16 > class batt::Watch< u32 > class batt::Watch< u64 > class batt::Watch< void * > Defines \ud83d\udd17 Name BATTERIES_ASYNC_WATCH_DECL_HPP BATT_SPECIALIZE_WATCH_ATOMIC (type) Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_WATCH_DECL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_WATCH_DECL_HPP() BATT_SPECIALIZE_WATCH_ATOMIC \ud83d\udd17 1 #define BATT_SPECIALIZE_WATCH_ATOMIC(type) Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WATCH_DECL_HPP #define BATTERIES_ASYNC_WATCH_DECL_HPP #include <batteries/async/handler.hpp> #include <batteries/finally.hpp> #include <batteries/optional.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #include <bitset> #include <mutex> #include <thread> namespace batt { template < typename T > class Watch { public : Watch ( const Watch & ) = delete ; Watch & operator = ( const Watch & ) = delete ; Watch () = default ; template < typename Init , typename = EnableIfNoShadow < Watch , Init >> explicit Watch ( Init && init_value ) noexcept : value_ ( BATT_FORWARD ( init_value )) { } ~ Watch () { this -> close (); } void close () { HandlerList < StatusOr < T >> local_observers ; { std :: unique_lock < std :: mutex > lock { mutex_ }; this -> closed_ = true ; local_observers = std :: move ( this -> observers_ ); } invoke_all_handlers ( & local_observers , Status { StatusCode :: kClosed }); } bool is_closed () const { std :: unique_lock < std :: mutex > lock { mutex_ }; return this -> closed_ ; } void set_value ( const T & new_value ) { HandlerList < StatusOr < T >> observers ; { std :: unique_lock < std :: mutex > lock { mutex_ }; if ( new_value != this -> value_ ) { value_ = new_value ; observers = std :: move ( observers_ ); } } invoke_all_handlers ( & observers , new_value ); } T get_value () const { std :: unique_lock < std :: mutex > lock { mutex_ }; return value_ ; } template < typename Fn > T modify ( Fn && fn ) { Optional < T > new_value ; HandlerList < StatusOr < T >> observers ; { std :: unique_lock < std :: mutex > lock { mutex_ }; new_value . emplace ( BATT_FORWARD ( fn )( value_ )); if ( * new_value != value_ ) { value_ = * new_value ; observers = std :: move ( observers_ ); } } invoke_all_handlers ( & observers , * new_value ); return std :: move ( * new_value ); } template < typename Handler > void async_wait ( const T & last_seen , Handler && fn ) { bool local_closed = false ; bool changed = false ; T new_value ; { std :: unique_lock < std :: mutex > lock { mutex_ }; if ( this -> closed_ ) { local_closed = true ; } else if ( value_ == last_seen && ! this -> closed_ ) { push_handler ( & observers_ , BATT_FORWARD ( fn )); } else { changed = true ; new_value = value_ ; } } if ( local_closed ) { BATT_FORWARD ( fn )( Status { StatusCode :: kClosed }); } else if ( changed ) { BATT_FORWARD ( fn )( new_value ); } } StatusOr < T > await_not_equal ( const T & last_seen ); template < typename Pred > StatusOr < T > await_true ( Pred && pred ) { StatusOr < T > last_seen = this -> get_value (); while ( last_seen . ok () && ! pred ( * last_seen )) { last_seen = this -> await_not_equal ( * last_seen ); } return last_seen ; } private : mutable std :: mutex mutex_ ; bool closed_ = false ; T value_ ; HandlerList < StatusOr < T >> observers_ ; }; template < typename T > class WatchAtomic { public : static constexpr u32 kLocked = 0x01 ; static constexpr u32 kOpen = 0x02 ; static constexpr u32 kWaiting = 0x04 ; static constexpr u32 kClosedAtEnd = 0x08 ; static constexpr u32 kClosedBeforeEnd = 0x10 ; WatchAtomic ( const WatchAtomic & ) = delete ; WatchAtomic & operator = ( const WatchAtomic & ) = delete ; WatchAtomic () = default ; template < typename Init , typename = EnableIfNoShadow < WatchAtomic , Init >> explicit WatchAtomic ( Init && init_value ) noexcept : value_ ( BATT_FORWARD ( init_value )) { } ~ WatchAtomic () noexcept { this -> close (); } void close ( StatusCode final_status_code = StatusCode :: kClosed ) { HandlerList < StatusOr < T >> local_observers ; { const u32 prior_state = this -> lock_observers (); local_observers = std :: move ( this -> observers_ ); const u32 desired_state = ( prior_state & ~ ( kOpen | kWaiting )) | ([ & ]() -> u32 { // If already closed, don't change the closed status. // if (( prior_state & kOpen ) != kOpen ) { return 0 ; } BATT_SUPPRESS_IF_GCC ( \"-Wswitch-enum\" ) { switch ( final_status_code ) { case StatusCode :: kEndOfStream : return WatchAtomic :: kClosedAtEnd ; case StatusCode :: kClosedBeforeEndOfStream : return WatchAtomic :: kClosedBeforeEnd ; case StatusCode :: kClosed : // fall-through default : // All other StatusCode values are ignored; set status // StatusCode::kClosed. // return 0 ; } } BATT_UNSUPPRESS_IF_GCC () }()); this -> unlock_observers ( desired_state ); } invoke_all_handlers ( & local_observers , this -> get_final_status ()); // // IMPORTANT: Nothing can come after invoking observers, since we must allow one observer to delete // the WatchAtomic object (`this`). } bool is_closed () const { return ! ( this -> spin_state_ . load () & kOpen ); } T set_value ( T new_value ) { const T old_value = this -> value_ . exchange ( new_value ); if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T get_value () const { return this -> value_ . load (); } T fetch_add ( T arg ) { T old_value = this -> value_ . fetch_add ( arg ); T new_value = old_value + arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T fetch_or ( T arg ) { T old_value = this -> value_ . fetch_or ( arg ); T new_value = old_value | arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T fetch_sub ( T arg ) { T old_value = this -> value_ . fetch_sub ( arg ); T new_value = old_value - arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T fetch_and ( T arg ) { T old_value = this -> value_ . fetch_and ( arg ); T new_value = old_value & arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } template < typename Fn = T ( T ) > T modify ( Fn && fn ) { T old_value = this -> value_ . load (); bool changed = false ; const T new_value = [ & ] { for (;;) { const T modified_value = fn ( old_value ); changed = changed || ( modified_value != old_value ); if ( this -> value_ . compare_exchange_weak ( old_value , modified_value )) { return modified_value ; } } }(); if ( changed ) { this -> notify ( new_value ); } // TODO [tastolfi 2021-10-14] make the non-atomic version of modify consistent with this behavior! return old_value ; } // Retry `fn` on the watch value until it succeeds or the watch is closed. Return the old (pre-modify) // value on which `fn` finally succeeded. // // `fn` should have the signature (T) -> Optional<T>. Returning None indicates `fn` should not be called // again until a new value is available. // template < typename Fn = Optional < T > ( T ) > StatusOr < T > await_modify ( Fn && fn ); // Fn: (T) -> Optional<T> // // Keeps retrying using CAS until success or `fn` returns None. Returns the value for which `fn` returned // non-None, or None. // template < typename Fn = Optional < T > ( T ) > Optional < T > modify_if ( Fn && fn ) { T old_value = this -> value_ . load (); bool changed = false ; const Optional < T > new_value = [ & ] { for (;;) { const Optional < T > modified_value = fn ( old_value ); changed = changed || ( modified_value && * modified_value != old_value ); if ( ! modified_value || this -> value_ . compare_exchange_weak ( old_value , * modified_value )) { return modified_value ; } } }(); if ( ! new_value ) { return None ; } if ( changed ) { this -> notify ( * new_value ); } return old_value ; } template < typename Handler > void async_wait ( T last_seen , Handler && fn ) const { T now_seen = this -> value_ . load (); bool changed = ( now_seen != last_seen ); if ( ! changed ) { u32 prior_state = this -> lock_observers (); if ( ! ( prior_state & kOpen )) { this -> unlock_observers ( prior_state ); BATT_FORWARD ( fn )( this -> get_final_status ()); return ; } auto unlock_guard = finally ([ & ] { this -> unlock_observers ( prior_state ); }); now_seen = this -> value_ . load (); changed = ( now_seen != last_seen ); if ( ! changed ) { push_handler ( & this -> observers_ , BATT_FORWARD ( fn )); prior_state |= kWaiting ; return ; // // The dtor of `unlock_guard` will atomically clear the `kLocked` flag and set `kWaiting`. } } // // If we get here, either the initial `changed` check was true, we are closed, or the second `changed` // check (with the spin lock held) must have succeeded; in any case, invoke the handler immediately. BATT_FORWARD ( fn )( now_seen ); } StatusOr < T > await_not_equal ( const T & last_seen ) const ; template < typename Pred > StatusOr < T > await_true ( Pred && pred ) const { StatusOr < T > last_seen = this -> get_value (); while ( last_seen . ok () && ! pred ( * last_seen )) { last_seen = this -> await_not_equal ( * last_seen ); } return last_seen ; } Status await_equal ( T val ) const { return this -> await_true ([ val ]( T observed ) { return observed == val ; }) . status (); } private : Status get_final_status () const { constexpr u32 mask = WatchAtomic :: kClosedAtEnd | WatchAtomic :: kClosedBeforeEnd ; switch ( this -> spin_state_ . load () & mask ) { case WatchAtomic :: kClosedBeforeEnd : return Status { StatusCode :: kClosedBeforeEndOfStream }; case WatchAtomic :: kClosedAtEnd : return Status { StatusCode :: kEndOfStream }; default : break ; } return Status { StatusCode :: kClosed }; } u32 lock_observers () const { for (;;) { const u32 prior_state = this -> spin_state_ . fetch_or ( kLocked ); if (( prior_state & kLocked ) == 0 ) { return prior_state ; } std :: this_thread :: yield (); } } void unlock_observers ( u32 desired_state ) const { this -> spin_state_ . store ( desired_state & ~ kLocked ); } void notify ( T new_value ) { const auto post_change_state = this -> spin_state_ . load (); if (( post_change_state & ( kLocked | kWaiting )) == 0 ) { // // If there is a concurrent call to async_wait that results in a handler being added to the // `observers_` list, it must go through the following atomic events: // // 1. load value (phase 1), no change // 2. set kLocked // 3. load value (phase 2), no change // 4. set kWaiting // // The notifier thread (this call), when not waking observers, goes through the following atomic // events: // // a. change value // b. load spin state, observe not kLocked and not kWaiting // // (b) must occur before (1) [therefore (a) < (1)] or between (1) and (2) [(a) < (3)]. In either // case, the async_wait call will load the value *after* this thread changes it (a), so there will // be no spurious deadlocks. // return ; } // Acquire the spinlock. // const auto pre_lock_state = this -> lock_observers (); HandlerList < StatusOr < T >> local_observers = std :: move ( this -> observers_ ); this -> unlock_observers ( pre_lock_state & ~ ( kWaiting )); invoke_all_handlers ( & local_observers , new_value ); } std :: atomic < T > value_ { 0 }; mutable std :: atomic < u32 > spin_state_ { kOpen }; mutable HandlerList < StatusOr < T >> observers_ ; }; #define BATT_SPECIALIZE_WATCH_ATOMIC(type) \\ template <> \\ class Watch<type> : public WatchAtomic<type> \\ { \\ public: \\ using WatchAtomic<type>::WatchAtomic; \\ } BATT_SPECIALIZE_WATCH_ATOMIC ( bool ); BATT_SPECIALIZE_WATCH_ATOMIC ( i8 ); BATT_SPECIALIZE_WATCH_ATOMIC ( i16 ); BATT_SPECIALIZE_WATCH_ATOMIC ( i32 ); BATT_SPECIALIZE_WATCH_ATOMIC ( i64 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u8 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u16 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u32 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u64 ); BATT_SPECIALIZE_WATCH_ATOMIC ( void * ); #undef BATT_SPECIALIZE_WATCH_ATOMIC } // namespace batt #endif // BATTERIES_ASYNC_WATCH_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/watch_decl.hpp"},{"location":"_autogen/Files/watch__decl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/watch__decl_8hpp/#classes","text":"Name class batt::Watch class batt::WatchAtomic class batt::Watch< bool > class batt::Watch< i8 > class batt::Watch< i16 > class batt::Watch< i32 > class batt::Watch< i64 > class batt::Watch< u8 > class batt::Watch< u16 > class batt::Watch< u32 > class batt::Watch< u64 > class batt::Watch< void * >","title":"Classes"},{"location":"_autogen/Files/watch__decl_8hpp/#defines","text":"Name BATTERIES_ASYNC_WATCH_DECL_HPP BATT_SPECIALIZE_WATCH_ATOMIC (type)","title":"Defines"},{"location":"_autogen/Files/watch__decl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/watch__decl_8hpp/#batteries_async_watch_decl_hpp","text":"1 #define BATTERIES_ASYNC_WATCH_DECL_HPP()","title":"BATTERIES_ASYNC_WATCH_DECL_HPP"},{"location":"_autogen/Files/watch__decl_8hpp/#batt_specialize_watch_atomic","text":"1 #define BATT_SPECIALIZE_WATCH_ATOMIC(type)","title":"BATT_SPECIALIZE_WATCH_ATOMIC"},{"location":"_autogen/Files/watch__decl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WATCH_DECL_HPP #define BATTERIES_ASYNC_WATCH_DECL_HPP #include <batteries/async/handler.hpp> #include <batteries/finally.hpp> #include <batteries/optional.hpp> #include <batteries/status.hpp> #include <batteries/type_traits.hpp> #include <bitset> #include <mutex> #include <thread> namespace batt { template < typename T > class Watch { public : Watch ( const Watch & ) = delete ; Watch & operator = ( const Watch & ) = delete ; Watch () = default ; template < typename Init , typename = EnableIfNoShadow < Watch , Init >> explicit Watch ( Init && init_value ) noexcept : value_ ( BATT_FORWARD ( init_value )) { } ~ Watch () { this -> close (); } void close () { HandlerList < StatusOr < T >> local_observers ; { std :: unique_lock < std :: mutex > lock { mutex_ }; this -> closed_ = true ; local_observers = std :: move ( this -> observers_ ); } invoke_all_handlers ( & local_observers , Status { StatusCode :: kClosed }); } bool is_closed () const { std :: unique_lock < std :: mutex > lock { mutex_ }; return this -> closed_ ; } void set_value ( const T & new_value ) { HandlerList < StatusOr < T >> observers ; { std :: unique_lock < std :: mutex > lock { mutex_ }; if ( new_value != this -> value_ ) { value_ = new_value ; observers = std :: move ( observers_ ); } } invoke_all_handlers ( & observers , new_value ); } T get_value () const { std :: unique_lock < std :: mutex > lock { mutex_ }; return value_ ; } template < typename Fn > T modify ( Fn && fn ) { Optional < T > new_value ; HandlerList < StatusOr < T >> observers ; { std :: unique_lock < std :: mutex > lock { mutex_ }; new_value . emplace ( BATT_FORWARD ( fn )( value_ )); if ( * new_value != value_ ) { value_ = * new_value ; observers = std :: move ( observers_ ); } } invoke_all_handlers ( & observers , * new_value ); return std :: move ( * new_value ); } template < typename Handler > void async_wait ( const T & last_seen , Handler && fn ) { bool local_closed = false ; bool changed = false ; T new_value ; { std :: unique_lock < std :: mutex > lock { mutex_ }; if ( this -> closed_ ) { local_closed = true ; } else if ( value_ == last_seen && ! this -> closed_ ) { push_handler ( & observers_ , BATT_FORWARD ( fn )); } else { changed = true ; new_value = value_ ; } } if ( local_closed ) { BATT_FORWARD ( fn )( Status { StatusCode :: kClosed }); } else if ( changed ) { BATT_FORWARD ( fn )( new_value ); } } StatusOr < T > await_not_equal ( const T & last_seen ); template < typename Pred > StatusOr < T > await_true ( Pred && pred ) { StatusOr < T > last_seen = this -> get_value (); while ( last_seen . ok () && ! pred ( * last_seen )) { last_seen = this -> await_not_equal ( * last_seen ); } return last_seen ; } private : mutable std :: mutex mutex_ ; bool closed_ = false ; T value_ ; HandlerList < StatusOr < T >> observers_ ; }; template < typename T > class WatchAtomic { public : static constexpr u32 kLocked = 0x01 ; static constexpr u32 kOpen = 0x02 ; static constexpr u32 kWaiting = 0x04 ; static constexpr u32 kClosedAtEnd = 0x08 ; static constexpr u32 kClosedBeforeEnd = 0x10 ; WatchAtomic ( const WatchAtomic & ) = delete ; WatchAtomic & operator = ( const WatchAtomic & ) = delete ; WatchAtomic () = default ; template < typename Init , typename = EnableIfNoShadow < WatchAtomic , Init >> explicit WatchAtomic ( Init && init_value ) noexcept : value_ ( BATT_FORWARD ( init_value )) { } ~ WatchAtomic () noexcept { this -> close (); } void close ( StatusCode final_status_code = StatusCode :: kClosed ) { HandlerList < StatusOr < T >> local_observers ; { const u32 prior_state = this -> lock_observers (); local_observers = std :: move ( this -> observers_ ); const u32 desired_state = ( prior_state & ~ ( kOpen | kWaiting )) | ([ & ]() -> u32 { // If already closed, don't change the closed status. // if (( prior_state & kOpen ) != kOpen ) { return 0 ; } BATT_SUPPRESS_IF_GCC ( \"-Wswitch-enum\" ) { switch ( final_status_code ) { case StatusCode :: kEndOfStream : return WatchAtomic :: kClosedAtEnd ; case StatusCode :: kClosedBeforeEndOfStream : return WatchAtomic :: kClosedBeforeEnd ; case StatusCode :: kClosed : // fall-through default : // All other StatusCode values are ignored; set status // StatusCode::kClosed. // return 0 ; } } BATT_UNSUPPRESS_IF_GCC () }()); this -> unlock_observers ( desired_state ); } invoke_all_handlers ( & local_observers , this -> get_final_status ()); // // IMPORTANT: Nothing can come after invoking observers, since we must allow one observer to delete // the WatchAtomic object (`this`). } bool is_closed () const { return ! ( this -> spin_state_ . load () & kOpen ); } T set_value ( T new_value ) { const T old_value = this -> value_ . exchange ( new_value ); if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T get_value () const { return this -> value_ . load (); } T fetch_add ( T arg ) { T old_value = this -> value_ . fetch_add ( arg ); T new_value = old_value + arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T fetch_or ( T arg ) { T old_value = this -> value_ . fetch_or ( arg ); T new_value = old_value | arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T fetch_sub ( T arg ) { T old_value = this -> value_ . fetch_sub ( arg ); T new_value = old_value - arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } T fetch_and ( T arg ) { T old_value = this -> value_ . fetch_and ( arg ); T new_value = old_value & arg ; if ( old_value != new_value ) { this -> notify ( new_value ); } return old_value ; } template < typename Fn = T ( T ) > T modify ( Fn && fn ) { T old_value = this -> value_ . load (); bool changed = false ; const T new_value = [ & ] { for (;;) { const T modified_value = fn ( old_value ); changed = changed || ( modified_value != old_value ); if ( this -> value_ . compare_exchange_weak ( old_value , modified_value )) { return modified_value ; } } }(); if ( changed ) { this -> notify ( new_value ); } // TODO [tastolfi 2021-10-14] make the non-atomic version of modify consistent with this behavior! return old_value ; } // Retry `fn` on the watch value until it succeeds or the watch is closed. Return the old (pre-modify) // value on which `fn` finally succeeded. // // `fn` should have the signature (T) -> Optional<T>. Returning None indicates `fn` should not be called // again until a new value is available. // template < typename Fn = Optional < T > ( T ) > StatusOr < T > await_modify ( Fn && fn ); // Fn: (T) -> Optional<T> // // Keeps retrying using CAS until success or `fn` returns None. Returns the value for which `fn` returned // non-None, or None. // template < typename Fn = Optional < T > ( T ) > Optional < T > modify_if ( Fn && fn ) { T old_value = this -> value_ . load (); bool changed = false ; const Optional < T > new_value = [ & ] { for (;;) { const Optional < T > modified_value = fn ( old_value ); changed = changed || ( modified_value && * modified_value != old_value ); if ( ! modified_value || this -> value_ . compare_exchange_weak ( old_value , * modified_value )) { return modified_value ; } } }(); if ( ! new_value ) { return None ; } if ( changed ) { this -> notify ( * new_value ); } return old_value ; } template < typename Handler > void async_wait ( T last_seen , Handler && fn ) const { T now_seen = this -> value_ . load (); bool changed = ( now_seen != last_seen ); if ( ! changed ) { u32 prior_state = this -> lock_observers (); if ( ! ( prior_state & kOpen )) { this -> unlock_observers ( prior_state ); BATT_FORWARD ( fn )( this -> get_final_status ()); return ; } auto unlock_guard = finally ([ & ] { this -> unlock_observers ( prior_state ); }); now_seen = this -> value_ . load (); changed = ( now_seen != last_seen ); if ( ! changed ) { push_handler ( & this -> observers_ , BATT_FORWARD ( fn )); prior_state |= kWaiting ; return ; // // The dtor of `unlock_guard` will atomically clear the `kLocked` flag and set `kWaiting`. } } // // If we get here, either the initial `changed` check was true, we are closed, or the second `changed` // check (with the spin lock held) must have succeeded; in any case, invoke the handler immediately. BATT_FORWARD ( fn )( now_seen ); } StatusOr < T > await_not_equal ( const T & last_seen ) const ; template < typename Pred > StatusOr < T > await_true ( Pred && pred ) const { StatusOr < T > last_seen = this -> get_value (); while ( last_seen . ok () && ! pred ( * last_seen )) { last_seen = this -> await_not_equal ( * last_seen ); } return last_seen ; } Status await_equal ( T val ) const { return this -> await_true ([ val ]( T observed ) { return observed == val ; }) . status (); } private : Status get_final_status () const { constexpr u32 mask = WatchAtomic :: kClosedAtEnd | WatchAtomic :: kClosedBeforeEnd ; switch ( this -> spin_state_ . load () & mask ) { case WatchAtomic :: kClosedBeforeEnd : return Status { StatusCode :: kClosedBeforeEndOfStream }; case WatchAtomic :: kClosedAtEnd : return Status { StatusCode :: kEndOfStream }; default : break ; } return Status { StatusCode :: kClosed }; } u32 lock_observers () const { for (;;) { const u32 prior_state = this -> spin_state_ . fetch_or ( kLocked ); if (( prior_state & kLocked ) == 0 ) { return prior_state ; } std :: this_thread :: yield (); } } void unlock_observers ( u32 desired_state ) const { this -> spin_state_ . store ( desired_state & ~ kLocked ); } void notify ( T new_value ) { const auto post_change_state = this -> spin_state_ . load (); if (( post_change_state & ( kLocked | kWaiting )) == 0 ) { // // If there is a concurrent call to async_wait that results in a handler being added to the // `observers_` list, it must go through the following atomic events: // // 1. load value (phase 1), no change // 2. set kLocked // 3. load value (phase 2), no change // 4. set kWaiting // // The notifier thread (this call), when not waking observers, goes through the following atomic // events: // // a. change value // b. load spin state, observe not kLocked and not kWaiting // // (b) must occur before (1) [therefore (a) < (1)] or between (1) and (2) [(a) < (3)]. In either // case, the async_wait call will load the value *after* this thread changes it (a), so there will // be no spurious deadlocks. // return ; } // Acquire the spinlock. // const auto pre_lock_state = this -> lock_observers (); HandlerList < StatusOr < T >> local_observers = std :: move ( this -> observers_ ); this -> unlock_observers ( pre_lock_state & ~ ( kWaiting )); invoke_all_handlers ( & local_observers , new_value ); } std :: atomic < T > value_ { 0 }; mutable std :: atomic < u32 > spin_state_ { kOpen }; mutable HandlerList < StatusOr < T >> observers_ ; }; #define BATT_SPECIALIZE_WATCH_ATOMIC(type) \\ template <> \\ class Watch<type> : public WatchAtomic<type> \\ { \\ public: \\ using WatchAtomic<type>::WatchAtomic; \\ } BATT_SPECIALIZE_WATCH_ATOMIC ( bool ); BATT_SPECIALIZE_WATCH_ATOMIC ( i8 ); BATT_SPECIALIZE_WATCH_ATOMIC ( i16 ); BATT_SPECIALIZE_WATCH_ATOMIC ( i32 ); BATT_SPECIALIZE_WATCH_ATOMIC ( i64 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u8 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u16 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u32 ); BATT_SPECIALIZE_WATCH_ATOMIC ( u64 ); BATT_SPECIALIZE_WATCH_ATOMIC ( void * ); #undef BATT_SPECIALIZE_WATCH_ATOMIC } // namespace batt #endif // BATTERIES_ASYNC_WATCH_DECL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/watch__impl_8hpp/","text":"batteries/async/watch_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_WATCH_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_WATCH_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_WATCH_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WATCH_IMPL_HPP #define BATTERIES_ASYNC_WATCH_IMPL_HPP #include <batteries/async/watch_decl.hpp> // #include <batteries/async/debug_info.hpp> #include <batteries/async/task.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class Watch //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL StatusOr < T > Watch < T >:: await_not_equal ( const T & last_seen ) { return Task :: await < StatusOr < T >> ([ & ]( auto && fn ) { this -> async_wait ( last_seen , BATT_FORWARD ( fn )); }); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class WatchAtomic //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Fn > BATT_INLINE_IMPL StatusOr < T > WatchAtomic < T >:: await_modify ( Fn && fn ) { T old_value = this -> value_ . load (); for (;;) { const Optional < T > new_value = [ & ] { for (;;) { const Optional < T > modified_value = fn ( old_value ); if ( ! modified_value || this -> value_ . compare_exchange_weak ( old_value , * modified_value )) { return modified_value ; } } }(); if ( new_value ) { if ( * new_value != old_value ) { this -> notify ( * new_value ); } break ; } BATT_DEBUG_INFO ( \"[WatchAtomic::await_modify] waiting for update (old_value=\" << old_value << \")\" ); StatusOr < T > updated_value = this -> await_not_equal ( old_value ); BATT_REQUIRE_OK ( updated_value ); old_value = * updated_value ; } return old_value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL StatusOr < T > WatchAtomic < T >:: await_not_equal ( const T & last_seen ) const { BATT_DEBUG_INFO ( \"WatchAtomic{value=\" << this -> value_ << \" spin_state=\" << std :: bitset < 8 > { this -> spin_state_ } << \"(locked=\" << kLocked << \",open=\" << kOpen << \",wait=\" << kWaiting << \") observers.size()=\" << this -> observers_ . size () << \" is_closed=\" << this -> is_closed () << \" last_seen=\" << last_seen << \"}\" ); return Task :: await < StatusOr < T >> ([ & ]( auto && fn ) { this -> async_wait ( last_seen , BATT_FORWARD ( fn )); }); } } // namespace batt #endif // BATTERIES_ASYNC_WATCH_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/watch_impl.hpp"},{"location":"_autogen/Files/watch__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/watch__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_WATCH_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/watch__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/watch__impl_8hpp/#batteries_async_watch_impl_hpp","text":"1 #define BATTERIES_ASYNC_WATCH_IMPL_HPP()","title":"BATTERIES_ASYNC_WATCH_IMPL_HPP"},{"location":"_autogen/Files/watch__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // Copyright 2021 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WATCH_IMPL_HPP #define BATTERIES_ASYNC_WATCH_IMPL_HPP #include <batteries/async/watch_decl.hpp> // #include <batteries/async/debug_info.hpp> #include <batteries/async/task.hpp> namespace batt { //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class Watch //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL StatusOr < T > Watch < T >:: await_not_equal ( const T & last_seen ) { return Task :: await < StatusOr < T >> ([ & ]( auto && fn ) { this -> async_wait ( last_seen , BATT_FORWARD ( fn )); }); } //=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+--------------- // class WatchAtomic //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > template < typename Fn > BATT_INLINE_IMPL StatusOr < T > WatchAtomic < T >:: await_modify ( Fn && fn ) { T old_value = this -> value_ . load (); for (;;) { const Optional < T > new_value = [ & ] { for (;;) { const Optional < T > modified_value = fn ( old_value ); if ( ! modified_value || this -> value_ . compare_exchange_weak ( old_value , * modified_value )) { return modified_value ; } } }(); if ( new_value ) { if ( * new_value != old_value ) { this -> notify ( * new_value ); } break ; } BATT_DEBUG_INFO ( \"[WatchAtomic::await_modify] waiting for update (old_value=\" << old_value << \")\" ); StatusOr < T > updated_value = this -> await_not_equal ( old_value ); BATT_REQUIRE_OK ( updated_value ); old_value = * updated_value ; } return old_value ; } //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // template < typename T > BATT_INLINE_IMPL StatusOr < T > WatchAtomic < T >:: await_not_equal ( const T & last_seen ) const { BATT_DEBUG_INFO ( \"WatchAtomic{value=\" << this -> value_ << \" spin_state=\" << std :: bitset < 8 > { this -> spin_state_ } << \"(locked=\" << kLocked << \",open=\" << kOpen << \",wait=\" << kWaiting << \") observers.size()=\" << this -> observers_ . size () << \" is_closed=\" << this -> is_closed () << \" last_seen=\" << last_seen << \"}\" ); return Task :: await < StatusOr < T >> ([ & ]( auto && fn ) { this -> async_wait ( last_seen , BATT_FORWARD ( fn )); }); } } // namespace batt #endif // BATTERIES_ASYNC_WATCH_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/work__context_8hpp/","text":"batteries/async/work_context.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::WorkContext class batt::ScopedWorkContext Defines \ud83d\udd17 Name BATTERIES_ASYNC_WORK_CONTEXT_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_WORK_CONTEXT_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_WORK_CONTEXT_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORK_CONTEXT_HPP #define BATTERIES_ASYNC_WORK_CONTEXT_HPP #include <batteries/config.hpp> // #include <batteries/async/worker_pool.hpp> #include <batteries/assert.hpp> #include <batteries/async/task.hpp> #include <batteries/finally.hpp> #include <batteries/logging.hpp> #include <batteries/utility.hpp> #include <thread> namespace batt { // Tracks a set of work items submitted to a WorkerPool so that application code can wait on the // completion of the entire set. // class WorkContext { public : WorkContext ( const WorkContext & ) = delete ; WorkContext & operator = ( const WorkContext & ) = delete ; explicit WorkContext ( WorkerPool & worker_pool ) noexcept : worker_pool_ { worker_pool } { } template < typename Fn > decltype ( auto ) async_run ( Fn && work_fn ) { this -> on_work_started (); return this -> worker_pool_ . async_run ([ this , work_fn = BATT_FORWARD ( work_fn )]() mutable { const auto on_exit = batt :: finally ([ & ] { this -> on_work_finished (); }); work_fn (); }); } void on_work_started () { this -> ref_count_ . fetch_add ( 1 ); this -> work_count_ . fetch_add ( 1 ); } void on_work_finished () { this -> work_count_ . fetch_sub ( 1 ); this -> ref_count_ . fetch_sub ( 1 ); } void await_done () { BATT_CHECK ( ! batt :: Task :: inside_work_fn ()); BATT_DEBUG_INFO ( \"work_count=\" << this -> work_count_ . get_value ()); this -> work_count_ . await_true ([]( i64 count ) { BATT_CHECK_GE ( count , 0 ); return count <= 0 ; }) . IgnoreError (); while ( this -> ref_count_ . load () > 0 ) { batt :: Task :: yield (); } } private : WorkerPool & worker_pool_ ; batt :: Watch < i64 > work_count_ { 0 }; std :: atomic < i64 > ref_count_ { 0 }; }; // Guard class that automatically waits on the completion of work in a WorkContext. // class ScopedWorkContext : public WorkContext { public : using WorkContext :: WorkContext ; void cancel () { this -> cancelled_ . store ( true ); } ~ ScopedWorkContext () noexcept { if ( ! this -> cancelled_ . load ()) { this -> await_done (); } } private : std :: atomic < bool > cancelled_ { false }; }; } // namespace batt #endif // BATTERIES_ASYNC_WORK_CONTEXT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/work_context.hpp"},{"location":"_autogen/Files/work__context_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/work__context_8hpp/#classes","text":"Name class batt::WorkContext class batt::ScopedWorkContext","title":"Classes"},{"location":"_autogen/Files/work__context_8hpp/#defines","text":"Name BATTERIES_ASYNC_WORK_CONTEXT_HPP","title":"Defines"},{"location":"_autogen/Files/work__context_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/work__context_8hpp/#batteries_async_work_context_hpp","text":"1 #define BATTERIES_ASYNC_WORK_CONTEXT_HPP()","title":"BATTERIES_ASYNC_WORK_CONTEXT_HPP"},{"location":"_autogen/Files/work__context_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORK_CONTEXT_HPP #define BATTERIES_ASYNC_WORK_CONTEXT_HPP #include <batteries/config.hpp> // #include <batteries/async/worker_pool.hpp> #include <batteries/assert.hpp> #include <batteries/async/task.hpp> #include <batteries/finally.hpp> #include <batteries/logging.hpp> #include <batteries/utility.hpp> #include <thread> namespace batt { // Tracks a set of work items submitted to a WorkerPool so that application code can wait on the // completion of the entire set. // class WorkContext { public : WorkContext ( const WorkContext & ) = delete ; WorkContext & operator = ( const WorkContext & ) = delete ; explicit WorkContext ( WorkerPool & worker_pool ) noexcept : worker_pool_ { worker_pool } { } template < typename Fn > decltype ( auto ) async_run ( Fn && work_fn ) { this -> on_work_started (); return this -> worker_pool_ . async_run ([ this , work_fn = BATT_FORWARD ( work_fn )]() mutable { const auto on_exit = batt :: finally ([ & ] { this -> on_work_finished (); }); work_fn (); }); } void on_work_started () { this -> ref_count_ . fetch_add ( 1 ); this -> work_count_ . fetch_add ( 1 ); } void on_work_finished () { this -> work_count_ . fetch_sub ( 1 ); this -> ref_count_ . fetch_sub ( 1 ); } void await_done () { BATT_CHECK ( ! batt :: Task :: inside_work_fn ()); BATT_DEBUG_INFO ( \"work_count=\" << this -> work_count_ . get_value ()); this -> work_count_ . await_true ([]( i64 count ) { BATT_CHECK_GE ( count , 0 ); return count <= 0 ; }) . IgnoreError (); while ( this -> ref_count_ . load () > 0 ) { batt :: Task :: yield (); } } private : WorkerPool & worker_pool_ ; batt :: Watch < i64 > work_count_ { 0 }; std :: atomic < i64 > ref_count_ { 0 }; }; // Guard class that automatically waits on the completion of work in a WorkContext. // class ScopedWorkContext : public WorkContext { public : using WorkContext :: WorkContext ; void cancel () { this -> cancelled_ . store ( true ); } ~ ScopedWorkContext () noexcept { if ( ! this -> cancelled_ . load ()) { this -> await_done (); } } private : std :: atomic < bool > cancelled_ { false }; }; } // namespace batt #endif // BATTERIES_ASYNC_WORK_CONTEXT_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/worker_8hpp/","text":"batteries/async/worker.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::Worker Defines \ud83d\udd17 Name BATTERIES_ASYNC_WORKER_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_WORKER_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_WORKER_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORKER_HPP #define BATTERIES_ASYNC_WORKER_HPP #include <batteries/config.hpp> // #include <batteries/async/debug_info.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/task.hpp> #include <batteries/constants.hpp> #include <batteries/finally.hpp> #include <batteries/small_fn.hpp> #include <string> namespace batt { class Worker { public : using WorkFn = batt :: UniqueSmallFn < void (), 128 - 16 > ; explicit Worker ( boost :: asio :: any_io_executor ex , std :: string && name = \"Worker::task\" ) noexcept : task { ex , [ this ] { int job_count = 0 ; for (;;) { BATT_DEBUG_INFO ( \"[Worker::task] waiting for next job (completed=\" << job_count << \")\" ); batt :: StatusOr < WorkFn > next_work = this -> work_queue . await_next (); if ( ! next_work . ok ()) { return ; } { batt :: Task :: inside_work_fn () = true ; auto on_work_done = batt :: finally ([] { batt :: Task :: inside_work_fn () = false ; }); ( * next_work )(); } ++ job_count ; } }, std :: move ( name ), batt :: StackSize { 2 * kMiB }} { } batt :: Queue < WorkFn > work_queue ; batt :: Task task ; }; } // namespace batt #endif // BATTERIES_ASYNC_WORKER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/worker.hpp"},{"location":"_autogen/Files/worker_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/worker_8hpp/#classes","text":"Name class batt::Worker","title":"Classes"},{"location":"_autogen/Files/worker_8hpp/#defines","text":"Name BATTERIES_ASYNC_WORKER_HPP","title":"Defines"},{"location":"_autogen/Files/worker_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/worker_8hpp/#batteries_async_worker_hpp","text":"1 #define BATTERIES_ASYNC_WORKER_HPP()","title":"BATTERIES_ASYNC_WORKER_HPP"},{"location":"_autogen/Files/worker_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORKER_HPP #define BATTERIES_ASYNC_WORKER_HPP #include <batteries/config.hpp> // #include <batteries/async/debug_info.hpp> #include <batteries/async/queue.hpp> #include <batteries/async/task.hpp> #include <batteries/constants.hpp> #include <batteries/finally.hpp> #include <batteries/small_fn.hpp> #include <string> namespace batt { class Worker { public : using WorkFn = batt :: UniqueSmallFn < void (), 128 - 16 > ; explicit Worker ( boost :: asio :: any_io_executor ex , std :: string && name = \"Worker::task\" ) noexcept : task { ex , [ this ] { int job_count = 0 ; for (;;) { BATT_DEBUG_INFO ( \"[Worker::task] waiting for next job (completed=\" << job_count << \")\" ); batt :: StatusOr < WorkFn > next_work = this -> work_queue . await_next (); if ( ! next_work . ok ()) { return ; } { batt :: Task :: inside_work_fn () = true ; auto on_work_done = batt :: finally ([] { batt :: Task :: inside_work_fn () = false ; }); ( * next_work )(); } ++ job_count ; } }, std :: move ( name ), batt :: StackSize { 2 * kMiB }} { } batt :: Queue < WorkFn > work_queue ; batt :: Task task ; }; } // namespace batt #endif // BATTERIES_ASYNC_WORKER_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/worker__pool_8hpp/","text":"batteries/async/worker_pool.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Classes \ud83d\udd17 Name class batt::WorkerPool Defines \ud83d\udd17 Name BATTERIES_ASYNC_WORKER_POOL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_WORKER_POOL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_WORKER_POOL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORKER_POOL_HPP #define BATTERIES_ASYNC_WORKER_POOL_HPP #include <batteries/config.hpp> // #include <batteries/async/task_scheduler.hpp> #include <batteries/async/worker.hpp> #include <batteries/int_types.hpp> #include <atomic> #include <memory> #include <vector> namespace batt { class WorkerPool { public : static WorkerPool & default_pool (); // A pool containing no workers; `async_run` will always execute the passed function immediately on the // caller's thread. // static WorkerPool & null_pool () { static WorkerPool * pool_ = new WorkerPool { 0 , NullTaskScheduler :: instance ()}; return * pool_ ; } explicit WorkerPool ( usize size , TaskScheduler & scheduler ) noexcept { for ( usize i = 0 ; i < size ; ++ i ) { this -> workers_ . emplace_back ( std :: make_unique < Worker > ( scheduler . schedule_task ())); } } template < typename Fn > void async_run ( Fn && fn ) { if ( this -> workers_ . size () == 0 ) { fn (); } else { const usize next = this -> round_robin_ . fetch_add ( 1 ) % this -> workers_ . size (); this -> workers_ [ next ] -> work_queue . push ( BATT_FORWARD ( fn )); } } void reset ( usize phase_shift = 0 ) { this -> round_robin_ = phase_shift ; } usize size () const { return workers_ . size (); } void halt () { for ( const auto & w : this -> workers_ ) { w -> work_queue . close (); } } void join () { for ( const auto & w : this -> workers_ ) { w -> task . join (); } } ~ WorkerPool () noexcept { this -> halt (); this -> join (); } private : WorkerPool () = default ; std :: vector < std :: unique_ptr < Worker >> workers_ ; std :: atomic < usize > round_robin_ { 0 }; }; } // namespace batt #if BATT_HEADER_ONLY #include <batteries/async/worker_pool_impl.hpp> #endif // BATT_HEADER_ONLY #endif // BATTERIES_ASYNC_WORKER_POOL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/worker_pool.hpp"},{"location":"_autogen/Files/worker__pool_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/worker__pool_8hpp/#classes","text":"Name class batt::WorkerPool","title":"Classes"},{"location":"_autogen/Files/worker__pool_8hpp/#defines","text":"Name BATTERIES_ASYNC_WORKER_POOL_HPP","title":"Defines"},{"location":"_autogen/Files/worker__pool_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/worker__pool_8hpp/#batteries_async_worker_pool_hpp","text":"1 #define BATTERIES_ASYNC_WORKER_POOL_HPP()","title":"BATTERIES_ASYNC_WORKER_POOL_HPP"},{"location":"_autogen/Files/worker__pool_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORKER_POOL_HPP #define BATTERIES_ASYNC_WORKER_POOL_HPP #include <batteries/config.hpp> // #include <batteries/async/task_scheduler.hpp> #include <batteries/async/worker.hpp> #include <batteries/int_types.hpp> #include <atomic> #include <memory> #include <vector> namespace batt { class WorkerPool { public : static WorkerPool & default_pool (); // A pool containing no workers; `async_run` will always execute the passed function immediately on the // caller's thread. // static WorkerPool & null_pool () { static WorkerPool * pool_ = new WorkerPool { 0 , NullTaskScheduler :: instance ()}; return * pool_ ; } explicit WorkerPool ( usize size , TaskScheduler & scheduler ) noexcept { for ( usize i = 0 ; i < size ; ++ i ) { this -> workers_ . emplace_back ( std :: make_unique < Worker > ( scheduler . schedule_task ())); } } template < typename Fn > void async_run ( Fn && fn ) { if ( this -> workers_ . size () == 0 ) { fn (); } else { const usize next = this -> round_robin_ . fetch_add ( 1 ) % this -> workers_ . size (); this -> workers_ [ next ] -> work_queue . push ( BATT_FORWARD ( fn )); } } void reset ( usize phase_shift = 0 ) { this -> round_robin_ = phase_shift ; } usize size () const { return workers_ . size (); } void halt () { for ( const auto & w : this -> workers_ ) { w -> work_queue . close (); } } void join () { for ( const auto & w : this -> workers_ ) { w -> task . join (); } } ~ WorkerPool () noexcept { this -> halt (); this -> join (); } private : WorkerPool () = default ; std :: vector < std :: unique_ptr < Worker >> workers_ ; std :: atomic < usize > round_robin_ { 0 }; }; } // namespace batt #if BATT_HEADER_ONLY #include <batteries/async/worker_pool_impl.hpp> #endif // BATT_HEADER_ONLY #endif // BATTERIES_ASYNC_WORKER_POOL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Files/worker__pool__impl_8hpp/","text":"batteries/async/worker_pool_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name batt Defines \ud83d\udd17 Name BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP Macro Documentation \ud83d\udd17 BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP \ud83d\udd17 1 #define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP() Source code \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP #define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP #include <batteries/config.hpp> #include <batteries/logging.hpp> #include <batteries/async/worker_pool.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ WorkerPool & WorkerPool :: default_pool () { static WorkerPool * pool_ = [] { static const usize cpu_count = std :: thread :: hardware_concurrency (); // These are intentionally leaked to prevent shutdown issues. // auto * thread_pool = new std :: vector < std :: thread > ; auto * io = new std :: vector < std :: unique_ptr < boost :: asio :: io_context >> ; auto * pool = new WorkerPool ; for ( usize i = 0 ; i < cpu_count / 2 ; ++ i ) { io -> emplace_back ( std :: make_unique < boost :: asio :: io_context > ()); io -> back () -> get_executor (). on_work_started (); thread_pool -> emplace_back ([ p_io = io -> back (). get (), i ] { if ( cpu_count >= 4 ) { cpu_set_t mask ; CPU_ZERO ( & mask ); usize c0 = ( i / 2 ) * 4 ; for ( usize j = c0 ; j < c0 + 4 ; ++ j ) { CPU_SET ( j % cpu_count , & mask ); BATT_VLOG ( 1 ) << \"worker[\" << i << \"]: cpu \" << j ; } BATT_CHECK_EQ ( 0 , sched_setaffinity ( 0 , sizeof ( mask ), & mask )) << \"cpu=\" << i << \" err=\" << std :: strerror ( errno ); } p_io -> run (); }); pool -> workers_ . emplace_back ( std :: make_unique < Worker > ( io -> back () -> get_executor ())); } return pool ; }(); return * pool_ ; } } // namespace batt #endif // BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries/async/worker_pool_impl.hpp"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#namespaces","text":"Name batt","title":"Namespaces"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#defines","text":"Name BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP","title":"Defines"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#batteries_async_worker_pool_impl_hpp","text":"1 #define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP()","title":"BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 //######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+ // Copyright 2022 Anthony Paul Astolfi // #pragma once #ifndef BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP #define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP #include <batteries/config.hpp> #include <batteries/logging.hpp> #include <batteries/async/worker_pool.hpp> namespace batt { //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- - - - - // BATT_INLINE_IMPL /*static*/ WorkerPool & WorkerPool :: default_pool () { static WorkerPool * pool_ = [] { static const usize cpu_count = std :: thread :: hardware_concurrency (); // These are intentionally leaked to prevent shutdown issues. // auto * thread_pool = new std :: vector < std :: thread > ; auto * io = new std :: vector < std :: unique_ptr < boost :: asio :: io_context >> ; auto * pool = new WorkerPool ; for ( usize i = 0 ; i < cpu_count / 2 ; ++ i ) { io -> emplace_back ( std :: make_unique < boost :: asio :: io_context > ()); io -> back () -> get_executor (). on_work_started (); thread_pool -> emplace_back ([ p_io = io -> back (). get (), i ] { if ( cpu_count >= 4 ) { cpu_set_t mask ; CPU_ZERO ( & mask ); usize c0 = ( i / 2 ) * 4 ; for ( usize j = c0 ; j < c0 + 4 ; ++ j ) { CPU_SET ( j % cpu_count , & mask ); BATT_VLOG ( 1 ) << \"worker[\" << i << \"]: cpu \" << j ; } BATT_CHECK_EQ ( 0 , sched_setaffinity ( 0 , sizeof ( mask ), & mask )) << \"cpu=\" << i << \" err=\" << std :: strerror ( errno ); } p_io -> run (); }); pool -> workers_ . emplace_back ( std :: make_unique < Worker > ( io -> back () -> get_executor ())); } return pool ; }(); return * pool_ ; } } // namespace batt #endif // BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP Updated on 26 August 2022 at 17:30:03 UTC","title":"Source code"},{"location":"_autogen/Modules/","text":"Modules \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"Modules"},{"location":"_autogen/Namespaces/","text":"Namespaces \ud83d\udd17 namespace batt namespace constants namespace detail namespace int_types namespace seq namespace batt::@104 namespace batteries namespace pico_http namespace detail namespace pico_http::detail::@107 namespace std Updated on 26 August 2022 at 17:30:03 UTC","title":"Namespaces"},{"location":"_autogen/Namespaces/namespacebatt/","text":"batt \ud83d\udd17 Namespaces \ud83d\udd17 Name batt::constants batt::detail batt::int_types batt::seq Classes \ud83d\udd17 Name class batt::AbstractHandler class batt::AbstractStackAllocator class batt::AbstractValue class batt::AbstractValueImpl class batt::AbstractValuePointer class batt::BasicFakeExecutor struct batt::BasicInterval class batt::BasicRateLimiter class batt::BasicStateMachineEntropySource class batt::BoxedSeq class batt::BufferSource class batt::BufferViewImpl class batt::CaseOfVisitor class batt::Channel class batt::ConstBufferView class batt::CountMetric class batt::CountMetricExporter class batt::CpuCacheLineIsolated class batt::CustomAllocHandler class batt::DebugInfoFrame struct batt::DecayRValueRefImpl class batt::DefaultHttpClient class batt::DerivedMetricExporter struct batt::DoNothing struct batt::EscapedStringLiteral class batt::ExhaustiveModelChecker struct batt::ExponentialBackoff class batt::FakeExecutionContext class batt::FakeTaskScheduler class batt::FakeTimeService class batt::FilterBufferSource class batt::FinalAct class batt::Future class batt::Grant struct batt::GreatestLowerBound class batt::HandlerAllocator class batt::HandlerBinder class batt::HandlerImpl class batt::HandlerMemory class batt::HandlerMemoryBase struct batt::HexByteDumper struct batt::HostAddress class batt::HttpChunkDecoder class batt::HttpClient class batt::HttpClientConnection class batt::HttpClientHostContext struct batt::HttpData class batt::HttpMessageBase class batt::HttpRequest class batt::HttpResponse class batt::HttpServer struct batt::HttpVersion struct batt::IClosed struct batt::IClosedOpen struct batt::InPlaceInitType struct batt::IntervalTraits struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn > struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn > struct batt::IntervalTraitsBase class batt::IOResult struct batt::IsBoxedSeq struct batt::IsBoxedSeq< BoxedSeq< T > > struct batt::IsTuple struct batt::IsTuple< std::tuple< Ts... > > struct batt::IsVariant struct batt::IsVariant< std::variant< Ts... > > class batt::kMoveOnly class batt::Latch class batt::LatencyMetric class batt::LatencyTimer struct batt::LeastUpperBound class batt::ManagedBuffer class batt::MapBufferSource struct batt::MapTuple struct batt::MapTuple< PerTypeT, std::tuple< Ts... > > class batt::MetricCsvFormatter class batt::MetricDumper class batt::MetricExporter class batt::MetricFormatter struct batt::MetricLabel class batt::MetricRegistry struct batt::MorphTuple struct batt::MorphTuple< TemplateT, std::tuple< Ts... > > class batt::MutableBufferView class batt::Mutex struct batt::NoneType struct batt::NoopDeleter class batt::NullTaskScheduler class batt::Optional class batt::Optional< T & > class batt::Pin class batt::Pinnable class batt::PrependBufferSource class batt::Promise class batt::Queue class batt::QueueBase class batt::QueueDepthExporter class batt::RadixQueue class batt::RangeDumper class batt::RateMetric class batt::Ref struct batt::RemoveStatusOrImpl struct batt::RemoveStatusOrImpl< StatusOr< T > > struct batt::RetryState class batt::RunningTotal class batt::Runtime class batt::ScopedWorkContext class batt::SeqBufferSource struct batt::SeqItem_Impl struct batt::SharedPtrImpl class batt::SkipN struct batt::SkipNBinder class batt::SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. class batt::StackAllocator class batt::StackAllocatorImpl struct batt::StateMachineBranch class batt::StateMachineModel struct batt::StateMachineModelCheckAdvancedOptions struct batt::StateMachineResult struct batt::StateMachineTraits struct batt::StaticBinaryAssertion struct batt::StaticSameTypeAssertion struct batt::StaticType struct batt::StaticValue class batt::Status class batt::StatusOr class batt::StatusOr< Status > class batt::StatusOr< StatusOr< T > > class batt::StochasticModelChecker class batt::StreamBuffer class batt::StrongType class batt::SubRangeSeq class batt::TakeNSource class batt::Task class batt::TaskScheduler struct batt::TaskSleepImpl struct batt::TupleIndexOf struct batt::TupleIndexOf< std::tuple< First, Rest... >, T > struct batt::TupleIndexOf< std::tuple< T, Rest... >, T > struct batt::TupleIndexOf< std::tuple<>, T > class batt::TypeErasedStorage class batt::TypeErasedStorageBase class batt::UniqueHandler struct batt::UrlParse class batt::VariableExporter class batt::VarSizeArray class batt::VecSeq struct batt::VecSeqBase class batt::Watch class batt::Watch< bool > class batt::Watch< i16 > class batt::Watch< i32 > class batt::Watch< i64 > class batt::Watch< i8 > class batt::Watch< u16 > class batt::Watch< u32 > class batt::Watch< u64 > class batt::Watch< u8 > class batt::Watch< void * > class batt::WatchAtomic class batt::WatchExporter class batt::WorkContext class batt::Worker class batt::WorkerPool struct batt::WorkSliceParams struct batt::WorkSlicePlan Types \ud83d\udd17 Name enum StackType { kFixedSize = 0, kProtectedFixedSize = 1, kPooledFixedSize = 2, kMaxValue} enum bool WaitForResource { kFalse = false, kTrue = true} enum bool InclusiveLowerBound { kFalse = false, kTrue = true} enum bool InclusiveUpperBound { kFalse = false, kTrue = true} enum int StatusCode { kOk = 0, kCancelled = 1, kUnknown = 2, kInvalidArgument = 3, kDeadlineExceeded = 4, kNotFound = 5, kAlreadyExists = 6, kPermissionDenied = 7, kResourceExhausted = 8, kFailedPrecondition = 9, kAborted = 10, kOutOfRange = 11, kUnimplemented = 12, kInternal = 13, kUnavailable = 14, kDataLoss = 15, kUnauthenticated = 16, kClosed = 100, kGrantUnavailable = 101, kLoopBreak = 102, kEndOfStream = 103, kClosedBeforeEndOfStream = 104, kGrantRevoked = 105} enum ErrnoValue { } enum LogLevel { kFatal, kError, kWarning, kInfo, kDebug, kVerbose} enum Pretty { True, False, Default} using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( PartsCount , _TAG)> PartsCount using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( PartSize , _TAG)> PartSize template <typename T > using decltype(detail::has_const_buffer_sequence_requirements_impl< T >(nullptr)) HasConstBufferSequenceRequirements template <typename T > using std::enable_if_t< has_const_buffer_sequence_requirements< T >()> EnableIfConstBufferSequence template <typename T > using decltype(detail::has_buffer_source_requirements_impl< T >(nullptr)) HasBufferSourceRequirements template <typename T > using std::enable_if_t< has_buffer_source_requirements< T >()> EnableIfBufferSource using boost::context::continuation Continuation using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( StackSize , _TAG)> StackSize using BasicFakeExecutor < boost::asio::execution::outstanding_work_t::untracked_t > FakeExecutor template <typename... Args> using boost::intrusive::list< AbstractHandler < Args... > > HandlerList using boost::system::error_code ErrorCode using BasicRateLimiter < std::chrono::steady_clock > RateLimiter using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( TaskCount , _TAG)> TaskCount using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( InputSize , _TAG)> InputSize using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( TaskSize , _TAG)> TaskSize using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( TaskIndex , _TAG)> TaskIndex using :: batt::StrongType < isize, BATT_STRONG_TYPEDEF_PASTE_( TaskOffset , _TAG)> TaskOffset using boost::asio::const_buffer ConstBuffer using boost::asio::mutable_buffer MutableBuffer using :: batt::StrongType < bool, BATT_STRONG_TYPEDEF_PASTE_( IncludeHttpTrailer , _TAG)> IncludeHttpTrailer using :: pico_http::MessageHeader HttpHeader template <typename T > using BasicInterval < IClosedOpen < T > > Interval template <typename T > using BasicInterval < IClosed < T > > CInterval template <typename T > using std::function< T()> DerivedMetric using std::vector< MetricLabel > MetricLabelSet template <typename T > using typename detail::NullableImpl < T >::type Nullable template <typename T > using std::unique_ptr< T, NoopDeleter > UniqueNonOwningPtr using void(*)(std::ostream &) PrintToStreamFunctionPointer template <typename T > using decltype(detail::has_seq_requirements_impl< T >(nullptr)) HasSeqRequirements template <typename T > using std::enable_if_t< has_seq_requirements< T >()> EnableIfSeq template <typename T > using typename SeqItem_Impl < T >::type SeqItem template <typename T > using boost::intrusive_ref_counter< std::decay_t< T > > RefCounted template <typename T > using decltype(detail::is_ref_counted_impl< std::decay_t< T > >(nullptr)) IsRefCounted template <typename T > using typename SharedPtrImpl < T >::type SharedPtr template <typename T > using boost::iterator_range< T * > Slice template <typename Signature ,usize kMaxSize =kCpuCacheLineSize - sizeof(void*)> using SmallFn < Signature, kMaxSize, true > UniqueSmallFn A type-erased container for a move-only callable function-like object. template <typename T ,usize kStaticSize =kDefaultSmallVecSize> using boost::container::small_vector< T, kStaticSize > SmallVec template <typename T > using boost::container::small_vector_base< T > SmallVecBase using BasicStateMachineEntropySource < std::function< usize(usize min_value, usize max_value)> > StateMachineEntropySource template <typename T > using detail::IsStatusOrImpl < std::decay_t< T > > IsStatusOr template <typename T > using typename RemoveStatusOrImpl < T >::type RemoveStatusOr using boost::flyweights::flyweight< std::string, boost::flyweights::no_tracking > Token template <template< typename... > class TemplateT,typename TupleT > using typename MorphTuple < TemplateT, std::decay_t< TupleT > >::type MorphTuple_t template <template< typename > class PerTypeT,typename TupleT > using typename MapTuple < PerTypeT, std::decay_t< TupleT > >::type MapTuple_t template <typename Fn ,typename... Args> using decltype(detail::is_callable_impl< Fn, Args... >(nullptr)) IsCallable template <typename T > using decltype(detail::is_printable_impl< T >(nullptr)) IsPrintable template <typename T > using decltype(detail::is_range_impl< T >(nullptr)) IsRange template <typename T ,typename... Args> using std::enable_if_t<!std::is_same< std::tuple< std::decay_t< T > * >, std::tuple< std::decay_t< Args > ... > >{} &&!std::is_same< std::tuple<>, std::tuple< std::decay_t< Args > ... > >{} > EnableIfNoShadow template <typename T > using typename DecayRValueRefImpl < T >::type DecayRValueRef template <typename T ,typename U =T> using decltype(detail::can_be_eq_compared_helper< T, U >(nullptr, nullptr)) CanBeEqCompared template <typename T > using decltype(unwrap_ref(std::declval< T >())) UnwrapRefType Functions \ud83d\udd17 Name template <typename Iter ,typename T ,typename BinaryOp > Slice< T > parallel_accumulate_partial ( WorkContext & context, Iter first, Iter last, T init, const BinaryOp & binary_op, T identity, const Slice< T > & task_result_buffer, const WorkSliceParams & params) template <typename Iter ,typename T ,typename BinaryOp > T parallel_accumulate ( WorkerPool & worker_pool, Iter first, Iter last, T init, const BinaryOp & binary_op, T identity, TaskSize min_task_size = TaskSize {4096}, TaskCount max_tasks = TaskCount {std::thread::hardware_concurrency()}) template <typename Src ,typename Dst > void parallel_copy ( WorkContext & work_context, Src src_begin, Src src_end, Dst dst_begin, TaskSize min_task_size, TaskCount max_tasks) template <typename Src0 ,typename Src1 ,typename Dst ,typename Compare > void parallel_merge ( WorkerPool & worker_pool, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare && compare, usize min_task_size =1400, usize max_tasks =std::thread::hardware_concurrency()/2) template <typename Src0 ,typename Src1 ,typename Dst ,typename Compare > void parallel_merge ( WorkContext & context, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare && compare, usize min_task_size =1400, usize max_tasks =std::thread::hardware_concurrency()/2) template <typename Iter ,typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool, Iter first, Iter last, const Fn & fn, const WorkSliceParams & params) template <typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool, Iter first, Iter last, const WorkSliceParams & params) template <typename Src ,typename Dst ,typename TransformFn > void parallel_transform ( WorkContext & work_context, Src src_begin, Src src_end, Dst dst_begin, const TransformFn & transform_fn, TaskSize min_task_size, TaskCount max_tasks) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( PartsCount , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( PartSize , _TAG) * ) template <typename T ,typename =std::enable_if_t {}>> decltype(auto) make_printable (T && obj) template <typename T ,typename =std::enable_if_t<!IsPrintable {}>,typename =void> std::string make_printable (T && obj) void fail_check_exit () template <typename... Ts> bool ignore (Ts && ...) bool lock_fail_check_mutex () template <typename RetryPolicy ,typename ActionFn ,typename Result =std::invoke_result_t ,typename SleepImpl =TaskSleepImpl> Result with_retry_policy (RetryPolicy && policy, std::string_view action_name, ActionFn && action_fn, SleepImpl && sleep_impl ={}) void update_retry_state ( RetryState & state, const ExponentialBackoff & policy) template <typename T > constexpr bool has_const_buffer_sequence_requirements ( StaticType < T > ={}) template <typename T > constexpr bool has_buffer_source_requirements ( StaticType < T > ={}) template <typename Src ,typename =EnableIfBufferSource > TakeNSource < Src > **[operator template <typename Src ,typename =EnableIfBufferSource > void **[operator template <typename Src ,typename Fn ,typename =EnableIfBufferSource > StatusOr < seq::LoopControl > **[operator template <typename Src ,typename =EnableIfBufferSource > StatusOr < std::vector< char > > **[operator template <typename Src ,typename =EnableIfBufferSource > Status **[operator template <typename Src ,typename =EnableIfBufferSource > Status **[operator template <typename Src ,typename AsyncWriteStream ,typename =EnableIfBufferSource > StatusOr < usize > **[operator template <typename Src ,typename ConstBufferSequence ,typename =EnableIfBufferSource ,typename =EnableIfConstBufferSequence > auto **[operator constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( StackSize , _TAG) * ) template <typename T > const StackAllocator & get_stack_allocator_with_type ( StackSize stack_size) const StackAllocator & get_stack_allocator ( StackSize stack_size, StackType stack_type) template <typename Fn > Continuation callcc ( StackSize stack_size, StackType stack_type, Fn && fn) void this_task_debug_info (std::ostream & out) void print_debug_info ( DebugInfoFrame * p, std::ostream & out) void print_all_threads_debug_info (std::ostream & out) const char * shortened_source_file (const char * raw) bool enable_dump_tasks () template <typename OutstandingWorkP > constexpr bool operator== (const BasicFakeExecutor < OutstandingWorkP > & l, const BasicFakeExecutor < OutstandingWorkP > & r) template <typename OutstandingWorkP > constexpr bool operator!= (const BasicFakeExecutor < OutstandingWorkP > & l, const BasicFakeExecutor < OutstandingWorkP > & r) bool operator< (const FakeTimeService::TimerInstance & l, const FakeTimeService::TimerInstance & r) bool operator> (const FakeTimeService::TimerInstance & l, const FakeTimeService::TimerInstance & r) template <typename T > Future < T > get_future (const Promise < T > & promise) std::ostream & operator<< (std::ostream & out, const Grant & t) template <typename... Args,typename HandlerFn > void push_handler (HandlerList< Args... > * list, HandlerFn && fn) template <typename... Params,typename... Args> void invoke_all_handlers (HandlerList< Params... > * handlers, Args &&... args) template <typename InnerFn ,typename OuterFn > HandlerBinder < std::decay_t< InnerFn >, std::decay_t< OuterFn > > bind_handler (InnerFn && inner, OuterFn && outer) template <typename Handler > CustomAllocHandler < std::decay_t< Handler > > make_custom_alloc_handler ( HandlerMemoryBase & m, Handler && h) template <typename... Ts> std::ostream & operator<< (std::ostream & out, const IOResult < Ts... > & t) template <typename... Ts> bool is_ok_status (const IOResult < Ts... > & io_result) bool is_ok_status (const ErrorCode & ec) template <typename... Ts> Status to_status (const IOResult < Ts... > & io_result) template <typename T > void pin_object (T * object) template <typename T > void unpin_object (T * object) template <typename T > Pin < T > make_pin (T * object) template <typename T ,typename U > bool operator== (const Pin < T > & l, const Pin < U > & r) template <typename T ,typename U > bool operator!= (const Pin < T > & l, const Pin < U > & r) template <typename T > bool operator== (const Pin < T > & l, std::nullptr_t ) template <typename T > bool operator!= (const Pin < T > & l, std::nullptr_t ) template <typename U > bool operator== (std::nullptr_t , const Pin < U > & r) template <typename U > bool operator!= (std::nullptr_t , const Pin < U > & r) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskCount , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( InputSize , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskSize , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskIndex , _TAG) * ) constexpr isize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskOffset , _TAG) * ) template <typename Iter > InputSize get_input_size (const Iter & first, const Iter & last) std::ostream & operator<< (std::ostream & out, const WorkSliceParams & t) TaskSize get_task_size (const WorkSliceParams & params, InputSize input_size) TaskCount get_task_count ( InputSize input_size, TaskSize task_size) std::ostream & operator<< (std::ostream & out, const WorkSlicePlan & t) template <typename WorkFnGenerator > void slice_work ( WorkContext & context, const WorkSlicePlan & plan, WorkFnGenerator && gen_work_fn) template <typename T > StatusOr < std::reference_wrapper< StreamBuffer > > operator<< ( StatusOr < std::reference_wrapper< StreamBuffer >> stream_buffer, T && obj) i32 next_thread_id () i32 & this_thread_id () i8 least_upper_bound (i8 n) i8 greatest_lower_bound (i8 n) i16 least_upper_bound (i16 n) i16 greatest_lower_bound (i16 n) i32 least_upper_bound (i32 n) i32 greatest_lower_bound (i32 n) i64 least_upper_bound (i64 n) i64 greatest_lower_bound (i64 n) u8 least_upper_bound (u8 n) u8 greatest_lower_bound (u8 n) u16 least_upper_bound (u16 n) u16 greatest_lower_bound (u16 n) u32 least_upper_bound (u32 n) u32 greatest_lower_bound (u32 n) u64 least_upper_bound (u64 n) u64 greatest_lower_bound (u64 n) template <typename T > LeastUpperBound < std::decay_t< T > > least_upper_bound (T && value) template <typename T ,typename U > bool operator< (const T & left, const LeastUpperBound < U > & right) template <typename T ,typename U > bool operator< (const LeastUpperBound < T > & left, const U & right) template <typename T ,typename U > bool operator< (const LeastUpperBound < T > & left, const LeastUpperBound < U > & right) template <typename T ,typename U > bool operator== (const T & , const LeastUpperBound < U > & ) template <typename T ,typename U > bool operator== (const LeastUpperBound < T > & , const U & ) template <typename T ,typename U > bool operator== (const LeastUpperBound < T > & left, const LeastUpperBound < U > & right) template <typename T ,typename U > bool operator> (const T & l, const LeastUpperBound < U > & r) BATT_UNWRAP (template< typename T, typename U > inline) U bool operator> (const LeastUpperBound < T > & l, const U & r) U bool operator> (const LeastUpperBound < T > & l, const LeastUpperBound < U > & r) U bool operator!= (const T & l, const LeastUpperBound < U > & r) template <typename T ,typename U > bool operator!= (const LeastUpperBound < T > & l, const U & r) template <typename T ,typename U > bool operator!= (const LeastUpperBound < T > & l, const LeastUpperBound < U > & r) template <typename T ,typename U > GreatestLowerBound < std::decay_t< T > > greatest_lower_bound (T && value) template <typename T ,typename U > bool operator< (const T & left, const GreatestLowerBound < U > & right) template <typename T ,typename U > bool operator< (const GreatestLowerBound < T > & left, const U & right) template <typename T ,typename U > bool operator< (const GreatestLowerBound < T > & left, const GreatestLowerBound < U > & right) template <typename T ,typename U > bool operator== (const T & , const GreatestLowerBound < U > & ) template <typename T ,typename U > bool operator== (const GreatestLowerBound < T > & , const U & ) template <typename T ,typename U > bool operator== (const GreatestLowerBound < T > & left, const GreatestLowerBound < U > & right) template <typename T ,typename U > bool operator> (const T & l, const GreatestLowerBound < U > & r) U bool operator> (const GreatestLowerBound < T > & l, const U & r) U bool operator> (const GreatestLowerBound < T > & l, const GreatestLowerBound < U > & r) U bool operator!= (const T & l, const GreatestLowerBound < U > & r) template <typename T ,typename U > bool operator!= (const GreatestLowerBound < T > & l, const U & r) template <typename T ,typename U > bool operator!= (const GreatestLowerBound < T > & l, const GreatestLowerBound < U > & r) template <typename... Args> decltype(auto) make_buffer (Args &&... args) template <typename T > ConstBuffer buffer_from_struct (const T & val) template <typename T > MutableBuffer mutable_buffer_from_struct (T & val) ConstBuffer resize_buffer (const ConstBuffer & b, usize s) MutableBuffer resize_buffer (const MutableBuffer & b, usize s) template <typename VecT > void consume_buffers (VecT & buffers, usize count) template <typename Iter > std::pair< Iter, usize > consume_buffers_iter (const std::pair< Iter, usize > & pos, const Iter & last, usize count) template <typename VecT > VecT consume_buffers_copy (const VecT & buffers, usize count) template <typename... Cases> CaseOfVisitor < Cases &&... > make_case_of_visitor (Cases &&... cases) Constructs and returns a single overloaded callable function object that forwards its arguments on to the first object in cases that is callable with those arguments. template <typename VarType ,typename... Cases> decltype(auto) case_of (VarType && v, Cases &&... cases) Matches a variant against a list of callables and apply the first one that will accept the current value. template <typename T ,typename Var > bool is_case (Var && v) template <typename ToType ,typename FromType ,typename =std::enable_if_t == std::is_signed_v\\ >> ToType checked_cast (FromType val, const char * file =\"\", int line =0) template <typename ToType ,typename FromType ,typename =std::enable_if_t && !std::is_signed_v\\ >,typename =void> ToType checked_cast (FromType val, const char * file =\"\", int line =0) template <typename ToType ,typename FromType ,typename =std::enable_if_t<!std::is_signed_v && std::is_signed_v >,typename =void,typename =void> ToType checked_cast (FromType val, const char * file =\"\", int line =0) template <typename T > std::ostream & operator<< (std::ostream & out, const CpuCacheLineIsolated < T > & t) Status pin_thread_to_cpu (usize cpu_i) template <typename... Args> void do_nothing (Args && ...) template <typename T > Optional < T > getenv_as (const char * var_name) template <typename Fn > auto finally (Fn && fn) usize hash () template <typename T > usize hash (T && obj) template <typename T ,typename HashT =typename std::decay_t ::Hash> usize hash_value (T && obj) template <typename First ,typename... Rest> usize hash (First && first, Rest &&... rest) StatusOr < SmallVec< boost::asio::ip::tcp::endpoint > > await_resolve (boost::asio::ip::tcp::resolver & resolver, const HostAddress & host_address) StatusOr < SmallVec< boost::asio::ip::tcp::endpoint > > await_resolve (boost::asio::io_context & io, const HostAddress & host_address) usize hash_value (const HostAddress & host_key) bool operator== (const HostAddress & l, const HostAddress & r) bool operator!= (const HostAddress & l, const HostAddress & r) std::ostream & operator<< (std::ostream & out, const HostAddress & t) template <typename Src ,typename AsyncWriteStream > Status http_encode_chunked (Src && src, AsyncWriteStream && dst, IncludeHttpTrailer include_trailer = IncludeHttpTrailer {false}) template <typename... Params> StatusOr < std::unique_ptr< HttpResponse > > http_request (std::string_view method, std::string_view url, Params &&... params) template <typename... Params> StatusOr < std::unique_ptr< HttpResponse > > http_get (std::string_view url, Params &&... params) template <typename... Params> StatusOr < std::unique_ptr< HttpResponse > > http_post (std::string_view url, Params &&... params) constexpr bool strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( IncludeHttpTrailer , _TAG) * ) Optional < std::string_view > find_header (const SmallVecBase< HttpHeader > & headers, const std::string_view & name) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > push_back (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > push_front (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > pop_back (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > pop_front (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename T ,typename U > BasicInterval < IClosedOpen < std::decay_t< T >, std::decay_t< U > > > make_interval (T && lower, U && upper) template <typename TraitsL ,typename TraitsR > bool operator== (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) template <typename TraitsL ,typename TraitsR > bool operator!= (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) template <typename Traits > std::ostream & operator<< (std::ostream & out, const BasicInterval < Traits > & t) template <typename Traits0 ,typename Traits1 > constexpr bool interval_traits_compatible () constexpr i32 log2_ceil (u64 i) constexpr i32 log2_floor (u64 i) template <typename IntT > constexpr IntT lsb_mask (i32 bits) template <typename IntT > constexpr IntT round_down_bits (i32 bits, IntT n) template <typename IntT > constexpr IntT round_up_bits (i32 bits, IntT n) template <typename IntT > constexpr IntT ipow (IntT base, IntT exponent, IntT accumulator =static_cast< IntT >(1)) std::ostream & operator<< (std::ostream & out, const LatencyMetric & t) MetricLabelSet normalize_labels (MetricLabelSet && labels) MetricRegistry & global_metric_registry () template <typename T > auto make_nullable (T && obj) template <typename T0 ,typename T1 > bool operator== (const Optional < T0 > & v0, const Optional < T1 > & v1) template <typename T0 ,typename T1 > bool operator!= (const Optional < T0 > & v0, const Optional < T1 > & v1) template <typename T0 ,typename T1 > bool operator== (const Optional < T0 > & v0, const T1 & v1) template <typename T0 ,typename T1 > bool operator!= (const Optional < T0 > & v0, const T1 & v1) template <typename T0 ,typename T1 > bool operator== (const T0 & v0, const Optional < T1 > & v1) template <typename T0 ,typename T1 > bool operator!= (const T0 & v0, const Optional < T1 > & v1) template <typename T > bool operator== ( NoneType , const Optional < T > & v) template <typename T > bool operator!= ( NoneType , const Optional < T > & v) template <typename T > bool operator== (const Optional < T > & v, NoneType ) template <typename T > bool operator!= (const Optional < T > & v, NoneType ) template <typename T > std::ostream & operator<< (std::ostream & out, const Optional < T > & t) std::ostream & operator<< (std::ostream & out, const NoneType & ) template <typename T > Optional < std::decay_t< T > > make_optional (T && val) template <typename T > decltype(auto) get_or_panic ( Optional < T > & opt) template <typename T > decltype(auto) get_or_panic (const Optional < T > & opt) template <typename T > decltype(auto) get_or_panic ( Optional < T > && opt) template <usize N_> std::ostream & operator<< (std::ostream & out, const RadixQueue < N_ > & t) template <typename T > std::ostream & operator<< (std::ostream & out, const Ref < T > & t) template <typename T > Ref < T > as_ref (T & obj_ref) template <typename T > Ref < const T > as_cref (const T & obj_ref) template <typename T > Ref < T > into_ref (T * ptr) template <typename T > Ref < const T > into_cref (const T * ptr) template <typename T > T & unwrap_ref (const Ref < T > & wrapper) std::atomic< PrintToStreamFunctionPointer > & extra_segv_debug_info_callback () void print_stack_trace () bool & print_stack_trace_atexit_enabled () void print_stack_trace_atexit () template <typename T > constexpr bool has_seq_requirements ( StaticType < T > ={}) SkipNBinder skip_n (usize n) template <typename Seq ,typename =EnableIfSeq > SkipN < Seq > **[operator template <typename T ,typename =decltype(std::declval ().front()),typename =decltype(std::declval ().drop_front())> SubRangeSeq < T > as_seq (T && sub_range) template <typename ForwardIter > auto as_seq (ForwardIter && begin, ForwardIter && end) template <typename VectorLike ,typename =decltype(std::declval ().data()),typename =decltype(std::declval ().size())> auto as_seq (VectorLike && v) template <typename T ,typename Begin =decltype(std::declval ().data()),typename End =decltype(std::declval () + std::declval ().size()),typename =std::enable_if_t >> auto vec_range (const T & vec) template <typename T > auto into_seq (std::vector< T > && v) template <typename T ,typename... Args,typename =std::enable_if_t {}>> SharedPtr< T > make_shared (Args &&... args) template <typename T ,typename... Args,typename =std::enable_if_t<!IsRefCounted {}>,typename =void> SharedPtr< T > make_shared (Args &&... args) template <typename T > SharedPtr< T > into_shared (std::unique_ptr< T > && ptr) template <typename T ,typename =std::enable_if_t< std::is_same_v , std::shared_ptr\\ >>>> SharedPtr< T > shared_ptr_from (T * that) template <typename T ,typename =std::enable_if_t< std::is_same_v , boost::intrusive_ptr\\ >>>,typename =void> SharedPtr< T > shared_ptr_from (T * that) template <typename T ,typename DataT =decltype(std::declval ().data()),typename =std::enable_if_t >,typename ElementT =typename std::pointer_traits ::element_type> Slice< ElementT > as_slice (T && container) template <typename ElementT > Slice< ElementT > as_slice (ElementT * begin, ElementT * end) template <typename ElementT > Slice< ElementT > as_slice (ElementT * begin, usize size) template <typename ElementT > Slice< ElementT > as_slice (const Slice< ElementT > & slice) template <typename ElementT > Slice< const ElementT > as_const_slice (const ElementT * begin, const ElementT * end) template <typename ElementT > Slice< const ElementT > as_const_slice (const ElementT * begin, usize size) template <typename T ,typename DataT =decltype(std::declval ().data()),typename =std::enable_if_t >,typename ElementT =typename std::pointer_traits ::element_type> Slice< const ElementT > as_const_slice (const T & container) template <typename ElementT > Slice< ElementT > empty_slice ( StaticType < ElementT > ={}) template <typename T > SubRangeSeq < Slice< T > > as_seq (const Slice< T > & s) template <typename T > auto as_seq (Slice< T > & s) template <typename T > auto as_seq (Slice< T > && s) template <typename T > auto as_seq (const Slice< T > && s) template <typename Iter > boost::iterator_range< Iter > as_range (const std::pair< Iter, Iter > & p) template <typename RangeT ,typename Iter =std::decay_t ()))>,typename OffsetT ,typename =std::enable_if_t >> boost::iterator_range< Iter > slice_range (RangeT && range, const Interval < OffsetT > & i) void copy_string (SmallVecBase< char > & dst, const std::string_view & src) std::string_view as_str (const SmallVecBase< char > & v) template <typename StateT ,typename StateHash ,typename StateEqual > std::ostream & operator<< (std::ostream & out, const StateMachineBranch < StateT, StateHash, StateEqual > & t) template <typename StateT ,typename StateHash ,typename StateEqual > bool operator== (const StateMachineBranch < StateT, StateHash, StateEqual > & l, const StateMachineBranch < StateT, StateHash, StateEqual > & r) template <typename StateT ,typename StateHash ,typename StateEqual > usize hash_value (const StateMachineBranch < StateT, StateHash, StateEqual > & branch) StateMachineResult combine_results (const StateMachineResult & a, const StateMachineResult & b) std::ostream & operator<< (std::ostream & out, const StateMachineResult & r) template <typename IntT ,IntT kBegin,IntT kEnd,typename Fn ,typename R =decltype(std::declval ()(std::integral_constant {}))> R static_dispatch (IntT i, Fn && fn) template <typename Fn > decltype(auto) static_dispatch (bool b, Fn && fn) template <typename Tuple ,typename Fn > decltype(auto) static_dispatch (std::size_t i, Fn && fn) std::ostream & operator<< (std::ostream & out, const Status & t) bool operator== (const Status & l, const Status & r) bool operator!= (const Status & l, const Status & r) Status OkStatus () template <typename T ,typename U ,typename =std::enable_if_t {}>> bool operator== (const StatusOr < T > & l, const StatusOr < U > & r) template <typename T ,typename U ,typename =std::enable_if_t<!CanBeEqCompared {}>,typename =void> bool operator== (const StatusOr < T > & l, const StatusOr < U > & r) template <typename T ,typename U > bool operator!= (const StatusOr < T > & l, const StatusOr < U > & r) bool is_ok_status (const std::error_code & ec) template <typename T > bool is_ok_status (const T & val) LogLevel & require_fail_thread_default_log_level () template <typename T ,typename =std::enable_if_t {} && !std::is_same_v\\ , StatusOr\\ >>> decltype(auto) to_status (T && v) template <typename T ,typename =std::enable_if_t<std::is_same_v , Status> template <typename T ,typename =std::enable_if_t<std::is_same_v , boost::system::error_code> Status status_from_errno (int code) template <typename T > Status status_from_retval (T retval) template <typename T > T && ok_result_or_panic ( StatusOr < T > && result) template <typename T ,typename =std::enable_if_t >{} && !std::is_same_v\\ , StatusOr\\ >>> std::ostream & operator<< (std::ostream & out, T && status_or) bool status_is_retryable (const Status & s) std::ostream & print_all (std::ostream & out) template <typename First ,typename... Rest> std::ostream & print_all (std::ostream & out, First && first, Rest &&... rest) std::istream & extract_all (std::istream & in) template <typename First ,typename... Rest> std::istream & extract_all (std::istream & in, First && first, Rest &&... rest) template <typename... Args> std::string to_string (Args &&... args) template <typename T ,typename... FormatArgs> std::optional< T > from_string (const std::string & str, FormatArgs &&... format_args) EscapedStringLiteral c_str_literal (const std::string_view & str) template <typename T ,typename =std::enable_if_t >> Optional < EscapedStringLiteral > c_str_literal (const Optional < T > & maybe_str) Optional < EscapedStringLiteral > c_str_literal (const NoneType & ) decltype(auto) make_printable (std::string & str) decltype(auto) make_printable (std::string && str) decltype(auto) make_printable (const std::string & str) decltype(auto) make_printable (const std::string && str) decltype(auto) make_printable (std::string_view & str) decltype(auto) make_printable (std::string_view && str) decltype(auto) make_printable (const std::string_view & str) decltype(auto) make_printable (const std::string_view && str) const std::string_view & StringUpperBound () std::ostream & operator<< (std::ostream & out, const EscapedStringLiteral & t) std::ostream & operator<< (std::ostream & out, const HexByteDumper & t) HexByteDumper dump_hex (const void * ptr, usize size) template <typename T > RangeDumper < const T & > dump_range (const T & value, Pretty pretty =Pretty::Default) auto pretty_print_indent () template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator+ ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator- ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator* ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator/ ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename Op > auto syscall_retry (Op && op) template <typename L ,typename R > constexpr bool operator== ( StaticType < L > , StaticType < R > ) template <typename L ,typename R > constexpr bool operator!= ( StaticType < L > , StaticType < R > ) template <typename T > auto name_of ( batt::StaticType < T > ={}) bool operator== (const UrlParse & left, const UrlParse & right) bool operator!= (const UrlParse & left, const UrlParse & right) std::ostream & operator<< (std::ostream & out, const UrlParse & t) StatusOr < UrlParse > parse_url (std::string_view url) template <typename T > T make_copy (const T & value) Return a copy of value . template <typename T ,typename =std::enable_if_t >>> T && sink (T && value) template <typename T > T sink (const T & value) template <typename T ,typename =std::enable_if_t<!std::is_same_v >> T make_default () Return a default-constructed instance of type T . template <typename T ,typename =std::enable_if_t >,typename =void> void make_default () template <typename T > T && unwrap_ref (T && obj) template <typename T > T & unwrap_ref (const std::reference_wrapper< T > & wrapper) template <typename T > T & unwrap_ref (std::reference_wrapper< T > && wrapper) template <typename T > T & unwrap_ref (std::reference_wrapper< T > & wrapper) template <typename T > T & unwrap_ref (const std::reference_wrapper< T > && wrapper) Attributes \ud83d\udd17 Name BATT_MAYBE_UNUSED :: batt::StaticBinaryAssertion < decltype(sizeof(void ) 3), decltype(sizeof(boost::context::stack_context)),(sizeof(void ) 3), struct ::batt::Eq,(sizeof(boost::context::stack_context)),((sizeof(void ) 3)==(sizeof(boost::context::stack_context)))> BOOST_PP_CAT constexpr usize kMinStackSizeLog2 constexpr usize kMaxStackSizeLog2 constexpr usize kMaxDebugInfoThreads const bool kTaskDebugInfoSegvCallbackInstalled BATT_MAYBE_UNUSED :: batt::StaticBinaryAssertion < decltype(sizeof( UniqueHandler <>)), decltype(sizeof(void )),(sizeof( UniqueHandler <>)), struct ::batt::Eq,(sizeof(void )),((sizeof( UniqueHandler <>))==(sizeof(void *)))> BOOST_PP_CAT constexpr auto kCpuCacheLineSize const bool kSigSegvHandlerInstalled constexpr usize kDefaultSmallVecSize constexpr auto TupleIndexOf_v Types Documentation \ud83d\udd17 enum StackType \ud83d\udd17 Enumerator Value Description kFixedSize 0 kProtectedFixedSize 1 kPooledFixedSize 2 kMaxValue enum WaitForResource \ud83d\udd17 Enumerator Value Description kFalse false kTrue true enum InclusiveLowerBound \ud83d\udd17 Enumerator Value Description kFalse false kTrue true enum InclusiveUpperBound \ud83d\udd17 Enumerator Value Description kFalse false kTrue true enum StatusCode \ud83d\udd17 Enumerator Value Description kOk 0 kCancelled 1 kUnknown 2 kInvalidArgument 3 kDeadlineExceeded 4 kNotFound 5 kAlreadyExists 6 kPermissionDenied 7 kResourceExhausted 8 kFailedPrecondition 9 kAborted 10 kOutOfRange 11 kUnimplemented 12 kInternal 13 kUnavailable 14 kDataLoss 15 kUnauthenticated 16 kClosed 100 kGrantUnavailable 101 kLoopBreak 102 kEndOfStream 103 kClosedBeforeEndOfStream 104 kGrantRevoked 105 enum ErrnoValue \ud83d\udd17 Enumerator Value Description enum LogLevel \ud83d\udd17 Enumerator Value Description kFatal kError kWarning kInfo kDebug kVerbose enum Pretty \ud83d\udd17 Enumerator Value Description True False Default using PartsCount \ud83d\udd17 1 using batt :: PartsCount = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( PartsCount , _TAG ) > ; using PartSize \ud83d\udd17 1 using batt :: PartSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( PartSize , _TAG ) > ; using HasConstBufferSequenceRequirements \ud83d\udd17 1 2 template < typename T > using batt :: HasConstBufferSequenceRequirements = typedef decltype ( detail :: has_const_buffer_sequence_requirements_impl < T > ( nullptr )); using EnableIfConstBufferSequence \ud83d\udd17 1 2 template < typename T > using batt :: EnableIfConstBufferSequence = typedef std :: enable_if_t < has_const_buffer_sequence_requirements < T > () > ; using HasBufferSourceRequirements \ud83d\udd17 1 2 template < typename T > using batt :: HasBufferSourceRequirements = typedef decltype ( detail :: has_buffer_source_requirements_impl < T > ( nullptr )); using EnableIfBufferSource \ud83d\udd17 1 2 template < typename T > using batt :: EnableIfBufferSource = typedef std :: enable_if_t < has_buffer_source_requirements < T > () > ; using Continuation \ud83d\udd17 1 using batt :: Continuation = typedef boost :: context :: continuation ; using StackSize \ud83d\udd17 1 using batt :: StackSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( StackSize , _TAG ) > ; using FakeExecutor \ud83d\udd17 1 using batt :: FakeExecutor = typedef BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ; using HandlerList \ud83d\udd17 1 2 template < typename ... Args > using batt :: HandlerList = typedef boost :: intrusive :: list < AbstractHandler < Args ... > > ; using ErrorCode \ud83d\udd17 1 using batt :: ErrorCode = typedef boost :: system :: error_code ; using RateLimiter \ud83d\udd17 1 using batt :: RateLimiter = typedef BasicRateLimiter < std :: chrono :: steady_clock > ; using TaskCount \ud83d\udd17 1 using batt :: TaskCount = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskCount , _TAG ) > ; using InputSize \ud83d\udd17 1 using batt :: InputSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( InputSize , _TAG ) > ; using TaskSize \ud83d\udd17 1 using batt :: TaskSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskSize , _TAG ) > ; using TaskIndex \ud83d\udd17 1 using batt :: TaskIndex = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskIndex , _TAG ) > ; using TaskOffset \ud83d\udd17 1 using batt :: TaskOffset = typedef :: batt :: StrongType < isize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskOffset , _TAG ) > ; using ConstBuffer \ud83d\udd17 1 using batt :: ConstBuffer = typedef boost :: asio :: const_buffer ; using MutableBuffer \ud83d\udd17 1 using batt :: MutableBuffer = typedef boost :: asio :: mutable_buffer ; using IncludeHttpTrailer \ud83d\udd17 1 using batt :: IncludeHttpTrailer = typedef :: batt :: StrongType < bool , BATT_STRONG_TYPEDEF_PASTE_ ( IncludeHttpTrailer , _TAG ) > ; using HttpHeader \ud83d\udd17 1 using batt :: HttpHeader = typedef :: pico_http :: MessageHeader ; using Interval \ud83d\udd17 1 2 template < typename T > using batt :: Interval = typedef BasicInterval < IClosedOpen < T > > ; using CInterval \ud83d\udd17 1 2 template < typename T > using batt :: CInterval = typedef BasicInterval < IClosed < T > > ; using DerivedMetric \ud83d\udd17 1 2 template < typename T > using batt :: DerivedMetric = typedef std :: function < T () > ; using MetricLabelSet \ud83d\udd17 1 using batt :: MetricLabelSet = typedef std :: vector < MetricLabel > ; using Nullable \ud83d\udd17 1 2 template < typename T > using batt :: Nullable = typedef typename detail :: NullableImpl < T >:: type ; using UniqueNonOwningPtr \ud83d\udd17 1 2 template < typename T > using batt :: UniqueNonOwningPtr = typedef std :: unique_ptr < T , NoopDeleter > ; using PrintToStreamFunctionPointer \ud83d\udd17 1 using batt :: PrintToStreamFunctionPointer = typedef void ( * )( std :: ostream & ); using HasSeqRequirements \ud83d\udd17 1 2 template < typename T > using batt :: HasSeqRequirements = typedef decltype ( detail :: has_seq_requirements_impl < T > ( nullptr )); using EnableIfSeq \ud83d\udd17 1 2 template < typename T > using batt :: EnableIfSeq = typedef std :: enable_if_t < has_seq_requirements < T > () > ; using SeqItem \ud83d\udd17 1 2 template < typename T > using batt :: SeqItem = typedef typename SeqItem_Impl < T >:: type ; using RefCounted \ud83d\udd17 1 2 template < typename T > using batt :: RefCounted = typedef boost :: intrusive_ref_counter < std :: decay_t < T > > ; using IsRefCounted \ud83d\udd17 1 2 template < typename T > using batt :: IsRefCounted = typedef decltype ( detail :: is_ref_counted_impl < std :: decay_t < T > > ( nullptr )); using SharedPtr \ud83d\udd17 1 2 template < typename T > using batt :: SharedPtr = typedef typename SharedPtrImpl < T >:: type ; using Slice \ud83d\udd17 1 2 template < typename T > using batt :: Slice = typedef boost :: iterator_range < T *> ; using UniqueSmallFn \ud83d\udd17 1 2 3 template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ) > using batt :: UniqueSmallFn = typedef SmallFn < Signature , kMaxSize , true > ; A type-erased container for a move-only callable function-like object. This type can be used to hold copyable functions, but is itself move-only, therefore does not require copy semantics from erased types. using SmallVec \ud83d\udd17 1 2 3 template < typename T , usize kStaticSize = kDefaultSmallVecSize > using batt :: SmallVec = typedef boost :: container :: small_vector < T , kStaticSize > ; using SmallVecBase \ud83d\udd17 1 2 template < typename T > using batt :: SmallVecBase = typedef boost :: container :: small_vector_base < T > ; using StateMachineEntropySource \ud83d\udd17 1 using batt :: StateMachineEntropySource = typedef BasicStateMachineEntropySource < std :: function < usize ( usize min_value , usize max_value ) > > ; using IsStatusOr \ud83d\udd17 1 2 template < typename T > using batt :: IsStatusOr = typedef detail :: IsStatusOrImpl < std :: decay_t < T > > ; using RemoveStatusOr \ud83d\udd17 1 2 template < typename T > using batt :: RemoveStatusOr = typedef typename RemoveStatusOrImpl < T >:: type ; using Token \ud83d\udd17 1 using batt :: Token = typedef boost :: flyweights :: flyweight < std :: string , boost :: flyweights :: no_tracking > ; using MorphTuple_t \ud83d\udd17 1 2 3 template < template < typename ... > class TemplateT , typename TupleT > using batt :: MorphTuple_t = typedef typename MorphTuple < TemplateT , std :: decay_t < TupleT > >:: type ; using MapTuple_t \ud83d\udd17 1 2 3 template < template < typename > class PerTypeT , typename TupleT > using batt :: MapTuple_t = typedef typename MapTuple < PerTypeT , std :: decay_t < TupleT > >:: type ; using IsCallable \ud83d\udd17 1 2 3 template < typename Fn , typename ... Args > using batt :: IsCallable = typedef decltype ( detail :: is_callable_impl < Fn , Args ... > ( nullptr )); using IsPrintable \ud83d\udd17 1 2 template < typename T > using batt :: IsPrintable = typedef decltype ( detail :: is_printable_impl < T > ( nullptr )); using IsRange \ud83d\udd17 1 2 template < typename T > using batt :: IsRange = typedef decltype ( detail :: is_range_impl < T > ( nullptr )); using EnableIfNoShadow \ud83d\udd17 1 2 3 template < typename T , typename ... Args > using batt :: EnableIfNoShadow = typedef std :: enable_if_t <! std :: is_same < std :: tuple < std :: decay_t < T >*> , std :: tuple < std :: decay_t < Args >* ... > > {} && ! std :: is_same < std :: tuple <> , std :: tuple < std :: decay_t < Args >* ... > > {} > ; using DecayRValueRef \ud83d\udd17 1 2 template < typename T > using batt :: DecayRValueRef = typedef typename DecayRValueRefImpl < T >:: type ; using CanBeEqCompared \ud83d\udd17 1 2 3 template < typename T , typename U = T > using batt :: CanBeEqCompared = typedef decltype ( detail :: can_be_eq_compared_helper < T , U > ( nullptr , nullptr )); using UnwrapRefType \ud83d\udd17 1 2 template < typename T > using batt :: UnwrapRefType = typedef decltype ( unwrap_ref ( std :: declval < T > ())); Functions Documentation \ud83d\udd17 function parallel_accumulate_partial \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename Iter , typename T , typename BinaryOp > Slice < T > parallel_accumulate_partial ( WorkContext & context , Iter first , Iter last , T init , const BinaryOp & binary_op , T identity , const Slice < T > & task_result_buffer , const WorkSliceParams & params ) function parallel_accumulate \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename Iter , typename T , typename BinaryOp > T parallel_accumulate ( WorkerPool & worker_pool , Iter first , Iter last , T init , const BinaryOp & binary_op , T identity , TaskSize min_task_size = TaskSize { 4096 }, TaskCount max_tasks = TaskCount { std :: thread :: hardware_concurrency ()} ) function parallel_copy \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 template < typename Src , typename Dst > void parallel_copy ( WorkContext & work_context , Src src_begin , Src src_end , Dst dst_begin , TaskSize min_task_size , TaskCount max_tasks ) function parallel_merge \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkerPool & worker_pool , Src0 src_0_begin , Src0 src_0_end , Src1 src_1_begin , Src1 src_1_end , Dst dst_begin , Compare && compare , usize min_task_size = 1400 , usize max_tasks = std :: thread :: hardware_concurrency () / 2 ) function parallel_merge \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkContext & context , Src0 src_0_begin , Src0 src_0_end , Src1 src_1_begin , Src1 src_1_end , Dst dst_begin , Compare && compare , usize min_task_size = 1400 , usize max_tasks = std :: thread :: hardware_concurrency () / 2 ) function parallel_running_total \ud83d\udd17 1 2 3 4 5 6 7 8 9 template < typename Iter , typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const Fn & fn , const WorkSliceParams & params ) function parallel_running_total \ud83d\udd17 1 2 3 4 5 6 7 template < typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const WorkSliceParams & params ) function parallel_transform \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 template < typename Src , typename Dst , typename TransformFn > void parallel_transform ( WorkContext & work_context , Src src_begin , Src src_end , Dst dst_begin , const TransformFn & transform_fn , TaskSize min_task_size , TaskCount max_tasks ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( PartsCount , _TAG ) * ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( PartSize , _TAG ) * ) function make_printable \ud83d\udd17 1 2 3 4 5 template < typename T , typename = std :: enable_if_t < IsPrintable < T > {} >> decltype ( auto ) make_printable ( T && obj ) function make_printable \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t <! IsPrintable < T > {} > , typename = void > std :: string make_printable ( T && obj ) function fail_check_exit \ud83d\udd17 1 inline void fail_check_exit () function ignore \ud83d\udd17 1 2 3 4 template < typename ... Ts > inline bool ignore ( Ts && ... ) function lock_fail_check_mutex \ud83d\udd17 1 inline bool lock_fail_check_mutex () function with_retry_policy \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 template < typename RetryPolicy , typename ActionFn , typename Result = std :: invoke_result_t < ActionFn > , typename SleepImpl = TaskSleepImpl > inline Result with_retry_policy ( RetryPolicy && policy , std :: string_view action_name , ActionFn && action_fn , SleepImpl && sleep_impl = {} ) function update_retry_state \ud83d\udd17 1 2 3 4 inline void update_retry_state ( RetryState & state , const ExponentialBackoff & policy ) function has_const_buffer_sequence_requirements \ud83d\udd17 1 2 3 4 template < typename T > inline constexpr bool has_const_buffer_sequence_requirements ( StaticType < T > = {} ) function has_buffer_source_requirements \ud83d\udd17 1 2 3 4 template < typename T > inline constexpr bool has_buffer_source_requirements ( StaticType < T > = {} ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> TakeNSource < Src > operator | ( Src && src , seq :: TakeNBinder binder ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> void operator | ( Src && src , SkipNBinder binder ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Src , typename Fn , typename = EnableIfBufferSource < Src >> inline StatusOr < seq :: LoopControl > operator | ( Src && src , seq :: ForEachBinder < Fn > && binder ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> inline StatusOr < std :: vector < char > > operator | ( Src && src , seq :: CollectVec ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: PrintOut p ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: Consume ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Src , typename AsyncWriteStream , typename = EnableIfBufferSource < Src >> StatusOr < usize > operator | ( Src && src , seq :: WriteToBinder < AsyncWriteStream > && binder ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename Src , typename ConstBufferSequence , typename = EnableIfBufferSource < Src > , typename = EnableIfConstBufferSequence < ConstBufferSequence >> inline auto operator | ( Src && src , seq :: PrependBinder < ConstBufferSequence > && binder ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( StackSize , _TAG ) * ) function get_stack_allocator_with_type \ud83d\udd17 1 2 3 4 template < typename T > inline const StackAllocator & get_stack_allocator_with_type ( StackSize stack_size ) function get_stack_allocator \ud83d\udd17 1 2 3 4 inline const StackAllocator & get_stack_allocator ( StackSize stack_size , StackType stack_type ) function callcc \ud83d\udd17 1 2 3 4 5 6 template < typename Fn > inline Continuation callcc ( StackSize stack_size , StackType stack_type , Fn && fn ) function this_task_debug_info \ud83d\udd17 1 2 3 inline void this_task_debug_info ( std :: ostream & out ) function print_debug_info \ud83d\udd17 1 2 3 4 inline void print_debug_info ( DebugInfoFrame * p , std :: ostream & out ) function print_all_threads_debug_info \ud83d\udd17 1 2 3 inline void print_all_threads_debug_info ( std :: ostream & out ) function shortened_source_file \ud83d\udd17 1 2 3 inline const char * shortened_source_file ( const char * raw ) function enable_dump_tasks \ud83d\udd17 1 inline bool enable_dump_tasks () function operator== \ud83d\udd17 1 2 3 4 5 template < typename OutstandingWorkP > inline constexpr bool operator == ( const BasicFakeExecutor < OutstandingWorkP > & l , const BasicFakeExecutor < OutstandingWorkP > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 template < typename OutstandingWorkP > inline constexpr bool operator != ( const BasicFakeExecutor < OutstandingWorkP > & l , const BasicFakeExecutor < OutstandingWorkP > & r ) function operator< \ud83d\udd17 1 2 3 4 inline bool operator < ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r ) function operator> \ud83d\udd17 1 2 3 4 inline bool operator > ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r ) function get_future \ud83d\udd17 1 2 3 4 template < typename T > inline Future < T > get_future ( const Promise < T > & promise ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Grant & t ) function push_handler \ud83d\udd17 1 2 3 4 5 6 template < typename ... Args , typename HandlerFn > inline void push_handler ( HandlerList < Args ... > * list , HandlerFn && fn ) function invoke_all_handlers \ud83d\udd17 1 2 3 4 5 6 template < typename ... Params , typename ... Args > inline void invoke_all_handlers ( HandlerList < Params ... > * handlers , Args && ... args ) function bind_handler \ud83d\udd17 1 2 3 4 5 6 template < typename InnerFn , typename OuterFn > HandlerBinder < std :: decay_t < InnerFn > , std :: decay_t < OuterFn > > bind_handler ( InnerFn && inner , OuterFn && outer ) function make_custom_alloc_handler \ud83d\udd17 1 2 3 4 5 template < typename Handler > inline CustomAllocHandler < std :: decay_t < Handler > > make_custom_alloc_handler ( HandlerMemoryBase & m , Handler && h ) function operator<< \ud83d\udd17 1 2 3 4 5 template < typename ... Ts > inline std :: ostream & operator << ( std :: ostream & out , const IOResult < Ts ... > & t ) function is_ok_status \ud83d\udd17 1 2 3 4 template < typename ... Ts > bool is_ok_status ( const IOResult < Ts ... > & io_result ) function is_ok_status \ud83d\udd17 1 2 3 inline bool is_ok_status ( const ErrorCode & ec ) function to_status \ud83d\udd17 1 2 3 4 template < typename ... Ts > Status to_status ( const IOResult < Ts ... > & io_result ) function pin_object \ud83d\udd17 1 2 3 4 template < typename T > void pin_object ( T * object ) function unpin_object \ud83d\udd17 1 2 3 4 template < typename T > void unpin_object ( T * object ) function make_pin \ud83d\udd17 1 2 3 4 template < typename T > inline Pin < T > make_pin ( T * object ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const Pin < T > & l , const Pin < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const Pin < T > & l , const Pin < U > & r ) function operator== \ud83d\udd17 1 2 3 4 5 template < typename T > inline bool operator == ( const Pin < T > & l , std :: nullptr_t ) function operator!= \ud83d\udd17 1 2 3 4 5 template < typename T > inline bool operator != ( const Pin < T > & l , std :: nullptr_t ) function operator== \ud83d\udd17 1 2 3 4 5 template < typename U > inline bool operator == ( std :: nullptr_t , const Pin < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 template < typename U > inline bool operator != ( std :: nullptr_t , const Pin < U > & r ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskCount , _TAG ) * ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( InputSize , _TAG ) * ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskSize , _TAG ) * ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskIndex , _TAG ) * ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr isize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskOffset , _TAG ) * ) function get_input_size \ud83d\udd17 1 2 3 4 5 template < typename Iter > inline InputSize get_input_size ( const Iter & first , const Iter & last ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const WorkSliceParams & t ) function get_task_size \ud83d\udd17 1 2 3 4 inline TaskSize get_task_size ( const WorkSliceParams & params , InputSize input_size ) function get_task_count \ud83d\udd17 1 2 3 4 inline TaskCount get_task_count ( InputSize input_size , TaskSize task_size ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const WorkSlicePlan & t ) function slice_work \ud83d\udd17 1 2 3 4 5 6 template < typename WorkFnGenerator > void slice_work ( WorkContext & context , const WorkSlicePlan & plan , WorkFnGenerator && gen_work_fn ) function operator<< \ud83d\udd17 1 2 3 4 5 template < typename T > StatusOr < std :: reference_wrapper < StreamBuffer > > operator << ( StatusOr < std :: reference_wrapper < StreamBuffer >> stream_buffer , T && obj ) function next_thread_id \ud83d\udd17 1 inline i32 next_thread_id () function this_thread_id \ud83d\udd17 1 inline i32 & this_thread_id () function least_upper_bound \ud83d\udd17 1 2 3 inline i8 least_upper_bound ( i8 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline i8 greatest_lower_bound ( i8 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline i16 least_upper_bound ( i16 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline i16 greatest_lower_bound ( i16 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline i32 least_upper_bound ( i32 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline i32 greatest_lower_bound ( i32 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline i64 least_upper_bound ( i64 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline i64 greatest_lower_bound ( i64 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline u8 least_upper_bound ( u8 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline u8 greatest_lower_bound ( u8 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline u16 least_upper_bound ( u16 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline u16 greatest_lower_bound ( u16 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline u32 least_upper_bound ( u32 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline u32 greatest_lower_bound ( u32 n ) function least_upper_bound \ud83d\udd17 1 2 3 inline u64 least_upper_bound ( u64 n ) function greatest_lower_bound \ud83d\udd17 1 2 3 inline u64 greatest_lower_bound ( u64 n ) function least_upper_bound \ud83d\udd17 1 2 3 4 template < typename T > LeastUpperBound < std :: decay_t < T > > least_upper_bound ( T && value ) function operator< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const T & left , const LeastUpperBound < U > & right ) function operator< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T > & left , const U & right ) function operator< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T > & left , const LeastUpperBound < U > & right ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const T & , const LeastUpperBound < U > & ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T > & , const U & ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T > & left , const LeastUpperBound < U > & right ) function operator> \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator > ( const T & l , const LeastUpperBound < U > & r ) function BATT_UNWRAP \ud83d\udd17 1 2 3 BATT_UNWRAP ( template < typename T , typename U > inline ) function operator> \ud83d\udd17 1 2 3 4 inline U bool operator > ( const LeastUpperBound < T > & l , const U & r ) function operator> \ud83d\udd17 1 2 3 4 inline U bool operator > ( const LeastUpperBound < T > & l , const LeastUpperBound < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 inline U bool operator != ( const T & l , const LeastUpperBound < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const LeastUpperBound < T > & l , const U & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const LeastUpperBound < T > & l , const LeastUpperBound < U > & r ) function greatest_lower_bound \ud83d\udd17 1 2 3 4 5 template < typename T , typename U > GreatestLowerBound < std :: decay_t < T > > greatest_lower_bound ( T && value ) function operator< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const T & left , const GreatestLowerBound < U > & right ) function operator< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T > & left , const U & right ) function operator< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T > & left , const GreatestLowerBound < U > & right ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const T & , const GreatestLowerBound < U > & ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T > & , const U & ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T > & left , const GreatestLowerBound < U > & right ) function operator> \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator > ( const T & l , const GreatestLowerBound < U > & r ) function operator> \ud83d\udd17 1 2 3 4 inline U bool operator > ( const GreatestLowerBound < T > & l , const U & r ) function operator> \ud83d\udd17 1 2 3 4 inline U bool operator > ( const GreatestLowerBound < T > & l , const GreatestLowerBound < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 inline U bool operator != ( const T & l , const GreatestLowerBound < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const GreatestLowerBound < T > & l , const U & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const GreatestLowerBound < T > & l , const GreatestLowerBound < U > & r ) function make_buffer \ud83d\udd17 1 2 3 4 template < typename ... Args > decltype ( auto ) make_buffer ( Args && ... args ) function buffer_from_struct \ud83d\udd17 1 2 3 4 template < typename T > inline ConstBuffer buffer_from_struct ( const T & val ) function mutable_buffer_from_struct \ud83d\udd17 1 2 3 4 template < typename T > inline MutableBuffer mutable_buffer_from_struct ( T & val ) function resize_buffer \ud83d\udd17 1 2 3 4 inline ConstBuffer resize_buffer ( const ConstBuffer & b , usize s ) function resize_buffer \ud83d\udd17 1 2 3 4 inline MutableBuffer resize_buffer ( const MutableBuffer & b , usize s ) function consume_buffers \ud83d\udd17 1 2 3 4 5 template < typename VecT > inline void consume_buffers ( VecT & buffers , usize count ) function consume_buffers_iter \ud83d\udd17 1 2 3 4 5 6 template < typename Iter > inline std :: pair < Iter , usize > consume_buffers_iter ( const std :: pair < Iter , usize > & pos , const Iter & last , usize count ) function consume_buffers_copy \ud83d\udd17 1 2 3 4 5 template < typename VecT > inline VecT consume_buffers_copy ( const VecT & buffers , usize count ) function make_case_of_visitor \ud83d\udd17 1 2 3 4 template < typename ... Cases > CaseOfVisitor < Cases && ... > make_case_of_visitor ( Cases && ... cases ) Constructs and returns a single overloaded callable function object that forwards its arguments on to the first object in cases that is callable with those arguments. function case_of \ud83d\udd17 1 2 3 4 5 6 template < typename VarType , typename ... Cases > decltype ( auto ) case_of ( VarType && v , Cases && ... cases ) Matches a variant against a list of callables and apply the first one that will accept the current value. Example: ```cpp std::variant var = Bar{}; int result = batt::case_of( var, { return 1; }, { return 2; }); BATT_CHECK_EQ(result, 2); 1 2 3 4 5 6 7 8 ### function is_case ```cpp template <typename T , typename Var > bool is_case( Var && v ) function checked_cast \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > == std :: is_signed_v < FromType >>> ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) function checked_cast \ud83d\udd17 1 2 3 4 5 6 7 8 9 template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > && ! std :: is_signed_v < FromType >> , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) function checked_cast \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 template < typename ToType , typename FromType , typename = std :: enable_if_t <! std :: is_signed_v < ToType > && std :: is_signed_v < FromType >> , typename = void , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 ) function operator<< \ud83d\udd17 1 2 3 4 5 template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const CpuCacheLineIsolated < T > & t ) function pin_thread_to_cpu \ud83d\udd17 1 2 3 inline Status pin_thread_to_cpu ( usize cpu_i ) function do_nothing \ud83d\udd17 1 2 3 4 template < typename ... Args > void do_nothing ( Args && ... ) function getenv_as \ud83d\udd17 1 2 3 4 template < typename T > Optional < T > getenv_as ( const char * var_name ) function finally \ud83d\udd17 1 2 3 4 template < typename Fn > auto finally ( Fn && fn ) function hash \ud83d\udd17 1 inline usize hash () function hash \ud83d\udd17 1 2 3 4 template < typename T > usize hash ( T && obj ) function hash_value \ud83d\udd17 1 2 3 4 5 template < typename T , typename HashT = typename std :: decay_t < T >:: Hash > usize hash_value ( T && obj ) function hash \ud83d\udd17 1 2 3 4 5 6 template < typename First , typename ... Rest > usize hash ( First && first , Rest && ... rest ) function await_resolve \ud83d\udd17 1 2 3 4 inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint > > await_resolve ( boost :: asio :: ip :: tcp :: resolver & resolver , const HostAddress & host_address ) function await_resolve \ud83d\udd17 1 2 3 4 inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint > > await_resolve ( boost :: asio :: io_context & io , const HostAddress & host_address ) function hash_value \ud83d\udd17 1 2 3 inline usize hash_value ( const HostAddress & host_key ) function operator== \ud83d\udd17 1 2 3 4 inline bool operator == ( const HostAddress & l , const HostAddress & r ) function operator!= \ud83d\udd17 1 2 3 4 inline bool operator != ( const HostAddress & l , const HostAddress & r ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const HostAddress & t ) function http_encode_chunked \ud83d\udd17 1 2 3 4 5 6 7 template < typename Src , typename AsyncWriteStream > inline Status http_encode_chunked ( Src && src , AsyncWriteStream && dst , IncludeHttpTrailer include_trailer = IncludeHttpTrailer { false } ) function http_request \ud83d\udd17 1 2 3 4 5 6 template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse > > http_request ( std :: string_view method , std :: string_view url , Params && ... params ) function http_get \ud83d\udd17 1 2 3 4 5 template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse > > http_get ( std :: string_view url , Params && ... params ) function http_post \ud83d\udd17 1 2 3 4 5 template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse > > http_post ( std :: string_view url , Params && ... params ) function strong_typedef_default_value \ud83d\udd17 1 2 3 inline constexpr bool strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( IncludeHttpTrailer , _TAG ) * ) function find_header \ud83d\udd17 1 2 3 4 inline Optional < std :: string_view > find_header ( const SmallVecBase < HttpHeader > & headers , const std :: string_view & name ) function push_back \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_back ( const BasicInterval < TraitsT > & i , DeltaT delta ) function push_front \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_front ( const BasicInterval < TraitsT > & i , DeltaT delta ) function pop_back \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_back ( const BasicInterval < TraitsT > & i , DeltaT delta ) function pop_front \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_front ( const BasicInterval < TraitsT > & i , DeltaT delta ) function make_interval \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > BasicInterval < IClosedOpen < std :: decay_t < T > , std :: decay_t < U > > > make_interval ( T && lower , U && upper ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator == ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator != ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r ) function operator<< \ud83d\udd17 1 2 3 4 5 template < typename Traits > inline std :: ostream & operator << ( std :: ostream & out , const BasicInterval < Traits > & t ) function interval_traits_compatible \ud83d\udd17 1 2 3 template < typename Traits0 , typename Traits1 > inline constexpr bool interval_traits_compatible () function log2_ceil \ud83d\udd17 1 2 3 inline constexpr i32 log2_ceil ( u64 i ) function log2_floor \ud83d\udd17 1 2 3 inline constexpr i32 log2_floor ( u64 i ) function lsb_mask \ud83d\udd17 1 2 3 4 template < typename IntT > inline constexpr IntT lsb_mask ( i32 bits ) function round_down_bits \ud83d\udd17 1 2 3 4 5 template < typename IntT > inline constexpr IntT round_down_bits ( i32 bits , IntT n ) function round_up_bits \ud83d\udd17 1 2 3 4 5 template < typename IntT > inline constexpr IntT round_up_bits ( i32 bits , IntT n ) function ipow \ud83d\udd17 1 2 3 4 5 6 template < typename IntT > inline constexpr IntT ipow ( IntT base , IntT exponent , IntT accumulator = static_cast < IntT > ( 1 ) ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const LatencyMetric & t ) function normalize_labels \ud83d\udd17 1 2 3 inline MetricLabelSet normalize_labels ( MetricLabelSet && labels ) function global_metric_registry \ud83d\udd17 1 inline MetricRegistry & global_metric_registry () function make_nullable \ud83d\udd17 1 2 3 4 template < typename T > auto make_nullable ( T && obj ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 > & v0 , const Optional < T1 > & v1 ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 > & v0 , const Optional < T1 > & v1 ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 > & v0 , const T1 & v1 ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 > & v0 , const T1 & v1 ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator == ( const T0 & v0 , const Optional < T1 > & v1 ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator != ( const T0 & v0 , const Optional < T1 > & v1 ) function operator== \ud83d\udd17 1 2 3 4 5 template < typename T > inline bool operator == ( NoneType , const Optional < T > & v ) function operator!= \ud83d\udd17 1 2 3 4 5 template < typename T > inline bool operator != ( NoneType , const Optional < T > & v ) function operator== \ud83d\udd17 1 2 3 4 5 template < typename T > inline bool operator == ( const Optional < T > & v , NoneType ) function operator!= \ud83d\udd17 1 2 3 4 5 template < typename T > inline bool operator != ( const Optional < T > & v , NoneType ) function operator<< \ud83d\udd17 1 2 3 4 5 template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Optional < T > & t ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const NoneType & ) function make_optional \ud83d\udd17 1 2 3 4 template < typename T > Optional < std :: decay_t < T > > make_optional ( T && val ) function get_or_panic \ud83d\udd17 1 2 3 4 template < typename T > decltype ( auto ) get_or_panic ( Optional < T > & opt ) function get_or_panic \ud83d\udd17 1 2 3 4 template < typename T > decltype ( auto ) get_or_panic ( const Optional < T > & opt ) function get_or_panic \ud83d\udd17 1 2 3 4 template < typename T > decltype ( auto ) get_or_panic ( Optional < T > && opt ) function operator<< \ud83d\udd17 1 2 3 4 5 template < usize N_ > inline std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ > & t ) function operator<< \ud83d\udd17 1 2 3 4 5 template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Ref < T > & t ) function as_ref \ud83d\udd17 1 2 3 4 template < typename T > Ref < T > as_ref ( T & obj_ref ) function as_cref \ud83d\udd17 1 2 3 4 template < typename T > Ref < const T > as_cref ( const T & obj_ref ) function into_ref \ud83d\udd17 1 2 3 4 template < typename T > Ref < T > into_ref ( T * ptr ) function into_cref \ud83d\udd17 1 2 3 4 template < typename T > Ref < const T > into_cref ( const T * ptr ) function unwrap_ref \ud83d\udd17 1 2 3 4 template < typename T > T & unwrap_ref ( const Ref < T > & wrapper ) function extra_segv_debug_info_callback \ud83d\udd17 1 inline std :: atomic < PrintToStreamFunctionPointer > & extra_segv_debug_info_callback () function print_stack_trace \ud83d\udd17 1 inline void print_stack_trace () function print_stack_trace_atexit_enabled \ud83d\udd17 1 inline bool & print_stack_trace_atexit_enabled () function print_stack_trace_atexit \ud83d\udd17 1 inline void print_stack_trace_atexit () function has_seq_requirements \ud83d\udd17 1 2 3 4 template < typename T > inline constexpr bool has_seq_requirements ( StaticType < T > = {} ) function skip_n \ud83d\udd17 1 2 3 inline SkipNBinder skip_n ( usize n ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> SkipN < Seq > operator | ( Seq && seq , const SkipNBinder & binder ) function as_seq \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = decltype ( std :: declval < T > (). front ()), typename = decltype ( std :: declval < T > (). drop_front ()) > SubRangeSeq < T > as_seq ( T && sub_range ) function as_seq \ud83d\udd17 1 2 3 4 5 template < typename ForwardIter > auto as_seq ( ForwardIter && begin , ForwardIter && end ) function as_seq \ud83d\udd17 1 2 3 4 5 6 template < typename VectorLike , typename = decltype ( std :: declval < VectorLike > (). data ()), typename = decltype ( std :: declval < VectorLike > (). size ()) > auto as_seq ( VectorLike && v ) function vec_range \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename Begin = decltype ( std :: declval < const T &> (). data ()), typename End = decltype ( std :: declval < Begin > () + std :: declval < const T &> (). size ()), typename = std :: enable_if_t < std :: is_same_v < Begin , End >>> auto vec_range ( const T & vec ) function into_seq \ud83d\udd17 1 2 3 4 template < typename T > auto into_seq ( std :: vector < T > && v ) function make_shared \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename ... Args , typename = std :: enable_if_t < IsRefCounted < T > {} >> SharedPtr < T > make_shared ( Args && ... args ) function make_shared \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename ... Args , typename = std :: enable_if_t <! IsRefCounted < T > {} > , typename = void > SharedPtr < T > make_shared ( Args && ... args ) function into_shared \ud83d\udd17 1 2 3 4 template < typename T > SharedPtr < T > into_shared ( std :: unique_ptr < T > && ptr ) function shared_ptr_from \ud83d\udd17 1 2 3 4 5 template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , std :: shared_ptr < std :: remove_reference_t < T >>>>> SharedPtr < T > shared_ptr_from ( T * that ) function shared_ptr_from \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , boost :: intrusive_ptr < std :: remove_reference_t < T >>>> , typename = void > SharedPtr < T > shared_ptr_from ( T * that ) function as_slice \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename DataT = decltype ( std :: declval < T > (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < ElementT > as_slice ( T && container ) function as_slice \ud83d\udd17 1 2 3 4 5 template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , ElementT * end ) function as_slice \ud83d\udd17 1 2 3 4 5 template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , usize size ) function as_slice \ud83d\udd17 1 2 3 4 template < typename ElementT > Slice < ElementT > as_slice ( const Slice < ElementT > & slice ) function as_const_slice \ud83d\udd17 1 2 3 4 5 template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , const ElementT * end ) function as_const_slice \ud83d\udd17 1 2 3 4 5 template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , usize size ) function as_const_slice \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename DataT = decltype ( std :: declval < const T &> (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < const ElementT > as_const_slice ( const T & container ) function empty_slice \ud83d\udd17 1 2 3 4 template < typename ElementT > Slice < ElementT > empty_slice ( StaticType < ElementT > = {} ) function as_seq \ud83d\udd17 1 2 3 4 template < typename T > SubRangeSeq < Slice < T > > as_seq ( const Slice < T > & s ) function as_seq \ud83d\udd17 1 2 3 4 template < typename T > auto as_seq ( Slice < T > & s ) function as_seq \ud83d\udd17 1 2 3 4 template < typename T > auto as_seq ( Slice < T > && s ) function as_seq \ud83d\udd17 1 2 3 4 template < typename T > auto as_seq ( const Slice < T > && s ) function as_range \ud83d\udd17 1 2 3 4 template < typename Iter > boost :: iterator_range < Iter > as_range ( const std :: pair < Iter , Iter > & p ) function slice_range \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename RangeT , typename Iter = std :: decay_t < decltype ( boost :: begin ( std :: declval < RangeT > ())) > , typename OffsetT , typename = std :: enable_if_t < std :: is_integral_v < OffsetT >>> boost :: iterator_range < Iter > slice_range ( RangeT && range , const Interval < OffsetT > & i ) function copy_string \ud83d\udd17 1 2 3 4 inline void copy_string ( SmallVecBase < char > & dst , const std :: string_view & src ) function as_str \ud83d\udd17 1 2 3 inline std :: string_view as_str ( const SmallVecBase < char > & v ) function operator<< \ud83d\udd17 1 2 3 4 5 6 7 template < typename StateT , typename StateHash , typename StateEqual > inline std :: ostream & operator << ( std :: ostream & out , const StateMachineBranch < StateT , StateHash , StateEqual > & t ) function operator== \ud83d\udd17 1 2 3 4 5 6 7 template < typename StateT , typename StateHash , typename StateEqual > inline bool operator == ( const StateMachineBranch < StateT , StateHash , StateEqual > & l , const StateMachineBranch < StateT , StateHash , StateEqual > & r ) function hash_value \ud83d\udd17 1 2 3 4 5 6 template < typename StateT , typename StateHash , typename StateEqual > inline usize hash_value ( const StateMachineBranch < StateT , StateHash , StateEqual > & branch ) function combine_results \ud83d\udd17 1 2 3 4 inline StateMachineResult combine_results ( const StateMachineResult & a , const StateMachineResult & b ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const StateMachineResult & r ) function static_dispatch \ud83d\udd17 1 2 3 4 5 6 7 8 9 template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R = decltype ( std :: declval < Fn > ()( std :: integral_constant < IntT , kBegin > {})) > R static_dispatch ( IntT i , Fn && fn ) function static_dispatch \ud83d\udd17 1 2 3 4 5 template < typename Fn > decltype ( auto ) static_dispatch ( bool b , Fn && fn ) function static_dispatch \ud83d\udd17 1 2 3 4 5 6 template < typename Tuple , typename Fn > decltype ( auto ) static_dispatch ( std :: size_t i , Fn && fn ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Status & t ) function operator== \ud83d\udd17 1 2 3 4 inline bool operator == ( const Status & l , const Status & r ) function operator!= \ud83d\udd17 1 2 3 4 inline bool operator != ( const Status & l , const Status & r ) function OkStatus \ud83d\udd17 1 inline Status OkStatus () function operator== \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename U , typename = std :: enable_if_t < CanBeEqCompared < T , U > {} >> inline bool operator == ( const StatusOr < T > & l , const StatusOr < U > & r ) function operator== \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename T , typename U , typename = std :: enable_if_t <! CanBeEqCompared < T , U > {} > , typename = void > inline bool operator == ( const StatusOr < T > & l , const StatusOr < U > & r ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const StatusOr < T > & l , const StatusOr < U > & r ) function is_ok_status \ud83d\udd17 1 2 3 inline bool is_ok_status ( const std :: error_code & ec ) function is_ok_status \ud83d\udd17 1 2 3 4 template < typename T > bool is_ok_status ( const T & val ) function require_fail_thread_default_log_level \ud83d\udd17 1 inline LogLevel & require_fail_thread_default_log_level () function to_status \ud83d\udd17 1 2 3 4 5 template < typename T , typename = std :: enable_if_t < IsStatusOr < T > {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> inline decltype ( auto ) to_status ( T && v ) function to_status \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , Status > || std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>> , typename = void > inline decltype ( auto ) to_status ( T && s ) function to_status \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , boost :: system :: error_code > || std :: is_same_v < std :: decay_t < T > , std :: error_code >> , typename = void , typename = void > inline Status to_status ( const T & ec ) function status_from_errno \ud83d\udd17 1 2 3 inline Status status_from_errno ( int code ) function status_from_retval \ud83d\udd17 1 2 3 4 template < typename T > inline Status status_from_retval ( T retval ) function ok_result_or_panic \ud83d\udd17 1 2 3 4 template < typename T > inline T && ok_result_or_panic ( StatusOr < T > && result ) function operator<< \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < IsStatusOr < std :: decay_t < T >> {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> std :: ostream & operator << ( std :: ostream & out , T && status_or ) function status_is_retryable \ud83d\udd17 1 2 3 inline bool status_is_retryable ( const Status & s ) function print_all \ud83d\udd17 1 2 3 inline std :: ostream & print_all ( std :: ostream & out ) function print_all \ud83d\udd17 1 2 3 4 5 6 7 template < typename First , typename ... Rest > std :: ostream & print_all ( std :: ostream & out , First && first , Rest && ... rest ) function extract_all \ud83d\udd17 1 2 3 inline std :: istream & extract_all ( std :: istream & in ) function extract_all \ud83d\udd17 1 2 3 4 5 6 7 template < typename First , typename ... Rest > std :: istream & extract_all ( std :: istream & in , First && first , Rest && ... rest ) function to_string \ud83d\udd17 1 2 3 4 template < typename ... Args > std :: string to_string ( Args && ... args ) function from_string \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename ... FormatArgs > std :: optional < T > from_string ( const std :: string & str , FormatArgs && ... format_args ) function c_str_literal \ud83d\udd17 1 2 3 inline EscapedStringLiteral c_str_literal ( const std :: string_view & str ) function c_str_literal \ud83d\udd17 1 2 3 4 5 template < typename T , typename = std :: enable_if_t < std :: is_convertible_v < T , std :: string_view >>> inline Optional < EscapedStringLiteral > c_str_literal ( const Optional < T > & maybe_str ) function c_str_literal \ud83d\udd17 1 2 3 inline Optional < EscapedStringLiteral > c_str_literal ( const NoneType & ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( std :: string & str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( std :: string && str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( const std :: string & str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( const std :: string && str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( std :: string_view & str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( std :: string_view && str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( const std :: string_view & str ) function make_printable \ud83d\udd17 1 2 3 inline decltype ( auto ) make_printable ( const std :: string_view && str ) function StringUpperBound \ud83d\udd17 1 inline const std :: string_view & StringUpperBound () function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const EscapedStringLiteral & t ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const HexByteDumper & t ) function dump_hex \ud83d\udd17 1 2 3 4 inline HexByteDumper dump_hex ( const void * ptr , usize size ) function dump_range \ud83d\udd17 1 2 3 4 5 template < typename T > RangeDumper < const T & > dump_range ( const T & value , Pretty pretty = Pretty :: Default ) function pretty_print_indent \ud83d\udd17 1 inline auto pretty_print_indent () function operator+ \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator + ( StrongType < T , Tag > a , StrongType < T , Tag > b ) function operator- \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator - ( StrongType < T , Tag > a , StrongType < T , Tag > b ) function operator* \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator * ( StrongType < T , Tag > a , StrongType < T , Tag > b ) function operator/ \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator / ( StrongType < T , Tag > a , StrongType < T , Tag > b ) function syscall_retry \ud83d\udd17 1 2 3 4 template < typename Op > auto syscall_retry ( Op && op ) function operator== \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename R > inline constexpr bool operator == ( StaticType < L > , StaticType < R > ) function operator!= \ud83d\udd17 1 2 3 4 5 6 template < typename L , typename R > inline constexpr bool operator != ( StaticType < L > , StaticType < R > ) function name_of \ud83d\udd17 1 2 3 4 template < typename T > auto name_of ( batt :: StaticType < T > = {} ) function operator== \ud83d\udd17 1 2 3 4 inline bool operator == ( const UrlParse & left , const UrlParse & right ) function operator!= \ud83d\udd17 1 2 3 4 inline bool operator != ( const UrlParse & left , const UrlParse & right ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const UrlParse & t ) function parse_url \ud83d\udd17 1 2 3 inline StatusOr < UrlParse > parse_url ( std :: string_view url ) function make_copy \ud83d\udd17 1 2 3 4 template < typename T > T make_copy ( const T & value ) Return a copy of value . Supports the \"sunk arguments idiom\" of always declaring function arguments whose value is copied/retained by the callee as rvalue-references. This idiom maintains optimal efficiency in most cases while providing a signal-boost at call sites that an arg is being copied or moved. Examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct MyStruct { std :: shared_ptr < bool > p_flag ; explicit MyStruct ( std :: shared_ptr < bool > && arg ) : p_flag { std :: move ( arg )} {} }; // These are allowed: // MyStruct ex1 { std :: make_shared < bool > ( true )}; auto flag_arg = std :: make_shared < bool > ( false ); MyStruct ex2 { batt :: make_copy ( flag_arg )}; MyStruct ex3 { std :: move ( flag_arg )}; // This is not allowed (the caller must declare intent loudly): // auto flag_arg2 = std :: make_shared < bool > ( true ); MyStruct ex4_BAD { flag_arg2 }; function sink \ud83d\udd17 1 2 3 4 5 template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , std :: decay_t < T >>>> T && sink ( T && value ) function sink \ud83d\udd17 1 2 3 4 template < typename T > T sink ( const T & value ) function make_default \ud83d\udd17 1 2 3 template < typename T , typename = std :: enable_if_t <! std :: is_same_v < T , void >>> T make_default () Return a default-constructed instance of type T . function make_default \ud83d\udd17 1 2 3 4 template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , void >> , typename = void > void make_default () function unwrap_ref \ud83d\udd17 1 2 3 4 template < typename T > T && unwrap_ref ( T && obj ) function unwrap_ref \ud83d\udd17 1 2 3 4 template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T > & wrapper ) function unwrap_ref \ud83d\udd17 1 2 3 4 template < typename T > T & unwrap_ref ( std :: reference_wrapper < T > && wrapper ) function unwrap_ref \ud83d\udd17 1 2 3 4 template < typename T > T & unwrap_ref ( std :: reference_wrapper < T > & wrapper ) function unwrap_ref \ud83d\udd17 1 2 3 4 template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T > && wrapper ) Attributes Documentation \ud83d\udd17 variable BOOST_PP_CAT \ud83d\udd17 1 static BATT_MAYBE_UNUSED :: batt :: StaticBinaryAssertion < decltype ( sizeof ( void * ) * 3 ), decltype ( sizeof ( boost :: context :: stack_context )),( sizeof ( void * ) * 3 ), struct :: batt :: Eq ,( sizeof ( boost :: context :: stack_context )),(( sizeof ( void * ) * 3 ) == ( sizeof ( boost :: context :: stack_context ))) > BOOST_PP_CAT ; variable kMinStackSizeLog2 \ud83d\udd17 1 constexpr usize kMinStackSizeLog2 = 10u ; variable kMaxStackSizeLog2 \ud83d\udd17 1 constexpr usize kMaxStackSizeLog2 = 32u ; variable kMaxDebugInfoThreads \ud83d\udd17 1 constexpr usize kMaxDebugInfoThreads = 32 ; variable kTaskDebugInfoSegvCallbackInstalled \ud83d\udd17 1 2 3 4 const bool kTaskDebugInfoSegvCallbackInstalled = [] { extra_segv_debug_info_callback () = & this_task_debug_info ; return true ; }(); variable BOOST_PP_CAT \ud83d\udd17 1 static BATT_MAYBE_UNUSED :: batt :: StaticBinaryAssertion < decltype ( sizeof ( UniqueHandler <> )), decltype ( sizeof ( void * )),( sizeof ( UniqueHandler <> )), struct :: batt :: Eq ,( sizeof ( void * )),(( sizeof ( UniqueHandler <> )) == ( sizeof ( void * ))) > BOOST_PP_CAT ; variable kCpuCacheLineSize \ud83d\udd17 1 constexpr auto kCpuCacheLineSize = usize { 64 }; variable kSigSegvHandlerInstalled \ud83d\udd17 1 2 3 4 5 6 const bool kSigSegvHandlerInstalled = [] { signal ( SIGSEGV , & detail :: handle_segv ); signal ( SIGABRT , & detail :: handle_segv ); std :: atexit ( & print_stack_trace_atexit ); return true ; }(); variable kDefaultSmallVecSize \ud83d\udd17 1 constexpr usize kDefaultSmallVecSize = 4 ; variable TupleIndexOf_v \ud83d\udd17 1 constexpr auto TupleIndexOf_v = TupleIndexOf < std :: decay_t < TupleT > , T >:: value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt"},{"location":"_autogen/Namespaces/namespacebatt/#namespaces","text":"Name batt::constants batt::detail batt::int_types batt::seq","title":"Namespaces"},{"location":"_autogen/Namespaces/namespacebatt/#classes","text":"Name class batt::AbstractHandler class batt::AbstractStackAllocator class batt::AbstractValue class batt::AbstractValueImpl class batt::AbstractValuePointer class batt::BasicFakeExecutor struct batt::BasicInterval class batt::BasicRateLimiter class batt::BasicStateMachineEntropySource class batt::BoxedSeq class batt::BufferSource class batt::BufferViewImpl class batt::CaseOfVisitor class batt::Channel class batt::ConstBufferView class batt::CountMetric class batt::CountMetricExporter class batt::CpuCacheLineIsolated class batt::CustomAllocHandler class batt::DebugInfoFrame struct batt::DecayRValueRefImpl class batt::DefaultHttpClient class batt::DerivedMetricExporter struct batt::DoNothing struct batt::EscapedStringLiteral class batt::ExhaustiveModelChecker struct batt::ExponentialBackoff class batt::FakeExecutionContext class batt::FakeTaskScheduler class batt::FakeTimeService class batt::FilterBufferSource class batt::FinalAct class batt::Future class batt::Grant struct batt::GreatestLowerBound class batt::HandlerAllocator class batt::HandlerBinder class batt::HandlerImpl class batt::HandlerMemory class batt::HandlerMemoryBase struct batt::HexByteDumper struct batt::HostAddress class batt::HttpChunkDecoder class batt::HttpClient class batt::HttpClientConnection class batt::HttpClientHostContext struct batt::HttpData class batt::HttpMessageBase class batt::HttpRequest class batt::HttpResponse class batt::HttpServer struct batt::HttpVersion struct batt::IClosed struct batt::IClosedOpen struct batt::InPlaceInitType struct batt::IntervalTraits struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn > struct batt::IntervalTraits< T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn > struct batt::IntervalTraitsBase class batt::IOResult struct batt::IsBoxedSeq struct batt::IsBoxedSeq< BoxedSeq< T > > struct batt::IsTuple struct batt::IsTuple< std::tuple< Ts... > > struct batt::IsVariant struct batt::IsVariant< std::variant< Ts... > > class batt::kMoveOnly class batt::Latch class batt::LatencyMetric class batt::LatencyTimer struct batt::LeastUpperBound class batt::ManagedBuffer class batt::MapBufferSource struct batt::MapTuple struct batt::MapTuple< PerTypeT, std::tuple< Ts... > > class batt::MetricCsvFormatter class batt::MetricDumper class batt::MetricExporter class batt::MetricFormatter struct batt::MetricLabel class batt::MetricRegistry struct batt::MorphTuple struct batt::MorphTuple< TemplateT, std::tuple< Ts... > > class batt::MutableBufferView class batt::Mutex struct batt::NoneType struct batt::NoopDeleter class batt::NullTaskScheduler class batt::Optional class batt::Optional< T & > class batt::Pin class batt::Pinnable class batt::PrependBufferSource class batt::Promise class batt::Queue class batt::QueueBase class batt::QueueDepthExporter class batt::RadixQueue class batt::RangeDumper class batt::RateMetric class batt::Ref struct batt::RemoveStatusOrImpl struct batt::RemoveStatusOrImpl< StatusOr< T > > struct batt::RetryState class batt::RunningTotal class batt::Runtime class batt::ScopedWorkContext class batt::SeqBufferSource struct batt::SeqItem_Impl struct batt::SharedPtrImpl class batt::SkipN struct batt::SkipNBinder class batt::SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. class batt::StackAllocator class batt::StackAllocatorImpl struct batt::StateMachineBranch class batt::StateMachineModel struct batt::StateMachineModelCheckAdvancedOptions struct batt::StateMachineResult struct batt::StateMachineTraits struct batt::StaticBinaryAssertion struct batt::StaticSameTypeAssertion struct batt::StaticType struct batt::StaticValue class batt::Status class batt::StatusOr class batt::StatusOr< Status > class batt::StatusOr< StatusOr< T > > class batt::StochasticModelChecker class batt::StreamBuffer class batt::StrongType class batt::SubRangeSeq class batt::TakeNSource class batt::Task class batt::TaskScheduler struct batt::TaskSleepImpl struct batt::TupleIndexOf struct batt::TupleIndexOf< std::tuple< First, Rest... >, T > struct batt::TupleIndexOf< std::tuple< T, Rest... >, T > struct batt::TupleIndexOf< std::tuple<>, T > class batt::TypeErasedStorage class batt::TypeErasedStorageBase class batt::UniqueHandler struct batt::UrlParse class batt::VariableExporter class batt::VarSizeArray class batt::VecSeq struct batt::VecSeqBase class batt::Watch class batt::Watch< bool > class batt::Watch< i16 > class batt::Watch< i32 > class batt::Watch< i64 > class batt::Watch< i8 > class batt::Watch< u16 > class batt::Watch< u32 > class batt::Watch< u64 > class batt::Watch< u8 > class batt::Watch< void * > class batt::WatchAtomic class batt::WatchExporter class batt::WorkContext class batt::Worker class batt::WorkerPool struct batt::WorkSliceParams struct batt::WorkSlicePlan","title":"Classes"},{"location":"_autogen/Namespaces/namespacebatt/#types","text":"Name enum StackType { kFixedSize = 0, kProtectedFixedSize = 1, kPooledFixedSize = 2, kMaxValue} enum bool WaitForResource { kFalse = false, kTrue = true} enum bool InclusiveLowerBound { kFalse = false, kTrue = true} enum bool InclusiveUpperBound { kFalse = false, kTrue = true} enum int StatusCode { kOk = 0, kCancelled = 1, kUnknown = 2, kInvalidArgument = 3, kDeadlineExceeded = 4, kNotFound = 5, kAlreadyExists = 6, kPermissionDenied = 7, kResourceExhausted = 8, kFailedPrecondition = 9, kAborted = 10, kOutOfRange = 11, kUnimplemented = 12, kInternal = 13, kUnavailable = 14, kDataLoss = 15, kUnauthenticated = 16, kClosed = 100, kGrantUnavailable = 101, kLoopBreak = 102, kEndOfStream = 103, kClosedBeforeEndOfStream = 104, kGrantRevoked = 105} enum ErrnoValue { } enum LogLevel { kFatal, kError, kWarning, kInfo, kDebug, kVerbose} enum Pretty { True, False, Default} using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( PartsCount , _TAG)> PartsCount using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( PartSize , _TAG)> PartSize template <typename T > using decltype(detail::has_const_buffer_sequence_requirements_impl< T >(nullptr)) HasConstBufferSequenceRequirements template <typename T > using std::enable_if_t< has_const_buffer_sequence_requirements< T >()> EnableIfConstBufferSequence template <typename T > using decltype(detail::has_buffer_source_requirements_impl< T >(nullptr)) HasBufferSourceRequirements template <typename T > using std::enable_if_t< has_buffer_source_requirements< T >()> EnableIfBufferSource using boost::context::continuation Continuation using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( StackSize , _TAG)> StackSize using BasicFakeExecutor < boost::asio::execution::outstanding_work_t::untracked_t > FakeExecutor template <typename... Args> using boost::intrusive::list< AbstractHandler < Args... > > HandlerList using boost::system::error_code ErrorCode using BasicRateLimiter < std::chrono::steady_clock > RateLimiter using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( TaskCount , _TAG)> TaskCount using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( InputSize , _TAG)> InputSize using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( TaskSize , _TAG)> TaskSize using :: batt::StrongType < usize, BATT_STRONG_TYPEDEF_PASTE_( TaskIndex , _TAG)> TaskIndex using :: batt::StrongType < isize, BATT_STRONG_TYPEDEF_PASTE_( TaskOffset , _TAG)> TaskOffset using boost::asio::const_buffer ConstBuffer using boost::asio::mutable_buffer MutableBuffer using :: batt::StrongType < bool, BATT_STRONG_TYPEDEF_PASTE_( IncludeHttpTrailer , _TAG)> IncludeHttpTrailer using :: pico_http::MessageHeader HttpHeader template <typename T > using BasicInterval < IClosedOpen < T > > Interval template <typename T > using BasicInterval < IClosed < T > > CInterval template <typename T > using std::function< T()> DerivedMetric using std::vector< MetricLabel > MetricLabelSet template <typename T > using typename detail::NullableImpl < T >::type Nullable template <typename T > using std::unique_ptr< T, NoopDeleter > UniqueNonOwningPtr using void(*)(std::ostream &) PrintToStreamFunctionPointer template <typename T > using decltype(detail::has_seq_requirements_impl< T >(nullptr)) HasSeqRequirements template <typename T > using std::enable_if_t< has_seq_requirements< T >()> EnableIfSeq template <typename T > using typename SeqItem_Impl < T >::type SeqItem template <typename T > using boost::intrusive_ref_counter< std::decay_t< T > > RefCounted template <typename T > using decltype(detail::is_ref_counted_impl< std::decay_t< T > >(nullptr)) IsRefCounted template <typename T > using typename SharedPtrImpl < T >::type SharedPtr template <typename T > using boost::iterator_range< T * > Slice template <typename Signature ,usize kMaxSize =kCpuCacheLineSize - sizeof(void*)> using SmallFn < Signature, kMaxSize, true > UniqueSmallFn A type-erased container for a move-only callable function-like object. template <typename T ,usize kStaticSize =kDefaultSmallVecSize> using boost::container::small_vector< T, kStaticSize > SmallVec template <typename T > using boost::container::small_vector_base< T > SmallVecBase using BasicStateMachineEntropySource < std::function< usize(usize min_value, usize max_value)> > StateMachineEntropySource template <typename T > using detail::IsStatusOrImpl < std::decay_t< T > > IsStatusOr template <typename T > using typename RemoveStatusOrImpl < T >::type RemoveStatusOr using boost::flyweights::flyweight< std::string, boost::flyweights::no_tracking > Token template <template< typename... > class TemplateT,typename TupleT > using typename MorphTuple < TemplateT, std::decay_t< TupleT > >::type MorphTuple_t template <template< typename > class PerTypeT,typename TupleT > using typename MapTuple < PerTypeT, std::decay_t< TupleT > >::type MapTuple_t template <typename Fn ,typename... Args> using decltype(detail::is_callable_impl< Fn, Args... >(nullptr)) IsCallable template <typename T > using decltype(detail::is_printable_impl< T >(nullptr)) IsPrintable template <typename T > using decltype(detail::is_range_impl< T >(nullptr)) IsRange template <typename T ,typename... Args> using std::enable_if_t<!std::is_same< std::tuple< std::decay_t< T > * >, std::tuple< std::decay_t< Args > ... > >{} &&!std::is_same< std::tuple<>, std::tuple< std::decay_t< Args > ... > >{} > EnableIfNoShadow template <typename T > using typename DecayRValueRefImpl < T >::type DecayRValueRef template <typename T ,typename U =T> using decltype(detail::can_be_eq_compared_helper< T, U >(nullptr, nullptr)) CanBeEqCompared template <typename T > using decltype(unwrap_ref(std::declval< T >())) UnwrapRefType","title":"Types"},{"location":"_autogen/Namespaces/namespacebatt/#functions","text":"Name template <typename Iter ,typename T ,typename BinaryOp > Slice< T > parallel_accumulate_partial ( WorkContext & context, Iter first, Iter last, T init, const BinaryOp & binary_op, T identity, const Slice< T > & task_result_buffer, const WorkSliceParams & params) template <typename Iter ,typename T ,typename BinaryOp > T parallel_accumulate ( WorkerPool & worker_pool, Iter first, Iter last, T init, const BinaryOp & binary_op, T identity, TaskSize min_task_size = TaskSize {4096}, TaskCount max_tasks = TaskCount {std::thread::hardware_concurrency()}) template <typename Src ,typename Dst > void parallel_copy ( WorkContext & work_context, Src src_begin, Src src_end, Dst dst_begin, TaskSize min_task_size, TaskCount max_tasks) template <typename Src0 ,typename Src1 ,typename Dst ,typename Compare > void parallel_merge ( WorkerPool & worker_pool, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare && compare, usize min_task_size =1400, usize max_tasks =std::thread::hardware_concurrency()/2) template <typename Src0 ,typename Src1 ,typename Dst ,typename Compare > void parallel_merge ( WorkContext & context, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare && compare, usize min_task_size =1400, usize max_tasks =std::thread::hardware_concurrency()/2) template <typename Iter ,typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool, Iter first, Iter last, const Fn & fn, const WorkSliceParams & params) template <typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool, Iter first, Iter last, const WorkSliceParams & params) template <typename Src ,typename Dst ,typename TransformFn > void parallel_transform ( WorkContext & work_context, Src src_begin, Src src_end, Dst dst_begin, const TransformFn & transform_fn, TaskSize min_task_size, TaskCount max_tasks) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( PartsCount , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( PartSize , _TAG) * ) template <typename T ,typename =std::enable_if_t {}>> decltype(auto) make_printable (T && obj) template <typename T ,typename =std::enable_if_t<!IsPrintable {}>,typename =void> std::string make_printable (T && obj) void fail_check_exit () template <typename... Ts> bool ignore (Ts && ...) bool lock_fail_check_mutex () template <typename RetryPolicy ,typename ActionFn ,typename Result =std::invoke_result_t ,typename SleepImpl =TaskSleepImpl> Result with_retry_policy (RetryPolicy && policy, std::string_view action_name, ActionFn && action_fn, SleepImpl && sleep_impl ={}) void update_retry_state ( RetryState & state, const ExponentialBackoff & policy) template <typename T > constexpr bool has_const_buffer_sequence_requirements ( StaticType < T > ={}) template <typename T > constexpr bool has_buffer_source_requirements ( StaticType < T > ={}) template <typename Src ,typename =EnableIfBufferSource > TakeNSource < Src > **[operator template <typename Src ,typename =EnableIfBufferSource > void **[operator template <typename Src ,typename Fn ,typename =EnableIfBufferSource > StatusOr < seq::LoopControl > **[operator template <typename Src ,typename =EnableIfBufferSource > StatusOr < std::vector< char > > **[operator template <typename Src ,typename =EnableIfBufferSource > Status **[operator template <typename Src ,typename =EnableIfBufferSource > Status **[operator template <typename Src ,typename AsyncWriteStream ,typename =EnableIfBufferSource > StatusOr < usize > **[operator template <typename Src ,typename ConstBufferSequence ,typename =EnableIfBufferSource ,typename =EnableIfConstBufferSequence > auto **[operator constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( StackSize , _TAG) * ) template <typename T > const StackAllocator & get_stack_allocator_with_type ( StackSize stack_size) const StackAllocator & get_stack_allocator ( StackSize stack_size, StackType stack_type) template <typename Fn > Continuation callcc ( StackSize stack_size, StackType stack_type, Fn && fn) void this_task_debug_info (std::ostream & out) void print_debug_info ( DebugInfoFrame * p, std::ostream & out) void print_all_threads_debug_info (std::ostream & out) const char * shortened_source_file (const char * raw) bool enable_dump_tasks () template <typename OutstandingWorkP > constexpr bool operator== (const BasicFakeExecutor < OutstandingWorkP > & l, const BasicFakeExecutor < OutstandingWorkP > & r) template <typename OutstandingWorkP > constexpr bool operator!= (const BasicFakeExecutor < OutstandingWorkP > & l, const BasicFakeExecutor < OutstandingWorkP > & r) bool operator< (const FakeTimeService::TimerInstance & l, const FakeTimeService::TimerInstance & r) bool operator> (const FakeTimeService::TimerInstance & l, const FakeTimeService::TimerInstance & r) template <typename T > Future < T > get_future (const Promise < T > & promise) std::ostream & operator<< (std::ostream & out, const Grant & t) template <typename... Args,typename HandlerFn > void push_handler (HandlerList< Args... > * list, HandlerFn && fn) template <typename... Params,typename... Args> void invoke_all_handlers (HandlerList< Params... > * handlers, Args &&... args) template <typename InnerFn ,typename OuterFn > HandlerBinder < std::decay_t< InnerFn >, std::decay_t< OuterFn > > bind_handler (InnerFn && inner, OuterFn && outer) template <typename Handler > CustomAllocHandler < std::decay_t< Handler > > make_custom_alloc_handler ( HandlerMemoryBase & m, Handler && h) template <typename... Ts> std::ostream & operator<< (std::ostream & out, const IOResult < Ts... > & t) template <typename... Ts> bool is_ok_status (const IOResult < Ts... > & io_result) bool is_ok_status (const ErrorCode & ec) template <typename... Ts> Status to_status (const IOResult < Ts... > & io_result) template <typename T > void pin_object (T * object) template <typename T > void unpin_object (T * object) template <typename T > Pin < T > make_pin (T * object) template <typename T ,typename U > bool operator== (const Pin < T > & l, const Pin < U > & r) template <typename T ,typename U > bool operator!= (const Pin < T > & l, const Pin < U > & r) template <typename T > bool operator== (const Pin < T > & l, std::nullptr_t ) template <typename T > bool operator!= (const Pin < T > & l, std::nullptr_t ) template <typename U > bool operator== (std::nullptr_t , const Pin < U > & r) template <typename U > bool operator!= (std::nullptr_t , const Pin < U > & r) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskCount , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( InputSize , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskSize , _TAG) * ) constexpr usize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskIndex , _TAG) * ) constexpr isize strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( TaskOffset , _TAG) * ) template <typename Iter > InputSize get_input_size (const Iter & first, const Iter & last) std::ostream & operator<< (std::ostream & out, const WorkSliceParams & t) TaskSize get_task_size (const WorkSliceParams & params, InputSize input_size) TaskCount get_task_count ( InputSize input_size, TaskSize task_size) std::ostream & operator<< (std::ostream & out, const WorkSlicePlan & t) template <typename WorkFnGenerator > void slice_work ( WorkContext & context, const WorkSlicePlan & plan, WorkFnGenerator && gen_work_fn) template <typename T > StatusOr < std::reference_wrapper< StreamBuffer > > operator<< ( StatusOr < std::reference_wrapper< StreamBuffer >> stream_buffer, T && obj) i32 next_thread_id () i32 & this_thread_id () i8 least_upper_bound (i8 n) i8 greatest_lower_bound (i8 n) i16 least_upper_bound (i16 n) i16 greatest_lower_bound (i16 n) i32 least_upper_bound (i32 n) i32 greatest_lower_bound (i32 n) i64 least_upper_bound (i64 n) i64 greatest_lower_bound (i64 n) u8 least_upper_bound (u8 n) u8 greatest_lower_bound (u8 n) u16 least_upper_bound (u16 n) u16 greatest_lower_bound (u16 n) u32 least_upper_bound (u32 n) u32 greatest_lower_bound (u32 n) u64 least_upper_bound (u64 n) u64 greatest_lower_bound (u64 n) template <typename T > LeastUpperBound < std::decay_t< T > > least_upper_bound (T && value) template <typename T ,typename U > bool operator< (const T & left, const LeastUpperBound < U > & right) template <typename T ,typename U > bool operator< (const LeastUpperBound < T > & left, const U & right) template <typename T ,typename U > bool operator< (const LeastUpperBound < T > & left, const LeastUpperBound < U > & right) template <typename T ,typename U > bool operator== (const T & , const LeastUpperBound < U > & ) template <typename T ,typename U > bool operator== (const LeastUpperBound < T > & , const U & ) template <typename T ,typename U > bool operator== (const LeastUpperBound < T > & left, const LeastUpperBound < U > & right) template <typename T ,typename U > bool operator> (const T & l, const LeastUpperBound < U > & r) BATT_UNWRAP (template< typename T, typename U > inline) U bool operator> (const LeastUpperBound < T > & l, const U & r) U bool operator> (const LeastUpperBound < T > & l, const LeastUpperBound < U > & r) U bool operator!= (const T & l, const LeastUpperBound < U > & r) template <typename T ,typename U > bool operator!= (const LeastUpperBound < T > & l, const U & r) template <typename T ,typename U > bool operator!= (const LeastUpperBound < T > & l, const LeastUpperBound < U > & r) template <typename T ,typename U > GreatestLowerBound < std::decay_t< T > > greatest_lower_bound (T && value) template <typename T ,typename U > bool operator< (const T & left, const GreatestLowerBound < U > & right) template <typename T ,typename U > bool operator< (const GreatestLowerBound < T > & left, const U & right) template <typename T ,typename U > bool operator< (const GreatestLowerBound < T > & left, const GreatestLowerBound < U > & right) template <typename T ,typename U > bool operator== (const T & , const GreatestLowerBound < U > & ) template <typename T ,typename U > bool operator== (const GreatestLowerBound < T > & , const U & ) template <typename T ,typename U > bool operator== (const GreatestLowerBound < T > & left, const GreatestLowerBound < U > & right) template <typename T ,typename U > bool operator> (const T & l, const GreatestLowerBound < U > & r) U bool operator> (const GreatestLowerBound < T > & l, const U & r) U bool operator> (const GreatestLowerBound < T > & l, const GreatestLowerBound < U > & r) U bool operator!= (const T & l, const GreatestLowerBound < U > & r) template <typename T ,typename U > bool operator!= (const GreatestLowerBound < T > & l, const U & r) template <typename T ,typename U > bool operator!= (const GreatestLowerBound < T > & l, const GreatestLowerBound < U > & r) template <typename... Args> decltype(auto) make_buffer (Args &&... args) template <typename T > ConstBuffer buffer_from_struct (const T & val) template <typename T > MutableBuffer mutable_buffer_from_struct (T & val) ConstBuffer resize_buffer (const ConstBuffer & b, usize s) MutableBuffer resize_buffer (const MutableBuffer & b, usize s) template <typename VecT > void consume_buffers (VecT & buffers, usize count) template <typename Iter > std::pair< Iter, usize > consume_buffers_iter (const std::pair< Iter, usize > & pos, const Iter & last, usize count) template <typename VecT > VecT consume_buffers_copy (const VecT & buffers, usize count) template <typename... Cases> CaseOfVisitor < Cases &&... > make_case_of_visitor (Cases &&... cases) Constructs and returns a single overloaded callable function object that forwards its arguments on to the first object in cases that is callable with those arguments. template <typename VarType ,typename... Cases> decltype(auto) case_of (VarType && v, Cases &&... cases) Matches a variant against a list of callables and apply the first one that will accept the current value. template <typename T ,typename Var > bool is_case (Var && v) template <typename ToType ,typename FromType ,typename =std::enable_if_t == std::is_signed_v\\ >> ToType checked_cast (FromType val, const char * file =\"\", int line =0) template <typename ToType ,typename FromType ,typename =std::enable_if_t && !std::is_signed_v\\ >,typename =void> ToType checked_cast (FromType val, const char * file =\"\", int line =0) template <typename ToType ,typename FromType ,typename =std::enable_if_t<!std::is_signed_v && std::is_signed_v >,typename =void,typename =void> ToType checked_cast (FromType val, const char * file =\"\", int line =0) template <typename T > std::ostream & operator<< (std::ostream & out, const CpuCacheLineIsolated < T > & t) Status pin_thread_to_cpu (usize cpu_i) template <typename... Args> void do_nothing (Args && ...) template <typename T > Optional < T > getenv_as (const char * var_name) template <typename Fn > auto finally (Fn && fn) usize hash () template <typename T > usize hash (T && obj) template <typename T ,typename HashT =typename std::decay_t ::Hash> usize hash_value (T && obj) template <typename First ,typename... Rest> usize hash (First && first, Rest &&... rest) StatusOr < SmallVec< boost::asio::ip::tcp::endpoint > > await_resolve (boost::asio::ip::tcp::resolver & resolver, const HostAddress & host_address) StatusOr < SmallVec< boost::asio::ip::tcp::endpoint > > await_resolve (boost::asio::io_context & io, const HostAddress & host_address) usize hash_value (const HostAddress & host_key) bool operator== (const HostAddress & l, const HostAddress & r) bool operator!= (const HostAddress & l, const HostAddress & r) std::ostream & operator<< (std::ostream & out, const HostAddress & t) template <typename Src ,typename AsyncWriteStream > Status http_encode_chunked (Src && src, AsyncWriteStream && dst, IncludeHttpTrailer include_trailer = IncludeHttpTrailer {false}) template <typename... Params> StatusOr < std::unique_ptr< HttpResponse > > http_request (std::string_view method, std::string_view url, Params &&... params) template <typename... Params> StatusOr < std::unique_ptr< HttpResponse > > http_get (std::string_view url, Params &&... params) template <typename... Params> StatusOr < std::unique_ptr< HttpResponse > > http_post (std::string_view url, Params &&... params) constexpr bool strong_typedef_default_value (BATT_STRONG_TYPEDEF_PASTE_( IncludeHttpTrailer , _TAG) * ) Optional < std::string_view > find_header (const SmallVecBase< HttpHeader > & headers, const std::string_view & name) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > push_back (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > push_front (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > pop_back (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename TraitsT ,typename DeltaT > BasicInterval < TraitsT > pop_front (const BasicInterval < TraitsT > & i, DeltaT delta) template <typename T ,typename U > BasicInterval < IClosedOpen < std::decay_t< T >, std::decay_t< U > > > make_interval (T && lower, U && upper) template <typename TraitsL ,typename TraitsR > bool operator== (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) template <typename TraitsL ,typename TraitsR > bool operator!= (const BasicInterval < TraitsL > & l, const BasicInterval < TraitsR > & r) template <typename Traits > std::ostream & operator<< (std::ostream & out, const BasicInterval < Traits > & t) template <typename Traits0 ,typename Traits1 > constexpr bool interval_traits_compatible () constexpr i32 log2_ceil (u64 i) constexpr i32 log2_floor (u64 i) template <typename IntT > constexpr IntT lsb_mask (i32 bits) template <typename IntT > constexpr IntT round_down_bits (i32 bits, IntT n) template <typename IntT > constexpr IntT round_up_bits (i32 bits, IntT n) template <typename IntT > constexpr IntT ipow (IntT base, IntT exponent, IntT accumulator =static_cast< IntT >(1)) std::ostream & operator<< (std::ostream & out, const LatencyMetric & t) MetricLabelSet normalize_labels (MetricLabelSet && labels) MetricRegistry & global_metric_registry () template <typename T > auto make_nullable (T && obj) template <typename T0 ,typename T1 > bool operator== (const Optional < T0 > & v0, const Optional < T1 > & v1) template <typename T0 ,typename T1 > bool operator!= (const Optional < T0 > & v0, const Optional < T1 > & v1) template <typename T0 ,typename T1 > bool operator== (const Optional < T0 > & v0, const T1 & v1) template <typename T0 ,typename T1 > bool operator!= (const Optional < T0 > & v0, const T1 & v1) template <typename T0 ,typename T1 > bool operator== (const T0 & v0, const Optional < T1 > & v1) template <typename T0 ,typename T1 > bool operator!= (const T0 & v0, const Optional < T1 > & v1) template <typename T > bool operator== ( NoneType , const Optional < T > & v) template <typename T > bool operator!= ( NoneType , const Optional < T > & v) template <typename T > bool operator== (const Optional < T > & v, NoneType ) template <typename T > bool operator!= (const Optional < T > & v, NoneType ) template <typename T > std::ostream & operator<< (std::ostream & out, const Optional < T > & t) std::ostream & operator<< (std::ostream & out, const NoneType & ) template <typename T > Optional < std::decay_t< T > > make_optional (T && val) template <typename T > decltype(auto) get_or_panic ( Optional < T > & opt) template <typename T > decltype(auto) get_or_panic (const Optional < T > & opt) template <typename T > decltype(auto) get_or_panic ( Optional < T > && opt) template <usize N_> std::ostream & operator<< (std::ostream & out, const RadixQueue < N_ > & t) template <typename T > std::ostream & operator<< (std::ostream & out, const Ref < T > & t) template <typename T > Ref < T > as_ref (T & obj_ref) template <typename T > Ref < const T > as_cref (const T & obj_ref) template <typename T > Ref < T > into_ref (T * ptr) template <typename T > Ref < const T > into_cref (const T * ptr) template <typename T > T & unwrap_ref (const Ref < T > & wrapper) std::atomic< PrintToStreamFunctionPointer > & extra_segv_debug_info_callback () void print_stack_trace () bool & print_stack_trace_atexit_enabled () void print_stack_trace_atexit () template <typename T > constexpr bool has_seq_requirements ( StaticType < T > ={}) SkipNBinder skip_n (usize n) template <typename Seq ,typename =EnableIfSeq > SkipN < Seq > **[operator template <typename T ,typename =decltype(std::declval ().front()),typename =decltype(std::declval ().drop_front())> SubRangeSeq < T > as_seq (T && sub_range) template <typename ForwardIter > auto as_seq (ForwardIter && begin, ForwardIter && end) template <typename VectorLike ,typename =decltype(std::declval ().data()),typename =decltype(std::declval ().size())> auto as_seq (VectorLike && v) template <typename T ,typename Begin =decltype(std::declval ().data()),typename End =decltype(std::declval () + std::declval ().size()),typename =std::enable_if_t >> auto vec_range (const T & vec) template <typename T > auto into_seq (std::vector< T > && v) template <typename T ,typename... Args,typename =std::enable_if_t {}>> SharedPtr< T > make_shared (Args &&... args) template <typename T ,typename... Args,typename =std::enable_if_t<!IsRefCounted {}>,typename =void> SharedPtr< T > make_shared (Args &&... args) template <typename T > SharedPtr< T > into_shared (std::unique_ptr< T > && ptr) template <typename T ,typename =std::enable_if_t< std::is_same_v , std::shared_ptr\\ >>>> SharedPtr< T > shared_ptr_from (T * that) template <typename T ,typename =std::enable_if_t< std::is_same_v , boost::intrusive_ptr\\ >>>,typename =void> SharedPtr< T > shared_ptr_from (T * that) template <typename T ,typename DataT =decltype(std::declval ().data()),typename =std::enable_if_t >,typename ElementT =typename std::pointer_traits ::element_type> Slice< ElementT > as_slice (T && container) template <typename ElementT > Slice< ElementT > as_slice (ElementT * begin, ElementT * end) template <typename ElementT > Slice< ElementT > as_slice (ElementT * begin, usize size) template <typename ElementT > Slice< ElementT > as_slice (const Slice< ElementT > & slice) template <typename ElementT > Slice< const ElementT > as_const_slice (const ElementT * begin, const ElementT * end) template <typename ElementT > Slice< const ElementT > as_const_slice (const ElementT * begin, usize size) template <typename T ,typename DataT =decltype(std::declval ().data()),typename =std::enable_if_t >,typename ElementT =typename std::pointer_traits ::element_type> Slice< const ElementT > as_const_slice (const T & container) template <typename ElementT > Slice< ElementT > empty_slice ( StaticType < ElementT > ={}) template <typename T > SubRangeSeq < Slice< T > > as_seq (const Slice< T > & s) template <typename T > auto as_seq (Slice< T > & s) template <typename T > auto as_seq (Slice< T > && s) template <typename T > auto as_seq (const Slice< T > && s) template <typename Iter > boost::iterator_range< Iter > as_range (const std::pair< Iter, Iter > & p) template <typename RangeT ,typename Iter =std::decay_t ()))>,typename OffsetT ,typename =std::enable_if_t >> boost::iterator_range< Iter > slice_range (RangeT && range, const Interval < OffsetT > & i) void copy_string (SmallVecBase< char > & dst, const std::string_view & src) std::string_view as_str (const SmallVecBase< char > & v) template <typename StateT ,typename StateHash ,typename StateEqual > std::ostream & operator<< (std::ostream & out, const StateMachineBranch < StateT, StateHash, StateEqual > & t) template <typename StateT ,typename StateHash ,typename StateEqual > bool operator== (const StateMachineBranch < StateT, StateHash, StateEqual > & l, const StateMachineBranch < StateT, StateHash, StateEqual > & r) template <typename StateT ,typename StateHash ,typename StateEqual > usize hash_value (const StateMachineBranch < StateT, StateHash, StateEqual > & branch) StateMachineResult combine_results (const StateMachineResult & a, const StateMachineResult & b) std::ostream & operator<< (std::ostream & out, const StateMachineResult & r) template <typename IntT ,IntT kBegin,IntT kEnd,typename Fn ,typename R =decltype(std::declval ()(std::integral_constant {}))> R static_dispatch (IntT i, Fn && fn) template <typename Fn > decltype(auto) static_dispatch (bool b, Fn && fn) template <typename Tuple ,typename Fn > decltype(auto) static_dispatch (std::size_t i, Fn && fn) std::ostream & operator<< (std::ostream & out, const Status & t) bool operator== (const Status & l, const Status & r) bool operator!= (const Status & l, const Status & r) Status OkStatus () template <typename T ,typename U ,typename =std::enable_if_t {}>> bool operator== (const StatusOr < T > & l, const StatusOr < U > & r) template <typename T ,typename U ,typename =std::enable_if_t<!CanBeEqCompared {}>,typename =void> bool operator== (const StatusOr < T > & l, const StatusOr < U > & r) template <typename T ,typename U > bool operator!= (const StatusOr < T > & l, const StatusOr < U > & r) bool is_ok_status (const std::error_code & ec) template <typename T > bool is_ok_status (const T & val) LogLevel & require_fail_thread_default_log_level () template <typename T ,typename =std::enable_if_t {} && !std::is_same_v\\ , StatusOr\\ >>> decltype(auto) to_status (T && v) template <typename T ,typename =std::enable_if_t<std::is_same_v , Status> template <typename T ,typename =std::enable_if_t<std::is_same_v , boost::system::error_code> Status status_from_errno (int code) template <typename T > Status status_from_retval (T retval) template <typename T > T && ok_result_or_panic ( StatusOr < T > && result) template <typename T ,typename =std::enable_if_t >{} && !std::is_same_v\\ , StatusOr\\ >>> std::ostream & operator<< (std::ostream & out, T && status_or) bool status_is_retryable (const Status & s) std::ostream & print_all (std::ostream & out) template <typename First ,typename... Rest> std::ostream & print_all (std::ostream & out, First && first, Rest &&... rest) std::istream & extract_all (std::istream & in) template <typename First ,typename... Rest> std::istream & extract_all (std::istream & in, First && first, Rest &&... rest) template <typename... Args> std::string to_string (Args &&... args) template <typename T ,typename... FormatArgs> std::optional< T > from_string (const std::string & str, FormatArgs &&... format_args) EscapedStringLiteral c_str_literal (const std::string_view & str) template <typename T ,typename =std::enable_if_t >> Optional < EscapedStringLiteral > c_str_literal (const Optional < T > & maybe_str) Optional < EscapedStringLiteral > c_str_literal (const NoneType & ) decltype(auto) make_printable (std::string & str) decltype(auto) make_printable (std::string && str) decltype(auto) make_printable (const std::string & str) decltype(auto) make_printable (const std::string && str) decltype(auto) make_printable (std::string_view & str) decltype(auto) make_printable (std::string_view && str) decltype(auto) make_printable (const std::string_view & str) decltype(auto) make_printable (const std::string_view && str) const std::string_view & StringUpperBound () std::ostream & operator<< (std::ostream & out, const EscapedStringLiteral & t) std::ostream & operator<< (std::ostream & out, const HexByteDumper & t) HexByteDumper dump_hex (const void * ptr, usize size) template <typename T > RangeDumper < const T & > dump_range (const T & value, Pretty pretty =Pretty::Default) auto pretty_print_indent () template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator+ ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator- ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator* ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename T ,typename Tag ,typename =std::enable_if_t > constexpr StrongType < T, Tag > operator/ ( StrongType < T, Tag > a, StrongType < T, Tag > b) template <typename Op > auto syscall_retry (Op && op) template <typename L ,typename R > constexpr bool operator== ( StaticType < L > , StaticType < R > ) template <typename L ,typename R > constexpr bool operator!= ( StaticType < L > , StaticType < R > ) template <typename T > auto name_of ( batt::StaticType < T > ={}) bool operator== (const UrlParse & left, const UrlParse & right) bool operator!= (const UrlParse & left, const UrlParse & right) std::ostream & operator<< (std::ostream & out, const UrlParse & t) StatusOr < UrlParse > parse_url (std::string_view url) template <typename T > T make_copy (const T & value) Return a copy of value . template <typename T ,typename =std::enable_if_t >>> T && sink (T && value) template <typename T > T sink (const T & value) template <typename T ,typename =std::enable_if_t<!std::is_same_v >> T make_default () Return a default-constructed instance of type T . template <typename T ,typename =std::enable_if_t >,typename =void> void make_default () template <typename T > T && unwrap_ref (T && obj) template <typename T > T & unwrap_ref (const std::reference_wrapper< T > & wrapper) template <typename T > T & unwrap_ref (std::reference_wrapper< T > && wrapper) template <typename T > T & unwrap_ref (std::reference_wrapper< T > & wrapper) template <typename T > T & unwrap_ref (const std::reference_wrapper< T > && wrapper)","title":"Functions"},{"location":"_autogen/Namespaces/namespacebatt/#attributes","text":"Name BATT_MAYBE_UNUSED :: batt::StaticBinaryAssertion < decltype(sizeof(void ) 3), decltype(sizeof(boost::context::stack_context)),(sizeof(void ) 3), struct ::batt::Eq,(sizeof(boost::context::stack_context)),((sizeof(void ) 3)==(sizeof(boost::context::stack_context)))> BOOST_PP_CAT constexpr usize kMinStackSizeLog2 constexpr usize kMaxStackSizeLog2 constexpr usize kMaxDebugInfoThreads const bool kTaskDebugInfoSegvCallbackInstalled BATT_MAYBE_UNUSED :: batt::StaticBinaryAssertion < decltype(sizeof( UniqueHandler <>)), decltype(sizeof(void )),(sizeof( UniqueHandler <>)), struct ::batt::Eq,(sizeof(void )),((sizeof( UniqueHandler <>))==(sizeof(void *)))> BOOST_PP_CAT constexpr auto kCpuCacheLineSize const bool kSigSegvHandlerInstalled constexpr usize kDefaultSmallVecSize constexpr auto TupleIndexOf_v","title":"Attributes"},{"location":"_autogen/Namespaces/namespacebatt/#types-documentation","text":"","title":"Types Documentation"},{"location":"_autogen/Namespaces/namespacebatt/#enum-stacktype","text":"Enumerator Value Description kFixedSize 0 kProtectedFixedSize 1 kPooledFixedSize 2 kMaxValue","title":"enum StackType"},{"location":"_autogen/Namespaces/namespacebatt/#enum-waitforresource","text":"Enumerator Value Description kFalse false kTrue true","title":"enum WaitForResource"},{"location":"_autogen/Namespaces/namespacebatt/#enum-inclusivelowerbound","text":"Enumerator Value Description kFalse false kTrue true","title":"enum InclusiveLowerBound"},{"location":"_autogen/Namespaces/namespacebatt/#enum-inclusiveupperbound","text":"Enumerator Value Description kFalse false kTrue true","title":"enum InclusiveUpperBound"},{"location":"_autogen/Namespaces/namespacebatt/#enum-statuscode","text":"Enumerator Value Description kOk 0 kCancelled 1 kUnknown 2 kInvalidArgument 3 kDeadlineExceeded 4 kNotFound 5 kAlreadyExists 6 kPermissionDenied 7 kResourceExhausted 8 kFailedPrecondition 9 kAborted 10 kOutOfRange 11 kUnimplemented 12 kInternal 13 kUnavailable 14 kDataLoss 15 kUnauthenticated 16 kClosed 100 kGrantUnavailable 101 kLoopBreak 102 kEndOfStream 103 kClosedBeforeEndOfStream 104 kGrantRevoked 105","title":"enum StatusCode"},{"location":"_autogen/Namespaces/namespacebatt/#enum-errnovalue","text":"Enumerator Value Description","title":"enum ErrnoValue"},{"location":"_autogen/Namespaces/namespacebatt/#enum-loglevel","text":"Enumerator Value Description kFatal kError kWarning kInfo kDebug kVerbose","title":"enum LogLevel"},{"location":"_autogen/Namespaces/namespacebatt/#enum-pretty","text":"Enumerator Value Description True False Default","title":"enum Pretty"},{"location":"_autogen/Namespaces/namespacebatt/#using-partscount","text":"1 using batt :: PartsCount = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( PartsCount , _TAG ) > ;","title":"using PartsCount"},{"location":"_autogen/Namespaces/namespacebatt/#using-partsize","text":"1 using batt :: PartSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( PartSize , _TAG ) > ;","title":"using PartSize"},{"location":"_autogen/Namespaces/namespacebatt/#using-hasconstbuffersequencerequirements","text":"1 2 template < typename T > using batt :: HasConstBufferSequenceRequirements = typedef decltype ( detail :: has_const_buffer_sequence_requirements_impl < T > ( nullptr ));","title":"using HasConstBufferSequenceRequirements"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifconstbuffersequence","text":"1 2 template < typename T > using batt :: EnableIfConstBufferSequence = typedef std :: enable_if_t < has_const_buffer_sequence_requirements < T > () > ;","title":"using EnableIfConstBufferSequence"},{"location":"_autogen/Namespaces/namespacebatt/#using-hasbuffersourcerequirements","text":"1 2 template < typename T > using batt :: HasBufferSourceRequirements = typedef decltype ( detail :: has_buffer_source_requirements_impl < T > ( nullptr ));","title":"using HasBufferSourceRequirements"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifbuffersource","text":"1 2 template < typename T > using batt :: EnableIfBufferSource = typedef std :: enable_if_t < has_buffer_source_requirements < T > () > ;","title":"using EnableIfBufferSource"},{"location":"_autogen/Namespaces/namespacebatt/#using-continuation","text":"1 using batt :: Continuation = typedef boost :: context :: continuation ;","title":"using Continuation"},{"location":"_autogen/Namespaces/namespacebatt/#using-stacksize","text":"1 using batt :: StackSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( StackSize , _TAG ) > ;","title":"using StackSize"},{"location":"_autogen/Namespaces/namespacebatt/#using-fakeexecutor","text":"1 using batt :: FakeExecutor = typedef BasicFakeExecutor < boost :: asio :: execution :: outstanding_work_t :: untracked_t > ;","title":"using FakeExecutor"},{"location":"_autogen/Namespaces/namespacebatt/#using-handlerlist","text":"1 2 template < typename ... Args > using batt :: HandlerList = typedef boost :: intrusive :: list < AbstractHandler < Args ... > > ;","title":"using HandlerList"},{"location":"_autogen/Namespaces/namespacebatt/#using-errorcode","text":"1 using batt :: ErrorCode = typedef boost :: system :: error_code ;","title":"using ErrorCode"},{"location":"_autogen/Namespaces/namespacebatt/#using-ratelimiter","text":"1 using batt :: RateLimiter = typedef BasicRateLimiter < std :: chrono :: steady_clock > ;","title":"using RateLimiter"},{"location":"_autogen/Namespaces/namespacebatt/#using-taskcount","text":"1 using batt :: TaskCount = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskCount , _TAG ) > ;","title":"using TaskCount"},{"location":"_autogen/Namespaces/namespacebatt/#using-inputsize","text":"1 using batt :: InputSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( InputSize , _TAG ) > ;","title":"using InputSize"},{"location":"_autogen/Namespaces/namespacebatt/#using-tasksize","text":"1 using batt :: TaskSize = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskSize , _TAG ) > ;","title":"using TaskSize"},{"location":"_autogen/Namespaces/namespacebatt/#using-taskindex","text":"1 using batt :: TaskIndex = typedef :: batt :: StrongType < usize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskIndex , _TAG ) > ;","title":"using TaskIndex"},{"location":"_autogen/Namespaces/namespacebatt/#using-taskoffset","text":"1 using batt :: TaskOffset = typedef :: batt :: StrongType < isize , BATT_STRONG_TYPEDEF_PASTE_ ( TaskOffset , _TAG ) > ;","title":"using TaskOffset"},{"location":"_autogen/Namespaces/namespacebatt/#using-constbuffer","text":"1 using batt :: ConstBuffer = typedef boost :: asio :: const_buffer ;","title":"using ConstBuffer"},{"location":"_autogen/Namespaces/namespacebatt/#using-mutablebuffer","text":"1 using batt :: MutableBuffer = typedef boost :: asio :: mutable_buffer ;","title":"using MutableBuffer"},{"location":"_autogen/Namespaces/namespacebatt/#using-includehttptrailer","text":"1 using batt :: IncludeHttpTrailer = typedef :: batt :: StrongType < bool , BATT_STRONG_TYPEDEF_PASTE_ ( IncludeHttpTrailer , _TAG ) > ;","title":"using IncludeHttpTrailer"},{"location":"_autogen/Namespaces/namespacebatt/#using-httpheader","text":"1 using batt :: HttpHeader = typedef :: pico_http :: MessageHeader ;","title":"using HttpHeader"},{"location":"_autogen/Namespaces/namespacebatt/#using-interval","text":"1 2 template < typename T > using batt :: Interval = typedef BasicInterval < IClosedOpen < T > > ;","title":"using Interval"},{"location":"_autogen/Namespaces/namespacebatt/#using-cinterval","text":"1 2 template < typename T > using batt :: CInterval = typedef BasicInterval < IClosed < T > > ;","title":"using CInterval"},{"location":"_autogen/Namespaces/namespacebatt/#using-derivedmetric","text":"1 2 template < typename T > using batt :: DerivedMetric = typedef std :: function < T () > ;","title":"using DerivedMetric"},{"location":"_autogen/Namespaces/namespacebatt/#using-metriclabelset","text":"1 using batt :: MetricLabelSet = typedef std :: vector < MetricLabel > ;","title":"using MetricLabelSet"},{"location":"_autogen/Namespaces/namespacebatt/#using-nullable","text":"1 2 template < typename T > using batt :: Nullable = typedef typename detail :: NullableImpl < T >:: type ;","title":"using Nullable"},{"location":"_autogen/Namespaces/namespacebatt/#using-uniquenonowningptr","text":"1 2 template < typename T > using batt :: UniqueNonOwningPtr = typedef std :: unique_ptr < T , NoopDeleter > ;","title":"using UniqueNonOwningPtr"},{"location":"_autogen/Namespaces/namespacebatt/#using-printtostreamfunctionpointer","text":"1 using batt :: PrintToStreamFunctionPointer = typedef void ( * )( std :: ostream & );","title":"using PrintToStreamFunctionPointer"},{"location":"_autogen/Namespaces/namespacebatt/#using-hasseqrequirements","text":"1 2 template < typename T > using batt :: HasSeqRequirements = typedef decltype ( detail :: has_seq_requirements_impl < T > ( nullptr ));","title":"using HasSeqRequirements"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifseq","text":"1 2 template < typename T > using batt :: EnableIfSeq = typedef std :: enable_if_t < has_seq_requirements < T > () > ;","title":"using EnableIfSeq"},{"location":"_autogen/Namespaces/namespacebatt/#using-seqitem","text":"1 2 template < typename T > using batt :: SeqItem = typedef typename SeqItem_Impl < T >:: type ;","title":"using SeqItem"},{"location":"_autogen/Namespaces/namespacebatt/#using-refcounted","text":"1 2 template < typename T > using batt :: RefCounted = typedef boost :: intrusive_ref_counter < std :: decay_t < T > > ;","title":"using RefCounted"},{"location":"_autogen/Namespaces/namespacebatt/#using-isrefcounted","text":"1 2 template < typename T > using batt :: IsRefCounted = typedef decltype ( detail :: is_ref_counted_impl < std :: decay_t < T > > ( nullptr ));","title":"using IsRefCounted"},{"location":"_autogen/Namespaces/namespacebatt/#using-sharedptr","text":"1 2 template < typename T > using batt :: SharedPtr = typedef typename SharedPtrImpl < T >:: type ;","title":"using SharedPtr"},{"location":"_autogen/Namespaces/namespacebatt/#using-slice","text":"1 2 template < typename T > using batt :: Slice = typedef boost :: iterator_range < T *> ;","title":"using Slice"},{"location":"_autogen/Namespaces/namespacebatt/#using-uniquesmallfn","text":"1 2 3 template < typename Signature , usize kMaxSize = kCpuCacheLineSize - sizeof ( void * ) > using batt :: UniqueSmallFn = typedef SmallFn < Signature , kMaxSize , true > ; A type-erased container for a move-only callable function-like object. This type can be used to hold copyable functions, but is itself move-only, therefore does not require copy semantics from erased types.","title":"using UniqueSmallFn"},{"location":"_autogen/Namespaces/namespacebatt/#using-smallvec","text":"1 2 3 template < typename T , usize kStaticSize = kDefaultSmallVecSize > using batt :: SmallVec = typedef boost :: container :: small_vector < T , kStaticSize > ;","title":"using SmallVec"},{"location":"_autogen/Namespaces/namespacebatt/#using-smallvecbase","text":"1 2 template < typename T > using batt :: SmallVecBase = typedef boost :: container :: small_vector_base < T > ;","title":"using SmallVecBase"},{"location":"_autogen/Namespaces/namespacebatt/#using-statemachineentropysource","text":"1 using batt :: StateMachineEntropySource = typedef BasicStateMachineEntropySource < std :: function < usize ( usize min_value , usize max_value ) > > ;","title":"using StateMachineEntropySource"},{"location":"_autogen/Namespaces/namespacebatt/#using-isstatusor","text":"1 2 template < typename T > using batt :: IsStatusOr = typedef detail :: IsStatusOrImpl < std :: decay_t < T > > ;","title":"using IsStatusOr"},{"location":"_autogen/Namespaces/namespacebatt/#using-removestatusor","text":"1 2 template < typename T > using batt :: RemoveStatusOr = typedef typename RemoveStatusOrImpl < T >:: type ;","title":"using RemoveStatusOr"},{"location":"_autogen/Namespaces/namespacebatt/#using-token","text":"1 using batt :: Token = typedef boost :: flyweights :: flyweight < std :: string , boost :: flyweights :: no_tracking > ;","title":"using Token"},{"location":"_autogen/Namespaces/namespacebatt/#using-morphtuple_t","text":"1 2 3 template < template < typename ... > class TemplateT , typename TupleT > using batt :: MorphTuple_t = typedef typename MorphTuple < TemplateT , std :: decay_t < TupleT > >:: type ;","title":"using MorphTuple_t"},{"location":"_autogen/Namespaces/namespacebatt/#using-maptuple_t","text":"1 2 3 template < template < typename > class PerTypeT , typename TupleT > using batt :: MapTuple_t = typedef typename MapTuple < PerTypeT , std :: decay_t < TupleT > >:: type ;","title":"using MapTuple_t"},{"location":"_autogen/Namespaces/namespacebatt/#using-iscallable","text":"1 2 3 template < typename Fn , typename ... Args > using batt :: IsCallable = typedef decltype ( detail :: is_callable_impl < Fn , Args ... > ( nullptr ));","title":"using IsCallable"},{"location":"_autogen/Namespaces/namespacebatt/#using-isprintable","text":"1 2 template < typename T > using batt :: IsPrintable = typedef decltype ( detail :: is_printable_impl < T > ( nullptr ));","title":"using IsPrintable"},{"location":"_autogen/Namespaces/namespacebatt/#using-isrange","text":"1 2 template < typename T > using batt :: IsRange = typedef decltype ( detail :: is_range_impl < T > ( nullptr ));","title":"using IsRange"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifnoshadow","text":"1 2 3 template < typename T , typename ... Args > using batt :: EnableIfNoShadow = typedef std :: enable_if_t <! std :: is_same < std :: tuple < std :: decay_t < T >*> , std :: tuple < std :: decay_t < Args >* ... > > {} && ! std :: is_same < std :: tuple <> , std :: tuple < std :: decay_t < Args >* ... > > {} > ;","title":"using EnableIfNoShadow"},{"location":"_autogen/Namespaces/namespacebatt/#using-decayrvalueref","text":"1 2 template < typename T > using batt :: DecayRValueRef = typedef typename DecayRValueRefImpl < T >:: type ;","title":"using DecayRValueRef"},{"location":"_autogen/Namespaces/namespacebatt/#using-canbeeqcompared","text":"1 2 3 template < typename T , typename U = T > using batt :: CanBeEqCompared = typedef decltype ( detail :: can_be_eq_compared_helper < T , U > ( nullptr , nullptr ));","title":"using CanBeEqCompared"},{"location":"_autogen/Namespaces/namespacebatt/#using-unwrapreftype","text":"1 2 template < typename T > using batt :: UnwrapRefType = typedef decltype ( unwrap_ref ( std :: declval < T > ()));","title":"using UnwrapRefType"},{"location":"_autogen/Namespaces/namespacebatt/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_accumulate_partial","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename Iter , typename T , typename BinaryOp > Slice < T > parallel_accumulate_partial ( WorkContext & context , Iter first , Iter last , T init , const BinaryOp & binary_op , T identity , const Slice < T > & task_result_buffer , const WorkSliceParams & params )","title":"function parallel_accumulate_partial"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_accumulate","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename Iter , typename T , typename BinaryOp > T parallel_accumulate ( WorkerPool & worker_pool , Iter first , Iter last , T init , const BinaryOp & binary_op , T identity , TaskSize min_task_size = TaskSize { 4096 }, TaskCount max_tasks = TaskCount { std :: thread :: hardware_concurrency ()} )","title":"function parallel_accumulate"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_copy","text":"1 2 3 4 5 6 7 8 9 10 template < typename Src , typename Dst > void parallel_copy ( WorkContext & work_context , Src src_begin , Src src_end , Dst dst_begin , TaskSize min_task_size , TaskCount max_tasks )","title":"function parallel_copy"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_merge","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkerPool & worker_pool , Src0 src_0_begin , Src0 src_0_end , Src1 src_1_begin , Src1 src_1_end , Dst dst_begin , Compare && compare , usize min_task_size = 1400 , usize max_tasks = std :: thread :: hardware_concurrency () / 2 )","title":"function parallel_merge"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_merge_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template < typename Src0 , typename Src1 , typename Dst , typename Compare > void parallel_merge ( WorkContext & context , Src0 src_0_begin , Src0 src_0_end , Src1 src_1_begin , Src1 src_1_end , Dst dst_begin , Compare && compare , usize min_task_size = 1400 , usize max_tasks = std :: thread :: hardware_concurrency () / 2 )","title":"function parallel_merge"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_running_total","text":"1 2 3 4 5 6 7 8 9 template < typename Iter , typename Fn > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const Fn & fn , const WorkSliceParams & params )","title":"function parallel_running_total"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_running_total_1","text":"1 2 3 4 5 6 7 template < typename Iter > RunningTotal parallel_running_total ( WorkerPool & worker_pool , Iter first , Iter last , const WorkSliceParams & params )","title":"function parallel_running_total"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_transform","text":"1 2 3 4 5 6 7 8 9 10 11 12 template < typename Src , typename Dst , typename TransformFn > void parallel_transform ( WorkContext & work_context , Src src_begin , Src src_end , Dst dst_begin , const TransformFn & transform_fn , TaskSize min_task_size , TaskCount max_tasks )","title":"function parallel_transform"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( PartsCount , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_1","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( PartSize , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable","text":"1 2 3 4 5 template < typename T , typename = std :: enable_if_t < IsPrintable < T > {} >> decltype ( auto ) make_printable ( T && obj )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_1","text":"1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t <! IsPrintable < T > {} > , typename = void > std :: string make_printable ( T && obj )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-fail_check_exit","text":"1 inline void fail_check_exit ()","title":"function fail_check_exit"},{"location":"_autogen/Namespaces/namespacebatt/#function-ignore","text":"1 2 3 4 template < typename ... Ts > inline bool ignore ( Ts && ... )","title":"function ignore"},{"location":"_autogen/Namespaces/namespacebatt/#function-lock_fail_check_mutex","text":"1 inline bool lock_fail_check_mutex ()","title":"function lock_fail_check_mutex"},{"location":"_autogen/Namespaces/namespacebatt/#function-with_retry_policy","text":"1 2 3 4 5 6 7 8 9 10 template < typename RetryPolicy , typename ActionFn , typename Result = std :: invoke_result_t < ActionFn > , typename SleepImpl = TaskSleepImpl > inline Result with_retry_policy ( RetryPolicy && policy , std :: string_view action_name , ActionFn && action_fn , SleepImpl && sleep_impl = {} )","title":"function with_retry_policy"},{"location":"_autogen/Namespaces/namespacebatt/#function-update_retry_state","text":"1 2 3 4 inline void update_retry_state ( RetryState & state , const ExponentialBackoff & policy )","title":"function update_retry_state"},{"location":"_autogen/Namespaces/namespacebatt/#function-has_const_buffer_sequence_requirements","text":"1 2 3 4 template < typename T > inline constexpr bool has_const_buffer_sequence_requirements ( StaticType < T > = {} )","title":"function has_const_buffer_sequence_requirements"},{"location":"_autogen/Namespaces/namespacebatt/#function-has_buffer_source_requirements","text":"1 2 3 4 template < typename T > inline constexpr bool has_buffer_source_requirements ( StaticType < T > = {} )","title":"function has_buffer_source_requirements"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator","text":"1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> TakeNSource < Src > operator | ( Src && src , seq :: TakeNBinder binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_1","text":"1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> void operator | ( Src && src , SkipNBinder binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_2","text":"1 2 3 4 5 6 7 template < typename Src , typename Fn , typename = EnableIfBufferSource < Src >> inline StatusOr < seq :: LoopControl > operator | ( Src && src , seq :: ForEachBinder < Fn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_3","text":"1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> inline StatusOr < std :: vector < char > > operator | ( Src && src , seq :: CollectVec )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_4","text":"1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: PrintOut p )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_5","text":"1 2 3 4 5 6 template < typename Src , typename = EnableIfBufferSource < Src >> inline Status operator | ( Src && src , seq :: Consume )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_6","text":"1 2 3 4 5 6 7 template < typename Src , typename AsyncWriteStream , typename = EnableIfBufferSource < Src >> StatusOr < usize > operator | ( Src && src , seq :: WriteToBinder < AsyncWriteStream > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_7","text":"1 2 3 4 5 6 7 8 template < typename Src , typename ConstBufferSequence , typename = EnableIfBufferSource < Src > , typename = EnableIfConstBufferSequence < ConstBufferSequence >> inline auto operator | ( Src && src , seq :: PrependBinder < ConstBufferSequence > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_2","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( StackSize , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_stack_allocator_with_type","text":"1 2 3 4 template < typename T > inline const StackAllocator & get_stack_allocator_with_type ( StackSize stack_size )","title":"function get_stack_allocator_with_type"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_stack_allocator","text":"1 2 3 4 inline const StackAllocator & get_stack_allocator ( StackSize stack_size , StackType stack_type )","title":"function get_stack_allocator"},{"location":"_autogen/Namespaces/namespacebatt/#function-callcc","text":"1 2 3 4 5 6 template < typename Fn > inline Continuation callcc ( StackSize stack_size , StackType stack_type , Fn && fn )","title":"function callcc"},{"location":"_autogen/Namespaces/namespacebatt/#function-this_task_debug_info","text":"1 2 3 inline void this_task_debug_info ( std :: ostream & out )","title":"function this_task_debug_info"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_debug_info","text":"1 2 3 4 inline void print_debug_info ( DebugInfoFrame * p , std :: ostream & out )","title":"function print_debug_info"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_all_threads_debug_info","text":"1 2 3 inline void print_all_threads_debug_info ( std :: ostream & out )","title":"function print_all_threads_debug_info"},{"location":"_autogen/Namespaces/namespacebatt/#function-shortened_source_file","text":"1 2 3 inline const char * shortened_source_file ( const char * raw )","title":"function shortened_source_file"},{"location":"_autogen/Namespaces/namespacebatt/#function-enable_dump_tasks","text":"1 inline bool enable_dump_tasks ()","title":"function enable_dump_tasks"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_8","text":"1 2 3 4 5 template < typename OutstandingWorkP > inline constexpr bool operator == ( const BasicFakeExecutor < OutstandingWorkP > & l , const BasicFakeExecutor < OutstandingWorkP > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_9","text":"1 2 3 4 5 template < typename OutstandingWorkP > inline constexpr bool operator != ( const BasicFakeExecutor < OutstandingWorkP > & l , const BasicFakeExecutor < OutstandingWorkP > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_10","text":"1 2 3 4 inline bool operator < ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_11","text":"1 2 3 4 inline bool operator > ( const FakeTimeService :: TimerInstance & l , const FakeTimeService :: TimerInstance & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_future","text":"1 2 3 4 template < typename T > inline Future < T > get_future ( const Promise < T > & promise )","title":"function get_future"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_12","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Grant & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_handler","text":"1 2 3 4 5 6 template < typename ... Args , typename HandlerFn > inline void push_handler ( HandlerList < Args ... > * list , HandlerFn && fn )","title":"function push_handler"},{"location":"_autogen/Namespaces/namespacebatt/#function-invoke_all_handlers","text":"1 2 3 4 5 6 template < typename ... Params , typename ... Args > inline void invoke_all_handlers ( HandlerList < Params ... > * handlers , Args && ... args )","title":"function invoke_all_handlers"},{"location":"_autogen/Namespaces/namespacebatt/#function-bind_handler","text":"1 2 3 4 5 6 template < typename InnerFn , typename OuterFn > HandlerBinder < std :: decay_t < InnerFn > , std :: decay_t < OuterFn > > bind_handler ( InnerFn && inner , OuterFn && outer )","title":"function bind_handler"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_custom_alloc_handler","text":"1 2 3 4 5 template < typename Handler > inline CustomAllocHandler < std :: decay_t < Handler > > make_custom_alloc_handler ( HandlerMemoryBase & m , Handler && h )","title":"function make_custom_alloc_handler"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_13","text":"1 2 3 4 5 template < typename ... Ts > inline std :: ostream & operator << ( std :: ostream & out , const IOResult < Ts ... > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status","text":"1 2 3 4 template < typename ... Ts > bool is_ok_status ( const IOResult < Ts ... > & io_result )","title":"function is_ok_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status_1","text":"1 2 3 inline bool is_ok_status ( const ErrorCode & ec )","title":"function is_ok_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status","text":"1 2 3 4 template < typename ... Ts > Status to_status ( const IOResult < Ts ... > & io_result )","title":"function to_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-pin_object","text":"1 2 3 4 template < typename T > void pin_object ( T * object )","title":"function pin_object"},{"location":"_autogen/Namespaces/namespacebatt/#function-unpin_object","text":"1 2 3 4 template < typename T > void unpin_object ( T * object )","title":"function unpin_object"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_pin","text":"1 2 3 4 template < typename T > inline Pin < T > make_pin ( T * object )","title":"function make_pin"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_14","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const Pin < T > & l , const Pin < U > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_15","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const Pin < T > & l , const Pin < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_16","text":"1 2 3 4 5 template < typename T > inline bool operator == ( const Pin < T > & l , std :: nullptr_t )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_17","text":"1 2 3 4 5 template < typename T > inline bool operator != ( const Pin < T > & l , std :: nullptr_t )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_18","text":"1 2 3 4 5 template < typename U > inline bool operator == ( std :: nullptr_t , const Pin < U > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_19","text":"1 2 3 4 5 template < typename U > inline bool operator != ( std :: nullptr_t , const Pin < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_3","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskCount , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_4","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( InputSize , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_5","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskSize , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_6","text":"1 2 3 inline constexpr usize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskIndex , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_7","text":"1 2 3 inline constexpr isize strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( TaskOffset , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_input_size","text":"1 2 3 4 5 template < typename Iter > inline InputSize get_input_size ( const Iter & first , const Iter & last )","title":"function get_input_size"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_20","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const WorkSliceParams & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_task_size","text":"1 2 3 4 inline TaskSize get_task_size ( const WorkSliceParams & params , InputSize input_size )","title":"function get_task_size"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_task_count","text":"1 2 3 4 inline TaskCount get_task_count ( InputSize input_size , TaskSize task_size )","title":"function get_task_count"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_21","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const WorkSlicePlan & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-slice_work","text":"1 2 3 4 5 6 template < typename WorkFnGenerator > void slice_work ( WorkContext & context , const WorkSlicePlan & plan , WorkFnGenerator && gen_work_fn )","title":"function slice_work"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_22","text":"1 2 3 4 5 template < typename T > StatusOr < std :: reference_wrapper < StreamBuffer > > operator << ( StatusOr < std :: reference_wrapper < StreamBuffer >> stream_buffer , T && obj )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-next_thread_id","text":"1 inline i32 next_thread_id ()","title":"function next_thread_id"},{"location":"_autogen/Namespaces/namespacebatt/#function-this_thread_id","text":"1 inline i32 & this_thread_id ()","title":"function this_thread_id"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound","text":"1 2 3 inline i8 least_upper_bound ( i8 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound","text":"1 2 3 inline i8 greatest_lower_bound ( i8 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_1","text":"1 2 3 inline i16 least_upper_bound ( i16 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_1","text":"1 2 3 inline i16 greatest_lower_bound ( i16 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_2","text":"1 2 3 inline i32 least_upper_bound ( i32 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_2","text":"1 2 3 inline i32 greatest_lower_bound ( i32 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_3","text":"1 2 3 inline i64 least_upper_bound ( i64 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_3","text":"1 2 3 inline i64 greatest_lower_bound ( i64 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_4","text":"1 2 3 inline u8 least_upper_bound ( u8 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_4","text":"1 2 3 inline u8 greatest_lower_bound ( u8 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_5","text":"1 2 3 inline u16 least_upper_bound ( u16 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_5","text":"1 2 3 inline u16 greatest_lower_bound ( u16 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_6","text":"1 2 3 inline u32 least_upper_bound ( u32 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_6","text":"1 2 3 inline u32 greatest_lower_bound ( u32 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_7","text":"1 2 3 inline u64 least_upper_bound ( u64 n )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_7","text":"1 2 3 inline u64 greatest_lower_bound ( u64 n )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_8","text":"1 2 3 4 template < typename T > LeastUpperBound < std :: decay_t < T > > least_upper_bound ( T && value )","title":"function least_upper_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_23","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const T & left , const LeastUpperBound < U > & right )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_24","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T > & left , const U & right )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_25","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const LeastUpperBound < T > & left , const LeastUpperBound < U > & right )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_26","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const T & , const LeastUpperBound < U > & )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_27","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T > & , const U & )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_28","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const LeastUpperBound < T > & left , const LeastUpperBound < U > & right )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_29","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator > ( const T & l , const LeastUpperBound < U > & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-batt_unwrap","text":"1 2 3 BATT_UNWRAP ( template < typename T , typename U > inline )","title":"function BATT_UNWRAP"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_30","text":"1 2 3 4 inline U bool operator > ( const LeastUpperBound < T > & l , const U & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_31","text":"1 2 3 4 inline U bool operator > ( const LeastUpperBound < T > & l , const LeastUpperBound < U > & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_32","text":"1 2 3 4 inline U bool operator != ( const T & l , const LeastUpperBound < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_33","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const LeastUpperBound < T > & l , const U & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_34","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const LeastUpperBound < T > & l , const LeastUpperBound < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_8","text":"1 2 3 4 5 template < typename T , typename U > GreatestLowerBound < std :: decay_t < T > > greatest_lower_bound ( T && value )","title":"function greatest_lower_bound"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_35","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const T & left , const GreatestLowerBound < U > & right )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_36","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T > & left , const U & right )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_37","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator < ( const GreatestLowerBound < T > & left , const GreatestLowerBound < U > & right )","title":"function operator&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_38","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const T & , const GreatestLowerBound < U > & )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_39","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T > & , const U & )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_40","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator == ( const GreatestLowerBound < T > & left , const GreatestLowerBound < U > & right )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_41","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator > ( const T & l , const GreatestLowerBound < U > & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_42","text":"1 2 3 4 inline U bool operator > ( const GreatestLowerBound < T > & l , const U & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_43","text":"1 2 3 4 inline U bool operator > ( const GreatestLowerBound < T > & l , const GreatestLowerBound < U > & r )","title":"function operator&gt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_44","text":"1 2 3 4 inline U bool operator != ( const T & l , const GreatestLowerBound < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_45","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const GreatestLowerBound < T > & l , const U & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_46","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const GreatestLowerBound < T > & l , const GreatestLowerBound < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-make_buffer","text":"1 2 3 4 template < typename ... Args > decltype ( auto ) make_buffer ( Args && ... args )","title":"function make_buffer"},{"location":"_autogen/Namespaces/namespacebatt/#function-buffer_from_struct","text":"1 2 3 4 template < typename T > inline ConstBuffer buffer_from_struct ( const T & val )","title":"function buffer_from_struct"},{"location":"_autogen/Namespaces/namespacebatt/#function-mutable_buffer_from_struct","text":"1 2 3 4 template < typename T > inline MutableBuffer mutable_buffer_from_struct ( T & val )","title":"function mutable_buffer_from_struct"},{"location":"_autogen/Namespaces/namespacebatt/#function-resize_buffer","text":"1 2 3 4 inline ConstBuffer resize_buffer ( const ConstBuffer & b , usize s )","title":"function resize_buffer"},{"location":"_autogen/Namespaces/namespacebatt/#function-resize_buffer_1","text":"1 2 3 4 inline MutableBuffer resize_buffer ( const MutableBuffer & b , usize s )","title":"function resize_buffer"},{"location":"_autogen/Namespaces/namespacebatt/#function-consume_buffers","text":"1 2 3 4 5 template < typename VecT > inline void consume_buffers ( VecT & buffers , usize count )","title":"function consume_buffers"},{"location":"_autogen/Namespaces/namespacebatt/#function-consume_buffers_iter","text":"1 2 3 4 5 6 template < typename Iter > inline std :: pair < Iter , usize > consume_buffers_iter ( const std :: pair < Iter , usize > & pos , const Iter & last , usize count )","title":"function consume_buffers_iter"},{"location":"_autogen/Namespaces/namespacebatt/#function-consume_buffers_copy","text":"1 2 3 4 5 template < typename VecT > inline VecT consume_buffers_copy ( const VecT & buffers , usize count )","title":"function consume_buffers_copy"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_case_of_visitor","text":"1 2 3 4 template < typename ... Cases > CaseOfVisitor < Cases && ... > make_case_of_visitor ( Cases && ... cases ) Constructs and returns a single overloaded callable function object that forwards its arguments on to the first object in cases that is callable with those arguments.","title":"function make_case_of_visitor"},{"location":"_autogen/Namespaces/namespacebatt/#function-case_of","text":"1 2 3 4 5 6 template < typename VarType , typename ... Cases > decltype ( auto ) case_of ( VarType && v , Cases && ... cases ) Matches a variant against a list of callables and apply the first one that will accept the current value. Example: ```cpp std::variant var = Bar{}; int result = batt::case_of( var, { return 1; }, { return 2; }); BATT_CHECK_EQ(result, 2); 1 2 3 4 5 6 7 8 ### function is_case ```cpp template <typename T , typename Var > bool is_case( Var && v )","title":"function case_of"},{"location":"_autogen/Namespaces/namespacebatt/#function-checked_cast","text":"1 2 3 4 5 6 7 8 template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > == std :: is_signed_v < FromType >>> ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 )","title":"function checked_cast"},{"location":"_autogen/Namespaces/namespacebatt/#function-checked_cast_1","text":"1 2 3 4 5 6 7 8 9 template < typename ToType , typename FromType , typename = std :: enable_if_t < std :: is_signed_v < ToType > && ! std :: is_signed_v < FromType >> , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 )","title":"function checked_cast"},{"location":"_autogen/Namespaces/namespacebatt/#function-checked_cast_2","text":"1 2 3 4 5 6 7 8 9 10 template < typename ToType , typename FromType , typename = std :: enable_if_t <! std :: is_signed_v < ToType > && std :: is_signed_v < FromType >> , typename = void , typename = void > ToType checked_cast ( FromType val , const char * file = \"\" , int line = 0 )","title":"function checked_cast"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_47","text":"1 2 3 4 5 template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const CpuCacheLineIsolated < T > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-pin_thread_to_cpu","text":"1 2 3 inline Status pin_thread_to_cpu ( usize cpu_i )","title":"function pin_thread_to_cpu"},{"location":"_autogen/Namespaces/namespacebatt/#function-do_nothing","text":"1 2 3 4 template < typename ... Args > void do_nothing ( Args && ... )","title":"function do_nothing"},{"location":"_autogen/Namespaces/namespacebatt/#function-getenv_as","text":"1 2 3 4 template < typename T > Optional < T > getenv_as ( const char * var_name )","title":"function getenv_as"},{"location":"_autogen/Namespaces/namespacebatt/#function-finally","text":"1 2 3 4 template < typename Fn > auto finally ( Fn && fn )","title":"function finally"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash","text":"1 inline usize hash ()","title":"function hash"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_1","text":"1 2 3 4 template < typename T > usize hash ( T && obj )","title":"function hash"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value","text":"1 2 3 4 5 template < typename T , typename HashT = typename std :: decay_t < T >:: Hash > usize hash_value ( T && obj )","title":"function hash_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_2","text":"1 2 3 4 5 6 template < typename First , typename ... Rest > usize hash ( First && first , Rest && ... rest )","title":"function hash"},{"location":"_autogen/Namespaces/namespacebatt/#function-await_resolve","text":"1 2 3 4 inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint > > await_resolve ( boost :: asio :: ip :: tcp :: resolver & resolver , const HostAddress & host_address )","title":"function await_resolve"},{"location":"_autogen/Namespaces/namespacebatt/#function-await_resolve_1","text":"1 2 3 4 inline StatusOr < SmallVec < boost :: asio :: ip :: tcp :: endpoint > > await_resolve ( boost :: asio :: io_context & io , const HostAddress & host_address )","title":"function await_resolve"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value_1","text":"1 2 3 inline usize hash_value ( const HostAddress & host_key )","title":"function hash_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_48","text":"1 2 3 4 inline bool operator == ( const HostAddress & l , const HostAddress & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_49","text":"1 2 3 4 inline bool operator != ( const HostAddress & l , const HostAddress & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_50","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const HostAddress & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_encode_chunked","text":"1 2 3 4 5 6 7 template < typename Src , typename AsyncWriteStream > inline Status http_encode_chunked ( Src && src , AsyncWriteStream && dst , IncludeHttpTrailer include_trailer = IncludeHttpTrailer { false } )","title":"function http_encode_chunked"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_request","text":"1 2 3 4 5 6 template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse > > http_request ( std :: string_view method , std :: string_view url , Params && ... params )","title":"function http_request"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_get","text":"1 2 3 4 5 template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse > > http_get ( std :: string_view url , Params && ... params )","title":"function http_get"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_post","text":"1 2 3 4 5 template < typename ... Params > StatusOr < std :: unique_ptr < HttpResponse > > http_post ( std :: string_view url , Params && ... params )","title":"function http_post"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_8","text":"1 2 3 inline constexpr bool strong_typedef_default_value ( BATT_STRONG_TYPEDEF_PASTE_ ( IncludeHttpTrailer , _TAG ) * )","title":"function strong_typedef_default_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-find_header","text":"1 2 3 4 inline Optional < std :: string_view > find_header ( const SmallVecBase < HttpHeader > & headers , const std :: string_view & name )","title":"function find_header"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_back","text":"1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_back ( const BasicInterval < TraitsT > & i , DeltaT delta )","title":"function push_back"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_front","text":"1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > push_front ( const BasicInterval < TraitsT > & i , DeltaT delta )","title":"function push_front"},{"location":"_autogen/Namespaces/namespacebatt/#function-pop_back","text":"1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_back ( const BasicInterval < TraitsT > & i , DeltaT delta )","title":"function pop_back"},{"location":"_autogen/Namespaces/namespacebatt/#function-pop_front","text":"1 2 3 4 5 6 template < typename TraitsT , typename DeltaT > BasicInterval < TraitsT > pop_front ( const BasicInterval < TraitsT > & i , DeltaT delta )","title":"function pop_front"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_interval","text":"1 2 3 4 5 6 template < typename T , typename U > BasicInterval < IClosedOpen < std :: decay_t < T > , std :: decay_t < U > > > make_interval ( T && lower , U && upper )","title":"function make_interval"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_51","text":"1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator == ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_52","text":"1 2 3 4 5 6 template < typename TraitsL , typename TraitsR > inline bool operator != ( const BasicInterval < TraitsL > & l , const BasicInterval < TraitsR > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_53","text":"1 2 3 4 5 template < typename Traits > inline std :: ostream & operator << ( std :: ostream & out , const BasicInterval < Traits > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-interval_traits_compatible","text":"1 2 3 template < typename Traits0 , typename Traits1 > inline constexpr bool interval_traits_compatible ()","title":"function interval_traits_compatible"},{"location":"_autogen/Namespaces/namespacebatt/#function-log2_ceil","text":"1 2 3 inline constexpr i32 log2_ceil ( u64 i )","title":"function log2_ceil"},{"location":"_autogen/Namespaces/namespacebatt/#function-log2_floor","text":"1 2 3 inline constexpr i32 log2_floor ( u64 i )","title":"function log2_floor"},{"location":"_autogen/Namespaces/namespacebatt/#function-lsb_mask","text":"1 2 3 4 template < typename IntT > inline constexpr IntT lsb_mask ( i32 bits )","title":"function lsb_mask"},{"location":"_autogen/Namespaces/namespacebatt/#function-round_down_bits","text":"1 2 3 4 5 template < typename IntT > inline constexpr IntT round_down_bits ( i32 bits , IntT n )","title":"function round_down_bits"},{"location":"_autogen/Namespaces/namespacebatt/#function-round_up_bits","text":"1 2 3 4 5 template < typename IntT > inline constexpr IntT round_up_bits ( i32 bits , IntT n )","title":"function round_up_bits"},{"location":"_autogen/Namespaces/namespacebatt/#function-ipow","text":"1 2 3 4 5 6 template < typename IntT > inline constexpr IntT ipow ( IntT base , IntT exponent , IntT accumulator = static_cast < IntT > ( 1 ) )","title":"function ipow"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_54","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const LatencyMetric & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-normalize_labels","text":"1 2 3 inline MetricLabelSet normalize_labels ( MetricLabelSet && labels )","title":"function normalize_labels"},{"location":"_autogen/Namespaces/namespacebatt/#function-global_metric_registry","text":"1 inline MetricRegistry & global_metric_registry ()","title":"function global_metric_registry"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_nullable","text":"1 2 3 4 template < typename T > auto make_nullable ( T && obj )","title":"function make_nullable"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_55","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 > & v0 , const Optional < T1 > & v1 )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_56","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 > & v0 , const Optional < T1 > & v1 )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_57","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator == ( const Optional < T0 > & v0 , const T1 & v1 )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_58","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator != ( const Optional < T0 > & v0 , const T1 & v1 )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_59","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator == ( const T0 & v0 , const Optional < T1 > & v1 )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_60","text":"1 2 3 4 5 6 template < typename T0 , typename T1 > inline bool operator != ( const T0 & v0 , const Optional < T1 > & v1 )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_61","text":"1 2 3 4 5 template < typename T > inline bool operator == ( NoneType , const Optional < T > & v )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_62","text":"1 2 3 4 5 template < typename T > inline bool operator != ( NoneType , const Optional < T > & v )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_63","text":"1 2 3 4 5 template < typename T > inline bool operator == ( const Optional < T > & v , NoneType )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_64","text":"1 2 3 4 5 template < typename T > inline bool operator != ( const Optional < T > & v , NoneType )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_65","text":"1 2 3 4 5 template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Optional < T > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_66","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const NoneType & )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_optional","text":"1 2 3 4 template < typename T > Optional < std :: decay_t < T > > make_optional ( T && val )","title":"function make_optional"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_or_panic","text":"1 2 3 4 template < typename T > decltype ( auto ) get_or_panic ( Optional < T > & opt )","title":"function get_or_panic"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_or_panic_1","text":"1 2 3 4 template < typename T > decltype ( auto ) get_or_panic ( const Optional < T > & opt )","title":"function get_or_panic"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_or_panic_2","text":"1 2 3 4 template < typename T > decltype ( auto ) get_or_panic ( Optional < T > && opt )","title":"function get_or_panic"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_67","text":"1 2 3 4 5 template < usize N_ > inline std :: ostream & operator << ( std :: ostream & out , const RadixQueue < N_ > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_68","text":"1 2 3 4 5 template < typename T > inline std :: ostream & operator << ( std :: ostream & out , const Ref < T > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_ref","text":"1 2 3 4 template < typename T > Ref < T > as_ref ( T & obj_ref )","title":"function as_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_cref","text":"1 2 3 4 template < typename T > Ref < const T > as_cref ( const T & obj_ref )","title":"function as_cref"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_ref","text":"1 2 3 4 template < typename T > Ref < T > into_ref ( T * ptr )","title":"function into_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_cref","text":"1 2 3 4 template < typename T > Ref < const T > into_cref ( const T * ptr )","title":"function into_cref"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref","text":"1 2 3 4 template < typename T > T & unwrap_ref ( const Ref < T > & wrapper )","title":"function unwrap_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-extra_segv_debug_info_callback","text":"1 inline std :: atomic < PrintToStreamFunctionPointer > & extra_segv_debug_info_callback ()","title":"function extra_segv_debug_info_callback"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_stack_trace","text":"1 inline void print_stack_trace ()","title":"function print_stack_trace"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_stack_trace_atexit_enabled","text":"1 inline bool & print_stack_trace_atexit_enabled ()","title":"function print_stack_trace_atexit_enabled"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_stack_trace_atexit","text":"1 inline void print_stack_trace_atexit ()","title":"function print_stack_trace_atexit"},{"location":"_autogen/Namespaces/namespacebatt/#function-has_seq_requirements","text":"1 2 3 4 template < typename T > inline constexpr bool has_seq_requirements ( StaticType < T > = {} )","title":"function has_seq_requirements"},{"location":"_autogen/Namespaces/namespacebatt/#function-skip_n","text":"1 2 3 inline SkipNBinder skip_n ( usize n )","title":"function skip_n"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_69","text":"1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> SkipN < Seq > operator | ( Seq && seq , const SkipNBinder & binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq","text":"1 2 3 4 5 6 template < typename T , typename = decltype ( std :: declval < T > (). front ()), typename = decltype ( std :: declval < T > (). drop_front ()) > SubRangeSeq < T > as_seq ( T && sub_range )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_1","text":"1 2 3 4 5 template < typename ForwardIter > auto as_seq ( ForwardIter && begin , ForwardIter && end )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_2","text":"1 2 3 4 5 6 template < typename VectorLike , typename = decltype ( std :: declval < VectorLike > (). data ()), typename = decltype ( std :: declval < VectorLike > (). size ()) > auto as_seq ( VectorLike && v )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-vec_range","text":"1 2 3 4 5 6 7 template < typename T , typename Begin = decltype ( std :: declval < const T &> (). data ()), typename End = decltype ( std :: declval < Begin > () + std :: declval < const T &> (). size ()), typename = std :: enable_if_t < std :: is_same_v < Begin , End >>> auto vec_range ( const T & vec )","title":"function vec_range"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_seq","text":"1 2 3 4 template < typename T > auto into_seq ( std :: vector < T > && v )","title":"function into_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_shared","text":"1 2 3 4 5 6 template < typename T , typename ... Args , typename = std :: enable_if_t < IsRefCounted < T > {} >> SharedPtr < T > make_shared ( Args && ... args )","title":"function make_shared"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_shared_1","text":"1 2 3 4 5 6 7 template < typename T , typename ... Args , typename = std :: enable_if_t <! IsRefCounted < T > {} > , typename = void > SharedPtr < T > make_shared ( Args && ... args )","title":"function make_shared"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_shared","text":"1 2 3 4 template < typename T > SharedPtr < T > into_shared ( std :: unique_ptr < T > && ptr )","title":"function into_shared"},{"location":"_autogen/Namespaces/namespacebatt/#function-shared_ptr_from","text":"1 2 3 4 5 template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , std :: shared_ptr < std :: remove_reference_t < T >>>>> SharedPtr < T > shared_ptr_from ( T * that )","title":"function shared_ptr_from"},{"location":"_autogen/Namespaces/namespacebatt/#function-shared_ptr_from_1","text":"1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < std :: is_same_v < SharedPtr < T > , boost :: intrusive_ptr < std :: remove_reference_t < T >>>> , typename = void > SharedPtr < T > shared_ptr_from ( T * that )","title":"function shared_ptr_from"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice","text":"1 2 3 4 5 6 7 template < typename T , typename DataT = decltype ( std :: declval < T > (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < ElementT > as_slice ( T && container )","title":"function as_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice_1","text":"1 2 3 4 5 template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , ElementT * end )","title":"function as_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice_2","text":"1 2 3 4 5 template < typename ElementT > Slice < ElementT > as_slice ( ElementT * begin , usize size )","title":"function as_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice_3","text":"1 2 3 4 template < typename ElementT > Slice < ElementT > as_slice ( const Slice < ElementT > & slice )","title":"function as_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_slice","text":"1 2 3 4 5 template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , const ElementT * end )","title":"function as_const_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_slice_1","text":"1 2 3 4 5 template < typename ElementT > Slice < const ElementT > as_const_slice ( const ElementT * begin , usize size )","title":"function as_const_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_slice_2","text":"1 2 3 4 5 6 7 template < typename T , typename DataT = decltype ( std :: declval < const T &> (). data ()), typename = std :: enable_if_t < std :: is_pointer_v < DataT >> , typename ElementT = typename std :: pointer_traits < DataT >:: element_type > Slice < const ElementT > as_const_slice ( const T & container )","title":"function as_const_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-empty_slice","text":"1 2 3 4 template < typename ElementT > Slice < ElementT > empty_slice ( StaticType < ElementT > = {} )","title":"function empty_slice"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_3","text":"1 2 3 4 template < typename T > SubRangeSeq < Slice < T > > as_seq ( const Slice < T > & s )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_4","text":"1 2 3 4 template < typename T > auto as_seq ( Slice < T > & s )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_5","text":"1 2 3 4 template < typename T > auto as_seq ( Slice < T > && s )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_6","text":"1 2 3 4 template < typename T > auto as_seq ( const Slice < T > && s )","title":"function as_seq"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_range","text":"1 2 3 4 template < typename Iter > boost :: iterator_range < Iter > as_range ( const std :: pair < Iter , Iter > & p )","title":"function as_range"},{"location":"_autogen/Namespaces/namespacebatt/#function-slice_range","text":"1 2 3 4 5 6 7 8 template < typename RangeT , typename Iter = std :: decay_t < decltype ( boost :: begin ( std :: declval < RangeT > ())) > , typename OffsetT , typename = std :: enable_if_t < std :: is_integral_v < OffsetT >>> boost :: iterator_range < Iter > slice_range ( RangeT && range , const Interval < OffsetT > & i )","title":"function slice_range"},{"location":"_autogen/Namespaces/namespacebatt/#function-copy_string","text":"1 2 3 4 inline void copy_string ( SmallVecBase < char > & dst , const std :: string_view & src )","title":"function copy_string"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_str","text":"1 2 3 inline std :: string_view as_str ( const SmallVecBase < char > & v )","title":"function as_str"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_70","text":"1 2 3 4 5 6 7 template < typename StateT , typename StateHash , typename StateEqual > inline std :: ostream & operator << ( std :: ostream & out , const StateMachineBranch < StateT , StateHash , StateEqual > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_71","text":"1 2 3 4 5 6 7 template < typename StateT , typename StateHash , typename StateEqual > inline bool operator == ( const StateMachineBranch < StateT , StateHash , StateEqual > & l , const StateMachineBranch < StateT , StateHash , StateEqual > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value_2","text":"1 2 3 4 5 6 template < typename StateT , typename StateHash , typename StateEqual > inline usize hash_value ( const StateMachineBranch < StateT , StateHash , StateEqual > & branch )","title":"function hash_value"},{"location":"_autogen/Namespaces/namespacebatt/#function-combine_results","text":"1 2 3 4 inline StateMachineResult combine_results ( const StateMachineResult & a , const StateMachineResult & b )","title":"function combine_results"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_72","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const StateMachineResult & r )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-static_dispatch","text":"1 2 3 4 5 6 7 8 9 template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R = decltype ( std :: declval < Fn > ()( std :: integral_constant < IntT , kBegin > {})) > R static_dispatch ( IntT i , Fn && fn )","title":"function static_dispatch"},{"location":"_autogen/Namespaces/namespacebatt/#function-static_dispatch_1","text":"1 2 3 4 5 template < typename Fn > decltype ( auto ) static_dispatch ( bool b , Fn && fn )","title":"function static_dispatch"},{"location":"_autogen/Namespaces/namespacebatt/#function-static_dispatch_2","text":"1 2 3 4 5 6 template < typename Tuple , typename Fn > decltype ( auto ) static_dispatch ( std :: size_t i , Fn && fn )","title":"function static_dispatch"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_73","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Status & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_74","text":"1 2 3 4 inline bool operator == ( const Status & l , const Status & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_75","text":"1 2 3 4 inline bool operator != ( const Status & l , const Status & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-okstatus","text":"1 inline Status OkStatus ()","title":"function OkStatus"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_76","text":"1 2 3 4 5 6 7 template < typename T , typename U , typename = std :: enable_if_t < CanBeEqCompared < T , U > {} >> inline bool operator == ( const StatusOr < T > & l , const StatusOr < U > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_77","text":"1 2 3 4 5 6 7 8 template < typename T , typename U , typename = std :: enable_if_t <! CanBeEqCompared < T , U > {} > , typename = void > inline bool operator == ( const StatusOr < T > & l , const StatusOr < U > & r )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_78","text":"1 2 3 4 5 6 template < typename T , typename U > inline bool operator != ( const StatusOr < T > & l , const StatusOr < U > & r )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status_2","text":"1 2 3 inline bool is_ok_status ( const std :: error_code & ec )","title":"function is_ok_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status_3","text":"1 2 3 4 template < typename T > bool is_ok_status ( const T & val )","title":"function is_ok_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-require_fail_thread_default_log_level","text":"1 inline LogLevel & require_fail_thread_default_log_level ()","title":"function require_fail_thread_default_log_level"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_1","text":"1 2 3 4 5 template < typename T , typename = std :: enable_if_t < IsStatusOr < T > {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> inline decltype ( auto ) to_status ( T && v )","title":"function to_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_2","text":"1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , Status > || std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>> , typename = void > inline decltype ( auto ) to_status ( T && s )","title":"function to_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_3","text":"1 2 3 4 5 6 7 template < typename T , typename = std :: enable_if_t < std :: is_same_v < std :: decay_t < T > , boost :: system :: error_code > || std :: is_same_v < std :: decay_t < T > , std :: error_code >> , typename = void , typename = void > inline Status to_status ( const T & ec )","title":"function to_status"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_from_errno","text":"1 2 3 inline Status status_from_errno ( int code )","title":"function status_from_errno"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_from_retval","text":"1 2 3 4 template < typename T > inline Status status_from_retval ( T retval )","title":"function status_from_retval"},{"location":"_autogen/Namespaces/namespacebatt/#function-ok_result_or_panic","text":"1 2 3 4 template < typename T > inline T && ok_result_or_panic ( StatusOr < T > && result )","title":"function ok_result_or_panic"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_79","text":"1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < IsStatusOr < std :: decay_t < T >> {} && ! std :: is_same_v < std :: decay_t < T > , StatusOr < Status >>>> std :: ostream & operator << ( std :: ostream & out , T && status_or )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_is_retryable","text":"1 2 3 inline bool status_is_retryable ( const Status & s )","title":"function status_is_retryable"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_all","text":"1 2 3 inline std :: ostream & print_all ( std :: ostream & out )","title":"function print_all"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_all_1","text":"1 2 3 4 5 6 7 template < typename First , typename ... Rest > std :: ostream & print_all ( std :: ostream & out , First && first , Rest && ... rest )","title":"function print_all"},{"location":"_autogen/Namespaces/namespacebatt/#function-extract_all","text":"1 2 3 inline std :: istream & extract_all ( std :: istream & in )","title":"function extract_all"},{"location":"_autogen/Namespaces/namespacebatt/#function-extract_all_1","text":"1 2 3 4 5 6 7 template < typename First , typename ... Rest > std :: istream & extract_all ( std :: istream & in , First && first , Rest && ... rest )","title":"function extract_all"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_string","text":"1 2 3 4 template < typename ... Args > std :: string to_string ( Args && ... args )","title":"function to_string"},{"location":"_autogen/Namespaces/namespacebatt/#function-from_string","text":"1 2 3 4 5 6 template < typename T , typename ... FormatArgs > std :: optional < T > from_string ( const std :: string & str , FormatArgs && ... format_args )","title":"function from_string"},{"location":"_autogen/Namespaces/namespacebatt/#function-c_str_literal","text":"1 2 3 inline EscapedStringLiteral c_str_literal ( const std :: string_view & str )","title":"function c_str_literal"},{"location":"_autogen/Namespaces/namespacebatt/#function-c_str_literal_1","text":"1 2 3 4 5 template < typename T , typename = std :: enable_if_t < std :: is_convertible_v < T , std :: string_view >>> inline Optional < EscapedStringLiteral > c_str_literal ( const Optional < T > & maybe_str )","title":"function c_str_literal"},{"location":"_autogen/Namespaces/namespacebatt/#function-c_str_literal_2","text":"1 2 3 inline Optional < EscapedStringLiteral > c_str_literal ( const NoneType & )","title":"function c_str_literal"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_2","text":"1 2 3 inline decltype ( auto ) make_printable ( std :: string & str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_3","text":"1 2 3 inline decltype ( auto ) make_printable ( std :: string && str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_4","text":"1 2 3 inline decltype ( auto ) make_printable ( const std :: string & str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_5","text":"1 2 3 inline decltype ( auto ) make_printable ( const std :: string && str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_6","text":"1 2 3 inline decltype ( auto ) make_printable ( std :: string_view & str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_7","text":"1 2 3 inline decltype ( auto ) make_printable ( std :: string_view && str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_8","text":"1 2 3 inline decltype ( auto ) make_printable ( const std :: string_view & str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_9","text":"1 2 3 inline decltype ( auto ) make_printable ( const std :: string_view && str )","title":"function make_printable"},{"location":"_autogen/Namespaces/namespacebatt/#function-stringupperbound","text":"1 inline const std :: string_view & StringUpperBound ()","title":"function StringUpperBound"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_80","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const EscapedStringLiteral & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_81","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const HexByteDumper & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-dump_hex","text":"1 2 3 4 inline HexByteDumper dump_hex ( const void * ptr , usize size )","title":"function dump_hex"},{"location":"_autogen/Namespaces/namespacebatt/#function-dump_range","text":"1 2 3 4 5 template < typename T > RangeDumper < const T & > dump_range ( const T & value , Pretty pretty = Pretty :: Default )","title":"function dump_range"},{"location":"_autogen/Namespaces/namespacebatt/#function-pretty_print_indent","text":"1 inline auto pretty_print_indent ()","title":"function pretty_print_indent"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_82","text":"1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator + ( StrongType < T , Tag > a , StrongType < T , Tag > b )","title":"function operator+"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator-","text":"1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator - ( StrongType < T , Tag > a , StrongType < T , Tag > b )","title":"function operator-"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_83","text":"1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator * ( StrongType < T , Tag > a , StrongType < T , Tag > b )","title":"function operator*"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_84","text":"1 2 3 4 5 6 7 template < typename T , typename Tag , typename = std :: enable_if_t < batt_strong_typedef_supports_numerics (( Tag * ) nullptr ) >> constexpr StrongType < T , Tag > operator / ( StrongType < T , Tag > a , StrongType < T , Tag > b )","title":"function operator/"},{"location":"_autogen/Namespaces/namespacebatt/#function-syscall_retry","text":"1 2 3 4 template < typename Op > auto syscall_retry ( Op && op )","title":"function syscall_retry"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_85","text":"1 2 3 4 5 6 template < typename L , typename R > inline constexpr bool operator == ( StaticType < L > , StaticType < R > )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_86","text":"1 2 3 4 5 6 template < typename L , typename R > inline constexpr bool operator != ( StaticType < L > , StaticType < R > )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-name_of","text":"1 2 3 4 template < typename T > auto name_of ( batt :: StaticType < T > = {} )","title":"function name_of"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_87","text":"1 2 3 4 inline bool operator == ( const UrlParse & left , const UrlParse & right )","title":"function operator=="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_88","text":"1 2 3 4 inline bool operator != ( const UrlParse & left , const UrlParse & right )","title":"function operator!="},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_89","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const UrlParse & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt/#function-parse_url","text":"1 2 3 inline StatusOr < UrlParse > parse_url ( std :: string_view url )","title":"function parse_url"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_copy","text":"1 2 3 4 template < typename T > T make_copy ( const T & value ) Return a copy of value . Supports the \"sunk arguments idiom\" of always declaring function arguments whose value is copied/retained by the callee as rvalue-references. This idiom maintains optimal efficiency in most cases while providing a signal-boost at call sites that an arg is being copied or moved. Examples: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct MyStruct { std :: shared_ptr < bool > p_flag ; explicit MyStruct ( std :: shared_ptr < bool > && arg ) : p_flag { std :: move ( arg )} {} }; // These are allowed: // MyStruct ex1 { std :: make_shared < bool > ( true )}; auto flag_arg = std :: make_shared < bool > ( false ); MyStruct ex2 { batt :: make_copy ( flag_arg )}; MyStruct ex3 { std :: move ( flag_arg )}; // This is not allowed (the caller must declare intent loudly): // auto flag_arg2 = std :: make_shared < bool > ( true ); MyStruct ex4_BAD { flag_arg2 };","title":"function make_copy"},{"location":"_autogen/Namespaces/namespacebatt/#function-sink","text":"1 2 3 4 5 template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , std :: decay_t < T >>>> T && sink ( T && value )","title":"function sink"},{"location":"_autogen/Namespaces/namespacebatt/#function-sink_1","text":"1 2 3 4 template < typename T > T sink ( const T & value )","title":"function sink"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_default","text":"1 2 3 template < typename T , typename = std :: enable_if_t <! std :: is_same_v < T , void >>> T make_default () Return a default-constructed instance of type T .","title":"function make_default"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_default_1","text":"1 2 3 4 template < typename T , typename = std :: enable_if_t < std :: is_same_v < T , void >> , typename = void > void make_default ()","title":"function make_default"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_1","text":"1 2 3 4 template < typename T > T && unwrap_ref ( T && obj )","title":"function unwrap_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_2","text":"1 2 3 4 template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T > & wrapper )","title":"function unwrap_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_3","text":"1 2 3 4 template < typename T > T & unwrap_ref ( std :: reference_wrapper < T > && wrapper )","title":"function unwrap_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_4","text":"1 2 3 4 template < typename T > T & unwrap_ref ( std :: reference_wrapper < T > & wrapper )","title":"function unwrap_ref"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_5","text":"1 2 3 4 template < typename T > T & unwrap_ref ( const std :: reference_wrapper < T > && wrapper )","title":"function unwrap_ref"},{"location":"_autogen/Namespaces/namespacebatt/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"_autogen/Namespaces/namespacebatt/#variable-boost_pp_cat","text":"1 static BATT_MAYBE_UNUSED :: batt :: StaticBinaryAssertion < decltype ( sizeof ( void * ) * 3 ), decltype ( sizeof ( boost :: context :: stack_context )),( sizeof ( void * ) * 3 ), struct :: batt :: Eq ,( sizeof ( boost :: context :: stack_context )),(( sizeof ( void * ) * 3 ) == ( sizeof ( boost :: context :: stack_context ))) > BOOST_PP_CAT ;","title":"variable BOOST_PP_CAT"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kminstacksizelog2","text":"1 constexpr usize kMinStackSizeLog2 = 10u ;","title":"variable kMinStackSizeLog2"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kmaxstacksizelog2","text":"1 constexpr usize kMaxStackSizeLog2 = 32u ;","title":"variable kMaxStackSizeLog2"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kmaxdebuginfothreads","text":"1 constexpr usize kMaxDebugInfoThreads = 32 ;","title":"variable kMaxDebugInfoThreads"},{"location":"_autogen/Namespaces/namespacebatt/#variable-ktaskdebuginfosegvcallbackinstalled","text":"1 2 3 4 const bool kTaskDebugInfoSegvCallbackInstalled = [] { extra_segv_debug_info_callback () = & this_task_debug_info ; return true ; }();","title":"variable kTaskDebugInfoSegvCallbackInstalled"},{"location":"_autogen/Namespaces/namespacebatt/#variable-boost_pp_cat_1","text":"1 static BATT_MAYBE_UNUSED :: batt :: StaticBinaryAssertion < decltype ( sizeof ( UniqueHandler <> )), decltype ( sizeof ( void * )),( sizeof ( UniqueHandler <> )), struct :: batt :: Eq ,( sizeof ( void * )),(( sizeof ( UniqueHandler <> )) == ( sizeof ( void * ))) > BOOST_PP_CAT ;","title":"variable BOOST_PP_CAT"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kcpucachelinesize","text":"1 constexpr auto kCpuCacheLineSize = usize { 64 };","title":"variable kCpuCacheLineSize"},{"location":"_autogen/Namespaces/namespacebatt/#variable-ksigsegvhandlerinstalled","text":"1 2 3 4 5 6 const bool kSigSegvHandlerInstalled = [] { signal ( SIGSEGV , & detail :: handle_segv ); signal ( SIGABRT , & detail :: handle_segv ); std :: atexit ( & print_stack_trace_atexit ); return true ; }();","title":"variable kSigSegvHandlerInstalled"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kdefaultsmallvecsize","text":"1 constexpr usize kDefaultSmallVecSize = 4 ;","title":"variable kDefaultSmallVecSize"},{"location":"_autogen/Namespaces/namespacebatt/#variable-tupleindexof_v","text":"1 constexpr auto TupleIndexOf_v = TupleIndexOf < std :: decay_t < TupleT > , T >:: value ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable TupleIndexOf_v"},{"location":"_autogen/Namespaces/namespacebatt_1_1_0d104/","text":"batt::@104 \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::@104"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/","text":"batt::constants \ud83d\udd17 Attributes \ud83d\udd17 Name constexpr u64 kKB constexpr u64 kMB constexpr u64 kGB constexpr u64 kTB constexpr u64 kPB constexpr u64 kEB constexpr u64 kKiB constexpr u64 kMiB constexpr u64 kGiB constexpr u64 kTiB constexpr u64 kPiB constexpr u64 kEiB Attributes Documentation \ud83d\udd17 variable kKB \ud83d\udd17 1 constexpr u64 kKB = 1000ull ; variable kMB \ud83d\udd17 1 constexpr u64 kMB = 1000ull * kKB ; variable kGB \ud83d\udd17 1 constexpr u64 kGB = 1000ull * kMB ; variable kTB \ud83d\udd17 1 constexpr u64 kTB = 1000ull * kGB ; variable kPB \ud83d\udd17 1 constexpr u64 kPB = 1000ull * kTB ; variable kEB \ud83d\udd17 1 constexpr u64 kEB = 1000ull * kPB ; variable kKiB \ud83d\udd17 1 constexpr u64 kKiB = 1024ull ; variable kMiB \ud83d\udd17 1 constexpr u64 kMiB = 1024ull * kKiB ; variable kGiB \ud83d\udd17 1 constexpr u64 kGiB = 1024ull * kMiB ; variable kTiB \ud83d\udd17 1 constexpr u64 kTiB = 1024ull * kGiB ; variable kPiB \ud83d\udd17 1 constexpr u64 kPiB = 1024ull * kTiB ; variable kEiB \ud83d\udd17 1 constexpr u64 kEiB = 1024ull * kPiB ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::constants"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#attributes","text":"Name constexpr u64 kKB constexpr u64 kMB constexpr u64 kGB constexpr u64 kTB constexpr u64 kPB constexpr u64 kEB constexpr u64 kKiB constexpr u64 kMiB constexpr u64 kGiB constexpr u64 kTiB constexpr u64 kPiB constexpr u64 kEiB","title":"Attributes"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kkb","text":"1 constexpr u64 kKB = 1000ull ;","title":"variable kKB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kmb","text":"1 constexpr u64 kMB = 1000ull * kKB ;","title":"variable kMB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kgb","text":"1 constexpr u64 kGB = 1000ull * kMB ;","title":"variable kGB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-ktb","text":"1 constexpr u64 kTB = 1000ull * kGB ;","title":"variable kTB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kpb","text":"1 constexpr u64 kPB = 1000ull * kTB ;","title":"variable kPB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-keb","text":"1 constexpr u64 kEB = 1000ull * kPB ;","title":"variable kEB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kkib","text":"1 constexpr u64 kKiB = 1024ull ;","title":"variable kKiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kmib","text":"1 constexpr u64 kMiB = 1024ull * kKiB ;","title":"variable kMiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kgib","text":"1 constexpr u64 kGiB = 1024ull * kMiB ;","title":"variable kGiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-ktib","text":"1 constexpr u64 kTiB = 1024ull * kGiB ;","title":"variable kTiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kpib","text":"1 constexpr u64 kPiB = 1024ull * kTiB ;","title":"variable kPiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-keib","text":"1 constexpr u64 kEiB = 1024ull * kPiB ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kEiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/","text":"batt::detail \ud83d\udd17 Classes \ud83d\udd17 Name class batt::detail::AbstractCopyFn class batt::detail::AbstractMoveFn class batt::detail::CopyFnImpl struct batt::detail::FirstMatchImpl struct batt::detail::FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > > struct batt::detail::FirstMatchImpl< std::tuple<>, std::tuple< Args... > > struct batt::detail::FirstPhase class batt::detail::FutureImpl class batt::detail::HttpClientRequestContext struct batt::detail::IsStatusOrImpl struct batt::detail::IsStatusOrImpl< StatusOr< T > > struct batt::detail::ModelCheckShardMetrics class batt::detail::MoveFnImpl class batt::detail::NotOkStatusWrapper struct batt::detail::NullableImpl struct batt::detail::NullableImpl< std::optional< T > > struct batt::detail::NullableImpl< std::shared_ptr< T > > struct batt::detail::NullableImpl< std::unique_ptr< T > > struct batt::detail::NullableImpl< T * > class batt::detail::ParallelModelCheckState struct batt::detail::SecondPhase class batt::detail::SigInfoHandler class batt::detail::StatusBase class batt::detail::StatusOrValueContainer class batt::detail::StatusOrValueContainer< T & > struct batt::detail::ThirdPhase struct batt::detail::VisitorResult struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > && > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const && > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const > Types \ud83d\udd17 Name template <typename Visitor ,typename VariantArg > using typename VisitorResult < Visitor, VariantArg >::type VisitorResultT template <bool kMoveOnly,typename Result ,typename... Args> using std::conditional_t< kMoveOnly , AbstractMoveFn < true, Result, Args... >, AbstractCopyFn < Result, Args... > > AbstractFn template <typename Fn ,bool kMoveOnly,typename Result ,typename... Args> using std::conditional_t< kMoveOnly , MoveFnImpl < Fn, kMoveOnly , Result, Args... >, CopyFnImpl < Fn, Result, Args... > > FnImpl template <typename Arg ,typename Result > using Result(*)(Arg) AbstractCaseHandler Functions \ud83d\udd17 Name template <typename Fixed ,typename Search ,typename Dst ,typename Compare ,typename Phase > void parallel_merge_fanout ( WorkContext & context, Fixed fixed_begin, Fixed fixed_end, Search search_begin, Search search_end, Dst dst_begin, Compare && compare, usize min_task_size, usize max_tasks, batt::StaticType < Phase > ) template <typename Src0 ,typename Src1 ,typename Dst ,typename Compare ,typename Phase > void parallel_merge_impl ( WorkContext & context, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare && compare, usize min_task_size, usize max_tasks, batt::StaticType < Phase > phase) template <typename Fixed ,typename Search ,typename Dst ,typename Compare ,typename Phase > void parallel_merge_fanout ( WorkContext & context, Fixed fixed_begin, Fixed fixed_end, Fixed fixed_part_begin, Fixed fixed_part_end, Search search_begin, Search search_end, Dst dst_begin, Compare && compare, usize min_task_size, usize max_tasks, batt::StaticType < Phase > ) template <typename T > std::false_type has_const_buffer_sequence_requirements_impl (... ) template <typename T ,typename ElementT =decltype(*boost::asio::buffer_sequence_begin(std::declval ()))> std::true_type has_const_buffer_sequence_requirements_impl (std::decay_t< T > * ) template <typename T > std::false_type has_buffer_source_requirements_impl (... ) template <typename T > std::true_type has_buffer_source_requirements_impl (std::decay_t< T > * ) void print_nothing (std::ostream & ) void handle_segv (int sig) void exit_impl (int code) template <typename T > std::false_type has_seq_requirements_impl (... ) template <typename T ,typename ItemT =typename std::decay_t ::Item> std::true_type has_seq_requirements_impl (std::decay_t< T > * ) template <typename T ,typename =decltype(intrusive_ptr_add_ref((T )nullptr)),typename =decltype(intrusive_ptr_release((T )nullptr))> std::true_type is_ref_counted_impl (void * ) template <typename T > std::false_type is_ref_counted_impl (... ) std::ostream & operator<< (std::ostream & out, const ModelCheckShardMetrics & t) template <typename IntT ,IntT I,typename Fn ,typename R > R CaseHandlerImpl (Fn && fn) template <typename IntT ,IntT I,typename Fn ,typename R > void initialize_case_handlers (std::integral_constant< IntT, I > , std::integral_constant< IntT, I > , AbstractCaseHandler< Fn, R > * , AbstractCaseHandler< Fn, R > * ) template <typename IntT ,IntT kBegin,IntT kEnd,typename Fn ,typename R > void initialize_case_handlers (std::integral_constant< IntT, kBegin > , std::integral_constant< IntT, kEnd > , AbstractCaseHandler< Fn, R > * begin, AbstractCaseHandler< Fn, R > * end) template <typename T ,typename... FormatArgs> std::optional< T > from_string_impl ( StaticType < T > , const std::string & str, FormatArgs &&... format_args) template <typename... FormatArgs> std::optional< bool > from_string_impl ( StaticType < bool > , const std::string & str, FormatArgs && ...) Pretty & range_dump_pretty () int & range_dump_depth () template <typename T ,typename =std::enable_if_t<!std::is_same , u8>{}>,typename =std::enable_if_t<!IsRange {}>> std::ostream & dump_item (std::ostream & out, T && item) std::ostream & dump_item (std::ostream & out, const std::string & s) std::ostream & dump_item (std::ostream & out, const std::string_view & s) template <typename T ,typename =std::enable_if_t {}>> std::ostream & dump_item (std::ostream & out, T && item) std::ostream & dump_item (std::ostream & out, u8 byte_val) template <typename FirstT ,typename SecondT > std::ostream & dump_item (std::ostream & out, const std::pair< FirstT, SecondT > & p) template <typename Fn ,typename... Args,typename Result =std::result_of_t > std::true_type is_callable_impl (void * ) template <typename Fn ,typename... Args> std::false_type is_callable_impl (... ) template <typename T ,typename Result =decltype(std::declval () << std::declval ())> std::true_type is_printable_impl (void * ) template <typename Fn ,typename... Args> std::false_type is_printable_impl (... ) template <typename T ,typename BeginIter =decltype(std::begin(std::declval ())),typename EndIter =decltype(std::end(std::declval ())),typename =std::enable_if_t {}>> std::true_type is_range_impl (void * ) template <typename T > std::false_type is_range_impl (... ) template <typename T ,typename U ,typename =decltype(std::declval () == std::declval ())> std::true_type can_be_eq_compared_helper (const T * , const U * ) template <typename T ,typename U > std::false_type can_be_eq_compared_helper (... ) StatusOr < UrlParse > parse_url_auth (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_host (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_port (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_path (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_query (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_fragment (std::string_view url, UrlParse && parse) Attributes \ud83d\udd17 Name constexpr isize kThreshold constexpr isize kMaxShards Types Documentation \ud83d\udd17 using VisitorResultT \ud83d\udd17 1 2 3 template < typename Visitor , typename VariantArg > using batt :: detail :: VisitorResultT = typedef typename VisitorResult < Visitor , VariantArg >:: type ; using AbstractFn \ud83d\udd17 1 2 3 4 template < bool kMoveOnly , typename Result , typename ... Args > using batt :: detail :: AbstractFn = typedef std :: conditional_t < kMoveOnly , AbstractMoveFn < true , Result , Args ... > , AbstractCopyFn < Result , Args ... > > ; using FnImpl \ud83d\udd17 1 2 3 4 5 template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > using batt :: detail :: FnImpl = typedef std :: conditional_t < kMoveOnly , MoveFnImpl < Fn , kMoveOnly , Result , Args ... > , CopyFnImpl < Fn , Result , Args ... > > ; using AbstractCaseHandler \ud83d\udd17 1 2 3 template < typename Arg , typename Result > using batt :: detail :: AbstractCaseHandler = typedef Result ( * )( Arg ); Functions Documentation \ud83d\udd17 function parallel_merge_fanout \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , Fixed fixed_begin , Fixed fixed_end , Search search_begin , Search search_end , Dst dst_begin , Compare && compare , usize min_task_size , usize max_tasks , batt :: StaticType < Phase > ) function parallel_merge_impl \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < typename Src0 , typename Src1 , typename Dst , typename Compare , typename Phase > void parallel_merge_impl ( WorkContext & context , Src0 src_0_begin , Src0 src_0_end , Src1 src_1_begin , Src1 src_1_end , Dst dst_begin , Compare && compare , usize min_task_size , usize max_tasks , batt :: StaticType < Phase > phase ) function parallel_merge_fanout \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , Fixed fixed_begin , Fixed fixed_end , Fixed fixed_part_begin , Fixed fixed_part_end , Search search_begin , Search search_end , Dst dst_begin , Compare && compare , usize min_task_size , usize max_tasks , batt :: StaticType < Phase > ) function has_const_buffer_sequence_requirements_impl \ud83d\udd17 1 2 3 4 template < typename T > inline std :: false_type has_const_buffer_sequence_requirements_impl ( ... ) function has_const_buffer_sequence_requirements_impl \ud83d\udd17 1 2 3 4 5 template < typename T , typename ElementT = decltype ( * boost :: asio :: buffer_sequence_begin ( std :: declval < T > ())) > inline std :: true_type has_const_buffer_sequence_requirements_impl ( std :: decay_t < T > * ) function has_buffer_source_requirements_impl \ud83d\udd17 1 2 3 4 template < typename T > inline std :: false_type has_buffer_source_requirements_impl ( ... ) function has_buffer_source_requirements_impl \ud83d\udd17 1 2 3 4 template < typename T > inline std :: true_type has_buffer_source_requirements_impl ( std :: decay_t < T > * ) function print_nothing \ud83d\udd17 1 2 3 inline void print_nothing ( std :: ostream & ) function handle_segv \ud83d\udd17 1 2 3 inline void handle_segv ( int sig ) function exit_impl \ud83d\udd17 1 2 3 inline void exit_impl ( int code ) function has_seq_requirements_impl \ud83d\udd17 1 2 3 4 template < typename T > inline std :: false_type has_seq_requirements_impl ( ... ) function has_seq_requirements_impl \ud83d\udd17 1 2 3 4 5 template < typename T , typename ItemT = typename std :: decay_t < T >:: Item > inline std :: true_type has_seq_requirements_impl ( std :: decay_t < T > * ) function is_ref_counted_impl \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = decltype ( intrusive_ptr_add_ref (( T * ) nullptr )), typename = decltype ( intrusive_ptr_release (( T * ) nullptr )) > std :: true_type is_ref_counted_impl ( void * ) function is_ref_counted_impl \ud83d\udd17 1 2 3 4 template < typename T > std :: false_type is_ref_counted_impl ( ... ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const ModelCheckShardMetrics & t ) function CaseHandlerImpl \ud83d\udd17 1 2 3 4 5 6 7 template < typename IntT , IntT I , typename Fn , typename R > R CaseHandlerImpl ( Fn && fn ) function initialize_case_handlers \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 template < typename IntT , IntT I , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , I > , std :: integral_constant < IntT , I > , AbstractCaseHandler < Fn , R > * , AbstractCaseHandler < Fn , R > * ) function initialize_case_handlers \ud83d\udd17 1 2 3 4 5 6 7 8 9 10 11 template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , kBegin > , std :: integral_constant < IntT , kEnd > , AbstractCaseHandler < Fn , R > * begin , AbstractCaseHandler < Fn , R > * end ) function from_string_impl \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename ... FormatArgs > std :: optional < T > from_string_impl ( StaticType < T > , const std :: string & str , FormatArgs && ... format_args ) function from_string_impl \ud83d\udd17 1 2 3 4 5 6 template < typename ... FormatArgs > std :: optional < bool > from_string_impl ( StaticType < bool > , const std :: string & str , FormatArgs && ... ) function range_dump_pretty \ud83d\udd17 1 inline Pretty & range_dump_pretty () function range_dump_depth \ud83d\udd17 1 inline int & range_dump_depth () function dump_item \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , u8 > {} > , typename = std :: enable_if_t <! IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item ) function dump_item \ud83d\udd17 1 2 3 4 inline std :: ostream & dump_item ( std :: ostream & out , const std :: string & s ) function dump_item \ud83d\udd17 1 2 3 4 inline std :: ostream & dump_item ( std :: ostream & out , const std :: string_view & s ) function dump_item \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item ) function dump_item \ud83d\udd17 1 2 3 4 inline std :: ostream & dump_item ( std :: ostream & out , u8 byte_val ) function dump_item \ud83d\udd17 1 2 3 4 5 6 template < typename FirstT , typename SecondT > inline std :: ostream & dump_item ( std :: ostream & out , const std :: pair < FirstT , SecondT > & p ) function is_callable_impl \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename ... Args , typename Result = std :: result_of_t < Fn ( Args ...) >> std :: true_type is_callable_impl ( void * ) function is_callable_impl \ud83d\udd17 1 2 3 4 5 template < typename Fn , typename ... Args > std :: false_type is_callable_impl ( ... ) function is_printable_impl \ud83d\udd17 1 2 3 4 5 template < typename T , typename Result = decltype ( std :: declval < std :: ostream &> () << std :: declval < T > ()) > std :: true_type is_printable_impl ( void * ) function is_printable_impl \ud83d\udd17 1 2 3 4 5 template < typename Fn , typename ... Args > std :: false_type is_printable_impl ( ... ) function is_range_impl \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename BeginIter = decltype ( std :: begin ( std :: declval < T > ())), typename EndIter = decltype ( std :: end ( std :: declval < T > ())), typename = std :: enable_if_t < std :: is_same < BeginIter , EndIter > {} >> std :: true_type is_range_impl ( void * ) function is_range_impl \ud83d\udd17 1 2 3 4 template < typename T > std :: false_type is_range_impl ( ... ) function can_be_eq_compared_helper \ud83d\udd17 1 2 3 4 5 6 7 template < typename T , typename U , typename = decltype ( std :: declval < const T &> () == std :: declval < const U &> ()) > std :: true_type can_be_eq_compared_helper ( const T * , const U * ) function can_be_eq_compared_helper \ud83d\udd17 1 2 3 4 5 template < typename T , typename U > std :: false_type can_be_eq_compared_helper ( ... ) function parse_url_auth \ud83d\udd17 1 2 3 4 inline StatusOr < UrlParse > parse_url_auth ( std :: string_view url , UrlParse && parse ) function parse_url_host \ud83d\udd17 1 2 3 4 inline StatusOr < UrlParse > parse_url_host ( std :: string_view url , UrlParse && parse ) function parse_url_port \ud83d\udd17 1 2 3 4 inline StatusOr < UrlParse > parse_url_port ( std :: string_view url , UrlParse && parse ) function parse_url_path \ud83d\udd17 1 2 3 4 inline StatusOr < UrlParse > parse_url_path ( std :: string_view url , UrlParse && parse ) function parse_url_query \ud83d\udd17 1 2 3 4 inline StatusOr < UrlParse > parse_url_query ( std :: string_view url , UrlParse && parse ) function parse_url_fragment \ud83d\udd17 1 2 3 4 StatusOr < UrlParse > parse_url_fragment ( std :: string_view url , UrlParse && parse ) Attributes Documentation \ud83d\udd17 variable kThreshold \ud83d\udd17 1 static constexpr isize kThreshold = 1400 ; variable kMaxShards \ud83d\udd17 1 static constexpr isize kMaxShards = 8 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::detail"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#classes","text":"Name class batt::detail::AbstractCopyFn class batt::detail::AbstractMoveFn class batt::detail::CopyFnImpl struct batt::detail::FirstMatchImpl struct batt::detail::FirstMatchImpl< std::tuple< CaseFirst, CaseRest... >, std::tuple< Args... > > struct batt::detail::FirstMatchImpl< std::tuple<>, std::tuple< Args... > > struct batt::detail::FirstPhase class batt::detail::FutureImpl class batt::detail::HttpClientRequestContext struct batt::detail::IsStatusOrImpl struct batt::detail::IsStatusOrImpl< StatusOr< T > > struct batt::detail::ModelCheckShardMetrics class batt::detail::MoveFnImpl class batt::detail::NotOkStatusWrapper struct batt::detail::NullableImpl struct batt::detail::NullableImpl< std::optional< T > > struct batt::detail::NullableImpl< std::shared_ptr< T > > struct batt::detail::NullableImpl< std::unique_ptr< T > > struct batt::detail::NullableImpl< T * > class batt::detail::ParallelModelCheckState struct batt::detail::SecondPhase class batt::detail::SigInfoHandler class batt::detail::StatusBase class batt::detail::StatusOrValueContainer class batt::detail::StatusOrValueContainer< T & > struct batt::detail::ThirdPhase struct batt::detail::VisitorResult struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > && > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const & > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const && > struct batt::detail::VisitorResult< Visitor, std::variant< Ts... > const >","title":"Classes"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#types","text":"Name template <typename Visitor ,typename VariantArg > using typename VisitorResult < Visitor, VariantArg >::type VisitorResultT template <bool kMoveOnly,typename Result ,typename... Args> using std::conditional_t< kMoveOnly , AbstractMoveFn < true, Result, Args... >, AbstractCopyFn < Result, Args... > > AbstractFn template <typename Fn ,bool kMoveOnly,typename Result ,typename... Args> using std::conditional_t< kMoveOnly , MoveFnImpl < Fn, kMoveOnly , Result, Args... >, CopyFnImpl < Fn, Result, Args... > > FnImpl template <typename Arg ,typename Result > using Result(*)(Arg) AbstractCaseHandler","title":"Types"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#functions","text":"Name template <typename Fixed ,typename Search ,typename Dst ,typename Compare ,typename Phase > void parallel_merge_fanout ( WorkContext & context, Fixed fixed_begin, Fixed fixed_end, Search search_begin, Search search_end, Dst dst_begin, Compare && compare, usize min_task_size, usize max_tasks, batt::StaticType < Phase > ) template <typename Src0 ,typename Src1 ,typename Dst ,typename Compare ,typename Phase > void parallel_merge_impl ( WorkContext & context, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare && compare, usize min_task_size, usize max_tasks, batt::StaticType < Phase > phase) template <typename Fixed ,typename Search ,typename Dst ,typename Compare ,typename Phase > void parallel_merge_fanout ( WorkContext & context, Fixed fixed_begin, Fixed fixed_end, Fixed fixed_part_begin, Fixed fixed_part_end, Search search_begin, Search search_end, Dst dst_begin, Compare && compare, usize min_task_size, usize max_tasks, batt::StaticType < Phase > ) template <typename T > std::false_type has_const_buffer_sequence_requirements_impl (... ) template <typename T ,typename ElementT =decltype(*boost::asio::buffer_sequence_begin(std::declval ()))> std::true_type has_const_buffer_sequence_requirements_impl (std::decay_t< T > * ) template <typename T > std::false_type has_buffer_source_requirements_impl (... ) template <typename T > std::true_type has_buffer_source_requirements_impl (std::decay_t< T > * ) void print_nothing (std::ostream & ) void handle_segv (int sig) void exit_impl (int code) template <typename T > std::false_type has_seq_requirements_impl (... ) template <typename T ,typename ItemT =typename std::decay_t ::Item> std::true_type has_seq_requirements_impl (std::decay_t< T > * ) template <typename T ,typename =decltype(intrusive_ptr_add_ref((T )nullptr)),typename =decltype(intrusive_ptr_release((T )nullptr))> std::true_type is_ref_counted_impl (void * ) template <typename T > std::false_type is_ref_counted_impl (... ) std::ostream & operator<< (std::ostream & out, const ModelCheckShardMetrics & t) template <typename IntT ,IntT I,typename Fn ,typename R > R CaseHandlerImpl (Fn && fn) template <typename IntT ,IntT I,typename Fn ,typename R > void initialize_case_handlers (std::integral_constant< IntT, I > , std::integral_constant< IntT, I > , AbstractCaseHandler< Fn, R > * , AbstractCaseHandler< Fn, R > * ) template <typename IntT ,IntT kBegin,IntT kEnd,typename Fn ,typename R > void initialize_case_handlers (std::integral_constant< IntT, kBegin > , std::integral_constant< IntT, kEnd > , AbstractCaseHandler< Fn, R > * begin, AbstractCaseHandler< Fn, R > * end) template <typename T ,typename... FormatArgs> std::optional< T > from_string_impl ( StaticType < T > , const std::string & str, FormatArgs &&... format_args) template <typename... FormatArgs> std::optional< bool > from_string_impl ( StaticType < bool > , const std::string & str, FormatArgs && ...) Pretty & range_dump_pretty () int & range_dump_depth () template <typename T ,typename =std::enable_if_t<!std::is_same , u8>{}>,typename =std::enable_if_t<!IsRange {}>> std::ostream & dump_item (std::ostream & out, T && item) std::ostream & dump_item (std::ostream & out, const std::string & s) std::ostream & dump_item (std::ostream & out, const std::string_view & s) template <typename T ,typename =std::enable_if_t {}>> std::ostream & dump_item (std::ostream & out, T && item) std::ostream & dump_item (std::ostream & out, u8 byte_val) template <typename FirstT ,typename SecondT > std::ostream & dump_item (std::ostream & out, const std::pair< FirstT, SecondT > & p) template <typename Fn ,typename... Args,typename Result =std::result_of_t > std::true_type is_callable_impl (void * ) template <typename Fn ,typename... Args> std::false_type is_callable_impl (... ) template <typename T ,typename Result =decltype(std::declval () << std::declval ())> std::true_type is_printable_impl (void * ) template <typename Fn ,typename... Args> std::false_type is_printable_impl (... ) template <typename T ,typename BeginIter =decltype(std::begin(std::declval ())),typename EndIter =decltype(std::end(std::declval ())),typename =std::enable_if_t {}>> std::true_type is_range_impl (void * ) template <typename T > std::false_type is_range_impl (... ) template <typename T ,typename U ,typename =decltype(std::declval () == std::declval ())> std::true_type can_be_eq_compared_helper (const T * , const U * ) template <typename T ,typename U > std::false_type can_be_eq_compared_helper (... ) StatusOr < UrlParse > parse_url_auth (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_host (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_port (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_path (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_query (std::string_view url, UrlParse && parse) StatusOr < UrlParse > parse_url_fragment (std::string_view url, UrlParse && parse)","title":"Functions"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#attributes","text":"Name constexpr isize kThreshold constexpr isize kMaxShards","title":"Attributes"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#types-documentation","text":"","title":"Types Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-visitorresultt","text":"1 2 3 template < typename Visitor , typename VariantArg > using batt :: detail :: VisitorResultT = typedef typename VisitorResult < Visitor , VariantArg >:: type ;","title":"using VisitorResultT"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-abstractfn","text":"1 2 3 4 template < bool kMoveOnly , typename Result , typename ... Args > using batt :: detail :: AbstractFn = typedef std :: conditional_t < kMoveOnly , AbstractMoveFn < true , Result , Args ... > , AbstractCopyFn < Result , Args ... > > ;","title":"using AbstractFn"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-fnimpl","text":"1 2 3 4 5 template < typename Fn , bool kMoveOnly , typename Result , typename ... Args > using batt :: detail :: FnImpl = typedef std :: conditional_t < kMoveOnly , MoveFnImpl < Fn , kMoveOnly , Result , Args ... > , CopyFnImpl < Fn , Result , Args ... > > ;","title":"using FnImpl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-abstractcasehandler","text":"1 2 3 template < typename Arg , typename Result > using batt :: detail :: AbstractCaseHandler = typedef Result ( * )( Arg );","title":"using AbstractCaseHandler"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parallel_merge_fanout","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , Fixed fixed_begin , Fixed fixed_end , Search search_begin , Search search_end , Dst dst_begin , Compare && compare , usize min_task_size , usize max_tasks , batt :: StaticType < Phase > )","title":"function parallel_merge_fanout"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parallel_merge_impl","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template < typename Src0 , typename Src1 , typename Dst , typename Compare , typename Phase > void parallel_merge_impl ( WorkContext & context , Src0 src_0_begin , Src0 src_0_end , Src1 src_1_begin , Src1 src_1_end , Dst dst_begin , Compare && compare , usize min_task_size , usize max_tasks , batt :: StaticType < Phase > phase )","title":"function parallel_merge_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parallel_merge_fanout_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template < typename Fixed , typename Search , typename Dst , typename Compare , typename Phase > void parallel_merge_fanout ( WorkContext & context , Fixed fixed_begin , Fixed fixed_end , Fixed fixed_part_begin , Fixed fixed_part_end , Search search_begin , Search search_end , Dst dst_begin , Compare && compare , usize min_task_size , usize max_tasks , batt :: StaticType < Phase > )","title":"function parallel_merge_fanout"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_const_buffer_sequence_requirements_impl","text":"1 2 3 4 template < typename T > inline std :: false_type has_const_buffer_sequence_requirements_impl ( ... )","title":"function has_const_buffer_sequence_requirements_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_const_buffer_sequence_requirements_impl_1","text":"1 2 3 4 5 template < typename T , typename ElementT = decltype ( * boost :: asio :: buffer_sequence_begin ( std :: declval < T > ())) > inline std :: true_type has_const_buffer_sequence_requirements_impl ( std :: decay_t < T > * )","title":"function has_const_buffer_sequence_requirements_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_buffer_source_requirements_impl","text":"1 2 3 4 template < typename T > inline std :: false_type has_buffer_source_requirements_impl ( ... )","title":"function has_buffer_source_requirements_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_buffer_source_requirements_impl_1","text":"1 2 3 4 template < typename T > inline std :: true_type has_buffer_source_requirements_impl ( std :: decay_t < T > * )","title":"function has_buffer_source_requirements_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-print_nothing","text":"1 2 3 inline void print_nothing ( std :: ostream & )","title":"function print_nothing"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-handle_segv","text":"1 2 3 inline void handle_segv ( int sig )","title":"function handle_segv"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-exit_impl","text":"1 2 3 inline void exit_impl ( int code )","title":"function exit_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_seq_requirements_impl","text":"1 2 3 4 template < typename T > inline std :: false_type has_seq_requirements_impl ( ... )","title":"function has_seq_requirements_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_seq_requirements_impl_1","text":"1 2 3 4 5 template < typename T , typename ItemT = typename std :: decay_t < T >:: Item > inline std :: true_type has_seq_requirements_impl ( std :: decay_t < T > * )","title":"function has_seq_requirements_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_ref_counted_impl","text":"1 2 3 4 5 6 template < typename T , typename = decltype ( intrusive_ptr_add_ref (( T * ) nullptr )), typename = decltype ( intrusive_ptr_release (( T * ) nullptr )) > std :: true_type is_ref_counted_impl ( void * )","title":"function is_ref_counted_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_ref_counted_impl_1","text":"1 2 3 4 template < typename T > std :: false_type is_ref_counted_impl ( ... )","title":"function is_ref_counted_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-operator","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const ModelCheckShardMetrics & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-casehandlerimpl","text":"1 2 3 4 5 6 7 template < typename IntT , IntT I , typename Fn , typename R > R CaseHandlerImpl ( Fn && fn )","title":"function CaseHandlerImpl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-initialize_case_handlers","text":"1 2 3 4 5 6 7 8 9 10 template < typename IntT , IntT I , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , I > , std :: integral_constant < IntT , I > , AbstractCaseHandler < Fn , R > * , AbstractCaseHandler < Fn , R > * )","title":"function initialize_case_handlers"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-initialize_case_handlers_1","text":"1 2 3 4 5 6 7 8 9 10 11 template < typename IntT , IntT kBegin , IntT kEnd , typename Fn , typename R > void initialize_case_handlers ( std :: integral_constant < IntT , kBegin > , std :: integral_constant < IntT , kEnd > , AbstractCaseHandler < Fn , R > * begin , AbstractCaseHandler < Fn , R > * end )","title":"function initialize_case_handlers"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-from_string_impl","text":"1 2 3 4 5 6 7 template < typename T , typename ... FormatArgs > std :: optional < T > from_string_impl ( StaticType < T > , const std :: string & str , FormatArgs && ... format_args )","title":"function from_string_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-from_string_impl_1","text":"1 2 3 4 5 6 template < typename ... FormatArgs > std :: optional < bool > from_string_impl ( StaticType < bool > , const std :: string & str , FormatArgs && ... )","title":"function from_string_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-range_dump_pretty","text":"1 inline Pretty & range_dump_pretty ()","title":"function range_dump_pretty"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-range_dump_depth","text":"1 inline int & range_dump_depth ()","title":"function range_dump_depth"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item","text":"1 2 3 4 5 6 7 template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , u8 > {} > , typename = std :: enable_if_t <! IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item )","title":"function dump_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_1","text":"1 2 3 4 inline std :: ostream & dump_item ( std :: ostream & out , const std :: string & s )","title":"function dump_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_2","text":"1 2 3 4 inline std :: ostream & dump_item ( std :: ostream & out , const std :: string_view & s )","title":"function dump_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_3","text":"1 2 3 4 5 6 template < typename T , typename = std :: enable_if_t < IsRange < T > {} >> inline std :: ostream & dump_item ( std :: ostream & out , T && item )","title":"function dump_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_4","text":"1 2 3 4 inline std :: ostream & dump_item ( std :: ostream & out , u8 byte_val )","title":"function dump_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_5","text":"1 2 3 4 5 6 template < typename FirstT , typename SecondT > inline std :: ostream & dump_item ( std :: ostream & out , const std :: pair < FirstT , SecondT > & p )","title":"function dump_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_callable_impl","text":"1 2 3 4 5 6 template < typename Fn , typename ... Args , typename Result = std :: result_of_t < Fn ( Args ...) >> std :: true_type is_callable_impl ( void * )","title":"function is_callable_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_callable_impl_1","text":"1 2 3 4 5 template < typename Fn , typename ... Args > std :: false_type is_callable_impl ( ... )","title":"function is_callable_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_printable_impl","text":"1 2 3 4 5 template < typename T , typename Result = decltype ( std :: declval < std :: ostream &> () << std :: declval < T > ()) > std :: true_type is_printable_impl ( void * )","title":"function is_printable_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_printable_impl_1","text":"1 2 3 4 5 template < typename Fn , typename ... Args > std :: false_type is_printable_impl ( ... )","title":"function is_printable_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_range_impl","text":"1 2 3 4 5 6 7 template < typename T , typename BeginIter = decltype ( std :: begin ( std :: declval < T > ())), typename EndIter = decltype ( std :: end ( std :: declval < T > ())), typename = std :: enable_if_t < std :: is_same < BeginIter , EndIter > {} >> std :: true_type is_range_impl ( void * )","title":"function is_range_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_range_impl_1","text":"1 2 3 4 template < typename T > std :: false_type is_range_impl ( ... )","title":"function is_range_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-can_be_eq_compared_helper","text":"1 2 3 4 5 6 7 template < typename T , typename U , typename = decltype ( std :: declval < const T &> () == std :: declval < const U &> ()) > std :: true_type can_be_eq_compared_helper ( const T * , const U * )","title":"function can_be_eq_compared_helper"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-can_be_eq_compared_helper_1","text":"1 2 3 4 5 template < typename T , typename U > std :: false_type can_be_eq_compared_helper ( ... )","title":"function can_be_eq_compared_helper"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_auth","text":"1 2 3 4 inline StatusOr < UrlParse > parse_url_auth ( std :: string_view url , UrlParse && parse )","title":"function parse_url_auth"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_host","text":"1 2 3 4 inline StatusOr < UrlParse > parse_url_host ( std :: string_view url , UrlParse && parse )","title":"function parse_url_host"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_port","text":"1 2 3 4 inline StatusOr < UrlParse > parse_url_port ( std :: string_view url , UrlParse && parse )","title":"function parse_url_port"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_path","text":"1 2 3 4 inline StatusOr < UrlParse > parse_url_path ( std :: string_view url , UrlParse && parse )","title":"function parse_url_path"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_query","text":"1 2 3 4 inline StatusOr < UrlParse > parse_url_query ( std :: string_view url , UrlParse && parse )","title":"function parse_url_query"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_fragment","text":"1 2 3 4 StatusOr < UrlParse > parse_url_fragment ( std :: string_view url , UrlParse && parse )","title":"function parse_url_fragment"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#variable-kthreshold","text":"1 static constexpr isize kThreshold = 1400 ;","title":"variable kThreshold"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#variable-kmaxshards","text":"1 static constexpr isize kMaxShards = 8 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kMaxShards"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/","text":"batt::int_types \ud83d\udd17 Types \ud83d\udd17 Name using std::uint8_t u8 using std::int8_t i8 using std::uint16_t u16 using std::int16_t i16 using std::uint32_t u32 using std::int32_t i32 using std::uint64_t u64 using std::int64_t i64 using std::size_t usize using std::ptrdiff_t isize Types Documentation \ud83d\udd17 using u8 \ud83d\udd17 1 using batt :: int_types :: u8 = typedef std :: uint8_t ; using i8 \ud83d\udd17 1 using batt :: int_types :: i8 = typedef std :: int8_t ; using u16 \ud83d\udd17 1 using batt :: int_types :: u16 = typedef std :: uint16_t ; using i16 \ud83d\udd17 1 using batt :: int_types :: i16 = typedef std :: int16_t ; using u32 \ud83d\udd17 1 using batt :: int_types :: u32 = typedef std :: uint32_t ; using i32 \ud83d\udd17 1 using batt :: int_types :: i32 = typedef std :: int32_t ; using u64 \ud83d\udd17 1 using batt :: int_types :: u64 = typedef std :: uint64_t ; using i64 \ud83d\udd17 1 using batt :: int_types :: i64 = typedef std :: int64_t ; using usize \ud83d\udd17 1 using batt :: int_types :: usize = typedef std :: size_t ; using isize \ud83d\udd17 1 using batt :: int_types :: isize = typedef std :: ptrdiff_t ; Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::int_types"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#types","text":"Name using std::uint8_t u8 using std::int8_t i8 using std::uint16_t u16 using std::int16_t i16 using std::uint32_t u32 using std::int32_t i32 using std::uint64_t u64 using std::int64_t i64 using std::size_t usize using std::ptrdiff_t isize","title":"Types"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#types-documentation","text":"","title":"Types Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u8","text":"1 using batt :: int_types :: u8 = typedef std :: uint8_t ;","title":"using u8"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i8","text":"1 using batt :: int_types :: i8 = typedef std :: int8_t ;","title":"using i8"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u16","text":"1 using batt :: int_types :: u16 = typedef std :: uint16_t ;","title":"using u16"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i16","text":"1 using batt :: int_types :: i16 = typedef std :: int16_t ;","title":"using i16"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u32","text":"1 using batt :: int_types :: u32 = typedef std :: uint32_t ;","title":"using u32"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i32","text":"1 using batt :: int_types :: i32 = typedef std :: int32_t ;","title":"using i32"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u64","text":"1 using batt :: int_types :: u64 = typedef std :: uint64_t ;","title":"using u64"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i64","text":"1 using batt :: int_types :: i64 = typedef std :: int64_t ;","title":"using i64"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-usize","text":"1 using batt :: int_types :: usize = typedef std :: size_t ;","title":"using usize"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-isize","text":"1 using batt :: int_types :: isize = typedef std :: ptrdiff_t ; Updated on 26 August 2022 at 17:30:03 UTC","title":"using isize"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/","text":"batt::seq \ud83d\udd17 Classes \ud83d\udd17 Name struct batt::seq::Addition struct batt::seq::AllBinder struct batt::seq::AnyBinder struct batt::seq::ApplyBinder class batt::seq::Attach struct batt::seq::AttachBinder struct batt::seq::BoxedBinder class batt::seq::CacheNext struct batt::seq::CacheNextBinder class batt::seq::Chain struct batt::seq::ChainBinder struct batt::seq::Collect struct batt::seq::CollectVec struct batt::seq::Consume struct batt::seq::CountBinder struct batt::seq::DecayItem struct batt::seq::Deref class batt::seq::Empty class batt::seq::Filter struct batt::seq::FilterBinder class batt::seq::FilterMap struct batt::seq::FilterMapBinder struct batt::seq::FirstBinder class batt::seq::Flatten struct batt::seq::FlattenBinder struct batt::seq::ForEachBinder class batt::seq::Fuse struct batt::seq::FuseBinder class batt::seq::GroupBy struct batt::seq::GroupByBinder struct batt::seq::InnerReduceBinder class batt::seq::InspectAdjacent struct batt::seq::InspectAdjacentBinder struct batt::seq::IsNotFalse struct batt::seq::IsSortedBinder class batt::seq::KMergeBy struct batt::seq::KMergeByBinder struct batt::seq::LastBinder class batt::seq::Lazy class batt::seq::Map class batt::seq::MapAdjacent struct batt::seq::MapAdjacentBinder struct batt::seq::MapBinder class batt::seq::MapFold struct batt::seq::MapFoldBinder class batt::seq::MapPairwise struct batt::seq::MapPairwiseBinder class batt::seq::MergeBy struct batt::seq::MergeByBinder struct batt::seq::NaturalEquals struct batt::seq::NaturalOrder struct batt::seq::PrependBinder class batt::seq::Printable struct batt::seq::PrintableBinder struct batt::seq::PrintOut struct batt::seq::ProductBinder struct batt::seq::ReduceBinder struct batt::seq::Reverse struct batt::seq::RollingBinder struct batt::seq::RunningTotalBinder class batt::seq::SingleItem class batt::seq::Splice struct batt::seq::SpliceBinder class batt::seq::StatusOk struct batt::seq::StatusOkBinder struct batt::seq::SumBinder class batt::seq::TakeN struct batt::seq::TakeNBinder class batt::seq::TakeWhile struct batt::seq::TakeWhileBinder struct batt::seq::WriteToBinder Types \ud83d\udd17 Name enum LoopControl { kContinue = 0, kBreak = 1} Functions \ud83d\udd17 Name template <typename AsyncWriteStream > auto write_to (AsyncWriteStream && dst) BoxedBinder boxed () template <typename Seq ,typename =EnableIfSeq ,typename Item =typename std::conditional_t (), SeqItem_Impl\\ , StaticType\\ >::type> BoxedSeq < Item > **[operator CacheNextBinder cache_next () template <typename Seq > auto **[operator template <typename Seq2 > ChainBinder < Seq2 > chain (Seq2 && seq2) template <typename Seq1 ,typename Seq2 > Chain < Seq1, Seq2 > **[operator CollectVec collect_vec () template <typename Seq ,typename =EnableIfSeq > auto **[operator auto consume () template <typename Seq ,typename =EnableIfSeq > void **[operator CountBinder count () template <typename Seq > BATT_MAYBE_UNUSED usize **[operator auto deref () template <typename Container > auto emplace_back (Container * dst) template <typename Predicate > FilterBinder < Predicate > filter (Predicate && predicate) template <typename Seq ,typename Predicate > Filter < Seq, Predicate > **[operator template <typename Seq ,typename Fn > auto filter_map_impl (Seq && seq, Fn && fn) template <typename Fn > FilterMapBinder < Fn > filter_map (Fn && fn) template <typename Seq ,typename Fn > FilterMap < Seq, Fn > **[operator FirstBinder first () template <typename Seq > auto **[operator FlattenBinder flatten () template <typename OuterSeq > Flatten < OuterSeq > **[operator template <typename Fn > ForEachBinder < Fn > for_each (Fn && fn) template <typename Seq ,typename Fn ,typename =EnableIfSeq > LoopControl **[operator template <typename GroupEq > GroupByBinder < GroupEq > group_by (GroupEq && group_eq) template <typename Seq ,typename GroupEq > GroupBy < Seq, GroupEq > **[operator template <typename Fn > auto lazy (Fn && fn) template <typename Fn ,typename... Args,typename =std::enable_if_t , LoopControl>>> LoopControl run_loop_fn (Fn && fn, Args &&... args) template <typename Fn ,typename... Args,typename =std::enable_if_t<!std::is_convertible_v , LoopControl>>,typename =void> LoopControl run_loop_fn (Fn && fn, Args &&... args) template <typename MapFn > MapBinder < MapFn > map (MapFn && map_fn) template <typename Seq ,typename MapFn > Map < Seq, MapFn > **[operator template <typename Compare ,typename RightSeq > MergeByBinder < RightSeq, Compare > merge_by (Compare && compare, RightSeq && right) template <typename RightSeq > auto merge (RightSeq && right) template <typename LeftSeq ,typename RightSeq ,typename Compare > MergeBy < LeftSeq, RightSeq, Compare > **[operator template <typename Item > auto prepend (Item && item) auto print_out (std::ostream & out, std::string_view sep =\" \") template <typename Seq ,typename =EnableIfSeq > auto **[operator auto debug_out (std::ostream & out, std::string_view sep =\" \") PrintableBinder printable () template <typename Seq > auto **[operator template <typename State ,typename ReduceFn > ReduceBinder < State, ReduceFn > reduce (State && state, ReduceFn && reduce_fn) template <typename Seq ,typename State ,typename ReduceFn > State **[operator auto status_ok () template <typename SeqT > StatusOk < SeqT > **[operator TakeNBinder take_n (usize n) template <typename Seq ,typename =EnableIfSeq > TakeN < Seq > **[operator template <typename Predicate > TakeWhileBinder < Predicate > take_while (Predicate && predicate) template <typename Seq ,typename Predicate > TakeWhile < Seq, Predicate > **[operator template <typename T > Collect < T > collect ( StaticType < T > ={}) template <typename Seq ,typename T > auto **[operator auto decayed () template <typename Compare > KMergeByBinder < Compare > kmerge_by (Compare && compare) auto kmerge () template <typename KSeqs ,typename Compare > KMergeBy < SeqItem< KSeqs >, Compare > **[operator template <typename RightSeq ,typename MapFn > MapPairwiseBinder < RightSeq, MapFn > map_pairwise (RightSeq && right, MapFn && map_fn) template <typename LeftSeq ,typename RightSeq ,typename MapFn > MapPairwise < LeftSeq, RightSeq, MapFn > **[operator LastBinder last () template <typename Seq > auto **[operator template <typename ReduceFn > InnerReduceBinder < ReduceFn > inner_reduce (ReduceFn && reduce_fn) template <typename Seq ,typename ReduceFn > Optional < std::decay_t< SeqItem< Seq > > > **[operator template <typename T > SingleItem < T > single_item (T && item) SumBinder sum () template <typename Seq > auto **[operator ProductBinder product () template <typename Seq > auto **[operator AnyBinder any_true () template <typename Seq > auto **[operator AllBinder all_true () template <typename Seq > auto **[operator template <typename Fn > MapAdjacentBinder < Fn > map_adjacent (Fn && fn) template <typename Seq ,typename Fn > MapAdjacent < Seq, Fn > **[operator template <typename State ,typename MapFn > MapFoldBinder < State, MapFn > map_fold (State && state, MapFn && map_fn) template <typename Seq ,typename State ,typename MapFn > MapFold < Seq, State, MapFn > **[operator template <typename T ,typename BinaryFn > RollingBinder < T, BinaryFn > rolling (BinaryFn && binary_fn, T && initial =T{}) template <typename Seq ,typename T ,typename BinaryFn > auto **[operator RunningTotalBinder running_total () template <typename Seq > auto **[operator template <typename Fn > auto inspect (Fn && fn) template <typename InnerSeq > SpliceBinder < InnerSeq > splice (std::size_t n, InnerSeq && inner_seq) template <typename OuterSeq ,typename InnerSeq > auto **[operator template <typename Compare > IsSortedBinder < Compare > is_sorted_by (Compare && compare) auto is_sorted () template <typename Seq ,typename Compare > bool **[operator template <typename Fn > InspectAdjacentBinder < Fn > inspect_adjacent (Fn && fn) template <typename Seq ,typename Fn > InspectAdjacent < Seq, Fn > **[operator template <typename SeqFn > ApplyBinder < SeqFn > apply (SeqFn && seq_fn) template <typename Seq ,typename SeqFn > decltype(auto) **[operator template <typename D > AttachBinder < D > attach (D && data) template <typename Seq ,typename D > auto **[operator FuseBinder fuse () template <typename Seq > Fuse < Seq > **[operator Types Documentation \ud83d\udd17 enum LoopControl \ud83d\udd17 Enumerator Value Description kContinue 0 kBreak 1 Functions Documentation \ud83d\udd17 function write_to \ud83d\udd17 1 2 3 4 template < typename AsyncWriteStream > inline auto write_to ( AsyncWriteStream && dst ) function boxed \ud83d\udd17 1 inline BoxedBinder boxed () function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Seq , typename = EnableIfSeq < Seq > , typename Item = typename std :: conditional_t < has_seq_requirements < Seq > (), SeqItem_Impl < Seq > , StaticType < void >>:: type > inline BoxedSeq < Item > operator | ( Seq && seq , BoxedBinder ) function cache_next \ud83d\udd17 1 inline CacheNextBinder cache_next () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , CacheNextBinder ) function chain \ud83d\udd17 1 2 3 4 template < typename Seq2 > ChainBinder < Seq2 > chain ( Seq2 && seq2 ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq1 , typename Seq2 > Chain < Seq1 , Seq2 > operator | ( Seq1 && seq1 , ChainBinder < Seq2 > && binder ) function collect_vec \ud83d\udd17 1 inline CollectVec collect_vec () function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> auto operator | ( Seq && seq , CollectVec ) function consume \ud83d\udd17 1 inline auto consume () function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> void operator | ( Seq && seq , Consume && ) function count \ud83d\udd17 1 inline CountBinder count () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > BATT_MAYBE_UNUSED usize operator | ( Seq && seq , CountBinder ) function deref \ud83d\udd17 1 inline auto deref () function emplace_back \ud83d\udd17 1 2 3 4 template < typename Container > inline auto emplace_back ( Container * dst ) function filter \ud83d\udd17 1 2 3 4 template < typename Predicate > FilterBinder < Predicate > filter ( Predicate && predicate ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Predicate > Filter < Seq , Predicate > operator | ( Seq && seq , FilterBinder < Predicate > && binder ) function filter_map_impl \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Fn > auto filter_map_impl ( Seq && seq , Fn && fn ) function filter_map \ud83d\udd17 1 2 3 4 template < typename Fn > FilterMapBinder < Fn > filter_map ( Fn && fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Fn > FilterMap < Seq , Fn > operator | ( Seq && seq , FilterMapBinder < Fn > && binder ) function first \ud83d\udd17 1 inline FirstBinder first () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , FirstBinder ) function flatten \ud83d\udd17 1 inline FlattenBinder flatten () function operator| \ud83d\udd17 1 2 3 4 5 template < typename OuterSeq > Flatten < OuterSeq > operator | ( OuterSeq && seq , FlattenBinder ) function for_each \ud83d\udd17 1 2 3 4 template < typename Fn > ForEachBinder < Fn > for_each ( Fn && fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Seq , typename Fn , typename = EnableIfSeq < Seq >> LoopControl operator | ( Seq && seq , ForEachBinder < Fn > && binder ) function group_by \ud83d\udd17 1 2 3 4 template < typename GroupEq > GroupByBinder < GroupEq > group_by ( GroupEq && group_eq ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename GroupEq > GroupBy < Seq , GroupEq > operator | ( Seq && seq , GroupByBinder < GroupEq > && binder ) function lazy \ud83d\udd17 1 2 3 4 template < typename Fn > auto lazy ( Fn && fn ) function run_loop_fn \ud83d\udd17 1 2 3 4 5 6 7 template < typename Fn , typename ... Args , typename = std :: enable_if_t < std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >>> LoopControl run_loop_fn ( Fn && fn , Args && ... args ) function run_loop_fn \ud83d\udd17 1 2 3 4 5 6 7 8 template < typename Fn , typename ... Args , typename = std :: enable_if_t <! std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >> , typename = void > LoopControl run_loop_fn ( Fn && fn , Args && ... args ) function map \ud83d\udd17 1 2 3 4 template < typename MapFn > MapBinder < MapFn > map ( MapFn && map_fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename MapFn > Map < Seq , MapFn > operator | ( Seq && seq , MapBinder < MapFn > && binder ) function merge_by \ud83d\udd17 1 2 3 4 5 6 template < typename Compare , typename RightSeq > MergeByBinder < RightSeq , Compare > merge_by ( Compare && compare , RightSeq && right ) function merge \ud83d\udd17 1 2 3 4 template < typename RightSeq > auto merge ( RightSeq && right ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename LeftSeq , typename RightSeq , typename Compare > MergeBy < LeftSeq , RightSeq , Compare > operator | ( LeftSeq && left , MergeByBinder < RightSeq , Compare > && binder ) function prepend \ud83d\udd17 1 2 3 4 template < typename Item > inline auto prepend ( Item && item ) function print_out \ud83d\udd17 1 2 3 4 inline auto print_out ( std :: ostream & out , std :: string_view sep = \" \" ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> inline auto operator | ( Seq && seq , PrintOut p ) function debug_out \ud83d\udd17 1 2 3 4 inline auto debug_out ( std :: ostream & out , std :: string_view sep = \" \" ) function printable \ud83d\udd17 1 inline PrintableBinder printable () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > inline auto operator | ( Seq && seq , PrintableBinder ) function reduce \ud83d\udd17 1 2 3 4 5 6 template < typename State , typename ReduceFn > ReduceBinder < State , ReduceFn > reduce ( State && state , ReduceFn && reduce_fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Seq , typename State , typename ReduceFn > State operator | ( Seq && seq , ReduceBinder < State , ReduceFn > binder ) function status_ok \ud83d\udd17 1 inline auto status_ok () function operator| \ud83d\udd17 1 2 3 4 5 template < typename SeqT > inline StatusOk < SeqT > operator | ( SeqT && seq , StatusOkBinder ) function take_n \ud83d\udd17 1 2 3 inline TakeNBinder take_n ( usize n ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> TakeN < Seq > operator | ( Seq && seq , const TakeNBinder & binder ) function take_while \ud83d\udd17 1 2 3 4 template < typename Predicate > TakeWhileBinder < Predicate > take_while ( Predicate && predicate ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Predicate > TakeWhile < Seq , Predicate > operator | ( Seq && seq , TakeWhileBinder < Predicate > && binder ) function collect \ud83d\udd17 1 2 3 4 template < typename T > inline Collect < T > collect ( StaticType < T > = {} ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename T > auto operator | ( Seq && seq , Collect < T > ) function decayed \ud83d\udd17 1 inline auto decayed () function kmerge_by \ud83d\udd17 1 2 3 4 template < typename Compare > KMergeByBinder < Compare > kmerge_by ( Compare && compare ) function kmerge \ud83d\udd17 1 inline auto kmerge () function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename KSeqs , typename Compare > KMergeBy < SeqItem < KSeqs > , Compare > operator | ( KSeqs && k_seqs , KMergeByBinder < Compare > && binder ) function map_pairwise \ud83d\udd17 1 2 3 4 5 6 template < typename RightSeq , typename MapFn > MapPairwiseBinder < RightSeq , MapFn > map_pairwise ( RightSeq && right , MapFn && map_fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename LeftSeq , typename RightSeq , typename MapFn > MapPairwise < LeftSeq , RightSeq , MapFn > operator | ( LeftSeq && left , MapPairwiseBinder < RightSeq , MapFn > && binder ) function last \ud83d\udd17 1 inline LastBinder last () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , LastBinder ) function inner_reduce \ud83d\udd17 1 2 3 4 template < typename ReduceFn > InnerReduceBinder < ReduceFn > inner_reduce ( ReduceFn && reduce_fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename ReduceFn > Optional < std :: decay_t < SeqItem < Seq > > > operator | ( Seq && seq , InnerReduceBinder < ReduceFn > binder ) function single_item \ud83d\udd17 1 2 3 4 template < typename T > SingleItem < T > single_item ( T && item ) function sum \ud83d\udd17 1 inline SumBinder sum () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , SumBinder ) function product \ud83d\udd17 1 inline ProductBinder product () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , ProductBinder ) function any_true \ud83d\udd17 1 inline AnyBinder any_true () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , AnyBinder ) function all_true \ud83d\udd17 1 inline AllBinder all_true () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , AllBinder ) function map_adjacent \ud83d\udd17 1 2 3 4 template < typename Fn > MapAdjacentBinder < Fn > map_adjacent ( Fn && fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Fn > MapAdjacent < Seq , Fn > operator | ( Seq && seq , MapAdjacentBinder < Fn > && binder ) function map_fold \ud83d\udd17 1 2 3 4 5 6 template < typename State , typename MapFn > MapFoldBinder < State , MapFn > map_fold ( State && state , MapFn && map_fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Seq , typename State , typename MapFn > MapFold < Seq , State , MapFn > operator | ( Seq && seq , MapFoldBinder < State , MapFn > && binder ) function rolling \ud83d\udd17 1 2 3 4 5 6 template < typename T , typename BinaryFn > inline RollingBinder < T , BinaryFn > rolling ( BinaryFn && binary_fn , T && initial = T {} ) function operator| \ud83d\udd17 1 2 3 4 5 6 7 template < typename Seq , typename T , typename BinaryFn > auto operator | ( Seq && seq , RollingBinder < T , BinaryFn > && binder ) function running_total \ud83d\udd17 1 inline RunningTotalBinder running_total () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , RunningTotalBinder ) function inspect \ud83d\udd17 1 2 3 4 template < typename Fn > auto inspect ( Fn && fn ) function splice \ud83d\udd17 1 2 3 4 5 template < typename InnerSeq > inline SpliceBinder < InnerSeq > splice ( std :: size_t n , InnerSeq && inner_seq ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename OuterSeq , typename InnerSeq > auto operator | ( OuterSeq && outer_seq , SpliceBinder < InnerSeq > && binder ) function is_sorted_by \ud83d\udd17 1 2 3 4 template < typename Compare > IsSortedBinder < Compare > is_sorted_by ( Compare && compare ) function is_sorted \ud83d\udd17 1 inline auto is_sorted () function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Compare > inline bool operator | ( Seq && seq , IsSortedBinder < Compare > && binder ) function inspect_adjacent \ud83d\udd17 1 2 3 4 template < typename Fn > InspectAdjacentBinder < Fn > inspect_adjacent ( Fn && fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename Fn > InspectAdjacent < Seq , Fn > operator | ( Seq && seq , InspectAdjacentBinder < Fn > && binder ) function apply \ud83d\udd17 1 2 3 4 template < typename SeqFn > inline ApplyBinder < SeqFn > apply ( SeqFn && seq_fn ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename SeqFn > inline decltype ( auto ) operator | ( Seq && seq , ApplyBinder < SeqFn > && binder ) function attach \ud83d\udd17 1 2 3 4 template < typename D > inline AttachBinder < D > attach ( D && data ) function operator| \ud83d\udd17 1 2 3 4 5 6 template < typename Seq , typename D > inline auto operator | ( Seq && seq , AttachBinder < D > && binder ) function fuse \ud83d\udd17 1 inline FuseBinder fuse () function operator| \ud83d\udd17 1 2 3 4 5 template < typename Seq > Fuse < Seq > operator | ( Seq && seq , FuseBinder ) Updated on 26 August 2022 at 17:30:03 UTC","title":"batt::seq"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#classes","text":"Name struct batt::seq::Addition struct batt::seq::AllBinder struct batt::seq::AnyBinder struct batt::seq::ApplyBinder class batt::seq::Attach struct batt::seq::AttachBinder struct batt::seq::BoxedBinder class batt::seq::CacheNext struct batt::seq::CacheNextBinder class batt::seq::Chain struct batt::seq::ChainBinder struct batt::seq::Collect struct batt::seq::CollectVec struct batt::seq::Consume struct batt::seq::CountBinder struct batt::seq::DecayItem struct batt::seq::Deref class batt::seq::Empty class batt::seq::Filter struct batt::seq::FilterBinder class batt::seq::FilterMap struct batt::seq::FilterMapBinder struct batt::seq::FirstBinder class batt::seq::Flatten struct batt::seq::FlattenBinder struct batt::seq::ForEachBinder class batt::seq::Fuse struct batt::seq::FuseBinder class batt::seq::GroupBy struct batt::seq::GroupByBinder struct batt::seq::InnerReduceBinder class batt::seq::InspectAdjacent struct batt::seq::InspectAdjacentBinder struct batt::seq::IsNotFalse struct batt::seq::IsSortedBinder class batt::seq::KMergeBy struct batt::seq::KMergeByBinder struct batt::seq::LastBinder class batt::seq::Lazy class batt::seq::Map class batt::seq::MapAdjacent struct batt::seq::MapAdjacentBinder struct batt::seq::MapBinder class batt::seq::MapFold struct batt::seq::MapFoldBinder class batt::seq::MapPairwise struct batt::seq::MapPairwiseBinder class batt::seq::MergeBy struct batt::seq::MergeByBinder struct batt::seq::NaturalEquals struct batt::seq::NaturalOrder struct batt::seq::PrependBinder class batt::seq::Printable struct batt::seq::PrintableBinder struct batt::seq::PrintOut struct batt::seq::ProductBinder struct batt::seq::ReduceBinder struct batt::seq::Reverse struct batt::seq::RollingBinder struct batt::seq::RunningTotalBinder class batt::seq::SingleItem class batt::seq::Splice struct batt::seq::SpliceBinder class batt::seq::StatusOk struct batt::seq::StatusOkBinder struct batt::seq::SumBinder class batt::seq::TakeN struct batt::seq::TakeNBinder class batt::seq::TakeWhile struct batt::seq::TakeWhileBinder struct batt::seq::WriteToBinder","title":"Classes"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#types","text":"Name enum LoopControl { kContinue = 0, kBreak = 1}","title":"Types"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#functions","text":"Name template <typename AsyncWriteStream > auto write_to (AsyncWriteStream && dst) BoxedBinder boxed () template <typename Seq ,typename =EnableIfSeq ,typename Item =typename std::conditional_t (), SeqItem_Impl\\ , StaticType\\ >::type> BoxedSeq < Item > **[operator CacheNextBinder cache_next () template <typename Seq > auto **[operator template <typename Seq2 > ChainBinder < Seq2 > chain (Seq2 && seq2) template <typename Seq1 ,typename Seq2 > Chain < Seq1, Seq2 > **[operator CollectVec collect_vec () template <typename Seq ,typename =EnableIfSeq > auto **[operator auto consume () template <typename Seq ,typename =EnableIfSeq > void **[operator CountBinder count () template <typename Seq > BATT_MAYBE_UNUSED usize **[operator auto deref () template <typename Container > auto emplace_back (Container * dst) template <typename Predicate > FilterBinder < Predicate > filter (Predicate && predicate) template <typename Seq ,typename Predicate > Filter < Seq, Predicate > **[operator template <typename Seq ,typename Fn > auto filter_map_impl (Seq && seq, Fn && fn) template <typename Fn > FilterMapBinder < Fn > filter_map (Fn && fn) template <typename Seq ,typename Fn > FilterMap < Seq, Fn > **[operator FirstBinder first () template <typename Seq > auto **[operator FlattenBinder flatten () template <typename OuterSeq > Flatten < OuterSeq > **[operator template <typename Fn > ForEachBinder < Fn > for_each (Fn && fn) template <typename Seq ,typename Fn ,typename =EnableIfSeq > LoopControl **[operator template <typename GroupEq > GroupByBinder < GroupEq > group_by (GroupEq && group_eq) template <typename Seq ,typename GroupEq > GroupBy < Seq, GroupEq > **[operator template <typename Fn > auto lazy (Fn && fn) template <typename Fn ,typename... Args,typename =std::enable_if_t , LoopControl>>> LoopControl run_loop_fn (Fn && fn, Args &&... args) template <typename Fn ,typename... Args,typename =std::enable_if_t<!std::is_convertible_v , LoopControl>>,typename =void> LoopControl run_loop_fn (Fn && fn, Args &&... args) template <typename MapFn > MapBinder < MapFn > map (MapFn && map_fn) template <typename Seq ,typename MapFn > Map < Seq, MapFn > **[operator template <typename Compare ,typename RightSeq > MergeByBinder < RightSeq, Compare > merge_by (Compare && compare, RightSeq && right) template <typename RightSeq > auto merge (RightSeq && right) template <typename LeftSeq ,typename RightSeq ,typename Compare > MergeBy < LeftSeq, RightSeq, Compare > **[operator template <typename Item > auto prepend (Item && item) auto print_out (std::ostream & out, std::string_view sep =\" \") template <typename Seq ,typename =EnableIfSeq > auto **[operator auto debug_out (std::ostream & out, std::string_view sep =\" \") PrintableBinder printable () template <typename Seq > auto **[operator template <typename State ,typename ReduceFn > ReduceBinder < State, ReduceFn > reduce (State && state, ReduceFn && reduce_fn) template <typename Seq ,typename State ,typename ReduceFn > State **[operator auto status_ok () template <typename SeqT > StatusOk < SeqT > **[operator TakeNBinder take_n (usize n) template <typename Seq ,typename =EnableIfSeq > TakeN < Seq > **[operator template <typename Predicate > TakeWhileBinder < Predicate > take_while (Predicate && predicate) template <typename Seq ,typename Predicate > TakeWhile < Seq, Predicate > **[operator template <typename T > Collect < T > collect ( StaticType < T > ={}) template <typename Seq ,typename T > auto **[operator auto decayed () template <typename Compare > KMergeByBinder < Compare > kmerge_by (Compare && compare) auto kmerge () template <typename KSeqs ,typename Compare > KMergeBy < SeqItem< KSeqs >, Compare > **[operator template <typename RightSeq ,typename MapFn > MapPairwiseBinder < RightSeq, MapFn > map_pairwise (RightSeq && right, MapFn && map_fn) template <typename LeftSeq ,typename RightSeq ,typename MapFn > MapPairwise < LeftSeq, RightSeq, MapFn > **[operator LastBinder last () template <typename Seq > auto **[operator template <typename ReduceFn > InnerReduceBinder < ReduceFn > inner_reduce (ReduceFn && reduce_fn) template <typename Seq ,typename ReduceFn > Optional < std::decay_t< SeqItem< Seq > > > **[operator template <typename T > SingleItem < T > single_item (T && item) SumBinder sum () template <typename Seq > auto **[operator ProductBinder product () template <typename Seq > auto **[operator AnyBinder any_true () template <typename Seq > auto **[operator AllBinder all_true () template <typename Seq > auto **[operator template <typename Fn > MapAdjacentBinder < Fn > map_adjacent (Fn && fn) template <typename Seq ,typename Fn > MapAdjacent < Seq, Fn > **[operator template <typename State ,typename MapFn > MapFoldBinder < State, MapFn > map_fold (State && state, MapFn && map_fn) template <typename Seq ,typename State ,typename MapFn > MapFold < Seq, State, MapFn > **[operator template <typename T ,typename BinaryFn > RollingBinder < T, BinaryFn > rolling (BinaryFn && binary_fn, T && initial =T{}) template <typename Seq ,typename T ,typename BinaryFn > auto **[operator RunningTotalBinder running_total () template <typename Seq > auto **[operator template <typename Fn > auto inspect (Fn && fn) template <typename InnerSeq > SpliceBinder < InnerSeq > splice (std::size_t n, InnerSeq && inner_seq) template <typename OuterSeq ,typename InnerSeq > auto **[operator template <typename Compare > IsSortedBinder < Compare > is_sorted_by (Compare && compare) auto is_sorted () template <typename Seq ,typename Compare > bool **[operator template <typename Fn > InspectAdjacentBinder < Fn > inspect_adjacent (Fn && fn) template <typename Seq ,typename Fn > InspectAdjacent < Seq, Fn > **[operator template <typename SeqFn > ApplyBinder < SeqFn > apply (SeqFn && seq_fn) template <typename Seq ,typename SeqFn > decltype(auto) **[operator template <typename D > AttachBinder < D > attach (D && data) template <typename Seq ,typename D > auto **[operator FuseBinder fuse () template <typename Seq > Fuse < Seq > **[operator","title":"Functions"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#types-documentation","text":"","title":"Types Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#enum-loopcontrol","text":"Enumerator Value Description kContinue 0 kBreak 1","title":"enum LoopControl"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-write_to","text":"1 2 3 4 template < typename AsyncWriteStream > inline auto write_to ( AsyncWriteStream && dst )","title":"function write_to"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-boxed","text":"1 inline BoxedBinder boxed ()","title":"function boxed"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator","text":"1 2 3 4 5 6 7 template < typename Seq , typename = EnableIfSeq < Seq > , typename Item = typename std :: conditional_t < has_seq_requirements < Seq > (), SeqItem_Impl < Seq > , StaticType < void >>:: type > inline BoxedSeq < Item > operator | ( Seq && seq , BoxedBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-cache_next","text":"1 inline CacheNextBinder cache_next ()","title":"function cache_next"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_1","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , CacheNextBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-chain","text":"1 2 3 4 template < typename Seq2 > ChainBinder < Seq2 > chain ( Seq2 && seq2 )","title":"function chain"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_2","text":"1 2 3 4 5 6 template < typename Seq1 , typename Seq2 > Chain < Seq1 , Seq2 > operator | ( Seq1 && seq1 , ChainBinder < Seq2 > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-collect_vec","text":"1 inline CollectVec collect_vec ()","title":"function collect_vec"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_3","text":"1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> auto operator | ( Seq && seq , CollectVec )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-consume","text":"1 inline auto consume ()","title":"function consume"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_4","text":"1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> void operator | ( Seq && seq , Consume && )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-count","text":"1 inline CountBinder count ()","title":"function count"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_5","text":"1 2 3 4 5 template < typename Seq > BATT_MAYBE_UNUSED usize operator | ( Seq && seq , CountBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-deref","text":"1 inline auto deref ()","title":"function deref"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-emplace_back","text":"1 2 3 4 template < typename Container > inline auto emplace_back ( Container * dst )","title":"function emplace_back"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-filter","text":"1 2 3 4 template < typename Predicate > FilterBinder < Predicate > filter ( Predicate && predicate )","title":"function filter"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_6","text":"1 2 3 4 5 6 template < typename Seq , typename Predicate > Filter < Seq , Predicate > operator | ( Seq && seq , FilterBinder < Predicate > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-filter_map_impl","text":"1 2 3 4 5 6 template < typename Seq , typename Fn > auto filter_map_impl ( Seq && seq , Fn && fn )","title":"function filter_map_impl"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-filter_map","text":"1 2 3 4 template < typename Fn > FilterMapBinder < Fn > filter_map ( Fn && fn )","title":"function filter_map"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_7","text":"1 2 3 4 5 6 template < typename Seq , typename Fn > FilterMap < Seq , Fn > operator | ( Seq && seq , FilterMapBinder < Fn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-first","text":"1 inline FirstBinder first ()","title":"function first"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_8","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , FirstBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-flatten","text":"1 inline FlattenBinder flatten ()","title":"function flatten"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_9","text":"1 2 3 4 5 template < typename OuterSeq > Flatten < OuterSeq > operator | ( OuterSeq && seq , FlattenBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-for_each","text":"1 2 3 4 template < typename Fn > ForEachBinder < Fn > for_each ( Fn && fn )","title":"function for_each"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_10","text":"1 2 3 4 5 6 7 template < typename Seq , typename Fn , typename = EnableIfSeq < Seq >> LoopControl operator | ( Seq && seq , ForEachBinder < Fn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-group_by","text":"1 2 3 4 template < typename GroupEq > GroupByBinder < GroupEq > group_by ( GroupEq && group_eq )","title":"function group_by"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_11","text":"1 2 3 4 5 6 template < typename Seq , typename GroupEq > GroupBy < Seq , GroupEq > operator | ( Seq && seq , GroupByBinder < GroupEq > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-lazy","text":"1 2 3 4 template < typename Fn > auto lazy ( Fn && fn )","title":"function lazy"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-run_loop_fn","text":"1 2 3 4 5 6 7 template < typename Fn , typename ... Args , typename = std :: enable_if_t < std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >>> LoopControl run_loop_fn ( Fn && fn , Args && ... args )","title":"function run_loop_fn"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-run_loop_fn_1","text":"1 2 3 4 5 6 7 8 template < typename Fn , typename ... Args , typename = std :: enable_if_t <! std :: is_convertible_v < std :: invoke_result_t < Fn && , Args && ... > , LoopControl >> , typename = void > LoopControl run_loop_fn ( Fn && fn , Args && ... args )","title":"function run_loop_fn"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map","text":"1 2 3 4 template < typename MapFn > MapBinder < MapFn > map ( MapFn && map_fn )","title":"function map"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_12","text":"1 2 3 4 5 6 template < typename Seq , typename MapFn > Map < Seq , MapFn > operator | ( Seq && seq , MapBinder < MapFn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-merge_by","text":"1 2 3 4 5 6 template < typename Compare , typename RightSeq > MergeByBinder < RightSeq , Compare > merge_by ( Compare && compare , RightSeq && right )","title":"function merge_by"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-merge","text":"1 2 3 4 template < typename RightSeq > auto merge ( RightSeq && right )","title":"function merge"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_13","text":"1 2 3 4 5 6 7 template < typename LeftSeq , typename RightSeq , typename Compare > MergeBy < LeftSeq , RightSeq , Compare > operator | ( LeftSeq && left , MergeByBinder < RightSeq , Compare > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-prepend","text":"1 2 3 4 template < typename Item > inline auto prepend ( Item && item )","title":"function prepend"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-print_out","text":"1 2 3 4 inline auto print_out ( std :: ostream & out , std :: string_view sep = \" \" )","title":"function print_out"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_14","text":"1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> inline auto operator | ( Seq && seq , PrintOut p )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-debug_out","text":"1 2 3 4 inline auto debug_out ( std :: ostream & out , std :: string_view sep = \" \" )","title":"function debug_out"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-printable","text":"1 inline PrintableBinder printable ()","title":"function printable"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_15","text":"1 2 3 4 5 template < typename Seq > inline auto operator | ( Seq && seq , PrintableBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-reduce","text":"1 2 3 4 5 6 template < typename State , typename ReduceFn > ReduceBinder < State , ReduceFn > reduce ( State && state , ReduceFn && reduce_fn )","title":"function reduce"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_16","text":"1 2 3 4 5 6 7 template < typename Seq , typename State , typename ReduceFn > State operator | ( Seq && seq , ReduceBinder < State , ReduceFn > binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-status_ok","text":"1 inline auto status_ok ()","title":"function status_ok"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_17","text":"1 2 3 4 5 template < typename SeqT > inline StatusOk < SeqT > operator | ( SeqT && seq , StatusOkBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-take_n","text":"1 2 3 inline TakeNBinder take_n ( usize n )","title":"function take_n"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_18","text":"1 2 3 4 5 6 template < typename Seq , typename = EnableIfSeq < Seq >> TakeN < Seq > operator | ( Seq && seq , const TakeNBinder & binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-take_while","text":"1 2 3 4 template < typename Predicate > TakeWhileBinder < Predicate > take_while ( Predicate && predicate )","title":"function take_while"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_19","text":"1 2 3 4 5 6 template < typename Seq , typename Predicate > TakeWhile < Seq , Predicate > operator | ( Seq && seq , TakeWhileBinder < Predicate > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-collect","text":"1 2 3 4 template < typename T > inline Collect < T > collect ( StaticType < T > = {} )","title":"function collect"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_20","text":"1 2 3 4 5 6 template < typename Seq , typename T > auto operator | ( Seq && seq , Collect < T > )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-decayed","text":"1 inline auto decayed ()","title":"function decayed"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-kmerge_by","text":"1 2 3 4 template < typename Compare > KMergeByBinder < Compare > kmerge_by ( Compare && compare )","title":"function kmerge_by"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-kmerge","text":"1 inline auto kmerge ()","title":"function kmerge"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_21","text":"1 2 3 4 5 6 template < typename KSeqs , typename Compare > KMergeBy < SeqItem < KSeqs > , Compare > operator | ( KSeqs && k_seqs , KMergeByBinder < Compare > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map_pairwise","text":"1 2 3 4 5 6 template < typename RightSeq , typename MapFn > MapPairwiseBinder < RightSeq , MapFn > map_pairwise ( RightSeq && right , MapFn && map_fn )","title":"function map_pairwise"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_22","text":"1 2 3 4 5 6 7 template < typename LeftSeq , typename RightSeq , typename MapFn > MapPairwise < LeftSeq , RightSeq , MapFn > operator | ( LeftSeq && left , MapPairwiseBinder < RightSeq , MapFn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-last","text":"1 inline LastBinder last ()","title":"function last"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_23","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , LastBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-inner_reduce","text":"1 2 3 4 template < typename ReduceFn > InnerReduceBinder < ReduceFn > inner_reduce ( ReduceFn && reduce_fn )","title":"function inner_reduce"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_24","text":"1 2 3 4 5 6 template < typename Seq , typename ReduceFn > Optional < std :: decay_t < SeqItem < Seq > > > operator | ( Seq && seq , InnerReduceBinder < ReduceFn > binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-single_item","text":"1 2 3 4 template < typename T > SingleItem < T > single_item ( T && item )","title":"function single_item"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-sum","text":"1 inline SumBinder sum ()","title":"function sum"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_25","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , SumBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-product","text":"1 inline ProductBinder product ()","title":"function product"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_26","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , ProductBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-any_true","text":"1 inline AnyBinder any_true ()","title":"function any_true"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_27","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , AnyBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-all_true","text":"1 inline AllBinder all_true ()","title":"function all_true"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_28","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , AllBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map_adjacent","text":"1 2 3 4 template < typename Fn > MapAdjacentBinder < Fn > map_adjacent ( Fn && fn )","title":"function map_adjacent"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_29","text":"1 2 3 4 5 6 template < typename Seq , typename Fn > MapAdjacent < Seq , Fn > operator | ( Seq && seq , MapAdjacentBinder < Fn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map_fold","text":"1 2 3 4 5 6 template < typename State , typename MapFn > MapFoldBinder < State , MapFn > map_fold ( State && state , MapFn && map_fn )","title":"function map_fold"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_30","text":"1 2 3 4 5 6 7 template < typename Seq , typename State , typename MapFn > MapFold < Seq , State , MapFn > operator | ( Seq && seq , MapFoldBinder < State , MapFn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-rolling","text":"1 2 3 4 5 6 template < typename T , typename BinaryFn > inline RollingBinder < T , BinaryFn > rolling ( BinaryFn && binary_fn , T && initial = T {} )","title":"function rolling"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_31","text":"1 2 3 4 5 6 7 template < typename Seq , typename T , typename BinaryFn > auto operator | ( Seq && seq , RollingBinder < T , BinaryFn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-running_total","text":"1 inline RunningTotalBinder running_total ()","title":"function running_total"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_32","text":"1 2 3 4 5 template < typename Seq > auto operator | ( Seq && seq , RunningTotalBinder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-inspect","text":"1 2 3 4 template < typename Fn > auto inspect ( Fn && fn )","title":"function inspect"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-splice","text":"1 2 3 4 5 template < typename InnerSeq > inline SpliceBinder < InnerSeq > splice ( std :: size_t n , InnerSeq && inner_seq )","title":"function splice"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_33","text":"1 2 3 4 5 6 template < typename OuterSeq , typename InnerSeq > auto operator | ( OuterSeq && outer_seq , SpliceBinder < InnerSeq > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-is_sorted_by","text":"1 2 3 4 template < typename Compare > IsSortedBinder < Compare > is_sorted_by ( Compare && compare )","title":"function is_sorted_by"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-is_sorted","text":"1 inline auto is_sorted ()","title":"function is_sorted"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_34","text":"1 2 3 4 5 6 template < typename Seq , typename Compare > inline bool operator | ( Seq && seq , IsSortedBinder < Compare > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-inspect_adjacent","text":"1 2 3 4 template < typename Fn > InspectAdjacentBinder < Fn > inspect_adjacent ( Fn && fn )","title":"function inspect_adjacent"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_35","text":"1 2 3 4 5 6 template < typename Seq , typename Fn > InspectAdjacent < Seq , Fn > operator | ( Seq && seq , InspectAdjacentBinder < Fn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-apply","text":"1 2 3 4 template < typename SeqFn > inline ApplyBinder < SeqFn > apply ( SeqFn && seq_fn )","title":"function apply"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_36","text":"1 2 3 4 5 6 template < typename Seq , typename SeqFn > inline decltype ( auto ) operator | ( Seq && seq , ApplyBinder < SeqFn > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-attach","text":"1 2 3 4 template < typename D > inline AttachBinder < D > attach ( D && data )","title":"function attach"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_37","text":"1 2 3 4 5 6 template < typename Seq , typename D > inline auto operator | ( Seq && seq , AttachBinder < D > && binder )","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-fuse","text":"1 inline FuseBinder fuse ()","title":"function fuse"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_38","text":"1 2 3 4 5 template < typename Seq > Fuse < Seq > operator | ( Seq && seq , FuseBinder ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator|"},{"location":"_autogen/Namespaces/namespacebatteries/","text":"batteries \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"batteries"},{"location":"_autogen/Namespaces/namespacepico__http/","text":"pico_http \ud83d\udd17 Namespaces \ud83d\udd17 Name pico_http::detail Classes \ud83d\udd17 Name struct pico_http::ChunkedDecoder struct pico_http::DecodeResult struct pico_http::MessageHeader struct pico_http::Request struct pico_http::Response Functions \ud83d\udd17 Name std::ostream & operator<< (std::ostream & out, const MessageHeader & t) std::ostream & operator<< (std::ostream & out, const batt::SmallVecBase< MessageHeader > & t) std::ostream & operator<< (std::ostream & out, const Request & t) std::ostream & operator<< (std::ostream & out, const Response & t) int parse_headers (const char * buf, usize len, batt::SmallVecBase< MessageHeader > * headers, usize last_len =0) batt::StatusOr < DecodeResult > decode_chunked ( ChunkedDecoder * decoder, const batt::ConstBuffer & input, batt::SmallVecBase< batt::ConstBuffer > * output) int decode_chunked_is_in_data ( ChunkedDecoder * decoder) Attributes \ud83d\udd17 Name constexpr usize kDefaultNumHeaders constexpr int kParseOk constexpr int kParseFailed constexpr int kParseIncomplete Functions Documentation \ud83d\udd17 function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const MessageHeader & t ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const batt :: SmallVecBase < MessageHeader > & t ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Request & t ) function operator<< \ud83d\udd17 1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Response & t ) function parse_headers \ud83d\udd17 1 2 3 4 5 6 int parse_headers ( const char * buf , usize len , batt :: SmallVecBase < MessageHeader > * headers , usize last_len = 0 ) function decode_chunked \ud83d\udd17 1 2 3 4 5 inline batt :: StatusOr < DecodeResult > decode_chunked ( ChunkedDecoder * decoder , const batt :: ConstBuffer & input , batt :: SmallVecBase < batt :: ConstBuffer > * output ) function decode_chunked_is_in_data \ud83d\udd17 1 2 3 inline int decode_chunked_is_in_data ( ChunkedDecoder * decoder ) Attributes Documentation \ud83d\udd17 variable kDefaultNumHeaders \ud83d\udd17 1 constexpr usize kDefaultNumHeaders = 16 ; variable kParseOk \ud83d\udd17 1 constexpr int kParseOk = 0 ; variable kParseFailed \ud83d\udd17 1 constexpr int kParseFailed = -1 ; variable kParseIncomplete \ud83d\udd17 1 constexpr int kParseIncomplete = -2 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http"},{"location":"_autogen/Namespaces/namespacepico__http/#namespaces","text":"Name pico_http::detail","title":"Namespaces"},{"location":"_autogen/Namespaces/namespacepico__http/#classes","text":"Name struct pico_http::ChunkedDecoder struct pico_http::DecodeResult struct pico_http::MessageHeader struct pico_http::Request struct pico_http::Response","title":"Classes"},{"location":"_autogen/Namespaces/namespacepico__http/#functions","text":"Name std::ostream & operator<< (std::ostream & out, const MessageHeader & t) std::ostream & operator<< (std::ostream & out, const batt::SmallVecBase< MessageHeader > & t) std::ostream & operator<< (std::ostream & out, const Request & t) std::ostream & operator<< (std::ostream & out, const Response & t) int parse_headers (const char * buf, usize len, batt::SmallVecBase< MessageHeader > * headers, usize last_len =0) batt::StatusOr < DecodeResult > decode_chunked ( ChunkedDecoder * decoder, const batt::ConstBuffer & input, batt::SmallVecBase< batt::ConstBuffer > * output) int decode_chunked_is_in_data ( ChunkedDecoder * decoder)","title":"Functions"},{"location":"_autogen/Namespaces/namespacepico__http/#attributes","text":"Name constexpr usize kDefaultNumHeaders constexpr int kParseOk constexpr int kParseFailed constexpr int kParseIncomplete","title":"Attributes"},{"location":"_autogen/Namespaces/namespacepico__http/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const MessageHeader & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator_1","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const batt :: SmallVecBase < MessageHeader > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator_2","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Request & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator_3","text":"1 2 3 4 inline std :: ostream & operator << ( std :: ostream & out , const Response & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacepico__http/#function-parse_headers","text":"1 2 3 4 5 6 int parse_headers ( const char * buf , usize len , batt :: SmallVecBase < MessageHeader > * headers , usize last_len = 0 )","title":"function parse_headers"},{"location":"_autogen/Namespaces/namespacepico__http/#function-decode_chunked","text":"1 2 3 4 5 inline batt :: StatusOr < DecodeResult > decode_chunked ( ChunkedDecoder * decoder , const batt :: ConstBuffer & input , batt :: SmallVecBase < batt :: ConstBuffer > * output )","title":"function decode_chunked"},{"location":"_autogen/Namespaces/namespacepico__http/#function-decode_chunked_is_in_data","text":"1 2 3 inline int decode_chunked_is_in_data ( ChunkedDecoder * decoder )","title":"function decode_chunked_is_in_data"},{"location":"_autogen/Namespaces/namespacepico__http/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kdefaultnumheaders","text":"1 constexpr usize kDefaultNumHeaders = 16 ;","title":"variable kDefaultNumHeaders"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kparseok","text":"1 constexpr int kParseOk = 0 ;","title":"variable kParseOk"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kparsefailed","text":"1 constexpr int kParseFailed = -1 ;","title":"variable kParseFailed"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kparseincomplete","text":"1 constexpr int kParseIncomplete = -2 ; Updated on 26 August 2022 at 17:30:03 UTC","title":"variable kParseIncomplete"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail/","text":"pico_http::detail \ud83d\udd17 Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::detail"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d107/","text":"pico_http::detail::@107 \ud83d\udd17 Types \ud83d\udd17 Name enum @0 { } Types Documentation \ud83d\udd17 enum @0 \ud83d\udd17 Enumerator Value Description Updated on 26 August 2022 at 17:30:03 UTC","title":"pico_http::detail::@107"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d107/#types","text":"Name enum @0 { }","title":"Types"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d107/#types-documentation","text":"","title":"Types Documentation"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d107/#enum-0","text":"Enumerator Value Description Updated on 26 August 2022 at 17:30:03 UTC","title":"enum @0"},{"location":"_autogen/Namespaces/namespacestd/","text":"std \ud83d\udd17 Functions \ud83d\udd17 Name template <typename T > ostream & operator<< (ostream & out, const optional< T > & t) template <typename Fn ,typename =enable_if_t<::batt::IsCallable {}>> ostream & operator<< (ostream & out, Fn && fn) Functions Documentation \ud83d\udd17 function operator<< \ud83d\udd17 1 2 3 4 5 template < typename T > inline ostream & operator << ( ostream & out , const optional < T > & t ) function operator<< \ud83d\udd17 1 2 3 4 5 6 template < typename Fn , typename = enable_if_t <:: batt :: IsCallable < Fn , ostream &> {} >> inline ostream & operator << ( ostream & out , Fn && fn ) Updated on 26 August 2022 at 17:30:03 UTC","title":"std"},{"location":"_autogen/Namespaces/namespacestd/#functions","text":"Name template <typename T > ostream & operator<< (ostream & out, const optional< T > & t) template <typename Fn ,typename =enable_if_t<::batt::IsCallable {}>> ostream & operator<< (ostream & out, Fn && fn)","title":"Functions"},{"location":"_autogen/Namespaces/namespacestd/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"_autogen/Namespaces/namespacestd/#function-operator","text":"1 2 3 4 5 template < typename T > inline ostream & operator << ( ostream & out , const optional < T > & t )","title":"function operator&lt;&lt;"},{"location":"_autogen/Namespaces/namespacestd/#function-operator_1","text":"1 2 3 4 5 6 template < typename Fn , typename = enable_if_t <:: batt :: IsCallable < Fn , ostream &> {} >> inline ostream & operator << ( ostream & out , Fn && fn ) Updated on 26 August 2022 at 17:30:03 UTC","title":"function operator&lt;&lt;"},{"location":"_autogen/Pages/","text":"Pages \ud83d\udd17 page NOTICE Updated on 26 August 2022 at 17:30:03 UTC","title":"Pages"},{"location":"_autogen/Pages/md_batteries_pico_http_README/","text":"NOTICE \ud83d\udd17 The contents of this directory were copied and modified from the Pico HTTP Parser project under the terms of the MIT License. The original copyright notice is preserved in the source files, and also quoted here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase, * Shigeo Mitsunari * * The software is licensed under either the MIT License (below) or the Perl * license. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to * deal in the Software without restriction, including without limitation the * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or * sell copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS * IN THE SOFTWARE. */ DO NOT remove this notice from the files in this directory! The Pico HTTP Parser and H2O projects are amazing and awesome; you should definitely support the authors and the project!!! Updated on 26 August 2022 at 17:30:03 UTC","title":"NOTICE"},{"location":"how-to/configure-ci-pipelines/","text":"How to Configure CI Pipelines for Batteries in GitLab \ud83d\udd17 [[ TOC ]] Create a Deploy Token for the Repository \ud83d\udd17 This step is necessary to allow Conan to access the Package Registry for your project so releases can be published. Navigate to your repo on GitLab. Go to Settings > Repository > Deploy Tokens Enter the following: Name: gitlab-deploy-token Expiration date (optional): Username (optional): For the \"Scopes\" section, click the checkbox next to write_package_registry (this is the only required capability). NOTE: The name \"gitlab-deploy-token\" MUST be entered exactly as shown; this is a special magic token name that GitLab uses to infer that the token should be injected via environment variables to CI/CD pipelines. Click \"Create deploy token.\" You can save the token value if you want, but you don't have to; it will be automatically injected into your pipeline jobs from now on. Set CI/CD Variables \ud83d\udd17 This step is necessary to tell Conan where to push released packages, and under what username and channel. NOTE: The instructions for this step assume that any Conan remote you are going to use have been configured in docker/Dockerfile . For example: 1 2 3 4 5 6 7 ... # Point at various release package repos. # RUN conan remote add gitlab https://gitlab.com/api/v4/packages/conan ... Navigate to your repo on GitLab. Go to Settings > CI/CD > Variables > Expand You must create three variables: RELEASE_CONAN_USER : The user under which to release packages; this should be the name of your repo on GitLab, with '+' substituted for '/'. For example, if your project lives at https://gitlab.com/janedoe/batteries_fork , the Conan user should be janedoe+batteries_fork RELEASE_CONAN_CHANNEL : The channel under which to release packages (for example, \"stable\", \"unstable\", or \"testing\") RELEASE_CONAN_REMOTE : The Conan remote name for the package registry to which releases should be published When you publish a release (e.g., 1.7.3), the Conan \"recipe name\" will be batteries/1.7.3@$RELEASE_CONAN_USER/$RELEASE_CONAN_CHANNEL . For each variable, leave the Type as \"Variable\" and the Environment scope as \"All (default)\". Under \"Flags\", \"Protect variable\" and \"Mask variable\" should both be unchecked . Build the Pipeline Docker Image and Upload to GitLab \ud83d\udd17 Clone a local repo: 1 git clone https://gitlab.com/tonyastolfi/batteries Enter the local repo directory: 1 cd batteries/ Build the docker image: 1 make docker-build Create an Access Token to login to the GitLab Docker Container Registry: Go to (Your Profile Picture in the upper-right corner) > Edit profile (in the drop-down) > Access Tokens (in the left-sidebar) Enter a token name and expiration date (can be anything) Select scope \"api\" Click \"Create personal access token\" IMPORTANT: Write down the access token value (or copy-paste it somewhere) Otherwise you will need to do these steps over again! (first time only) Log in to the GitLab Container Registry using the access token you just created (you can retrieve the correct command for your GitLab instance by going to (your repo) > Packages & Registries > Container Registry and clicking the CLI Commands drop down button in the upper-right): 1 docker login registry.gitlab.com Upload the container image you built in step 3: 1 make docker-push If you want to check to see if this succeeded, you can go to (your repo) > Packages & Registries > Container Registry to see a list of the containers that have been added to your registry. Configure GitLab Runners \ud83d\udd17 NOTE: This step is optional if your GitLab instance already has CI Runners configured in the scope of your project. You can check whether this is the case by navigating to (your repo) > Settings > CI/CD > Runners > Expand. Install GitLab Runner on your hardware \ud83d\udd17 GNU/Linux (x86_64) \ud83d\udd17 Download \ud83d\udd17 Follow the instructions at Linux Manual Install option (Linux x86-64) to download the gitlab-runner binary: 1 sudo curl -L --output /usr/local/bin/gitlab-runner \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64\" Make runnable \ud83d\udd17 1 sudo chmod +x /usr/local/bin/gitlab-runner Create gitlab-runner user \ud83d\udd17 You can put the home directory for this user wherever you want; it was convenient for my setup to place it under /local/home . 1 mkdir -p /local/home/ && sudo useradd gitlab-runner --comment 'GitLab Runner' --home /local/home/gitlab-runner --create-home --shell /bin/bash \"Install\" the runner \ud83d\udd17 1 sudo gitlab-runner install --user = gitlab-runner --working-directory = /local/home/gitlab-runner Start the runner \ud83d\udd17 1 sudo gitlab-runner start Register the runner with GitLab \ud83d\udd17 Go to (your repo) > Settings > CI/CD > Runners > Expand. Under the column \"Specific runners,\" copy the registration token string. On the machine where you installed gitlab-runner: 1 sudo gitlab-runner register This will prompt you for various pieces of information. Paste the registration token string you copied above when prompted. NOTE: When asked for executor type, choose docker . When it asks you about the default Docker image, enter registry.gitlab.com/tonyastolfi/batteries . Do not enter any tags/labels when prompted. If this step is successful, you will see your runner show up on the Settings > CI/CD > Runners page in GitLab.","title":"How to Configure CI Pipelines for Batteries in GitLab"},{"location":"how-to/configure-ci-pipelines/#create-a-deploy-token-for-the-repository","text":"This step is necessary to allow Conan to access the Package Registry for your project so releases can be published. Navigate to your repo on GitLab. Go to Settings > Repository > Deploy Tokens Enter the following: Name: gitlab-deploy-token Expiration date (optional): Username (optional): For the \"Scopes\" section, click the checkbox next to write_package_registry (this is the only required capability). NOTE: The name \"gitlab-deploy-token\" MUST be entered exactly as shown; this is a special magic token name that GitLab uses to infer that the token should be injected via environment variables to CI/CD pipelines. Click \"Create deploy token.\" You can save the token value if you want, but you don't have to; it will be automatically injected into your pipeline jobs from now on.","title":"Create a Deploy Token for the Repository"},{"location":"how-to/configure-ci-pipelines/#set-cicd-variables","text":"This step is necessary to tell Conan where to push released packages, and under what username and channel. NOTE: The instructions for this step assume that any Conan remote you are going to use have been configured in docker/Dockerfile . For example: 1 2 3 4 5 6 7 ... # Point at various release package repos. # RUN conan remote add gitlab https://gitlab.com/api/v4/packages/conan ... Navigate to your repo on GitLab. Go to Settings > CI/CD > Variables > Expand You must create three variables: RELEASE_CONAN_USER : The user under which to release packages; this should be the name of your repo on GitLab, with '+' substituted for '/'. For example, if your project lives at https://gitlab.com/janedoe/batteries_fork , the Conan user should be janedoe+batteries_fork RELEASE_CONAN_CHANNEL : The channel under which to release packages (for example, \"stable\", \"unstable\", or \"testing\") RELEASE_CONAN_REMOTE : The Conan remote name for the package registry to which releases should be published When you publish a release (e.g., 1.7.3), the Conan \"recipe name\" will be batteries/1.7.3@$RELEASE_CONAN_USER/$RELEASE_CONAN_CHANNEL . For each variable, leave the Type as \"Variable\" and the Environment scope as \"All (default)\". Under \"Flags\", \"Protect variable\" and \"Mask variable\" should both be unchecked .","title":"Set CI/CD Variables"},{"location":"how-to/configure-ci-pipelines/#build-the-pipeline-docker-image-and-upload-to-gitlab","text":"Clone a local repo: 1 git clone https://gitlab.com/tonyastolfi/batteries Enter the local repo directory: 1 cd batteries/ Build the docker image: 1 make docker-build Create an Access Token to login to the GitLab Docker Container Registry: Go to (Your Profile Picture in the upper-right corner) > Edit profile (in the drop-down) > Access Tokens (in the left-sidebar) Enter a token name and expiration date (can be anything) Select scope \"api\" Click \"Create personal access token\" IMPORTANT: Write down the access token value (or copy-paste it somewhere) Otherwise you will need to do these steps over again! (first time only) Log in to the GitLab Container Registry using the access token you just created (you can retrieve the correct command for your GitLab instance by going to (your repo) > Packages & Registries > Container Registry and clicking the CLI Commands drop down button in the upper-right): 1 docker login registry.gitlab.com Upload the container image you built in step 3: 1 make docker-push If you want to check to see if this succeeded, you can go to (your repo) > Packages & Registries > Container Registry to see a list of the containers that have been added to your registry.","title":"Build the Pipeline Docker Image and Upload to GitLab"},{"location":"how-to/configure-ci-pipelines/#configure-gitlab-runners","text":"NOTE: This step is optional if your GitLab instance already has CI Runners configured in the scope of your project. You can check whether this is the case by navigating to (your repo) > Settings > CI/CD > Runners > Expand.","title":"Configure GitLab Runners"},{"location":"how-to/configure-ci-pipelines/#install-gitlab-runner-on-your-hardware","text":"","title":"Install GitLab Runner on your hardware"},{"location":"how-to/configure-ci-pipelines/#gnulinux-x86_64","text":"","title":"GNU/Linux (x86_64)"}]}