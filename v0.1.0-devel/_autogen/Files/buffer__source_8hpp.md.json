{
  "abstract": false,
  "anchor": "#file-buffer-source.hpp",
  "category": "files",
  "const": false,
  "defines": [
    {
      "abstract": false,
      "anchor": "#define-batteries-async-buffer-source-hpp",
      "category": "defines",
      "const": false,
      "definition": "",
      "explicit": false,
      "fullname": "BATTERIES_ASYNC_BUFFER_SOURCE_HPP",
      "hasDetails": false,
      "inline": false,
      "kind": "define",
      "language": "cpp",
      "location": {
        "bodyFile": "batteries/async/buffer_source.hpp",
        "bodyStart": 6,
        "column": 9,
        "file": "batteries/async/buffer_source.hpp",
        "line": 6
      },
      "name": "BATTERIES_ASYNC_BUFFER_SOURCE_HPP",
      "override": false,
      "refid": "buffer__source_8hpp_1a898c2d9c49152482575abd95e4c19a4d",
      "static": false,
      "strong": false,
      "title": "BATTERIES_ASYNC_BUFFER_SOURCE_HPP",
      "url": "/_autogen/Files/buffer__source_8hpp/#define-batteries-async-buffer-source-hpp",
      "visibility": "public"
    }
  ],
  "definition": "",
  "explicit": false,
  "fullname": "batteries/async/buffer_source.hpp",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "includes": "<batteries/config.hpp>",
  "inline": false,
  "kind": "file",
  "language": "cpp",
  "location": {
    "column": 0,
    "file": "batteries/async/buffer_source.hpp",
    "line": 0
  },
  "name": "batteries/async/buffer_source.hpp",
  "namespaces": [
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt",
      "refid": "namespacebatt",
      "title": "batt",
      "url": "/_autogen/Namespaces/namespacebatt/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt::detail",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt::detail",
      "refid": "namespacebatt_1_1detail",
      "title": "batt::detail",
      "url": "/_autogen/Namespaces/namespacebatt_1_1detail/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt::seq",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt::seq",
      "refid": "namespacebatt_1_1seq",
      "title": "batt::seq",
      "url": "/_autogen/Namespaces/namespacebatt_1_1seq/",
      "visibility": "public"
    }
  ],
  "override": false,
  "parent": {
    "anchor": "#dir-batteries/async",
    "category": "dirs",
    "fullname": "batteries/async",
    "kind": "dir",
    "language": "",
    "name": "batteries/async",
    "refid": "dir_faaa2176564b41e79cedcf3028f42662",
    "title": "batteries/async",
    "url": "/_autogen/Files/dir_faaa2176564b41e79cedcf3028f42662/#dir-batteries/async",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "#dir-batteries",
      "category": "dirs",
      "fullname": "batteries",
      "kind": "dir",
      "language": "",
      "name": "batteries",
      "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
      "title": "batteries",
      "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
      "visibility": "public"
    },
    {
      "anchor": "#dir-batteries/async",
      "category": "dirs",
      "fullname": "batteries/async",
      "kind": "dir",
      "language": "",
      "name": "batteries/async",
      "refid": "dir_faaa2176564b41e79cedcf3028f42662",
      "title": "batteries/async",
      "url": "/_autogen/Files/dir_faaa2176564b41e79cedcf3028f42662/#dir-batteries/async",
      "visibility": "public"
    }
  ],
  "programlisting": "//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BUFFER_SOURCE_HPP\n#define BATTERIES_ASYNC_BUFFER_SOURCE_HPP\n\n#include <batteries/config.hpp>\n//\n#include <batteries/async/io_result.hpp>\n#include <batteries/async/task_decl.hpp>\n\n#include <batteries/seq/collect_vec.hpp>\n#include <batteries/seq/consume.hpp>\n#include <batteries/seq/for_each.hpp>\n#include <batteries/seq/prepend.hpp>\n#include <batteries/seq/print_out.hpp>\n#include <batteries/seq/skip_n.hpp>\n#include <batteries/seq/take_n.hpp>\n\n#include <batteries/buffer.hpp>\n#include <batteries/checked_cast.hpp>\n#include <batteries/cpu_align.hpp>\n#include <batteries/int_types.hpp>\n#include <batteries/small_vec.hpp>\n#include <batteries/status.hpp>\n#include <batteries/type_erasure.hpp>\n#include <batteries/utility.hpp>\n\n#include <boost/asio/buffer.hpp>\n\nnamespace batt {\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nnamespace detail {\n\ntemplate <typename T>\ninline std::false_type has_const_buffer_sequence_requirements_impl(...)\n{\n    return {};\n}\n\ntemplate <typename T,\n          typename ElementT = decltype(*boost::asio::buffer_sequence_begin(std::declval<T>())),  //\n          typename = std::enable_if_t<                                                           //\n              std::is_same_v<decltype(boost::asio::buffer_sequence_begin(std::declval<T>())),    //\n                             decltype(boost::asio::buffer_sequence_end(std::declval<T>()))> &&   //\n              std::is_convertible_v<ElementT, boost::asio::const_buffer>>>\ninline std::true_type has_const_buffer_sequence_requirements_impl(std::decay_t<T>*)\n{\n    return {};\n}\n\n}  // namespace detail\n   //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n\ntemplate <typename T>\nusing HasConstBufferSequenceRequirements =\n    decltype(detail::has_const_buffer_sequence_requirements_impl<T>(nullptr));\n\ntemplate <typename T>\ninline constexpr bool has_const_buffer_sequence_requirements(StaticType<T> = {})\n{\n    return HasConstBufferSequenceRequirements<T>{};\n}\n\ntemplate <typename T>\nusing EnableIfConstBufferSequence = std::enable_if_t<has_const_buffer_sequence_requirements<T>()>;\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nnamespace detail {\n\ntemplate <typename T>\ninline std::false_type has_buffer_source_requirements_impl(...)\n{\n    return {};\n}\n\ntemplate <typename T,\n          typename = std::enable_if_t<                                                           //\n              std::is_same_v<decltype(std::declval<T>().size()), usize> &&                       //\n              std::is_same_v<decltype(std::declval<T>().consume(std::declval<i64>())), void> &&  //\n              std::is_same_v<decltype(std::declval<T>().close_for_read()), void> &&\n              HasConstBufferSequenceRequirements<\n                  decltype(*(std::declval<T>().fetch_at_least(std::declval<i64>())))>{}>>\ninline std::true_type has_buffer_source_requirements_impl(std::decay_t<T>*)\n{\n    return {};\n}\n\n}  // namespace detail\n   //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n\ntemplate <typename T>\nusing HasBufferSourceRequirements = decltype(detail::has_buffer_source_requirements_impl<T>(nullptr));\n\ntemplate <typename T>\ninline constexpr bool has_buffer_source_requirements(StaticType<T> = {})\n{\n    return HasBufferSourceRequirements<T>{};\n}\n\ntemplate <typename T>\nusing EnableIfBufferSource = std::enable_if_t<has_buffer_source_requirements<T>()>;\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nclass SingleBufferSource\n{\n   public:\n    SingleBufferSource() = default;\n\n    SingleBufferSource(const SingleBufferSource&) = default;\n\n    SingleBufferSource& operator=(const SingleBufferSource&) = default;\n\n    explicit SingleBufferSource(const ConstBuffer& buffer) noexcept : buffer_{buffer}\n    {\n    }\n\n    explicit SingleBufferSource(const void* ptr, usize size) noexcept : buffer_{ptr, size}\n    {\n    }\n\n    explicit SingleBufferSource(const std::string_view& str) noexcept : buffer_{str.data(), str.size()}\n    {\n    }\n\n    SingleBufferSource& operator=(const ConstBuffer& buffer) noexcept\n    {\n        this->buffer_ = buffer;\n        return *this;\n    }\n\n    SingleBufferSource& operator=(const std::string_view& str) noexcept\n    {\n        this->buffer_ = ConstBuffer{str.data(), str.size()};\n        return *this;\n    }\n\n    usize size() const\n    {\n        return this->buffer_.size();\n    }\n\n    StatusOr<SmallVec<ConstBuffer, 1>> fetch_at_least(i64 min_count)\n    {\n        if (min_count > static_cast<i64>(this->buffer_.size())) {\n            return {StatusCode::kEndOfStream};\n        }\n        if (this->buffer_.size() == 0u) {\n            return {SmallVec<ConstBuffer, 1>{}};\n        }\n        return {{this->buffer_}};\n    }\n\n    void consume(i64 count)\n    {\n        BATT_CHECK_GE(count, 0);\n        this->buffer_ += count;\n    }\n\n    void close_for_read()\n    {\n        this->buffer_ = {};\n    }\n\n   private:\n    ConstBuffer buffer_;\n};\n\nstatic_assert(has_buffer_source_requirements<SingleBufferSource>());\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// A type-erased no-copy input stream.\n//\n// Instead of a traditional (copying) input stream, which copies data into caller-supplied buffers,\n// BufferSource provides the `fetch_at_least` operation, which returns one or more pre-populated data buffers\n// owned by the BufferSource.  The caller is guaranteed that these buffers remain valid until the next\n// non-const member function is invoked on the BufferSource.\n//\n// To make dealing with byte streams easier, BufferSource values can be modified/transformed via a select\n// subset of `batt::seq` operators:\n//\n// - seq::take_n(byte_count)\n// - seq::skip_n(byte_count)\n// - seq::prepend(const_buffer_sequence)\n// - seq::for_each(fn) (fn takes ConstBuffer)\n// - seq::collect_vec() => std::vector<char>\n// - seq::print_out(std::ostream)\n// - seq::consume()\n//\n// In addition, a new operator is defined for BufferSource, seq::write_to(AsyncWriteStream):\n//\n// ```c++\n// batt::BufferSource data_to_send;\n// boost::asio::ip::tcp::socket dst_stream;\n//\n// // Write all the data to the stream.\n// //\n// StatusOr<usize> result = data_to_send | batt::seq::write_to(dst_stream);\n// ```\n//\nclass BufferSource\n{\n   public:\n    BufferSource() = default;\n\n    template <typename T, typename = EnableIfNoShadow<BufferSource, T&&>,\n              typename = EnableIfBufferSource<UnwrapRefType<T>>,\n              typename = std::enable_if_t<std::is_same_v<std::decay_t<T>, T>>>\n    /*implicit*/ BufferSource(T&& obj) noexcept;\n\n    explicit BufferSource(const ConstBuffer& buffer) noexcept : BufferSource{SingleBufferSource{buffer}}\n    {\n    }\n\n    explicit BufferSource(const void* ptr, usize size) noexcept : BufferSource{SingleBufferSource{ptr, size}}\n    {\n    }\n\n    explicit BufferSource(const std::string_view& str) noexcept : BufferSource{SingleBufferSource{str}}\n    {\n    }\n\n    // Returns true iff this object contains a valid BufferSource impl.\n    //\n    explicit operator bool() const;\n\n    // Release the type-erased impl object; post-condition: `bool{*this} == false`.\n    //\n    void clear();\n\n    // The current number of bytes available as consumable data.  This should be used as an optimization hint\n    // only; the next call to `fetch_*` may return more bytes than the last returned value of size.\n    // Specifically, callers should not count on `size()` returning 0 being an indication that the next call\n    // to `fetch_at_least` will block.\n    //\n    usize size() const;\n\n    // Returns a ConstBufferSequence containing at least `min_count` bytes of data.\n    //\n    // This method may block the current task if there isn't enough data available to satisfy\n    // the request (i.e., if `this->size() < min_count`).\n    //\n    StatusOr<SmallVec<ConstBuffer, 2>> fetch_at_least(i64 min_count);\n\n    // Consume the specified number of bytes from the front of the stream so that future calls to\n    // `fetch_at_least` will not return the same data.\n    //\n    void consume(i64 count);\n\n    // Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods).  This\n    // signals to the buffer (and all other clients of this object) that no more data will be read/consumed.\n    //\n    void close_for_read();\n\n   private:\n    class AbstractBufferSource;\n\n    template <typename T>\n    class BufferSourceImpl;\n\n    //+++++++++++-+-+--+----- --- -- -  -  -   -\n\n    TypeErasedStorage<AbstractBufferSource, BufferSourceImpl> impl_;\n};\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Adapts a Seq of Item = ConstBuffer to a BufferSource impl, allowing it to be wrapped via the BufferSource\n// class.\n//\ntemplate <typename Seq>\nclass SeqBufferSource\n{\n   public:\n    using Item = ConstBuffer;\n\n    static_assert(std::is_convertible_v<SeqItem<Seq>, ConstBuffer>, \"\");\n\n    usize size() const\n    {\n        return boost::asio::buffer_size(this->active_buffers_);\n    }\n\n    StatusOr<SmallVec<ConstBuffer, 2>> fetch_at_least(i64 min_count)\n    {\n        usize active_size = boost::asio::buffer_size(this->active_buffers_);\n\n        while (active_size < min_count) {\n            Optional<ConstBuffer> next_buffer = this->seq_.next();\n            if (next_buffer == None) {\n                return {StatusCode::kEndOfStream};\n            }\n\n            active_size += next_buffer->size();\n            this->active_buffers_.emplace_back(std::move(*next_buffer));\n        }\n\n        return this->active_buffers_;\n    }\n\n    void consume(i64 count)\n    {\n        consume_buffers(this->active_buffers_, count);\n    }\n\n    void close_for_read()\n    {\n        while (this->seq_.next()) {\n            continue;\n        }\n\n        this->active_buffers_.clear();\n    }\n\n   private:\n    Seq seq_;\n    SmallVec<ConstBuffer, 2> active_buffers_;\n};\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::take_n(byte_count)\n//\ntemplate <typename Src>\nclass TakeNSource\n{\n   public:\n    explicit TakeNSource(Src&& src, usize limit) noexcept : limit_{limit}, src_{BATT_FORWARD(src)}\n    {\n    }\n\n    usize size() const\n    {\n        return std::min(this->limit_, this->src_.size());\n    }\n\n    StatusOr<SmallVec<ConstBuffer, 2>> fetch_at_least(i64 min_count)\n    {\n        BATT_ASSERT_GE(min_count, 0);\n\n        // If we will be limited to an amount of data that is smaller than the requested minimum, just return\n        // end-of-stream.\n        //\n        if (this->limit_ < static_cast<usize>(min_count)) {\n            return {StatusCode::kEndOfStream};\n        }\n\n        StatusOr<SmallVec<ConstBuffer, 2>> buffers = this->src_.fetch_at_least(min_count);\n        BATT_REQUIRE_OK(buffers);\n\n        usize n_fetched = boost::asio::buffer_size(*buffers);\n\n        // Trim data from the end of the fetched range until we are under our limit.\n        //\n        while (n_fetched > this->limit_ && !buffers->empty()) {\n            ConstBuffer& last_buffer = buffers->back();\n            const usize extra_bytes = n_fetched - this->limit_;\n\n            if (last_buffer.size() <= extra_bytes) {\n                n_fetched -= last_buffer.size();\n                buffers->pop_back();\n            } else {\n                n_fetched -= extra_bytes;\n                last_buffer = ConstBuffer{last_buffer.data(), last_buffer.size() - extra_bytes};\n            }\n        }\n\n        return buffers;\n    }\n\n    void consume(i64 count)\n    {\n        const usize n_to_consume = std::min(BATT_CHECKED_CAST(usize, count), this->limit_);\n        this->src_.consume(BATT_CHECKED_CAST(usize, n_to_consume));\n        this->limit_ -= n_to_consume;\n    }\n\n    void close_for_read()\n    {\n        this->limit_ = 0;\n    }\n\n   private:\n    usize limit_;\n    Src src_;\n};\n\ntemplate <typename Src, typename = EnableIfBufferSource<Src>>\nTakeNSource<Src> operator|(Src&& src, seq::TakeNBinder binder)\n{\n    return TakeNSource<Src>{BATT_FORWARD(src), binder.n};\n}\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::skip_n(byte_count)\n//\ntemplate <typename Src, typename = EnableIfBufferSource<Src>>\nvoid operator|(Src&& /*src*/, SkipNBinder /*binder*/)\n{\n    // TODO [tastolfi 2022-03-23]\n    BATT_PANIC() << \"TODO [tastolfi 2022-03-28] implement me!\";\n}\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::filter(StatusOr<ConstBufferSequence>(ConstBufferSequence))\n//\ntemplate <typename Src, typename MapFn>\nclass FilterBufferSource\n{\n   public:\n    // TODO [tastolfi 2022-06-22]\n   private:\n};\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::map(void(BufferSource& src, BufferSink& dst))\n//\ntemplate <typename Src, typename MapFn>\nclass MapBufferSource\n{\n   public:\n    // TODO [tastolfi 2022-06-22]\n   private:\n};\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::for_each()\n//\ntemplate <typename Src, typename Fn, typename = EnableIfBufferSource<Src>>\ninline StatusOr<seq::LoopControl> operator|(Src&& src, seq::ForEachBinder<Fn>&& binder)\n{\n    for (;;) {\n        auto fetched = src.fetch_at_least(1);\n        if (fetched.status() == StatusCode::kEndOfStream) {\n            break;\n        }\n        BATT_REQUIRE_OK(fetched);\n\n        usize n_to_consume = 0;\n        for (const ConstBuffer& buffer : *fetched) {\n            n_to_consume += buffer.size();\n            if (BATT_HINT_FALSE(seq::run_loop_fn(binder.fn, buffer) == seq::kBreak)) {\n                return seq::kBreak;\n            }\n        }\n        if (n_to_consume == 0) {\n            break;\n        }\n\n        src.consume(n_to_consume);\n    }\n\n    return seq::kContinue;\n}\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::collect_vec()\n//\ntemplate <typename Src, typename = EnableIfBufferSource<Src>>\ninline StatusOr<std::vector<char>> operator|(Src&& src, seq::CollectVec)\n{\n    std::vector<char> bytes;\n\n    StatusOr<seq::LoopControl> result =\n        BATT_FORWARD(src) | seq::for_each([&bytes](const ConstBuffer& buffer) {\n            const char* data_begin = static_cast<const char*>(buffer.data());\n            const char* data_end = data_begin + buffer.size();\n            bytes.insert(bytes.end(), data_begin, data_end);\n        });\n\n    BATT_REQUIRE_OK(result);\n\n    return bytes;\n}\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::print_out(out)\n//\ntemplate <typename Src, typename = EnableIfBufferSource<Src>>\ninline Status operator|(Src&& src, seq::PrintOut p)\n{\n    return (BATT_FORWARD(src) | seq::for_each([&](const ConstBuffer& buffer) {\n                p.out.write(static_cast<const char*>(buffer.data()), buffer.size());\n            }))\n        .status();\n}\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::consume()\n\ntemplate <typename Src, typename = EnableIfBufferSource<Src>>\ninline Status operator|(Src&& src, seq::Consume)\n{\n    StatusOr<seq::LoopControl> result = BATT_FORWARD(src) | seq::for_each([](auto&&...) noexcept {\n                                            // nom, nom, nom...\n                                        });\n    BATT_REQUIRE_OK(result);\n    BATT_CHECK_EQ(*result, seq::kContinue);\n\n    return OkStatus();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nnamespace seq {\n\ntemplate <typename AsyncWriteStream>\nstruct WriteToBinder {\n    AsyncWriteStream dst;\n};\n\ntemplate <typename AsyncWriteStream>\ninline auto write_to(AsyncWriteStream&& dst)\n{\n    return WriteToBinder<AsyncWriteStream>{BATT_FORWARD(dst)};\n}\n\n}  // namespace seq\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::write_to(async_write_stream)\n//\ntemplate <typename Src, typename AsyncWriteStream, typename = EnableIfBufferSource<Src>>\nStatusOr<usize> operator|(Src&& src, seq::WriteToBinder<AsyncWriteStream>&& binder)\n{\n    usize bytes_transferred = 0;\n\n    for (;;) {\n        auto fetched = src.fetch_at_least(1);\n        if (fetched.status() == StatusCode::kEndOfStream) {\n            break;\n        }\n        BATT_REQUIRE_OK(fetched);\n\n        IOResult<usize> bytes_written = Task::await_write_some(binder.dst, *fetched);\n        BATT_REQUIRE_OK(bytes_written);\n\n        bytes_transferred += *bytes_written;\n        src.consume(*bytes_written);\n    }\n\n    return bytes_transferred;\n}\n\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::prepend(buffers)\n//\n\ntemplate <typename Src, typename ConstBufferSequence>\nclass PrependBufferSource\n{\n   public:\n    using BufferIter =\n        std::decay_t<decltype(boost::asio::buffer_sequence_begin(std::declval<ConstBufferSequence>()))>;\n\n    explicit PrependBufferSource(ConstBufferSequence&& buffers, Src&& rest) noexcept\n        : first_{BATT_FORWARD(buffers)}\n        , first_buffer_index_{0}\n        , first_buffer_offset_{0}\n        , first_bytes_remaining_{boost::asio::buffer_size(this->first_)}\n        , rest_{BATT_FORWARD(rest)}\n    {\n        static_assert(std::is_same_v<std::decay_t<ConstBufferSequence>, ConstBufferSequence>,\n                      \"PrependBufferSource may not capture ConstBufferSequence reference types!\");\n    }\n\n    usize size() const\n    {\n        return this->first_bytes_remaining_ + this->rest_.size();\n    }\n\n    StatusOr<SmallVec<ConstBuffer, 3>> fetch_at_least(i64 min_count_i)\n    {\n        const usize min_count_z = BATT_CHECKED_CAST(usize, min_count_i);\n        SmallVec<ConstBuffer, 3> buffer;\n\n        if (this->first_bytes_remaining_ > 0) {\n            const auto first_begin = boost::asio::buffer_sequence_begin(this->first_);\n            const auto first_end = boost::asio::buffer_sequence_end(this->first_);\n            const auto first_iter = std::next(first_begin, this->first_buffer_index_);\n\n            BATT_CHECK_NE(first_iter, first_end)\n                << \"If bytes_remaining > 0, then the unread buffer sequence should be non-empty\";\n\n            buffer.insert(buffer.end(), first_iter, first_end);\n\n            BATT_CHECK(!buffer.empty());\n\n            buffer.front() += this->first_buffer_offset_;\n        }\n\n        const usize rest_min_count = min_count_z - std::min(this->first_bytes_remaining_, min_count_z);\n        auto fetched_from_rest = this->rest_.fetch_at_least(rest_min_count);\n        if (buffer.empty() || fetched_from_rest.status() != StatusCode::kEndOfStream) {\n            BATT_REQUIRE_OK(fetched_from_rest);\n        }\n\n        if (fetched_from_rest.ok()) {\n            buffer.insert(buffer.end(),  //\n                          boost::asio::buffer_sequence_begin(*fetched_from_rest),\n                          boost::asio::buffer_sequence_end(*fetched_from_rest));\n        }\n\n        return buffer;\n    }\n\n    void consume(i64 count_i)\n    {\n        const usize count_z = BATT_CHECKED_CAST(usize, count_i);\n        const usize consume_from_first = std::min(this->first_bytes_remaining_, count_z);\n        const usize consume_from_rest = count_z - consume_from_first;\n\n        const auto first_begin = boost::asio::buffer_sequence_begin(this->first_);\n        const auto first_end = boost::asio::buffer_sequence_end(this->first_);\n        auto first_iter = std::next(first_begin, this->first_buffer_index_);\n\n        std::tie(first_iter, this->first_buffer_offset_) = consume_buffers_iter(\n            std::make_pair(first_iter, this->first_buffer_offset_), first_end, consume_from_first);\n        this->first_buffer_index_ = std::distance(first_begin, first_iter);\n        this->first_bytes_remaining_ -= consume_from_first;\n\n        if (consume_from_rest > 0) {\n            this->rest_.consume(consume_from_rest);\n        }\n    }\n\n    void close_for_read()\n    {\n        this->first_buffer_index_ = std::distance(boost::asio::buffer_sequence_begin(this->first_),\n                                                  boost::asio::buffer_sequence_end(this->first_));\n        this->first_buffer_offset_ = 0;\n        this->first_bytes_remaining_ = 0;\n\n        this->rest_.close_for_read();\n    }\n\n   private:\n    ConstBufferSequence first_;\n\n    // How far into the buffer sequence `first_` is the first unread data?\n    //\n    usize first_buffer_index_;\n\n    // How far within the current buffer the first unread data?\n    //\n    usize first_buffer_offset_;\n\n    // How much data in `first` has not yet been consumed?\n    //\n    usize first_bytes_remaining_;\n\n    // What follows `first_`.\n    //\n    Src rest_;\n};\n\ntemplate <typename Src, typename ConstBufferSequence,  //\n          typename = EnableIfBufferSource<Src>,        //\n          typename = EnableIfConstBufferSequence<ConstBufferSequence>>\ninline auto operator|(Src&& src, seq::PrependBinder<ConstBufferSequence>&& binder)\n{\n    return PrependBufferSource<Src, ConstBufferSequence>{BATT_FORWARD(binder.item), BATT_FORWARD(src)};\n}\n\n}  // namespace batt\n\n#endif  // BATTERIES_ASYNC_BUFFER_SOURCE_HPP\n\n#include <batteries/config.hpp>\n\n#if BATT_HEADER_ONLY\n#include <batteries/async/buffer_source_impl.hpp>\n#endif  // BATT_HEADER_ONLY",
  "publicClasses": [
    {
      "anchor": "",
      "brief": "Adapts a single ConstBuffer to be a [BufferSource](). ",
      "category": "classes",
      "fullname": "batt::SingleBufferSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::SingleBufferSource",
      "refid": "classbatt_1_1SingleBufferSource",
      "summary": "Adapts a single ConstBuffer to be a BufferSource. ",
      "title": "batt::SingleBufferSource",
      "url": "/_autogen/Classes/classbatt_1_1SingleBufferSource/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::BufferSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::BufferSource",
      "refid": "classbatt_1_1BufferSource",
      "title": "batt::BufferSource",
      "url": "/_autogen/Classes/classbatt_1_1BufferSource/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::SeqBufferSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::SeqBufferSource",
      "refid": "classbatt_1_1SeqBufferSource",
      "title": "batt::SeqBufferSource",
      "url": "/_autogen/Classes/classbatt_1_1SeqBufferSource/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::TakeNSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::TakeNSource",
      "refid": "classbatt_1_1TakeNSource",
      "title": "batt::TakeNSource",
      "url": "/_autogen/Classes/classbatt_1_1TakeNSource/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::FilterBufferSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::FilterBufferSource",
      "refid": "classbatt_1_1FilterBufferSource",
      "title": "batt::FilterBufferSource",
      "url": "/_autogen/Classes/classbatt_1_1FilterBufferSource/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::MapBufferSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::MapBufferSource",
      "refid": "classbatt_1_1MapBufferSource",
      "title": "batt::MapBufferSource",
      "url": "/_autogen/Classes/classbatt_1_1MapBufferSource/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::WriteToBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::WriteToBinder",
      "refid": "structbatt_1_1seq_1_1WriteToBinder",
      "title": "batt::seq::WriteToBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::PrependBufferSource",
      "kind": "class",
      "language": "cpp",
      "name": "batt::PrependBufferSource",
      "refid": "classbatt_1_1PrependBufferSource",
      "title": "batt::PrependBufferSource",
      "url": "/_autogen/Classes/classbatt_1_1PrependBufferSource/",
      "visibility": "public"
    }
  ],
  "refid": "buffer__source_8hpp",
  "static": false,
  "strong": false,
  "title": "batteries/async/buffer_source.hpp",
  "url": "/_autogen/Files/buffer__source_8hpp/#file-buffer-source.hpp",
  "visibility": "public"
}