{
  "abstract": false,
  "anchor": "#file-http-client-connection-impl.hpp",
  "category": "files",
  "const": false,
  "defines": [
    {
      "abstract": false,
      "anchor": "#define-batteries-http-http-client-connection-impl-hpp",
      "category": "defines",
      "const": false,
      "definition": "",
      "explicit": false,
      "fullname": "BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP",
      "hasDetails": false,
      "inline": false,
      "kind": "define",
      "language": "cpp",
      "location": {
        "bodyFile": "batteries/http/http_client_connection_impl.hpp",
        "bodyStart": 6,
        "column": 9,
        "file": "batteries/http/http_client_connection_impl.hpp",
        "line": 6
      },
      "name": "BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP",
      "override": false,
      "refid": "http__client__connection__impl_8hpp_1a4081232166f66d35216dab0602525a96",
      "static": false,
      "strong": false,
      "title": "BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP",
      "url": "/_autogen/Files/http__client__connection__impl_8hpp/#define-batteries-http-http-client-connection-impl-hpp",
      "visibility": "public"
    }
  ],
  "definition": "",
  "explicit": false,
  "fullname": "batteries/http/http_client_connection_impl.hpp",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "includes": "<batteries/config.hpp>",
  "inline": false,
  "kind": "file",
  "language": "cpp",
  "location": {
    "column": 0,
    "file": "batteries/http/http_client_connection_impl.hpp",
    "line": 0
  },
  "name": "batteries/http/http_client_connection_impl.hpp",
  "namespaces": [
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt",
      "refid": "namespacebatt",
      "title": "batt",
      "url": "/_autogen/Namespaces/namespacebatt/",
      "visibility": "public"
    }
  ],
  "override": false,
  "parent": {
    "anchor": "#dir-batteries/http",
    "category": "dirs",
    "fullname": "batteries/http",
    "kind": "dir",
    "language": "",
    "name": "batteries/http",
    "refid": "dir_9b7f6a4fee6d4e32025f5ad2daa53829",
    "title": "batteries/http",
    "url": "/_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/#dir-batteries/http",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "#dir-batteries",
      "category": "dirs",
      "fullname": "batteries",
      "kind": "dir",
      "language": "",
      "name": "batteries",
      "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
      "title": "batteries",
      "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
      "visibility": "public"
    },
    {
      "anchor": "#dir-batteries/http",
      "category": "dirs",
      "fullname": "batteries/http",
      "kind": "dir",
      "language": "",
      "name": "batteries/http",
      "refid": "dir_9b7f6a4fee6d4e32025f5ad2daa53829",
      "title": "batteries/http",
      "url": "/_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/#dir-batteries/http",
      "visibility": "public"
    }
  ],
  "programlisting": "//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP\n\n#include <batteries/config.hpp>\n//\n#include <batteries/http/http_chunk_decoder.hpp>\n#include <batteries/http/http_client_connection_decl.hpp>\n#include <batteries/http/http_client_host_context_decl.hpp>\n\n#include <chrono>\n\nnamespace batt {\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ void HttpClientConnection::spawn(HttpClientHostContext& context,\n                                                             Watch<usize>& active_connections) noexcept\n{\n    active_connections.fetch_add(1);\n\n    Task::spawn(\n        context.get_io_context().get_executor(),\n        [&context, &active_connections] {\n            auto on_scope_exit = batt::finally([&active_connections] {\n                active_connections.fetch_sub(1);\n            });\n\n            {\n                HttpClientConnection connection{context};\n                connection.run();\n            }\n            //\n            // Important: this nested scope is here to emphasize that the HttpClientConnection object should\n            // be completely destroyed before decrementing `active_connections`.\n        },\n        /*name=*/\"HttpClientConnection::parent_task\");\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpClientConnection::HttpClientConnection(\n    HttpClientHostContext& context) noexcept\n    : context_{context}\n    , idle_connection_timeout_ms_{this->context_.get_connection_timeout_ms()}\n    , socket_{this->context_.get_io_context()}\n    , idle_timer_{this->context_.get_io_context()}\n{\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL boost::asio::io_context& HttpClientConnection::get_io_context()\n{\n    return this->context_.get_io_context();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr<boost::asio::ip::tcp::endpoint> HttpClientConnection::local_endpoint()\n    const noexcept\n{\n    boost::system::error_code ec;\n    auto ep = this->socket_.local_endpoint(ec);\n    BATT_REQUIRE_OK(ec);\n    return ep;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr<boost::asio::ip::tcp::endpoint> HttpClientConnection::remote_endpoint()\n    const noexcept\n{\n    boost::system::error_code ec;\n    auto ep = this->socket_.remote_endpoint(ec);\n    BATT_REQUIRE_OK(ec);\n    return ep;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientConnection::run()\n{\n    BATT_DEBUG_INFO(BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint()));\n\n    auto executor = Task::current().get_executor();\n\n    Task process_requests_task{executor,\n                               [this] {\n                                   BATT_DEBUG_INFO(BATT_INSPECT(this->local_endpoint())\n                                                   << BATT_INSPECT(this->remote_endpoint()));\n\n                                   this->process_requests().IgnoreError();\n                               },\n                               \"HttpClientConnection::process_requests\"};\n\n    Task process_responses_task{executor,\n                                [this] {\n                                    BATT_DEBUG_INFO(BATT_INSPECT(this->local_endpoint())\n                                                    << BATT_INSPECT(this->remote_endpoint()));\n\n                                    this->process_responses().IgnoreError();\n                                },\n                                \"HttpClientConnection::process_responses\"};\n\n    Task idle_connection_timeout_task{executor,\n                                      [this] {\n                                          BATT_DEBUG_INFO(BATT_INSPECT(this->local_endpoint())\n                                                          << BATT_INSPECT(this->remote_endpoint()));\n\n                                          this->idle_connection_timeout_task_main();\n                                      },\n                                      \"HttpClientConnection::idle_connection_timeout_task\"};\n\n    idle_connection_timeout_task.join();\n    process_requests_task.join();\n    process_responses_task.join();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpClientConnection::open_connection()\n{\n    StatusOr<SmallVec<boost::asio::ip::tcp::endpoint>> hosts =\n        await_resolve(this->get_io_context(), this->context_.host_address());\n    BATT_REQUIRE_OK(hosts);\n\n    for (const boost::asio::ip::tcp::endpoint& endpoint : *hosts) {\n        ErrorCode ec = Task::await_connect(this->socket_, endpoint);\n        if (!ec) {\n            return OkStatus();\n        }\n    }\n\n    return StatusCode::kUnavailable;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientConnection::halt() noexcept\n{\n    this->response_count_.close();\n\n    if (this->socket_.is_open()) {\n        boost::system::error_code ec;\n        this->socket_.close(ec);\n    }\n\n    this->input_buffer_.close_for_read();\n    this->input_buffer_.close_for_write();\n\n    this->response_queue_.close();\n\n    this->idle_timer_.cancel();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpClientConnection::process_requests()\n{\n    Optional<Task> fill_input_buffer_task;\n\n    auto on_exit = finally([this, &fill_input_buffer_task] {\n        BATT_VLOG(1) << \"HttpClientConnection::process_requests() exiting\"\n                     << BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint());\n\n        boost::system::error_code ec;\n        this->socket_.shutdown(boost::asio::socket_base::shutdown_send, ec);\n\n        this->response_queue_.close();\n        this->activity_.close();\n        this->idle_timer_.cancel();\n\n        if (fill_input_buffer_task) {\n            fill_input_buffer_task->join();\n        }\n    });\n\n    bool connected = false;\n    usize request_count = 0;\n\n    // We keep looping until we encounter an error or the socket is closed.\n    //\n    for (;;) {\n        {\n            // Wait for any outstanding responses to be consumed before deciding whether we can continue.\n            //  Note: this does mean that we are not supporting request pipelining, which definitely makes\n            //  it simpler to deal with scenarios where requests *are* pipelined but the server responds\n            //  by closing the connection before we read their responses.\n            //\n            BATT_DEBUG_INFO(\"process_requests() waiting for response to be processed\"\n                            << BATT_INSPECT(request_count)\n                            << BATT_INSPECT(this->response_count_.get_value()));\n\n            BATT_REQUIRE_OK(this->response_count_.await_equal(request_count));\n        }\n\n        // If the response task closed the connection, exit the loop.\n        //\n        if (connected && !this->socket_.is_open()) {\n            break;\n        }\n\n        // These are read from the host context's queue (on a FIFO, MPMC basis).  The Pin forces the\n        // referred objects from going out of scope while this function (or some other part of the\n        // connection) is still using them.  IMPORTANT: this means if the Pins aren't released, it may\n        // block some part of the application that submitted the request or is waiting for a response.\n        //\n        Pin<HttpRequest> request;\n        Pin<HttpResponse> response;\n\n        BATT_VLOG(1) << \"HttpClientConnection::process_requests() waiting for next request\";\n\n        auto queue_result = this->context_.await_next_request();\n        if (queue_result.status() == StatusCode::kPoke) {\n            continue;\n        }\n        BATT_ASSIGN_OK_RESULT(std::tie(request, response), std::move(queue_result));\n\n        this->activity_.fetch_add(1);\n\n        BATT_VLOG(1) << \"HttpClientConnection::process_requests() got request/response pair\"\n                     << BATT_INSPECT(connected);\n\n        request_count += 1;\n\n        BATT_CHECK_NOT_NULLPTR(request);\n        BATT_CHECK_NOT_NULLPTR(response);\n        BATT_CHECK_EQ(request->state().get_value(), HttpRequest::kInitialized);\n\n        if (!connected) {\n            Status status = this->open_connection();\n            if (!status.ok()) {\n                request->update_status(status);\n                request->state().close();\n            }\n            BATT_REQUIRE_OK(status);\n            connected = true;\n            this->activity_.fetch_add(1);\n\n            fill_input_buffer_task.emplace(\n                Task::current().get_executor(),\n                [this] {\n                    BATT_DEBUG_INFO(BATT_INSPECT(this->local_endpoint())\n                                    << BATT_INSPECT(this->remote_endpoint()));\n                    this->fill_input_buffer().IgnoreError();\n                },\n                \"HttpClientConnection::fill_input_buffer_task\");\n        }\n\n        // Hand the response off to the process_responses() task; use of `std::move` here releases our\n        // local pin on the response object.\n        //\n        BATT_REQUIRE_OK(this->response_queue_.push(std::move(response)));\n\n        BATT_VLOG(1) << \"HttpClientConnection::process_requests() serializing request\";\n\n        // Write the request message to the socket.  This function will block until the entire request has\n        // been serialized.\n        //\n        Status status = request->serialize(this->socket_);\n        BATT_REQUIRE_OK(status) << LogLevel::kError << \"Error serializing request\";\n\n        this->activity_.fetch_add(1);\n\n        BATT_VLOG(1)\n            << \"HttpClientConnection::process_requests() request serialized!  Setting state to kConsumed\";\n\n        request->state().set_value(HttpRequest::kConsumed);\n        //\n        // ~request - releases the Pin\n    }\n\n    return OkStatus();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpClientConnection::fill_input_buffer()\n{\n    auto on_exit = finally([this] {\n        BATT_VLOG(1) << \"HttpClientConnection::fill_input_buffer() exiting\"\n                     << BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint());\n\n        this->input_buffer_.close_for_write();\n    });\n\n    for (;;) {\n        // Allocate some space in the input buffer for incoming data.\n        //\n        StatusOr<SmallVec<MutableBuffer, 2>> buffer = this->input_buffer_.prepare_at_least(1);\n        BATT_REQUIRE_OK(buffer);\n\n        // Read data from the socket into the buffer.\n        //\n        auto n_read = Task::await<IOResult<usize>>([&](auto&& handler) {\n            this->socket_.async_read_some(*buffer, BATT_FORWARD(handler));\n        });\n        BATT_REQUIRE_OK(n_read);\n\n        this->activity_.fetch_add(1);\n\n        // Assuming we were successful, commit the read data so it can be consumed by the parser task.\n        //\n        this->input_buffer_.commit(*n_read);\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpClientConnection::process_responses()\n{\n    auto on_exit = finally([this] {\n        BATT_VLOG(1) << \"HttpClientConnection::process_responses() exiting\"\n                     << BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint());\n\n        // Unblock all other tasks by closing anything they might wait on.\n        //\n        this->activity_.close();\n        this->idle_timer_.cancel();\n        this->input_buffer_.close_for_read();\n        this->response_count_.close();\n\n        if (this->socket_.is_open()) {\n            boost::system::error_code ec;\n            this->socket_.close(ec);\n        }\n    });\n\n    for (;;) {\n        BATT_VLOG(1) << \"Awaiting response\";\n\n        BATT_ASSIGN_OK_RESULT(Pin<HttpResponse> const response, this->response_queue_.await_next());\n        BATT_CHECK_NOT_NULLPTR(response);\n\n        this->activity_.fetch_add(1);\n\n        BATT_VLOG(1) << \"Got response\";\n\n        pico_http::Response response_message;\n        StatusOr<i32> message_length = this->read_next_response(response_message);\n        BATT_REQUIRE_OK(message_length) << LogLevel::kError << \"Failed to read response\";\n\n        BATT_VLOG(1) << \"Parsed response header\";\n\n        ResponseInfo response_info(response_message);\n        if (!response_info.is_valid()) {\n            response->update_status(StatusCode::kInvalidArgument);\n            response->state().close();\n            return StatusCode::kInvalidArgument;\n        }\n\n        response->state().set_value(HttpResponse::kInitialized);\n\n        // Pass control over to the consumer and wait for it to signal it is done reading the message\n        // headers.\n        //\n        Status message_consumed = response->await_set_message(response_message);\n        BATT_REQUIRE_OK(message_consumed) << LogLevel::kError;\n\n        BATT_VLOG(1) << \"App done reading header\";\n        this->activity_.fetch_add(1);\n\n        // The consume is done with the message; consume it and move on to the body.\n        //\n        this->input_buffer_.consume(*message_length);\n\n        HttpData response_data{response_info.get_data(this->input_buffer_)};\n        response->await_set_data(response_data).IgnoreError();\n        //\n        BATT_VLOG(1) << \"App done reading body\";\n        //\n        // We must not touch `response` after `await_set_data` returns!\n\n        // Whether or not we keep the connection alive, acknowledge the response when we exit the loop.\n        //\n        auto on_scope_exit = batt::finally([this] {\n            this->response_count_.fetch_add(1);\n        });\n\n        this->activity_.fetch_add(1);\n\n        // If we are going to keep the connection alive, we must consume any extra data that wasn't read\n        // by the application.  Otherwise we just close it.\n        //\n        if (response_info.keep_alive) {\n            BATT_VLOG(1) << \"response is keep_alive\";\n            Status data_consumed = std::move(response_data) | seq::consume();\n            BATT_REQUIRE_OK(data_consumed) << LogLevel::kError;\n        } else {\n            BATT_VLOG(1) << \"response is close; closing socket\";\n            break;\n        }\n    }\n\n    return OkStatus();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr<i32> HttpClientConnection::read_next_response(pico_http::Response& response)\n{\n    i32 result = 0;\n    usize min_to_fetch = 1;\n    for (;;) {\n        StatusOr<SmallVec<ConstBuffer, 2>> fetched = this->input_buffer_.fetch_at_least(min_to_fetch);\n        BATT_REQUIRE_OK(fetched);\n\n        auto& buffers = *fetched;\n        const usize n_bytes_fetched = boost::asio::buffer_size(buffers);\n\n        BATT_CHECK(!buffers.empty());\n        result = response.parse(buffers.front());\n\n        if (result == pico_http::kParseIncomplete) {\n            min_to_fetch = std::max(min_to_fetch + 1, n_bytes_fetched);\n            continue;\n        }\n\n        if (result == pico_http::kParseFailed) {\n            auto chunk = buffers.front();\n            BATT_VLOG(1) << \"Failed to parse http message: \"\n                         << c_str_literal(std::string_view{(const char*)chunk.data(), chunk.size()});\n            return {StatusCode::kInternal};\n        }\n\n        BATT_CHECK_GT(result, 0);\n        return result;\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpClientConnection::ResponseInfo::ResponseInfo(const pico_http::Response& response)\n    : content_length{find_header(response.headers, \"Content-Length\").flat_map([](std::string_view s) {\n        return Optional{from_string<usize>(std::string(s))};\n    })}\n    , keep_alive{find_header(response.headers, \"Connection\")\n                     .map([](std::string_view s) {\n                         return s == \"keep-alive\";\n                     })\n                     .value_or(response.major_version == 1 && response.minor_version >= 1)}\n    , chunked_encoding{find_header(response.headers, \"Transfer-Encoding\")\n                           .map([](std::string_view s) {\n                               return s == \"chunked\";\n                           })\n                           .value_or(false)}\n\n{\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpData HttpClientConnection::ResponseInfo::get_data(StreamBuffer& input_buffer)\n{\n    return HttpData{[&]() -> BufferSource {\n        const auto consume_trailer = IncludeHttpTrailer{true};\n\n        if (this->content_length == None) {\n            if (this->chunked_encoding) {\n                return HttpChunkDecoder<StreamBuffer&>{input_buffer, consume_trailer};\n            } else {\n                if (this->keep_alive) {\n                    return BufferSource{};\n                } else {\n                    return std::ref(input_buffer);\n                }\n            }\n        } else {\n            if (this->chunked_encoding) {\n                return HttpChunkDecoder<StreamBuffer&>{input_buffer, consume_trailer}  //\n                       | seq::take_n(*this->content_length);\n            } else {\n                return input_buffer | seq::take_n(*this->content_length);\n            }\n        }\n    }()};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientConnection::idle_connection_timeout_task_main()\n{\n    // Zero means disable timeouts.\n    //\n    if (this->idle_connection_timeout_ms_ == 0) {\n        return;\n    }\n\n    // Whenever we wake up to find there has been some activity while we were asleep, we will reset\n    // `idle_since` to the current clock time.\n    //\n    auto idle_since = std::chrono::steady_clock::now();\n\n    // Local helper function - returns the elapsed time from `idle_since` to now.\n    //\n    const auto get_idle_ms = [&idle_since] {\n        return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::steady_clock::now() -\n                                                                     idle_since)\n            .count();\n    };\n\n    // Repeatedly sleep for ~1/4 of the timeout value, until the activity object is closed, the idle_timer_ is\n    // cancelled, or we reach the idle timeout.\n    //\n    while (get_idle_ms() < this->idle_connection_timeout_ms_ && !this->activity_.is_closed()) {\n        const auto initial_activity = this->activity_.get_value();\n        const auto timeout_ms = (this->idle_connection_timeout_ms_ + 3) / 4;\n\n        BATT_VLOG(1) << \"Sleeping for \" << timeout_ms << \"ms;\" << BATT_INSPECT(get_idle_ms());\n\n        ErrorCode ec = Task::await<ErrorCode>([&](auto&& handler) {\n            ErrorCode ec;\n            this->idle_timer_.expires_from_now(boost::posix_time::milliseconds(timeout_ms), ec);\n            if (ec) {\n                BATT_FORWARD(handler)(ec);\n            } else {\n                this->idle_timer_.async_wait(BATT_FORWARD(handler));\n            }\n        });\n\n        if (ec) {\n            BATT_VLOG(1) << \"Idle connection timer was cancelled; exiting\";\n            break;\n        }\n\n        if (this->activity_.get_value() != initial_activity) {\n            idle_since = std::chrono::steady_clock::now();\n        }\n    }\n    BATT_VLOG(1) << \"Finished idle connection timer loop\";\n\n    // Once we are out the loop, it is time to shut down!\n    //\n    if (!this->activity_.is_closed()) {\n        BATT_VLOG(1) << \"Shutting down HttpClientConnection due to inactivity;\" << BATT_INSPECT(get_idle_ms())\n                     << BATT_INSPECT(this->idle_connection_timeout_ms_)\n                     << BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint());\n\n        this->halt();\n    }\n    // else - if activity_ is closed, then we are in the process of shutting down due to other causes\n}\n\n}  // namespace batt\n\n#endif  // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP",
  "refid": "http__client__connection__impl_8hpp",
  "static": false,
  "strong": false,
  "title": "batteries/http/http_client_connection_impl.hpp",
  "url": "/_autogen/Files/http__client__connection__impl_8hpp/#file-http-client-connection-impl.hpp",
  "visibility": "public"
}