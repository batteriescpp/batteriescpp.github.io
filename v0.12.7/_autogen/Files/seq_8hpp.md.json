{
  "abstract": false,
  "anchor": "#file-seq.hpp",
  "category": "files",
  "const": false,
  "defines": [
    {
      "abstract": false,
      "anchor": "#define-batteries-seq-hpp",
      "category": "defines",
      "const": false,
      "definition": "",
      "explicit": false,
      "fullname": "BATTERIES_SEQ_HPP",
      "hasDetails": false,
      "inline": false,
      "kind": "define",
      "language": "cpp",
      "location": {
        "bodyFile": "batteries/seq.hpp",
        "bodyStart": 9,
        "column": 9,
        "file": "batteries/seq.hpp",
        "line": 9
      },
      "name": "BATTERIES_SEQ_HPP",
      "override": false,
      "refid": "seq_8hpp_1a3c22f39976d771a07a52b8ad53de3f75",
      "static": false,
      "strong": false,
      "title": "BATTERIES_SEQ_HPP",
      "url": "/_autogen/Files/seq_8hpp/#define-batteries-seq-hpp",
      "visibility": "public"
    }
  ],
  "definition": "",
  "explicit": false,
  "fullname": "batteries/seq.hpp",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "includes": "<batteries/config.hpp>",
  "inline": false,
  "kind": "file",
  "language": "cpp",
  "location": {
    "column": 0,
    "file": "batteries/seq.hpp",
    "line": 0
  },
  "name": "batteries/seq.hpp",
  "namespaces": [
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt",
      "refid": "namespacebatt",
      "title": "batt",
      "url": "/_autogen/Namespaces/namespacebatt/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt::seq",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt::seq",
      "refid": "namespacebatt_1_1seq",
      "title": "batt::seq",
      "url": "/_autogen/Namespaces/namespacebatt_1_1seq/",
      "visibility": "public"
    }
  ],
  "override": false,
  "parent": {
    "anchor": "#dir-batteries",
    "category": "dirs",
    "fullname": "batteries",
    "kind": "dir",
    "language": "",
    "name": "batteries",
    "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
    "title": "batteries",
    "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "#dir-batteries",
      "category": "dirs",
      "fullname": "batteries",
      "kind": "dir",
      "language": "",
      "name": "batteries",
      "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
      "title": "batteries",
      "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
      "visibility": "public"
    }
  ],
  "programlisting": "//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n\n// Utilities for dealing with sequences.\n//\n#pragma once\n#ifndef BATTERIES_SEQ_HPP\n#define BATTERIES_SEQ_HPP\n\n#include <batteries/config.hpp>\n//\n#include <batteries/assert.hpp>\n#include <batteries/case_of.hpp>\n#include <batteries/optional.hpp>\n#include <batteries/seq/boxed.hpp>\n#include <batteries/seq/cache_next.hpp>\n#include <batteries/seq/chain.hpp>\n#include <batteries/seq/collect_vec.hpp>\n#include <batteries/seq/consume.hpp>\n#include <batteries/seq/count.hpp>\n#include <batteries/seq/deref.hpp>\n#include <batteries/seq/emplace_back.hpp>\n#include <batteries/seq/filter.hpp>\n#include <batteries/seq/filter_map.hpp>\n#include <batteries/seq/first.hpp>\n#include <batteries/seq/flatten.hpp>\n#include <batteries/seq/for_each.hpp>\n#include <batteries/seq/group_by.hpp>\n#include <batteries/seq/lazy.hpp>\n#include <batteries/seq/map.hpp>\n#include <batteries/seq/merge_by.hpp>\n#include <batteries/seq/natural_order.hpp>\n#include <batteries/seq/print_out.hpp>\n#include <batteries/seq/printable.hpp>\n#include <batteries/seq/reduce.hpp>\n#include <batteries/seq/seq_item.hpp>\n#include <batteries/seq/skip_n.hpp>\n#include <batteries/seq/status_ok.hpp>\n#include <batteries/seq/sub_range_seq.hpp>\n#include <batteries/seq/take_n.hpp>\n#include <batteries/seq/take_while.hpp>\n#include <batteries/small_vec.hpp>\n#include <batteries/stream_util.hpp>\n#include <batteries/type_traits.hpp>\n#include <batteries/utility.hpp>\n\n#include <boost/range/iterator_range.hpp>\n\n#include <algorithm>\n#include <ostream>\n#include <string_view>\n#include <type_traits>\n#include <variant>\n#include <vector>\n\nnamespace batt {\n\ntemplate <typename ForwardIter>\nauto as_seq(ForwardIter&& begin, ForwardIter&& end)\n{\n    return as_seq(boost::make_iterator_range(BATT_FORWARD(begin), BATT_FORWARD(end)));\n}\n\ntemplate <typename VectorLike, typename = decltype(std::declval<VectorLike>().data()),\n          typename = decltype(std::declval<VectorLike>().size()),\n          typename = std::enable_if_t<std::is_same_v<decltype(std::declval<VectorLike>().data()),\n                                                     decltype(std::declval<VectorLike>().data() +\n                                                              std::declval<VectorLike>().size())>>>\nauto as_seq(VectorLike&& v)\n{\n    return as_seq(v.data(), v.data() + v.size());\n}\n\ntemplate <typename T, typename Begin = decltype(std::declval<const T&>().data()),\n          typename End = decltype(std::declval<Begin>() + std::declval<const T&>().size()),\n          typename = std::enable_if_t<std::is_same_v<Begin, End>>>\nauto vec_range(const T& vec)\n{\n    return boost::make_iterator_range(vec.data(), vec.data() + vec.size());\n}\n\ntemplate <typename T>\nstruct VecSeqBase {\n    explicit VecSeqBase(std::vector<T>&& v) noexcept : vec(std::move(v))\n    {\n    }\n\n    std::vector<T> vec;\n};\n\ntemplate <typename T>\nclass VecSeq\n    : public VecSeqBase<T>\n    , public SubRangeSeq<boost::iterator_range<const T*>>\n{\n   public:\n    explicit VecSeq(std::vector<T>&& v) noexcept\n        : VecSeqBase<T>{std::move(v)}\n        , SubRangeSeq<boost::iterator_range<const T*>>{\n              boost::make_iterator_range(this->vec.data(), this->vec.data() + this->vec.size())}\n    {\n    }\n};\n\ntemplate <typename T>\nauto into_seq(std::vector<T>&& v)\n{\n    return VecSeq<T>{std::move(v)};\n}\n\nnamespace seq {\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// collect\n//\ntemplate <typename T>\nstruct Collect {\n};\n\ntemplate <typename T>\ninline Collect<T> collect(StaticType<T> = {})\n{\n    return {};\n}\n\ntemplate <typename Seq, typename T>\n[[nodiscard]] auto operator|(Seq&& seq, Collect<T>)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>,\n                  \"(seq::collect) Sequences may not be captured implicitly by reference.\");\n\n    T v;\n    BATT_FORWARD(seq) | for_each([&v](auto&& item) {\n        v.emplace_back(BATT_FORWARD(item));\n    });\n    return std::move(v);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// decayed\n//\n\nstruct DecayItem {\n    template <typename T>\n    std::decay_t<T> operator()(T&& val) const\n    {\n        return BATT_FORWARD(val);\n    }\n};\n\ninline auto decayed()\n{\n    return map(DecayItem{});\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// kmerge, kmerge_by\n//\n\ntemplate <typename Seq, typename Compare>\nclass KMergeBy\n{\n   public:\n    using Item = SeqItem<Seq>;\n\n    struct HeapOrder {\n        template <typename L, typename R>\n        bool operator()(L* l, R* r) const\n        {\n            // Reversed because it's a max-heap.\n            return compare_(*r->peek(), *l->peek());\n        }\n\n        Compare compare_;\n    };\n\n    template <typename KSeqs>\n    explicit KMergeBy(KSeqs&& k_seqs, Compare&& compare) noexcept\n        : order_{BATT_FORWARD(compare)}\n        , k_seqs_(BATT_FORWARD(k_seqs) | decayed() | map([](auto&& seq) {\n                      return BATT_FORWARD(seq) | cache_next();\n                  }) |\n                  collect_vec())\n    {\n        static_assert(std::is_same_v<Seq, SeqItem<KSeqs>>, \"\");\n\n        as_seq(k_seqs_) | for_each([this](CacheNext<std::decay_t<Seq>>& seq) {\n            if (!seq.peek()) {\n                return;\n            }\n            this->heap_.emplace_back(&seq);\n            std::push_heap(this->heap_.begin(), this->heap_.end(), this->order_);\n        });\n\n        BATT_ASSERT_LE(this->heap_.size(), this->k_seqs_.size());\n    }\n\n    KMergeBy(const KMergeBy& that) noexcept : order_(that.order_), k_seqs_(that.k_seqs_), heap_(that.heap_)\n    {\n        fix_heap_pointers(that);\n    }\n\n    KMergeBy& operator=(const KMergeBy& that) noexcept\n    {\n        if (BATT_HINT_TRUE(this != &that)) {\n            this->order_ = that.order_;\n            this->k_seqs_ = that.k_seqs_;\n            this->heap_ = that.heap_;\n            fix_heap_pointers(that);\n        }\n        return *this;\n    }\n\n    Optional<Item> next()\n    {\n        if (this->heap_.empty()) {\n            return None;\n        }\n\n        // The lowest key is at the front of the level heap.  Pop it off the heap\n        // first, then remove it from that level's sequence and replace the level\n        // in the heap if it isn't empty.\n        //\n        std::pop_heap(this->heap_.begin(), this->heap_.end(), this->order_);\n\n        CacheNext<std::decay_t<Seq>>* next_seq = this->heap_.back();\n        BATT_ASSERT_NOT_NULLPTR(next_seq);\n\n        auto next_item = next_seq->next();\n        BATT_ASSERT_NE(next_item, None);\n\n        if (!next_seq->peek()) {\n            this->heap_.pop_back();\n        } else {\n            std::push_heap(this->heap_.begin(), this->heap_.end(), this->order_);\n        }\n\n        return next_item;\n    }\n\n    Optional<Item> peek()\n    {\n        if (this->heap_.empty()) {\n            return None;\n        }\n        return this->heap_.front()->peek();\n    }\n\n   private:\n    void fix_heap_pointers(const KMergeBy& that)\n    {\n        for (std::size_t i = 0; i < this->heap_.size(); ++i) {\n            BATT_ASSERT_GE(this->heap_[i], that.k_seqs_.data());\n            BATT_ASSERT_LT(this->heap_[i], that.k_seqs_.data() + that.k_seqs_.size());\n        }\n\n        for (auto& ptr : this->heap_) {\n            ptr = this->k_seqs_.data() + (ptr - that.k_seqs_.data());\n        }\n\n        for (std::size_t i = 0; i < this->heap_.size(); ++i) {\n            BATT_ASSERT_GE(this->heap_[i], this->k_seqs_.data());\n            BATT_ASSERT_LT(this->heap_[i], this->k_seqs_.data() + this->k_seqs_.size());\n            BATT_ASSERT_EQ(this->heap_[i] - this->k_seqs_.data(), that.heap_[i] - that.k_seqs_.data());\n        }\n    }\n\n    HeapOrder order_;  // TODO [tastolfi 2020-10-13] empty base class optimization\n\n    // The stack of sequences we are merging.\n    //\n    std::vector<CacheNext<std::decay_t<Seq>>> k_seqs_;\n\n    // A min-heap (by key) of per-level edit sequences, so we can quickly know\n    // where the next lowest key is.\n    //\n    SmallVec<CacheNext<std::decay_t<Seq>>*, 6> heap_;\n};\n\ntemplate <typename Compare>\nstruct KMergeByBinder {\n    Compare compare;\n};\n\ntemplate <typename Compare>\nKMergeByBinder<Compare> kmerge_by(Compare&& compare)\n{\n    return {BATT_FORWARD(compare)};\n}\n\ninline auto kmerge()\n{\n    return kmerge_by(NaturalOrder{});\n}\n\ntemplate <typename KSeqs, typename Compare>\n[[nodiscard]] KMergeBy<SeqItem<KSeqs>, Compare> operator|(KSeqs&& k_seqs, KMergeByBinder<Compare>&& binder)\n{\n    static_assert(std::is_same_v<KSeqs, std::decay_t<KSeqs>>,\n                  \"Merged sequences may not be captured implicitly by reference.\");\n\n    return KMergeBy<SeqItem<KSeqs>, Compare>{BATT_FORWARD(k_seqs), BATT_FORWARD(binder.compare)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map_pairwise\n//  Given: seqA = {a0, a1, a2, ...}, seqB = {b0, b1, b2, ...}, fn = (A, B) -> T\n//  Produce: {fn(a0, b0), fn(a1, b1), fn(a2, b2), ...}\n//\ntemplate <typename LeftSeq, typename RightSeq, typename MapFn>\nclass MapPairwise\n{\n   public:\n    using Item = std::invoke_result_t<MapFn, SeqItem<LeftSeq>, SeqItem<RightSeq>>;\n\n    explicit MapPairwise(LeftSeq&& left, RightSeq&& right, MapFn&& map_fn) noexcept\n        : left_(BATT_FORWARD(left))\n        , right_(BATT_FORWARD(right))\n        , map_fn_(BATT_FORWARD(map_fn))\n    {\n    }\n\n    MapPairwise(MapPairwise&& that) noexcept\n        : left_(BATT_FORWARD(that.left_))\n        , right_(BATT_FORWARD(that.right_))\n        , map_fn_(BATT_FORWARD(*that.map_fn_))\n    {\n    }\n\n    MapPairwise(const MapPairwise& that) : left_(that.left_), right_(that.right_), map_fn_(*that.map_fn_)\n    {\n    }\n\n    MapPairwise& operator=(MapPairwise&& that) noexcept\n    {\n        if (BATT_HINT_TRUE(this != &that)) {\n            this->left_ = BATT_FORWARD(that.left_);\n            this->right_ = BATT_FORWARD(that.right_);\n            this->map_fn_.emplace(BATT_FORWARD(*that.map_fn_));\n        }\n        return *this;\n    }\n\n    MapPairwise& operator=(const MapPairwise& that)\n    {\n        if (BATT_HINT_TRUE(this != &that)) {\n            this->left_ = that.left_;\n            this->right_ = that.right_;\n            this->map_fn_.emplace(*that.map_fn_);\n        }\n        return *this;\n    }\n\n    Optional<Item> peek()\n    {\n        return left_.peek().flat_map([this](auto&& left_item) {\n            return right_.peek().map([this, &left_item](auto&& right_item) {\n                return (*map_fn_)(BATT_FORWARD(left_item), BATT_FORWARD(right_item));\n            });\n        });\n    }\n\n    Optional<Item> next()\n    {\n        return left_.next().flat_map([this](auto&& left_item) {\n            return right_.next().map([this, &left_item](auto&& right_item) {\n                return (*map_fn_)(BATT_FORWARD(left_item), BATT_FORWARD(right_item));\n            });\n        });\n    }\n\n   private:\n    LeftSeq left_;\n    RightSeq right_;\n    Optional<MapFn> map_fn_;\n};\n\ntemplate <typename RightSeq, typename MapFn>\nstruct MapPairwiseBinder {\n    RightSeq right;\n    MapFn map_fn;\n};\n\ntemplate <typename RightSeq, typename MapFn>\nMapPairwiseBinder<RightSeq, MapFn> map_pairwise(RightSeq&& right, MapFn&& map_fn)\n{\n    return {BATT_FORWARD(right), BATT_FORWARD(map_fn)};\n}\n\ntemplate <typename LeftSeq, typename RightSeq, typename MapFn>\n[[nodiscard]] MapPairwise<LeftSeq, RightSeq, MapFn> operator|(LeftSeq&& left,\n                                                              MapPairwiseBinder<RightSeq, MapFn>&& binder)\n{\n    static_assert(std::is_same_v<LeftSeq, std::decay_t<LeftSeq>>,\n                  \"Mapped sequences may not be captured implicitly by reference.\");\n\n    static_assert(std::is_same_v<RightSeq, std::decay_t<RightSeq>>,\n                  \"Mapped sequences may not be captured implicitly by reference.\");\n\n    static_assert(std::is_same_v<MapFn, std::decay_t<MapFn>>,\n                  \"Mapping functions may not be captured implicitly by reference.\");\n\n    return MapPairwise<LeftSeq, RightSeq, MapFn>{BATT_FORWARD(left), BATT_FORWARD(binder.right),\n                                                 BATT_FORWARD(binder.map_fn)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// last\n//\nstruct LastBinder {\n};\n\ninline LastBinder last()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] auto operator|(Seq&& seq, LastBinder)\n{\n    using Item = SeqItem<Seq>;\n    Optional<Item> prev, next = seq.next();\n    while (next) {\n        prev = std::move(next);\n        next = seq.next();\n    }\n    return prev;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// inner_reduce\n//\ntemplate <typename ReduceFn>\nstruct InnerReduceBinder {\n    ReduceFn reduce_fn;\n};\n\ntemplate <typename ReduceFn>\nInnerReduceBinder<ReduceFn> inner_reduce(ReduceFn&& reduce_fn)\n{\n    return {BATT_FORWARD(reduce_fn)};\n}\n\ntemplate <typename Seq, typename ReduceFn>\n[[nodiscard]] Optional<std::decay_t<SeqItem<Seq>>> operator|(Seq&& seq, InnerReduceBinder<ReduceFn> binder)\n{\n    Optional<std::decay_t<SeqItem<Seq>>> state = seq.next();\n    if (!state) {\n        return state;\n    }\n    return BATT_FORWARD(seq) | reduce(std::move(*state), BATT_FORWARD(binder.reduce_fn));\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// single_item\n//\ntemplate <typename T>\nclass SingleItem\n{\n   public:\n    using Item = T;\n\n    explicit SingleItem(T&& item) noexcept : item_(BATT_FORWARD(item))\n    {\n    }\n\n    Optional<Item> peek()\n    {\n        return item_;\n    }\n\n    Optional<Item> next()\n    {\n        auto n = std::move(item_);\n        item_ = None;\n        return n;\n    }\n\n   private:\n    Optional<Item> item_;\n};\n\ntemplate <typename T>\n[[nodiscard]] SingleItem<T> single_item(T&& item)\n{\n    return SingleItem<T>{BATT_FORWARD(item)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// sum\n//\nstruct SumBinder {\n};\n\ninline SumBinder sum()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] auto operator|(Seq&& seq, SumBinder)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>,\n                  \"(seq::sum) Sequences may not be captured implicitly by reference.\");\n\n    return BATT_FORWARD(seq) | reduce(SeqItem<Seq>{}, [](auto&& a, auto&& b) {\n               return a + b;\n           });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// product\n//\nstruct ProductBinder {\n};\n\ninline ProductBinder product()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] auto operator|(Seq&& seq, ProductBinder)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>,\n                  \"(seq::product) Sequences may not be captured implicitly by reference.\");\n\n    return BATT_FORWARD(seq) | reduce(SeqItem<Seq>{1}, [](auto&& a, auto&& b) {\n               return a * b;\n           });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// any_true\n//\nstruct AnyBinder {\n};\n\ninline AnyBinder any_true()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] auto operator|(Seq&& seq, AnyBinder)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>,\n                  \"(seq::any_true) Sequences may not be captured implicitly by reference.\");\n\n    bool ans = false;\n    BATT_FORWARD(seq) | for_each([&ans](auto&& item) {\n        if (bool{item}) {\n            ans = true;\n            return LoopControl::kBreak;\n        }\n        return LoopControl::kContinue;\n    });\n    return ans;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// all_true\n//\nstruct AllBinder {\n};\n\ninline AllBinder all_true()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] auto operator|(Seq&& seq, AllBinder)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>,\n                  \"(seq::all_true) Sequences may not be captured implicitly by reference.\");\n\n    bool ans = true;\n    BATT_FORWARD(seq) | for_each([&ans](auto&& item) {\n        if (!bool{item}) {\n            ans = false;\n            return LoopControl::kBreak;\n        }\n        return LoopControl::kContinue;\n    });\n    return ans;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map_adjacent(binary_map_fn) -\n//  Transform [i0, i1, i2, i3, i4, ...]\n//       into [f(i0, i1), f(i1, i2), f(i2, i3), ...]\n//\ntemplate <typename Seq, typename Fn>\nclass MapAdjacent\n{\n   public:\n    using Item = decltype(std::declval<Fn&>()(std::declval<const SeqItem<Seq>&>(),\n                                              std::declval<const SeqItem<Seq>&>()));\n\n    explicit MapAdjacent(Seq&& seq, Fn&& fn) noexcept : seq_(BATT_FORWARD(seq)), fn_(BATT_FORWARD(fn))\n    {\n    }\n\n    Optional<Item> peek()\n    {\n        return item_.map([&](const auto& first) {\n            return seq_.peek().map([&](const auto& second) {\n                return fn_(first, second);\n            });\n        });\n    }\n    Optional<Item> next()\n    {\n        if (!item_) {\n            return None;\n        }\n        auto first = std::move(*item_);\n        item_ = seq_.next();\n        return item_.map([&](const auto& second) {\n            return fn_(first, second);\n        });\n    }\n\n   private:\n    Seq seq_;\n    Fn fn_;\n    Optional<SeqItem<Seq>> item_{seq_.next()};\n};\n\ntemplate <typename Fn>\nstruct MapAdjacentBinder {\n    Fn fn;\n};\n\ntemplate <typename Fn>\nMapAdjacentBinder<Fn> map_adjacent(Fn&& fn)\n{\n    return {BATT_FORWARD(fn)};\n}\n\ntemplate <typename Seq, typename Fn>\n[[nodiscard]] MapAdjacent<Seq, Fn> operator|(Seq&& seq, MapAdjacentBinder<Fn>&& binder)\n{\n    return MapAdjacent<Seq, Fn>{BATT_FORWARD(seq), BATT_FORWARD(binder.fn)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map_fold(state, map_fn)\n//\n//  map_fn: (state, item) -> tuple<state, mapped_item>\n//\n// seq | map_fold(...): Seq<mapped_item>\n//\n// Threads a state variable through a map operation, so that each invocation\n// of the map function sees the folded state from previous items.\n//\ntemplate <typename Seq, typename State, typename MapFn>\nclass MapFold\n{\n   public:\n    using Item = std::tuple_element_t<1, std::invoke_result_t<MapFn, State, SeqItem<Seq>>>;\n\n    explicit MapFold(Seq&& seq, State&& state, MapFn&& map_fn) noexcept\n        : seq_(BATT_FORWARD(seq))\n        , state_(BATT_FORWARD(state))\n        , map_fn_(BATT_FORWARD(map_fn))\n    {\n    }\n\n    Optional<Item> peek()\n    {\n        auto tr = seq_.peek().map([&](auto&& item) {\n            return map_fn_(state_, BATT_FORWARD(item));\n        });\n\n        if (!tr) {\n            return None;\n        }\n        // Don't update state if we are just peeking.\n        return {std::get<1>(std::move(*tr))};\n    }\n\n    Optional<Item> next()\n    {\n        auto tr = seq_.next().map([&](auto&& item) {\n            return map_fn_(state_, BATT_FORWARD(item));\n        });\n\n        if (!tr) {\n            return None;\n        }\n        // Update state.\n        state_ = std::get<0>(std::move(*tr));\n        return {std::get<1>(std::move(*tr))};\n    }\n\n   private:\n    Seq seq_;\n    State state_;\n    MapFn map_fn_;\n};\n\ntemplate <typename State, typename MapFn>\nstruct MapFoldBinder {\n    State state;\n    MapFn map_fn;\n};\n\ntemplate <typename State, typename MapFn>\nMapFoldBinder<State, MapFn> map_fold(State&& state, MapFn&& map_fn)\n{\n    return {BATT_FORWARD(state), BATT_FORWARD(map_fn)};\n}\n\ntemplate <typename Seq, typename State, typename MapFn>\n[[nodiscard]] MapFold<Seq, State, MapFn> operator|(Seq&& seq, MapFoldBinder<State, MapFn>&& binder)\n{\n    return MapFold<Seq, State, MapFn>{BATT_FORWARD(seq), BATT_FORWARD(binder.state),\n                                      BATT_FORWARD(binder.map_fn)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// rolling(initial, binary_fn)\n//\ntemplate <typename T, typename BinaryFn>\nstruct RollingBinder {\n    BinaryFn binary_fn;\n    T initial;\n};\n\ntemplate <typename T, typename BinaryFn>\ninline RollingBinder<T, BinaryFn> rolling(BinaryFn&& binary_fn, T&& initial = T{})\n{\n    return {BATT_FORWARD(binary_fn), BATT_FORWARD(initial)};\n}\n\ntemplate <typename Seq, typename T, typename BinaryFn>\n[[nodiscard]] auto operator|(Seq&& seq, RollingBinder<T, BinaryFn>&& binder)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>, \"Sequences may not be captured by reference.\");\n\n    return BATT_FORWARD(seq) | map_fold(BATT_FORWARD(binder.initial),\n                                        [binary_fn = BATT_FORWARD(binder.binary_fn)](auto a, auto b) {\n                                            auto c = binary_fn(a, b);\n                                            return std::make_tuple(c, c);\n                                        });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// running_total()\n//\nstruct Addition {\n    template <typename L, typename R>\n    decltype(auto) operator()(L&& l, R&& r) const\n    {\n        return BATT_FORWARD(l) + BATT_FORWARD(r);\n    }\n};\n\nstruct RunningTotalBinder {\n};\n\ninline RunningTotalBinder running_total()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] auto operator|(Seq&& seq, RunningTotalBinder)\n{\n    static_assert(std::is_same_v<Seq, std::decay_t<Seq>>, \"Sequences may not be captured by reference.\");\n\n    using T = std::decay_t<SeqItem<Seq>>;\n\n    return BATT_FORWARD(seq) | rolling<T>(Addition{});\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// inspect\n\ntemplate <typename Fn>\nauto inspect(Fn&& fn)\n{\n    return map([fn = BATT_FORWARD(fn)](auto&& item) -> decltype(auto) {\n        fn(item);\n        return BATT_FORWARD(item);\n    });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// splice\n//\ntemplate <typename OuterSeq, typename InnerSeq>\nclass Splice\n{\n   public:\n    using OuterSeqRef = std::add_lvalue_reference_t<OuterSeq>;\n    using Impl = Chain<TakeN<OuterSeqRef>, Chain<InnerSeq, OuterSeqRef>>;\n\n    using Item = SeqItem<Impl>;\n\n    explicit Splice(OuterSeq&& outer_seq, std::size_t n, InnerSeq&& inner_seq) noexcept\n        : outer_seq_(BATT_FORWARD(outer_seq))\n        , impl_{TakeN<OuterSeqRef>{outer_seq_, n},\n                Chain<InnerSeq, OuterSeqRef>{BATT_FORWARD(inner_seq), outer_seq_}}\n    {\n    }\n\n    Optional<Item> peek()\n    {\n        return impl_.peek();\n    }\n    Optional<Item> next()\n    {\n        return impl_.next();\n    }\n\n   private:\n    OuterSeq outer_seq_;\n    Impl impl_;\n};\n\ntemplate <typename InnerSeq>\nstruct SpliceBinder {\n    std::size_t n;\n    InnerSeq inner_seq;\n};\n\ntemplate <typename InnerSeq>\ninline SpliceBinder<InnerSeq> splice(std::size_t n, InnerSeq&& inner_seq)\n{\n    return {\n        n,\n        BATT_FORWARD(inner_seq),\n    };\n}\n\ntemplate <typename OuterSeq, typename InnerSeq>\n[[nodiscard]] auto operator|(OuterSeq&& outer_seq, SpliceBinder<InnerSeq>&& binder)\n{\n    return Splice<OuterSeq, InnerSeq>{BATT_FORWARD(outer_seq), binder.n, BATT_FORWARD(binder.inner_seq)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// is_sorted\n//\n\ntemplate <typename Compare>\nstruct IsSortedBinder {\n    Compare compare;\n};\n\ntemplate <typename Compare>\nIsSortedBinder<Compare> is_sorted_by(Compare&& compare)\n{\n    return {BATT_FORWARD(compare)};\n}\n\ninline auto is_sorted()\n{\n    return is_sorted_by([](const auto& left, const auto& right) {\n        return (left < right) || !(right < left);\n    });\n}\n\ntemplate <typename Seq, typename Compare>\n[[nodiscard]] inline bool operator|(Seq&& seq, IsSortedBinder<Compare>&& binder)\n{\n    return BATT_FORWARD(seq) | map_adjacent(BATT_FORWARD(binder.compare)) | all_true();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// inspect_adjacent(binary_fn)\n//\ntemplate <typename Seq, typename Fn>\nclass InspectAdjacent\n{\n   public:\n    using Item = SeqItem<Seq>;\n\n    explicit InspectAdjacent(Seq&& seq, Fn&& fn) noexcept : seq_(BATT_FORWARD(seq)), fn_(BATT_FORWARD(fn))\n    {\n    }\n\n    InspectAdjacent(InspectAdjacent&& that) noexcept\n        : seq_(BATT_FORWARD(that.seq_))\n        , fn_(BATT_FORWARD(*that.fn_))\n        , next_(BATT_FORWARD(that.next_))\n    {\n    }\n\n    InspectAdjacent& operator=(InspectAdjacent&& that) noexcept\n    {\n        if (BATT_HINT_TRUE(this != &that)) {\n            this->seq_ = BATT_FORWARD(that.seq_);\n            this->fn_.emplace(BATT_FORWARD(*that.fn_));\n            this->next_ = BATT_FORWARD(that.next_);\n        }\n        return *this;\n    }\n\n    InspectAdjacent(const InspectAdjacent& that) : seq_(that.seq_), fn_(*that.fn_), next_(that.next_)\n    {\n    }\n\n    InspectAdjacent& operator=(const InspectAdjacent& that)\n    {\n        if (BATT_HINT_TRUE(this != &that)) {\n            this->seq_ = that.seq_;\n            this->fn_.emplace(*that.fn_);\n            this->next_ = that.next_;\n        }\n        return *this;\n    }\n\n    Optional<Item> peek()\n    {\n        return next_;\n    }\n\n    Optional<Item> next()\n    {\n        auto item = std::move(next_);\n        next_ = seq_.next();\n\n        if (item && next_) {\n            (*fn_)(*item, *next_);\n        }\n\n        return item;\n    }\n\n   private:\n    Seq seq_;\n    Optional<Fn> fn_;\n    Optional<SeqItem<Seq>> next_{seq_.next()};\n};\n\ntemplate <typename Fn>\nstruct InspectAdjacentBinder {\n    Fn fn;\n};\n\ntemplate <typename Fn>\nInspectAdjacentBinder<Fn> inspect_adjacent(Fn&& fn)\n{\n    return {BATT_FORWARD(fn)};\n}\n\ntemplate <typename Seq, typename Fn>\nInspectAdjacent<Seq, Fn> operator|(Seq&& seq, InspectAdjacentBinder<Fn>&& binder)\n{\n    return InspectAdjacent<Seq, Fn>{BATT_FORWARD(seq), BATT_FORWARD(binder.fn)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// apply(seq_function) - apply a function to an entire sequence.\n//\n// Not to be confused with map, which applies some function to each item.\n//\ntemplate <typename SeqFn>\nstruct ApplyBinder {\n    SeqFn seq_fn;\n};\n\ntemplate <typename SeqFn>\ninline ApplyBinder<SeqFn> apply(SeqFn&& seq_fn)\n{\n    return {BATT_FORWARD(seq_fn)};\n}\n\ntemplate <typename Seq, typename SeqFn>\n[[nodiscard]] inline decltype(auto) operator|(Seq&& seq, ApplyBinder<SeqFn>&& binder)\n{\n    return BATT_FORWARD(binder.seq_fn)(BATT_FORWARD(seq));\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// attach(user_data) - attach a value to a sequence\n//\n\ntemplate <typename Seq, typename Data>\nclass Attach\n{\n   public:\n    using Item = SeqItem<Seq>;\n    using UserData = Data;\n\n    explicit Attach(Seq&& seq, Data&& data) noexcept : seq_(BATT_FORWARD(seq)), data_(BATT_FORWARD(data))\n    {\n    }\n\n    Data& user_data()\n    {\n        return data_;\n    }\n    const Data& user_data() const\n    {\n        return data_;\n    }\n\n    Optional<Item> peek()\n    {\n        return seq_.peek();\n    }\n    Optional<Item> next()\n    {\n        return seq_.next();\n    }\n\n   private:\n    Seq seq_;\n    Data data_;\n};\n\ntemplate <typename D>\nstruct AttachBinder {\n    D data;\n};\n\ntemplate <typename D>\ninline AttachBinder<D> attach(D&& data)\n{\n    return {BATT_FORWARD(data)};\n}\n\ntemplate <typename Seq, typename D>\n[[nodiscard]] inline auto operator|(Seq&& seq, AttachBinder<D>&& binder)\n{\n    static_assert(std::is_same_v<std::decay_t<Seq>, Seq>, \"attach may not be used with references\");\n    static_assert(std::is_same_v<std::decay_t<D>, D>, \"attach may not be used with references\");\n\n    return Attach<Seq, D>{BATT_FORWARD(seq), BATT_FORWARD(binder.data)};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// fuse() - Seq<Optional<T>> => Seq<T>; take T while Optional<T> != None\n//\n\ntemplate <typename Seq>\nclass Fuse\n{\n   public:\n    using OptionalItem = SeqItem<Seq>;\n    using Item = typename std::decay_t<OptionalItem>::value_type;\n\n    explicit Fuse(Seq&& seq) noexcept : seq_(BATT_FORWARD(seq))\n    {\n    }\n\n    Optional<Item> peek()\n    {\n        if (fused_) {\n            return None;\n        }\n        return *seq_.peek();\n    }\n\n    Optional<Item> next()\n    {\n        if (fused_) {\n            return None;\n        }\n\n        Optional<Optional<Item>> opt_item = seq_.next();\n\n        if (!opt_item) {\n            fused_ = true;\n            return None;\n        }\n        if (!*opt_item) {\n            fused_ = true;\n            return None;\n        }\n\n        return std::move(*opt_item);\n    }\n\n   private:\n    bool fused_ = false;\n    Seq seq_;\n};\n\nstruct FuseBinder {\n};\n\ninline FuseBinder fuse()\n{\n    return {};\n}\n\ntemplate <typename Seq>\n[[nodiscard]] Fuse<Seq> operator|(Seq&& seq, FuseBinder)\n{\n    return Fuse<Seq>{BATT_FORWARD(seq)};\n}\n\n}  // namespace seq\n}  // namespace batt\n\n#endif  // BATTERIES_SEQ_HPP",
  "publicClasses": [
    {
      "anchor": "",
      "category": "classes",
      "derivedClasses": [
        {
          "external": false,
          "name": "batt::VecSeq< T >",
          "refid": "classbatt_1_1VecSeq",
          "url": "/_autogen/Classes/classbatt_1_1VecSeq/",
          "virtual": "non-virtual",
          "visibility": "public"
        }
      ],
      "fullname": "batt::VecSeqBase",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::VecSeqBase",
      "refid": "structbatt_1_1VecSeqBase",
      "title": "batt::VecSeqBase",
      "url": "/_autogen/Classes/structbatt_1_1VecSeqBase/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "baseClasses": [
        {
          "external": false,
          "name": "batt::VecSeqBase< T >",
          "refid": "structbatt_1_1VecSeqBase",
          "url": "/_autogen/Classes/structbatt_1_1VecSeqBase/",
          "virtual": "non-virtual",
          "visibility": "public"
        },
        {
          "external": false,
          "name": "batt::SubRangeSeq< boost::iterator_range< const T * > >",
          "refid": "classbatt_1_1SubRangeSeq",
          "url": "/_autogen/Classes/classbatt_1_1SubRangeSeq/",
          "virtual": "non-virtual",
          "visibility": "public"
        }
      ],
      "category": "classes",
      "fullname": "batt::VecSeq",
      "kind": "class",
      "language": "cpp",
      "name": "batt::VecSeq",
      "refid": "classbatt_1_1VecSeq",
      "title": "batt::VecSeq",
      "url": "/_autogen/Classes/classbatt_1_1VecSeq/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::Collect",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::Collect",
      "refid": "structbatt_1_1seq_1_1Collect",
      "title": "batt::seq::Collect",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1Collect/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::DecayItem",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::DecayItem",
      "refid": "structbatt_1_1seq_1_1DecayItem",
      "title": "batt::seq::DecayItem",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1DecayItem/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::KMergeBy",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::KMergeBy",
      "refid": "classbatt_1_1seq_1_1KMergeBy",
      "title": "batt::seq::KMergeBy",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::KMergeBy::HeapOrder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::KMergeBy::HeapOrder",
      "refid": "structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder",
      "title": "batt::seq::KMergeBy::HeapOrder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1KMergeBy_1_1HeapOrder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::KMergeByBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::KMergeByBinder",
      "refid": "structbatt_1_1seq_1_1KMergeByBinder",
      "title": "batt::seq::KMergeByBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::MapPairwise",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::MapPairwise",
      "refid": "classbatt_1_1seq_1_1MapPairwise",
      "title": "batt::seq::MapPairwise",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::MapPairwiseBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::MapPairwiseBinder",
      "refid": "structbatt_1_1seq_1_1MapPairwiseBinder",
      "title": "batt::seq::MapPairwiseBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::LastBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::LastBinder",
      "refid": "structbatt_1_1seq_1_1LastBinder",
      "title": "batt::seq::LastBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1LastBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::InnerReduceBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::InnerReduceBinder",
      "refid": "structbatt_1_1seq_1_1InnerReduceBinder",
      "title": "batt::seq::InnerReduceBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::SingleItem",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::SingleItem",
      "refid": "classbatt_1_1seq_1_1SingleItem",
      "title": "batt::seq::SingleItem",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1SingleItem/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::SumBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::SumBinder",
      "refid": "structbatt_1_1seq_1_1SumBinder",
      "title": "batt::seq::SumBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1SumBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::ProductBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::ProductBinder",
      "refid": "structbatt_1_1seq_1_1ProductBinder",
      "title": "batt::seq::ProductBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1ProductBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::AnyBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::AnyBinder",
      "refid": "structbatt_1_1seq_1_1AnyBinder",
      "title": "batt::seq::AnyBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1AnyBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::AllBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::AllBinder",
      "refid": "structbatt_1_1seq_1_1AllBinder",
      "title": "batt::seq::AllBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1AllBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::MapAdjacent",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::MapAdjacent",
      "refid": "classbatt_1_1seq_1_1MapAdjacent",
      "title": "batt::seq::MapAdjacent",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::MapAdjacentBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::MapAdjacentBinder",
      "refid": "structbatt_1_1seq_1_1MapAdjacentBinder",
      "title": "batt::seq::MapAdjacentBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::MapFold",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::MapFold",
      "refid": "classbatt_1_1seq_1_1MapFold",
      "title": "batt::seq::MapFold",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1MapFold/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::MapFoldBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::MapFoldBinder",
      "refid": "structbatt_1_1seq_1_1MapFoldBinder",
      "title": "batt::seq::MapFoldBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::RollingBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::RollingBinder",
      "refid": "structbatt_1_1seq_1_1RollingBinder",
      "title": "batt::seq::RollingBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::Addition",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::Addition",
      "refid": "structbatt_1_1seq_1_1Addition",
      "title": "batt::seq::Addition",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1Addition/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::RunningTotalBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::RunningTotalBinder",
      "refid": "structbatt_1_1seq_1_1RunningTotalBinder",
      "title": "batt::seq::RunningTotalBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1RunningTotalBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::Splice",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::Splice",
      "refid": "classbatt_1_1seq_1_1Splice",
      "title": "batt::seq::Splice",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1Splice/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::SpliceBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::SpliceBinder",
      "refid": "structbatt_1_1seq_1_1SpliceBinder",
      "title": "batt::seq::SpliceBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::IsSortedBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::IsSortedBinder",
      "refid": "structbatt_1_1seq_1_1IsSortedBinder",
      "title": "batt::seq::IsSortedBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::InspectAdjacent",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::InspectAdjacent",
      "refid": "classbatt_1_1seq_1_1InspectAdjacent",
      "title": "batt::seq::InspectAdjacent",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::InspectAdjacentBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::InspectAdjacentBinder",
      "refid": "structbatt_1_1seq_1_1InspectAdjacentBinder",
      "title": "batt::seq::InspectAdjacentBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::ApplyBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::ApplyBinder",
      "refid": "structbatt_1_1seq_1_1ApplyBinder",
      "title": "batt::seq::ApplyBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::Attach",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::Attach",
      "refid": "classbatt_1_1seq_1_1Attach",
      "title": "batt::seq::Attach",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1Attach/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::AttachBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::AttachBinder",
      "refid": "structbatt_1_1seq_1_1AttachBinder",
      "title": "batt::seq::AttachBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::Fuse",
      "kind": "class",
      "language": "cpp",
      "name": "batt::seq::Fuse",
      "refid": "classbatt_1_1seq_1_1Fuse",
      "title": "batt::seq::Fuse",
      "url": "/_autogen/Classes/classbatt_1_1seq_1_1Fuse/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "classes",
      "fullname": "batt::seq::FuseBinder",
      "kind": "struct",
      "language": "cpp",
      "name": "batt::seq::FuseBinder",
      "refid": "structbatt_1_1seq_1_1FuseBinder",
      "title": "batt::seq::FuseBinder",
      "url": "/_autogen/Classes/structbatt_1_1seq_1_1FuseBinder/",
      "visibility": "public"
    }
  ],
  "refid": "seq_8hpp",
  "static": false,
  "strong": false,
  "title": "batteries/seq.hpp",
  "url": "/_autogen/Files/seq_8hpp/#file-seq.hpp",
  "visibility": "public"
}