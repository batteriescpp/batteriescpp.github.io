{
  "abstract": false,
  "anchor": "#file-status-impl.hpp",
  "category": "files",
  "const": false,
  "defines": [
    {
      "abstract": false,
      "anchor": "#define-batteries-status-impl-hpp",
      "category": "defines",
      "const": false,
      "definition": "",
      "explicit": false,
      "fullname": "BATTERIES_STATUS_IMPL_HPP",
      "hasDetails": false,
      "inline": false,
      "kind": "define",
      "language": "cpp",
      "location": {
        "bodyFile": "batteries/status_impl.hpp",
        "bodyStart": 6,
        "column": 9,
        "file": "batteries/status_impl.hpp",
        "line": 6
      },
      "name": "BATTERIES_STATUS_IMPL_HPP",
      "override": false,
      "refid": "status__impl_8hpp_1a16610e019509c53819e6bb9ffbd47606",
      "static": false,
      "strong": false,
      "title": "BATTERIES_STATUS_IMPL_HPP",
      "url": "/_autogen/Files/status__impl_8hpp/#define-batteries-status-impl-hpp",
      "visibility": "public"
    }
  ],
  "definition": "",
  "explicit": false,
  "fullname": "batteries/status_impl.hpp",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "includes": "<batteries/config.hpp>",
  "inline": false,
  "kind": "file",
  "language": "cpp",
  "location": {
    "column": 0,
    "file": "batteries/status_impl.hpp",
    "line": 0
  },
  "name": "batteries/status_impl.hpp",
  "namespaces": [
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt",
      "refid": "namespacebatt",
      "title": "batt",
      "url": "/_autogen/Namespaces/namespacebatt/",
      "visibility": "public"
    },
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt::detail",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt::detail",
      "refid": "namespacebatt_1_1detail",
      "title": "batt::detail",
      "url": "/_autogen/Namespaces/namespacebatt_1_1detail/",
      "visibility": "public"
    }
  ],
  "override": false,
  "parent": {
    "anchor": "#dir-batteries",
    "category": "dirs",
    "fullname": "batteries",
    "kind": "dir",
    "language": "",
    "name": "batteries",
    "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
    "title": "batteries",
    "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "#dir-batteries",
      "category": "dirs",
      "fullname": "batteries",
      "kind": "dir",
      "language": "",
      "name": "batteries",
      "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
      "title": "batteries",
      "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
      "visibility": "public"
    }
  ],
  "programlisting": "//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATUS_IMPL_HPP\n#define BATTERIES_STATUS_IMPL_HPP\n\n#include <batteries/config.hpp>\n//\n#include <batteries/assert.hpp>\n#include <batteries/config.hpp>\n#include <batteries/hint.hpp>\n#include <batteries/no_destruct.hpp>\n#include <batteries/status.hpp>\n\n#include <future>\n#include <utility>\n#include <vector>\n\nnamespace batt {\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const char* Status::CodeGroup::name() const noexcept\n{\n    return name_of(this->enum_type_index);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ const std::string& Status::unknown_enum_value_message()\n{\n    static const NoDestruct<std::string> s{\n        \"(Unknown enum value; not registered via batt::Status::register_codes)\"};\n    return *s;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ const Status::CodeEntry& Status::get_entry_from_code(value_type value)\n{\n    const usize index_of_group = Status::get_index_of_group(value);\n    const usize index_within_group = Status::get_index_within_group(value);\n    const auto& all_groups = Status::registered_groups();\n\n    if (BATT_HINT_FALSE(!(index_of_group < all_groups.size()) ||\n                        !(index_within_group < all_groups[index_of_group]->entries.size()))) {\n        if (!fail_check_exit_entered().exchange(true)) {\n            BATT_PANIC() << BATT_INSPECT(value)                      //\n                         << BATT_INSPECT(index_of_group)             //\n                         << BATT_INSPECT(all_groups.size())          //\n                         << BATT_INSPECT((isize)index_of_group)      //\n                         << BATT_INSPECT((isize)index_within_group)  //\n                ;\n        }\n        return all_groups[0]->entries[0];\n    }\n\n    return all_groups[index_of_group]->entries[index_within_group];\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ std::string_view Status::message_from_code(value_type value)\n{\n    return Status::get_entry_from_code(value).message;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::Status() : Status(StatusCode::kOk)\n{\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool Status::ok() const noexcept BATT_WARN_UNUSED_RESULT\n{\n    return (this->value_ & kLocalMask) == 0;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::value_type Status::code() const noexcept\n{\n    return this->value_;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::value_type Status::code_index_within_group() const noexcept\n{\n    return Status::get_index_within_group(this->value_);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const Status::CodeEntry& Status::code_entry() const noexcept\n{\n    return Status::get_entry_from_code(this->value_);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::string_view Status::message() const noexcept\n{\n#ifdef BATT_STATUS_CUSTOM_MESSSAGES\n    return this->message_;\n#else\n    return message_from_code(this->value_);\n#endif\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::value_type Status::group_index() const noexcept\n{\n    return get_index_of_group(this->value_);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const Status::CodeGroup& Status::group() const\n{\n    const usize index_of_group = get_index_of_group(this->value_);\n    const auto& all_groups = registered_groups();\n\n    BATT_CHECK_LT(index_of_group, all_groups.size());\n    BATT_ASSERT_NOT_NULLPTR(all_groups[index_of_group]);\n\n    return *all_groups[index_of_group];\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Status::IgnoreError() const noexcept\n{\n    // do nothing\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Status::Update(const Status& new_status)\n{\n    if (this->ok() || *this == Status{StatusCode::kUnknown}) {\n        *this = new_status;\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ usize Status::next_group_index()\n{\n    static NoDestruct<std::atomic<i32>> next_index{0};\n    const usize i = next_index->fetch_add(1);\n    BATT_CHECK_LT(i, kMaxGroupCount);\n    return i;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ std::array<Status::CodeGroup*, Status::kMaxGroupCount>&\nStatus::registered_groups()\n{\n    static NoDestruct<std::array<CodeGroup*, kMaxGroupCount>> all_groups;\n    [[maybe_unused]] static bool initialized = [] {\n        all_groups->fill(nullptr);\n        return true;\n    }();\n\n    return *all_groups;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ usize Status::get_index_of_group(value_type value)\n{\n    return (value & kGroupMask) >> kGroupSizeBits;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ usize Status::get_index_within_group(value_type value)\n{\n    return value & kLocalMask;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream& operator<<(std::ostream& out, const Status& t)\n{\n    return out << t.group_index() << \".\" << t.code_index_within_group() << \":\" << t.message();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool operator==(const Status& l, const Status& r)\n{\n    return l.code() == r.code() || (l.ok() && r.ok());\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool operator!=(const Status& l, const Status& r)\n{\n    return !(l == r);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status OkStatus()\n{\n    return Status{};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL detail::StatusBase::StatusBase() noexcept\n{\n    [[maybe_unused]] static bool initialized = [] {\n        Status::register_codes_internal<StatusCode>({\n            {StatusCode::kOk, \"Ok\"},\n            {StatusCode::kCancelled, \"Cancelled\"},\n            {StatusCode::kUnknown, \"Unknown\"},\n            {StatusCode::kInvalidArgument, \"Invalid Argument\"},\n            {StatusCode::kDeadlineExceeded, \"Deadline Exceeded\"},\n            {StatusCode::kNotFound, \"Not Found\"},\n            {StatusCode::kAlreadyExists, \"Already Exists\"},\n            {StatusCode::kPermissionDenied, \"Permission Denied\"},\n            {StatusCode::kResourceExhausted, \"Resource Exhausted\"},\n            {StatusCode::kFailedPrecondition, \"Failed Precondition\"},\n            {StatusCode::kAborted, \"Aborted\"},\n            {StatusCode::kOutOfRange, \"Out of Range\"},\n            {StatusCode::kUnimplemented, \"Unimplemented\"},\n            {StatusCode::kInternal, \"Internal\"},\n            {StatusCode::kUnavailable, \"Unavailable\"},\n            {StatusCode::kDataLoss, \"Data Loss\"},\n            {StatusCode::kUnauthenticated, \"Unauthenticated\"},\n            //\n            {StatusCode::kClosed, \"Closed\"},\n            {StatusCode::kGrantUnavailable, \"The requested grant count exceeds available count\"},\n            {StatusCode::kLoopBreak, \"Loop break\"},\n            {StatusCode::kEndOfStream, \"End of stream\"},\n            {StatusCode::kClosedBeforeEndOfStream, \"The stream was closed before the end of data\"},\n            {StatusCode::kGrantRevoked, \"The Grant was revoked\"},\n            {StatusCode::kPoke, \"The observed object was poked\"},\n        });\n\n        std::vector<std::pair<ErrnoValue, std::string>> errno_codes;\n        for (int code = 0; code < Status::kGroupSize; ++code) {\n            const char* msg = std::strerror(code);\n            if (msg) {\n                errno_codes.emplace_back(static_cast<ErrnoValue>(code), std::string(msg));\n            } else {\n                errno_codes.emplace_back(static_cast<ErrnoValue>(code), std::string(\"(unknown)\"));\n            }\n        }\n        return Status::register_codes_internal<ErrnoValue>(errno_codes);\n    }();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool is_ok_status(const std::error_code& ec)\n{\n    return !ec;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream& operator<<(std::ostream& out, LogLevel t)\n{\n    switch (t) {\n    case LogLevel::kFatal:\n        return out << \"LogLevel::kFatal\";\n\n    case LogLevel::kError:\n        return out << \"LogLevel::kError\";\n\n    case LogLevel::kWarning:\n        return out << \"LogLevel::kWarning\";\n\n    case LogLevel::kInfo:\n        return out << \"LogLevel::kInfo\";\n\n    case LogLevel::kDebug:\n        return out << \"LogLevel::kDebug\";\n\n    case LogLevel::kVerbose:\n        return out << \"LogLevel::kVerbose\";\n\n    default:\n        break;\n    }\n    return out << \"(Bad LogLevel value:\" << (int)t << \")\";\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::atomic<LogLevel>& require_fail_global_default_log_level()\n{\n    static std::atomic<LogLevel> global_default_{LogLevel::kVerbose};\n    return global_default_;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Optional<LogLevel>& require_fail_thread_default_log_level()\n{\n    thread_local Optional<LogLevel> per_thread_default_;\n    return per_thread_default_;\n}\n\nnamespace detail {\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ NotOkStatusWrapper::NotOkStatusWrapper(usize this_size, const char* file,\n                                                                     int line, const Status& status,\n                                                                     bool vlog_is_on) noexcept\n    : file_{file}\n    , line_{line}\n    , status_(status)\n    , vlog_is_on_{vlog_is_on}\n{\n    BATT_CHECK_EQ(sizeof(NotOkStatusWrapper), this_size);\n#if BATT_WITH_GLOG\n    this->output_ << \"(\" << this->file_ << \":\" << this->line_ << \") \" << this->status_ << \"; \";\n#endif  // BATT_WITH_GLOG\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL NotOkStatusWrapper::~NotOkStatusWrapper() noexcept\n{\n#if BATT_WITH_GLOG\n    switch (this->level_) {\n    case LogLevel::kFatal:\n        ::google::LogMessage(this->file_, this->line_, google::GLOG_FATAL).stream() << this->output_.str();\n        break;\n    case LogLevel::kError:\n        ::google::LogMessage(this->file_, this->line_, google::GLOG_ERROR).stream() << this->output_.str();\n        break;\n    case LogLevel::kWarning:\n        ::google::LogMessage(this->file_, this->line_, google::GLOG_WARNING).stream() << this->output_.str();\n        break;\n    case LogLevel::kInfo:\n        ::google::LogMessage(this->file_, this->line_, google::GLOG_INFO).stream() << this->output_.str();\n        break;\n    case LogLevel::kDebug:\n        DLOG(INFO) << \" [\" << this->file_ << \":\" << this->line_ << \"] \" << this->output_.str();\n        break;\n    case LogLevel::kVerbose:\n        if (this->vlog_is_on_) {\n            ::google::LogMessage(this->file_, this->line_, google::GLOG_INFO).stream() << this->output_.str();\n        }\n        break;\n    }\n#endif  // BATT_WITH_GLOG\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL NotOkStatusWrapper::operator Status() noexcept\n{\n    return std::move(this->status_);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL NotOkStatusWrapper& NotOkStatusWrapper::operator<<(LogLevel new_level)\n{\n    this->level_ = new_level;\n    return *this;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL\nstd::unordered_map<const boost::system::error_category*, const std::unordered_map<int, Status>>&\nthread_local_error_category_status_map()\n{\n    thread_local std::unordered_map<const boost::system::error_category*,\n                                    const std::unordered_map<int, Status>>\n        thread_cache_;\n\n    return thread_cache_;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::mutex& global_error_category_status_map_mutex()\n{\n    static NoDestruct<std::mutex> mutex_;\n\n    return *mutex_;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL\nstd::unordered_map<const boost::system::error_category*, const std::unordered_map<int, Status>>&\nglobal_error_category_status_map()\n{\n    static NoDestruct<\n        std::unordered_map<const boost::system::error_category*, const std::unordered_map<int, Status>>>\n        global_cache_;\n\n    return *global_cache_;\n}\n\n}  //namespace detail\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status status_from_error_category(const boost::system::error_category& category, int code)\n{\n    // First check in the thread-local cache for the given category.\n    //\n    auto& thread_cache = detail::thread_local_error_category_status_map();\n    auto iter = thread_cache.find(&category);\n    if (iter != thread_cache.end()) {\n        //  The category was found in the local cache; look up the code value.\n        //\n        auto iter2 = iter->second.find(code);\n        if (iter2 != iter->second.end()) {\n            return iter2->second;\n        }\n    }\n\n    // Fall back on the global cache.  To access this, we need to grab the mutex.\n    {\n        std::unique_lock<std::mutex> lock{detail::global_error_category_status_map_mutex()};\n\n        auto& global_cache = detail::global_error_category_status_map();\n        auto iter2 = global_cache.find(&category);\n        if (iter2 != global_cache.end()) {\n            //  We found the category in the global cache; add it to the thread cache and retry.\n            //\n            thread_cache.emplace(*iter2);\n            return status_from_error_category(category, code);\n        }\n    }\n\n    // This code wasn't registered for this category, or the category wasn't found.  Return `kUnknown`.\n    //\n    return StatusCode::kUnknown;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status status_from_error_code(const boost::system::error_code& ec)\n{\n    return status_from_error_category(ec.category(), ec.value());\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status error_code_to_status(const boost::system::error_code& ec)\n{\n    if (!ec) {\n        return OkStatus();\n    }\n    if (&(ec.category()) == &(boost::asio::error::get_misc_category())) {\n        switch (ec.value()) {\n        case boost::asio::error::eof:\n            return Status{StatusCode::kEndOfStream};\n\n        case boost::asio::error::not_found:\n            return Status{StatusCode::kNotFound};\n\n        default:\n            break;\n        }\n    } else if (&(ec.category()) == &(boost::asio::error::get_system_category())) {\n        switch (ec.value()) {\n        case boost::asio::error::access_denied:\n            return status_from_errno(EACCES);\n\n        case boost::asio::error::address_family_not_supported:\n            return status_from_errno(EAFNOSUPPORT);\n\n        case boost::asio::error::address_in_use:\n            return status_from_errno(EADDRINUSE);\n\n        case boost::asio::error::already_connected:\n            return status_from_errno(EISCONN);\n\n        case boost::asio::error::already_started:\n            return status_from_errno(EALREADY);\n\n        case boost::asio::error::broken_pipe:\n            // TODO [tastolfi 2022-12-16] On Windows: ERROR_BROKEN_PIPE\n            return status_from_errno(EPIPE);\n\n        case boost::asio::error::connection_aborted:\n            return status_from_errno(ECONNABORTED);\n\n        case boost::asio::error::connection_refused:\n            return status_from_errno(ECONNREFUSED);\n\n        case boost::asio::error::connection_reset:\n            return status_from_errno(ECONNRESET);\n\n        case boost::asio::error::bad_descriptor:\n            return status_from_errno(EBADF);\n\n        case boost::asio::error::fault:\n            return status_from_errno(EFAULT);\n\n        case boost::asio::error::host_unreachable:\n            return status_from_errno(EHOSTUNREACH);\n\n        case boost::asio::error::in_progress:\n            return status_from_errno(EINPROGRESS);\n\n        case boost::asio::error::interrupted:\n            return status_from_errno(EINTR);\n\n        case boost::asio::error::invalid_argument:\n            return status_from_errno(EINVAL);\n\n        case boost::asio::error::message_size:\n            return status_from_errno(EMSGSIZE);\n\n        case boost::asio::error::name_too_long:\n            return status_from_errno(ENAMETOOLONG);\n\n        case boost::asio::error::network_down:\n            return status_from_errno(ENETDOWN);\n\n        case boost::asio::error::network_reset:\n            return status_from_errno(ENETRESET);\n\n        case boost::asio::error::network_unreachable:\n            return status_from_errno(ENETUNREACH);\n\n        case boost::asio::error::no_descriptors:\n            return status_from_errno(EMFILE);\n\n        case boost::asio::error::no_buffer_space:\n            return status_from_errno(ENOBUFS);\n\n        case boost::asio::error::no_memory:\n            // TODO [tastolfi 2022-12-16] Windows: ERROR_OUTOFMEMORY\n            return status_from_errno(ENOMEM);\n\n        case boost::asio::error::no_permission:\n            // TODO [tastolfi 2022-12-16] Windows: ERROR_ACCESS_DENIED\n            return status_from_errno(EPERM);\n\n        case boost::asio::error::no_protocol_option:\n            return status_from_errno(ENOPROTOOPT);\n\n        case boost::asio::error::no_such_device:\n            // TODO [tastolfi 2022-12-16] Windows: ERROR_BAD_UNIT\n            return status_from_errno(ENODEV);\n\n        case boost::asio::error::not_connected:\n            return status_from_errno(ENOTCONN);\n\n        case boost::asio::error::not_socket:\n            return status_from_errno(ENOTSOCK);\n\n        case boost::asio::error::operation_aborted:\n            // TODO [tastolfi 2022-12-16] Windows: ERROR_OPERATION_ABORTED\n            return status_from_errno(ECANCELED);\n\n        case boost::asio::error::operation_not_supported:\n            return status_from_errno(EOPNOTSUPP);\n\n#ifndef BATT_PLATFORM_IS_WINDOWS\n        case boost::asio::error::shut_down:\n            return status_from_errno(ESHUTDOWN);\n#endif  // BATT_PLATFORM_IS_WINDOWS\n\n        case boost::asio::error::timed_out:\n            return status_from_errno(ETIMEDOUT);\n\n        case boost::asio::error::try_again:\n            // TODO [tastolfi 2022-12-16] Windows: ERROR_RETRY\n            return status_from_errno(EAGAIN);\n\n#if !defined(__linux__) && !defined(__APPLE__)\n#if EAGAIN != EWOULDBLOCK\n        case boost::asio::error::would_block:\n            return status_from_errno(EWOULDBLOCK);\n#endif\n#endif  // __linux__\n\n        default:\n            break;\n        }\n    }\n    return status_from_error_code(ec);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status error_code_to_status(const std::error_code& ec)\n{\n    static const std::error_category* std_generic_category = std::addressof(std::generic_category());\n    static const std::error_category* std_system_category = std::addressof(std::system_category());\n    static const std::error_category* std_future_category = std::addressof(std::future_category());\n    static const std::error_category* std_iostream_category = std::addressof(std::iostream_category());\n\n    [[maybe_unused]] static const bool initialized = [] {\n        const auto register_std_error_category = [](auto code_enum_type,\n                                                    const std::error_category* category) {\n            using CodeEnumT = typename decltype(code_enum_type)::type;\n\n            std::vector<std::pair<CodeEnumT, std::string>> code_table;\n\n            for (int i = 0; i < Status::kGroupSize; ++i) {\n                std::error_code ec(i, *category);\n                code_table.emplace_back(static_cast<CodeEnumT>(i), ec.message());\n            }\n\n            return Status::register_codes<CodeEnumT>(code_table);\n        };\n\n        return register_std_error_category(StaticType<StdGenericErrorCode>{}, std_generic_category) &&    //\n               register_std_error_category(StaticType<StdSystemErrorCode>{}, std_system_category) &&      //\n               register_std_error_category(StaticType<StdFutureErrorCode>{}, std_future_category) &&      //\n               register_std_error_category(StaticType<StdIostreamErrorCode>{}, std_iostream_category) &&  //\n               true;\n    }();\n\n    if (!ec) {\n        return OkStatus();\n    }\n\n    const std::error_category* category = std::addressof(ec.category());\n\n    if (category == std_generic_category) {\n        return Status{static_cast<StdGenericErrorCode>(ec.value())};\n    } else if (category == std_system_category) {\n        return Status{static_cast<StdSystemErrorCode>(ec.value())};\n\n    } else if (category == std_future_category) {\n        return Status{static_cast<StdFutureErrorCode>(ec.value())};\n\n    } else if (category == std_iostream_category) {\n        return Status{static_cast<StdIostreamErrorCode>(ec.value())};\n    }\n\n    return Status{StatusCode::kInternal};\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool status_is_retryable(const Status& s)\n{\n    return s == StatusCode::kUnavailable            //\n           || s == static_cast<ErrnoValue>(EAGAIN)  //\n           || s == static_cast<ErrnoValue>(EINTR)   //\n           || s == StatusCode::kPoke                //\n        ;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::Status(const StatusOr<NoneType>& status_or) noexcept : Status{status_or.status()}\n{\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status& Status::operator=(const StatusOr<NoneType>& status_or) noexcept\n{\n    *this = status_or.status();\n    return *this;\n}\n\n}  // namespace batt\n\n#endif  // BATTERIES_STATUS_IMPL_HPP",
  "refid": "status__impl_8hpp",
  "static": false,
  "strong": false,
  "title": "batteries/status_impl.hpp",
  "url": "/_autogen/Files/status__impl_8hpp/#file-status-impl.hpp",
  "visibility": "public"
}