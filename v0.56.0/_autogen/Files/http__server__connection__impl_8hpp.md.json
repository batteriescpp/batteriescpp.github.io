{
  "abstract": false,
  "anchor": "#file-http-server-connection-impl.hpp",
  "category": "files",
  "const": false,
  "defines": [
    {
      "abstract": false,
      "anchor": "#define-batteries-http-http-server-connection-impl-hpp",
      "category": "defines",
      "const": false,
      "definition": "",
      "explicit": false,
      "fullname": "BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP",
      "hasDetails": false,
      "inline": false,
      "kind": "define",
      "language": "cpp",
      "location": {
        "bodyFile": "batteries/http/http_server_connection_impl.hpp",
        "bodyStart": 6,
        "column": 9,
        "file": "batteries/http/http_server_connection_impl.hpp",
        "line": 6
      },
      "name": "BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP",
      "override": false,
      "refid": "http__server__connection__impl_8hpp_1a8d413bc2b029f8c1c916a2966ae09a39",
      "static": false,
      "strong": false,
      "title": "BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP",
      "url": "/_autogen/Files/http__server__connection__impl_8hpp/#define-batteries-http-http-server-connection-impl-hpp",
      "visibility": "public"
    }
  ],
  "definition": "",
  "explicit": false,
  "fullname": "batteries/http/http_server_connection_impl.hpp",
  "hasAdditionalMembers": false,
  "hasDetails": false,
  "includes": "<batteries/http/http_message_info.hpp>",
  "inline": false,
  "kind": "file",
  "language": "cpp",
  "location": {
    "column": 0,
    "file": "batteries/http/http_server_connection_impl.hpp",
    "line": 0
  },
  "name": "batteries/http/http_server_connection_impl.hpp",
  "namespaces": [
    {
      "anchor": "",
      "category": "namespaces",
      "fullname": "batt",
      "kind": "namespace",
      "language": "cpp",
      "name": "batt",
      "refid": "namespacebatt",
      "title": "batt",
      "url": "/_autogen/Namespaces/namespacebatt/",
      "visibility": "public"
    }
  ],
  "override": false,
  "parent": {
    "anchor": "#dir-batteries/http",
    "category": "dirs",
    "fullname": "batteries/http",
    "kind": "dir",
    "language": "",
    "name": "batteries/http",
    "refid": "dir_9b7f6a4fee6d4e32025f5ad2daa53829",
    "title": "batteries/http",
    "url": "/_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/#dir-batteries/http",
    "visibility": "public"
  },
  "parentBreadcrumbs": [
    {
      "anchor": "#dir-batteries",
      "category": "dirs",
      "fullname": "batteries",
      "kind": "dir",
      "language": "",
      "name": "batteries",
      "refid": "dir_af4e2857c92a31b60ebae85174ebeccb",
      "title": "batteries",
      "url": "/_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#dir-batteries",
      "visibility": "public"
    },
    {
      "anchor": "#dir-batteries/http",
      "category": "dirs",
      "fullname": "batteries/http",
      "kind": "dir",
      "language": "",
      "name": "batteries/http",
      "refid": "dir_9b7f6a4fee6d4e32025f5ad2daa53829",
      "title": "batteries/http",
      "url": "/_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/#dir-batteries/http",
      "visibility": "public"
    }
  ],
  "programlisting": "//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP\n\n#include <batteries/http/http_message_info.hpp>\n\n#include <boost/date_time/posix_time/posix_time.hpp>\n\nnamespace batt {\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ void HttpServerConnection::spawn(\n    boost::asio::ip::tcp::socket&& socket, HttpRequestDispatcherFactoryFn&& request_dispatcher_factory,\n    const HttpServerSettings& settings) noexcept\n{\n    Task::spawn(Task::current().get_executor(), [socket = std::move(socket),\n                                                 request_dispatcher_factory =\n                                                     std::move(request_dispatcher_factory),\n                                                 settings]() mutable {\n        HttpServerConnection connection{std::move(socket), std::move(request_dispatcher_factory), settings};\n\n        connection.start();\n        connection.join();\n    });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpServerConnection::HttpServerConnection(\n    boost::asio::ip::tcp::socket&& socket, HttpRequestDispatcherFactoryFn&& request_dispatcher_factory,\n    const HttpServerSettings& settings) noexcept\n    : socket_{std::move(socket)}\n    , request_dispatcher_factory_{std::move(request_dispatcher_factory)}\n    , settings_{settings}\n    , request_processor_tokens_{this->settings_.max_requests_per_connection}\n    , idle_timer_{this->socket_.get_executor()}\n    , input_buffer_{this->settings_.connection_buffer_size}\n{\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpServerConnection::~HttpServerConnection() noexcept\n{\n    this->halt();\n    this->join();\n\n    BATT_VLOG(1) << \"HttpServerConnection::~HttpServerConnection() Done\";\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr<boost::asio::ip::tcp::endpoint> HttpServerConnection::local_endpoint()\n    const noexcept\n{\n    boost::system::error_code ec;\n    auto ep = this->socket_.local_endpoint(ec);\n    BATT_REQUIRE_OK(ec);\n    return ep;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr<boost::asio::ip::tcp::endpoint> HttpServerConnection::remote_endpoint()\n    const noexcept\n{\n    boost::system::error_code ec;\n    auto ep = this->socket_.remote_endpoint(ec);\n    BATT_REQUIRE_OK(ec);\n    return ep;\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::start()\n{\n    BATT_VLOG(1) << \"HttpServerConnection::run() entered\";\n\n    auto executor = Task::current().get_executor();\n\n    BATT_CHECK(!this->fill_input_buffer_task_);\n    this->fill_input_buffer_task_.emplace(executor, [this] {\n        this->fill_input_buffer().IgnoreError();\n    });\n\n    BATT_CHECK(!this->read_requests_task_);\n    this->read_requests_task_.emplace(executor, [this] {\n        this->read_requests().IgnoreError();\n    });\n\n    BATT_CHECK(!this->send_responses_task_);\n    this->send_responses_task_.emplace(executor, [this] {\n        this->send_responses().IgnoreError();\n    });\n\n    BATT_CHECK(!this->idle_connection_timeout_task_);\n    this->idle_connection_timeout_task_.emplace(executor, [this] {\n        this->idle_connection_timeout_task_main();\n    });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::halt()\n{\n    this->idle_shutdown();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::join()\n{\n    const auto join_subtask = [](Optional<Task>& subtask) {\n        if (subtask) {\n            subtask->join();\n            subtask = None;\n        }\n    };\n\n    join_subtask(this->fill_input_buffer_task_);\n    join_subtask(this->read_requests_task_);\n    join_subtask(this->send_responses_task_);\n    join_subtask(this->idle_connection_timeout_task_);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::fill_input_buffer()\n{\n    auto on_exit = finally([this] {\n        BATT_VLOG(1) << \"HttpServerConnection::fill_input_buffer() exiting\"\n                     << BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint());\n\n        this->input_buffer_.close_for_write();\n    });\n\n    for (;;) {\n        BATT_VLOG(1) << \"Reading from socket\";\n\n        // Allocate some space in the input buffer for incoming data.\n        //\n        StatusOr<SmallVec<MutableBuffer, 2>> buffer = this->input_buffer_.prepare_at_least(1);\n        BATT_REQUIRE_OK(buffer);\n\n        // Read data from the socket into the buffer.\n        //\n        auto n_read = Task::await<IOResult<usize>>([&](auto&& handler) {\n            this->socket_.async_read_some(*buffer, BATT_FORWARD(handler));\n        });\n        BATT_REQUIRE_OK(n_read) << \"(HttpServerConnection::fill_input_buffer)\";\n\n        BATT_VLOG(1) << \"Read \" << *n_read << \" bytes; committing to buffer\";\n\n        this->activity_.fetch_add(1);\n\n        // Assuming we were successful, commit the read data so it can be consumed by the parser task.\n        //\n        this->input_buffer_.commit(*n_read);\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::read_requests()\n{\n    auto on_exit = finally([this] {\n        BATT_VLOG(1) << \"HttpServerConnection::read_requests() exiting\"\n                     << BATT_INSPECT(this->local_endpoint()) << BATT_INSPECT(this->remote_endpoint());\n\n        // Unblock all other tasks by closing anything they might wait on.\n        //\n        this->activity_.close();\n        this->halt_idle_timeout_task();\n        this->input_buffer_.close_for_read();\n        this->shutdown_request_queue();\n        this->response_queue_.close();\n\n        boost::system::error_code ec;\n        this->socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_receive, ec);\n    });\n\n    for (;;) {\n        BATT_VLOG(1) << \"Awaiting request\";\n\n        //----- --- -- -  -  -   -\n        // If there are no request processor subtasks asking for work to do, then try to start one.\n        //\n        this->try_spawn_request_processor();\n\n        //----- --- -- -  -  -   -\n        // Wait for an available request processor to ask for work by queuing a request/response object pair.\n        //\n        using RequestResponseTuple = std::tuple<Pin<HttpRequest>, Pin<HttpResponse>>;\n\n        BATT_ASSIGN_OK_RESULT(RequestResponseTuple request_response, this->request_queue_.await_next());\n\n        Pin<HttpRequest> request;\n        Pin<HttpResponse> response;\n        std::tie(request, response) = std::move(request_response);\n\n        BATT_CHECK_NOT_NULLPTR(request);\n        BATT_CHECK_NOT_NULLPTR(response);\n\n        // By default, we will mark the request and response as 'closed' so that the processor task who owns\n        // them isn't indefinitely blocked.  These FinalAct objects will be cancelled once an alternate code\n        // path for updating the state has been entered.\n        //\n        auto close_request = batt::finally([&request] {\n            request->close();\n        });\n        auto close_response = batt::finally([&response] {\n            response->close();\n        });\n\n        //----- --- -- -  -  -   -\n        // We're only interested in the request; send the pinned response ref to the response writer task\n        // (send_responses).  NOTE: The fact that there is only one task per connection inside read_requests\n        // guarantees that the order of requests and responses will always match!\n        //\n        BATT_REQUIRE_OK(this->response_queue_.push(std::move(response)));\n        close_response.cancel();\n\n        BATT_VLOG(1) << \"Got request/response pair\";\n\n        //----- --- -- -  -  -   -\n        // Read a single HTTP request message from the input buffer.\n        //\n        pico_http::Request request_message;\n        StatusOr<i32> message_length = this->read_next_request(request_message);\n        BATT_REQUIRE_OK(message_length)\n            << LogLevel::kError << \"Failed to read/parse request (HttpServerConnection::read_requests)\";\n\n        BATT_VLOG(1) << \"Parsed response header\";\n\n        // Extract connection-level information about the request.\n        //\n        HttpMessageInfo request_info(request_message);\n        if (!request_info.is_valid()) {\n            return StatusCode::kInvalidArgument;\n        }\n\n        //----- --- -- -  -  -   -\n        // Request state is now kInitialized.\n        //\n        close_request.cancel();\n        request->state().set_value(HttpRequest::kInitialized);\n\n        //----- --- -- -  -  -   -\n        // Pass control over to the request processor task who owns `request` and wait for it to signal it is\n        // done reading the message headers/url/etc.\n        //\n        Status message_consumed = request->await_set_message(request_message);\n        BATT_REQUIRE_OK(message_consumed) << LogLevel::kError;\n\n        BATT_VLOG(1) << \"Done reading request header\";\n        this->activity_.fetch_add(1);\n\n        // The consume is done with the message; consume it and move on to the body.\n        //\n        this->input_buffer_.consume(*message_length);\n\n        //----- --- -- -  -  -   -\n        // Create an HttpData object to read the body of the request.  Hand control over to the request\n        // processor task and wait for it to signal it is done.\n        //\n        HttpData request_data{request_info.get_data(this->input_buffer_)};\n        request->await_set_data(request_data).IgnoreError();\n        //\n        BATT_VLOG(1) << \"Done reading request body\";\n        //\n        // We must not touch `request` after `await_set_data` returns!\n\n        // Whether or not we keep the connection alive, acknowledge the response when we exit the loop.\n        //\n        auto on_scope_exit = batt::finally([this] {\n            this->request_count_.fetch_add(1);\n        });\n\n        this->activity_.fetch_add(1);\n\n        //----- --- -- -  -  -   -\n        // If we are going to keep the connection alive, we must consume any extra data that wasn't read\n        // by the request processor.  Otherwise we just close the socket.\n        //\n        if (request_info.keep_alive) {\n            BATT_VLOG(1) << \"Request is Keep-Alive\";\n            Status data_consumed = std::move(request_data) | seq::consume();\n            BATT_REQUIRE_OK(data_consumed) << LogLevel::kError;\n        } else {\n            BATT_VLOG(1) << \"Response is Close; closing socket\";\n            break;\n        }\n    }\n\n    return OkStatus();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::try_spawn_request_processor() noexcept\n{\n    if (this->request_queue_.size() == 0) {\n        // Each request processor task must hold a token; this limits the total number of tasks and the\n        // pipelined request depth.  Try to acquire 1 token; if this succeeds, then spawn a request\n        // processor task.\n        //\n        StatusOr<Grant> maybe_token = this->request_processor_tokens_.issue_grant(1, WaitForResource::kFalse);\n\n        if (maybe_token.ok()) {\n            Task::spawn(Task::current().get_executor(), [this, token = std::move(*maybe_token)]() mutable {\n                this->process_requests(std::move(token)).IgnoreError();\n            });\n        }\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr<i32> HttpServerConnection::read_next_request(pico_http::Request& request)\n{\n    BATT_VLOG(1) << \"HttpServerConnection::read_next_request\";\n\n    i32 result = 0;\n    usize min_to_fetch = 1;\n    for (;;) {\n        StatusOr<SmallVec<ConstBuffer, 2>> fetched = this->input_buffer_.fetch_at_least(min_to_fetch);\n        BATT_REQUIRE_OK(fetched) << \"(HttpServerConnection::read_next_request)\";\n\n        auto& buffers = *fetched;\n        const usize n_bytes_fetched = boost::asio::buffer_size(buffers);\n\n        BATT_CHECK(!buffers.empty());\n        result = request.parse(buffers.front());\n\n        if (result == pico_http::kParseIncomplete) {\n            min_to_fetch = std::max(min_to_fetch + 1, n_bytes_fetched);\n            continue;\n        }\n\n        if (result == pico_http::kParseFailed) {\n            auto chunk = buffers.front();\n            BATT_VLOG(1) << \"Failed to parse http message: \"\n                         << c_str_literal(std::string_view{(const char*)chunk.data(), chunk.size()});\n            return {StatusCode::kInternal};\n        }\n\n        BATT_CHECK_GT(result, 0);\n        return result;\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::idle_connection_timeout_task_main()\n{\n    for (;;) {\n        const u64 activity_before = this->activity_.get_value();\n\n        // IMPORTANT: we must set the timer and _then_ check the halt_requested_ flag (the reverse of the\n        // order in which they are set when shutting down), so we will never miss a shutdown.\n        //\n        boost::system::error_code ec;\n        this->idle_timer_.expires_from_now(\n            boost::posix_time::milliseconds(this->settings_.idle_connection_timeout_ms), ec);\n\n        BATT_VLOG(1) << BATT_INSPECT(activity_before) << \"; Waiting for \"\n                     << this->settings_.idle_connection_timeout_ms << \"ms\"\n                     << BATT_INSPECT(this->idle_timer_.expires_at());\n\n        if (ec) {\n            BATT_VLOG(1) << \"Error setting idle timer: \" << BATT_INSPECT(to_status(ec));\n            break;\n        }\n\n        if (this->halt_requested_.get_value()) {\n            break;\n        }\n\n        IOResult<> result = Task::await<IOResult<>>([this](auto&& handler) {\n            this->idle_timer_.async_wait(BATT_FORWARD(handler));\n        });\n\n        if (!result.ok() || this->halt_requested_.get_value()) {\n            BATT_VLOG(1) << \"Idle timer cancelled: \" << BATT_INSPECT(result)\n                         << BATT_INSPECT(this->halt_requested_);\n            break;\n        }\n\n        if (this->activity_.get_value() == activity_before) {\n            BATT_VLOG(1) << \"Closing idle connection\" << BATT_INSPECT(this->remote_endpoint())\n                         << BATT_INSPECT(this->local_endpoint());\n            this->idle_shutdown();\n            break;\n        }\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::halt_idle_timeout_task() noexcept\n{\n    // IMPORTANT: halt_requested_ flag must be set before cancelling the timer.\n    //\n    this->halt_requested_.set_value(true);\n\n    boost::system::error_code ec;\n\n    this->idle_timer_.cancel(ec);\n    this->idle_timer_.expires_from_now(boost::posix_time::seconds(-1), ec);\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::idle_shutdown() noexcept\n{\n    boost::system::error_code ec;\n    this->socket_.close(ec);\n    //----- --- -- -  -  -   -\n    // Do NOT close the token pool, since we never do a blocking issue_grant during normal operation.\n    //  this->request_processor_tokens_.close();\n    //----- --- -- -  -  -   -\n    this->input_buffer_.close();\n    this->shutdown_request_queue();\n    this->shutdown_response_queue();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::process_requests(Grant token)\n{\n    const auto task_id = Task::current_id();\n\n    BATT_VLOG(1) << \"HttpServerConnection::process_requests Entered\" << BATT_INSPECT(task_id);\n\n    auto on_scope_exit = batt::finally([&] {\n        BATT_VLOG(1) << \"HttpServerConnection::process_requests Exiting\" << BATT_INSPECT(task_id);\n    });\n\n    BATT_CHECK_EQ(token.size(), 1u);\n    BATT_CHECK_EQ(token.get_issuer(), std::addressof(this->request_processor_tokens_));\n\n    BATT_ASSIGN_OK_RESULT(HttpRequestDispatcherFn request_dispatcher, this->request_dispatcher_factory_());\n\n    for (;;) {\n        HttpRequest request;\n        HttpResponse response;\n\n        Status push_status = this->request_queue_.push(make_pin(&request), make_pin(&response));\n        BATT_REQUIRE_OK(push_status);\n\n        BATT_VLOG(1) << \"HttpServerConnection::process_requests: Waiting for message\"\n                     << BATT_INSPECT(task_id);\n\n        StatusOr<pico_http::Request&> request_message = request.await_message();\n        BATT_REQUIRE_OK(request_message)\n            << \"HttpServerConnection::process_requests: Failed to receive HTTP request message\";\n\n        BATT_VLOG(1) << \"HttpServerConnection::process_requests: Got request; dispatching\"\n                     << BATT_INSPECT(task_id);\n\n        Status dispatch_status = request_dispatcher(request, response);\n        BATT_REQUIRE_OK(dispatch_status);\n    }\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::send_responses()\n{\n    BATT_VLOG(1) << \"HttpServerConnection::send_responses Entered\";\n\n    auto on_scope_exit = batt::finally([&] {\n        BATT_VLOG(1) << \"HttpServerConnection::send_responses Exiting\";\n\n        this->shutdown_request_queue();\n        this->shutdown_response_queue();\n\n        boost::system::error_code ec;\n        this->socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    });\n\n    for (;;) {\n        BATT_VLOG(1) << \"HttpServerConnection::send_responses: Waiting for request processor\";\n\n        BATT_ASSIGN_OK_RESULT(Pin<HttpResponse> response, this->response_queue_.await_next());\n\n        BATT_VLOG(1) << \"HttpServerConnection::send_responses: Waiting for response\";\n\n        StatusOr<pico_http::Response&> response_message = response->await_message();\n        BATT_REQUIRE_OK(response_message);\n\n        HttpMessageInfo response_info{*response_message};\n        if (!response_info.is_valid()) {\n            response_info.keep_alive = false;\n            if (!response_info.is_valid()) {\n                BATT_LOG_WARNING() << \"Invalid response message: \" << response_info;\n                break;\n            }\n        }\n\n        this->activity_.fetch_add(1);\n\n        BATT_VLOG(1) << \"HttpServerConnection::send_responses: Got response; serializing\";\n\n        Status status = response->serialize(this->socket_);\n        BATT_REQUIRE_OK(status);\n\n        BATT_VLOG(1) << \"HttpServerConnection::send_responses: Finished serializing response\";\n\n        this->activity_.fetch_add(1);\n\n        if (!response_info.keep_alive) {\n            break;\n        }\n    }\n\n    return OkStatus();\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::shutdown_request_queue()\n{\n    BATT_VLOG(1) << \"Shutting down request queue\";\n\n    this->request_queue_.close();\n\n    this->request_queue_.drain([](std::tuple<Pin<HttpRequest>, Pin<HttpResponse>>& item) {\n        Pin<HttpRequest> request;\n        Pin<HttpResponse> response;\n        std::tie(request, response) = std::move(item);\n\n        BATT_CHECK_NOT_NULLPTR(request);\n        BATT_CHECK_NOT_NULLPTR(response);\n\n        request->close();\n        response->close();\n    });\n}\n\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::shutdown_response_queue()\n{\n    BATT_VLOG(1) << \"Shutting down response queue\";\n\n    this->response_queue_.close();\n\n    this->response_queue_.drain([](Pin<HttpResponse>& response) {\n        BATT_CHECK_NOT_NULLPTR(response);\n        response->close();\n    });\n}\n\n}  //namespace batt\n\n#endif  // BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP",
  "refid": "http__server__connection__impl_8hpp",
  "static": false,
  "strong": false,
  "title": "batteries/http/http_server_connection_impl.hpp",
  "url": "/_autogen/Files/http__server__connection__impl_8hpp/#file-http-server-connection-impl.hpp",
  "visibility": "public"
}