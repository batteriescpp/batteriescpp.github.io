{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-batteries-c","title":"Welcome to Batteries C++!","text":"<p>Ever get the feeling that there's a lot of nice stuff in other programming languages that was just left out of C++?  Like the batteries weren't included?</p> <p>Batteries is a library designed to fix that!</p> <p>Features:</p> <ul> <li>Header-only: makes including/using in your program super easy</li> <li>A la carte: only include what you need, don't pay for the rest</li> <li>Many useful facilities, including:<ul> <li>Enhanced Runtime Checks/Assertions</li> <li>Composable Sequences (like Java Streams or Rust Iter)</li> <li>Fast, User-Space Asynchronous Tasks</li> <li>batt::case_of, An Ergonomic Replacement For std::visit</li> <li>Support for Exception-Free Coding in C++</li> </ul> </li> </ul> <p>\u00a9 2019-2023 Anthony Paul Astolfi, et al.</p>"},{"location":"assert.hpp/","title":"&lt;batteries/assert.hpp&gt; : Fatal error check macros","text":"<p>File Reference</p> <p>This header includes enhanced drop-in replacements for standard <code>assert()</code> statements.  All the supported assertion types have a version (<code>BATT_CHECK*</code>) which is always on, even in optimized/release builds, and a version (<code>BATT_ASSERT*</code>) that is automatically stripped out of non-Debug builds.</p> <p>NOTE: Batteries assumes the build type is Release/Optimized if the macro <code>NDEBUG</code> is defined; in this case, all <code>BATT_ASSERT*</code> statements will be stripped out of the compilation. </p>"},{"location":"assert.hpp/#advantages","title":"Advantages","text":""},{"location":"assert.hpp/#informative-messages","title":"Informative Messages","text":"<p>Using a more descriptive assertion macro allows your program to print a more informative error message if an assertion does fail.  For example, you might use the statement:</p> <p><pre><code>assert(x == 1);\n</code></pre> But if this assertion fails, all you know is that x was not equal to 1.  What was it equal to?!  Batteries will answer this question automatically if you write:</p> <pre><code>BATT_ASSERT_EQ(x, 1);\n</code></pre> <p>You don't have to worry about making sure that the types you're comparing support <code>std::ostream</code> output to take advantage of this feature; Batteries will automatically do its best to print out something that might be useful, regardless of type.</p> <p>If you want to take advantage of this feature explicitly (when writing some arbitrary type to a stream), you can use:</p> <pre><code>#include &lt;batteries/assert.hpp&gt;\nstruct MyCustomType {\nint x;\nint y;\n};\nint main() {\nMyCustomType x;\n// Works even though MyCustomType has no ostream operator&lt;&lt;!\n//\nstd::cout &lt;&lt; batt::make_printable(x);\nreturn 0;\n}\n</code></pre>"},{"location":"assert.hpp/#stack-traces","title":"Stack Traces","text":"<p>Full stack traces, with source symbols if available, are automatically printed whenever an assertion failure happens.</p>"},{"location":"assert.hpp/#always-on-checks","title":"Always On Checks","text":"<p><code>BATT_CHECK_*</code> allows you to write assertions that are guaranteed never to be compiled out of your program, even in optimized/release builds. - All <code>BATT_CHECK_*</code>/<code>BATT_ASSERT_*</code> statements support <code>operator&lt;&lt;</code> like <code>std::ostream</code> objects, so that you can add more contextual information to help diagnose an assertion failure.  Example:</p> <pre><code>int y = get_y();\nint z = get_z();\nint x = (y + z) / 2;\nBATT_ASSERT_EQ(x, 1) &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; \", z = \" &lt;&lt; z &lt;&lt; \" (expected the average of y and z to be 1)\";\n</code></pre>"},{"location":"assert.hpp/#low-overhead","title":"Low-Overhead","text":"<p>Diagnostic output expressions added via <code>&lt;&lt;</code> are never evaluated unless the assertion actually fails, so don't worry if they are somewhat expensive.</p>"},{"location":"assert.hpp/#prevent-code-rot","title":"Prevent Code Rot","text":"<p>Even on Release builds, all expressions that appear in a <code>BATT_ASSERT_*</code> statement will be compiled, so you don't have to worry about breaking Debug builds when compiling primarily using optimization.</p>"},{"location":"assert.hpp/#quick-reference","title":"Quick Reference","text":""},{"location":"assert.hpp/#logical-assertions","title":"Logical Assertions","text":"Debug-only Always Enabled Description BATT_ASSERT(cond) BATT_CHECK(cond) Assert that <code>bool{cond} == true</code> BATT_ASSERT_IMPLES(p, q) BATT_CHECK_IMPLIES(p, q) Assert that if <code>(p)</code> is true, then so is <code>(q)</code> (i.e., <code>(!(p) || (q))</code>) BATT_ASSERT_NOT_NULLPTR(x) BATT_CHECK_NOT_NULLPTR(x) Assert that <code>(x) != nullptr</code>"},{"location":"assert.hpp/#comparison-assertions","title":"Comparison Assertions","text":"Debug-only Always Enabled Description BATT_ASSERT_EQ(a, b) BATT_CHECK_EQ(a, b) Assert that <code>(a) == (b)</code> BATT_ASSERT_NE(a, b) BATT_CHECK_NE(a, b) Assert that <code>(a) != (b)</code> BATT_ASSERT_LT(a, b) BATT_CHECK_LT(a, b) Assert that <code>(a) &lt; (b)</code> BATT_ASSERT_GT(a, b) BATT_CHECK_GT(a, b) Assert that <code>(a) &gt; (b)</code> BATT_ASSERT_LE(a, b) BATT_CHECK_LE(a, b) Assert that <code>(a) &lt;= (b)</code> BATT_ASSERT_GE(a, b) BATT_CHECK_GE(a, b) Assert that <code>(a) &gt;= (b)</code>"},{"location":"assert.hpp/#otheradvanced","title":"Other/Advanced","text":"Name Description BATT_PANIC() Forces the program to exit immediately, printing a full stack trace and any message <code>&lt;&lt;</code>-inserted to the <code>BATT_PANIC()</code> statement. Example:<code>BATT_PANIC() &lt;&lt; \"Something has gone horribly wrong!  x = \" &lt;&lt; x;</code> BATT_UNREACHABLE() Statement that tells the compiler this point in the code should be unreachable; for example, it is right after a call to <code>std::abort()</code> or <code>std::terminate()</code>.  Use this to silence spurious warnings about dead code. BATT_NORETURN When added to a function declaration (before the return type), tells the compiler that a function never returns.  Use this to silence spurious warnings. Example: <code>BATT_NORETURN void print_stuff_and_exit();</code> batt::make_printable(obj) Makes any expression printable, even if it doesn't have an overloaded  <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, T)</code> .  If the type of <code>obj</code> does define such an operator, however, that will be invoked when using <code>batt::make_printable</code>.  <code>obj</code> is passed/forwarded by reference only; no copy of the original object/value is made."},{"location":"async/","title":"&lt;batteries/async/...&gt; : Async Tasks and I/O","text":""},{"location":"async/#quick-reference","title":"Quick Reference","text":"Name Description batt::Channel&lt;T&gt; Unbuffered single-producer/single-consumer (SPSC) communcation channel between Tasks batt::Future&lt;T&gt; An asynchronously generated value of type T batt::Grant Counted resource allocation/sychronization (similar to counting semaphore) batt::Latch&lt;T&gt; A write-once, single-value synchronized container.  Similar to Future/Promise, but guaranteed not to alloc and has no defined copy/move semantics. batt::Mutex&lt;T&gt; Mutual exclusion for use with batt::Task batt::Queue&lt;T&gt; Unbounded multi-producer/multi-consumer (MPMC) FIFO queue. batt::Task Lightweight user-space thread for async I/O and high-concurrency programs. batt::Watch&lt;T&gt; Atomic variable with synchronous and asynchronous change notification. &lt;batteries/async/handler.hpp&gt; Utilities for managing asynchronous callback handlers"},{"location":"async/#batttask","title":"batt::Task","text":"<p>API Reference</p> <p>A <code>batt::Task</code> is similar to <code>std::thread</code>, but much lighter weight.  Like <code>std::thread</code>, each <code>batt::Task</code> has an independent call stack.  Unlike <code>std::thread</code>, however, <code>batt::Task</code> is implemented 100% in user space, and does not support preemption.  This makes the context swap overhead of <code>batt::Task</code> very low in comparison to a <code>std::thread</code>, which means it is possible to have many more <code>batt::Task</code> instances without losing efficiency.</p>"},{"location":"async/#asynchronous-io","title":"Asynchronous I/O","text":"<p>The primary use case for <code>batt::Task</code> is to support asynchronous I/O for efficiency, while retaining the programming model of traditional threads.  This makes asynchronous code much easier to write, read, debug, and maintain than equivalent code using asynchronous continuation handlers (in the style of Boost Asio or Node.js).</p> <p>An important feature of <code>batt::Task</code> to highlight is the static method batt::Task::await.  This method allows the use of asynchronous continuation handler-based APIs (e.g., Boost Asio) in a \"blocking\" style.  Example:</p> <pre><code>#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;boost/asio/ip/tcp.hpp&gt;\n// Some function to get a server endpoint to which \n// to connect.\n//\nextern boost::asio::ip::tcp::endpoint get_server_endpoint();\nint main() {\n// Create an io_context to schedule our Task and manage \n// all asynchronous I/O.\n//\nboost::asio::io_context io;\n// Create a TCP/IP socket; we will use this to connect \n// to the server endpoint.\n//\nboost::asio::ip::tcp::socket s{io};\n// Launch a task to act as our client.\n//\nbatt::Task client_task{io.get_executor(), /*body_fn=*/[&amp;] {\n// Connect to the server.  batt::Task::await will not \n// return until the handler passed to `async_connect`\n// has been invoked.\n//\nboost::system::error_code ec = batt::Task::await&lt;boost::system::error_code&gt;(\n[&amp;](auto&amp;&amp; handler){\ns.async_connect(get_server_endpoint(), BATT_FORWARD(handler));\n});\nBATT_CHECK(!ec);\n// Interact with the server via the connected socket...\n}};\n// VERY IMPORTANT: without this line, nothing will happen!\n//\nio.run();\nreturn 0;\n}\n</code></pre> <p>All continuation handler based async APIs require a callback (the continuation handler).  In order to simplify the code, we want to \"pause\" our code until the I/O is finished, but the async API, <code>async_connect</code> in this case, will return immediately.  batt::Task::await gives us access to the \"continuation\" of the task, in this case everything that happens after <code>await</code> returns, as a handler that can be passed directly to <code>async_connect</code>.  All the context swapping, scheduling, memory managment, and synchronization is handled automatically by <code>batt::Task</code>, allowing the programmer to focus on the application's natural flow of control, and not the mechanics used to implement this flow.</p>"},{"location":"async/#task-scheduling-and-priorities","title":"Task Scheduling and Priorities","text":"<p>When a <code>batt::Task</code> is created, it is passed a Boost Asio executor object.  All execution of task code on the task's stack will happen via <code>boost::asio::dispatch</code> or <code>boost::asio::post</code> using this executor.  NOTE: this means if, for example, you use the executor from a <code>boost::asio::io_context</code> to create a task, that task will not run unless you call <code>io_context::run()</code>!</p> <p>A running <code>batt::Task</code> is never preempted by another task.  Instead it must yield control of the current thread to allow another task to run.  There are four ways to do this:</p> <ul> <li>batt::Task::join()</li> <li>batt::Task::await()</li> <li>batt::Task::yield()</li> <li>batt::Task::sleep()</li> </ul> <p>WARNING: if you use a kernel or standard library synchronization mechanism or blocking call, for example <code>std::mutex</code>, from inside a <code>batt::Task</code>, that task WILL NOT YIELD!  This is why the Batteries Async library contains its own synchronization primitives, like <code>batt::Watch</code>, <code>batt::Queue</code>, and <code>batt::Mutex</code>.  All of these primitives are implemented on top one or more of the four methods enumerated above.</p> <p>Each <code>batt::Task</code> is assigned a scheduling priority, which is a signed 32-bit integer.  Greater values of the priority int mean more urgent priority; lesser values mean less urgency.  Even though tasks don't interrupt each other (i.e. preemption), they sometimes perform actions that cause another task to move from a \"waiting\" state to a \"ready to run\" state.  For example, one task may be blocked inside a call to <code>batt::Watch&lt;T&gt;::await_equal</code>, and another task (let's call it the \"notifier\") may call <code>batt::Watch&lt;T&gt;::set_value</code>, activating the first task (let's call it the \"listener\").  As noted above, the newly activated (\"listener\") task will be run via <code>boost::asio::dispatch</code> or <code>boost::asio::post</code>.  Which mechanism is used depends on the relative priority of the two tasks:</p> <ul> <li>If the \"notifier\" has a higher (numerically greater) priority value than the \"listener\", the \"listener\" is scheduled via <code>boost::asio::post</code>.</li> <li>Otherwise, the \"notifier\" is immediately suspended and re-scheduled via <code>boost::asio::post</code>; then the \"listener\" is scheduled via <code>boost::asio::dispatch</code>.</li> </ul> <p>In any case, activating another task will not cause a running task to go from a \"running\" state to a \"waiting\" state.  It may however \"bounce\" it to another thread, or to be pushed to the back of an execution queue.  This only matters when there are more tasks ready to run than there are available threads for a given ExecutionContext: higher priority tasks are scheduled before lower priority ones in general.</p> <p>NOTE: you may still end up with a priority inversion situation when multiple tasks with different priorities are <code>boost::asio::post</code>-ed to the same queue.  In this case, there is no mechanism currently for re-ordering the tasks to give preference based on priority.</p> <p>Overall, it is best to consider priority \"best-effort\" rather than a guarantee of scheduling order.  It should be used for performance tuning, not to control execution semantics in a way that affects the functional behavior of a program.</p>"},{"location":"async/#synchronization-primitives","title":"Synchronization Primitives","text":""},{"location":"async/#battwatch","title":"batt::Watch","text":"<p>API Reference</p> <p>Watch is the simplest of Batteries' synchronization mechanisms.  It is like an atomic variable with the ability to wait on changes.  This is similar to a Futex, and is used to implement the other synchronization primitives at a low level.</p>"},{"location":"async/#battmutex","title":"batt::Mutex","text":"<p>API Reference</p> <p>Mutex provides mutual exclusion to an object.  It is based on batt::Watch, so it is fair, but it will not scale well as the number of tasks/threads attempting to acquire a Mutex concurrently.  It is up to the application programmer to avoid high levels of contention for a single Mutex.</p> <p>An instance of <code>batt::Mutex&lt;T&gt;</code> may be locked in a few different ways:</p>"},{"location":"async/#lock-via-guard-class-similar-to-stdunique_lock","title":"Lock via guard class (similar to std::unique_lock)","text":"<pre><code>batt::Mutex&lt;std::string&gt; s;\n{\nbatt::Mutex&lt;std::string&gt;::Lock lock{s};\n// Once the lock is acquired, you can access the protected object\n// via pointer...\n//\nstd::string* ptr = lock.get();\n// ... or by reference ...\n//\nstd::string&amp; ref = lock.value();\n// ... by operator* like a smart pointer...\n//\nstd::string&amp; ref2 = *lock;\n// ... or you can access its members via operator-&gt;:\n//\nconst char* cs = lock-&gt;c_str();\n}\n// The lock is released when the guard class goes out of scope.\n</code></pre>"},{"location":"async/#lock-via-lock-method","title":"Lock via lock() method","text":"<p>Equivalently, an instance of <code>batt::Mutex&lt;T&gt;::Lock</code> can be created via the <code>lock()</code> method:</p> <pre><code>batt::Mutex&lt;std::string&gt; s;\n{\nauto locked = s.lock();\nstatic_assert(\nstd::is_same_v&lt;decltype(locked), batt::Mutex&lt;std::string&gt;::Lock&gt;, \"It is nice to use auto in this case!\");\n}\n</code></pre> <p>As the second example implies, <code>batt::Mutex&lt;T&gt;::Lock</code> is a movable type (however it is non-copyable).</p>"},{"location":"async/#run-function-with-lock-acquired","title":"Run function with lock acquired","text":"<pre><code>batt::Mutex&lt;std::string&gt; s{\"Some string\"};\ns.with_lock([](std::string&amp; locked_s) {\nlocked_s += \" and then some!\";\n});\n</code></pre>"},{"location":"async/#lock-free-access-to-t","title":"Lock-free access to T","text":"<p>Even though access to the protected object of type <code>T</code> mostly happens via a lock, <code>batt::Mutex</code> supports types with a partial interface that is thread-safe without locking.  Example:</p> <pre><code>// Since lock-free access to a type is by definition\n// a subset of all access to that type, we define\n// a base class containing all lock-free fields and\n// member functions.\n//\nstruct MyStateBase {\nexplicit MyStateBase(std::string&amp;&amp; init_val) : initial_value{std::move(init_val)}\n{}\n// This is safe to access concurrently because it is\n// const.\n//\nconst std::string initial_value;\n};\nstruct MyState : MyStateBase {\n// IMPORTANT: this member type alias tells batt::Mutex to\n// enable the `no_lock()` method/feature.\n//\nusing ThreadSafeBase = MyStateBase;\nexplicit MyState(std::string&amp;&amp; init_val)\n: MyStateBase{init_val}\n, current_value{init_val}\n{}\n// Because this field is non-const, it must be accessed\n// while holding a lock.\n//\nstd::string current_value;\n};\nbatt::Mutex&lt;MyState&gt; state{\"initial\"};\n// batt::Mutex::nolock returns a reference to the \n// ThreadSafeBase type declared in MyState.\n//\nMyStateBase&amp; base = state.no_lock();\n// No lock needed to read a const value.\n//\nstd::cout &lt;&lt; \"initial value = \" &lt;&lt; base.initial_value &lt;&lt; std::endl;\n// We still need to acquire the lock to access the derived\n// class.\n//\nstate.with_lock([](MyState&amp; s) {\nstd::cout &lt;&lt; \"current value = \" &lt;&lt; s.current_value &lt;&lt; std::endl;\ns.current_value = \"changed\";\n});\n</code></pre>"},{"location":"async/#battchannel","title":"batt::Channel","text":"<p>API Reference</p> <p>Channel is a simple unbuffered SPSC primitive for transferring information between two tasks.  It can be used to implement zero-copy communication between tasks.</p> <p>Example:</p> <pre><code>#include &lt;batteries/async/channel.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nint main() {\nboost::asio::io_context io;\n// Create a channel to pass strings between tasks.\n//\nbatt::Channel&lt;std::string&gt; channel;\n// The producer task reads lines from stdin until it gets an empty line.\n//\nbatt::Task producer{io.get_executor(), [&amp;channel]{\nstd::string s;\n// Keep reading lines until an empty line is read.\n//\nfor (;;) {\nstd::getline(std::cin, s);\nif (s.empty()) {\nbreak;\n}\nbatt::Status write_status = channel.write(s);\nBATT_CHECK_OK(write_status);\n}\n// Let the consumer task know we are done.\n//\nchannel.close_for_write();\n}};\n// The consumer tasks reads strings from the channel, printing them to stdout\n// until the channel is closed.\n//\nbatt::Task consumer{io.get_executor(), [&amp;channel]{\nfor (;;) {\nbatt::StatusOr&lt;std::string&amp;&gt; line = channel.read();\nif (!line.ok()) {\nbreak;\n}\nstd::cout &lt;&lt; *line &lt;&lt; std::endl;\n// Important: signal to the producer that we are done with the string!\n//\nchannel.consume();\n}\nchannel.close_for_read();\n}};\nio.run();\nproducer.join();\nconsumer.join();\nreturn 0;\n}\n</code></pre>"},{"location":"async/#battfuture","title":"batt::Future","text":"<p>API Reference</p>"},{"location":"async/#battgrant","title":"batt::Grant","text":"<p>API Reference</p>"},{"location":"async/#battlatch","title":"batt::Latch","text":"<p>API Reference</p> <p>If you don't need to move the Latch, then this mechanism is strictly more efficient than Future/Promise or Mutex.</p>"},{"location":"async/#battqueue","title":"batt::Queue","text":"<p>API Reference</p> <p>Note: This is an unbounded FIFO implementation, so a back-pressure or rate-limiting mechanism is needed to prevent buffer bloat.</p>"},{"location":"case_of.hpp/","title":"&lt;batteries/case_of.hpp&gt;: <code>switch</code>-like handling for <code>std::variant</code>","text":"<p><code>batt::case_of</code> is a replacement for <code>std::visit</code>.</p> <p>Example:</p> <pre><code>std::variant&lt;Foo, Bar&gt; var = Bar{};\nint result = batt::case_of(\nvar,\n[](const Foo &amp;) {\nreturn 1;\n},\n[](const Bar &amp;) {\nreturn 2;\n});\nBATT_CHECK_EQ(result, 2);\n</code></pre>"},{"location":"case_of.hpp/#battcase_of","title":"<code>batt::case_of</code>","text":"<p>The form of <code>batt::case_of</code> is:</p> <p><code>batt::case_of(</code> variant-object <code>,</code> handler-for-case-1 <code>,</code> handler-for-case-2 <code>, ...);</code></p> <p>The \"handlers\" can be any callable type that takes one argument whose type matches one of the types in the variant passed as variant-object.  The handlers do not have to return a value, but if any of them do, they must all return the same type.  The handler that will be invoked is the first one (from left to right) that is invokable for a given variant case type.  This behavior allows you to write things like:</p> <pre><code>std::variant&lt;std::logic_error, std::runtime_error, std::string, int, double&gt; v;\nbatt::case_of(\nv, [](const std::exception&amp; e) {\n// common code for all types deriving from std::exception\n},\n[](int i) {\n// a special case for integers\n},\n[](const auto&amp; value) {\n// A default case for everything else\n});\n</code></pre>"},{"location":"case_of.hpp/#battmake_case_of_visitor","title":"<code>batt::make_case_of_visitor</code>","text":"<p>You can construct an overloaded functor from a list of functions with the same number of arguments using <code>batt::make_case_of_visitor</code>.  This functor behaves similarly to <code>batt::case_of</code> (and in fact is used to implement <code>case_of</code>): the function that actually gets invoked on a particular set of arguments is the first one in the list whose paramaeters will bind to those arguments.</p> <p>Example:</p> <pre><code>auto do_stuff = batt::make_case_of_visitor(\n[](int) {\nstd::cout &lt;&lt; \"one int\" &lt;&lt; std::endl;\n},\n[](int, int) {\nstd::cout &lt;&lt; \"two ints\" &lt;&lt; std::endl;\n},\n[](auto&amp;&amp;...) {\nstd::cout &lt;&lt; \"something else!\" &lt;&lt; std::endl;\n});\ndo_stuff(5);\ndo_stuff(9, 4);\ndo_stuff();\ndo_stuff(\"hello, world!\");\n</code></pre> <p>Output:</p> <pre><code>one int\ntwo ints\nsomething else!\nsomething else!\n</code></pre>"},{"location":"coding_style/","title":"Batteries C++ Coding Style Guide","text":"<p>This document describes the coding conventions to be followed in this library.</p>"},{"location":"coding_style/#file-names","title":"File Names","text":"<p>All source code files live under <code>batteries/src</code>.</p> <ul> <li>Source, header, inline/implementation, and test sources should be colocated within the same directory.</li> <li>Source files should use the <code>.cpp</code> extension.</li> <li>Header files should use the <code>.hpp</code> extension.</li> <li>Test files for a given source/header should use the <code>.test.cpp</code> suffix.</li> </ul> <p>For example, if you have a header file: <code>src/some_namespace/myutils.hpp</code>, then you should also have:</p> <ul> <li><code>src/some_namespace/myutils.cpp</code></li> <li><code>src/some_namespace/myutils.test.cpp</code></li> <li><code>src/some_namespace/myutils.ipp</code></li> </ul>"},{"location":"coding_style/#class-member-access","title":"Class Member Access","text":"<p>To enhance readability, all implicit uses of <code>this</code> within a class should be made explicit.  For example:</p> <p>DO NOT write:</p> <pre><code>class MyClass {\npublic:\nvoid my_method()\n{\ninternal_method();  // BAD!\n}\nprivate:\nvoid internal_method() {\n++counter_;  // BAD!\n}\nint counter_;\n};\n</code></pre> <p>Instead, DO write:</p> <pre><code>class MyClass {\npublic:\nvoid my_method()\n{\nthis-&gt;internal_method();  // GOOD!\n}\nprivate:\nvoid internal_method() {\n++this-&gt;counter_;  // GOOD!\n}\nint counter_;\n};\n</code></pre>"},{"location":"cpu_align.hpp/","title":"&lt;batteries/cpu_align.hpp&gt;: Prevent false sharing by isolating a type in its own cache line(s).","text":"<p>File Reference</p>"},{"location":"cpu_align.hpp/#features","title":"Features","text":"<ul> <li>Class template batt::CpuCacheLineIsolated for guaranteed cache-line isolation of an object.</li> </ul>"},{"location":"cpu_align.hpp/#details","title":"Details","text":"<p>Sometimes when objects modified by different threads are packed too closely in memory, performance can degrade significantly due to a \"ping-pong\" effect where each CPU/core that modifies an object in the same cache line (the minimum-sized block of memory fetched from main memory into cache) must wait to read changes made to the other objects in that cache line.  This problem can be solved by padding the memory into which the objects are placed to ensure each resides within its own cache line.  <code>batt::CpuCacheLineIsolated&lt;T&gt;</code> makes this very simple and easy to do.</p> <pre><code>// More compact, but slower due to false sharing between CPUs:\n//\nstd::array&lt;int, 100&gt; slow_ints;\n// Each int is padded and aligned so it gets its own cache line:\n//\nstd::array&lt;batt::CpuCacheLineIsolated&lt;int&gt;, 100&gt; fast_ints;\n// The underlying `T` (int in this case) is accessed via `*` and `-&gt;`\n// operators, like a pointer or `std::optional`.\n//\nint&amp; i_ref = *fast_int[0];\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<ul> <li>TOC {:toc}</li> </ul>"},{"location":"faq/#why-is-it-called-batteries","title":"Why is it called 'batteries'?","text":"<p>The name derives from the idomatic expression \"batteries not included,\" referring to something that is missing some essential pieces in order to be useful.  Anyone who has ever had their C++ program crash with nothing but the following output...</p> <pre><code>Segmentation fault (core dumped)\n$ </code></pre> <p>...knows what I'm talking about.  Um, stack trace please?</p> <p>It's also a bit of a pun on the statement you use to import the batteries library:</p> <pre><code>#include &lt;batteries.hpp&gt;\n</code></pre>"},{"location":"finally.hpp/","title":"Finally.hpp","text":"<p>Function <code>batt::finally</code> to execute arbitrary code at scope exit.</p> <p>File Reference</p>"},{"location":"hint.hpp/","title":"Hint.hpp","text":"<p>Branch prediction hint macros: <code>BATT_HINT_TRUE</code>, <code>BATT_HINT_FALSE</code></p> <p>File Reference</p>"},{"location":"int_types.hpp/","title":"<batteries/int_types.hpp>","text":"<p>Rust-like type aliases for standard integer types.</p> <p>File Reference</p>","tags":["ergonomics","portability"]},{"location":"nullable.hpp/","title":"Nullable.hpp","text":"<p>Trait <code>batt::Nullable</code> for transforming arbitrary types into a type that can be given a \"null\" or empty value.</p> <p>File Reference</p>"},{"location":"platforms/","title":"Supported Platforms","text":"<p>Batteries is written in C++17.</p> <p>Supported Compilers:</p> <ul> <li>Clang/LLVM 11 (x86_54)</li> <li>GCC 9.3</li> </ul> <p>Supported Operating Systems:</p> <ul> <li>GNU/Linux (kernel 5.8 or newer)</li> <li>macOS Catalina</li> </ul>"},{"location":"release_notes/","title":"Release notes","text":"<ul> <li> <p>0.57.0 (2024/09/25)</p> <ul> <li>Added SSL/TLS (<code>https://</code>) support to <code>batt::HttpClient</code><ul> <li>SSL context initialization can be customized by supplying a <code>std::function</code> to <code>batt::HttpClient::set_ssl_init_fn</code>.  The function should have the signature <code>void(Optional&lt;boost::asio::ssl::context&gt;&amp;, const HostAddress&amp;)</code>, and should construct the passed optional context in-place (using <code>batt::Optional::emplace</code>).</li> </ul> </li> <li>Worked around race conditions in conan install when downloading/building new packages</li> <li>Added support in CI pipelines for uploading any packages that were built from source during <code>make install</code> to a cache artifact server.</li> <li>Upgraded dependencies in the lockfile (and also added openssl, for https support).</li> </ul> </li> <li> <p>0.56.2 (2024/09/10)</p> <ul> <li>Fixed race condition bugs in <code>batt::ReadWriteLock</code> that could lead to panics or deadlocks</li> <li>Added <code>HoldOwnership</code> and <code>ReleaseOwnership</code> modes for all <code>WatchAtomic&lt;T&gt;</code> simple modification functions<ul> <li><code>HoldOwnership</code> is the default; it is slightly faster and more scalable, but assumes that the caller will keep the Watch object alive until the function returns</li> <li><code>ReleaseOwnership</code> is slightly slower and less scalable, but is safe to call even when the modification being performed to the Watch value will cause the Watch itself to be deleted</li> </ul> </li> <li>Added a <code>batt::FakeTimeService</code> instance to <code>batt::FakeExecutionContext</code>; added support in <code>batt::FakeExecutionContext::run_with_random_seed</code> for simulated timer expirations</li> </ul> </li> <li> <p>0.56.0 (2024/09/06)</p> <ul> <li>Renamed <code>batt::Grant</code> to <code>batt::SpinGrant</code></li> <li>Introduced new Grant implementation, <code>batt::ScalableGrant</code><ul> <li>Uses explicit mutex locks and a waiter queue to scale more gracefully than the old Grant (now SpinGrant), where all contenders to claim Grant count use a single <code>batt::Watch</code> and CAS-like loops</li> <li><code>AsyncScalableGrantTest.ScalabilityBenchmark</code> test (newly added) demonstrates that, as expected, SpinGrant degrades linearly with the number of contenders, whereas ScalableGrant maintains a constant throughput even when faced with hundreds or thousands of Tasks competing for Grant count.</li> </ul> </li> <li><code>batt::Grant</code> is now a type alias to <code>batt::ScalableGrant</code></li> <li>Minor bug fixes that cause spurious failed checks when panicking on another thread</li> </ul> </li> <li> <p>0.55.1 (2024/07/25)</p> <ul> <li>Fixed bug where printing a <code>batt::WaitForResource</code> to a <code>std::ostream</code> results in a crash</li> <li>Added test for <code>std::ostream</code> printing of <code>batt::CountMetric</code></li> </ul> </li> <li> <p>0.55.0 (2024/07/19)</p> <ul> <li>Added <code>batt::LazyLatch&lt;T&gt;</code> - like <code>batt::Latch&lt;T&gt;</code> but   automatically initializes when value is requested, via an   <code>init_fn</code> passed in at construction time.</li> </ul> </li> <li> <p>0.54.0</p> <ul> <li>Added template parameter <code>bool kAllowAlloc</code> for <code>batt::SmallFn</code>,   which enables falling back to dynamic (heap) allocation if a   type-erased function is too large to fit in the inline small   object buffer (similar to <code>batt::SmallVec</code>).</li> <li>Added <code>batt::InstanceCounter&lt;T&gt;</code> for easy debug tracking of the   number of active instances for a given type.</li> </ul> </li> <li> <p>0.53.0</p> <ul> <li>Batteries now uses Conan version ranges for dependencies + lock files.</li> <li>Added <code>batt::StaticTypeMap&lt;KeyTupleT, ValueT&gt;</code>, to store a fixed-size collection of values indexed by distinct types.</li> </ul> </li> <li> <p>0.52.5</p> <ul> <li>Added <code>batt::ReadWriteMutex&lt;T&gt;</code> to wrap <code>batt::ReadWriteLock</code> and an instance of <code>T</code>, using an API similar to <code>batt::Mutex&lt;T&gt;</code>.</li> </ul> </li> <li> <p>0.52.3</p> <ul> <li>Fixed race condition bug in <code>WatchAtomic::poke()</code>/<code>Queue&lt;T&gt;::poke()</code> that could cause the next waiter to miss the poke.</li> </ul> </li> <li> <p>0.52.1</p> <ul> <li>Added a static assert to detect incorrect use of <code>batt::seq::map</code> (when the map function returns void).</li> </ul> </li> <li> <p>0.52.0</p> <ul> <li>Added <code>batt::HttpServer</code>: a basic HTTP/1.1 server implementation based on <code>batt::Task</code>, sharing common code with <code>batt::HttpClient</code></li> <li>Added <code>cleanup_fn</code> optional argument to <code>batt::Queue&lt;T&gt;::drain</code></li> <li>Added <code>batt::HttpMessageBase::close()</code> (inherited by <code>batt::HttpRequest</code> and <code>batt::HttpResponse</code>)</li> <li>Added <code>batt::HttpMessageBase::invoke_stream_writer(writer_fn)</code> (inherited by <code>batt::HttpRequest</code> and <code>batt::HttpResponse</code>)</li> <li>Moved <code>serialize</code> method from <code>batt::HttpRequest</code> to <code>batt::HttpMessageBase</code> so it can be used by <code>batt::HttpResponse</code></li> <li>Moved <code>RequestInfo</code> to top level <code>batt::HttpMessageInfo</code> so it can be used with requests and responses</li> </ul> </li> <li> <p>0.51.1</p> <ul> <li>Added <code>BATT_ASSERT</code> statements to detect attempts to access the contents of an invalid <code>batt::Optional&lt;T&gt;</code>.</li> </ul> </li> <li> <p>0.51.0</p> <ul> <li>Added <code>batt::bit_count</code>, a portable version of the \"how many 1-bits in this integer\" machine instruction (POPCOUNT on Intel).</li> </ul> </li> <li> <p>0.50.9</p> <ul> <li>Added better explanation of the <code>batt::Mutex&lt;T&gt;::with_lock</code> (doc comments).</li> <li>Added a <code>\\return</code> doc tag for <code>WatchAtomic&lt;T&gt;::set_value</code>.</li> </ul> </li> <li> <p>0.50.7</p> <ul> <li>Added <code>patchelf</code> package to Docker image for CI/CD pipelines.</li> <li>Added <code>batt::InlineSubTask&lt;kStackBufferSize&gt;</code> (<code>#include &lt;batteries/async/inline_sub_task.hpp&gt;</code>) for easy allocation/launching of sub-tasks using part of the stack memory of an existing task.</li> </ul> </li> <li> <p>0.50.6</p> <ul> <li>Added environment variable <code>BATT_DEFAULT_SCHEDULER_PIN_CPU</code> to control whether <code>batt::Runtime::default_scheduler()</code> pins its thread pool 1:1 to specific CPUs.</li> </ul> </li> <li> <p>0.50.5</p> <ul> <li>Added <code>batt::ReadWriteLock</code>, an implementation of a fair reader/writer mutex as described in \"Synchronization Without Contention\" (Mellor-Crummey, Scott, 1991)</li> <li>Changed the Dockerfile to install all Python packages (including Conan) in a virtual environment (/opt/venv) instead of the ambient environment.</li> <li>Upgrade the Dockerfile to install Conan version 2.0.16.</li> <li>Added <code>batt::WatchAtomic&lt;T&gt;::poll()</code>, which yields the current task and then reloads/returns the watch value.</li> </ul> </li> <li> <p>0.50.3</p> <ul> <li>Fixed a problem with the CMakeLists.txt and conanfile.py that caused unit tests to be (re-)built when running conan install from a downstream project.</li> </ul> </li> <li> <p>0.50.1</p> <ul> <li>Added <code>batt::AtomicCounterGauge&lt;T&gt;</code>, an atomic variable with both gauge-like (moves up and down) and counter-like (add/subtract counters are monotonically increasing) semantics.</li> </ul> </li> <li> <p>0.49.2</p> <ul> <li>Added <code>batt::BoolStatus</code> (<code>&lt;batteries/bool_status.hpp&gt;</code>), an enum that has true/false/unknown values and overloaded logical operators.</li> </ul> </li> <li> <p>0.49.1</p> <ul> <li>Added to <code>&lt;batteries/type_traits.hpp&gt;</code>:<ul> <li><code>is_any_true(expr0, expr1, expr2, ...)</code>: (<code>constexpr</code>) Returns true (and short circuits) at the first <code>true</code>-valued argument; else <code>false</code></li> <li><code>are_all_true(expr0, expr1, expr2, ...)</code>: (<code>constexpr</code>) Returns false (and short circuits) at the first <code>false</code>-valued argument else <code>true</code></li> <li><code>IsOneOf&lt;T, M0, M1, ...&gt;</code>: (<code>inline constexpr bool</code>) True iff <code>T</code> is exactly one of the set <code>M0</code>, <code>M1</code>, ...</li> <li><code>DecaysToOneOf&lt;T, M0, M1, ...&gt;</code>: (<code>inline constexpr bool</code>) True iff <code>std::decay_t&lt;T&gt;</code> is one of the set <code>M0</code>, <code>M1</code>, ...</li> </ul> </li> </ul> </li> <li> <p>0.49.0</p> <ul> <li>Added <code>BATT_RETURN_OK_RESULT(expr)</code>, which unwraps and returns expr if it evaluates to an ok status, continues without returning otherwise.</li> </ul> </li> <li> <p>0.48.9/0.48.10 (2023/11/27)</p> <ul> <li>Fix conan install bug in conanfile.py: search for script/batt.py relative to the source folder, in addition to the conanfile.py folder.</li> </ul> </li> <li> <p>0.48.8 (2023/11/21)</p> <ul> <li>Add <code>batt::Promise&lt;T&gt;::is_ready()</code> to test whether a future value or error has been set.</li> </ul> </li> <li> <p>0.48.4 (2023/11/16)</p> <ul> <li><code>batt::Status</code> now preserves message strings from <code>std::error_code</code> (for the built-in error categories: <code>std::system_category()</code>, <code>std::generic_category()</code>, <code>std::future_category()</code>, and <code>std::iostream_category()</code>).</li> </ul> </li> <li> <p>0.48.3 (2023/11/15)</p> <ul> <li>Added header <code>operators.hpp</code>:<ul> <li><code>BATT_OBJECT_PRINT_IMPL(inline_decl, type, fields_tuple)</code><ul> <li>Defines <code>&lt;&lt;</code> to print the object to an ostream</li> </ul> </li> <li><code>BATT_OBJECT_EQUALS_IMPL(inline_decl, type, fields_tuple)</code><ul> <li>Defines <code>==</code> as conjunction of field-wise equality</li> </ul> </li> <li><code>BATT_OBJECT_LESS_THAN_IMPL(inline_decl, type, fields_tuple)</code><ul> <li>Defines <code>&lt;</code> as a lexicographical ordering of the field orders</li> </ul> </li> <li><code>BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type)</code><ul> <li>Defines <code>!=</code> based on <code>==</code></li> </ul> </li> <li><code>BATT_TOTALLY_ORDERED(inline_decl, left_type_right_type)</code><ul> <li>Defines <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> based on <code>&lt;</code></li> </ul> </li> </ul> </li> </ul> </li> <li> <p>0.48.2 (2023/11/06)</p> <ul> <li>Added <code>batt::Future&lt;T&gt;::from_value</code>, <code>batt::Future&lt;T&gt;::from_error</code>: convenient API for making completed Futures.</li> <li>Print <code>batt::Status</code> as <code>GROUP.CODE:MESSAGE</code> instead of <code>VALUE:MESSAGE</code>; this allows the savvy reader to convert printed Status values to, for example, errno codes by inspection.</li> </ul> </li> <li> <p>0.47.0 (2023/10/17)</p> <ul> <li>Added <code>batt::Future&lt;T&gt;::and_then</code> for monadic future composition.</li> </ul> </li> <li> <p>0.33.0 (2023/05/19)</p> <ul> <li>Added Conan options for build variants that affect ABI:<ul> <li><code>header_only</code></li> <li><code>glog_support</code></li> <li><code>protobuf_support</code></li> <li><code>asserts_enabled</code></li> <li><code>shared</code></li> </ul> </li> <li>Added <code>&lt;batteries/stacktrace.hpp&gt;</code>, which includes boost   stacktrace and suppresses spurious GCC warnings in the boost   code.</li> <li>Added a runtime check system to <code>&lt;batteries/config.hpp&gt;</code> that   computes a \"feature [bit-]mask\" which captures the build   variant; this is done for each compilation unit that includes   <code>config.hpp</code> (using static init of a <code>bool</code> in an anonymous   namespace) and compared to a global, canonical feature mask.  In   this way, we can now detect bugs where different libraries were   built with different Batteries feature settings and halt the   program before undefined behavior ensues.</li> <li>Added new macros to control optimization suppression in the code:<ul> <li><code>BATT_GCC_BEGIN_OPTIMIZE(setting)</code> - setting must be a string literal, e.g. \"O0\"</li> <li><code>BATT_GCC_END_OPTIMIZE()</code> - reverts the optimization level set by <code>BATT_GCC_BEGIN_OPTIMIZE</code></li> <li><code>BATT_BEGIN_NO_OPTIMIZE()</code> - begins a section in which optimization is completely disabled</li> <li><code>BATT_END_NO_OPTIMIZE()</code> - ends a section begun by <code>BATT_BEGIN_NO_OPTIMIZE</code></li> </ul> </li> <li>Enabling <code>BATT_ASSERT</code> statements can now be done independent of   the <code>NDEBUG</code> define, using <code>BATT_ASSERTS_ENABLED</code>, which is   controlled by the Conan config via the <code>asserts_enabled</code> option,   which can be <code>None</code> (default), <code>True</code>, or <code>False</code>.  If   <code>BATT_ASSERTS_ENABLED</code> is not defined (i.e., <code>asserts_enabled</code>   is <code>None</code>), then asserts are only enabled when <code>NDEBUG</code> is   defined, like before.</li> <li>Added support for <code>std::ostream operator&lt;&lt;</code> to <code>batt::LogLevel</code> (<code>&lt;batteries/status.hpp&gt;</code>)</li> <li>Fixed silent ABI breakage bug in   <code>batt::detail::NotOkStatusWrapper</code> that causes aborts at runtime   when some libraries are compiled with <code>BATT_GLOG_AVAILABLE</code> and   some without.</li> <li>Fixed an overly aggressive check in <code>batt::Task</code></li> </ul> </li> <li> <p>0.31.3 (2023/05/03)</p> <ul> <li>Fixed bug in TakeNSource that causes hang after limit is reached   (instead of returning batt::StatusCode::kEndOfStream).</li> </ul> </li> <li> <p>0.31.0 (2023/05/03)</p> <ul> <li>Added <code>batt::SingleBufferSource</code>.</li> </ul> </li> <li> <p>0.30.0 (2023/04/13)</p> <ul> <li>Fix #4 (Added <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, batt::Watch&lt;T&gt;)</code>)</li> <li>Fix #5 (Deadlock if a failed BATT_CHECK generates another failed check when trying to print the message)</li> <li>Fix #6 (Added <code>batt::Watch&lt;T&gt;::reset()</code>)</li> </ul> </li> <li> <p>0.29.0 (2023/03/31)</p> <ul> <li>Add <code>batt::seq::zip</code>.</li> </ul> </li> <li> <p>0.28.5 (2023/03/17)</p> <ul> <li>Add doc comment for <code>batt::getenv_as</code>.</li> </ul> </li> <li> <p>0.28.4 (2023/03/17)</p> <ul> <li>Added <code>batt::Optional::or_else(Fn)</code> to match <code>std::optional</code>.</li> <li>Changed <code>batt::require_fail_thread_default_log_level()</code> to return <code>batt::Optional&lt;batt::LogLevel&gt;&amp;</code> instead of <code>batt::LogLevel&amp;</code>, and made it default to the current global setting when it is <code>batt::None</code>.</li> </ul> </li> <li> <p>0.28.3 (2023/03/13)</p> <ul> <li>Fix bug that prevented the use of <code>batt::Future&lt;T&gt;::await</code>.</li> </ul> </li> <li> <p>0.27.1 (2023/03/08)</p> <ul> <li>Fixed typo in case_of.hpp doc.</li> <li>Added support for silent conversion of <code>batt::StatusOr&lt;batt::NoneType&gt;</code> to <code>batt::Status</code>.</li> </ul> </li> <li> <p>0.27.0 (2023/03/07)</p> <ul> <li>Added <code>BATT_CHECK_TYPE(type, expr)</code> to <code>&lt;batteries/static_assert.hpp&gt;</code>:<ul> <li>At runtime, evaluates to just <code>expr</code>, but adds a compile-time assertion that the type of <code>expr</code> is <code>type</code>.</li> </ul> </li> </ul> </li> <li> <p>0.26.0 (2023/03/04)</p> <ul> <li>Added <code>batt::Task::DeferStart{bool}</code> option to suppress automatic Task starting; also:<ul> <li>Added member fn <code>batt::Task::is_started()</code></li> <li>Added member fn <code>batt::Task::start()</code></li> <li>Added class <code>batt::Task::Options</code></li> </ul> </li> </ul> </li> <li> <p>0.25.3 (2023/03/02)</p> <ul> <li>Fixed many missing functions/operators for <code>batt::Optional&lt;T&amp;&gt;</code> partial specialization.</li> </ul> </li> <li> <p>0.25.0 (2023/02/23)</p> <ul> <li>Added <code>batt::Task::await_signal</code> (moved from \"upper layers\").</li> </ul> </li> <li> <p>0.24.6 (2023/02/22)</p> <ul> <li>Added support for MacOS/Clang build pipelines</li> <li>Added <code>batt::Task::spawn()</code></li> <li>Added <code>batt::NoDestruct&lt;T&gt;</code></li> </ul> </li> <li> <p>0.23.1 (2023/02/06)</p> <ul> <li>Fixed bug in script/run-with-docker.sh</li> <li>Added xxd to docker images</li> </ul> </li> <li> <p>0.22.1 (2023/01/27)</p> <ul> <li>Added <code>batt::DefaultInitialized</code>, a type that implicitly converts to any default-constructible type.</li> <li>Added a <code>step</code> parameter (type <code>batt::TransferStep &amp;</code>, batteries/async/fetch.hpp) that allows callers to determine which step failed when <code>batt::transfer_chunked_data</code> returns an error.</li> </ul> </li> <li> <p>0.21.0 (2023/01/25)</p> <ul> <li>Added <code>batt::register_error_category</code> to allow applications to specify how <code>error_code</code> values with custom <code>error_category</code> objects should be converted to <code>batt::Status</code>.</li> <li>Upgraded boost to 1.81.0</li> <li>Upgraded gtest to 1.13.0</li> </ul> </li> <li> <p>0.20.1 (2023/01/18)</p> <ul> <li>Added <code>batt::transfer_chunked_data</code> (in batteries/async/fetch.hpp).</li> </ul> </li> <li> <p>0.19.8 (2023/01/11)</p> <ul> <li>Upgrade to Conan 1.56 (from 1.53).</li> </ul> </li> <li> <p>0.19.6 (2022/12/19)</p> <ul> <li>Fixed build error with <code>batt::to_status(std::error_code)</code></li> </ul> </li> <li> <p>0.19.5 (2022/12/16)</p> <ul> <li>Fixed crash bug caused by accidental implicit conversion from error_code enum values to batt::Status.</li> </ul> </li> <li> <p>0.19.2 (2022/12/16)</p> <ul> <li>Fixed test regression by updating the expected error status to match the boost::system::error_code value.</li> </ul> </li> <li> <p>0.19.1 (2022/12/16)</p> <ul> <li>Added accurate translation of more boost::system::error_code values into batt::Status.</li> </ul> </li> <li> <p>0.19.0 (2022/12/14)</p> <ul> <li>Added <code>batt::Latch&lt;T&gt;::set_error</code> to explicitly set the Latch to an error status for better readability.</li> <li>Added new header batteries/async/fetch.hpp with:<ul> <li><code>batt::fetch_chunk</code>: blocking API for no-copy input streams with an async_fetch method</li> <li><code>batt::BasicScopedChunk&lt;Stream&gt;</code>: automatically calls consume on fetched data at scope exit</li> </ul> </li> </ul> </li> <li> <p>0.18.1 (2022/12/09)</p> <ul> <li>Added <code>batt::PinnablePtr&lt;T&gt;</code>.</li> </ul> </li> <li> <p>0.18.0 (2022/12/07)</p> <ul> <li>Added <code>batt::Channel&lt;T&gt;::async_read</code>, along with unit tests for the async methods of <code>batt::Channel&lt;T&gt;</code>.</li> </ul> </li> <li> <p>0.17.1 (2022/12/02)</p> <ul> <li>Added <code>batt::Runtime::reset()</code> and <code>batt::Runtime::is_halted()</code> so that downstream libraries that use a Google Test global environment to start/stop batt::Runtime can restart the default thread pool, for GTEST_REPEAT/--gtest_repeat testing.</li> </ul> </li> <li> <p>0.16.2 (2022/11/30)</p> <ul> <li>Fixed a broken link in the release notes.</li> </ul> </li> <li> <p>0.16.1 (2022/11/30)</p> <ul> <li>Added release notes (this document) to the doc pages.</li> </ul> </li> <li> <p>0.16.0 (2022/11/30)</p> <ul> <li>Added clamp min/max functions to batt::Watch, to atomically enforce upper/lower bounds on the watched value.</li> </ul> </li> </ul>"},{"location":"segv.hpp/","title":"Segv.hpp","text":"<p>Just include this header to enable automatic stack trace dump to STDERR on seg fault.</p> <p>File Reference</p>"},{"location":"seq/","title":"&lt;batteries/seq/...&gt;: Fast, Ergonomic Sequence Processing","text":"<p>The Batteries Seq abstraction builds on top of STL iterator ranges, seeking to offer more readable and maintainable code without sacrificing efficiency.</p>"},{"location":"seq/#intro-example","title":"Intro Example","text":"<pre><code>#include &lt;batteries/seq.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nint main() {\nstd::vector&lt;int&gt; nums = {2, 1, -3, 4, 5, -2};\nint answer = batt::as_seq(nums)\n// Take only non-negative items.\n//\n| batt::seq::filter([](int n) {\nreturn n &gt;= 0;\n})\n// Calculate a running total plus count.\n//\n| batt::seq::reduce(\n// Initial state ({total, count}):\n//\nstd::make_pair(0, 0),\n// Reduce function:\n//\n[](std::pair&lt;int, int&gt; totals, int n) {\nreturn std::make_pair(totals.first + n, totals.second + 1);\n})\n// Divide total by count to get the final answer.\n//\n| batt::seq::apply([](std::pair&lt;int, int&gt; final_totals) {\nreturn final_totals.first / final_totals.second;\n});\nstd::cout &lt;&lt; \"The average value of non-negative elements is: \" &lt;&lt; answer &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <p>Output:</p> <pre><code>The average value of non-negative elements is: 3\n</code></pre>"},{"location":"seq/#seqt-concept","title":"Seq&lt;T&gt; Concept","text":"<p><code>Seq&lt;T&gt;</code> is a concept that represents an ordered sequence of objects of type <code>T</code>.  The class batt::BoxedSeq is a type-erased container for an object that models this concept.  The type requirements/interface of <code>batt::BoxedSeq&lt;T&gt;</code> are: <ul> <li><code>Seq&lt;T&gt;</code> must be copy-constructible, copy-assignable, and publically destructible</li> <li><code>Seq&lt;T&gt;</code> must have a public type member or type alias/typedef named <code>Item</code>, equivalent to <code>T</code></li> <li>Given an object <code>seq</code> of type <code>Seq&lt;T&gt;</code>:<ul> <li><code>seq.peek()</code> must return a value of type <code>batt::Optional&lt;T&gt;</code>; if the sequence is empty or at its end, <code>batt::None</code> is returned, otherwise the next item in the sequence is returned</li> <li><code>seq.next()</code> is the same in terms of returned value, but it additionally has the side effect of consuming the returned item from the sequence</li> </ul> </li> </ul>"},{"location":"seq/#stl-ranges-to-sequences","title":"STL Ranges to Sequences","text":"<p>The function <code>batt::as_seq</code> is used to create a <code>Seq</code> from STL containers and ranges in order to access the rest of the Seq API.  You can pass a range, a pair of iterators, or a starting iterator and a size to overloads of <code>batt::as_seq</code> to do this.</p>"},{"location":"seq/#composing-sequences","title":"Composing Sequences","text":"<p>Sequences are composed by applying one or more \"operators\" to transform the sequence or aggregate its values.  A given sequence operator <code>Op()</code> is applied to an input sequence <code>seq</code> by using the expression: <code>seq | Op()</code>.  The resulting expression is usually another sequence, but it may be a single value (e.g., count(), collect(), etc.).  The set of operators defined by batteries is shown the table below.  It is possible for your application code to define additional operators by composing the ones included in Batteries, or by following the conventions used to define the included operators.</p>"},{"location":"seq/#sequence-operator-reference","title":"Sequence Operator Reference","text":"<p> NOTE:  All of the functions below are defined in the namespace <code>batt::seq::</code>, which has been omitted for brevity.</p> Name Description all_true() Returns <code>true</code> iff all items in the input sequence are <code>true</code> when evaluated in a boolean context.  This operator supports short-circuit; i.e., it stops as soon as it encounters the first <code>false</code>-valued item.<code>#include &lt;batteries/seq/all_true.hpp&gt;</code> any_true() Returns <code>true</code> iff any items in the input sequence are <code>true</code> when evaluated in a boolean context.  This operator supports short-circuit; i.e., it stops as soon as it encounters the first <code>true</code>-valued item.<code>#include &lt;batteries/seq/any_true.hpp&gt;</code> apply(Fn) Applies the passed function to the entire sequence as a single value, returning the result.  Not to be confused with map(Fn) which applies a function to each item in the sequence to produce a new sequence.<code>#include &lt;batteries/seq/apply.hpp&gt;</code> attach(Data&amp;&amp; data) Produces a sequence identical to the input except that a copy of <code>data</code> is stored in the sequence object.  Useful for extending the lifetimes of objects that a sequence may depend on, but doesn't explicitly capture.<code>#include &lt;batteries/seq/attach.hpp&gt;</code> boxed() Transforms a templated sequence type to a type-erased container of concrete type <code>batt::BoxedSeq&lt;T&gt;</code>, hiding the details of how the sequence was composed.<code>#include &lt;batteries/seq/boxed.hpp&gt;</code> cache_next() Lazily caches a copy of the next item in the input sequence, to speed up repeated calls to <code>peek()</code>.<code>#include &lt;batteries/seq/cache_next.hpp&gt;</code> chain(seq2) Concatenates <code>seq2</code> onto the end of the input sequence.<code>#include &lt;batteries/seq/chain.hpp&gt;</code> collect(batt::StaticType&lt;T&gt;) Collects all the items in the sequence by repeatedly calling <code>T::emplace_back</code> on a default-constructed instance of container type <code>T</code>. <code>#include &lt;batteries/seq/collect.hpp&gt;</code> collect_vec() Collects all the items in the input sequence into a <code>std::vector&lt;T&gt;</code>, where <code>T</code> is the declared Item type of the sequence.<code>#include &lt;batteries/seq/collect_vec.hpp&gt;</code> consume() Consumes the entire input sequence, throwing away all values and returning <code>void</code>.<code>#include &lt;batteries/seq/consume.hpp&gt;</code> count() Returns the number of items in the sequence, consuming all items in the process.<code>#include &lt;batteries/seq/count.hpp&gt;</code> debug_out(out, sep=\" \") Prints all items in the input sequence to the passed <code>std::ostream</code> as a side-effect, leaving the input otherwise unmodified.<code>#include &lt;batteries/seq/print_out.hpp&gt;</code> decayed() Transforms a sequence comprised of value references into an equivalent sequence of value-copies, similar to <code>std::decay&lt;T&gt;</code>.<code>#include &lt;batteries/seq/decay.hpp&gt;</code> deref() Transforms a sequence by dereferencing all items, i.e. <code>item</code> becomes <code>*item</code>.  The Item type may be anything which defines <code>operator*</code>, including all built-in pointers, smart pointers, optionals, iterators, etc.<code>#include &lt;batteries/seq/deref.hpp&gt;</code> emplace_back(T&amp; container) Invokes <code>container.emplace_back(item)</code> for each item in the input sequence, fully consuming the sequence.<code>#include &lt;batteries/seq/emplace_back.hpp&gt;</code> filter(PredFn) Removes any items from the input sequence for which the passed <code>PredFn</code> returns <code>false</code>, producing a filtered sequence.<code>#include &lt;batteries/seq/filter.hpp&gt;</code> filter_map(Fn) Combines the effect of map and filter by invoking the passed <code>Fn</code> on each item of the input sequence, producing a temporary sequence of <code>Optional&lt;Item&gt;</code> values, from which all <code>None</code> values are removed. <code>#include &lt;batteries/seq/filter_map.hpp&gt;</code> first() Returns the first item in the sequence; equivalent to calling <code>seq.next()</code>.<code>#include &lt;batteries/seq/first.hpp&gt;</code> flatten() Transforms a sequence of sequences into a flat sequence of the nested items by concatenating all the sub-sequences together.<code>#include &lt;batteries/seq/flatten.hpp&gt;</code> for_each(Fn) Invokes the passed function on each item of the sequence, consuming the input.  <code>Fn</code> may return type <code>void</code> or value of type <code>batt::seq::LoopControl</code> (i.e., <code>LoopControl::kContinue</code> or <code>LoopControl::kBreak</code>) to control how much of the input sequence to consume, similar to the C++ keywords <code>continue</code> and <code>break</code> within a built-in loop.<code>#include &lt;batteries/seq/for_each.hpp&gt;</code> fuse() Transforms a sequence with item type <code>Optional&lt;T&gt;</code> into a sequence of <code>T</code>, terminating the sequence when the first <code>None</code> value is encountered.<code>#include &lt;batteries/seq/fuse.hpp&gt;</code> group_by(BinaryPredFn) Transforms a sequence into a sequence of sequences by invoking <code>BinaryPredFn</code> on each pair of adjacent items in the input, creating a split wherever <code>BinaryPredFn</code> returns false.<code>#include &lt;batteries/seq/group_by.hpp&gt;</code> inner_reduce(Fn) Given input sequence <code>xs = x0, x1, x2, x3, ..., xN</code>, the expression <code>xs | inner_reduce(fn)</code> produces the return value of the expression <code>fn(...fn(fn(fn(x0, x1), x2, x3)..., xN)</code>.<code>#include &lt;batteries/seq/inner_reduce.hpp&gt;</code> inspect(Fn) Calls the given <code>Fn</code> on each item of the input sequence, producing a sequence equivalent to the original input.  This differs from for_each, which also invokes a function for each input item, but does not produce a sequence.<code>#include &lt;batteries/seq/inspect.hpp&gt;</code> inspect_adjacent(BinaryFn) Calls the given <code>BinaryFn</code> on each sequentially adjacent pair of items of the input, producing a sequence equivalent to the original sequence (similar to inspect).<code>#include &lt;batteries/seq/inspect_adjacent.hpp&gt;</code> is_sorted() Returns <code>true</code> iff the input sequence is sorted.  The item type of the input sequence must support <code>operator&lt;</code>.<code>#include &lt;batteries/seq/is_sorted.hpp&gt;</code> is_sorted_by(OrderFn) Returns <code>true</code> iff the input sequence is sorted according to the passed <code>OrderFn</code>, which should behave like the less-than operator.<code>#include &lt;batteries/seq/is_sorted.hpp&gt;</code> kmerge() Performs a k-way merge of a sequence of sorted sequences, producing a single sorted sequence.  The built in comparison operators (e.g. <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, etc.) are used to define the ordering of nested items.  Behavior is unspecified if the input sequences are not sorted!  The input sequences must be copyable, with each copy able to iterate through independent of the others.<code>#include &lt;batteries/seq/kmerge.hpp&gt;</code> kmerge_by(OrderFn) Like kmerge(), except the ordering is defined by the passed binary predicate <code>OrderFn</code>, which should behave like the less-than operator (<code>operator&lt;</code>).<code>#include &lt;batteries/seq/kmerge.hpp&gt;</code> last() Returns the final item in the sequence if the input is non-empty, else <code>batt::None</code>.<code>#include &lt;batteries/seq/last.hpp&gt;</code> map(Fn) Transforms the input sequence by applying the passed <code>Fn</code> to each item in the input to produce the output.<code>#include &lt;batteries/seq/map.hpp&gt;</code> map_adjacent(Fn) Transforms <code>x0, x1, x2, x3, ...</code> into <code>fn(x0, x1), fn(x1, x2), fn(x2, x3), ...</code><code>#include &lt;batteries/seq/map_adjacent.hpp&gt;</code> map_fold(state0, fn) Similar to <code>map(Fn: auto (T) -&gt; U)</code>, except that the <code>fn</code> takes an additional first argument, the <code>state</code>, and returns a <code>std::tuple&lt;State, U&gt;</code>.  This produces both a sequence of output values <code>u0, u1, u2, ...</code> and also a series of state values, <code>state1, state2, state3, ...</code>, with each item's state output passed into the next item's call to <code>fn</code>.  This operator is preferable to using <code>map</code> with an <code>Fn</code> that uses mutable state in its implementation.<code>#include &lt;batteries/seq/map_fold.hpp&gt;</code> map_pairwise(SeqB, Fn) Given two sequences <code>seqA = a0, a1, a2, ...</code> and <code>seqB = b0, b1, b2, ...</code>, the expression <code>seqA | map_pairwise(seqB, fn)</code> produces a sequence with items <code>fn(a0, b0), fn(a1, b1), fn(a2, b2), ...</code><code>#include &lt;batteries/seq/map_pairwise.hpp&gt;</code> prepend(seq0) Forms a new sequence by concatenating the input sequence onto the end of <code>seq0</code>; this is the opposite of chain.<code>#include &lt;batteries/seq/prepend.hpp&gt;</code> print_out(out, sep=\" \") Consumes all items in the input stream, printing them to the passed <code>std::ostream out</code>, inserting the passed separator string <code>sep</code> in between each item.<code>#include &lt;batteries/seq/print_out.hpp&gt;</code> printable() Turns the input sequence into a value that can be <code>&lt;&lt;</code>-inserted to any <code>std::ostream</code> to print out all items.<code>#include &lt;batteries/seq/printable.hpp&gt;</code> product() Returns the arithmetic product of the items in the input sequence.  The item type <code>T</code> of the input sequence must support built-in multiplication (<code>operator*</code>), and <code>T{1}</code> must be the multiplicative identity value of <code>T</code> (i.e., \"one\").<code>#include &lt;batteries/seq/product.hpp&gt;</code> reduce(state, fn) Transforms a sequence of items <code>item0, item1, item2, ..., itemN</code> into the result of calling: <code>fn(...fn(fn(fn(state, item0), item1), item2)..., itemN)</code>; this operation is sometimes called left-fold or foldl.<code>#include &lt;batteries/seq/reduce.hpp&gt;</code> rolling(Fn, init = {}) Like reduce, but instead of evaluating to the single final value, produces a sequence starting with <code>init</code> followed by all intermediate values calculated by <code>Fn</code> (Note: this means rolling produces a sequence one larger than the input sequence).  The type of the <code>init</code> param should be the Item type <code>T</code> of the sequence; <code>Fn</code> should have the signature: <code>auto (T, T) -&gt; T</code>.<code>#include &lt;batteries/seq/rolling.hpp&gt;</code> rolling_sum(Fn) Produces a sequence that begins with a default-initialized item (i.e. \"zero\"), followed by a running total of all the items up to that point in the input.<code>#include &lt;batteries/seq/rolling_sum.hpp&gt;</code> skip_n(n) Produces a new sequence that doesn't include the first <code>n</code> items of the input sequence.  This is the complement of take_n(n).<code>#include &lt;batteries/seq/skip_n.hpp&gt;</code> splice(n, InnerSeq) Inserts the items of <code>InnerSeq</code> into the input sequence at position <code>n</code>.  This is a more general version of chain and prepend.<code>#include &lt;batteries/seq/splice.hpp&gt;</code> status_ok() Transforms a sequence <code>a</code> with item type <code>batt::StatusOr&lt;T&gt;</code> into a sequence <code>b</code> with item type <code>T</code> by unwrapping each input item until one with non-ok status is encountered, at which point <code>b</code> is terminated.  If the <code>b</code> ends because of a non-ok item from <code>a</code>, then <code>b.status()</code> may be used to retrieve the error status value. <code>#include &lt;batteries/seq/status_ok.hpp&gt;</code> sum() Returns the arithmetic sum of the items in the input sequence.  The item type <code>T</code> of the input sequence must support built-in addition (<code>operator+</code>), and <code>T{}</code> must be the additive identity value of <code>T</code> (i.e., \"zero\").<code>#include &lt;batteries/seq/sum.hpp&gt;</code> take_n(n) Produces a new sequence comprised of only the first <code>n</code> items of the input sequence.  This is the complement of skip_n(n).<code>#include &lt;batteries/seq/take_n.hpp&gt;</code> take_while(PredFn) Produces a sequence with the same items as the input up until the passed <code>PredFn</code> returns <code>false</code>, at which point the sequence is terminated.<code>#include &lt;batteries/seq/take_while.hpp&gt;</code> zip(Seqs...) Produces a sequence of tuples constructed from items pulled in unison from all zipped sequences.<code>#include &lt;batteries/seq/zip.hpp&gt;</code>"},{"location":"seq/#other-functionsclasses","title":"Other Functions/Classes","text":"<ul> <li><code>Addition</code></li> <li><code>Empty&lt;T&gt;</code></li> <li><code>lazy</code></li> <li><code>NaturalOrder</code></li> <li><code>NaturalEqual</code></li> <li><code>single_item</code></li> </ul>"},{"location":"small_fn.hpp/","title":"Small fn.hpp","text":"<p>Type-erased function wrappers that are guaranteed not to allocate: <code>batt::SmallFn</code>, <code>batt::UniqueSmallFn</code>.</p> <p>File Reference</p>"},{"location":"static_assert.hpp/","title":"Static assert.hpp","text":"<p>Comparison based static assertion macros that, when failure occurs, cause compiler output to contain the values being compared.</p> Macro Name Assertion <code>BATT_STATIC_ASSERT_EQ</code>(x,y) x == y <code>BATT_STATIC_ASSERT_NE</code>(x,y) x != y <code>BATT_STATIC_ASSERT_LT</code>(x,y) x &lt; y <code>BATT_STATIC_ASSERT_GT</code>(x,y) x &gt; y <code>BATT_STATIC_ASSERT_LE</code>(x,y) x &lt;= y <code>BATT_STATIC_ASSERT_GE</code>(x,y) x &gt;= y <p>File Reference</p>"},{"location":"static_dispatcher.hpp/","title":"Static dispatcher.hpp","text":"<p>Function <code>batt::static_dispatch</code> that transforms a runtime integer value into a compile-time (static) integer constant type. Macro <code>BATT_CONST</code> for turning constant integer expressions into static types.</p> <p>File Reference</p>"},{"location":"status.hpp/","title":"&lt;batteries/status.hpp&gt;: Efficient, Ergonomic Error Handling","text":""},{"location":"status.hpp/#summary","title":"Summary","text":"<pre><code>#include &lt;batteries/status.hpp&gt;\n</code></pre> Types Functions Macros batt::Status batt::to_status BATT_REQUIRE_OK batt::StatusCode batt::OkStatus BATT_CHECK_OK batt::StatusOr&lt;T&gt; batt::status_from_retval BATT_OK_RESULT_OR_PANIC batt::ErrnoValue batt::status_from_errno BATT_ASSIGN_OK_RESULT batt::IsStatusOr&lt;T&gt; batt::status_is_retryable batt::RemoveStatusOr&lt;T&gt; batt::is_ok_status batt::LogLevel batt::ok_result_or_panic&lt;T&gt;"},{"location":"status.hpp/#why-not-exceptions","title":"Why not exceptions?","text":"<p>Batteries C++ discourages the use of exceptions as an error handling mechanism.  Exceptions tend to hurt the readability and maintainability of code because they introduce non-local control flow (throw statements can jump to catch statements arbitrarily far away with no obvious connection between the two points), break the separation of interface and implementation (because implementations can silently introduce new failure modes because of a deep change, even several layers down), and add to the complexity of syntax because when you program with exceptions now there are multiple ways to return a value from a function, each with its own caveats and idiosyncrasies.  The purported benefit of exceptions, that they clean up the code by hiding error handling code, does more harm than good because failure modes are an essential element to understanding any code.</p>"},{"location":"status.hpp/#what-instead-of-exceptions-battstatus","title":"What instead of exceptions? (batt::Status)","text":"<p>In place of exceptions, Batteries provides <code>batt::Status</code> and many related constructs.</p> <p>DISCLAIMER/ACKNOWLEDGMENT: batt::Status is modelled very closely after absl::Status from Google's Abseil library.</p> <p>A <code>batt::Status</code> is like an exception in that it represents a specific error condition, but it can also represent no error at all.  When a function that returns a value, say an <code>int</code>, can also fail, it is best to write it as:</p> <pre><code>batt::StatusOr&lt;int&gt; parse_int(std::string_view s);\n</code></pre> <p>In this example, we imagine a function that takes a string and parses it as an integer value.  Because this operation may fail (if for example it is handed an invalid string like \"hello, world\"), we declare the return type as <code>batt::StatusOr&lt;int&gt;</code>.</p> <p>Functions returning no value that can fail should just return <code>batt::Status</code>.</p> <p>To make the use of <code>Status</code> easier in practice, Batteries provides several macros to automatically unwrap a <code>Status</code> or propagate it up a call stack.  Example:</p> <pre><code>batt::StatusOr&lt;Endpoint&gt; resolve_url(std::string url);\nbatt::StatusOr&lt;std::string&gt; download_from_server(std::string url)\n{\n// This will panic (crash) our program if the url fails to resolve.\n//\nEndpoint endpoint = BATT_OK_RESULT_OR_PANIC(resolve_url(url));\n// Connect to the server.\n//\nbatt::StatusOr&lt;Socket&gt; maybe_socket = connect_to_server(endpoint);\nBATT_REQUIRE_OK(maybe_socket);\n//\n//   ^^^ This will cause the current function to return the non-ok status \n//       code if there is an error, or continue otherwise.\n// We can unwrap the StatusOr like this.\n//\nSocket&amp; socket = *maybe_socket;\n// This macro combines the two steps above, checking for errors \n// and unwrapping the value.\n//\nBATT_ASSIGN_OK_RESULT(std::string data, socket.read_all());\n// Done!\n//\nreturn data;\n}\n</code></pre>"},{"location":"status.hpp/#standard-status-codes","title":"Standard Status Codes","text":"<p>Batteries provides the same standard status codes as Abseil Status, plus a few extras:</p> <pre><code>enum class StatusCode : int {\nkOk = 0,\nkCancelled = 1,\nkUnknown = 2,\nkInvalidArgument = 3,\nkDeadlineExceeded = 4,\nkNotFound = 5,\nkAlreadyExists = 6,\nkPermissionDenied = 7,\nkResourceExhausted = 8,\nkFailedPrecondition = 9,\nkAborted = 10,\nkOutOfRange = 11,\nkUnimplemented = 12,\nkInternal = 13,\nkUnavailable = 14,\nkDataLoss = 15,\nkUnauthenticated = 16,\n// ...\n// This range reserved for future allocation of Abseil status codes.\n// ...\nkClosed = 100,\nkGrantUnavailable = 101,\nkLoopBreak = 102,\n};\n</code></pre>"},{"location":"status.hpp/#handling-system-errors","title":"Handling System Errors","text":"<p>In addition, <code>batt::Status</code> can accept standard <code>errno</code> values from system calls:</p> <pre><code>batt::Status example() {\nint fd = open(\"something.txt\", 0);\nif (fd == -1) {\nreturn batt::status_from_errno(errno);\n}\nreturn batt::OkStatus();\n}\n</code></pre> <p>In fact, because this pattern is so common when invoking system APIs, the above example can also be written as:</p> <pre><code>batt::Status even_better_example() {\nint fd = open(\"something.txt\", 0);\nBATT_REQUIRE_OK(batt::status_from_retval(fd));\nreturn batt::OkStatus();\n}\n</code></pre>"},{"location":"status.hpp/#battstatus","title":"batt::Status","text":""},{"location":"status.hpp/#summary_1","title":"Summary","text":"<pre><code>#include &lt;batteries/status.hpp&gt;\n</code></pre> Constructors Operators Methods Status() operator= ok group Status(enum_value) operator&lt;&lt; code IgnoreError Status(const Status&amp;) operator== message Update Static Methods Types Constants code_group_for_type value_type kGroupSizeBits message_from_code CodeEntry kGroupSize register_codes CodeGroup kMaxGroups unknown_enum_value_message"},{"location":"status.hpp/#constructors","title":"Constructors","text":""},{"location":"status.hpp/#operators","title":"Operators","text":""},{"location":"status.hpp/#methods","title":"Methods","text":""},{"location":"status.hpp/#static-methods","title":"Static Methods","text":""},{"location":"status.hpp/#types","title":"Types","text":""},{"location":"status.hpp/#constants","title":"Constants","text":""},{"location":"stream_util.hpp/","title":"<batteries/stream_util.hpp>","text":"<p>Enables insertion of lambda expressions into <code>std::ostream</code>, provides {{&lt; doxfn \"batt::to_string\" &gt;}} and {{&lt; doxfn \"batt::from_string\" &gt;}} functions, C-string literal escaping ({{&lt; doxfn \"batt::c_str_literal\" &gt;}}), and dumping range values with and without pretty printing ({{&lt; doxfn \"batt::dump_range\" &gt;}}).</p> <p>File Reference</p>","tags":["collections","diagnostics","string processing"]},{"location":"stream_util.hpp/#inserting-lambdas-into-stdostream","title":"Inserting Lambdas into std::ostream","text":"<p>Example:</p> <pre><code>std::cout &lt;&lt; \"Here is some output: \" &lt;&lt; [](std::ostream&amp; out) {\nfor (int i=0; i&lt;10; ++i) {\nout &lt;&lt; i &lt;&lt; \", \";\n}\n};\n</code></pre> <p>Output:</p> <pre><code>Here is some output: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \n</code></pre>","tags":["collections","diagnostics","string processing"]},{"location":"strict.hpp/","title":"<batteries/strict.hpp>","text":"<p>Including this header enables strict-level compiler warnings and tells the compiler to treat all warnings as errors.</p> <p>File Reference</p>","tags":["compile-time","diagnostics"]},{"location":"suppress.hpp/","title":"<batteries/suppress.hpp>","text":"<p>Provides {{&lt; doxdefine file=\"suppress.hpp\" name=\"BATT_SUPPRESS\" &gt;}}(warn_id)/{{&lt; doxdefine file=\"suppress.hpp\" name=\"BATT_UNSUPPRESS\" &gt;}}() macros to suppress compiler warnings, {{&lt; doxdefine file=\"suppress.hpp\" name=\"BATT_NO_OPTIMIZE\" &gt;}} to suppress optimization of a specific function.</p> <p>File Reference</p>","tags":["compile-time","diagnostics","performance","portability"]},{"location":"_autogen/Classes/","title":"Classes","text":"<ul> <li>class SkipList </li> <li>class SkipNode </li> <li>namespace batt <ul> <li>class AbstractStackAllocator </li> <li>class AbstractValue </li> <li>class AbstractValueImpl </li> <li>class AbstractValuePointer </li> <li>class AtomicCounterGauge An atomic variable that maintains a gauge-like value, which can rise and fall over time, by means of two monotonic counters: one for increases, one for decreases. <ul> <li>class State A value of the atomic variable that implements AtomicCounterGauge. </li> </ul> </li> <li>class BasicAbstractHandler A type-erased async completion handler with linked list pointers. <ul> <li>struct Deleter Deleter for use in std::unique_ptr. </li> </ul> </li> <li>class BasicExecutor </li> <li>class BasicFakeExecutor </li> <li>class BasicHandlerImpl </li> <li>class BasicHttpClientConnection </li> <li>struct BasicInterval A set of totally ordered values, defined by a lower and upper bound. <ul> <li>struct LexicographicalOrder Total order that sorts intervals first by lower bound, then by upper bound (i.e., by \"dictionary order\"). </li> <li>struct LinearOrder Partial order on Interval values that corresponds to a strict ordering on a one dimensional number line. </li> </ul> </li> <li>class BasicMCSMutex A fair mutual exclusion lock based on the MCS lock algorithm. <ul> <li>class Lock </li> <li>struct Metrics Metric counters for measuring behavior of MCSMutex locks. </li> </ul> </li> <li>class BasicRateLimiter </li> <li>class BasicReadWriteLock An MCS-style fair reader/writer lock. <ul> <li>class QueueNode Base class for Reader and Writer scoped lock guards. </li> <li>class Reader </li> <li>class Writer </li> </ul> </li> <li>class BasicRunningTotal <ul> <li>class Iterator </li> </ul> </li> <li>class BasicScopedChunk A fetched chunk of data that is automatically consumed (partially or entirely) when it goes out of scope. </li> <li>class BasicStateMachineEntropySource </li> <li>class BoxedSeq <ul> <li>class AbstractSeq </li> <li>class SeqImpl </li> </ul> </li> <li>class BufferSource <ul> <li>class BufferSourceImpl </li> </ul> </li> <li>class BufferViewImpl </li> <li>class BufferedChannel </li> <li>struct ByteSwap </li> <li>class CancelToken Enables effective cancellation of arbitrary async operations. <ul> <li>class HandlerImpl </li> <li>class Impl </li> </ul> </li> <li>class CaseOfVisitor </li> <li>class Channel A Channel is a one-way, unbuffered, SPSC (single-producer, single consumer) communication/synchronization primitive.  <li>class ConstBufferView </li> <li>class CountMetric </li> <li>class CpuCacheLineIsolated </li> <li>class CustomAllocHandler Wrapper for an async completion handler type <code>Handler</code>. </li> <li>class DebugInfoFrame </li> <li>struct DecayRValueRefImpl </li> <li>class DefaultHttpClient A singleton instance of HttpClient; contains an io_context and thread pool (size == 1). </li> <li>struct DefaultInitialized A single type that implicitly converts to any default-constructible type (via batt::make_default()). </li> <li>struct DefaultStatusIsRetryableImpl </li> <li>class DerivedMetricExporter </li> <li>struct Difference Type trait that maps subtractable type <code>T</code> to the difference type. </li> <li>struct Difference&lt; std::pair&lt; A, B &gt; &gt; </li> <li>struct Difference&lt; std::tuple&lt; Ts... &gt; &gt; </li> <li>struct Difference&lt; unsigned char &gt; </li> <li>struct Difference&lt; unsigned long &gt; </li> <li>struct Difference&lt; unsigned long long &gt; </li> <li>struct Difference&lt; unsigned short &gt; </li> <li>struct DoNothing </li> <li>struct DumpReadWriteLockState </li> <li>struct EscapedStringLiteral </li> <li>class ExhaustiveModelChecker </li> <li>struct ExponentialBackoff </li> <li>class FakeExecutionContext <ul> <li>struct AlwaysReturnZero </li> </ul> </li> <li>class FakeTaskScheduler <ul> <li>class ScopeGuard </li> </ul> </li> <li>class FakeTimeService <ul> <li>class State </li> <li>struct TimerInstance <ul> <li>struct Impl </li> </ul> </li> </ul> </li> <li>class FilterBufferSource </li> <li>class FinalAct </li> <li>class Future A value of type T that will be provided at some point in the future. </li> <li>class GaugeMetric A Metric collector that stores and reports a single instantaneous value. </li> <li>struct GreatestLowerBound </li> <li>class HandlerAllocator An allocator associated with a completion handler. </li> <li>class HandlerBinder </li> <li>class HandlerMemory A chunk of memory that can be attached to an async completion handler. </li> <li>class HandlerMemoryBase Abstract base for HandlerMemory.  <li>struct HexByteDumper </li> <li>class HistogramMetric Collect histogram values for multiple samples. <ul> <li>struct Bucket Represents a single histogram bucket for reporting. </li> </ul> </li> <li>struct HoldOwnership </li> <li>struct HostAddress </li> <li>class HttpChunkDecoder BufferSource transformer that decodes HTTP chunked content fetched from <code>Src</code>. </li> <li>class HttpClient An HTTP/1.1 client implementation. </li> <li>class HttpClientHostContext </li> <li>struct HttpData </li> <li>class HttpMessageBase The common base type for HttpRequest and HttpResponse. </li> <li>struct HttpMessageInfo A summary of information about a response message that is necessary for the connection to correctly handle it. </li> <li>class HttpRequest </li> <li>class HttpResponse </li> <li>class HttpServer An HTTP server. </li> <li>class HttpServerConnection </li> <li>struct HttpServerSettings </li> <li>struct HttpVersion </li> <li>struct IClosed </li> <li>struct IClosedOpen </li> <li>class IOResult </li> <li>struct InPlaceInitType </li> <li>class InlineSubTask A scoped asynchronous task with inline stack memory. </li> <li>class InstanceCounter A quick and easy way to track the number of instances of a given type in existence; just add batt::InstanceCounter as a field or base class of T.  <li>struct IntervalTraits </li> <li>struct IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt; </li> <li>struct IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt; </li> <li>struct IntervalTraitsBase </li> <li>struct IsBoxedSeq </li> <li>struct IsBoxedSeq&lt; BoxedSeq&lt; T &gt; &gt; </li> <li>struct IsTuple </li> <li>struct IsTuple&lt; std::tuple&lt; Ts... &gt; &gt; </li> <li>struct IsVariant </li> <li>struct IsVariant&lt; std::variant&lt; Ts... &gt; &gt; </li> <li>class Latch A write-once, single-value synchronized container. <ul> <li>class AsyncGetHandler </li> </ul> </li> <li>class LatencyMetric </li> <li>class LatencyTimer </li> <li>class LazyLatch A write-once, single-value synchronized container that is populated lazily by an init_fn when the value is requested. <ul> <li>class AsyncGetHandler </li> </ul> </li> <li>struct LeastUpperBound </li> <li>class LockBase </li> <li>class ManagedBuffer </li> <li>class MapBufferSource </li> <li>struct MapTuple </li> <li>struct MapTuple&lt; PerTypeT, std::tuple&lt; Ts... &gt; &gt; </li> <li>class MetricCsvFormatter </li> <li>class MetricDumper </li> <li>class MetricExporter </li> <li>class MetricFormatter </li> <li>struct MetricLabel </li> <li>class MetricOpenTelemetryFormatter Format metrics into OpenTelemetry data format: {=, ...}  <li>class MetricRegistry </li> <li>struct MorphTuple </li> <li>struct MorphTuple&lt; TemplateT, std::tuple&lt; Ts... &gt; &gt; </li> <li>class MutableBufferView </li> <li>class Mutex Provides mutually-exclusive access to an instance of type <code>T</code>. <ul> <li>class LockImpl Represents a lock aquisition. </li> <li>struct ThreadSafeBaseIsNotSupportedByType Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is. </li> </ul> </li> <li>class MutexBase Base class of typed Mutex; implements core logic without any type dependencies.  <li>class NoDestruct </li> <li>struct NoneType </li> <li>struct NoopDeleter </li> <li>class NullTaskScheduler </li> <li>class Optional </li> <li>class Optional&lt; T &amp; &gt; </li> <li>class Pin </li> <li>class Pinnable </li> <li>class PinnablePtr A raw pointer augmented to support the batt::Pinnable interface, so that a batt::Pin&gt; can be created to block the destruction of the pointer.  <li>class PreallocatedTask <ul> <li>class PreallocatedStackAllocator </li> </ul> </li> <li>class PrependBufferSource </li> <li>class PriorityWatch </li> <li>class PrometheusMetricExporter <ul> <li>struct Metrics </li> </ul> </li> <li>class Promise An obligation to provide a value of type T to a Future. </li> <li>class Queue Unbounded multi-producer/multi-consumer (MPMC) FIFO queue. </li> <li>class QueueBase Type-agnostic base class for all Queue types. </li> <li>class QueueDepthExporter </li> <li>class RadixQueue <ul> <li>struct Hash </li> <li>struct Segment </li> </ul> </li> <li>class RangeDumper </li> <li>class RateMetric </li> <li>class ReadWriteMutex Mutex wrapper for a value of type T, providing exclusive read/write access and non-exclusive read-only access. <ul> <li>struct ThreadSafeBaseIsNotSupportedByType Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is. </li> </ul> </li> <li>class Ref </li> <li>struct ReleaseOwnership </li> <li>struct RemoveStatusOrImpl </li> <li>struct RemoveStatusOrImpl&lt; StatusOr&lt; T &gt; &gt; </li> <li>struct RetryState </li> <li>class Runtime <ul> <li>class DefaultScheduler </li> <li>struct WeakNotifySlot </li> </ul> </li> <li>class ScalableGrant A claim on some counted resource. </li> <li>class ScalableGrantIssuer A pool from which ScalableGrant instances are allocated. <ul> <li>struct ConsumerBase Base for consumer handler type; adds list node and count needed. </li> <li>class State Implements the common mechanisms shared by Issuer and Grant. </li> </ul> </li> <li>class ScalarMetricExporter Exports a single value metric. </li> <li>class ScopedLock </li> <li>class ScopedReadWriteLockImpl </li> <li>class ScopedWorkContext </li> <li>class ScopedWorkerThreadPool </li> <li>class SeqBufferSource </li> <li>struct SeqItem_Impl </li> <li>class SeqRef </li> <li>struct SharedPtrImpl </li> <li>class SimpleExecutionContext A minimal multi-threaded execution context implementation, suitable for parallel-compute thread pools. </li> <li>class SingleBufferSource Adapts a single ConstBuffer to be a BufferSource. </li> <li>struct SizeDumper Wrapper around <code>usize</code> (<code>std::size_t</code>) that prints as human-readable sizes. </li> <li>class SkipN </li> <li>struct SkipNBinder </li> <li>class SkipNode </li> <li>class SkipNodeBase </li> <li>class SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. </li> <li>class SpinGrant A claim on some counted resource. <ul> <li>class Issuer A pool from which SpinGrant instances are allocated. </li> </ul> </li> <li>class SslTransport An SSL/TLS based transport for HTTPS clients. </li> <li>class StackAllocator </li> <li>class StackAllocatorImpl </li> <li>struct StateMachineBranch </li> <li>class StateMachineModel </li> <li>struct StateMachineModelCheckAdvancedOptions </li> <li>struct StateMachineResult </li> <li>struct StateMachineTraits </li> <li>struct StaticBinaryAssertion </li> <li>struct StaticSameTypeAssertion </li> <li>struct StaticType </li> <li>class StaticTypeMap Stores a fixed-size set of Value objects, indexed by a set of bounded types (keys). </li> <li>struct StaticValue </li> <li>class StatsMetric Collect count, total, max and min values for multiple samples. </li> <li>class Status <ul> <li>struct CodeEntry </li> <li>struct CodeGroup </li> <li>struct ForceLookup Sentinel type passed to Status constructor to force the passed code enum value to be treated as a non-error_code type. </li> </ul> </li> <li>class StatusOr </li> <li>class StatusOr&lt; Status &gt; </li> <li>class StatusOr&lt; StatusOr&lt; T &gt; &gt; </li> <li>class StochasticModelChecker </li> <li>class StreamBuffer </li> <li>class StrongType <ul> <li>struct Delta </li> <li>struct Hash </li> </ul> </li> <li>class SubRangeSeq </li> <li>class TakeNSource </li> <li>class Task A user-space cooperatively scheduled thread of control. <ul> <li>class ConcurrentTaskList Thread-safe list of tasks. </li> <li>struct DebugTrace Stack trace and debug information collected from a Task. </li> <li>struct Options Optional params for Task creation. </li> <li>class SpinLockGuard </li> <li>class Trampoline </li> </ul> </li> <li>class TaskScheduler </li> <li>struct TaskSleepImpl </li> <li>class TcpTransport A thread-safe socket based TCP connection for HTTP clients. </li> <li>struct ThreadPoolConfig </li> <li>struct TupleIndexOf </li> <li>struct TupleIndexOf&lt; std::tuple&lt; First, Rest... &gt;, T &gt; </li> <li>struct TupleIndexOf&lt; std::tuple&lt; T, Rest... &gt;, T &gt; </li> <li>struct TupleIndexOf&lt; std::tuple&lt;&gt;, T &gt; </li> <li>class TypeErasedStorage </li> <li>class TypeErasedStorageBase </li> <li>class UniqueHandler </li> <li>struct UrlParse </li> <li>class VariableExporter </li> <li>class VecSeq </li> <li>struct VecSeqBase </li> <li>class Watch A batt::Watch is like a <code>std::atomic</code> that you can block on, synchronously and asynchronously; see also batt::WatchAtomic. </li> <li>class Watch&lt; T * &gt; </li> <li>class Watch&lt; bool &gt; </li> <li>class Watch&lt; i16 &gt; </li> <li>class Watch&lt; i32 &gt; </li> <li>class Watch&lt; i64 &gt; </li> <li>class Watch&lt; i8 &gt; </li> <li>class Watch&lt; u16 &gt; </li> <li>class Watch&lt; u32 &gt; </li> <li>class Watch&lt; u64 &gt; </li> <li>class Watch&lt; u8 &gt; </li> <li>class Watch&lt; void * &gt; </li> <li>class WatchAtomic Watch for atomic primitive type. </li> <li>class WatchExporter </li> <li>class WorkContext </li> <li>struct WorkSliceParams </li> <li>struct WorkSlicePlan </li> <li>class Worker </li> <li>class WorkerPool </li> <li>namespace constants </li> <li>namespace detail <ul> <li>class AbstractCopyFn </li> <li>class AbstractMoveFn </li> <li>class AllocFnWrapper </li> <li>class CopyFnImpl </li> <li>struct EmptyBaseHelper </li> <li>struct EmptyBaseTestCase </li> <li>struct EmptyBaseTestCase2 </li> <li>struct FirstMatchImpl </li> <li>struct FirstMatchImpl&lt; std::tuple&lt; CaseFirst, CaseRest... &gt;, std::tuple&lt; Args... &gt; &gt; </li> <li>struct FirstMatchImpl&lt; std::tuple&lt;&gt;, std::tuple&lt; Args... &gt; &gt; </li> <li>struct FirstPhase </li> <li>class FutureImpl </li> <li>class HttpClientRequestContext </li> <li>struct IsStatusOrImpl </li> <li>struct IsStatusOrImpl&lt; StatusOr&lt; T &amp; &gt; &gt; </li> <li>struct IsStatusOrImpl&lt; StatusOr&lt; T &gt; &gt; </li> <li>struct ModelCheckShardMetrics </li> <li>class MoveFnImpl </li> <li>class NotOkStatusWrapper </li> <li>struct NullableImpl </li> <li>struct NullableImpl&lt; T * &gt; </li> <li>struct NullableImpl&lt; std::optional&lt; T &gt; &gt; </li> <li>struct NullableImpl&lt; std::shared_ptr&lt; T &gt; &gt; </li> <li>struct NullableImpl&lt; std::unique_ptr&lt; T &gt; &gt; </li> <li>class OptionalBase </li> <li>class OptionalEmptyBase </li> <li>class ParallelModelCheckState </li> <li>class PriorityHeap </li> <li>class PriorityHeapItem </li> <li>class PriorityHeapItemList </li> <li>struct SecondPhase </li> <li>class SigInfoHandler </li> <li>class StatusBase </li> <li>class StatusOrValueContainer </li> <li>class StatusOrValueContainer&lt; T &amp; &gt; </li> <li>struct ThirdPhase </li> <li>struct VisitorResult </li> <li>struct VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp; &gt; </li> <li>struct VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp;&amp; &gt; </li> <li>struct VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &gt; </li> <li>struct VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp; &gt; </li> <li>struct VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp;&amp; &gt; </li> <li>struct VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &gt; </li> </ul> </li> <li>namespace features <ul> <li>struct State Captures the normative feature mask plus the stack trace where the global singleton instance of this type was initialized. </li> </ul> </li> <li>namespace int_types </li> <li>class kAllowAlloc </li> <li>namespace seq <ul> <li>struct Addition </li> <li>struct AllBinder </li> <li>struct AnyBinder </li> <li>struct ApplyBinder </li> <li>class Attach </li> <li>struct AttachBinder </li> <li>struct BoxedBinder </li> <li>class CacheNext </li> <li>struct CacheNextBinder </li> <li>class Chain </li> <li>struct ChainBinder </li> <li>struct Collect </li> <li>struct CollectVec </li> <li>struct Consume </li> <li>struct CountBinder </li> <li>struct DecayItem </li> <li>struct Deref </li> <li>class Empty </li> <li>class Filter </li> <li>struct FilterBinder </li> <li>class FilterMap </li> <li>struct FilterMapBinder </li> <li>struct FirstBinder </li> <li>class Flatten </li> <li>struct FlattenBinder </li> <li>struct ForEachBinder </li> <li>class Fuse </li> <li>struct FuseBinder </li> <li>class GroupBy <ul> <li>class SubGroup </li> </ul> </li> <li>struct GroupByBinder </li> <li>struct InnerReduceBinder </li> <li>class InspectAdjacent </li> <li>struct InspectAdjacentBinder </li> <li>struct IsNotFalse </li> <li>struct IsSortedBinder </li> <li>class KMergeBy </li> <li>struct KMergeByBinder </li> <li>struct LastBinder </li> <li>class Lazy </li> <li>class Map </li> <li>class MapAdjacent </li> <li>struct MapAdjacentBinder </li> <li>struct MapBinder </li> <li>class MapFold </li> <li>struct MapFoldBinder </li> <li>class MapPairwise </li> <li>struct MapPairwiseBinder </li> <li>class MergeBy <ul> <li>struct ToItem </li> </ul> </li> <li>struct MergeByBinder </li> <li>struct NaturalEquals </li> <li>struct NaturalOrder </li> <li>struct PrependBinder </li> <li>struct PrintOut </li> <li>class Printable </li> <li>struct PrintableBinder </li> <li>struct ProductBinder </li> <li>struct ReduceBinder </li> <li>struct Reverse </li> <li>struct RollingBinder </li> <li>struct RollingSumBinder </li> <li>class SingleItem </li> <li>class Splice </li> <li>struct SpliceBinder </li> <li>class StatusOk </li> <li>struct StatusOkBinder </li> <li>struct SumBinder </li> <li>class TakeN </li> <li>struct TakeNBinder </li> <li>class TakeWhile </li> <li>struct TakeWhileBinder </li> <li>struct WriteToBinder </li> <li>class Zip </li> <li>struct ZipBinder </li> <li>namespace detail <ul> <li>struct HeapOrder </li> <li>struct HeapOrderBase </li> <li>struct HeapOrderEmptyBase </li> </ul> </li> </ul> </li> <li>namespace batt::@121 </li> <li>namespace batt::@197 </li> <li>namespace batteries </li> <li>namespace boost </li> <li>namespace pico_http <ul> <li>struct ChunkedDecoder </li> <li>struct DecodeResult </li> <li>struct MessageHeader </li> <li>struct Request </li> <li>struct Response </li> <li>namespace detail </li> </ul> </li> <li>namespace pico_http::detail::@201 </li> <li>namespace std </li> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Classes/classSkipList/","title":"SkipList","text":"<p>More...</p>"},{"location":"_autogen/Classes/classSkipList/#public-types","title":"Public Types","text":"Name template &lt;i32 kHeight&gt; using SkipNode&lt; KeyT, ValueT, OrderFn, kHeight &gt; Node using SkipNodeBase&lt; KeyT, ValueT, OrderFn &gt; NodeBase"},{"location":"_autogen/Classes/classSkipList/#public-functions","title":"Public Functions","text":"Name SkipList() i32 height() const usize size() const bool empty() const const NodeBase * find(const KeyT &amp; key) const template &lt;typename KeyArg &gt; bool erase(const KeyArg &amp; key_arg) template &lt;typename KeyArg ,typename ValueArg &gt; NodeBase * emplace(KeyArg &amp;&amp; key_arg, ValueArg &amp;&amp; value_arg) void check_invariants() const"},{"location":"_autogen/Classes/classSkipList/#public-attributes","title":"Public Attributes","text":"Name Rng rng_ u64 active_levels_ Node&lt; 64 &gt; head_ usize size_"},{"location":"_autogen/Classes/classSkipList/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename KeyT ,\ntypename ValueT ,\ntypename OrderFn  =std::less&lt;KeyT&gt;,\ntypename Rng  =pcg64_unique&gt;\nclass SkipList;\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classSkipList/#using-node","title":"using Node","text":"<pre><code>template &lt;i32 kHeight&gt;\nusing SkipList&lt; KeyT, ValueT, OrderFn, Rng &gt;::Node =  SkipNode&lt;KeyT, ValueT, OrderFn, kHeight&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#using-nodebase","title":"using NodeBase","text":"<pre><code>using SkipList&lt; KeyT, ValueT, OrderFn, Rng &gt;::NodeBase =  SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classSkipList/#function-skiplist","title":"function SkipList","text":"<pre><code>inline SkipList()\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-height","title":"function height","text":"<pre><code>inline i32 height() const\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-find","title":"function find","text":"<pre><code>inline const NodeBase * find(\nconst KeyT &amp; key\n) const\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-erase","title":"function erase","text":"<pre><code>template &lt;typename KeyArg &gt;\ninline bool erase(\nconst KeyArg &amp; key_arg\n)\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-emplace","title":"function emplace","text":"<pre><code>template &lt;typename KeyArg ,\ntypename ValueArg &gt;\ninline NodeBase * emplace(\nKeyArg &amp;&amp; key_arg,\nValueArg &amp;&amp; value_arg\n)\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#function-check_invariants","title":"function check_invariants","text":"<pre><code>inline void check_invariants() const\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classSkipList/#variable-rng_","title":"variable rng_","text":"<pre><code>Rng rng_;\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#variable-active_levels_","title":"variable active_levels_","text":"<pre><code>u64 active_levels_;\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#variable-head_","title":"variable head_","text":"<pre><code>Node&lt; 64 &gt; head_;\n</code></pre>"},{"location":"_autogen/Classes/classSkipList/#variable-size_","title":"variable size_","text":"<pre><code>usize size_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classSkipNode/","title":"SkipNode","text":"<p>More...</p> <p>Inherits from SkipNodeBase&lt; KeyT, ValueT, OrderFn &gt;</p>"},{"location":"_autogen/Classes/classSkipNode/#public-types","title":"Public Types","text":"Name using SkipNodeBase&lt; KeyT, ValueT, OrderFn &gt; Super"},{"location":"_autogen/Classes/classSkipNode/#public-functions","title":"Public Functions","text":"Name SkipNode()"},{"location":"_autogen/Classes/classSkipNode/#public-attributes","title":"Public Attributes","text":"Name std::array&lt; Super *, kHeight &gt; next_"},{"location":"_autogen/Classes/classSkipNode/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename KeyT ,\ntypename ValueT ,\ntypename OrderFn ,\ni32 kHeight&gt;\nclass SkipNode;\n</code></pre>"},{"location":"_autogen/Classes/classSkipNode/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classSkipNode/#using-super","title":"using Super","text":"<pre><code>using SkipNode&lt; KeyT, ValueT, OrderFn, kHeight &gt;::Super =  SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classSkipNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classSkipNode/#function-skipnode","title":"function SkipNode","text":"<pre><code>inline SkipNode()\n</code></pre>"},{"location":"_autogen/Classes/classSkipNode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classSkipNode/#variable-next_","title":"variable next_","text":"<pre><code>std::array&lt; Super *, kHeight &gt; next_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/","title":"batt::AbstractStackAllocator","text":"<p>Inherits from batt::AbstractValue&lt; AbstractStackAllocator &gt;</p> <p>Inherited by batt::AbstractValueImpl&lt; AbstractStackAllocator, StackAllocatorImpl, T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#public-functions","title":"Public Functions","text":"Name AbstractStackAllocator(const AbstractStackAllocator &amp; ) =deleted AbstractStackAllocator &amp; operator=(const AbstractStackAllocator &amp; ) =deleted virtual ~AbstractStackAllocator() =default virtual boost::context::stack_context allocate() =0 virtual void deallocate(boost::context::stack_context &amp; ) =0"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#protected-functions","title":"Protected Functions","text":"Name AbstractStackAllocator() =default"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::AbstractValue&lt; AbstractStackAllocator &gt;</p> Name AbstractValue(const AbstractValue &amp; ) =deleted virtual ~AbstractValue() =default virtual T * copy_to(MutableBuffer memory) const =0 virtual T * move_to(MutableBuffer memory) =0 <p>Protected Functions inherited from batt::AbstractValue&lt; AbstractStackAllocator &gt;</p> Name AbstractValue() =default"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-abstractstackallocator","title":"function AbstractStackAllocator","text":"<pre><code>AbstractStackAllocator(\nconst AbstractStackAllocator &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-operator","title":"function operator=","text":"<pre><code>AbstractStackAllocator &amp; operator=(\nconst AbstractStackAllocator &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-abstractstackallocator_1","title":"function ~AbstractStackAllocator","text":"<pre><code>virtual ~AbstractStackAllocator() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-allocate","title":"function allocate","text":"<pre><code>virtual boost::context::stack_context allocate() =0\n</code></pre> <p>Reimplemented by: batt::StackAllocatorImpl::allocate</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-deallocate","title":"function deallocate","text":"<pre><code>virtual void deallocate(\nboost::context::stack_context &amp; ) =0\n</code></pre> <p>Reimplemented by: batt::StackAllocatorImpl::deallocate</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractStackAllocator/#function-abstractstackallocator_2","title":"function AbstractStackAllocator","text":"<pre><code>AbstractStackAllocator() =default\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/","title":"batt::AbstractValue","text":"<p>More...</p> <p>Inherited by batt::AbstractValuePointer&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#public-functions","title":"Public Functions","text":"Name AbstractValue(const AbstractValue &amp; ) =deleted AbstractValue &amp; operator=(const AbstractValue &amp; ) =deleted virtual ~AbstractValue() =default virtual T * copy_to(MutableBuffer memory) const =0 virtual T * move_to(MutableBuffer memory) =0"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#protected-functions","title":"Protected Functions","text":"Name AbstractValue() =default"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::AbstractValue;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-abstractvalue","title":"function AbstractValue","text":"<pre><code>AbstractValue(\nconst AbstractValue &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-operator","title":"function operator=","text":"<pre><code>AbstractValue &amp; operator=(\nconst AbstractValue &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-abstractvalue_1","title":"function ~AbstractValue","text":"<pre><code>virtual ~AbstractValue() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-copy_to","title":"function copy_to","text":"<pre><code>virtual T * copy_to(\nMutableBuffer memory\n) const =0\n</code></pre> <p>Reimplemented by: batt::AbstractValuePointer::copy_to, batt::AbstractValueImpl::copy_to</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-move_to","title":"function move_to","text":"<pre><code>virtual T * move_to(\nMutableBuffer memory\n) =0\n</code></pre> <p>Reimplemented by: batt::AbstractValuePointer::move_to, batt::AbstractValueImpl::move_to</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractValue/#function-abstractvalue_2","title":"function AbstractValue","text":"<pre><code>AbstractValue() =default\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/","title":"batt::AbstractValueImpl","text":"<p>More...</p> <p>Inherits from AbstractType</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#public-functions","title":"Public Functions","text":"Name AbstractValueImpl(T &amp;&amp; obj) AbstractType * copy_to(MutableBuffer memory) const override AbstractType * move_to(MutableBuffer memory) override"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#protected-attributes","title":"Protected Attributes","text":"Name T obj_"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename AbstractType ,\ntemplate&lt; typename &gt; class TypedImpl,\ntypename T &gt;\nclass batt::AbstractValueImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#function-abstractvalueimpl","title":"function AbstractValueImpl","text":"<pre><code>inline explicit AbstractValueImpl(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#function-copy_to","title":"function copy_to","text":"<pre><code>inline AbstractType * copy_to(\nMutableBuffer memory\n) const override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#function-move_to","title":"function move_to","text":"<pre><code>inline AbstractType * move_to(\nMutableBuffer memory\n) override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractValueImpl/#variable-obj_","title":"variable obj_","text":"<pre><code>T obj_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/","title":"batt::AbstractValuePointer","text":"<p>More...</p> <p>Inherits from batt::AbstractValue&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#public-functions","title":"Public Functions","text":"Name AbstractValuePointer(std::unique_ptr&lt; T &gt; ptr) virtual T * copy_to(MutableBuffer memory) const override virtual T * move_to(MutableBuffer memory) override"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::AbstractValue&lt; T &gt;</p> Name AbstractValue(const AbstractValue &amp; ) =deleted AbstractValue &amp; operator=(const AbstractValue &amp; ) =deleted virtual ~AbstractValue() =default <p>Protected Functions inherited from batt::AbstractValue&lt; T &gt;</p> Name AbstractValue() =default"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::AbstractValuePointer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#function-abstractvaluepointer","title":"function AbstractValuePointer","text":"<pre><code>inline explicit AbstractValuePointer(\nstd::unique_ptr&lt; T &gt; ptr\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#function-copy_to","title":"function copy_to","text":"<pre><code>inline virtual T * copy_to(\nMutableBuffer memory\n) const override\n</code></pre> <p>Reimplements: batt::AbstractValue::copy_to</p>"},{"location":"_autogen/Classes/classbatt_1_1AbstractValuePointer/#function-move_to","title":"function move_to","text":"<pre><code>inline virtual T * move_to(\nMutableBuffer memory\n) override\n</code></pre> <p>Reimplements: batt::AbstractValue::move_to</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/","title":"classbatt 1 1AtomicCounterGauge","text":"<p>title: batt::AtomicCounterGauge summary: An atomic variable that maintains a gauge-like value, which can rise and fall over time, by means of two monotonic counters: one for increases, one for decreases. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#battatomiccountergauge","title":"batt::AtomicCounterGauge","text":"<p>An atomic variable that maintains a gauge-like value, which can rise and fall over time, by means of two monotonic counters: one for increases, one for decreases.  More...</p> <p><code>#include &lt;batteries/atomic_counter_gauge.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-classes","title":"Public Classes","text":"Name class State A value of the atomic variable that implements AtomicCounterGauge."},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-types","title":"Public Types","text":"Name using AtomicCounterGauge Self using IntT value_type"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-functions","title":"Public Functions","text":"Name AtomicCounterGauge(value_type initial_value =0)Constructs an AtomicCounterGauge with the given initial (gauge) value. AtomicCounterGauge(State initial_state)Constructs an AtomicCounterGauge with the given initial raw state value. State load()Atomically loads and returns the value of the variable. void store(value_type new_value)Atomically updates the (gauge) value of the variable. void store(State new_state)Atomically updates the raw state value of the variable. State exchange(State new_state)Atomically swaps the raw state value of the variable, returning its old value. State exchange(value_type new_value)Atomically swaps the gauge value of the variable, returning its old value. State fetch_add(value_type delta)Atomically increments the variable by increasing the add counter. State increment()Same as <code>this-&gt;fetch_add(1)</code>. State fetch_sub(value_type delta)Atomically decrements the variable by increasing the sub counter. State decrement()Same as <code>this-&gt;fetch_sub(1)</code>."},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kNumBits constexpr usize kNumCountBits constexpr value_type kHalfMask constexpr value_type kCountMask constexpr value_type kGaugeMask constexpr usize kAddShift constexpr usize kAddOverflowShift constexpr usize kSubShift constexpr usize kSubOverflowShift constexpr value_type kAddIncrement constexpr value_type kAddOverflow constexpr value_type kAddMask constexpr value_type kSubIncrement constexpr value_type kSubOverflow constexpr value_type kSubMask"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename IntT &gt;\nclass batt::AtomicCounterGauge;\n</code></pre> <p>An atomic variable that maintains a gauge-like value, which can rise and fall over time, by means of two monotonic counters: one for increases, one for decreases. </p> <p>The monotonic counters that combine to form the gauge value are stored in the upper and lower halves of the bits of a single atomic variable. Because under this scheme, we must prevent overflow from one counter into the next, each modification to the variable is subsequently normalized by resetting the most significant bit of both the increase counter and decrease counter to zero if they are ever both observed to be 1. This normalization is done via compare-and-swap loop after an atomic fetch add operation to do either the addition or subtraction. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#using-self","title":"using Self","text":"<pre><code>using batt::AtomicCounterGauge&lt; IntT &gt;::Self =  AtomicCounterGauge;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#using-value_type","title":"using value_type","text":"<pre><code>using batt::AtomicCounterGauge&lt; IntT &gt;::value_type =  IntT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-atomiccountergauge","title":"function AtomicCounterGauge","text":"<pre><code>inline explicit AtomicCounterGauge(\nvalue_type initial_value =0\n)\n</code></pre> <p>Constructs an AtomicCounterGauge with the given initial (gauge) value. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-atomiccountergauge_1","title":"function AtomicCounterGauge","text":"<pre><code>inline explicit AtomicCounterGauge(\nState initial_state\n)\n</code></pre> <p>Constructs an AtomicCounterGauge with the given initial raw state value. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-load","title":"function load","text":"<pre><code>inline State load()\n</code></pre> <p>Atomically loads and returns the value of the variable. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-store","title":"function store","text":"<pre><code>inline void store(\nvalue_type new_value\n)\n</code></pre> <p>Atomically updates the (gauge) value of the variable. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-store_1","title":"function store","text":"<pre><code>inline void store(\nState new_state\n)\n</code></pre> <p>Atomically updates the raw state value of the variable. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-exchange","title":"function exchange","text":"<pre><code>inline State exchange(\nState new_state\n)\n</code></pre> <p>Atomically swaps the raw state value of the variable, returning its old value. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-exchange_1","title":"function exchange","text":"<pre><code>inline State exchange(\nvalue_type new_value\n)\n</code></pre> <p>Atomically swaps the gauge value of the variable, returning its old value. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-fetch_add","title":"function fetch_add","text":"<pre><code>inline State fetch_add(\nvalue_type delta\n)\n</code></pre> <p>Atomically increments the variable by increasing the add counter. </p> <p><code>delta</code> must NOT be negative; use AtomicCounterGauge::fetch_sub in this case. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-increment","title":"function increment","text":"<pre><code>inline State increment()\n</code></pre> <p>Same as <code>this-&gt;fetch_add(1)</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-fetch_sub","title":"function fetch_sub","text":"<pre><code>inline State fetch_sub(\nvalue_type delta\n)\n</code></pre> <p>Atomically decrements the variable by increasing the sub counter. </p> <p><code>delta</code> must NOT be negative; use AtomicCounterGauge::fetch_sub in this case. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#function-decrement","title":"function decrement","text":"<pre><code>inline State decrement()\n</code></pre> <p>Same as <code>this-&gt;fetch_sub(1)</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-knumbits","title":"variable kNumBits","text":"<pre><code>static constexpr usize kNumBits = sizeof(IntT) * 8;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-knumcountbits","title":"variable kNumCountBits","text":"<pre><code>static constexpr usize kNumCountBits = kNumBits / 2;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-khalfmask","title":"variable kHalfMask","text":"<pre><code>static constexpr value_type kHalfMask = ((value_type{1} &lt;&lt; kNumCountBits) - 1);\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kcountmask","title":"variable kCountMask","text":"<pre><code>static constexpr value_type kCountMask = (value_type{1} &lt;&lt; (kNumCountBits - 1)) - 1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kgaugemask","title":"variable kGaugeMask","text":"<pre><code>static constexpr value_type kGaugeMask = kCountMask;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kaddshift","title":"variable kAddShift","text":"<pre><code>static constexpr usize kAddShift = 0;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kaddoverflowshift","title":"variable kAddOverflowShift","text":"<pre><code>static constexpr usize kAddOverflowShift = kNumCountBits - 1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-ksubshift","title":"variable kSubShift","text":"<pre><code>static constexpr usize kSubShift = kNumCountBits;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-ksuboverflowshift","title":"variable kSubOverflowShift","text":"<pre><code>static constexpr usize kSubOverflowShift = kNumBits - 1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kaddincrement","title":"variable kAddIncrement","text":"<pre><code>static constexpr value_type kAddIncrement = value_type{1} &lt;&lt; kAddShift;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kaddoverflow","title":"variable kAddOverflow","text":"<pre><code>static constexpr value_type kAddOverflow = value_type{1} &lt;&lt; kAddOverflowShift;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-kaddmask","title":"variable kAddMask","text":"<pre><code>static constexpr value_type kAddMask = kHalfMask &lt;&lt; kAddShift;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-ksubincrement","title":"variable kSubIncrement","text":"<pre><code>static constexpr value_type kSubIncrement = value_type{1} &lt;&lt; kSubShift;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-ksuboverflow","title":"variable kSubOverflow","text":"<pre><code>static constexpr value_type kSubOverflow = value_type{1} &lt;&lt; kSubOverflowShift;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge/#variable-ksubmask","title":"variable kSubMask","text":"<pre><code>static constexpr value_type kSubMask = kHalfMask &lt;&lt; kSubShift;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/","title":"batt::AtomicCounterGauge::State","text":"<p>A value of the atomic variable that implements AtomicCounterGauge.  More...</p> <p><code>#include &lt;batteries/atomic_counter_gauge.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#public-functions","title":"Public Functions","text":"Name State from_counts(value_type add_count, value_type sub_count)Constructs and returns a State value representing the combination of adding and subtracting the given counts. State from_gauge(value_type gauge_value)Constructs and returns a State value representing an instantaneous gauge value. value_type normalize(value_type observed_state)Returns the normalized form of a given raw state value. State(value_type value)Constructs a State from the exact atomic representation <code>value</code>. value_type get_gauge() constReturns the gauge interpretation value of the State. value_type get_add_count() constReturns the add (positive) component of the counter(s) interpretation of the State. value_type get_sub_count() constReturns the subtract (negative) component of the counter(s) interpretation of the State. value_type value() constReturns the raw state value."},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#friends","title":"Friends","text":"Name class AtomicCounterGauge&lt; IntT &gt;"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::AtomicCounterGauge::State;\n</code></pre> <p>A value of the atomic variable that implements AtomicCounterGauge. </p> <p>Can be interpreted either as add/sub counters (via State::get_add_count, State::get_sub_count) or as a single combined \"gauge\" value (via State::get_gauge()).</p> <p>IMPORTANT: the dynamic range of counters and gauges is constrained by the mask values <code>AtomicCounterGauge::kCountMask</code> and <code>AtomicCounterGauge::kGaugeMask</code> respectively; i.e., if the \"true\" value of, say, the gauge interpretation of a State<code>s</code> is expected to be <code>x</code>, then application code may only assume that <code>(s.get_gauge() &amp; [AtomicCounterGauge](/_autogen/Classes/classbatt_1_1AtomicCounterGauge/)&lt;T&gt;::kGaugeMask) == (x &amp; [AtomicCounterGauge](/_autogen/Classes/classbatt_1_1AtomicCounterGauge/)&lt;T&gt;::kGaugeMask)</code>, but generally NOT that <code>s.get_gauge() == x</code>. This caveat applies to all returned values for this class (so is only explicitly stated here). </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-from_counts","title":"function from_counts","text":"<pre><code>static inline State from_counts(\nvalue_type add_count,\nvalue_type sub_count\n)\n</code></pre> <p>Constructs and returns a State value representing the combination of adding and subtracting the given counts. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-from_gauge","title":"function from_gauge","text":"<pre><code>static inline State from_gauge(\nvalue_type gauge_value\n)\n</code></pre> <p>Constructs and returns a State value representing an instantaneous gauge value. </p> <p>This is equivalent to <code>State::from_counts(gauge_value, 0)</code> (or in fact to any expression <code>[State::from_counts](/_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-from-counts)(gauge_value + K, K)</code> for arbitrary K &lt;= AtomicCounterGauge::kGaugeMask). </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-normalize","title":"function normalize","text":"<pre><code>static inline value_type normalize(\nvalue_type observed_state\n)\n</code></pre> <p>Returns the normalized form of a given raw state value. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-state","title":"function State","text":"<pre><code>inline explicit State(\nvalue_type value\n)\n</code></pre> <p>Constructs a State from the exact atomic representation <code>value</code>. </p> <p><code>value</code>'s least significant bits should be set to the add counter, and most significant bits should be set to the subtract counter. The value should also be normalized (i.e., at most 1 of the most significant bit within either count value may be set; if they are both 1, then the normalized form sets them both to 0).</p> <p>NOTE: Because this constructor is used internally in places where it is already known that <code>value</code> is in normalized form, this constructor does NOT make any attempt to validate or normalize the passed value. If you pass a non-normalized value here, behavior is undefined. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-get_gauge","title":"function get_gauge","text":"<pre><code>inline value_type get_gauge() const\n</code></pre> <p>Returns the gauge interpretation value of the State. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-get_add_count","title":"function get_add_count","text":"<pre><code>inline value_type get_add_count() const\n</code></pre> <p>Returns the add (positive) component of the counter(s) interpretation of the State. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-get_sub_count","title":"function get_sub_count","text":"<pre><code>inline value_type get_sub_count() const\n</code></pre> <p>Returns the subtract (negative) component of the counter(s) interpretation of the State. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#function-value","title":"function value","text":"<pre><code>inline value_type value() const\n</code></pre> <p>Returns the raw state value. </p>"},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1AtomicCounterGauge_1_1State/#friend-atomiccountergauge-intt","title":"friend AtomicCounterGauge&lt; IntT &gt;","text":"<pre><code>friend class AtomicCounterGauge&lt; IntT &gt;(\nAtomicCounterGauge&lt; IntT &gt; );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/","title":"batt::BasicAbstractHandler","text":"<p>A type-erased async completion handler with linked list pointers.  More...</p> <p><code>#include &lt;batteries/async/handler.hpp&gt;</code></p> <p>Inherits from Base</p> <p>Inherited by batt::LazyLatch&lt; T, InitFn &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#public-classes","title":"Public Classes","text":"Name struct Deleter Deleter for use in std::unique_ptr."},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#public-types","title":"Public Types","text":"Name using BasicAbstractHandler Self"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#public-functions","title":"Public Functions","text":"Name BasicAbstractHandler(const Self &amp; ) =deletedAbstractHandler is not copy-constructible. Self &amp; operator=(const Self &amp; ) =deletedAbstractHandler is not copy-assignable. virtual void notify(Args... args) =0Invoke the handler; notify should delete <code>this</code> as a side-effect. virtual void destroy() =0Release memory associated with this handler and destroy the implementation object, without invoking it. virtual void dump(std::ostream &amp; out) =0Print the type and any other associated information about the handler."},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#protected-functions","title":"Protected Functions","text":"Name BasicAbstractHandler() =default virtual ~BasicAbstractHandler() =default"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Base ,\ntypename... Args&gt;\nclass batt::BasicAbstractHandler;\n</code></pre> <p>A type-erased async completion handler with linked list pointers. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#using-self","title":"using Self","text":"<pre><code>using batt::BasicAbstractHandler&lt; Base, Args &gt;::Self =  BasicAbstractHandler;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-basicabstracthandler","title":"function BasicAbstractHandler","text":"<pre><code>BasicAbstractHandler(\nconst Self &amp; ) =deleted\n</code></pre> <p>AbstractHandler is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-operator","title":"function operator=","text":"<pre><code>Self &amp; operator=(\nconst Self &amp; ) =deleted\n</code></pre> <p>AbstractHandler is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-notify","title":"function notify","text":"<pre><code>virtual void notify(\nArgs... args\n) =0\n</code></pre> <p>Invoke the handler; notify should delete <code>this</code> as a side-effect. </p> <p>Reimplemented by: batt::BasicHandlerImpl::notify</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-destroy","title":"function destroy","text":"<pre><code>virtual void destroy() =0\n</code></pre> <p>Release memory associated with this handler and destroy the implementation object, without invoking it. </p> <p>Reimplemented by: batt::BasicHandlerImpl::destroy, batt::LazyLatch::destroy</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-dump","title":"function dump","text":"<pre><code>virtual void dump(\nstd::ostream &amp; out\n) =0\n</code></pre> <p>Print the type and any other associated information about the handler. </p> <p>Reimplemented by: batt::BasicHandlerImpl::dump, batt::LazyLatch::dump</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-basicabstracthandler_1","title":"function BasicAbstractHandler","text":"<pre><code>BasicAbstractHandler() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicAbstractHandler/#function-basicabstracthandler_2","title":"function ~BasicAbstractHandler","text":"<pre><code>virtual ~BasicAbstractHandler() =default\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/","title":"batt::BasicExecutor","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#public-types","title":"Public Types","text":"Name using BasicExecutor Self using ContextT context_type"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#public-functions","title":"Public Functions","text":"Name constexpr BasicExecutor() constexpr BasicExecutor(ContextT * context) constexpr BasicExecutor(const Self &amp; other) constexpr BasicExecutor(Self &amp;&amp; other) Self &amp; operator=(const Self &amp; other) Self &amp; operator=(Self &amp;&amp; other) ~BasicExecutor() void swap(Self &amp; other) ContextT &amp; context() const constexpr auto require(boost::asio::execution::blocking_t::possibly_t ) const constexpr auto require(boost::asio::execution::blocking_t::never_t ) const constexpr auto require(boost::asio::execution::relationship_t::fork_t ) const constexpr auto require(boost::asio::execution::relationship_t::continuation_t ) const constexpr auto require(boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto require(boost::asio::execution::outstanding_work_t::untracked_t ) const template &lt;typename OtherAllocator &gt; constexpr Self require(boost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const constexpr Self require(boost::asio::execution::allocator_t&lt; void &gt; ) const template &lt;typename T &gt; constexpr auto prefer(boost::asio::execution::prefer_only&lt; T &gt; ) const constexpr auto query(boost::asio::execution::blocking_t ) const constexpr auto query(boost::asio::execution::relationship_t ) const template &lt;typename OtherAllocator &gt; constexpr auto query(boost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const constexpr auto query(boost::asio::execution::allocator_t&lt; void &gt; ) const auto query(boost::asio::execution::context_t ) const auto query(boost::asio::execution::context_as_t&lt; boost::asio::execution_context &amp; &gt; ) const void on_work_started() const void on_work_finished() const template &lt;typename Fn &gt; void execute(Fn &amp;&amp; fn) const template &lt;typename Fn ,typename FnAllocator &gt; void dispatch(Fn &amp;&amp; fn, FnAllocator &amp;&amp; ) const template &lt;typename Fn ,typename FnAllocator &gt; void post(Fn &amp;&amp; fn, FnAllocator &amp;&amp; ) const template &lt;typename Fn ,typename FnAllocator &gt; void defer(Fn &amp;&amp; fn, FnAllocator &amp;&amp; ) const constexpr auto query(boost::asio::execution::mapping_t ) constexpr auto query(boost::asio::execution::outstanding_work_t )"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename ContextT ,\ntypename OutstandingWorkP ,\ntypename BlockingP ,\ntypename RelationshipP &gt;\nclass batt::BasicExecutor;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#using-self","title":"using Self","text":"<pre><code>using batt::BasicExecutor&lt; ContextT, OutstandingWorkP, BlockingP, RelationshipP &gt;::Self =  BasicExecutor;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#using-context_type","title":"using context_type","text":"<pre><code>using batt::BasicExecutor&lt; ContextT, OutstandingWorkP, BlockingP, RelationshipP &gt;::context_type =  ContextT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-basicexecutor","title":"function BasicExecutor","text":"<pre><code>inline explicit constexpr BasicExecutor()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-basicexecutor_1","title":"function BasicExecutor","text":"<pre><code>inline explicit constexpr BasicExecutor(\nContextT * context\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-basicexecutor_2","title":"function BasicExecutor","text":"<pre><code>inline constexpr BasicExecutor(\nconst Self &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-basicexecutor_3","title":"function BasicExecutor","text":"<pre><code>inline constexpr BasicExecutor(\nSelf &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-operator","title":"function operator=","text":"<pre><code>inline Self &amp; operator=(\nconst Self &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-operator_1","title":"function operator=","text":"<pre><code>inline Self &amp; operator=(\nSelf &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-basicexecutor_4","title":"function ~BasicExecutor","text":"<pre><code>inline ~BasicExecutor()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nSelf &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-context","title":"function context","text":"<pre><code>inline ContextT &amp; context() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::blocking_t::possibly_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_1","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::blocking_t::never_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_2","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::relationship_t::fork_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_3","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::relationship_t::continuation_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_4","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::outstanding_work_t::tracked_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_5","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::outstanding_work_t::untracked_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_6","title":"function require","text":"<pre><code>template &lt;typename OtherAllocator &gt;\ninline constexpr Self require(\nboost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-require_7","title":"function require","text":"<pre><code>inline constexpr Self require(\nboost::asio::execution::allocator_t&lt; void &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-prefer","title":"function prefer","text":"<pre><code>template &lt;typename T &gt;\ninline constexpr auto prefer(\nboost::asio::execution::prefer_only&lt; T &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query","title":"function query","text":"<pre><code>constexpr auto query(\nboost::asio::execution::blocking_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_1","title":"function query","text":"<pre><code>constexpr auto query(\nboost::asio::execution::relationship_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_2","title":"function query","text":"<pre><code>template &lt;typename OtherAllocator &gt;\nconstexpr auto query(\nboost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_3","title":"function query","text":"<pre><code>constexpr auto query(\nboost::asio::execution::allocator_t&lt; void &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_4","title":"function query","text":"<pre><code>auto query(\nboost::asio::execution::context_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_5","title":"function query","text":"<pre><code>auto query(\nboost::asio::execution::context_as_t&lt; boost::asio::execution_context &amp; &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-on_work_started","title":"function on_work_started","text":"<pre><code>void on_work_started() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-on_work_finished","title":"function on_work_finished","text":"<pre><code>void on_work_finished() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-execute","title":"function execute","text":"<pre><code>template &lt;typename Fn &gt;\nvoid execute(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-dispatch","title":"function dispatch","text":"<pre><code>template &lt;typename Fn ,\ntypename FnAllocator &gt;\nvoid dispatch(\nFn &amp;&amp; fn,\nFnAllocator &amp;&amp; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-post","title":"function post","text":"<pre><code>template &lt;typename Fn ,\ntypename FnAllocator &gt;\nvoid post(\nFn &amp;&amp; fn,\nFnAllocator &amp;&amp; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-defer","title":"function defer","text":"<pre><code>template &lt;typename Fn ,\ntypename FnAllocator &gt;\nvoid defer(\nFn &amp;&amp; fn,\nFnAllocator &amp;&amp; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_6","title":"function query","text":"<pre><code>static constexpr auto query(\nboost::asio::execution::mapping_t )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicExecutor/#function-query_7","title":"function query","text":"<pre><code>static constexpr auto query(\nboost::asio::execution::outstanding_work_t )\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/","title":"batt::BasicFakeExecutor","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-types","title":"Public Types","text":"Name using BasicFakeExecutor Self"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-functions","title":"Public Functions","text":"Name constexpr BasicFakeExecutor() constexpr BasicFakeExecutor(FakeExecutionContext * context) constexpr BasicFakeExecutor(const Self &amp; other) constexpr BasicFakeExecutor(Self &amp;&amp; other) Self &amp; operator=(const Self &amp; other) Self &amp; operator=(Self &amp;&amp; other) ~BasicFakeExecutor() void swap(Self &amp; other) FakeExecutionContext &amp; context() const constexpr Self require(boost::asio::execution::blocking_t::possibly_t ) const constexpr Self require(boost::asio::execution::blocking_t::never_t ) const constexpr Self require(boost::asio::execution::relationship_t::fork_t ) const constexpr Self require(boost::asio::execution::relationship_t::continuation_t ) const constexpr auto require(boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto require(boost::asio::execution::outstanding_work_t::untracked_t ) const template &lt;typename OtherAllocator &gt; constexpr Self require(boost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const constexpr Self require(boost::asio::execution::allocator_t&lt; void &gt; ) const constexpr Self prefer(boost::asio::execution::blocking_t::possibly_t ) const constexpr Self prefer(boost::asio::execution::blocking_t::never_t ) const constexpr Self prefer(boost::asio::execution::relationship_t::fork_t ) const constexpr Self prefer(boost::asio::execution::relationship_t::continuation_t ) const constexpr auto prefer(boost::asio::execution::outstanding_work_t::tracked_t ) const constexpr auto prefer(boost::asio::execution::outstanding_work_t::untracked_t ) const template &lt;typename OtherAllocator &gt; constexpr Self prefer(boost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const constexpr Self prefer(boost::asio::execution::allocator_t&lt; void &gt; ) const FakeExecutionContext &amp; query(boost::asio::execution::context_t ) const boost::asio::execution_context &amp; query(boost::asio::execution::context_as_t&lt; boost::asio::execution_context &amp; &gt; ) const constexpr boost::asio::execution::blocking_t query(boost::asio::execution::blocking_t ) const constexpr boost::asio::execution::relationship_t query(boost::asio::execution::relationship_t ) const template &lt;typename OtherAllocator &gt; constexpr std::allocator&lt; void &gt; query(boost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const constexpr std::allocator&lt; void &gt; query(boost::asio::execution::allocator_t&lt; void &gt; ) const void on_work_started() const void on_work_finished() const template &lt;typename Fn &gt; void execute(Fn &amp;&amp; fn) const template &lt;typename Fn ,typename FnAllocator &gt; void dispatch(Fn &amp;&amp; fn, FnAllocator &amp;&amp; ) const template &lt;typename Fn ,typename FnAllocator &gt; void post(Fn &amp;&amp; fn, FnAllocator &amp;&amp; ) const template &lt;typename Fn ,typename FnAllocator &gt; void defer(Fn &amp;&amp; fn, FnAllocator &amp;&amp; ) const constexpr boost::asio::execution::mapping_t query(boost::asio::execution::mapping_t ) constexpr boost::asio::execution::outstanding_work_t query(boost::asio::execution::outstanding_work_t )"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename OutstandingWorkP &gt;\nclass batt::BasicFakeExecutor;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#using-self","title":"using Self","text":"<pre><code>using batt::BasicFakeExecutor&lt; OutstandingWorkP &gt;::Self =  BasicFakeExecutor;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor","title":"function BasicFakeExecutor","text":"<pre><code>inline explicit constexpr BasicFakeExecutor()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_1","title":"function BasicFakeExecutor","text":"<pre><code>inline explicit constexpr BasicFakeExecutor(\nFakeExecutionContext * context\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_2","title":"function BasicFakeExecutor","text":"<pre><code>inline constexpr BasicFakeExecutor(\nconst Self &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_3","title":"function BasicFakeExecutor","text":"<pre><code>inline constexpr BasicFakeExecutor(\nSelf &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-operator","title":"function operator=","text":"<pre><code>inline Self &amp; operator=(\nconst Self &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-operator_1","title":"function operator=","text":"<pre><code>inline Self &amp; operator=(\nSelf &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-basicfakeexecutor_4","title":"function ~BasicFakeExecutor","text":"<pre><code>inline ~BasicFakeExecutor()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nSelf &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-context","title":"function context","text":"<pre><code>inline FakeExecutionContext &amp; context() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require","title":"function require","text":"<pre><code>inline constexpr Self require(\nboost::asio::execution::blocking_t::possibly_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_1","title":"function require","text":"<pre><code>inline constexpr Self require(\nboost::asio::execution::blocking_t::never_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_2","title":"function require","text":"<pre><code>inline constexpr Self require(\nboost::asio::execution::relationship_t::fork_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_3","title":"function require","text":"<pre><code>inline constexpr Self require(\nboost::asio::execution::relationship_t::continuation_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_4","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::outstanding_work_t::tracked_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_5","title":"function require","text":"<pre><code>inline constexpr auto require(\nboost::asio::execution::outstanding_work_t::untracked_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_6","title":"function require","text":"<pre><code>template &lt;typename OtherAllocator &gt;\ninline constexpr Self require(\nboost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-require_7","title":"function require","text":"<pre><code>inline constexpr Self require(\nboost::asio::execution::allocator_t&lt; void &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer","title":"function prefer","text":"<pre><code>inline constexpr Self prefer(\nboost::asio::execution::blocking_t::possibly_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_1","title":"function prefer","text":"<pre><code>inline constexpr Self prefer(\nboost::asio::execution::blocking_t::never_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_2","title":"function prefer","text":"<pre><code>inline constexpr Self prefer(\nboost::asio::execution::relationship_t::fork_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_3","title":"function prefer","text":"<pre><code>inline constexpr Self prefer(\nboost::asio::execution::relationship_t::continuation_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_4","title":"function prefer","text":"<pre><code>inline constexpr auto prefer(\nboost::asio::execution::outstanding_work_t::tracked_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_5","title":"function prefer","text":"<pre><code>inline constexpr auto prefer(\nboost::asio::execution::outstanding_work_t::untracked_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_6","title":"function prefer","text":"<pre><code>template &lt;typename OtherAllocator &gt;\ninline constexpr Self prefer(\nboost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-prefer_7","title":"function prefer","text":"<pre><code>inline constexpr Self prefer(\nboost::asio::execution::allocator_t&lt; void &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query","title":"function query","text":"<pre><code>inline FakeExecutionContext &amp; query(\nboost::asio::execution::context_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_1","title":"function query","text":"<pre><code>inline boost::asio::execution_context &amp; query(\nboost::asio::execution::context_as_t&lt; boost::asio::execution_context &amp; &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_2","title":"function query","text":"<pre><code>inline constexpr boost::asio::execution::blocking_t query(\nboost::asio::execution::blocking_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_3","title":"function query","text":"<pre><code>inline constexpr boost::asio::execution::relationship_t query(\nboost::asio::execution::relationship_t ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_4","title":"function query","text":"<pre><code>template &lt;typename OtherAllocator &gt;\nconstexpr std::allocator&lt; void &gt; query(\nboost::asio::execution::allocator_t&lt; OtherAllocator &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_5","title":"function query","text":"<pre><code>constexpr std::allocator&lt; void &gt; query(\nboost::asio::execution::allocator_t&lt; void &gt; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-on_work_started","title":"function on_work_started","text":"<pre><code>inline void on_work_started() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-on_work_finished","title":"function on_work_finished","text":"<pre><code>inline void on_work_finished() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-execute","title":"function execute","text":"<pre><code>template &lt;typename Fn &gt;\nvoid execute(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-dispatch","title":"function dispatch","text":"<pre><code>template &lt;typename Fn ,\ntypename FnAllocator &gt;\ninline void dispatch(\nFn &amp;&amp; fn,\nFnAllocator &amp;&amp; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-post","title":"function post","text":"<pre><code>template &lt;typename Fn ,\ntypename FnAllocator &gt;\ninline void post(\nFn &amp;&amp; fn,\nFnAllocator &amp;&amp; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-defer","title":"function defer","text":"<pre><code>template &lt;typename Fn ,\ntypename FnAllocator &gt;\ninline void defer(\nFn &amp;&amp; fn,\nFnAllocator &amp;&amp; ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_6","title":"function query","text":"<pre><code>static inline constexpr boost::asio::execution::mapping_t query(\nboost::asio::execution::mapping_t )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicFakeExecutor/#function-query_7","title":"function query","text":"<pre><code>static inline constexpr boost::asio::execution::outstanding_work_t query(\nboost::asio::execution::outstanding_work_t )\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/","title":"batt::BasicHandlerImpl","text":"<p>More...</p> <p>Inherits from batt::BasicAbstractHandler&lt; Base, Args... &gt;, Base</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#public-types","title":"Public Types","text":"Name using BasicHandlerImpl Self using typename std::allocator_traits&lt; boost::asio::associated_allocator_t&lt; HandlerFn &gt; &gt;::template rebind_alloc&lt; Self &gt; allocator_type"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#public-functions","title":"Public Functions","text":"Name template &lt;typename HandlerFnArg &gt; Self * make_new(HandlerFnArg &amp;&amp; h) template &lt;typename HandlerFnArg &gt; Self * make_new(HandlerFnArg &amp;&amp; h, usize extra_bytes) template &lt;typename HandlerFnArg ,typename  =batt::EnableIfNoShadow&gt;  BasicHandlerImpl(HandlerFnArg &amp;&amp; h) virtual void notify(Args... args) overrideInvoke the handler; notify should delete <code>this</code> as a side-effect. virtual void destroy() overrideRelease memory associated with this handler and destroy the implementation object, without invoking it. virtual void dump(std::ostream &amp; out) overridePrint the type and any other associated information about the handler. HandlerFn &amp; get_fn()"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from batt::BasicAbstractHandler&lt; Base, Args... &gt;</p> Name struct Deleter Deleter for use in std::unique_ptr. <p>Public Functions inherited from batt::BasicAbstractHandler&lt; Base, Args... &gt;</p> Name BasicAbstractHandler(const Self &amp; ) =deletedAbstractHandler is not copy-constructible. Self &amp; operator=(const Self &amp; ) =deletedAbstractHandler is not copy-assignable. <p>Protected Functions inherited from batt::BasicAbstractHandler&lt; Base, Args... &gt;</p> Name BasicAbstractHandler() =default virtual ~BasicAbstractHandler() =default"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename HandlerFn ,\ntypename Base ,\ntypename... Args&gt;\nclass batt::BasicHandlerImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#using-self","title":"using Self","text":"<pre><code>using batt::BasicHandlerImpl&lt; HandlerFn, Base, Args &gt;::Self =  BasicHandlerImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#using-allocator_type","title":"using allocator_type","text":"<pre><code>using batt::BasicHandlerImpl&lt; HandlerFn, Base, Args &gt;::allocator_type =  typename std::allocator_traits&lt; boost::asio::associated_allocator_t&lt;HandlerFn&gt; &gt;::template rebind_alloc&lt;Self&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-make_new","title":"function make_new","text":"<pre><code>template &lt;typename HandlerFnArg &gt;\nstatic inline Self * make_new(\nHandlerFnArg &amp;&amp; h\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-make_new_1","title":"function make_new","text":"<pre><code>template &lt;typename HandlerFnArg &gt;\nstatic inline Self * make_new(\nHandlerFnArg &amp;&amp; h,\nusize extra_bytes\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-basichandlerimpl","title":"function BasicHandlerImpl","text":"<pre><code>template &lt;typename HandlerFnArg ,\ntypename  =batt::EnableIfNoShadow&lt;Self, HandlerFnArg&amp;&amp;&gt;&gt;\ninline explicit BasicHandlerImpl(\nHandlerFnArg &amp;&amp; h\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-notify","title":"function notify","text":"<pre><code>inline virtual void notify(\nArgs... args\n) override\n</code></pre> <p>Invoke the handler; notify should delete <code>this</code> as a side-effect. </p> <p>Reimplements: batt::BasicAbstractHandler::notify</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-destroy","title":"function destroy","text":"<pre><code>inline virtual void destroy() override\n</code></pre> <p>Release memory associated with this handler and destroy the implementation object, without invoking it. </p> <p>Reimplements: batt::BasicAbstractHandler::destroy</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-dump","title":"function dump","text":"<pre><code>inline virtual void dump(\nstd::ostream &amp; out\n) override\n</code></pre> <p>Print the type and any other associated information about the handler. </p> <p>Reimplements: batt::BasicAbstractHandler::dump</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHandlerImpl/#function-get_fn","title":"function get_fn","text":"<pre><code>inline HandlerFn &amp; get_fn()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHttpClientConnection/","title":"batt::BasicHttpClientConnection","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicHttpClientConnection/#public-functions","title":"Public Functions","text":"Name void spawn(HttpClientHostContext &amp; context, Watch&lt; usize &gt; &amp; active_connections)Used to start an HttpClientConnection processing Task."},{"location":"_autogen/Classes/classbatt_1_1BasicHttpClientConnection/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Transport &gt;\nclass batt::BasicHttpClientConnection;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicHttpClientConnection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicHttpClientConnection/#function-spawn","title":"function spawn","text":"<pre><code>static void spawn(\nHttpClientHostContext &amp; context,\nWatch&lt; usize &gt; &amp; active_connections\n)\n</code></pre> <p>Used to start an HttpClientConnection processing Task. </p> <p>The created Task will pull from the request/response pair queue of the passed context until an error occurs or the queue is closed. This function increments <code>active_connections</code> by one before returning, and decrements <code>active_connections</code> when it exits.</p> <p>WARNING: Be careful about asserting/assuming that <code>active_connections</code> will appear to increase from the caller's perspective! This function guarantees that <code>active_connections</code> is incremented before returning, but it does NOT guarantee that <code>active_connections</code> is not subsequently decremented \"before\" returning, since that can happen asynchronously on some other thread/task.)</p> <p>This function uses batt::Task::spawn internally, so the created Task will be a sub-Task of the currently running Task (this means that the task that calls HttpClientConnection::spawn will automatically join to the sub-Task.</p> <p>It is the caller's responsibility to ensure that <code>context</code> and <code>active_connections</code> do not go out of scope while there are still active connections (as tracked by the passed Watch). </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/","title":"batt::BasicMCSMutex","text":"<p>A fair mutual exclusion lock based on the MCS lock algorithm.  More...</p> <p><code>#include &lt;batteries/async/mcs_lock.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#public-classes","title":"Public Classes","text":"Name class Lock struct Metrics Metric counters for measuring behavior of MCSMutex locks."},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#public-functions","title":"Public Functions","text":"Name Metrics &amp; metrics() BasicMCSMutex() =default BasicMCSMutex(const BasicMCSMutex &amp; ) =deleted BasicMCSMutex &amp; operator=(const BasicMCSMutex &amp; ) =deleted bool is_locked() constReturns true iff the mutex is currently held by some Lock instance."},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;bool kMetricsEnabled =true&gt;\nclass batt::BasicMCSMutex;\n</code></pre> <p>A fair mutual exclusion lock based on the MCS lock algorithm. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#function-metrics","title":"function metrics","text":"<pre><code>static inline Metrics &amp; metrics()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#function-basicmcsmutex","title":"function BasicMCSMutex","text":"<pre><code>BasicMCSMutex() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#function-basicmcsmutex_1","title":"function BasicMCSMutex","text":"<pre><code>BasicMCSMutex(\nconst BasicMCSMutex &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#function-operator","title":"function operator=","text":"<pre><code>BasicMCSMutex &amp; operator=(\nconst BasicMCSMutex &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex/#function-is_locked","title":"function is_locked","text":"<pre><code>inline bool is_locked() const\n</code></pre> <p>Returns true iff the mutex is currently held by some Lock instance. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/","title":"batt::BasicMCSMutex::Lock","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#public-functions","title":"Public Functions","text":"Name Lock(BasicMCSMutex &amp; mutex)Acquires a lock on the passed mutex. Lock(BasicMCSMutex &amp; mutex, std::defer_lock_t )Does not acquire the mutex until this-&gt;lock() is called. ~Lock()Releases the lock held by the current thread. Lock(const Lock &amp; ) =deletedMCSMutex::Lock is not copy-constructible. Lock &amp; operator=(const Lock &amp; ) =deletedMCSMutex::Lock is not copy-assignable. bool owns_lock() constReturns true iff this Lock currently owns the mutex. void lock()Lock the mutex. void unlock()Unlock the mutex. bool needs_reset() constReturns true if this-&gt;reset() must be called before this-&gt;lock() may be called again. void reset()Resets the internal lock state so that this lock can re-acquire the mutex."},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kAcquireSpinCyclesInit constexpr usize kAcquireSpinCyclesSteady"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-lock","title":"function Lock","text":"<pre><code>inline explicit Lock(\nBasicMCSMutex &amp; mutex\n)\n</code></pre> <p>Acquires a lock on the passed mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-lock_1","title":"function Lock","text":"<pre><code>inline explicit Lock(\nBasicMCSMutex &amp; mutex,\nstd::defer_lock_t )\n</code></pre> <p>Does not acquire the mutex until this-&gt;lock() is called. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-lock_2","title":"function ~Lock","text":"<pre><code>inline ~Lock()\n</code></pre> <p>Releases the lock held by the current thread. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-lock_3","title":"function Lock","text":"<pre><code>Lock(\nconst Lock &amp; ) =deleted\n</code></pre> <p>MCSMutex::Lock is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-operator","title":"function operator=","text":"<pre><code>Lock &amp; operator=(\nconst Lock &amp; ) =deleted\n</code></pre> <p>MCSMutex::Lock is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-owns_lock","title":"function owns_lock","text":"<pre><code>inline bool owns_lock() const\n</code></pre> <p>Returns true iff this Lock currently owns the mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-lock_4","title":"function lock","text":"<pre><code>inline void lock()\n</code></pre> <p>Lock the mutex. </p> <p>Will panic unless <code>this-&gt;[owns_lock()](/_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-owns-lock)</code> and <code>this-&gt;[needs_reset()](/_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-needs-reset)</code> are both false. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-unlock","title":"function unlock","text":"<pre><code>inline void unlock()\n</code></pre> <p>Unlock the mutex. </p> <p>Will panic if <code>this-&gt;[owns_lock()](/_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-owns-lock)</code> is false. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-needs_reset","title":"function needs_reset","text":"<pre><code>inline bool needs_reset() const\n</code></pre> <p>Returns true if this-&gt;reset() must be called before this-&gt;lock() may be called again. </p> <p>In order to make the normal case as fast as possible, a MCRMutex::Lock must be explicitly reset in between <code>[unlock()](/_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-unlock)</code> and re-<code>[lock()](/_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-lock)</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre> <p>Resets the internal lock state so that this lock can re-acquire the mutex. </p> <p>Will panic unless <code>this-&gt;[needs_reset()](/_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#function-needs-reset)</code> is true. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#variable-kacquirespincyclesinit","title":"variable kAcquireSpinCyclesInit","text":"<pre><code>static constexpr usize kAcquireSpinCyclesInit = 2048;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicMCSMutex_1_1Lock/#variable-kacquirespincyclessteady","title":"variable kAcquireSpinCyclesSteady","text":"<pre><code>static constexpr usize kAcquireSpinCyclesSteady = 8;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/","title":"batt::BasicRateLimiter","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#public-functions","title":"Public Functions","text":"Name BasicRateLimiter(double rate, i64 burst =1) bool poll() i64 available() const double time_remaining_sec() const double elapsed_usec() const double elapsed_sec() const double period_sec() const"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Clock &gt;\nclass batt::BasicRateLimiter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-basicratelimiter","title":"function BasicRateLimiter","text":"<pre><code>inline explicit BasicRateLimiter(\ndouble rate,\ni64 burst =1\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-poll","title":"function poll","text":"<pre><code>inline bool poll()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-available","title":"function available","text":"<pre><code>inline i64 available() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-time_remaining_sec","title":"function time_remaining_sec","text":"<pre><code>inline double time_remaining_sec() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-elapsed_usec","title":"function elapsed_usec","text":"<pre><code>inline double elapsed_usec() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-elapsed_sec","title":"function elapsed_sec","text":"<pre><code>inline double elapsed_sec() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRateLimiter/#function-period_sec","title":"function period_sec","text":"<pre><code>inline double period_sec() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/","title":"batt::BasicReadWriteLock","text":"<p>An MCS-style fair reader/writer lock.  More...</p> <p><code>#include &lt;batteries/async/read_write_lock.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-classes","title":"Public Classes","text":"Name class QueueNode Base class for Reader and Writer scoped lock guards. class Reader class Writer"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-types","title":"Public Types","text":"Name using BasicReadWriteLock Self using Self Lock using DumpReadWriteLockState DumpState"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-functions","title":"Public Functions","text":"Name constexpr u32 make_state(u32 is_blocked, u32 successor_class)Returns a state value representing the combination of the passed bit fields. constexpr bool is_blocked_from_state(u32 state)Returns true iff the blocked bit of state is set. constexpr u32 successor_class_from_state(u32 state)Returns the masked successor class value of <code>state</code>, which can be compared to kSuccessorNone, kSuccessorReader, and kSuccessorWriter. i64 reader_count() constReturns the current number of readers holding this lock."},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-attributes","title":"Public Attributes","text":"Name constexpr u32 kBlockedMask constexpr u32 kBlockedFalse constexpr u32 kBlockedTrue constexpr u32 kSuccessorMask constexpr u32 kSuccessorNone constexpr u32 kSuccessorReader constexpr u32 kSuccessorWriter constexpr u32 kInitialState"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;template&lt; typename &gt; class WatchImplT,\nbool kPollForNext =false&gt;\nclass batt::BasicReadWriteLock;\n</code></pre> <p>An MCS-style fair reader/writer lock. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#using-self","title":"using Self","text":"<pre><code>using batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::Self =  BasicReadWriteLock;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#using-lock","title":"using Lock","text":"<pre><code>using batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::Lock =  Self;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#using-dumpstate","title":"using DumpState","text":"<pre><code>using batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::DumpState =  DumpReadWriteLockState;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#function-make_state","title":"function make_state","text":"<pre><code>static inline constexpr u32 make_state(\nu32 is_blocked,\nu32 successor_class\n)\n</code></pre> <p>Returns a state value representing the combination of the passed bit fields. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#function-is_blocked_from_state","title":"function is_blocked_from_state","text":"<pre><code>static inline constexpr bool is_blocked_from_state(\nu32 state\n)\n</code></pre> <p>Returns true iff the blocked bit of state is set. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#function-successor_class_from_state","title":"function successor_class_from_state","text":"<pre><code>static inline constexpr u32 successor_class_from_state(\nu32 state\n)\n</code></pre> <p>Returns the masked successor class value of <code>state</code>, which can be compared to kSuccessorNone, kSuccessorReader, and kSuccessorWriter. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#function-reader_count","title":"function reader_count","text":"<pre><code>inline i64 reader_count() const\n</code></pre> <p>Returns the current number of readers holding this lock. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-kblockedmask","title":"variable kBlockedMask","text":"<pre><code>static constexpr u32 kBlockedMask = 0b1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-kblockedfalse","title":"variable kBlockedFalse","text":"<pre><code>static constexpr u32 kBlockedFalse = 0b0;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-kblockedtrue","title":"variable kBlockedTrue","text":"<pre><code>static constexpr u32 kBlockedTrue = 0b1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-ksuccessormask","title":"variable kSuccessorMask","text":"<pre><code>static constexpr u32 kSuccessorMask = 0b110;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-ksuccessornone","title":"variable kSuccessorNone","text":"<pre><code>static constexpr u32 kSuccessorNone = 0b000;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-ksuccessorreader","title":"variable kSuccessorReader","text":"<pre><code>static constexpr u32 kSuccessorReader = 0b010;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-ksuccessorwriter","title":"variable kSuccessorWriter","text":"<pre><code>static constexpr u32 kSuccessorWriter = 0b100;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock/#variable-kinitialstate","title":"variable kInitialState","text":"<pre><code>static constexpr u32 kInitialState = Self::make_state(Self::kBlockedTrue, Self::kSuccessorNone);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/","title":"batt::BasicReadWriteLock::QueueNode","text":"<p>Base class for Reader and Writer scoped lock guards.  <code>#include &lt;batteries/async/read_write_lock.hpp&gt;</code></p> <p>Inherited by batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::Reader, batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::Writer</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#public-types","title":"Public Types","text":"Name using ReadWriteLockQueueNodeClass NodeClass"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#public-functions","title":"Public Functions","text":"Name QueueNode(Lock * lock, NodeClass node_class) QueueNode * fast_lock_or_get_predecessor(u32 &amp; observed_state)The initial fast path is the same for both readers and writers: attempt to fetch-and-store the lock-&gt;tail_ pointer to this; if the previous value was nullptr, then <code>this</code> is the current holder of the lock (regardless whether it is a writer or a reader). template &lt;typename Mode &gt; void set_unblocked(u32 &amp; observed_state, Mode mode)Updates this-&gt;state_ (and observed_state), clearing the blocked bit. void await_unblocked(u32 &amp; observed_state)Spins/waits for the blocked bit of this-&gt;state_ to be 0. bool fast_unlock(QueueNode *&amp; observed_next)Attempts a fast release of the lock. void await_next(QueueNode *&amp; observed_next)Waits until this-&gt;next_ is non-null (indicating that the successor of this node is done accessing our state)."},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#public-attributes","title":"Public Attributes","text":"Name Lock *const lock_ NodeClass const class_ CpuCacheLineIsolated&lt; WatchImplT&lt; QueueNode * &gt; &gt; next_ CpuCacheLineIsolated&lt; WatchImplT&lt; u32 &gt; &gt; state_"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#using-nodeclass","title":"using NodeClass","text":"<pre><code>using batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode::NodeClass =  ReadWriteLockQueueNodeClass;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#function-queuenode","title":"function QueueNode","text":"<pre><code>inline explicit QueueNode(\nLock * lock,\nNodeClass node_class\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#function-fast_lock_or_get_predecessor","title":"function fast_lock_or_get_predecessor","text":"<pre><code>inline QueueNode * fast_lock_or_get_predecessor(\nu32 &amp; observed_state\n)\n</code></pre> <p>The initial fast path is the same for both readers and writers: attempt to fetch-and-store the lock-&gt;tail_ pointer to this; if the previous value was nullptr, then <code>this</code> is the current holder of the lock (regardless whether it is a writer or a reader). </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#function-set_unblocked","title":"function set_unblocked","text":"<pre><code>template &lt;typename Mode &gt;\ninline void set_unblocked(\nu32 &amp; observed_state,\nMode mode\n)\n</code></pre> <p>Updates this-&gt;state_ (and observed_state), clearing the blocked bit. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#function-await_unblocked","title":"function await_unblocked","text":"<pre><code>inline void await_unblocked(\nu32 &amp; observed_state\n)\n</code></pre> <p>Spins/waits for the blocked bit of this-&gt;state_ to be 0. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#function-fast_unlock","title":"function fast_unlock","text":"<pre><code>inline bool fast_unlock(\nQueueNode *&amp; observed_next\n)\n</code></pre> <p>Attempts a fast release of the lock. </p> <p>Return: true iff there is no successor of this (implies the fast unlock succeeded). </p> <p>The fast path is the same for both readers and writers; the goal is to either replace <code>lock-&gt;tail</code> as though we were never there (the uncontended case), or to obtain the next pointer so we know the successor of this node. Depending on whether this function is called by a reader or writer, there are slightly different things to do once we know the true value of <code>next</code>.</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#function-await_next","title":"function await_next","text":"<pre><code>inline void await_next(\nQueueNode *&amp; observed_next\n)\n</code></pre> <p>Waits until this-&gt;next_ is non-null (indicating that the successor of this node is done accessing our state). </p> <p>Whether or not we will need to use this-&gt;next_ depends on the state of <code>this</code>, after non-nullptr next is observed. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#variable-lock_","title":"variable lock_","text":"<pre><code>Lock *const lock_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#variable-class_","title":"variable class_","text":"<pre><code>NodeClass const class_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#variable-next_","title":"variable next_","text":"<pre><code>CpuCacheLineIsolated&lt; WatchImplT&lt; QueueNode * &gt; &gt; next_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1QueueNode/#variable-state_","title":"variable state_","text":"<pre><code>CpuCacheLineIsolated&lt; WatchImplT&lt; u32 &gt; &gt; state_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/","title":"batt::BasicReadWriteLock::Reader","text":"<p>Inherits from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/#public-functions","title":"Public Functions","text":"Name Reader(Lock &amp; lock) ~Reader() Lock * lock() constReturns the lock for this Reader."},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p> Name using ReadWriteLockQueueNodeClass NodeClass <p>Public Functions inherited from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p> Name QueueNode(Lock * lock, NodeClass node_class) QueueNode * fast_lock_or_get_predecessor(u32 &amp; observed_state)The initial fast path is the same for both readers and writers: attempt to fetch-and-store the lock-&gt;tail_ pointer to this; if the previous value was nullptr, then <code>this</code> is the current holder of the lock (regardless whether it is a writer or a reader). template &lt;typename Mode &gt; void set_unblocked(u32 &amp; observed_state, Mode mode)Updates this-&gt;state_ (and observed_state), clearing the blocked bit. void await_unblocked(u32 &amp; observed_state)Spins/waits for the blocked bit of this-&gt;state_ to be 0. bool fast_unlock(QueueNode *&amp; observed_next)Attempts a fast release of the lock. void await_next(QueueNode *&amp; observed_next)Waits until this-&gt;next_ is non-null (indicating that the successor of this node is done accessing our state). <p>Public Attributes inherited from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p> Name Lock *const lock_ NodeClass const class_ CpuCacheLineIsolated&lt; WatchImplT&lt; QueueNode * &gt; &gt; next_ CpuCacheLineIsolated&lt; WatchImplT&lt; u32 &gt; &gt; state_"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/#function-reader","title":"function Reader","text":"<pre><code>inline explicit Reader(\nLock &amp; lock\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/#function-reader_1","title":"function ~Reader","text":"<pre><code>inline ~Reader()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Reader/#function-lock","title":"function lock","text":"<pre><code>inline Lock * lock() const\n</code></pre> <p>Returns the lock for this Reader. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/","title":"batt::BasicReadWriteLock::Writer","text":"<p>Inherits from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/#public-functions","title":"Public Functions","text":"Name Writer(Lock &amp; lock) ~Writer() Lock * lock() constReturns the lock for this Reader."},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p> Name using ReadWriteLockQueueNodeClass NodeClass <p>Public Functions inherited from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p> Name QueueNode(Lock * lock, NodeClass node_class) QueueNode * fast_lock_or_get_predecessor(u32 &amp; observed_state)The initial fast path is the same for both readers and writers: attempt to fetch-and-store the lock-&gt;tail_ pointer to this; if the previous value was nullptr, then <code>this</code> is the current holder of the lock (regardless whether it is a writer or a reader). template &lt;typename Mode &gt; void set_unblocked(u32 &amp; observed_state, Mode mode)Updates this-&gt;state_ (and observed_state), clearing the blocked bit. void await_unblocked(u32 &amp; observed_state)Spins/waits for the blocked bit of this-&gt;state_ to be 0. bool fast_unlock(QueueNode *&amp; observed_next)Attempts a fast release of the lock. void await_next(QueueNode *&amp; observed_next)Waits until this-&gt;next_ is non-null (indicating that the successor of this node is done accessing our state). <p>Public Attributes inherited from batt::BasicReadWriteLock&lt; WatchImplT, kPollForNext &gt;::QueueNode</p> Name Lock *const lock_ NodeClass const class_ CpuCacheLineIsolated&lt; WatchImplT&lt; QueueNode * &gt; &gt; next_ CpuCacheLineIsolated&lt; WatchImplT&lt; u32 &gt; &gt; state_"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/#function-writer","title":"function Writer","text":"<pre><code>inline explicit Writer(\nLock &amp; lock\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/#function-writer_1","title":"function ~Writer","text":"<pre><code>inline ~Writer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicReadWriteLock_1_1Writer/#function-lock","title":"function lock","text":"<pre><code>inline Lock * lock() const\n</code></pre> <p>Returns the lock for this Reader. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/","title":"batt::BasicRunningTotal","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#public-classes","title":"Public Classes","text":"Name class Iterator"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#public-types","title":"Public Types","text":"Name using Iterator iterator using Iterator const_iterator using T value_type using boost::iterator_range&lt; Iterator &gt; slice_type"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#public-functions","title":"Public Functions","text":"Name BasicRunningTotal() =default BasicRunningTotal(BasicRunningTotal &amp;&amp; ) =default BasicRunningTotal(PartsCount count, PartSize size) ~BasicRunningTotal() =default BasicRunningTotal &amp; operator=(BasicRunningTotal &amp;&amp; ) =default PartsCount parts_count() const PartSize part_size() const usize size() const bool empty() const const T &amp; front() const T back() const iterator begin() const iterator end() const slice_type slice(usize begin_index, usize end_index) const slice_type slice(Interval&lt; usize &gt; interval) const void reset(PartsCount count, PartSize size) void set_size(usize new_size) Slice&lt; const T &gt; const_part(usize i) const Slice&lt; T &gt; mutable_part(usize i) Slice&lt; const T &gt; const_summary() const Slice&lt; T &gt; mutable_summary() T operator[](isize i) const Slice&lt; const T &gt; raw_values() const std::function&lt; void(std::ostream &amp;)&gt; dump() const void update_summary()"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::BasicRunningTotal;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#using-iterator","title":"using iterator","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::iterator =  Iterator;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#using-const_iterator","title":"using const_iterator","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::const_iterator =  Iterator;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#using-value_type","title":"using value_type","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#using-slice_type","title":"using slice_type","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::slice_type =  boost::iterator_range&lt;Iterator&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-basicrunningtotal","title":"function BasicRunningTotal","text":"<pre><code>BasicRunningTotal() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-basicrunningtotal_1","title":"function BasicRunningTotal","text":"<pre><code>BasicRunningTotal(\nBasicRunningTotal &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-basicrunningtotal_2","title":"function BasicRunningTotal","text":"<pre><code>explicit BasicRunningTotal(\nPartsCount count,\nPartSize size\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-basicrunningtotal_3","title":"function ~BasicRunningTotal","text":"<pre><code>~BasicRunningTotal() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-operator","title":"function operator=","text":"<pre><code>BasicRunningTotal &amp; operator=(\nBasicRunningTotal &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-parts_count","title":"function parts_count","text":"<pre><code>inline PartsCount parts_count() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-part_size","title":"function part_size","text":"<pre><code>inline PartSize part_size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-front","title":"function front","text":"<pre><code>inline const T &amp; front() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-back","title":"function back","text":"<pre><code>inline T back() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-begin","title":"function begin","text":"<pre><code>iterator begin() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-end","title":"function end","text":"<pre><code>iterator end() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-slice","title":"function slice","text":"<pre><code>slice_type slice(\nusize begin_index,\nusize end_index\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-slice_1","title":"function slice","text":"<pre><code>slice_type slice(\nInterval&lt; usize &gt; interval\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-reset","title":"function reset","text":"<pre><code>void reset(\nPartsCount count,\nPartSize size\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-set_size","title":"function set_size","text":"<pre><code>void set_size(\nusize new_size\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-const_part","title":"function const_part","text":"<pre><code>Slice&lt; const T &gt; const_part(\nusize i\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-mutable_part","title":"function mutable_part","text":"<pre><code>Slice&lt; T &gt; mutable_part(\nusize i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-const_summary","title":"function const_summary","text":"<pre><code>Slice&lt; const T &gt; const_summary() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-mutable_summary","title":"function mutable_summary","text":"<pre><code>Slice&lt; T &gt; mutable_summary()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-operator_1","title":"function operator[]","text":"<pre><code>T operator[](\nisize i\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-raw_values","title":"function raw_values","text":"<pre><code>Slice&lt; const T &gt; raw_values() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-dump","title":"function dump","text":"<pre><code>std::function&lt; void(std::ostream &amp;)&gt; dump() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal/#function-update_summary","title":"function update_summary","text":"<pre><code>void update_summary()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/","title":"batt::BasicRunningTotal::Iterator","text":"<p>Inherits from boost::iterator_facade&lt; Iterator, T, std::random_access_iterator_tag, T, isize &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#public-types","title":"Public Types","text":"Name using Iterator Self using std::random_access_iterator_tag iterator_category using usize value_type using value_type reference"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#public-functions","title":"Public Functions","text":"Name Iterator(const BasicRunningTotal&lt; T &gt; * container, usize position) reference dereference() const bool equal(const Self &amp; other) const void increment() void decrement() void advance(isize delta) isize distance_to(const Self &amp; other) const const BasicRunningTotal&lt; T &gt; * container() const isize position() const"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#using-self","title":"using Self","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::Iterator::Self =  Iterator;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#using-iterator_category","title":"using iterator_category","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::Iterator::iterator_category =  std::random_access_iterator_tag;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#using-value_type","title":"using value_type","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::Iterator::value_type =  usize;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#using-reference","title":"using reference","text":"<pre><code>using batt::BasicRunningTotal&lt; T &gt;::Iterator::reference =  value_type;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-iterator","title":"function Iterator","text":"<pre><code>inline explicit Iterator(\nconst BasicRunningTotal&lt; T &gt; * container,\nusize position\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-dereference","title":"function dereference","text":"<pre><code>inline reference dereference() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-equal","title":"function equal","text":"<pre><code>inline bool equal(\nconst Self &amp; other\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-increment","title":"function increment","text":"<pre><code>inline void increment()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-decrement","title":"function decrement","text":"<pre><code>inline void decrement()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-advance","title":"function advance","text":"<pre><code>inline void advance(\nisize delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-distance_to","title":"function distance_to","text":"<pre><code>inline isize distance_to(\nconst Self &amp; other\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-container","title":"function container","text":"<pre><code>inline const BasicRunningTotal&lt; T &gt; * container() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicRunningTotal_1_1Iterator/#function-position","title":"function position","text":"<pre><code>inline isize position() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/","title":"batt::BasicScopedChunk","text":"<p>A fetched chunk of data that is automatically consumed (partially or entirely) when it goes out of scope.  More...</p> <p><code>#include &lt;batteries/async/fetch.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#public-types","title":"Public Types","text":"Name using AsyncFetchStreamT stream_type"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#public-functions","title":"Public Functions","text":"Name BasicScopedChunk() =defaultConstructs an empty BasicScopedChunk. BasicScopedChunk(const BasicScopedChunk &amp; ) =deletedBasicScopedChunks are movable but not copyable. BasicScopedChunk &amp; operator=(const BasicScopedChunk &amp; ) =deletedBasicScopedChunks are movable but not copyable. BasicScopedChunk(BasicScopedChunk &amp;&amp; other)BasicScopedChunks are movable but not copyable. BasicScopedChunk &amp; operator=(BasicScopedChunk &amp;&amp; other)BasicScopedChunks are movable but not copyable. BasicScopedChunk(stream_type * source, const boost::asio::const_buffer &amp; buffer)Constructs a BasicScopedChunk from the passed buffer which was async_fetch-ed from the passed AsyncNoCopyReadStream. BasicScopedChunk(stream_type * source, batt::SmallVec&lt; char, kLocalStorageSize &gt; &amp;&amp; storage)Constructs a BasicScopedChunk from the passed buffer which was async_fetch-ed from the passed AsyncNoCopyReadStream. ~BasicScopedChunk()Destroys this BasicScopedChunk, consuming what is currently in the buffer from the source stream. const void * data() constReturns a pointer to the start of the fetched data. usize size() constReturns the size (in bytes) of the fetched data. const boost::asio::const_buffer &amp; buffer() constReturns the fetched data chunk as a boost::asio::const_buffer. bool empty() constReturns true if this object was default constructed, consume has been called (so that there is no associated stream), or the buffer is currently size 0. void back_up(usize n =std::numeric_limits&lt; usize &gt;::max())Truncates the data chunk by the specified number of bytes, starting at the end. void consume()Consumes the current size of this buffer from the source stream, setting this object to an empty state."},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kLocalStorageSize"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename AsyncFetchStreamT &gt;\nclass batt::BasicScopedChunk;\n</code></pre> <p>A fetched chunk of data that is automatically consumed (partially or entirely) when it goes out of scope. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#using-stream_type","title":"using stream_type","text":"<pre><code>using batt::BasicScopedChunk&lt; AsyncFetchStreamT &gt;::stream_type =  AsyncFetchStreamT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-basicscopedchunk","title":"function BasicScopedChunk","text":"<pre><code>BasicScopedChunk() =default\n</code></pre> <p>Constructs an empty BasicScopedChunk. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-basicscopedchunk_1","title":"function BasicScopedChunk","text":"<pre><code>BasicScopedChunk(\nconst BasicScopedChunk &amp; ) =deleted\n</code></pre> <p>BasicScopedChunks are movable but not copyable. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-operator","title":"function operator=","text":"<pre><code>BasicScopedChunk &amp; operator=(\nconst BasicScopedChunk &amp; ) =deleted\n</code></pre> <p>BasicScopedChunks are movable but not copyable. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-basicscopedchunk_2","title":"function BasicScopedChunk","text":"<pre><code>inline BasicScopedChunk(\nBasicScopedChunk &amp;&amp; other\n)\n</code></pre> <p>BasicScopedChunks are movable but not copyable. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-operator_1","title":"function operator=","text":"<pre><code>inline BasicScopedChunk &amp; operator=(\nBasicScopedChunk &amp;&amp; other\n)\n</code></pre> <p>BasicScopedChunks are movable but not copyable. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-basicscopedchunk_3","title":"function BasicScopedChunk","text":"<pre><code>inline explicit BasicScopedChunk(\nstream_type * source,\nconst boost::asio::const_buffer &amp; buffer\n)\n</code></pre> <p>Constructs a BasicScopedChunk from the passed buffer which was async_fetch-ed from the passed AsyncNoCopyReadStream. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-basicscopedchunk_4","title":"function BasicScopedChunk","text":"<pre><code>inline explicit BasicScopedChunk(\nstream_type * source,\nbatt::SmallVec&lt; char, kLocalStorageSize &gt; &amp;&amp; storage\n)\n</code></pre> <p>Constructs a BasicScopedChunk from the passed buffer which was async_fetch-ed from the passed AsyncNoCopyReadStream. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-basicscopedchunk_5","title":"function ~BasicScopedChunk","text":"<pre><code>inline ~BasicScopedChunk()\n</code></pre> <p>Destroys this BasicScopedChunk, consuming what is currently in the buffer from the source stream. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-data","title":"function data","text":"<pre><code>inline const void * data() const\n</code></pre> <p>Returns a pointer to the start of the fetched data. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre> <p>Returns the size (in bytes) of the fetched data. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-buffer","title":"function buffer","text":"<pre><code>inline const boost::asio::const_buffer &amp; buffer() const\n</code></pre> <p>Returns the fetched data chunk as a boost::asio::const_buffer. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre> <p>Returns true if this object was default constructed, consume has been called (so that there is no associated stream), or the buffer is currently size 0. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-back_up","title":"function back_up","text":"<pre><code>inline void back_up(\nusize n =std::numeric_limits&lt; usize &gt;::max()\n)\n</code></pre> <p>Truncates the data chunk by the specified number of bytes, starting at the end. </p> <p>For example, BasicScopedChunk::back_up(0) will leave this object unchanged, whereas BasicScopedChunk::back_up(this-&gt;size()) will cause the buffer to be re-sized to 0, causing 0 bytes to be consumed when the chunk goes out of scope. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#function-consume","title":"function consume","text":"<pre><code>inline void consume()\n</code></pre> <p>Consumes the current size of this buffer from the source stream, setting this object to an empty state. </p>"},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicScopedChunk/#variable-klocalstoragesize","title":"variable kLocalStorageSize","text":"<pre><code>static constexpr usize kLocalStorageSize = 48;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/","title":"batt::BasicStateMachineEntropySource","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-types","title":"Public Types","text":"Name using Fn PickIntFn"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-functions","title":"Public Functions","text":"Name BasicStateMachineEntropySource() =default BasicStateMachineEntropySource(PickIntFn &amp;&amp; pick_int_fn) usize pick_int(usize min_value, usize max_value) const bool pick_branch() const template &lt;typename T &gt; T pick_one_of(std::initializer_list&lt; T &gt; values) const bool run_one(FakeExecutionContext &amp; context) const template &lt;typename... ActionFn&gt; void do_one_of(ActionFn &amp;&amp;... actions) const"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nclass batt::BasicStateMachineEntropySource;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#using-pickintfn","title":"using PickIntFn","text":"<pre><code>using batt::BasicStateMachineEntropySource&lt; Fn &gt;::PickIntFn =  Fn;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-basicstatemachineentropysource","title":"function BasicStateMachineEntropySource","text":"<pre><code>BasicStateMachineEntropySource() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-basicstatemachineentropysource_1","title":"function BasicStateMachineEntropySource","text":"<pre><code>inline explicit BasicStateMachineEntropySource(\nPickIntFn &amp;&amp; pick_int_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-pick_int","title":"function pick_int","text":"<pre><code>inline usize pick_int(\nusize min_value,\nusize max_value\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-pick_branch","title":"function pick_branch","text":"<pre><code>inline bool pick_branch() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-pick_one_of","title":"function pick_one_of","text":"<pre><code>template &lt;typename T &gt;\ninline T pick_one_of(\nstd::initializer_list&lt; T &gt; values\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-run_one","title":"function run_one","text":"<pre><code>inline bool run_one(\nFakeExecutionContext &amp; context\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BasicStateMachineEntropySource/#function-do_one_of","title":"function do_one_of","text":"<pre><code>template &lt;typename... ActionFn&gt;\ninline void do_one_of(\nActionFn &amp;&amp;... actions\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/","title":"batt::BoxedSeq","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-classes","title":"Public Classes","text":"Name class AbstractSeq class SeqImpl"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-types","title":"Public Types","text":"Name using TypeErasedStorage&lt; AbstractSeq, SeqImpl &gt; storage_type using ItemT Item"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-functions","title":"Public Functions","text":"Name BoxedSeq() =default template &lt;typename T ,typename  =EnableIfNoShadow,typename  =EnableIfSeq,typename  =std::enable_if_t&lt;!std::is_same_v, Status&gt; &amp;&amp;                                          !std::is_same_v, StatusCode&gt;&gt;&gt;  BoxedSeq(T &amp;&amp; seq) template &lt;typename U ,typename  =std::enable_if_t&lt;!std::is_same_v&gt;&gt;  BoxedSeq(const BoxedSeq&lt; U &gt; &amp; other_seq) =deleted template &lt;typename U ,typename  =std::enable_if_t&lt;!std::is_same_v&gt;&gt;  BoxedSeq(BoxedSeq&lt; U &gt; &amp;&amp; other_seq) =deleted BoxedSeq(BoxedSeq &amp;&amp; ) =default BoxedSeq(const BoxedSeq &amp; that) =default BoxedSeq &amp; operator=(BoxedSeq &amp;&amp; ) =default BoxedSeq &amp; operator=(const BoxedSeq &amp; that) =default bool is_valid() const operator bool() const Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename ItemT &gt;\nclass batt::BoxedSeq;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#using-storage_type","title":"using storage_type","text":"<pre><code>using batt::BoxedSeq&lt; ItemT &gt;::storage_type =  TypeErasedStorage&lt;AbstractSeq, SeqImpl&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#using-item","title":"using Item","text":"<pre><code>using batt::BoxedSeq&lt; ItemT &gt;::Item =  ItemT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq","title":"function BoxedSeq","text":"<pre><code>BoxedSeq() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_1","title":"function BoxedSeq","text":"<pre><code>template &lt;typename T ,\ntypename  =EnableIfNoShadow&lt;BoxedSeq, T&amp;&amp;&gt;,\ntypename  =EnableIfSeq&lt;T&gt;,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;T&gt;, Status&gt; &amp;&amp;                                          !std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusCode&gt;&gt;&gt;\ninline explicit BoxedSeq(\nT &amp;&amp; seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_2","title":"function BoxedSeq","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;ItemT, U&gt;&gt;&gt;\nBoxedSeq(\nconst BoxedSeq&lt; U &gt; &amp; other_seq\n) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_3","title":"function BoxedSeq","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;ItemT, U&gt;&gt;&gt;\nBoxedSeq(\nBoxedSeq&lt; U &gt; &amp;&amp; other_seq\n) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_4","title":"function BoxedSeq","text":"<pre><code>BoxedSeq(\nBoxedSeq &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-boxedseq_5","title":"function BoxedSeq","text":"<pre><code>BoxedSeq(\nconst BoxedSeq &amp; that\n) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-operator","title":"function operator=","text":"<pre><code>BoxedSeq &amp; operator=(\nBoxedSeq &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-operator_1","title":"function operator=","text":"<pre><code>BoxedSeq &amp; operator=(\nconst BoxedSeq &amp; that\n) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/","title":"batt::BoxedSeq::AbstractSeq","text":"<p>Inherits from batt::AbstractValue&lt; AbstractSeq &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#public-functions","title":"Public Functions","text":"Name AbstractSeq() =default AbstractSeq(const AbstractSeq &amp; ) =deleted AbstractSeq &amp; operator=(const AbstractSeq &amp; ) =deleted virtual ~AbstractSeq() =default virtual Optional&lt; ItemT &gt; peek() =0 virtual Optional&lt; ItemT &gt; next() =0"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::AbstractValue&lt; AbstractSeq &gt;</p> Name AbstractValue(const AbstractValue &amp; ) =deleted virtual ~AbstractValue() =default virtual T * copy_to(MutableBuffer memory) const =0 virtual T * move_to(MutableBuffer memory) =0 <p>Protected Functions inherited from batt::AbstractValue&lt; AbstractSeq &gt;</p> Name AbstractValue() =default"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-abstractseq","title":"function AbstractSeq","text":"<pre><code>AbstractSeq() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-abstractseq_1","title":"function AbstractSeq","text":"<pre><code>AbstractSeq(\nconst AbstractSeq &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-operator","title":"function operator=","text":"<pre><code>AbstractSeq &amp; operator=(\nconst AbstractSeq &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-abstractseq_2","title":"function ~AbstractSeq","text":"<pre><code>virtual ~AbstractSeq() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-peek","title":"function peek","text":"<pre><code>virtual Optional&lt; ItemT &gt; peek() =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1AbstractSeq/#function-next","title":"function next","text":"<pre><code>virtual Optional&lt; ItemT &gt; next() =0\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/","title":"batt::BoxedSeq::SeqImpl","text":"<p>More...</p> <p>Inherits from batt::AbstractValueImpl&lt; AbstractSeq, SeqImpl, T &gt;, AbstractType</p>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-types","title":"Public Types","text":"Name using AbstractValueImpl&lt; AbstractSeq, SeqImpl, T &gt; Super"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-functions","title":"Public Functions","text":"Name SeqImpl(T &amp;&amp; seq) Optional&lt; ItemT &gt; peek() override Optional&lt; ItemT &gt; next() override"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::AbstractValueImpl&lt; AbstractSeq, SeqImpl, T &gt;</p> Name AbstractValueImpl(T &amp;&amp; obj) AbstractType * copy_to(MutableBuffer memory) const override AbstractType * move_to(MutableBuffer memory) override <p>Protected Attributes inherited from batt::AbstractValueImpl&lt; AbstractSeq, SeqImpl, T &gt;</p> Name T obj_"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::BoxedSeq::SeqImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#using-super","title":"using Super","text":"<pre><code>using batt::BoxedSeq&lt; ItemT &gt;::SeqImpl&lt; T &gt;::Super =  AbstractValueImpl&lt;AbstractSeq, SeqImpl, T&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#function-seqimpl","title":"function SeqImpl","text":"<pre><code>inline explicit SeqImpl(\nT &amp;&amp; seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; ItemT &gt; peek() override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BoxedSeq_1_1SeqImpl/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; ItemT &gt; next() override\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/","title":"batt::BufferSource","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#public-functions","title":"Public Functions","text":"Name BufferSource() =default template &lt;typename T ,typename  =EnableIfNoShadow,typename  =EnableIfBufferSource&gt;,typename  =std::enable_if_t, T&gt;&gt;&gt;  BufferSource(T &amp;&amp; obj) BufferSource(const ConstBuffer &amp; buffer) BufferSource(const void * ptr, usize size) BufferSource(const std::string_view &amp; str) operator bool() const void clear() usize size() const StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(i64 min_count) void consume(i64 count) void close_for_read()"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource","title":"function BufferSource","text":"<pre><code>BufferSource() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource_1","title":"function BufferSource","text":"<pre><code>template &lt;typename T ,\ntypename  =EnableIfNoShadow&lt;BufferSource, T&amp;&amp;&gt;,\ntypename  =EnableIfBufferSource&lt;UnwrapRefType&lt;T&gt;&gt;,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, T&gt;&gt;&gt;\nBufferSource(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource_2","title":"function BufferSource","text":"<pre><code>inline explicit BufferSource(\nconst ConstBuffer &amp; buffer\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource_3","title":"function BufferSource","text":"<pre><code>inline explicit BufferSource(\nconst void * ptr,\nusize size\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-buffersource_4","title":"function BufferSource","text":"<pre><code>inline explicit BufferSource(\nconst std::string_view &amp; str\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-clear","title":"function clear","text":"<pre><code>void clear()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(\ni64 min_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/","title":"batt::BufferSource::BufferSourceImpl","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BufferSource_1_1BufferSourceImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::BufferSource::BufferSourceImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/","title":"batt::BufferViewImpl","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-types","title":"Public Types","text":"Name using BufferViewImpl Self"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-functions","title":"Public Functions","text":"Name BufferViewImpl(SharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer, usize offset =0) BufferViewImpl(SharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer, usize offset, usize length) void * data() const usize size() const Self &amp; operator+=(usize delta) bool append(Self &amp;&amp; next)"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#using-self","title":"using Self","text":"<pre><code>using batt::BufferViewImpl::Self =  BufferViewImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-bufferviewimpl","title":"function BufferViewImpl","text":"<pre><code>inline explicit BufferViewImpl(\nSharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer,\nusize offset =0\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-bufferviewimpl_1","title":"function BufferViewImpl","text":"<pre><code>inline explicit BufferViewImpl(\nSharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer,\nusize offset,\nusize length\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-data","title":"function data","text":"<pre><code>inline void * data() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-operator","title":"function operator+=","text":"<pre><code>inline Self &amp; operator+=(\nusize delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferViewImpl/#function-append","title":"function append","text":"<pre><code>inline bool append(\nSelf &amp;&amp; next\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/","title":"batt::BufferedChannel","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#public-types","title":"Public Types","text":"Name using T value_type"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#public-functions","title":"Public Functions","text":"Name BufferedChannel() =default BufferedChannel(const BufferedChannel &amp; ) =deleted BufferedChannel &amp; operator=(const BufferedChannel &amp; ) =deleted ~BufferedChannel() =default Status get_last_status() const bool is_active() const void await_inactive() template &lt;typename Handler  =void(StatusOr)&gt; void async_read(Handler &amp;&amp; handler) StatusOr&lt; T &amp; &gt; read() void consume() void close_for_read() template &lt;typename... ArgsAndHandler&gt; void async_write(ArgsAndHandler &amp;&amp;... args_and_handler) template &lt;typename... Args&gt; Status write(Args &amp;&amp;... args) void close_for_write()"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::BufferedChannel;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#using-value_type","title":"using value_type","text":"<pre><code>using batt::BufferedChannel&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-bufferedchannel","title":"function BufferedChannel","text":"<pre><code>BufferedChannel() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-bufferedchannel_1","title":"function BufferedChannel","text":"<pre><code>BufferedChannel(\nconst BufferedChannel &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-operator","title":"function operator=","text":"<pre><code>BufferedChannel &amp; operator=(\nconst BufferedChannel &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-bufferedchannel_2","title":"function ~BufferedChannel","text":"<pre><code>~BufferedChannel() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-get_last_status","title":"function get_last_status","text":"<pre><code>inline Status get_last_status() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-is_active","title":"function is_active","text":"<pre><code>inline bool is_active() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-await_inactive","title":"function await_inactive","text":"<pre><code>inline void await_inactive()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-async_read","title":"function async_read","text":"<pre><code>template &lt;typename Handler  =void(StatusOr&lt;T&amp;&gt;)&gt;\ninline void async_read(\nHandler &amp;&amp; handler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-read","title":"function read","text":"<pre><code>inline StatusOr&lt; T &amp; &gt; read()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-consume","title":"function consume","text":"<pre><code>inline void consume()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-async_write","title":"function async_write","text":"<pre><code>template &lt;typename... ArgsAndHandler&gt;\ninline void async_write(\nArgsAndHandler &amp;&amp;... args_and_handler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-write","title":"function write","text":"<pre><code>template &lt;typename... Args&gt;\ninline Status write(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1BufferedChannel/#function-close_for_write","title":"function close_for_write","text":"<pre><code>inline void close_for_write()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/","title":"batt::CancelToken","text":"<p>Enables effective cancellation of arbitrary async operations.  <code>#include &lt;batteries/async/cancel_token.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#public-classes","title":"Public Classes","text":"Name class HandlerImpl class Impl"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#public-functions","title":"Public Functions","text":"Name constexpr bool is_idle_state(u32 value) constexpr bool is_cancelled_state(u32 value) constexpr bool is_completed_state(u32 value) constexpr bool is_resolved_state(u32 value) const CancelToken &amp; none() CancelToken(NoneType ) CancelToken() =default CancelToken(const CancelToken &amp; ) =default CancelToken &amp; operator=(const CancelToken &amp; ) =default CancelToken &amp; operator=(const NoneType &amp; ) template &lt;typename T ,typename Fn &gt; batt::StatusOr&lt; T &gt; await(Fn &amp;&amp; fn) const template &lt;typename Fn &gt; batt::Status await(Fn &amp;&amp; fn) const void cancel() const bool is_valid() const bool is_cancelled() const operator bool() const SmallFn&lt; void(std::ostream &amp;)&gt; debug_info() const"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#public-attributes","title":"Public Attributes","text":"Name constexpr u32 kIdle constexpr u32 kActiveHandler constexpr u32 kResolving constexpr u32 kCompleted constexpr u32 kCancelled"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friends","title":"Friends","text":"Name usize hash_value(const CancelToken &amp; cancel_token) CancelToken is hashed by its impl pointer. bool operator==(const CancelToken &amp; l, const CancelToken &amp; r) Returns true iff the two objects are copies of the same CancelToken. bool operator&lt;(const CancelToken &amp; l, const CancelToken &amp; r) bool operator!=(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&gt;(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&lt;=(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&gt;=(const CancelToken &amp; l, const CancelToken &amp; r)"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-is_idle_state","title":"function is_idle_state","text":"<pre><code>static inline constexpr bool is_idle_state(\nu32 value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-is_cancelled_state","title":"function is_cancelled_state","text":"<pre><code>static inline constexpr bool is_cancelled_state(\nu32 value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-is_completed_state","title":"function is_completed_state","text":"<pre><code>static inline constexpr bool is_completed_state(\nu32 value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-is_resolved_state","title":"function is_resolved_state","text":"<pre><code>static inline constexpr bool is_resolved_state(\nu32 value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-none","title":"function none","text":"<pre><code>static inline const CancelToken &amp; none()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-canceltoken","title":"function CancelToken","text":"<pre><code>inline CancelToken(\nNoneType )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-canceltoken_1","title":"function CancelToken","text":"<pre><code>CancelToken() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-canceltoken_2","title":"function CancelToken","text":"<pre><code>CancelToken(\nconst CancelToken &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-operator","title":"function operator=","text":"<pre><code>CancelToken &amp; operator=(\nconst CancelToken &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-operator_1","title":"function operator=","text":"<pre><code>inline CancelToken &amp; operator=(\nconst NoneType &amp; )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-await","title":"function await","text":"<pre><code>template &lt;typename T ,\ntypename Fn &gt;\nbatt::StatusOr&lt; T &gt; await(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-await_1","title":"function await","text":"<pre><code>template &lt;typename Fn &gt;\ninline batt::Status await(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-cancel","title":"function cancel","text":"<pre><code>inline void cancel() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-is_cancelled","title":"function is_cancelled","text":"<pre><code>inline bool is_cancelled() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#function-debug_info","title":"function debug_info","text":"<pre><code>inline SmallFn&lt; void(std::ostream &amp;)&gt; debug_info() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#variable-kidle","title":"variable kIdle","text":"<pre><code>static constexpr u32 kIdle = 0;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#variable-kactivehandler","title":"variable kActiveHandler","text":"<pre><code>static constexpr u32 kActiveHandler = 1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#variable-kresolving","title":"variable kResolving","text":"<pre><code>static constexpr u32 kResolving = 2;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#variable-kcompleted","title":"variable kCompleted","text":"<pre><code>static constexpr u32 kCompleted = 4;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#variable-kcancelled","title":"variable kCancelled","text":"<pre><code>static constexpr u32 kCancelled = 8;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-hash_value","title":"friend hash_value","text":"<pre><code>friend usize hash_value(\nconst CancelToken &amp; cancel_token\n);\n</code></pre> <p>CancelToken is hashed by its impl pointer. </p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-operator","title":"friend operator==","text":"<pre><code>friend bool operator==(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n);\n</code></pre> <p>Returns true iff the two objects are copies of the same CancelToken. </p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-operator_1","title":"friend operator&lt;","text":"<pre><code>friend bool operator&lt;(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n);\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-operator_2","title":"friend operator!=","text":"<pre><code>friend bool operator!=(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n);\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-operator_3","title":"friend operator&gt;","text":"<pre><code>friend bool operator&gt;(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n);\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-operator_4","title":"friend operator&lt;=","text":"<pre><code>friend bool operator&lt;=(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n);\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken/#friend-operator_5","title":"friend operator&gt;=","text":"<pre><code>friend bool operator&gt;=(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/","title":"batt::CancelToken::HandlerImpl","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#public-functions","title":"Public Functions","text":"Name HandlerImpl(batt::SharedPtr&lt; Impl &gt; &amp;&amp; impl, batt::Optional&lt; T &gt; &amp; result) HandlerImpl(const HandlerImpl &amp; ) =default HandlerImpl &amp; operator=(const HandlerImpl &amp; ) =default template &lt;typename... Args&gt; void operator()(Args &amp;&amp;... args) const bool is_cancelled() const"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::CancelToken::HandlerImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#function-handlerimpl","title":"function HandlerImpl","text":"<pre><code>explicit HandlerImpl(\nbatt::SharedPtr&lt; Impl &gt; &amp;&amp; impl,\nbatt::Optional&lt; T &gt; &amp; result\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#function-handlerimpl_1","title":"function HandlerImpl","text":"<pre><code>HandlerImpl(\nconst HandlerImpl &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#function-operator","title":"function operator=","text":"<pre><code>HandlerImpl &amp; operator=(\nconst HandlerImpl &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#function-operator_1","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\nvoid operator()(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1HandlerImpl/#function-is_cancelled","title":"function is_cancelled","text":"<pre><code>inline bool is_cancelled() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/","title":"batt::CancelToken::Impl","text":"<p>Inherits from batt::RefCounted&lt; Impl &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#public-functions","title":"Public Functions","text":"Name bool is_cancelled() const"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#public-attributes","title":"Public Attributes","text":"Name batt::HandlerMemory&lt; 2 *kCpuCacheLineSize - sizeof(batt::Watch&lt; u32 &gt;)&gt; memory_ batt::Watch&lt; u32 &gt; state_"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#function-is_cancelled","title":"function is_cancelled","text":"<pre><code>inline bool is_cancelled() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#variable-memory_","title":"variable memory_","text":"<pre><code>batt::HandlerMemory&lt; 2 *kCpuCacheLineSize - sizeof(batt::Watch&lt; u32 &gt;)&gt; memory_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CancelToken_1_1Impl/#variable-state_","title":"variable state_","text":"<pre><code>batt::Watch&lt; u32 &gt; state_ {kIdle};\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/","title":"batt::CaseOfVisitor","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-types","title":"Public Types","text":"Name using std::tuple&lt; Cases... &gt; CaseTuple template &lt;typename... Args&gt; using detail::FirstMatchImpl&lt; CaseTuple, std::tuple&lt; Args... &gt; &gt; FirstMatch"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-functions","title":"Public Functions","text":"Name template &lt;typename... CaseArgs&gt;  CaseOfVisitor(CaseArgs &amp;&amp;... case_args) template &lt;typename... Args&gt; decltype(auto) operator()(Args &amp;&amp;... args) template &lt;typename... Args&gt; decltype(auto) operator()(Args &amp;&amp;... args) template &lt;typename... Args&gt; decltype(auto) operator()(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) operator()(Args &amp;&amp;... args) const"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Cases&gt;\nclass batt::CaseOfVisitor;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#using-casetuple","title":"using CaseTuple","text":"<pre><code>using batt::CaseOfVisitor&lt; Cases &gt;::CaseTuple =  std::tuple&lt;Cases...&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#using-firstmatch","title":"using FirstMatch","text":"<pre><code>template &lt;typename... Args&gt;\nusing batt::CaseOfVisitor&lt; Cases &gt;::FirstMatch =  detail::FirstMatchImpl&lt;CaseTuple, std::tuple&lt;Args...&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-caseofvisitor","title":"function CaseOfVisitor","text":"<pre><code>template &lt;typename... CaseArgs&gt;\ninline explicit CaseOfVisitor(\nCaseArgs &amp;&amp;... case_args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) operator()(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator_1","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) operator()(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator_2","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) operator()(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CaseOfVisitor/#function-operator_3","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) operator()(\nArgs &amp;&amp;... args\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/","title":"batt::Channel","text":"<p>A Channel is a one-way, unbuffered, SPSC (single-producer, single consumer) communication/synchronization primitive.  More... <p><code>#include &lt;batteries/async/channel.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#public-functions","title":"Public Functions","text":"Name template &lt;typename Handler ,typename  =std::enable_if_t&gt;&gt; void invoke_write_handler(Handler &amp;&amp; handler, const batt::Status &amp; status, T &amp; value) template &lt;typename Handler ,typename  =std::enable_if_t&lt;!std::is_invocable_v &amp;&amp;                                          std::is_invocable_v&gt;,typename  =void&gt; void invoke_write_handler(Handler &amp;&amp; handler, const batt::Status &amp; status, T &amp; ) Channel()Construct a new Channel object. Channel(const Channel &amp; ) =deletedChannel is not copy-constructible. Channel &amp; operator=(const Channel &amp; ) =deletedChannel is not copy-assignable. ~Channel()Destroy the Channel; calls this-&gt;close_for_write() and waits for any active reader to finish (via Channel::consume). bool is_active() constReturns true iff there is currently an object available on the channel. void await_inactive()Blocks the current Task until the Channel is inactive. template &lt;typename Handler &gt; void async_wait_inactive(Handler &amp;&amp; handler) template &lt;typename Handler  =void(StatusOr)&gt; void async_read(Handler &amp;&amp; handler)Start a new read and invoke the passed handler when the next value is written to the channel. StatusOr&lt; T &amp; &gt; read()Wait for an object to be written to the Channel, then return a reference to that object. void consume()Release the last value read on the Channel. void close_for_read()Unblock all ongoing calls to Channel::write / Channel::async_write and cause all future calls to fail with closed error status. template &lt;typename Handler  =void(Status, T&amp;)&gt; void async_write(T &amp; value, Handler &amp;&amp; handler)Write a value to the Channel. Status write(T &amp; value)Blocking (Task::await) version of Channel::async_write. void close_for_write()Unblock all ongoing calls to read() and cause all future calls to fail with closed error status."},{"location":"_autogen/Classes/classbatt_1_1Channel/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Channel;\n</code></pre> <p>A Channel is a one-way, unbuffered, SPSC (single-producer, single consumer) communication/synchronization primitive."},{"location":"_autogen/Classes/classbatt_1_1Channel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-invoke_write_handler","title":"function invoke_write_handler","text":"<pre><code>template &lt;typename Handler ,\ntypename  =std::enable_if_t&lt;std::is_invocable_v&lt;Handler&amp;&amp;, const Status&amp;, T&amp;&gt;&gt;&gt;\nstatic inline void invoke_write_handler(\nHandler &amp;&amp; handler,\nconst batt::Status &amp; status,\nT &amp; value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-invoke_write_handler_1","title":"function invoke_write_handler","text":"<pre><code>template &lt;typename Handler ,\ntypename  =std::enable_if_t&lt;!std::is_invocable_v&lt;Handler&amp;&amp;, const Status&amp;, T&amp;&gt; &amp;&amp;                                          std::is_invocable_v&lt;Handler&amp;&amp;, const Status&amp;&gt;&gt;,\ntypename  =void&gt;\nstatic inline void invoke_write_handler(\nHandler &amp;&amp; handler,\nconst batt::Status &amp; status,\nT &amp; )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-channel","title":"function Channel","text":"<pre><code>inline Channel()\n</code></pre> <p>Construct a new Channel object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-channel_1","title":"function Channel","text":"<pre><code>Channel(\nconst Channel &amp; ) =deleted\n</code></pre> <p>Channel is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-operator","title":"function operator=","text":"<pre><code>Channel &amp; operator=(\nconst Channel &amp; ) =deleted\n</code></pre> <p>Channel is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-channel_2","title":"function ~Channel","text":"<pre><code>inline ~Channel()\n</code></pre> <p>Destroy the Channel; calls this-&gt;close_for_write() and waits for any active reader to finish (via Channel::consume). </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-is_active","title":"function is_active","text":"<pre><code>inline bool is_active() const\n</code></pre> <p>Returns true iff there is currently an object available on the channel. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-await_inactive","title":"function await_inactive","text":"<pre><code>inline void await_inactive()\n</code></pre> <p>Blocks the current Task until the Channel is inactive. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-async_wait_inactive","title":"function async_wait_inactive","text":"<pre><code>template &lt;typename Handler &gt;\ninline void async_wait_inactive(\nHandler &amp;&amp; handler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-async_read","title":"function async_read","text":"<pre><code>template &lt;typename Handler  =void(StatusOr&lt;T&amp;&gt;)&gt;\nvoid async_read(\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Start a new read and invoke the passed handler when the next value is written to the channel. </p> <p>Will invoke the handler immediately with batt::StatusCode::kClosed if either:</p> <ul> <li>The channel was closed for read prior to calling async_read</li> <li>The channel is closed for write, before or after the call to async_read </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-read","title":"function read","text":"<pre><code>inline StatusOr&lt; T &amp; &gt; read()\n</code></pre> <p>Wait for an object to be written to the Channel, then return a reference to that object. </p> <p>The referred object will stay valid until Channel::consume is called. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-consume","title":"function consume","text":"<pre><code>inline void consume()\n</code></pre> <p>Release the last value read on the Channel. </p> <p>Panic if consume() is called without a prior successful call to read() (indicating that this-&gt;is_active() is true). </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre> <p>Unblock all ongoing calls to Channel::write / Channel::async_write and cause all future calls to fail with closed error status. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-async_write","title":"function async_write","text":"<pre><code>template &lt;typename Handler  =void(Status, T&amp;)&gt;\nvoid async_write(\nT &amp; value,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Write a value to the Channel. </p> <p>Panic if there is currently an ongoing write (single-producer).</p> <p>The passed handler is invoked once the value is consumed via this-&gt;read() / this-&gt;consume(). </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-write","title":"function write","text":"<pre><code>inline Status write(\nT &amp; value\n)\n</code></pre> <p>Blocking (Task::await) version of Channel::async_write. </p> <p>This function will not return until the passed value has been consumed. The value is guaranteed not to be copied; the consumer will see the same exact object passed into write. </p>"},{"location":"_autogen/Classes/classbatt_1_1Channel/#function-close_for_write","title":"function close_for_write","text":"<pre><code>inline void close_for_write()\n</code></pre> <p>Unblock all ongoing calls to read() and cause all future calls to fail with closed error status. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/","title":"batt::ConstBufferView","text":""},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#public-functions","title":"Public Functions","text":"Name ConstBufferView(const ConstBufferView &amp; ) =default ConstBufferView &amp; operator=(const ConstBufferView &amp; ) =default ConstBufferView(SharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer, usize offset =0) ConstBufferView(SharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer, usize offset, usize length) ConstBufferView(const MutableBufferView &amp; other) ConstBufferView(MutableBufferView &amp;&amp; other) ConstBufferView &amp; operator=(const MutableBufferView &amp; other) ConstBufferView &amp; operator=(MutableBufferView &amp;&amp; other) operator ConstBuffer() const ConstBufferView &amp; operator+=(usize delta) const void * data() const usize size() const bool append(ConstBufferView &amp;&amp; next) bool append(MutableBufferView &amp;&amp; next)"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#friends","title":"Friends","text":"Name class MutableBufferView"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview","title":"function ConstBufferView","text":"<pre><code>ConstBufferView(\nconst ConstBufferView &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator","title":"function operator=","text":"<pre><code>ConstBufferView &amp; operator=(\nconst ConstBufferView &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_1","title":"function ConstBufferView","text":"<pre><code>inline explicit ConstBufferView(\nSharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer,\nusize offset =0\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_2","title":"function ConstBufferView","text":"<pre><code>inline explicit ConstBufferView(\nSharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer,\nusize offset,\nusize length\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_3","title":"function ConstBufferView","text":"<pre><code>inline ConstBufferView(\nconst MutableBufferView &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-constbufferview_4","title":"function ConstBufferView","text":"<pre><code>inline ConstBufferView(\nMutableBufferView &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator_1","title":"function operator=","text":"<pre><code>inline ConstBufferView &amp; operator=(\nconst MutableBufferView &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator_2","title":"function operator=","text":"<pre><code>inline ConstBufferView &amp; operator=(\nMutableBufferView &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator-constbuffer","title":"function operator ConstBuffer","text":"<pre><code>inline operator ConstBuffer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-operator_3","title":"function operator+=","text":"<pre><code>inline ConstBufferView &amp; operator+=(\nusize delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-data","title":"function data","text":"<pre><code>inline const void * data() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-append","title":"function append","text":"<pre><code>inline bool append(\nConstBufferView &amp;&amp; next\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#function-append_1","title":"function append","text":"<pre><code>inline bool append(\nMutableBufferView &amp;&amp; next\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1ConstBufferView/#friend-mutablebufferview","title":"friend MutableBufferView","text":"<pre><code>friend class MutableBufferView(\nMutableBufferView );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/","title":"batt::CountMetric","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#public-functions","title":"Public Functions","text":"Name CountMetric() =default CountMetric(T init_val) void set(T value) template &lt;typename D &gt; void add(D delta) template &lt;typename D &gt; decltype(auto) fetch_add(D delta) operator T() const decltype(auto) operator++(int ) decltype(auto) operator++() template &lt;typename D &gt; decltype(auto) operator+=(D delta) T load() const void reset() void clamp_min(T lower_bound)Atomically ensure that value_ is at least lower_bound. void clamp_max(T upper_bound)Atomically ensure that value_ is at most upper_bound."},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::CountMetric;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-countmetric","title":"function CountMetric","text":"<pre><code>CountMetric() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-countmetric_1","title":"function CountMetric","text":"<pre><code>inline CountMetric(\nT init_val\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-set","title":"function set","text":"<pre><code>inline void set(\nT value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-add","title":"function add","text":"<pre><code>template &lt;typename D &gt;\ninline void add(\nD delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-fetch_add","title":"function fetch_add","text":"<pre><code>template &lt;typename D &gt;\ninline decltype(auto) fetch_add(\nD delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator-t","title":"function operator T","text":"<pre><code>inline operator T() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator","title":"function operator++","text":"<pre><code>inline decltype(auto) operator++(\nint )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator_1","title":"function operator++","text":"<pre><code>inline decltype(auto) operator++()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-operator_2","title":"function operator+=","text":"<pre><code>template &lt;typename D &gt;\ninline decltype(auto) operator+=(\nD delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-load","title":"function load","text":"<pre><code>inline T load() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-clamp_min","title":"function clamp_min","text":"<pre><code>inline void clamp_min(\nT lower_bound\n)\n</code></pre> <p>Atomically ensure that value_ is at least lower_bound. </p> <p>Parameters: </p> <ul> <li>Lower bound </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1CountMetric/#function-clamp_max","title":"function clamp_max","text":"<pre><code>inline void clamp_max(\nT upper_bound\n)\n</code></pre> <p>Atomically ensure that value_ is at most upper_bound. </p> <p>Parameters: </p> <ul> <li>Upper bound </li> </ul> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/","title":"batt::CpuCacheLineIsolated","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-types","title":"Public Types","text":"Name using T value_type"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-functions","title":"Public Functions","text":"Name CpuCacheLineIsolated * pointer_from(T * inner_obj) const CpuCacheLineIsolated * pointer_from(const T * inner_obj) CpuCacheLineIsolated() template &lt;typename... Args,typename  =EnableIfNoShadow&gt;  CpuCacheLineIsolated(Args &amp;&amp;... args) CpuCacheLineIsolated(const CpuCacheLineIsolated &amp; that) CpuCacheLineIsolated(CpuCacheLineIsolated &amp;&amp; that) CpuCacheLineIsolated &amp; operator=(const CpuCacheLineIsolated &amp; that) template &lt;typename V ,typename  =std::enable_if_t&lt;!std::is_same_v, CpuCacheLineIsolated&gt;&gt;&gt; CpuCacheLineIsolated &amp; operator=(V &amp;&amp; val) CpuCacheLineIsolated &amp; operator=(CpuCacheLineIsolated &amp;&amp; that) ~CpuCacheLineIsolated() T * get() const T * get() const T &amp; value() const T &amp; value() const T &amp;&amp; value() const T &amp;&amp; value() const =deleted T * operator-&gt;() const T * operator-&gt;() const T &amp; operator*() const T &amp; operator*() const T &amp;&amp; operator*()"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kIsolatedSize"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::CpuCacheLineIsolated;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#using-value_type","title":"using value_type","text":"<pre><code>using batt::CpuCacheLineIsolated&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-pointer_from","title":"function pointer_from","text":"<pre><code>static inline CpuCacheLineIsolated * pointer_from(\nT * inner_obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-pointer_from_1","title":"function pointer_from","text":"<pre><code>static inline const CpuCacheLineIsolated * pointer_from(\nconst T * inner_obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated","title":"function CpuCacheLineIsolated","text":"<pre><code>inline CpuCacheLineIsolated()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_1","title":"function CpuCacheLineIsolated","text":"<pre><code>template &lt;typename... Args,\ntypename  =EnableIfNoShadow&lt;CpuCacheLineIsolated, Args...&gt;&gt;\ninline explicit CpuCacheLineIsolated(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_2","title":"function CpuCacheLineIsolated","text":"<pre><code>inline CpuCacheLineIsolated(\nconst CpuCacheLineIsolated &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_3","title":"function CpuCacheLineIsolated","text":"<pre><code>inline CpuCacheLineIsolated(\nCpuCacheLineIsolated &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator","title":"function operator=","text":"<pre><code>inline CpuCacheLineIsolated &amp; operator=(\nconst CpuCacheLineIsolated &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_1","title":"function operator=","text":"<pre><code>template &lt;typename V ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;V&gt;, CpuCacheLineIsolated&gt;&gt;&gt;\ninline CpuCacheLineIsolated &amp; operator=(\nV &amp;&amp; val\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_2","title":"function operator=","text":"<pre><code>inline CpuCacheLineIsolated &amp; operator=(\nCpuCacheLineIsolated &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-cpucachelineisolated_4","title":"function ~CpuCacheLineIsolated","text":"<pre><code>inline ~CpuCacheLineIsolated()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-get","title":"function get","text":"<pre><code>inline T * get()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-get_1","title":"function get","text":"<pre><code>inline const T * get() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value","title":"function value","text":"<pre><code>inline T &amp; value()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value_1","title":"function value","text":"<pre><code>inline const T &amp; value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value_2","title":"function value","text":"<pre><code>inline T &amp;&amp; value()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-value_3","title":"function value","text":"<pre><code>const T &amp;&amp; value() const =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline const T * operator-&gt;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_3","title":"function operator*","text":"<pre><code>inline T &amp; operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_4","title":"function operator*","text":"<pre><code>inline const T &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#function-operator_5","title":"function operator*","text":"<pre><code>inline T &amp;&amp; operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CpuCacheLineIsolated/#variable-kisolatedsize","title":"variable kIsolatedSize","text":"<pre><code>static constexpr usize kIsolatedSize =\n(sizeof(T) + kCpuCacheLineSize - 1) - ((sizeof(T) + kCpuCacheLineSize - 1) % kCpuCacheLineSize);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/","title":"batt::CustomAllocHandler","text":"<p>Wrapper for an async completion handler type <code>Handler</code>.  More...</p> <p><code>#include &lt;batteries/async/handler.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-types","title":"Public Types","text":"Name using HandlerAllocator&lt; Handler &gt; allocator_type"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-functions","title":"Public Functions","text":"Name template &lt;typename HandlerArg &gt;  CustomAllocHandler(HandlerMemoryBase &amp; m, HandlerArg &amp;&amp; h) allocator_type get_allocator() const template &lt;typename... Args&gt; void operator()(Args &amp;&amp;... args) const Handler &amp; get_handler() const"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Handler &gt;\nclass batt::CustomAllocHandler;\n</code></pre> <p>Wrapper for an async completion handler type <code>Handler</code>. </p> <p>Provides an associated allocator that allocates from a <code>[HandlerMemory](/_autogen/Classes/classbatt_1_1HandlerMemory/)</code> instance. </p>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#using-allocator_type","title":"using allocator_type","text":"<pre><code>using batt::CustomAllocHandler&lt; Handler &gt;::allocator_type =  HandlerAllocator&lt;Handler&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-customallochandler","title":"function CustomAllocHandler","text":"<pre><code>template &lt;typename HandlerArg &gt;\ninline CustomAllocHandler(\nHandlerMemoryBase &amp; m,\nHandlerArg &amp;&amp; h\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-get_allocator","title":"function get_allocator","text":"<pre><code>inline allocator_type get_allocator() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\ninline void operator()(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1CustomAllocHandler/#function-get_handler","title":"function get_handler","text":"<pre><code>inline const Handler &amp; get_handler() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/","title":"batt::DebugInfoFrame","text":""},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#public-functions","title":"Public Functions","text":"Name Slice&lt; DebugInfoFrame * &gt; all_threads() DebugInfoFrame *&amp; top() template &lt;typename Fn &gt;  DebugInfoFrame(Fn &amp;&amp; fn) ~DebugInfoFrame()"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#friends","title":"Friends","text":"Name void print_debug_info(DebugInfoFrame * p, std::ostream &amp; out)"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-all_threads","title":"function all_threads","text":"<pre><code>static inline Slice&lt; DebugInfoFrame * &gt; all_threads()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-top","title":"function top","text":"<pre><code>static inline DebugInfoFrame *&amp; top()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-debuginfoframe","title":"function DebugInfoFrame","text":"<pre><code>template &lt;typename Fn &gt;\nexplicit DebugInfoFrame(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#function-debuginfoframe_1","title":"function ~DebugInfoFrame","text":"<pre><code>inline ~DebugInfoFrame()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1DebugInfoFrame/#friend-print_debug_info","title":"friend print_debug_info","text":"<pre><code>friend void print_debug_info(\nDebugInfoFrame * p,\nstd::ostream &amp; out\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/","title":"batt::DefaultHttpClient","text":"<p>A singleton instance of HttpClient; contains an io_context and thread pool (size == 1).  <code>#include &lt;batteries/http/http_client.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/#public-functions","title":"Public Functions","text":"Name HttpClient &amp; get()Returns a reference to the default HttpClient instance."},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1DefaultHttpClient/#function-get","title":"function get","text":"<pre><code>static inline HttpClient &amp; get()\n</code></pre> <p>Returns a reference to the default HttpClient instance. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/","title":"batt::DerivedMetricExporter","text":"<p>More...</p> <p>Inherits from batt::MetricExporter</p>"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#public-functions","title":"Public Functions","text":"Name DerivedMetricExporter(const std::string &amp; name, DerivedMetric&lt; T &gt; &amp; metric) virtual Token get_name() const override virtual double get_value() const override"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricExporter</p> Name MetricExporter(const MetricExporter &amp; ) =deleted MetricExporter &amp; operator=(const MetricExporter &amp; ) =deleted virtual ~MetricExporter() =default virtual std::string_view get_description() const virtual std::string_view get_type() const virtual const MetricLabelSet &amp; get_labels() const virtual void set_labels(MetricLabelSet &amp;&amp; labels) <p>Protected Functions inherited from batt::MetricExporter</p> Name MetricExporter() =default"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::DerivedMetricExporter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#function-derivedmetricexporter","title":"function DerivedMetricExporter","text":"<pre><code>inline explicit DerivedMetricExporter(\nconst std::string &amp; name,\nDerivedMetric&lt; T &gt; &amp; metric\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#function-get_name","title":"function get_name","text":"<pre><code>inline virtual Token get_name() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_name</p>"},{"location":"_autogen/Classes/classbatt_1_1DerivedMetricExporter/#function-get_value","title":"function get_value","text":"<pre><code>inline virtual double get_value() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_value</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/","title":"batt::ExhaustiveModelChecker","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-types","title":"Public Types","text":"Name using ModelT StateMachineModel using typename StateMachineModel::Branch Branch using typename StateMachineModel::state_type StateT using StateMachineResult Result using StateMachineModelCheckAdvancedOptions AdvancedOptions using typename Branch::delta_type BranchDelta using typename StateMachineModel::VisitResult VisitResult using ::batt::StrongType&lt; bool, ForceSend_TAG &gt; ForceSend"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-functions","title":"Public Functions","text":"Name constexpr bool strong_typedef_default_value(ForceSend_TAG * ) ExhaustiveModelChecker(StateMachineModel &amp; model, detail::ParallelModelCheckState&lt; Branch &gt; &amp; mesh, usize shard_i) ~ExhaustiveModelChecker() Result run() usize pick_int(usize min_value, usize max_value)"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename ModelT &gt;\nclass batt::ExhaustiveModelChecker;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-statemachinemodel","title":"using StateMachineModel","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::StateMachineModel =  ModelT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-branch","title":"using Branch","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::Branch =  typename StateMachineModel::Branch;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-statet","title":"using StateT","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::StateT =  typename StateMachineModel::state_type;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-result","title":"using Result","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::Result =  StateMachineResult;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-advancedoptions","title":"using AdvancedOptions","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::AdvancedOptions =  StateMachineModelCheckAdvancedOptions;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-branchdelta","title":"using BranchDelta","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::BranchDelta =  typename Branch::delta_type;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-visitresult","title":"using VisitResult","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::VisitResult =  typename StateMachineModel::VisitResult;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#using-forcesend","title":"using ForceSend","text":"<pre><code>using batt::ExhaustiveModelChecker&lt; ModelT &gt;::ForceSend =  ::batt::StrongType&lt; bool , ForceSend_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-strong_typedef_default_value","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr bool strong_typedef_default_value(\nForceSend_TAG * )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-exhaustivemodelchecker","title":"function ExhaustiveModelChecker","text":"<pre><code>inline explicit ExhaustiveModelChecker(\nStateMachineModel &amp; model,\ndetail::ParallelModelCheckState&lt; Branch &gt; &amp; mesh,\nusize shard_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-exhaustivemodelchecker_1","title":"function ~ExhaustiveModelChecker","text":"<pre><code>inline ~ExhaustiveModelChecker()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-run","title":"function run","text":"<pre><code>Result run()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ExhaustiveModelChecker/#function-pick_int","title":"function pick_int","text":"<pre><code>inline usize pick_int(\nusize min_value,\nusize max_value\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/","title":"batt::FakeExecutionContext","text":"<p>Inherits from boost::asio::execution_context</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-classes","title":"Public Classes","text":"Name struct AlwaysReturnZero"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-types","title":"Public Types","text":"Name using BasicFakeExecutor&lt; boost::asio::execution::outstanding_work_t::untracked_t &gt; executor_type"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-functions","title":"Public Functions","text":"Name FakeExecutionContext() ~FakeExecutionContext() =default executor_type get_executor() Watch&lt; i64 &gt; &amp; work_count() void push_ready_handler(UniqueHandler&lt;&gt; &amp;&amp; handler) UniqueHandler pop_ready_handler(const std::function&lt; usize(usize)&gt; &amp; picker =AlwaysReturnZero{}) std::allocator&lt; void &gt; get_allocator() const bool poll_one() usize poll() usize run() void reset() usize run_with_random_seed(usize seed)"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#friends","title":"Friends","text":"Name class BasicFakeExecutor"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#using-executor_type","title":"using executor_type","text":"<pre><code>using batt::FakeExecutionContext::executor_type =  BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-fakeexecutioncontext","title":"function FakeExecutionContext","text":"<pre><code>inline FakeExecutionContext()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-fakeexecutioncontext_1","title":"function ~FakeExecutionContext","text":"<pre><code>~FakeExecutionContext() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-get_executor","title":"function get_executor","text":"<pre><code>inline executor_type get_executor()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-work_count","title":"function work_count","text":"<pre><code>inline Watch&lt; i64 &gt; &amp; work_count()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-push_ready_handler","title":"function push_ready_handler","text":"<pre><code>inline void push_ready_handler(\nUniqueHandler&lt;&gt; &amp;&amp; handler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-pop_ready_handler","title":"function pop_ready_handler","text":"<pre><code>inline UniqueHandler pop_ready_handler(\nconst std::function&lt; usize(usize)&gt; &amp; picker =AlwaysReturnZero{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-get_allocator","title":"function get_allocator","text":"<pre><code>inline std::allocator&lt; void &gt; get_allocator() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-poll_one","title":"function poll_one","text":"<pre><code>inline bool poll_one()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-poll","title":"function poll","text":"<pre><code>inline usize poll()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-run","title":"function run","text":"<pre><code>inline usize run()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#function-run_with_random_seed","title":"function run_with_random_seed","text":"<pre><code>inline usize run_with_random_seed(\nusize seed\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeExecutionContext/#friend-basicfakeexecutor","title":"friend BasicFakeExecutor","text":"<pre><code>friend class BasicFakeExecutor(\nBasicFakeExecutor );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/","title":"batt::FakeTaskScheduler","text":"<p>Inherits from batt::TaskScheduler</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#public-classes","title":"Public Classes","text":"Name class ScopeGuard"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#public-functions","title":"Public Functions","text":"Name FakeTaskScheduler() =default FakeExecutionContext &amp; get_context() FakeExecutor get_executor() virtual boost::asio::any_io_executor schedule_task() override virtual void halt() override virtual void join() override"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::TaskScheduler</p> Name TaskScheduler(const TaskScheduler &amp; ) =deleted TaskScheduler &amp; operator=(const TaskScheduler &amp; ) =deleted virtual ~TaskScheduler() =default <p>Protected Functions inherited from batt::TaskScheduler</p> Name TaskScheduler() =default"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-faketaskscheduler","title":"function FakeTaskScheduler","text":"<pre><code>FakeTaskScheduler() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-get_context","title":"function get_context","text":"<pre><code>inline FakeExecutionContext &amp; get_context()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-get_executor","title":"function get_executor","text":"<pre><code>inline FakeExecutor get_executor()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-schedule_task","title":"function schedule_task","text":"<pre><code>inline virtual boost::asio::any_io_executor schedule_task() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::schedule_task</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-halt","title":"function halt","text":"<pre><code>inline virtual void halt() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::halt</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler/#function-join","title":"function join","text":"<pre><code>inline virtual void join() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::join</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/","title":"batt::FakeTaskScheduler::ScopeGuard","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#public-functions","title":"Public Functions","text":"Name ScopeGuard(const ScopeGuard &amp; ) =deleted ScopeGuard &amp; operator=(const ScopeGuard &amp; ) =deleted ScopeGuard(FakeTaskScheduler &amp; scheduler) ~ScopeGuard()"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-scopeguard","title":"function ScopeGuard","text":"<pre><code>ScopeGuard(\nconst ScopeGuard &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-operator","title":"function operator=","text":"<pre><code>ScopeGuard &amp; operator=(\nconst ScopeGuard &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-scopeguard_1","title":"function ScopeGuard","text":"<pre><code>inline explicit ScopeGuard(\nFakeTaskScheduler &amp; scheduler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTaskScheduler_1_1ScopeGuard/#function-scopeguard_2","title":"function ~ScopeGuard","text":"<pre><code>inline ~ScopeGuard()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/","title":"batt::FakeTimeService","text":"<p>Inherits from boost::asio::execution_context::service</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-classes","title":"Public Classes","text":"Name class State struct TimerInstance"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-types","title":"Public Types","text":"Name using FakeTimeService Self using boost::posix_time::ptime TimePoint using boost::posix_time::time_duration Duration using boost::heap::d_ary_heap&lt; TimerInstance, boost::heap::arity&lt; 2 &gt;, boost::heap::compare&lt; std::greater&lt;&gt; &gt;, boost::heap::mutable_&lt; true &gt; &gt; TimerQueue"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-functions","title":"Public Functions","text":"Name State &amp; state() TimePoint now() void advance_time(Duration delta) bool has_scheduled_timers() Optional&lt; TimePoint &gt; next_expiration_time() FakeTimeService(boost::asio::execution_context &amp; context) void shutdown() override template &lt;typename HandlerFn &gt; void async_wait(const boost::asio::any_io_executor &amp; executor, TimePoint expires_at, HandlerFn &amp;&amp; fn)"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-attributes","title":"Public Attributes","text":"Name boost::asio::execution_context::id id"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-self","title":"using Self","text":"<pre><code>using batt::FakeTimeService::Self =  FakeTimeService;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-timepoint","title":"using TimePoint","text":"<pre><code>using batt::FakeTimeService::TimePoint =  boost::posix_time::ptime;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-duration","title":"using Duration","text":"<pre><code>using batt::FakeTimeService::Duration =  boost::posix_time::time_duration;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#using-timerqueue","title":"using TimerQueue","text":"<pre><code>using batt::FakeTimeService::TimerQueue =  boost::heap::d_ary_heap&lt;TimerInstance, boost::heap::arity&lt;2&gt;, boost::heap::compare&lt;std::greater&lt;&gt; &gt;, boost::heap::mutable_&lt;true&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-state","title":"function state","text":"<pre><code>static inline State &amp; state()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-now","title":"function now","text":"<pre><code>static inline TimePoint now()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-advance_time","title":"function advance_time","text":"<pre><code>static inline void advance_time(\nDuration delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-has_scheduled_timers","title":"function has_scheduled_timers","text":"<pre><code>static inline bool has_scheduled_timers()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-next_expiration_time","title":"function next_expiration_time","text":"<pre><code>static inline Optional&lt; TimePoint &gt; next_expiration_time()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-faketimeservice","title":"function FakeTimeService","text":"<pre><code>inline explicit FakeTimeService(\nboost::asio::execution_context &amp; context\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-shutdown","title":"function shutdown","text":"<pre><code>inline void shutdown() override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#function-async_wait","title":"function async_wait","text":"<pre><code>template &lt;typename HandlerFn &gt;\ninline void async_wait(\nconst boost::asio::any_io_executor &amp; executor,\nTimePoint expires_at,\nHandlerFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService/#variable-id","title":"variable id","text":"<pre><code>static boost::asio::execution_context::id id;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/","title":"batt::FakeTimeService::State","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-types","title":"Public Types","text":"Name using std::unique_lock&lt; std::mutex &gt; Lock"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-functions","title":"Public Functions","text":"Name State()Initializes the fake time service state. TimePoint now()Returns the current fake time. template &lt;typename HandlerFn &gt; void schedule_timer(FakeTimeService * service_instance, const boost::asio::any_io_executor &amp; executor, TimePoint expires_at, HandlerFn &amp;&amp; fn)Queue a timer for later invocation, or immediate invocation if \"fake time\" is at or beyond <code>expires_at</code>. void advance_time(Duration delta)Move \"fake time\" ahead by the specified amount. bool has_scheduled_timers()Returns true iff there are active timers in the queue. Optional&lt; TimePoint &gt; next_expiration_time()Returns the earliest expiration time of the currently scheduled (active) timers."},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#using-lock","title":"using Lock","text":"<pre><code>using batt::FakeTimeService::State::Lock =  std::unique_lock&lt;std::mutex&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-state","title":"function State","text":"<pre><code>inline State()\n</code></pre> <p>Initializes the fake time service state. </p> <p>The initial value for <code>now</code> will be set to the current local system time. </p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-now","title":"function now","text":"<pre><code>inline TimePoint now()\n</code></pre> <p>Returns the current fake time. </p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-schedule_timer","title":"function schedule_timer","text":"<pre><code>template &lt;typename HandlerFn &gt;\nvoid schedule_timer(\nFakeTimeService * service_instance,\nconst boost::asio::any_io_executor &amp; executor,\nTimePoint expires_at,\nHandlerFn &amp;&amp; fn\n)\n</code></pre> <p>Queue a timer for later invocation, or immediate invocation if \"fake time\" is at or beyond <code>expires_at</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-advance_time","title":"function advance_time","text":"<pre><code>inline void advance_time(\nDuration delta\n)\n</code></pre> <p>Move \"fake time\" ahead by the specified amount. </p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-has_scheduled_timers","title":"function has_scheduled_timers","text":"<pre><code>inline bool has_scheduled_timers()\n</code></pre> <p>Returns true iff there are active timers in the queue. </p>"},{"location":"_autogen/Classes/classbatt_1_1FakeTimeService_1_1State/#function-next_expiration_time","title":"function next_expiration_time","text":"<pre><code>inline Optional&lt; TimePoint &gt; next_expiration_time()\n</code></pre> <p>Returns the earliest expiration time of the currently scheduled (active) timers. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FilterBufferSource/","title":"batt::FilterBufferSource","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1FilterBufferSource/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Src ,\ntypename MapFn &gt;\nclass batt::FilterBufferSource;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/","title":"batt::FinalAct","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#public-functions","title":"Public Functions","text":"Name FinalAct(const FinalAct &amp; ) =deleted FinalAct &amp; operator=(const FinalAct &amp; ) =deleted FinalAct(FinalAct &amp;&amp; that) template &lt;typename FnArg ,typename  =EnableIfNoShadow&gt;  FinalAct(FnArg &amp;&amp; arg) ~FinalAct() void cancel()"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nclass batt::FinalAct;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact","title":"function FinalAct","text":"<pre><code>FinalAct(\nconst FinalAct &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-operator","title":"function operator=","text":"<pre><code>FinalAct &amp; operator=(\nconst FinalAct &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact_1","title":"function FinalAct","text":"<pre><code>inline FinalAct(\nFinalAct &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact_2","title":"function FinalAct","text":"<pre><code>template &lt;typename FnArg ,\ntypename  =EnableIfNoShadow&lt;FinalAct, FnArg&amp;&amp;&gt;&gt;\ninline explicit FinalAct(\nFnArg &amp;&amp; arg\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-finalact_3","title":"function ~FinalAct","text":"<pre><code>inline ~FinalAct()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1FinalAct/#function-cancel","title":"function cancel","text":"<pre><code>inline void cancel()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Future/","title":"batt::Future","text":"<p>A value of type T that will be provided at some point in the future.  More...</p> <p><code>#include &lt;batteries/async/future_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args&gt; Future from_value(Args &amp;&amp;... args)Constructs a ready Future by constructing a T from the passed args. Future from_error(const Status &amp; status)Constructs a ready Future with the passed error Status. template &lt;typename Handler &gt; void async_wait(Handler &amp;&amp; handler) constRegisters the passed handler to be invoked once the Future is resolved (via Promise::set_value). bool is_ready() constTests whether the Future value is ready to be read. StatusOr&lt; T &gt; await() constAwaits resolution of the future. template &lt;typename Fn ,typename U  =RemoveStatusOr&gt;&gt; Future&lt; U &gt; and_then(Fn &amp;&amp; fn)Returns a Future for the return value of the passed fn, applied to the result of the current future when it completes."},{"location":"_autogen/Classes/classbatt_1_1Future/#friends","title":"Friends","text":"Name Future&lt; U &gt; get_future(const Promise&lt; U &gt; &amp; promise)"},{"location":"_autogen/Classes/classbatt_1_1Future/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Future;\n</code></pre> <p>A value of type T that will be provided at some point in the future. </p> <p>See: batt::Promise</p> <p>To block on a Future being ready, use Task::await.</p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Future/#function-from_value","title":"function from_value","text":"<pre><code>template &lt;typename... Args&gt;\nstatic inline Future from_value(\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Constructs a ready Future by constructing a T from the passed args. </p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-from_error","title":"function from_error","text":"<pre><code>static inline Future from_error(\nconst Status &amp; status\n)\n</code></pre> <p>Constructs a ready Future with the passed error Status. </p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-async_wait","title":"function async_wait","text":"<pre><code>template &lt;typename Handler &gt;\nvoid async_wait(\nHandler &amp;&amp; handler\n) const\n</code></pre> <p>Registers the passed handler to be invoked once the Future is resolved (via Promise::set_value). </p> <p>Parameters: </p> <ul> <li>handler Invoked with the future value; must have signature <code>void(</code>StatusOr<code>&lt;T&gt;)</code></li> </ul> <p>If the Future is already in a ready state, then the handler will be executed immediately.</p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-is_ready","title":"function is_ready","text":"<pre><code>bool is_ready() const\n</code></pre> <p>Tests whether the Future value is ready to be read. </p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-await","title":"function await","text":"<pre><code>StatusOr&lt; T &gt; await() const\n</code></pre> <p>Awaits resolution of the future. </p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#function-and_then","title":"function and_then","text":"<pre><code>template &lt;typename Fn ,\ntypename U  =RemoveStatusOr&lt;std::invoke_result_t&lt;Fn, T&amp;&gt;&gt;&gt;\ninline Future&lt; U &gt; and_then(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Returns a Future for the return value of the passed fn, applied to the result of the current future when it completes. </p>"},{"location":"_autogen/Classes/classbatt_1_1Future/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1Future/#friend-get_future","title":"friend get_future","text":"<pre><code>friend Future&lt; U &gt; get_future(\nconst Promise&lt; U &gt; &amp; promise\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/","title":"batt::GaugeMetric","text":"<p>A Metric collector that stores and reports a single instantaneous value.  More...</p> <p><code>#include &lt;batteries/metrics/metric_collectors.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/#public-functions","title":"Public Functions","text":"Name GaugeMetric() =defaultInitializes an empty metric. template &lt;typename D &gt; void set(D sample)Sets the stored value to a given sample. T load() const"},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::GaugeMetric;\n</code></pre> <p>A Metric collector that stores and reports a single instantaneous value. </p>"},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/#function-gaugemetric","title":"function GaugeMetric","text":"<pre><code>GaugeMetric() =default\n</code></pre> <p>Initializes an empty metric. </p>"},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/#function-set","title":"function set","text":"<pre><code>template &lt;typename D &gt;\ninline void set(\nD sample\n)\n</code></pre> <p>Sets the stored value to a given sample. </p> <p>Parameters: </p> <ul> <li>sample value. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1GaugeMetric/#function-load","title":"function load","text":"<pre><code>inline T load() const\n</code></pre> <p>Return: The gauge value. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/","title":"batt::HandlerAllocator","text":"<p>An allocator associated with a completion handler.  More...</p> <p><code>#include &lt;batteries/async/handler.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-types","title":"Public Types","text":"Name using T value_type"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-functions","title":"Public Functions","text":"Name HandlerAllocator(HandlerMemoryBase &amp; mem) template &lt;typename U &gt;  HandlerAllocator(const HandlerAllocator&lt; U &gt; &amp; that) T * allocate(usize n) const void deallocate(T * p, usize ) const"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#friends","title":"Friends","text":"Name class HandlerAllocator"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::HandlerAllocator;\n</code></pre> <p>An allocator associated with a completion handler. </p> <p>Designed to satisfy the C++11 minimal allocator requirements. </p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#using-value_type","title":"using value_type","text":"<pre><code>using batt::HandlerAllocator&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-handlerallocator","title":"function HandlerAllocator","text":"<pre><code>inline explicit HandlerAllocator(\nHandlerMemoryBase &amp; mem\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-handlerallocator_1","title":"function HandlerAllocator","text":"<pre><code>template &lt;typename U &gt;\ninline HandlerAllocator(\nconst HandlerAllocator&lt; U &gt; &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-allocate","title":"function allocate","text":"<pre><code>inline T * allocate(\nusize n\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#function-deallocate","title":"function deallocate","text":"<pre><code>inline void deallocate(\nT * p,\nusize ) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerAllocator/#friend-handlerallocator","title":"friend HandlerAllocator","text":"<pre><code>friend class HandlerAllocator(\nHandlerAllocator );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/","title":"batt::HandlerBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-types","title":"Public Types","text":"Name using boost::asio::associated_allocator_t&lt; InnerFn &gt; allocator_type"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-functions","title":"Public Functions","text":"Name template &lt;typename InnerFnArg ,typename OuterFnArg &gt;  HandlerBinder(InnerFnArg &amp;&amp; inner, OuterFnArg &amp;&amp; outer) allocator_type get_allocator() const template &lt;typename... Args,typename  =std::enable_if_t{}&gt;&gt; void operator()(Args &amp;&amp;... args)"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-attributes","title":"Public Attributes","text":"Name InnerFn inner_fn_ OuterFn outer_fn_"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename InnerFn ,\ntypename OuterFn &gt;\nclass batt::HandlerBinder;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#using-allocator_type","title":"using allocator_type","text":"<pre><code>using batt::HandlerBinder&lt; InnerFn, OuterFn &gt;::allocator_type =  boost::asio::associated_allocator_t&lt;InnerFn&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#function-handlerbinder","title":"function HandlerBinder","text":"<pre><code>template &lt;typename InnerFnArg ,\ntypename OuterFnArg &gt;\ninline explicit HandlerBinder(\nInnerFnArg &amp;&amp; inner,\nOuterFnArg &amp;&amp; outer\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#function-get_allocator","title":"function get_allocator","text":"<pre><code>inline allocator_type get_allocator() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename... Args,\ntypename  =std::enable_if_t&lt;batt::IsCallable&lt;OuterFn&amp;&amp;, InnerFn&amp;&amp;, Args&amp;&amp;...&gt;{}&gt;&gt;\ninline void operator()(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#variable-inner_fn_","title":"variable inner_fn_","text":"<pre><code>InnerFn inner_fn_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerBinder/#variable-outer_fn_","title":"variable outer_fn_","text":"<pre><code>OuterFn outer_fn_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/","title":"batt::HandlerMemory","text":"<p>A chunk of memory that can be attached to an async completion handler.  More...</p> <p><code>#include &lt;batteries/async/handler.hpp&gt;</code></p> <p>Inherits from batt::HandlerMemoryBase</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#public-functions","title":"Public Functions","text":"Name HandlerMemory() HandlerMemory(const HandlerMemory &amp; ) =deleted HandlerMemory &amp; operator=(const HandlerMemory &amp; ) =deleted"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::HandlerMemoryBase</p> Name HandlerMemoryBase(const MutableBuffer &amp; buffer) HandlerMemoryBase(void * ptr, usize size) HandlerMemoryBase(const HandlerMemoryBase &amp; ) =deleted virtual ~HandlerMemoryBase() =default void * allocate(usize size) void deallocate(void * pointer) bool in_use() const"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;usize kSize&gt;\nclass batt::HandlerMemory;\n</code></pre> <p>A chunk of memory that can be attached to an async completion handler. </p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-handlermemory","title":"function HandlerMemory","text":"<pre><code>inline HandlerMemory()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-handlermemory_1","title":"function HandlerMemory","text":"<pre><code>HandlerMemory(\nconst HandlerMemory &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemory/#function-operator","title":"function operator=","text":"<pre><code>HandlerMemory &amp; operator=(\nconst HandlerMemory &amp; ) =deleted\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/","title":"batt::HandlerMemoryBase","text":"<p>Abstract base for HandlerMemory.  More... <p><code>#include &lt;batteries/async/handler.hpp&gt;</code></p> <p>Inherited by batt::HandlerMemory&lt; 2 *kCpuCacheLineSize - sizeof(batt::Watch&lt; u32 &gt;)&gt;, batt::HandlerMemory&lt; kHandlerMemoryBytes &gt;, batt::HandlerMemory&lt; kStackBufferSize &gt;, batt::HandlerMemory&lt; kSize &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#public-functions","title":"Public Functions","text":"Name HandlerMemoryBase(const MutableBuffer &amp; buffer) HandlerMemoryBase(void * ptr, usize size) HandlerMemoryBase(const HandlerMemoryBase &amp; ) =deleted HandlerMemoryBase &amp; operator=(const HandlerMemoryBase &amp; ) =deleted virtual ~HandlerMemoryBase() =default void * allocate(usize size) void deallocate(void * pointer) bool in_use() const"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::HandlerMemoryBase;\n</code></pre> <p>Abstract base for HandlerMemory.  <p>Decouples users of HandlerMemory from knowledge of the static memory size. </p>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase","title":"function HandlerMemoryBase","text":"<pre><code>inline explicit HandlerMemoryBase(\nconst MutableBuffer &amp; buffer\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase_1","title":"function HandlerMemoryBase","text":"<pre><code>inline explicit HandlerMemoryBase(\nvoid * ptr,\nusize size\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase_2","title":"function HandlerMemoryBase","text":"<pre><code>HandlerMemoryBase(\nconst HandlerMemoryBase &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-operator","title":"function operator=","text":"<pre><code>HandlerMemoryBase &amp; operator=(\nconst HandlerMemoryBase &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-handlermemorybase_3","title":"function ~HandlerMemoryBase","text":"<pre><code>virtual ~HandlerMemoryBase() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-allocate","title":"function allocate","text":"<pre><code>inline void * allocate(\nusize size\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-deallocate","title":"function deallocate","text":"<pre><code>inline void deallocate(\nvoid * pointer\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HandlerMemoryBase/#function-in_use","title":"function in_use","text":"<pre><code>inline bool in_use() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/","title":"batt::HistogramMetric","text":"<p>Collect histogram values for multiple samples.  More...</p> <p><code>#include &lt;batteries/metrics/metric_collectors.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#public-classes","title":"Public Classes","text":"Name struct Bucket Represents a single histogram bucket for reporting."},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#public-functions","title":"Public Functions","text":"Name HistogramMetric() =default HistogramMetric(const HistogramMetric &amp; ) =deleted HistogramMetric &amp; operator=(const HistogramMetric &amp; ) =deleted HistogramMetric(const batt::int_types::usize intervals, const T min_val, const T max_val)Initializes an empty histogram with fixed number of buckets. Exits if initialization failed. bool initialize(const batt::int_types::usize intervals, const T min_val, const T max_val)Initializes an empty histogram with fixed number of buckets. Should be called in a single threaded context. void reset()Resets metric to empty pre-initialized state. Should be called in a single threaded context. void clear()Clears metric to empty post-initialized state. Should be called in a single threaded context. batt::int_types::usize bucket_index(T sample) constFinds index of correponding bucket for a given input sample. Thread-safe read-only access to scalar data members. void update(T sample)Updates the histogram with a given sample. std::vector&lt; HistogramMetric&lt; T &gt;::Bucket &gt; get() constGets a snapshot of histogram buckets current value."},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#public-attributes","title":"Public Attributes","text":"Name constexpr batt::int_types::i64 kMaxNumberOfIntervals The maximum number of intervals allowed in histogram initialization."},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#friends","title":"Friends","text":"Name class MetricRegistry"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::HistogramMetric;\n</code></pre> <p>Collect histogram values for multiple samples. </p> <p>Histogram initialization: provide data-range (min, max] and the number of buckets. Histogram calculation: update per observed sample, uses constant memory.</p> <p>Buckets are evenly spaced, except when the required range/number of buckets ratio would result with a remainder. Each bucket interval is: (lower-bound, upper-bound] with 2 excess buckets to account for out-of-range samples, (which exceed expected maximum or subceed expected minimum values). </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-histogrammetric","title":"function HistogramMetric","text":"<pre><code>HistogramMetric() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-histogrammetric_1","title":"function HistogramMetric","text":"<pre><code>HistogramMetric(\nconst HistogramMetric &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-operator","title":"function operator=","text":"<pre><code>HistogramMetric &amp; operator=(\nconst HistogramMetric &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-histogrammetric_2","title":"function HistogramMetric","text":"<pre><code>inline HistogramMetric(\nconst batt::int_types::usize intervals,\nconst T min_val,\nconst T max_val\n)\n</code></pre> <p>Initializes an empty histogram with fixed number of buckets. Exits if initialization failed. </p> <p>Parameters: </p> <ul> <li>intervals The fixed number of buckets. </li> <li>min_val The expected minimum value. </li> <li>max_val The expected maximum value. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-initialize","title":"function initialize","text":"<pre><code>inline bool initialize(\nconst batt::int_types::usize intervals,\nconst T min_val,\nconst T max_val\n)\n</code></pre> <p>Initializes an empty histogram with fixed number of buckets. Should be called in a single threaded context. </p> <p>Parameters: </p> <ul> <li>intervals The fixed number of buckets. </li> <li>min_val The expected minimum value. </li> <li>max_val The expected maximum value. </li> </ul> <p>Return: True if succeeded. </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre> <p>Resets metric to empty pre-initialized state. Should be called in a single threaded context. </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre> <p>Clears metric to empty post-initialized state. Should be called in a single threaded context. </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-bucket_index","title":"function bucket_index","text":"<pre><code>inline batt::int_types::usize bucket_index(\nT sample\n) const\n</code></pre> <p>Finds index of correponding bucket for a given input sample. Thread-safe read-only access to scalar data members. </p> <p>Parameters: </p> <ul> <li>sample value. </li> </ul> <p>Return: The corresponding bucket: buckets_ index. </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-update","title":"function update","text":"<pre><code>inline void update(\nT sample\n)\n</code></pre> <p>Updates the histogram with a given sample. </p> <p>Parameters: </p> <ul> <li>sample value. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#function-get","title":"function get","text":"<pre><code>inline std::vector&lt; HistogramMetric&lt; T &gt;::Bucket &gt; get() const\n</code></pre> <p>Gets a snapshot of histogram buckets current value. </p> <p>Return: The buckets vector - each bucket element contains: upper-limit, count and total corresponding values. Empty vector if histogram was not initialized. </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#variable-kmaxnumberofintervals","title":"variable kMaxNumberOfIntervals","text":"<pre><code>static constexpr batt::int_types::i64 kMaxNumberOfIntervals =  1 + 16 +  1;\n</code></pre> <p>The maximum number of intervals allowed in histogram initialization. </p>"},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1HistogramMetric/#friend-metricregistry","title":"friend MetricRegistry","text":"<pre><code>friend class MetricRegistry(\nMetricRegistry );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/","title":"batt::HttpChunkDecoder","text":"<p>BufferSource transformer that decodes HTTP chunked content fetched from <code>Src</code>.  More...</p> <p><code>#include &lt;batteries/http/http_chunk_decoder.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#public-functions","title":"Public Functions","text":"Name HttpChunkDecoder(Src &amp;&amp; src, IncludeHttpTrailer consume_trailer =IncludeHttpTrailer{false}) usize size() const bool done() const StatusOr&lt; SmallVec&lt; ConstBuffer, kBufferVecPreAlloc &gt; &gt; fetch_at_least(const i64 min_count_i) void consume(i64 count) void close_for_read()"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kBufferVecPreAlloc"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Src &gt;\nclass batt::HttpChunkDecoder;\n</code></pre> <p>BufferSource transformer that decodes HTTP chunked content fetched from <code>Src</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-httpchunkdecoder","title":"function HttpChunkDecoder","text":"<pre><code>inline explicit HttpChunkDecoder(\nSrc &amp;&amp; src,\nIncludeHttpTrailer consume_trailer =IncludeHttpTrailer{false}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-done","title":"function done","text":"<pre><code>inline bool done() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, kBufferVecPreAlloc &gt; &gt; fetch_at_least(\nconst i64 min_count_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpChunkDecoder/#variable-kbuffervecprealloc","title":"variable kBufferVecPreAlloc","text":"<pre><code>static constexpr usize kBufferVecPreAlloc = 2;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/","title":"batt::HttpClient","text":"<p>An HTTP/1.1 client implementation.  <code>#include &lt;batteries/http/http_client.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-types","title":"Public Types","text":"Name using ::batt::StrongType&lt; bool, CreateIfNotFound_TAG &gt; CreateIfNotFound"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-functions","title":"Public Functions","text":"Name constexpr bool strong_typedef_default_value(CreateIfNotFound_TAG * ) HttpClient(boost::asio::io_context &amp; io)Constructs an HttpClient that uses the specified io_context to schedule I/O and completions. boost::asio::io_context &amp; get_io_context() constReturns the io_context passed in at construction time. std::function&lt; void(Optional&lt; boost::asio::ssl::context &gt; &amp;, const HostAddress &amp;)&gt; get_ssl_init_fn() constReturns a copy of the current SSL context initialization function. void set_ssl_init_fn(std::function&lt; void(Optional&lt; boost::asio::ssl::context &gt; &amp;, const HostAddress &amp;)&gt; &amp;&amp; fn)Sets a custom initialization function for SSL contexts. Status submit_request(const HostAddress &amp; host_address, Pin&lt; HttpRequest &gt; &amp;&amp; request, Pin&lt; HttpResponse &gt; &amp;&amp; response)Submits an HttpRequest for asynchronous processing. usize get_default_max_connections_per_host() constReturns the default maximum TCP connection count per remote endpoint. void set_default_max_connections_per_host(usize max_connections)Sets the new default maximum connection count per remote host/port. void set_max_connections_per_host(const HostAddress &amp; host_address, usize max_connections)Sets the new maximum connection count for a specific host/port endpoint. i32 get_default_connection_timeout_ms() constReturns the default connection idle timeout, in milliseconds. void set_default_connection_timeout_ms(i32 timeout_ms)Sets the default connection idle timeout, in milliseconds. usize count_active_connections() constReturns the total number of active connections for this client. usize count_active_connections_for_host(const HostAddress &amp; host_address)Returns the total number of active connections in this client for the given host."},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-attributes","title":"Public Attributes","text":"Name constexpr boost::asio::ssl::context::method kDefaultSslMethod The default security method for a secure (https) connection."},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#using-createifnotfound","title":"using CreateIfNotFound","text":"<pre><code>using batt::HttpClient::CreateIfNotFound =  ::batt::StrongType&lt; bool , CreateIfNotFound_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-strong_typedef_default_value","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr bool strong_typedef_default_value(\nCreateIfNotFound_TAG * )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-httpclient","title":"function HttpClient","text":"<pre><code>inline explicit HttpClient(\nboost::asio::io_context &amp; io\n)\n</code></pre> <p>Constructs an HttpClient that uses the specified io_context to schedule I/O and completions. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-get_io_context","title":"function get_io_context","text":"<pre><code>inline boost::asio::io_context &amp; get_io_context() const\n</code></pre> <p>Returns the io_context passed in at construction time. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-get_ssl_init_fn","title":"function get_ssl_init_fn","text":"<pre><code>inline std::function&lt; void(Optional&lt; boost::asio::ssl::context &gt; &amp;, const HostAddress &amp;)&gt; get_ssl_init_fn() const\n</code></pre> <p>Returns a copy of the current SSL context initialization function. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-set_ssl_init_fn","title":"function set_ssl_init_fn","text":"<pre><code>inline void set_ssl_init_fn(\nstd::function&lt; void(Optional&lt; boost::asio::ssl::context &gt; &amp;, const HostAddress &amp;)&gt; &amp;&amp; fn\n)\n</code></pre> <p>Sets a custom initialization function for SSL contexts. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-submit_request","title":"function submit_request","text":"<pre><code>inline Status submit_request(\nconst HostAddress &amp; host_address,\nPin&lt; HttpRequest &gt; &amp;&amp; request,\nPin&lt; HttpResponse &gt; &amp;&amp; response\n)\n</code></pre> <p>Submits an HttpRequest for asynchronous processing. </p> <p>This function returns as soon as the request/response pair has been queued for processing by the HttpClientHostContext associated with the passed host_address. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-get_default_max_connections_per_host","title":"function get_default_max_connections_per_host","text":"<pre><code>inline usize get_default_max_connections_per_host() const\n</code></pre> <p>Returns the default maximum TCP connection count per remote endpoint. </p> <p>This can be changed via set_default_max_connections_per_host (for all hosts) or set_max_connections_per_host (for a specific host). </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-set_default_max_connections_per_host","title":"function set_default_max_connections_per_host","text":"<pre><code>inline void set_default_max_connections_per_host(\nusize max_connections\n)\n</code></pre> <p>Sets the new default maximum connection count per remote host/port. </p> <p>This setting only affects HttpClientHostContext objects created after the default is changed. To change this setting for an existing per-host pool of connections, use set_max_connections_per_host. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-set_max_connections_per_host","title":"function set_max_connections_per_host","text":"<pre><code>inline void set_max_connections_per_host(\nconst HostAddress &amp; host_address,\nusize max_connections\n)\n</code></pre> <p>Sets the new maximum connection count for a specific host/port endpoint. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-get_default_connection_timeout_ms","title":"function get_default_connection_timeout_ms","text":"<pre><code>inline i32 get_default_connection_timeout_ms() const\n</code></pre> <p>Returns the default connection idle timeout, in milliseconds. </p> <p>Pooled connections that have not seen activity for more than this amount of time will be automatically closed. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-set_default_connection_timeout_ms","title":"function set_default_connection_timeout_ms","text":"<pre><code>inline void set_default_connection_timeout_ms(\ni32 timeout_ms\n)\n</code></pre> <p>Sets the default connection idle timeout, in milliseconds. </p> <p>Pooled connections that have not seen activity for more than this amount of time will be automatically closed. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-count_active_connections","title":"function count_active_connections","text":"<pre><code>inline usize count_active_connections() const\n</code></pre> <p>Returns the total number of active connections for this client. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#function-count_active_connections_for_host","title":"function count_active_connections_for_host","text":"<pre><code>inline usize count_active_connections_for_host(\nconst HostAddress &amp; host_address\n)\n</code></pre> <p>Returns the total number of active connections in this client for the given host. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpClient/#variable-kdefaultsslmethod","title":"variable kDefaultSslMethod","text":"<pre><code>static constexpr boost::asio::ssl::context::method kDefaultSslMethod = boost::asio::ssl::context::tlsv12;\n</code></pre> <p>The default security method for a secure (https) connection. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/","title":"batt::HttpClientHostContext","text":"<p>Inherits from batt::RefCounted&lt; HttpClientHostContext &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-functions","title":"Public Functions","text":"Name HttpClientHostContext(HttpClient &amp; client, const HostAddress &amp; host_address) boost::asio::io_context &amp; get_io_context() std::function&lt; void(Optional&lt; boost::asio::ssl::context &gt; &amp;, const HostAddress &amp;)&gt; get_ssl_init_fn() const HttpClient &amp; client() const void set_max_connections(usize n) void set_connection_timeout_ms(i32 timeout_ms) i32 get_connection_timeout_ms() const usize count_active_connections() const Status submit_request(Pin&lt; HttpRequest &gt; &amp;&amp; request, Pin&lt; HttpResponse &gt; &amp;&amp; response) void halt() void join() bool can_grow() const const HostAddress &amp; host_address() const StatusOr&lt; std::tuple&lt; Pin&lt; HttpRequest &gt;, Pin&lt; HttpResponse &gt; &gt; &gt; await_next_request()"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kDefaultMaxConnections constexpr usize kDefaultIdleConnectionTimeoutMs"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-httpclienthostcontext","title":"function HttpClientHostContext","text":"<pre><code>inline explicit HttpClientHostContext(\nHttpClient &amp; client,\nconst HostAddress &amp; host_address\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-get_io_context","title":"function get_io_context","text":"<pre><code>inline boost::asio::io_context &amp; get_io_context()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-get_ssl_init_fn","title":"function get_ssl_init_fn","text":"<pre><code>std::function&lt; void(Optional&lt; boost::asio::ssl::context &gt; &amp;, const HostAddress &amp;)&gt; get_ssl_init_fn() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-client","title":"function client","text":"<pre><code>HttpClient &amp; client() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-set_max_connections","title":"function set_max_connections","text":"<pre><code>inline void set_max_connections(\nusize n\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-set_connection_timeout_ms","title":"function set_connection_timeout_ms","text":"<pre><code>inline void set_connection_timeout_ms(\ni32 timeout_ms\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-get_connection_timeout_ms","title":"function get_connection_timeout_ms","text":"<pre><code>inline i32 get_connection_timeout_ms() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-count_active_connections","title":"function count_active_connections","text":"<pre><code>inline usize count_active_connections() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-submit_request","title":"function submit_request","text":"<pre><code>inline Status submit_request(\nPin&lt; HttpRequest &gt; &amp;&amp; request,\nPin&lt; HttpResponse &gt; &amp;&amp; response\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-can_grow","title":"function can_grow","text":"<pre><code>inline bool can_grow() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-host_address","title":"function host_address","text":"<pre><code>inline const HostAddress &amp; host_address() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#function-await_next_request","title":"function await_next_request","text":"<pre><code>inline StatusOr&lt; std::tuple&lt; Pin&lt; HttpRequest &gt;, Pin&lt; HttpResponse &gt; &gt; &gt; await_next_request()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#variable-kdefaultmaxconnections","title":"variable kDefaultMaxConnections","text":"<pre><code>static constexpr usize kDefaultMaxConnections = 2;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpClientHostContext/#variable-kdefaultidleconnectiontimeoutms","title":"variable kDefaultIdleConnectionTimeoutMs","text":"<pre><code>static constexpr usize kDefaultIdleConnectionTimeoutMs = 60 * 1000;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/","title":"batt::HttpMessageBase","text":"<p>The common base type for HttpRequest and HttpResponse.  More...</p> <p><code>#include &lt;batteries/http/http_message_base.hpp&gt;</code></p> <p>Inherits from batt::Pinnable</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-types","title":"Public Types","text":"Name enum State { kCreated = 0, kInitialized = 1, kConsumed = 2} using T Message"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-functions","title":"Public Functions","text":"Name HttpMessageBase(const HttpMessageBase &amp; ) =deleted HttpMessageBase &amp; operator=(const HttpMessageBase &amp; ) =deleted HttpMessageBase() ~HttpMessageBase() Watch&lt; i32 &gt; &amp; state() void update_status(Status status) Status get_status() const void close(Status status =StatusCode::kClosed) void async_set_message(Message &amp; message) Status await_set_message(Message &amp; message) StatusOr&lt; Message &amp; &gt; await_message() Message &amp; await_message_or_panic() void release_message() void async_set_data(HttpData &amp; data) Status await_set_data(HttpData &amp; data) template &lt;typename WriterFn &gt; Status invoke_stream_writer(usize buffer_size, WriterFn &amp;&amp; writer_fn) template &lt;typename WriterFn &gt; Status invoke_stream_writer(WriterFn &amp;&amp; writer_fn) StatusOr&lt; HttpData &amp; &gt; await_data() void release_data() i32 major_version() i32 minor_version() const SmallVecBase&lt; HttpHeader &gt; &amp; headers() Optional&lt; std::string_view &gt; find_header(const std::string_view &amp; name) template &lt;typename AsyncWriteStream &gt; Status serialize(AsyncWriteStream &amp; stream)Writes this message to the passed stream."},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#protected-attributes","title":"Protected Attributes","text":"Name Status status_ Watch&lt; i32 &gt; state_ Channel&lt; Message &gt; message_ Channel&lt; HttpData &gt; data_"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::Pinnable</p> Name Pinnable() =default Pinnable(const Pinnable &amp; ) =deleted ~Pinnable() void pin() void unpin()"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::HttpMessageBase;\n</code></pre> <p>The common base type for HttpRequest and HttpResponse. </p> <p>The lifecycle of all HTTP message objects is tracked through the state property (see HttpMessageBase::state):</p> <ul> <li><code>[HttpMessageBase](/_autogen/Classes/classbatt_1_1HttpMessageBase/)&lt;T&gt;::kCreated</code><ul> <li>The starting state for all message objects</li> </ul> </li> <li><code>[HttpMessageBase](/_autogen/Classes/classbatt_1_1HttpMessageBase/)&lt;T&gt;::kInitialized</code><ul> <li>The message has been fully initialized and is ready to be read/serialized</li> </ul> </li> <li><code>[HttpMessageBase](/_autogen/Classes/classbatt_1_1HttpMessageBase/)&lt;T&gt;::kConsumed</code><ul> <li>The reader (consumer) of the message is done and the object may safely be disposed of </li> </ul> </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#enum-state","title":"enum State","text":"Enumerator Value Description kCreated 0 kInitialized 1 kConsumed 2"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#using-message","title":"using Message","text":"<pre><code>using batt::HttpMessageBase&lt; T &gt;::Message =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-httpmessagebase","title":"function HttpMessageBase","text":"<pre><code>HttpMessageBase(\nconst HttpMessageBase &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-operator","title":"function operator=","text":"<pre><code>HttpMessageBase &amp; operator=(\nconst HttpMessageBase &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-httpmessagebase_1","title":"function HttpMessageBase","text":"<pre><code>inline HttpMessageBase()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-httpmessagebase_2","title":"function ~HttpMessageBase","text":"<pre><code>inline ~HttpMessageBase()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-state","title":"function state","text":"<pre><code>inline Watch&lt; i32 &gt; &amp; state()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-update_status","title":"function update_status","text":"<pre><code>inline void update_status(\nStatus status\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-get_status","title":"function get_status","text":"<pre><code>inline Status get_status() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-close","title":"function close","text":"<pre><code>inline void close(\nStatus status =StatusCode::kClosed\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-async_set_message","title":"function async_set_message","text":"<pre><code>inline void async_set_message(\nMessage &amp; message\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_set_message","title":"function await_set_message","text":"<pre><code>inline Status await_set_message(\nMessage &amp; message\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_message","title":"function await_message","text":"<pre><code>inline StatusOr&lt; Message &amp; &gt; await_message()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_message_or_panic","title":"function await_message_or_panic","text":"<pre><code>inline Message &amp; await_message_or_panic()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-release_message","title":"function release_message","text":"<pre><code>inline void release_message()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-async_set_data","title":"function async_set_data","text":"<pre><code>inline void async_set_data(\nHttpData &amp; data\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_set_data","title":"function await_set_data","text":"<pre><code>inline Status await_set_data(\nHttpData &amp; data\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-invoke_stream_writer","title":"function invoke_stream_writer","text":"<pre><code>template &lt;typename WriterFn &gt;\ninline Status invoke_stream_writer(\nusize buffer_size,\nWriterFn &amp;&amp; writer_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-invoke_stream_writer_1","title":"function invoke_stream_writer","text":"<pre><code>template &lt;typename WriterFn &gt;\ninline Status invoke_stream_writer(\nWriterFn &amp;&amp; writer_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-await_data","title":"function await_data","text":"<pre><code>inline StatusOr&lt; HttpData &amp; &gt; await_data()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-release_data","title":"function release_data","text":"<pre><code>inline void release_data()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-major_version","title":"function major_version","text":"<pre><code>inline i32 major_version()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-minor_version","title":"function minor_version","text":"<pre><code>inline i32 minor_version()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-headers","title":"function headers","text":"<pre><code>inline const SmallVecBase&lt; HttpHeader &gt; &amp; headers()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-find_header","title":"function find_header","text":"<pre><code>inline Optional&lt; std::string_view &gt; find_header(\nconst std::string_view &amp; name\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#function-serialize","title":"function serialize","text":"<pre><code>template &lt;typename AsyncWriteStream &gt;\ninline Status serialize(\nAsyncWriteStream &amp; stream\n)\n</code></pre> <p>Writes this message to the passed stream. </p> <p>This function uses batt::Task::await to block the caller until the message has been fully written to the stream. Once it returns, it is safe to unpin/delete <code>this</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-status_","title":"variable status_","text":"<pre><code>Status status_ {OkStatus()};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-state_","title":"variable state_","text":"<pre><code>Watch&lt; i32 &gt; state_ {kCreated};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-message_","title":"variable message_","text":"<pre><code>Channel&lt; Message &gt; message_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpMessageBase/#variable-data_","title":"variable data_","text":"<pre><code>Channel&lt; HttpData &gt; data_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/","title":"batt::HttpRequest","text":"<p>Inherits from batt::HttpMessageBase&lt; pico_http::Request &gt;, batt::Pinnable</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#public-functions","title":"Public Functions","text":"Name const std::string_view &amp; method() const std::string_view &amp; path()"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::HttpMessageBase&lt; pico_http::Request &gt;</p> Name enum State { kCreated, kInitialized, kConsumed} using T Message <p>Public Functions inherited from batt::HttpMessageBase&lt; pico_http::Request &gt;</p> Name HttpMessageBase(const HttpMessageBase &amp; ) =deleted HttpMessageBase &amp; operator=(const HttpMessageBase &amp; ) =deleted HttpMessageBase() ~HttpMessageBase() Watch&lt; i32 &gt; &amp; state() void update_status(Status status) Status get_status() const void close(Status status =StatusCode::kClosed) void async_set_message(Message &amp; message) Status await_set_message(Message &amp; message) StatusOr&lt; Message &amp; &gt; await_message() Message &amp; await_message_or_panic() void release_message() void async_set_data(HttpData &amp; data) Status await_set_data(HttpData &amp; data) template &lt;typename WriterFn &gt; Status invoke_stream_writer(usize buffer_size, WriterFn &amp;&amp; writer_fn) template &lt;typename WriterFn &gt; Status invoke_stream_writer(WriterFn &amp;&amp; writer_fn) StatusOr&lt; HttpData &amp; &gt; await_data() void release_data() i32 major_version() i32 minor_version() const SmallVecBase&lt; HttpHeader &gt; &amp; headers() Optional&lt; std::string_view &gt; find_header(const std::string_view &amp; name) template &lt;typename AsyncWriteStream &gt; Status serialize(AsyncWriteStream &amp; stream)Writes this message to the passed stream. <p>Protected Attributes inherited from batt::HttpMessageBase&lt; pico_http::Request &gt;</p> Name Status status_ Watch&lt; i32 &gt; state_ Channel&lt; Message &gt; message_ Channel&lt; HttpData &gt; data_ <p>Public Functions inherited from batt::Pinnable</p> Name Pinnable() =default Pinnable(const Pinnable &amp; ) =deleted Pinnable &amp; operator=(const Pinnable &amp; ) =deleted ~Pinnable() void pin() void unpin()"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#function-method","title":"function method","text":"<pre><code>inline const std::string_view &amp; method()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpRequest/#function-path","title":"function path","text":"<pre><code>inline const std::string_view &amp; path()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/","title":"batt::HttpResponse","text":"<p>Inherits from batt::HttpMessageBase&lt; pico_http::Response &gt;, batt::Pinnable</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#public-functions","title":"Public Functions","text":"Name i32 code() std::string_view message_text()"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::HttpMessageBase&lt; pico_http::Response &gt;</p> Name enum State { kCreated, kInitialized, kConsumed} using T Message <p>Public Functions inherited from batt::HttpMessageBase&lt; pico_http::Response &gt;</p> Name HttpMessageBase(const HttpMessageBase &amp; ) =deleted HttpMessageBase &amp; operator=(const HttpMessageBase &amp; ) =deleted HttpMessageBase() ~HttpMessageBase() Watch&lt; i32 &gt; &amp; state() void update_status(Status status) Status get_status() const void close(Status status =StatusCode::kClosed) void async_set_message(Message &amp; message) Status await_set_message(Message &amp; message) StatusOr&lt; Message &amp; &gt; await_message() Message &amp; await_message_or_panic() void release_message() void async_set_data(HttpData &amp; data) Status await_set_data(HttpData &amp; data) template &lt;typename WriterFn &gt; Status invoke_stream_writer(usize buffer_size, WriterFn &amp;&amp; writer_fn) template &lt;typename WriterFn &gt; Status invoke_stream_writer(WriterFn &amp;&amp; writer_fn) StatusOr&lt; HttpData &amp; &gt; await_data() void release_data() i32 major_version() i32 minor_version() const SmallVecBase&lt; HttpHeader &gt; &amp; headers() Optional&lt; std::string_view &gt; find_header(const std::string_view &amp; name) template &lt;typename AsyncWriteStream &gt; Status serialize(AsyncWriteStream &amp; stream)Writes this message to the passed stream. <p>Protected Attributes inherited from batt::HttpMessageBase&lt; pico_http::Response &gt;</p> Name Status status_ Watch&lt; i32 &gt; state_ Channel&lt; Message &gt; message_ Channel&lt; HttpData &gt; data_ <p>Public Functions inherited from batt::Pinnable</p> Name Pinnable() =default Pinnable(const Pinnable &amp; ) =deleted Pinnable &amp; operator=(const Pinnable &amp; ) =deleted ~Pinnable() void pin() void unpin()"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#function-code","title":"function code","text":"<pre><code>inline i32 code()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpResponse/#function-message_text","title":"function message_text","text":"<pre><code>inline std::string_view message_text()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/","title":"batt::HttpServer","text":"<p>An HTTP server.  More...</p> <p><code>#include &lt;batteries/http/http_server_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#public-functions","title":"Public Functions","text":"Name HttpServer(boost::asio::io_context &amp; io, HostAddress &amp;&amp; host_address, HttpRequestDispatcherFactoryFn &amp;&amp; dispatcher_factory, const Optional&lt; HttpServerSettings &gt; &amp; settings =None) ~HttpServer() boost::asio::io_context &amp; get_io_context() const void halt() void join() Status get_final_status() const"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::HttpServer;\n</code></pre> <p>An HTTP server. </p> <p>Currently only supports non-encrypted TCP/IP transport. </p>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-httpserver","title":"function HttpServer","text":"<pre><code>inline explicit HttpServer(\nboost::asio::io_context &amp; io,\nHostAddress &amp;&amp; host_address,\nHttpRequestDispatcherFactoryFn &amp;&amp; dispatcher_factory,\nconst Optional&lt; HttpServerSettings &gt; &amp; settings =None\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-httpserver_1","title":"function ~HttpServer","text":"<pre><code>inline ~HttpServer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-get_io_context","title":"function get_io_context","text":"<pre><code>inline boost::asio::io_context &amp; get_io_context() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1HttpServer/#function-get_final_status","title":"function get_final_status","text":"<pre><code>Status get_final_status() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1HttpServerConnection/","title":"batt::HttpServerConnection","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpServerConnection/#public-functions","title":"Public Functions","text":"Name void spawn(boost::asio::ip::tcp::socket &amp;&amp; socket, HttpRequestDispatcherFactoryFn &amp;&amp; request_dispatcher_factory, const HttpServerSettings &amp; settings)Used to start an HttpServerConnection processing Task."},{"location":"_autogen/Classes/classbatt_1_1HttpServerConnection/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1HttpServerConnection/#function-spawn","title":"function spawn","text":"<pre><code>static inline void spawn(\nboost::asio::ip::tcp::socket &amp;&amp; socket,\nHttpRequestDispatcherFactoryFn &amp;&amp; request_dispatcher_factory,\nconst HttpServerSettings &amp; settings\n)\n</code></pre> <p>Used to start an HttpServerConnection processing Task. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/","title":"batt::IOResult","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-types","title":"Public Types","text":"Name using std::tuple_element_t&lt; 0, std::conditional_t&lt;(sizeof...(Ts)==1), std::tuple&lt; Ts... &gt;, std::tuple&lt; std::tuple&lt; Ts... &gt; &gt;&gt; &gt; value_type"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args,typename  =std::enable_if_t&gt;&gt;  IOResult(const ErrorCode &amp; ec, Args &amp;&amp;... args) bool ok() const const ErrorCode &amp; error() const value_type &amp; operator*() const value_type &amp; operator*() const value_type &amp; value() const value_type &amp; value() const value_type * operator-&gt;() const value_type * operator-&gt;() const"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Ts&gt;\nclass batt::IOResult;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1IOResult/#using-value_type","title":"using value_type","text":"<pre><code>using batt::IOResult&lt; Ts &gt;::value_type =  std::tuple_element_t&lt; 0, std::conditional_t&lt;(sizeof...(Ts) == 1), std::tuple&lt;Ts...&gt;, std::tuple&lt;std::tuple&lt;Ts...&gt; &gt;&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-ioresult","title":"function IOResult","text":"<pre><code>template &lt;typename... Args,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;value_type, Args&amp;&amp;...&gt;&gt;&gt;\ninline explicit IOResult(\nconst ErrorCode &amp; ec,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-ok","title":"function ok","text":"<pre><code>inline bool ok() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-error","title":"function error","text":"<pre><code>inline const ErrorCode &amp; error() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator","title":"function operator*","text":"<pre><code>inline value_type &amp; operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator_1","title":"function operator*","text":"<pre><code>inline const value_type &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-value","title":"function value","text":"<pre><code>inline value_type &amp; value()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-value_1","title":"function value","text":"<pre><code>inline const value_type &amp; value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline value_type * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1IOResult/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline const value_type * operator-&gt;() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/","title":"batt::InlineSubTask","text":"<p>A scoped asynchronous task with inline stack memory.  More...</p> <p><code>#include &lt;batteries/async/inline_sub_task.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#public-functions","title":"Public Functions","text":"Name template &lt;typename BodyFn ,typename... TaskArgs&gt;  InlineSubTask(const boost::asio::any_io_executor &amp; ex, BodyFn &amp;&amp; body_fn, TaskArgs &amp;&amp;... task_args)Creates a new InlineSubTask. InlineSubTask(const InlineSubTask &amp; ) =deleted InlineSubTask &amp; operator=(const InlineSubTask &amp; ) =deleted ~InlineSubTask()Automatically joins to the sub-task, blocking until it has completed. template &lt;typename F  =void()&gt; void call_when_done(F &amp;&amp; handler)Adds a completion handler to the task; the task must be created with batt::Task::DeferStart{true}, and must not have been started yet. void start()Starts the sub-task if batt::Task::DeferStart{true} was passed in at construction time; otherwise does nothing. bool is_started() constReturnes true if the task has been started. void join()Blocks the caller until the sub-task has completed."},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kTaskStackOverhead"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;usize kStackBufferSize&gt;\nclass batt::InlineSubTask;\n</code></pre> <p>A scoped asynchronous task with inline stack memory. </p> <p>This class does not allocate any dynamic memory for the sub-task. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-inlinesubtask","title":"function InlineSubTask","text":"<pre><code>template &lt;typename BodyFn ,\ntypename... TaskArgs&gt;\ninline explicit InlineSubTask(\nconst boost::asio::any_io_executor &amp; ex,\nBodyFn &amp;&amp; body_fn,\nTaskArgs &amp;&amp;... task_args\n)\n</code></pre> <p>Creates a new InlineSubTask. </p> <p>The arguments passed to this constructor are the same as those that would be passed directly to batt::Task::Task. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-inlinesubtask_1","title":"function InlineSubTask","text":"<pre><code>InlineSubTask(\nconst InlineSubTask &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-operator","title":"function operator=","text":"<pre><code>InlineSubTask &amp; operator=(\nconst InlineSubTask &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-inlinesubtask_2","title":"function ~InlineSubTask","text":"<pre><code>inline ~InlineSubTask()\n</code></pre> <p>Automatically joins to the sub-task, blocking until it has completed. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-call_when_done","title":"function call_when_done","text":"<pre><code>template &lt;typename F  =void()&gt;\ninline void call_when_done(\nF &amp;&amp; handler\n)\n</code></pre> <p>Adds a completion handler to the task; the task must be created with batt::Task::DeferStart{true}, and must not have been started yet. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre> <p>Starts the sub-task if batt::Task::DeferStart{true} was passed in at construction time; otherwise does nothing. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-is_started","title":"function is_started","text":"<pre><code>inline bool is_started() const\n</code></pre> <p>Returnes true if the task has been started. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre> <p>Blocks the caller until the sub-task has completed. </p>"},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1InlineSubTask/#variable-ktaskstackoverhead","title":"variable kTaskStackOverhead","text":"<pre><code>static constexpr usize kTaskStackOverhead = 4 * kKiB;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/","title":"batt::InstanceCounter","text":"<p>A quick and easy way to track the number of instances of a given type in existence; just add batt::InstanceCounter as a field or base class of T.  More... <p><code>#include &lt;batteries/instance_counter.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#public-types","title":"Public Types","text":"Name using InstanceCounter Self"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#public-functions","title":"Public Functions","text":"Name isize get() InstanceCounter() ~InstanceCounter()"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::InstanceCounter;\n</code></pre> <p>A quick and easy way to track the number of instances of a given type in existence; just add batt::InstanceCounter as a field or base class of T."},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#using-self","title":"using Self","text":"<pre><code>using batt::InstanceCounter&lt; T &gt;::Self =  InstanceCounter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#function-get","title":"function get","text":"<pre><code>static inline isize get()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#function-instancecounter","title":"function InstanceCounter","text":"<pre><code>inline InstanceCounter()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1InstanceCounter/#function-instancecounter_1","title":"function ~InstanceCounter","text":"<pre><code>inline ~InstanceCounter()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/","title":"batt::Latch","text":"<p>A write-once, single-value synchronized container.  More...</p> <p><code>#include &lt;batteries/async/latch_decl.hpp&gt;</code></p> <p>Inherits from batt::RefCounted&lt; Latch&lt; T &gt; &gt;</p> <p>Inherited by batt::detail::FutureImpl&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-classes","title":"Public Classes","text":"Name class AsyncGetHandler"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-types","title":"Public Types","text":"Name enum u32 State { kInitial = 0, kSetting = 1, kReady = 3}The possible states for the Latch."},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-functions","title":"Public Functions","text":"Name Latch() =defaultDefault-constructs an empty Latch. Latch(const Latch &amp; ) =deletedLatch is not copy/move-constructible. Latch &amp; operator=(const Latch &amp; ) =deletedLatch is not copy/move-assignable. bool set_error(const batt::Status &amp; status)Sets the Latch to an error status value. template &lt;typename... Args&gt; bool set_value(Args &amp;&amp;... args)Sets the value, closing the latch. bool is_ready() constReturns true iff the latch is in the ready state. StatusOr&lt; T &gt; await()Block the current task until the Latch is ready, then return the set value (or Status). StatusOr&lt; T &gt; await()Block the current task until the Latch is ready, then return the set value (or Status) via move. StatusOr&lt; T &gt; poll()Same as await(), except this method never blocks; if the Latch isn't ready yet, it immediately returns <code>StatusCode::kUnavailable</code>. StatusOr&lt; T &gt; get_ready_value_or_panic()Returns the value of the Latch (non-blocking), panicking if it is not in the ready state. StatusOr&lt; T &gt; get_ready_value_or_panic()Returns the value of the Latch (non-blocking) via move, panicking if it is not in the ready state. template &lt;typename Handler &gt; void async_get(Handler &amp;&amp; handler)Invokes <code>handler</code> when the Latch value is set (i.e., when it enters the ready state); invokes handler immediately if the Latch is ready when this method is called. void invalidate()Force the latch into an invalid state (for testing mostly)."},{"location":"_autogen/Classes/classbatt_1_1Latch/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Latch;\n</code></pre> <p>A write-once, single-value synchronized container. </p> <p>Similar to a Future / Promise pair, but Latch has no defined copy/move semantics. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Latch/#enum-state","title":"enum State","text":"Enumerator Value Description kInitial 0 kSetting 1 kReady 3 <p>The possible states for the Latch. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-latch","title":"function Latch","text":"<pre><code>Latch() =default\n</code></pre> <p>Default-constructs an empty Latch. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-latch_1","title":"function Latch","text":"<pre><code>Latch(\nconst Latch &amp; ) =deleted\n</code></pre> <p>Latch is not copy/move-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-operator","title":"function operator=","text":"<pre><code>Latch &amp; operator=(\nconst Latch &amp; ) =deleted\n</code></pre> <p>Latch is not copy/move-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-set_error","title":"function set_error","text":"<pre><code>bool set_error(\nconst batt::Status &amp; status\n)\n</code></pre> <p>Sets the Latch to an error status value. </p> <p>status.ok() must be false, or else this function will panic. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-set_value","title":"function set_value","text":"<pre><code>template &lt;typename... Args&gt;\nbool set_value(\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Sets the value, closing the latch. </p> <p>Return: true if the Latch was not previously set and this call succeeded in setting its value, or false if the value was previously/concurrently set by another thread. </p> <p><code>args</code> are used to construct a StatusOr, so you can pass an instance of <code>T</code> to set_value, or a Status to indicate an error occurred."},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-is_ready","title":"function is_ready","text":"<pre><code>bool is_ready() const\n</code></pre> <p>Returns true iff the latch is in the ready state. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-await","title":"function await","text":"<pre><code>StatusOr&lt; T &gt; await()\n</code></pre> <p>Block the current task until the Latch is ready, then return the set value (or Status). </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-await_1","title":"function await","text":"<pre><code>StatusOr&lt; T &gt; await()\n</code></pre> <p>Block the current task until the Latch is ready, then return the set value (or Status) via move. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-poll","title":"function poll","text":"<pre><code>StatusOr&lt; T &gt; poll()\n</code></pre> <p>Same as await(), except this method never blocks; if the Latch isn't ready yet, it immediately returns <code>StatusCode::kUnavailable</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-get_ready_value_or_panic","title":"function get_ready_value_or_panic","text":"<pre><code>StatusOr&lt; T &gt; get_ready_value_or_panic()\n</code></pre> <p>Returns the value of the Latch (non-blocking), panicking if it is not in the ready state. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-get_ready_value_or_panic_1","title":"function get_ready_value_or_panic","text":"<pre><code>StatusOr&lt; T &gt; get_ready_value_or_panic()\n</code></pre> <p>Returns the value of the Latch (non-blocking) via move, panicking if it is not in the ready state. </p>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-async_get","title":"function async_get","text":"<pre><code>template &lt;typename Handler &gt;\nvoid async_get(\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Invokes <code>handler</code> when the Latch value is set (i.e., when it enters the ready state); invokes handler immediately if the Latch is ready when this method is called. </p> <p>Parameters: </p> <ul> <li>handler Should have signature <code>void(</code>StatusOr<code>&lt;T&gt;)</code></li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1Latch/#function-invalidate","title":"function invalidate","text":"<pre><code>void invalidate()\n</code></pre> <p>Force the latch into an invalid state (for testing mostly). </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/","title":"batt::Latch::AsyncGetHandler","text":""},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#public-functions","title":"Public Functions","text":"Name AsyncGetHandler(Latch * latch) template &lt;typename Handler &gt; void operator()(Handler &amp;&amp; handler, const StatusOr&lt; u32 &gt; &amp; result) const"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#function-asyncgethandler","title":"function AsyncGetHandler","text":"<pre><code>inline explicit AsyncGetHandler(\nLatch * latch\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Latch_1_1AsyncGetHandler/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename Handler &gt;\ninline void operator()(\nHandler &amp;&amp; handler,\nconst StatusOr&lt; u32 &gt; &amp; result\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/","title":"batt::LatencyMetric","text":""},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-functions","title":"Public Functions","text":"Name void update(std::chrono::steady_clock::time_point start, u64 count_delta =1) void update(std::chrono::steady_clock::duration elapsed_duration, u64 count_delta =1) double rate_per_second() const void reset()"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-attributes","title":"Public Attributes","text":"Name CountMetric&lt; u64 &gt; total_usec CountMetric&lt; u64 &gt; count"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-update","title":"function update","text":"<pre><code>inline void update(\nstd::chrono::steady_clock::time_point start,\nu64 count_delta =1\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-update_1","title":"function update","text":"<pre><code>inline void update(\nstd::chrono::steady_clock::duration elapsed_duration,\nu64 count_delta =1\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-rate_per_second","title":"function rate_per_second","text":"<pre><code>inline double rate_per_second() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#variable-total_usec","title":"variable total_usec","text":"<pre><code>CountMetric&lt; u64 &gt; total_usec {0};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyMetric/#variable-count","title":"variable count","text":"<pre><code>CountMetric&lt; u64 &gt; count {0};\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/","title":"batt::LatencyTimer","text":""},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#public-functions","title":"Public Functions","text":"Name LatencyTimer(const LatencyTimer &amp; ) =deleted LatencyTimer &amp; operator=(const LatencyTimer &amp; ) =deleted LatencyTimer(LatencyMetric &amp; counter, u64 delta =1) ~LatencyTimer() i64 read_usec() const void stop()"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-latencytimer","title":"function LatencyTimer","text":"<pre><code>LatencyTimer(\nconst LatencyTimer &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-operator","title":"function operator=","text":"<pre><code>LatencyTimer &amp; operator=(\nconst LatencyTimer &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-latencytimer_1","title":"function LatencyTimer","text":"<pre><code>inline explicit LatencyTimer(\nLatencyMetric &amp; counter,\nu64 delta =1\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-latencytimer_2","title":"function ~LatencyTimer","text":"<pre><code>inline ~LatencyTimer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-read_usec","title":"function read_usec","text":"<pre><code>inline i64 read_usec() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LatencyTimer/#function-stop","title":"function stop","text":"<pre><code>inline void stop()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/","title":"batt::LazyLatch","text":"<p>A write-once, single-value synchronized container that is populated lazily by an init_fn when the value is requested.  More...</p> <p><code>#include &lt;batteries/async/lazy_latch_decl.hpp&gt;</code></p> <p>Inherits from batt::RefCounted&lt; LazyLatch&lt; T &gt; &gt;, batt::BasicAbstractHandler&lt; StatusOr&lt; T &gt; &amp;&amp; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#public-classes","title":"Public Classes","text":"Name class AsyncGetHandler"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#public-types","title":"Public Types","text":"Name enum u32 State { kInitial = 0, kTriggered = 1, kReady = 3}The possible states for the LazyLatch."},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#public-functions","title":"Public Functions","text":"Name LazyLatch(InitFn &amp;&amp; init_fn)Stores the init function until the latch is triggered. LazyLatch(const LazyLatch &amp; ) =deletedLazyLatch is not copy/move-constructible. ~LazyLatch()Destructs the LazyLatch. LazyLatch &amp; operator=(const LazyLatch &amp; ) =deletedLazyLatch is not copy/move-assignable. void trigger()Invokes the init function that was passed in at construction time. bool is_ready() constReturns true iff the lazy_latch is in the ready state. StatusOr&lt; T &gt; await()Block the current task until the LazyLatch is ready, then return the set value (or Status). StatusOr&lt; T &gt; await()Block the current task until the LazyLatch is ready, then return the set value (or Status) via move. StatusOr&lt; T &gt; poll()Same as await(), except this method never blocks; if the LazyLatch isn't ready yet, it immediately returns <code>StatusCode::kUnavailable</code>. StatusOr&lt; T &gt; get_ready_value_or_panic()Returns the value of the LazyLatch (non-blocking), panicking if it is not in the ready state. StatusOr&lt; T &gt; get_ready_value_or_panic()Returns the value of the LazyLatch (non-blocking) via move, panicking if it is not in the ready state. template &lt;typename Handler &gt; void async_get(Handler &amp;&amp; handler)Invokes <code>handler</code> when the LazyLatch value is set (i.e., when it enters the ready state); invokes handler immediately if the LazyLatch is ready when this method is called. void poke()For testing only."},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from batt::BasicAbstractHandler&lt; StatusOr&lt; T &gt; &amp;&amp; &gt;</p> Name struct Deleter Deleter for use in std::unique_ptr. <p>Public Types inherited from batt::BasicAbstractHandler&lt; StatusOr&lt; T &gt; &amp;&amp; &gt;</p> Name using BasicAbstractHandler Self <p>Public Functions inherited from batt::BasicAbstractHandler&lt; StatusOr&lt; T &gt; &amp;&amp; &gt;</p> Name BasicAbstractHandler(const Self &amp; ) =deletedAbstractHandler is not copy-constructible. <p>Protected Functions inherited from batt::BasicAbstractHandler&lt; StatusOr&lt; T &gt; &amp;&amp; &gt;</p> Name BasicAbstractHandler() =default virtual ~BasicAbstractHandler() =default"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename InitFn  =SmallFn&lt;void(AbstractHandler&lt;StatusOr&lt;T&gt;&amp;&amp;&gt;*),                                    kCpuCacheLineSize - (sizeof(void*) + sizeof(Watch&lt;u32&gt;)),                                    true,                                    true&gt;&gt;\nclass batt::LazyLatch;\n</code></pre> <p>A write-once, single-value synchronized container that is populated lazily by an init_fn when the value is requested. </p> <p>This class implements the <code>AbstractHandler&lt;[StatusOr](/_autogen/Classes/classbatt_1_1StatusOr/)&lt;T&gt;&amp;&amp;&gt;</code> interface, which is only exposed when invoking the init function passed in at construction time. This function is invoked when the LazyLatch is \"triggered\" (i.e., when its value is asked for) by calling one of the following member functions:</p> <ul> <li>trigger</li> <li>await</li> <li>async_get The init function must resolve the latch by calling AbstractHandler::notify with a status or value, or AbstractHandler::destroy (in which case, the LazyLatch is resolved to batt::StatusCode::kCancelled). It may do so synchronously or asynchronously. In either case, when the latch is resolved, the init function should assume that invoking notify or destroy will also destroy itself. LazyLatch guarantees that the init function will remain valid until this happens (or until the LazyLatch is destroyed, whichever comes first). Once triggered, the LazyLatch MUST remain in scope until the latch is resolved by the init function. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#enum-state","title":"enum State","text":"Enumerator Value Description kInitial 0 kTriggered 1 kReady 3 <p>The possible states for the LazyLatch. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-lazylatch","title":"function LazyLatch","text":"<pre><code>explicit LazyLatch(\nInitFn &amp;&amp; init_fn\n)\n</code></pre> <p>Stores the init function until the latch is triggered. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-lazylatch_1","title":"function LazyLatch","text":"<pre><code>LazyLatch(\nconst LazyLatch &amp; ) =deleted\n</code></pre> <p>LazyLatch is not copy/move-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-lazylatch_2","title":"function ~LazyLatch","text":"<pre><code>~LazyLatch()\n</code></pre> <p>Destructs the LazyLatch. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-operator","title":"function operator=","text":"<pre><code>LazyLatch &amp; operator=(\nconst LazyLatch &amp; ) =deleted\n</code></pre> <p>LazyLatch is not copy/move-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-trigger","title":"function trigger","text":"<pre><code>void trigger()\n</code></pre> <p>Invokes the init function that was passed in at construction time. </p> <p>The init function is only invoked once, the first time any of the following member functions are called:</p> <ul> <li>trigger</li> <li>await</li> <li>async_get </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-is_ready","title":"function is_ready","text":"<pre><code>bool is_ready() const\n</code></pre> <p>Returns true iff the lazy_latch is in the ready state. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-await","title":"function await","text":"<pre><code>StatusOr&lt; T &gt; await()\n</code></pre> <p>Block the current task until the LazyLatch is ready, then return the set value (or Status). </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-await_1","title":"function await","text":"<pre><code>StatusOr&lt; T &gt; await()\n</code></pre> <p>Block the current task until the LazyLatch is ready, then return the set value (or Status) via move. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-poll","title":"function poll","text":"<pre><code>StatusOr&lt; T &gt; poll()\n</code></pre> <p>Same as await(), except this method never blocks; if the LazyLatch isn't ready yet, it immediately returns <code>StatusCode::kUnavailable</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-get_ready_value_or_panic","title":"function get_ready_value_or_panic","text":"<pre><code>StatusOr&lt; T &gt; get_ready_value_or_panic()\n</code></pre> <p>Returns the value of the LazyLatch (non-blocking), panicking if it is not in the ready state. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-get_ready_value_or_panic_1","title":"function get_ready_value_or_panic","text":"<pre><code>StatusOr&lt; T &gt; get_ready_value_or_panic()\n</code></pre> <p>Returns the value of the LazyLatch (non-blocking) via move, panicking if it is not in the ready state. </p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-async_get","title":"function async_get","text":"<pre><code>template &lt;typename Handler &gt;\nvoid async_get(\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Invokes <code>handler</code> when the LazyLatch value is set (i.e., when it enters the ready state); invokes handler immediately if the LazyLatch is ready when this method is called. </p> <p>Parameters: </p> <ul> <li>handler Should have signature <code>void(</code>StatusOr<code>&lt;T&gt;)</code></li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch/#function-poke","title":"function poke","text":"<pre><code>inline void poke()\n</code></pre> <p>For testing only. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch_1_1AsyncGetHandler/","title":"batt::LazyLatch::AsyncGetHandler","text":""},{"location":"_autogen/Classes/classbatt_1_1LazyLatch_1_1AsyncGetHandler/#public-functions","title":"Public Functions","text":"Name AsyncGetHandler(LazyLatch * latch) template &lt;typename Handler &gt; void operator()(Handler &amp;&amp; handler, const StatusOr&lt; u32 &gt; &amp; result) const"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch_1_1AsyncGetHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LazyLatch_1_1AsyncGetHandler/#function-asyncgethandler","title":"function AsyncGetHandler","text":"<pre><code>inline explicit AsyncGetHandler(\nLazyLatch * latch\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LazyLatch_1_1AsyncGetHandler/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename Handler &gt;\ninline void operator()(\nHandler &amp;&amp; handler,\nconst StatusOr&lt; u32 &gt; &amp; result\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/","title":"batt::LockBase","text":""},{"location":"_autogen/Classes/classbatt_1_1LockBase/#public-types","title":"Public Types","text":"Name enum State { kUnlocked = 0, kLocked = 1, kLockedHaveNext = 2, kInvalid = 3}The possible local states for a lock."},{"location":"_autogen/Classes/classbatt_1_1LockBase/#public-functions","title":"Public Functions","text":"Name PerThreadState &amp; per_thread() LockBase * acquire(const MutexBase &amp; mutex) void release(LockBase * lock) LockBase()Constructs a lock object in an unlocked state. LockBase(const MutexBase &amp; mutex)Constructs a lock object, returning from the constructor only after having acquired the mutex. LockBase(LockBase &amp;&amp; src)Moves the passed lock into a newly constructed lock object, retaining its locked state. LockBase(const LockBase &amp; ) =deletedLocks may not be copy-constructed. LockBase &amp; operator=(const LockBase &amp; ) =deletedLocks may not be copy-assigned. ~LockBase()Destroys this lock object, releasing the mutex if it is currently held by this. LockBase &amp; operator=(LockBase &amp;&amp; src)Releases any mutex currently held by this, and moves <code>src</code> into this, retaining its locked state. void release()Releases the mutex, if held; safe to call if this lock object isn't currently holding the mutex."},{"location":"_autogen/Classes/classbatt_1_1LockBase/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kMaxLockDepth The maximum number of locks a thread can hold at a time, if using the legacy Mutex::lock() API."},{"location":"_autogen/Classes/classbatt_1_1LockBase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LockBase/#enum-state","title":"enum State","text":"Enumerator Value Description kUnlocked 0 This lock does not hold the mutex. kLocked 1 This lock holds the mutex; it is not known whether it is still at the back of the mutex queue, nor whether its next pointer has been set. kLockedHaveNext 2 This lock holds the mutex; it is known that it is no longer at the back of the mutex queue, and that its next pointer has been set. kInvalid 3 <p>The possible local states for a lock. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-per_thread","title":"function per_thread","text":"<pre><code>static PerThreadState &amp; per_thread()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-acquire","title":"function acquire","text":"<pre><code>static LockBase * acquire(\nconst MutexBase &amp; mutex\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-release","title":"function release","text":"<pre><code>static void release(\nLockBase * lock\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-lockbase","title":"function LockBase","text":"<pre><code>inline LockBase()\n</code></pre> <p>Constructs a lock object in an unlocked state. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-lockbase_1","title":"function LockBase","text":"<pre><code>inline explicit LockBase(\nconst MutexBase &amp; mutex\n)\n</code></pre> <p>Constructs a lock object, returning from the constructor only after having acquired the mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-lockbase_2","title":"function LockBase","text":"<pre><code>inline LockBase(\nLockBase &amp;&amp; src\n)\n</code></pre> <p>Moves the passed lock into a newly constructed lock object, retaining its locked state. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-lockbase_3","title":"function LockBase","text":"<pre><code>LockBase(\nconst LockBase &amp; ) =deleted\n</code></pre> <p>Locks may not be copy-constructed. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-operator","title":"function operator=","text":"<pre><code>LockBase &amp; operator=(\nconst LockBase &amp; ) =deleted\n</code></pre> <p>Locks may not be copy-assigned. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-lockbase_4","title":"function ~LockBase","text":"<pre><code>inline ~LockBase()\n</code></pre> <p>Destroys this lock object, releasing the mutex if it is currently held by this. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-operator_1","title":"function operator=","text":"<pre><code>inline LockBase &amp; operator=(\nLockBase &amp;&amp; src\n)\n</code></pre> <p>Releases any mutex currently held by this, and moves <code>src</code> into this, retaining its locked state. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#function-release_1","title":"function release","text":"<pre><code>inline void release()\n</code></pre> <p>Releases the mutex, if held; safe to call if this lock object isn't currently holding the mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1LockBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1LockBase/#variable-kmaxlockdepth","title":"variable kMaxLockDepth","text":"<pre><code>static constexpr usize kMaxLockDepth = 8;\n</code></pre> <p>The maximum number of locks a thread can hold at a time, if using the legacy Mutex::lock() API.  <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/","title":"batt::ManagedBuffer","text":"<p>Inherits from batt::RefCounted&lt; ManagedBuffer &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-functions","title":"Public Functions","text":"Name char * data() const char * data() const usize size() const"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kCapacity"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#function-data","title":"function data","text":"<pre><code>inline char * data()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#function-data_1","title":"function data","text":"<pre><code>inline const char * data() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ManagedBuffer/#variable-kcapacity","title":"variable kCapacity","text":"<pre><code>static constexpr usize kCapacity = 4096;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MapBufferSource/","title":"batt::MapBufferSource","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1MapBufferSource/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Src ,\ntypename MapFn &gt;\nclass batt::MapBufferSource;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/","title":"batt::MetricCsvFormatter","text":"<p>Inherits from batt::MetricFormatter</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#public-functions","title":"Public Functions","text":"Name virtual void initialize(MetricRegistry &amp; src, std::ostream &amp; dst) override virtual void format_values(MetricRegistry &amp; src, std::ostream &amp; dst) override virtual void finished(MetricRegistry &amp; src, std::ostream &amp; dst) override"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricFormatter</p> Name MetricFormatter(const MetricFormatter &amp; ) =deleted MetricFormatter &amp; operator=(const MetricFormatter &amp; ) =deleted virtual ~MetricFormatter() =default <p>Protected Functions inherited from batt::MetricFormatter</p> Name MetricFormatter() =default std::string fully_qualified_name(std::string_view name, const MetricLabelSet &amp; labels)"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#function-initialize","title":"function initialize","text":"<pre><code>inline virtual void initialize(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) override\n</code></pre> <p>Reimplements: batt::MetricFormatter::initialize</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#function-format_values","title":"function format_values","text":"<pre><code>inline virtual void format_values(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) override\n</code></pre> <p>Reimplements: batt::MetricFormatter::format_values</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricCsvFormatter/#function-finished","title":"function finished","text":"<pre><code>inline virtual void finished(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) override\n</code></pre> <p>Reimplements: batt::MetricFormatter::finished</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/","title":"batt::MetricDumper","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#public-functions","title":"Public Functions","text":"Name MetricDumper(MetricRegistry &amp; registry, double rows_per_sec, std::ostream &amp; out, std::unique_ptr&lt; MetricFormatter &gt; formatter) ~MetricDumper() void halt() void join() void stop()"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-metricdumper","title":"function MetricDumper","text":"<pre><code>inline explicit MetricDumper(\nMetricRegistry &amp; registry,\ndouble rows_per_sec,\nstd::ostream &amp; out,\nstd::unique_ptr&lt; MetricFormatter &gt; formatter\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-metricdumper_1","title":"function ~MetricDumper","text":"<pre><code>inline ~MetricDumper()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricDumper/#function-stop","title":"function stop","text":"<pre><code>inline void stop()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/","title":"batt::MetricExporter","text":"<p>Inherited by batt::DerivedMetricExporter&lt; T &gt;, batt::QueueDepthExporter, batt::ScalarMetricExporter&lt; T &gt;, batt::VariableExporter&lt; T &gt;, batt::WatchExporter&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#public-functions","title":"Public Functions","text":"Name MetricExporter(const MetricExporter &amp; ) =deleted MetricExporter &amp; operator=(const MetricExporter &amp; ) =deleted virtual ~MetricExporter() =default virtual Token get_name() const =0 virtual std::string_view get_description() const virtual std::string_view get_type() const virtual const MetricLabelSet &amp; get_labels() const virtual void set_labels(MetricLabelSet &amp;&amp; labels) virtual double get_value() const =0"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#protected-functions","title":"Protected Functions","text":"Name MetricExporter() =default"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-metricexporter","title":"function MetricExporter","text":"<pre><code>MetricExporter(\nconst MetricExporter &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-operator","title":"function operator=","text":"<pre><code>MetricExporter &amp; operator=(\nconst MetricExporter &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-metricexporter_1","title":"function ~MetricExporter","text":"<pre><code>virtual ~MetricExporter() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_name","title":"function get_name","text":"<pre><code>virtual Token get_name() const =0\n</code></pre> <p>Reimplemented by: batt::ScalarMetricExporter::get_name, batt::DerivedMetricExporter::get_name, batt::VariableExporter::get_name, batt::WatchExporter::get_name, batt::QueueDepthExporter::get_name</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_description","title":"function get_description","text":"<pre><code>inline virtual std::string_view get_description() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_type","title":"function get_type","text":"<pre><code>inline virtual std::string_view get_type() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_labels","title":"function get_labels","text":"<pre><code>inline virtual const MetricLabelSet &amp; get_labels() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-set_labels","title":"function set_labels","text":"<pre><code>inline virtual void set_labels(\nMetricLabelSet &amp;&amp; labels\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-get_value","title":"function get_value","text":"<pre><code>virtual double get_value() const =0\n</code></pre> <p>Reimplemented by: batt::ScalarMetricExporter::get_value, batt::DerivedMetricExporter::get_value, batt::VariableExporter::get_value, batt::WatchExporter::get_value, batt::QueueDepthExporter::get_value</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricExporter/#function-metricexporter_2","title":"function MetricExporter","text":"<pre><code>MetricExporter() =default\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/","title":"batt::MetricFormatter","text":"<p>Inherited by batt::MetricCsvFormatter, batt::MetricOpenTelemetryFormatter</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#public-functions","title":"Public Functions","text":"Name MetricFormatter(const MetricFormatter &amp; ) =deleted MetricFormatter &amp; operator=(const MetricFormatter &amp; ) =deleted virtual ~MetricFormatter() =default virtual void initialize(MetricRegistry &amp; src, std::ostream &amp; dst) =0 virtual void format_values(MetricRegistry &amp; src, std::ostream &amp; dst) =0 virtual void finished(MetricRegistry &amp; src, std::ostream &amp; dst) =0"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#protected-functions","title":"Protected Functions","text":"Name MetricFormatter() =default std::string fully_qualified_name(std::string_view name, const MetricLabelSet &amp; labels)"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-metricformatter","title":"function MetricFormatter","text":"<pre><code>MetricFormatter(\nconst MetricFormatter &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-operator","title":"function operator=","text":"<pre><code>MetricFormatter &amp; operator=(\nconst MetricFormatter &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-metricformatter_1","title":"function ~MetricFormatter","text":"<pre><code>virtual ~MetricFormatter() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-initialize","title":"function initialize","text":"<pre><code>virtual void initialize(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) =0\n</code></pre> <p>Reimplemented by: batt::MetricCsvFormatter::initialize, batt::MetricOpenTelemetryFormatter::initialize</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-format_values","title":"function format_values","text":"<pre><code>virtual void format_values(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) =0\n</code></pre> <p>Reimplemented by: batt::MetricCsvFormatter::format_values, batt::MetricOpenTelemetryFormatter::format_values</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-finished","title":"function finished","text":"<pre><code>virtual void finished(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) =0\n</code></pre> <p>Reimplemented by: batt::MetricCsvFormatter::finished, batt::MetricOpenTelemetryFormatter::finished</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-metricformatter_2","title":"function MetricFormatter","text":"<pre><code>MetricFormatter() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricFormatter/#function-fully_qualified_name","title":"function fully_qualified_name","text":"<pre><code>inline std::string fully_qualified_name(\nstd::string_view name,\nconst MetricLabelSet &amp; labels\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/","title":"classbatt 1 1MetricOpenTelemetryFormatter","text":"<p>title: batt::MetricOpenTelemetryFormatter summary: Format metrics into OpenTelemetry data format: {=, ...}"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#battmetricopentelemetryformatter","title":"batt::MetricOpenTelemetryFormatter","text":"<p>Format metrics into OpenTelemetry data format: {=, ...}  More... <p><code>#include &lt;batteries/metrics/metric_otel_formatter.hpp&gt;</code></p> <p>Inherits from batt::MetricFormatter</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#public-functions","title":"Public Functions","text":"Name virtual void initialize(MetricRegistry &amp; src, std::ostream &amp; dst) overrideNothing to do for OpenTelemtry format (stateless implementation). virtual void format_values(MetricRegistry &amp; src, std::ostream &amp; dst) overrideFormat the current metrics and values stored in <code>src</code> to <code>dst</code>. virtual void finished(MetricRegistry &amp; src, std::ostream &amp; dst) overrideNothing to do for OpenTelemtry format (stateless implementation)."},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#public-attributes","title":"Public Attributes","text":"Name constexpr int kMetricValuePrecision The maximum precision for reporting metric numeric value to <code>dst</code>."},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricFormatter</p> Name MetricFormatter(const MetricFormatter &amp; ) =deleted MetricFormatter &amp; operator=(const MetricFormatter &amp; ) =deleted virtual ~MetricFormatter() =default <p>Protected Functions inherited from batt::MetricFormatter</p> Name MetricFormatter() =default std::string fully_qualified_name(std::string_view name, const MetricLabelSet &amp; labels)"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::MetricOpenTelemetryFormatter;\n</code></pre> <p>Format metrics into OpenTelemetry data format: {=, ...}  <p>Example: <code>http_requests_total{method=\"POST\", job=\"Batteries\"} 36000</code></p> <p>Usage: Call <code>format_values</code> any number of times to format the current metric values stored in <code>src</code> to <code>dst</code>. <code>format_values</code> implementation is stateless and does not require calling <code>initialize</code> / <code>finished</code>. Note that <code>dst</code> is not flushed (and it's left up to the caller to decide when to perform this action).</p> <p>Output to <code>dst</code> is reported in lexicographic order to maintain consistency between calls. Since it's possible for metrics to be added or removed from <code>src</code> over time, the data reported to <code>dst</code> represents a snapshot of the current metrics and values during <code>format_values</code> call time. </p>"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#function-initialize","title":"function initialize","text":"<pre><code>inline virtual void initialize(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) override\n</code></pre> <p>Nothing to do for OpenTelemtry format (stateless implementation). </p> <p>Reimplements: batt::MetricFormatter::initialize</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#function-format_values","title":"function format_values","text":"<pre><code>inline virtual void format_values(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) override\n</code></pre> <p>Format the current metrics and values stored in <code>src</code> to <code>dst</code>. </p> <p>Parameters: </p> <ul> <li>src The MetricRegistry where metrics and values are stored. </li> <li>dst The output stream to where formatted data is reported. </li> </ul> <p>Reimplements: batt::MetricFormatter::format_values</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#function-finished","title":"function finished","text":"<pre><code>inline virtual void finished(\nMetricRegistry &amp; src,\nstd::ostream &amp; dst\n) override\n</code></pre> <p>Nothing to do for OpenTelemtry format (stateless implementation). </p> <p>Reimplements: batt::MetricFormatter::finished</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricOpenTelemetryFormatter/#variable-kmetricvalueprecision","title":"variable kMetricValuePrecision","text":"<pre><code>static constexpr int kMetricValuePrecision = 10;\n</code></pre> <p>The maximum precision for reporting metric numeric value to <code>dst</code>. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/","title":"batt::MetricRegistry","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#public-functions","title":"Public Functions","text":"Name MetricRegistry &amp; add_exporter(const void * obj, std::unique_ptr&lt; MetricExporter &gt; exporter, MetricLabelSet &amp;&amp; labels) template &lt;typename T &gt; MetricRegistry &amp; add(std::string_view name, CountMetric&lt; T &gt; &amp; counter, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) MetricRegistry &amp; add(std::string_view name, LatencyMetric &amp; latency, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) template &lt;typename T &gt; MetricRegistry &amp; add(std::string_view name, GaugeMetric&lt; T &gt; &amp; gauge, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) template &lt;typename T &gt; MetricRegistry &amp; add(std::string_view name, StatsMetric&lt; T &gt; &amp; stats, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) template &lt;typename T &gt; MetricRegistry &amp; add(std::string_view name, HistogramMetric&lt; T &gt; &amp; histogram, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) template &lt;typename T &gt; MetricRegistry &amp; add(std::string_view name, Watch&lt; T &gt; &amp; watch, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) MetricRegistry &amp; add(std::string_view name, QueueBase &amp; queue, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) template &lt;typename T &gt; MetricRegistry &amp; add(std::string_view name, DerivedMetric&lt; T &gt; &amp; metric, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) MetricRegistry &amp; add(std::string_view name, const double &amp; var, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) MetricRegistry &amp; add(std::string_view name, const usize &amp; var, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) MetricRegistry &amp; add(std::string_view name, const isize &amp; var, MetricLabelSet &amp;&amp; labels =MetricLabelSet{}) void read_all(std::function&lt; void(std::string_view name, double value, const MetricLabelSet &amp;labels)&gt; &amp;&amp; fn) const template &lt;typename T &gt; MetricRegistry &amp; remove(T &amp; obj) template &lt;typename T &gt; MetricRegistry &amp; remove(HistogramMetric&lt; T &gt; &amp; histogram) template &lt;typename T &gt; auto scoped_add(std::string_view name, T &amp; obj)"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_exporter","title":"function add_exporter","text":"<pre><code>inline MetricRegistry &amp; add_exporter(\nconst void * obj,\nstd::unique_ptr&lt; MetricExporter &gt; exporter,\nMetricLabelSet &amp;&amp; labels\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add","title":"function add","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; add(\nstd::string_view name,\nCountMetric&lt; T &gt; &amp; counter,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_1","title":"function add","text":"<pre><code>inline MetricRegistry &amp; add(\nstd::string_view name,\nLatencyMetric &amp; latency,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_2","title":"function add","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; add(\nstd::string_view name,\nGaugeMetric&lt; T &gt; &amp; gauge,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_3","title":"function add","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; add(\nstd::string_view name,\nStatsMetric&lt; T &gt; &amp; stats,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_4","title":"function add","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; add(\nstd::string_view name,\nHistogramMetric&lt; T &gt; &amp; histogram,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_5","title":"function add","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; add(\nstd::string_view name,\nWatch&lt; T &gt; &amp; watch,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_6","title":"function add","text":"<pre><code>inline MetricRegistry &amp; add(\nstd::string_view name,\nQueueBase &amp; queue,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_7","title":"function add","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; add(\nstd::string_view name,\nDerivedMetric&lt; T &gt; &amp; metric,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_8","title":"function add","text":"<pre><code>inline MetricRegistry &amp; add(\nstd::string_view name,\nconst double &amp; var,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_9","title":"function add","text":"<pre><code>inline MetricRegistry &amp; add(\nstd::string_view name,\nconst usize &amp; var,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-add_10","title":"function add","text":"<pre><code>inline MetricRegistry &amp; add(\nstd::string_view name,\nconst isize &amp; var,\nMetricLabelSet &amp;&amp; labels =MetricLabelSet{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-read_all","title":"function read_all","text":"<pre><code>inline void read_all(\nstd::function&lt; void(std::string_view name, double value, const MetricLabelSet &amp;labels)&gt; &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-remove","title":"function remove","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; remove(\nT &amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-remove_1","title":"function remove","text":"<pre><code>template &lt;typename T &gt;\ninline MetricRegistry &amp; remove(\nHistogramMetric&lt; T &gt; &amp; histogram\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MetricRegistry/#function-scoped_add","title":"function scoped_add","text":"<pre><code>template &lt;typename T &gt;\ninline auto scoped_add(\nstd::string_view name,\nT &amp; obj\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/","title":"batt::MutableBufferView","text":""},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#public-functions","title":"Public Functions","text":"Name MutableBufferView(const MutableBufferView &amp; ) =default MutableBufferView &amp; operator=(const MutableBufferView &amp; ) =default MutableBufferView(SharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer, usize offset =0) MutableBufferView(SharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer, usize offset, usize length) operator MutableBuffer() const operator ConstBuffer() const MutableBufferView &amp; operator+=(usize delta) void * data() const usize size() const bool append(ConstBufferView &amp;&amp; next) bool append(MutableBufferView &amp;&amp; next)"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#friends","title":"Friends","text":"Name class ConstBufferView"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-mutablebufferview","title":"function MutableBufferView","text":"<pre><code>MutableBufferView(\nconst MutableBufferView &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator","title":"function operator=","text":"<pre><code>MutableBufferView &amp; operator=(\nconst MutableBufferView &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-mutablebufferview_1","title":"function MutableBufferView","text":"<pre><code>inline explicit MutableBufferView(\nSharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer,\nusize offset =0\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-mutablebufferview_2","title":"function MutableBufferView","text":"<pre><code>inline explicit MutableBufferView(\nSharedPtr&lt; ManagedBuffer &gt; &amp;&amp; buffer,\nusize offset,\nusize length\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator-mutablebuffer","title":"function operator MutableBuffer","text":"<pre><code>inline operator MutableBuffer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator-constbuffer","title":"function operator ConstBuffer","text":"<pre><code>inline operator ConstBuffer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-operator_1","title":"function operator+=","text":"<pre><code>inline MutableBufferView &amp; operator+=(\nusize delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-data","title":"function data","text":"<pre><code>inline void * data() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-append","title":"function append","text":"<pre><code>inline bool append(\nConstBufferView &amp;&amp; next\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#function-append_1","title":"function append","text":"<pre><code>inline bool append(\nMutableBufferView &amp;&amp; next\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1MutableBufferView/#friend-constbufferview","title":"friend ConstBufferView","text":"<pre><code>friend class ConstBufferView(\nConstBufferView );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/","title":"batt::Mutex","text":"<p>Provides mutually-exclusive access to an instance of type <code>T</code>.  More...</p> <p><code>#include &lt;batteries/async/mutex.hpp&gt;</code></p> <p>Inherits from batt::MutexBase</p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-classes","title":"Public Classes","text":"Name class LockImpl Represents a lock aquisition. struct ThreadSafeBaseIsNotSupportedByType Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is."},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-types","title":"Public Types","text":"Name using LockImpl&lt; T, Mutex &gt; Lock Lock guard for mutable access. using LockImpl&lt; const T, const Mutex &gt; ConstLock Lock guard for const access."},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-functions","title":"Public Functions","text":"Name template &lt;typename Self ,typename Base  =typename Self::ThreadSafeBase&gt; Base * thread_safe_base(Self * ptr)(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object. template &lt;typename Self ,typename Base  =typename Self::ThreadSafeBase&gt; const Base * thread_safe_base(const Self * ptr)(INTERNAL USE ONLY) Return a const pointer to the thread-safe base class of the protected object. template &lt;typename Self ,typename Base  =typename Self::ThreadSafeBase,typename  =void&gt; Base * thread_safe_base(const std::unique_ptr&lt; Self &gt; * ptr)(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object (std::unique_ptr variant). ThreadSafeBaseIsNotSupportedByType&lt; T &gt; * thread_safe_base(... )(INTERNAL USE ONLY) Overload that is selected in the \"not supported\" case - designed to produce an error message that elucidates the root cause of the problem. Mutex(const Mutex &amp; ) =deletedMutex is not copy-constructible. Mutex &amp; operator=(const Mutex &amp; ) =deletedMutex is not copy-assignable. Mutex() =defaultDefault-initializes the protected object. template &lt;typename... Args,typename  =EnableIfNoShadow&gt;  Mutex(Args &amp;&amp;... args)Initializes the protected object by forwarding the args to T's constructor. Lock lock()Acquires a lock on the protected object. ConstLock lock() constAcquires a lock on a const reference to the protected object, for read-only access. template &lt;typename Action &gt; decltype(auto) with_lock(Action &amp;&amp; action)Performs the specified action while holding a lock on the Mutex, by passing a reference to the protected object to the specified action. auto operator-&gt;()Accesses the protected object's thread-safe base class members. decltype(auto) no_lock()Accesses the protected object's thread-safe base class by reference. decltype(auto) no_lock() constAccesses the protected object's thread-safe base class by pointer."},{"location":"_autogen/Classes/classbatt_1_1Mutex/#friends","title":"Friends","text":"Name class ScopedLock"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#additional-inherited-members","title":"Additional inherited members","text":"<p>Protected Attributes inherited from batt::MutexBase</p> Name std::atomic&lt; void * &gt; queue_back_ The most-recent end of the queue of locks; once a locker has acquired the mutex, it stays in this queue until it passes the lock to the next in line. <p>Friends inherited from batt::MutexBase</p> Name class LockBase"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Mutex;\n</code></pre> <p>Provides mutually-exclusive access to an instance of type <code>T</code>. </p> <p>This class has two advantages over <code>std::mutex</code>:</p> <ol> <li>It will yield the current batt::Task (if there is one) when blocking to acquire a lock, allowing the current thread to be used by other tasks</li> <li>By embedding the protected type <code>T</code> within the object, there is a much lower chance that state which should be accessed via a mutex will accidentally be accessed directly This mutex implementation is mostly fair because it uses a modified version of Lamport's Bakery Algorithm </li> </ol>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Mutex/#using-lock","title":"using Lock","text":"<pre><code>using batt::Mutex&lt; T &gt;::Lock =  LockImpl&lt;T, Mutex&gt;;\n</code></pre> <p>Lock guard for mutable access. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#using-constlock","title":"using ConstLock","text":"<pre><code>using batt::Mutex&lt; T &gt;::ConstLock =  LockImpl&lt;const T, const Mutex&gt;;\n</code></pre> <p>Lock guard for const access. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base","title":"function thread_safe_base","text":"<pre><code>template &lt;typename Self ,\ntypename Base  =typename Self::ThreadSafeBase&gt;\nstatic inline Base * thread_safe_base(\nSelf * ptr\n)\n</code></pre> <p>(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base_1","title":"function thread_safe_base","text":"<pre><code>template &lt;typename Self ,\ntypename Base  =typename Self::ThreadSafeBase&gt;\nstatic inline const Base * thread_safe_base(\nconst Self * ptr\n)\n</code></pre> <p>(INTERNAL USE ONLY) Return a const pointer to the thread-safe base class of the protected object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base_2","title":"function thread_safe_base","text":"<pre><code>template &lt;typename Self ,\ntypename Base  =typename Self::ThreadSafeBase,\ntypename  =void&gt;\nstatic inline Base * thread_safe_base(\nconst std::unique_ptr&lt; Self &gt; * ptr\n)\n</code></pre> <p>(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object (std::unique_ptr variant). </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-thread_safe_base_3","title":"function thread_safe_base","text":"<pre><code>static inline ThreadSafeBaseIsNotSupportedByType&lt; T &gt; * thread_safe_base(\n... )\n</code></pre> <p>(INTERNAL USE ONLY) Overload that is selected in the \"not supported\" case - designed to produce an error message that elucidates the root cause of the problem. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-mutex","title":"function Mutex","text":"<pre><code>Mutex(\nconst Mutex &amp; ) =deleted\n</code></pre> <p>Mutex is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-operator","title":"function operator=","text":"<pre><code>Mutex &amp; operator=(\nconst Mutex &amp; ) =deleted\n</code></pre> <p>Mutex is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-mutex_1","title":"function Mutex","text":"<pre><code>Mutex() =default\n</code></pre> <p>Default-initializes the protected object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-mutex_2","title":"function Mutex","text":"<pre><code>template &lt;typename... Args,\ntypename  =EnableIfNoShadow&lt;Mutex, Args...&gt;&gt;\ninline explicit Mutex(\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Initializes the protected object by forwarding the args to T's constructor. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-lock","title":"function lock","text":"<pre><code>inline Lock lock()\n</code></pre> <p>Acquires a lock on the protected object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-lock_1","title":"function lock","text":"<pre><code>inline ConstLock lock() const\n</code></pre> <p>Acquires a lock on a const reference to the protected object, for read-only access. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-with_lock","title":"function with_lock","text":"<pre><code>template &lt;typename Action &gt;\ndecltype(auto) with_lock(\nAction &amp;&amp; action\n)\n</code></pre> <p>Performs the specified action while holding a lock on the Mutex, by passing a reference to the protected object to the specified action. </p> <p>Return: The value returned by <code>action</code>. </p> <p>This function first locks the Mutex, guaranteeing that the current Task will have exclusive access to the protected object (T). Then it passes a non-const reference to the supplied function, whose signature should be <code>Result (T&amp; obj)</code>. When <code>action</code> returns, the Mutex lock is released, and the return value of <code>action</code> is passed back to the caller.</p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline auto operator-&gt;()\n</code></pre> <p>Accesses the protected object's thread-safe base class members. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-no_lock","title":"function no_lock","text":"<pre><code>inline decltype(auto) no_lock()\n</code></pre> <p>Accesses the protected object's thread-safe base class by reference. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#function-no_lock_1","title":"function no_lock","text":"<pre><code>inline decltype(auto) no_lock() const\n</code></pre> <p>Accesses the protected object's thread-safe base class by pointer. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1Mutex/#friend-scopedlock","title":"friend ScopedLock","text":"<pre><code>friend class ScopedLock(\nScopedLock );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1MutexBase/","title":"batt::MutexBase","text":"<p>Base class of typed Mutex; implements core logic without any type dependencies.  <code>#include &lt;batteries/async/mutex.hpp&gt;</code> <p>Inherited by batt::Mutex&lt; std::unordered_map&lt; batt::HostAddress, SharedPtr&lt; batt::HttpClientHostContext &gt;, boost::hash&lt; batt::HostAddress &gt; &gt; &gt;, batt::Mutex&lt; std::deque&lt; T &gt; &gt;, batt::Mutex&lt; batt::NoneType &gt;, batt::Mutex&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1MutexBase/#protected-attributes","title":"Protected Attributes","text":"Name std::atomic&lt; void * &gt; queue_back_ The most-recent end of the queue of locks; once a locker has acquired the mutex, it stays in this queue until it passes the lock to the next in line."},{"location":"_autogen/Classes/classbatt_1_1MutexBase/#friends","title":"Friends","text":"Name class LockBase"},{"location":"_autogen/Classes/classbatt_1_1MutexBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1MutexBase/#variable-queue_back_","title":"variable queue_back_","text":"<pre><code>std::atomic&lt; void * &gt; queue_back_ {nullptr};\n</code></pre> <p>The most-recent end of the queue of locks; once a locker has acquired the mutex, it stays in this queue until it passes the lock to the next in line. </p>"},{"location":"_autogen/Classes/classbatt_1_1MutexBase/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1MutexBase/#friend-lockbase","title":"friend LockBase","text":"<pre><code>friend class LockBase(\nLockBase );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/","title":"batt::Mutex::LockImpl","text":"<p>Represents a lock aquisition.  More...</p> <p><code>#include &lt;batteries/async/mutex.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#public-functions","title":"Public Functions","text":"Name LockImpl(MutexT &amp; m)Acquire a lock on the passed Mutex. LockImpl(const LockImpl &amp; ) =deletedLock is not copy-constructible. LockImpl &amp; operator=(const LockImpl &amp; ) =deletedLock is not copy-assignable. LockImpl(LockImpl &amp;&amp; ) =defaultLock is move-constructible. LockImpl &amp; operator=(LockImpl &amp;&amp; ) =defaultLock is move-assignable. ~LockImpl()Destroy the Lock object, releasing the Mutex. bool is_held() constTest whether this Lock object is the current holder of an exclusive lock on the underlying Mutex. operator bool() constEquivalent to this-&gt;is_held(). U &amp; operator*()Access the locked object. U * get()Access the locked object by pointer. U &amp; value()Access the locked object by reference. U * operator-&gt;()Access members of the locked object. bool release()Explicitly release this lock."},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename U ,\ntypename MutexT &gt;\nclass batt::Mutex::LockImpl;\n</code></pre> <p>Represents a lock aquisition. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl","title":"function LockImpl","text":"<pre><code>inline explicit LockImpl(\nMutexT &amp; m\n)\n</code></pre> <p>Acquire a lock on the passed Mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl_1","title":"function LockImpl","text":"<pre><code>LockImpl(\nconst LockImpl &amp; ) =deleted\n</code></pre> <p>Lock is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator","title":"function operator=","text":"<pre><code>LockImpl &amp; operator=(\nconst LockImpl &amp; ) =deleted\n</code></pre> <p>Lock is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl_2","title":"function LockImpl","text":"<pre><code>LockImpl(\nLockImpl &amp;&amp; ) =default\n</code></pre> <p>Lock is move-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator_1","title":"function operator=","text":"<pre><code>LockImpl &amp; operator=(\nLockImpl &amp;&amp; ) =default\n</code></pre> <p>Lock is move-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-lockimpl_3","title":"function ~LockImpl","text":"<pre><code>inline ~LockImpl()\n</code></pre> <p>Destroy the Lock object, releasing the Mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-is_held","title":"function is_held","text":"<pre><code>inline bool is_held() const\n</code></pre> <p>Test whether this Lock object is the current holder of an exclusive lock on the underlying Mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre> <p>Equivalent to this-&gt;is_held(). </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator_2","title":"function operator*","text":"<pre><code>inline U &amp; operator*()\n</code></pre> <p>Access the locked object. </p> <p>WARNING: Behavior is undefined unless this-&gt;is_held() is true. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-get","title":"function get","text":"<pre><code>inline U * get()\n</code></pre> <p>Access the locked object by pointer. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-value","title":"function value","text":"<pre><code>inline U &amp; value()\n</code></pre> <p>Access the locked object by reference. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline U * operator-&gt;()\n</code></pre> <p>Access members of the locked object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Mutex_1_1LockImpl/#function-release","title":"function release","text":"<pre><code>inline bool release()\n</code></pre> <p>Explicitly release this lock. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/","title":"batt::NoDestruct","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#public-functions","title":"Public Functions","text":"Name NoDestruct() template &lt;typename... Args,typename  =EnableIfNoShadow&gt;  NoDestruct(Args &amp;&amp;... args) NoDestruct(const NoDestruct &amp; ) =deleted NoDestruct &amp; operator=(const NoDestruct &amp; ) =deleted ~NoDestruct() T * pointer() const T * pointer() const T &amp; get() const T &amp; get() const T * operator-&gt;() const T * operator-&gt;() const T &amp; operator*() const T &amp; operator*() const"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::NoDestruct;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-nodestruct","title":"function NoDestruct","text":"<pre><code>inline explicit NoDestruct()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-nodestruct_1","title":"function NoDestruct","text":"<pre><code>template &lt;typename... Args,\ntypename  =EnableIfNoShadow&lt;NoDestruct, Args...&gt;&gt;\ninline explicit NoDestruct(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-nodestruct_2","title":"function NoDestruct","text":"<pre><code>NoDestruct(\nconst NoDestruct &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-operator","title":"function operator=","text":"<pre><code>NoDestruct &amp; operator=(\nconst NoDestruct &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-nodestruct_3","title":"function ~NoDestruct","text":"<pre><code>inline ~NoDestruct()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-pointer","title":"function pointer","text":"<pre><code>inline T * pointer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-pointer_1","title":"function pointer","text":"<pre><code>inline const T * pointer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-get","title":"function get","text":"<pre><code>inline T &amp; get()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-get_1","title":"function get","text":"<pre><code>inline const T &amp; get() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline const T * operator-&gt;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-operator_1","title":"function operator*","text":"<pre><code>inline T &amp; operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NoDestruct/#function-operator_2","title":"function operator*","text":"<pre><code>inline const T &amp; operator*() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/","title":"batt::NullTaskScheduler","text":"<p>Inherits from batt::TaskScheduler</p>"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#public-functions","title":"Public Functions","text":"Name NullTaskScheduler &amp; instance() NullTaskScheduler() virtual boost::asio::any_io_executor schedule_task() override virtual void halt() override virtual void join() override"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::TaskScheduler</p> Name TaskScheduler(const TaskScheduler &amp; ) =deleted TaskScheduler &amp; operator=(const TaskScheduler &amp; ) =deleted virtual ~TaskScheduler() =default <p>Protected Functions inherited from batt::TaskScheduler</p> Name TaskScheduler() =default"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-instance","title":"function instance","text":"<pre><code>static inline NullTaskScheduler &amp; instance()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-nulltaskscheduler","title":"function NullTaskScheduler","text":"<pre><code>inline NullTaskScheduler()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-schedule_task","title":"function schedule_task","text":"<pre><code>inline virtual boost::asio::any_io_executor schedule_task() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::schedule_task</p>"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-halt","title":"function halt","text":"<pre><code>inline virtual void halt() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::halt</p>"},{"location":"_autogen/Classes/classbatt_1_1NullTaskScheduler/#function-join","title":"function join","text":"<pre><code>inline virtual void join() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::join</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Optional/","title":"batt::Optional","text":"<p>More...</p> <p>Inherits from std::conditional_t&lt; can_be_empty_base&lt; T &gt;(), detail::OptionalEmptyBase&lt; T &gt;, detail::OptionalBase&lt; T &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#public-functions","title":"Public Functions","text":"Name Optional() Optional(NoneType ) template &lt;typename... Args,typename  =std::enable_if_t&gt;&gt;  Optional(InPlaceInitType , Args &amp;&amp;... args) Optional(std::optional&lt; T &gt; &amp;&amp; init) template &lt;typename U ,typename  =std::enable_if_t &amp;&amp; !std::is_same_v\\&gt;&gt;,typename  =batt::EnableIfNoShadow&gt;  Optional(Optional&lt; U &gt; &amp;&amp; u) template &lt;typename U ,typename  =std::enable_if_t &amp;&amp; !std::is_same_v\\&gt;&gt;,typename  =batt::EnableIfNoShadow&gt;  Optional(const Optional&lt; U &gt; &amp; u) template &lt;typename... Args,typename  =std::enable_if_t&gt;,typename  =batt::EnableIfNoShadow&gt;  Optional(Args &amp;&amp;... args) Optional(const T &amp; val) ~Optional() Optional(Optional &amp;&amp; that) Optional(const Optional &amp; that) void reset() Optional &amp; operator=(Optional &amp;&amp; that) Optional &amp; operator=(const Optional &amp; that) template &lt;typename... Args&gt; T &amp; emplace(Args &amp;&amp;... args) template &lt;typename U &gt; T value_or(U &amp;&amp; else_val) const template &lt;typename Fn &gt; T or_else(Fn &amp;&amp; fn) const template &lt;typename Fn ,typename U  =std::invoke_result_t&gt; Optional&lt; U &gt; map(Fn &amp;&amp; fn) const template &lt;typename Fn ,typename OptionalU  =std::invoke_result_t&gt; OptionalU flat_map(Fn &amp;&amp; fn) const operator bool() const bool has_value() const Optional &amp; operator=(NoneType ) T &amp; operator*() const T &amp; operator*() const T operator*() T operator*() const =deleted T * operator-&gt;() const T * operator-&gt;() const T * get_ptr() const T * get_ptr() const"},{"location":"_autogen/Classes/classbatt_1_1Optional/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Optional;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional","title":"function Optional","text":"<pre><code>inline Optional()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_1","title":"function Optional","text":"<pre><code>inline Optional(\nNoneType )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_2","title":"function Optional","text":"<pre><code>template &lt;typename... Args,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;T, Args&amp;&amp;...&gt;&gt;&gt;\ninline Optional(\nInPlaceInitType ,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_3","title":"function Optional","text":"<pre><code>inline Optional(\nstd::optional&lt; T &gt; &amp;&amp; init\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_4","title":"function Optional","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;std::is_convertible_v&lt;U, T&gt; &amp;&amp; !std::is_same_v&lt;T, Optional&lt;U&gt;&gt;&gt;,\ntypename  =batt::EnableIfNoShadow&lt;Optional, U&gt;&gt;\ninline Optional(\nOptional&lt; U &gt; &amp;&amp; u\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_5","title":"function Optional","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;std::is_convertible_v&lt;U, T&gt; &amp;&amp; !std::is_same_v&lt;T, Optional&lt;U&gt;&gt;&gt;,\ntypename  =batt::EnableIfNoShadow&lt;Optional, U&gt;&gt;\ninline Optional(\nconst Optional&lt; U &gt; &amp; u\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_6","title":"function Optional","text":"<pre><code>template &lt;typename... Args,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;T, Args&amp;&amp;...&gt;&gt;,\ntypename  =batt::EnableIfNoShadow&lt;Optional, Args...&gt;&gt;\ninline Optional(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_7","title":"function Optional","text":"<pre><code>inline Optional(\nconst T &amp; val\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_8","title":"function ~Optional","text":"<pre><code>inline ~Optional()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_9","title":"function Optional","text":"<pre><code>inline Optional(\nOptional &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-optional_10","title":"function Optional","text":"<pre><code>inline Optional(\nconst Optional &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator","title":"function operator=","text":"<pre><code>inline Optional &amp; operator=(\nOptional &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_1","title":"function operator=","text":"<pre><code>inline Optional &amp; operator=(\nconst Optional &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-emplace","title":"function emplace","text":"<pre><code>template &lt;typename... Args&gt;\ninline T &amp; emplace(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-value_or","title":"function value_or","text":"<pre><code>template &lt;typename U &gt;\ninline T value_or(\nU &amp;&amp; else_val\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-or_else","title":"function or_else","text":"<pre><code>template &lt;typename Fn &gt;\ninline T or_else(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-map","title":"function map","text":"<pre><code>template &lt;typename Fn ,\ntypename U  =std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\ninline Optional&lt; U &gt; map(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-flat_map","title":"function flat_map","text":"<pre><code>template &lt;typename Fn ,\ntypename OptionalU  =std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\ninline OptionalU flat_map(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-has_value","title":"function has_value","text":"<pre><code>inline bool has_value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_2","title":"function operator=","text":"<pre><code>inline Optional &amp; operator=(\nNoneType )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_3","title":"function operator*","text":"<pre><code>inline T &amp; operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_4","title":"function operator*","text":"<pre><code>inline const T &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_5","title":"function operator*","text":"<pre><code>inline T operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator_6","title":"function operator*","text":"<pre><code>T operator*() const =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline const T * operator-&gt;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-get_ptr","title":"function get_ptr","text":"<pre><code>inline T * get_ptr()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional/#function-get_ptr_1","title":"function get_ptr","text":"<pre><code>inline const T * get_ptr() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/","title":"batt::Optional&lt; T &amp; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#public-functions","title":"Public Functions","text":"Name Optional() Optional(NoneType ) template &lt;typename... Args,typename  =std::enable_if_t&gt;&gt;  Optional(InPlaceInitType , Args &amp;&amp;... args) template &lt;typename U ,typename  =std::enable_if_t &amp;&amp; !std::is_same_v\\&gt;&gt;,typename  =batt::EnableIfNoShadow&gt;  Optional(const Optional&lt; U &amp; &gt; &amp; u) Optional(T &amp; ref) Optional(const Optional &amp; ) =default Optional &amp; operator=(const Optional &amp; ) =default ~Optional() template &lt;typename Fn ,typename U  =std::invoke_result_t&gt; Optional&lt; U &gt; map(Fn &amp;&amp; fn) const template &lt;typename Fn ,typename OptionalU  =std::invoke_result_t&gt; OptionalU flat_map(Fn &amp;&amp; fn) const T &amp; operator*() const T * operator-&gt;() const T * operator-&gt;() const bool has_value() const operator bool() const bool operator!() const T &amp; emplace(T &amp; ref) Optional &amp; operator=(NoneType ) T &amp; value_or(T &amp; other) template &lt;typename Fn &gt; T &amp; or_else(Fn &amp;&amp; fn) const"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Optional&lt; T &amp; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional","title":"function Optional","text":"<pre><code>inline Optional()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_1","title":"function Optional","text":"<pre><code>inline Optional(\nNoneType )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_2","title":"function Optional","text":"<pre><code>template &lt;typename... Args,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;T&amp;, Args&amp;&amp;...&gt;&gt;&gt;\ninline Optional(\nInPlaceInitType ,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_3","title":"function Optional","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;std::is_convertible_v&lt;U*, T*&gt; &amp;&amp; !std::is_same_v&lt;T, const Optional&lt;U&gt;&gt;&gt;,\ntypename  =batt::EnableIfNoShadow&lt;Optional, U&gt;&gt;\ninline Optional(\nconst Optional&lt; U &amp; &gt; &amp; u\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_4","title":"function Optional","text":"<pre><code>inline Optional(\nT &amp; ref\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_5","title":"function Optional","text":"<pre><code>Optional(\nconst Optional &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator","title":"function operator=","text":"<pre><code>Optional &amp; operator=(\nconst Optional &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-optional_6","title":"function ~Optional","text":"<pre><code>inline ~Optional()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-map","title":"function map","text":"<pre><code>template &lt;typename Fn ,\ntypename U  =std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\ninline Optional&lt; U &gt; map(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-flat_map","title":"function flat_map","text":"<pre><code>template &lt;typename Fn ,\ntypename OptionalU  =std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\ninline OptionalU flat_map(\nFn &amp;&amp; fn\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator_1","title":"function operator*","text":"<pre><code>inline T &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline const T * operator-&gt;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-has_value","title":"function has_value","text":"<pre><code>inline bool has_value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator_2","title":"function operator!","text":"<pre><code>inline bool operator!() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-emplace","title":"function emplace","text":"<pre><code>inline T &amp; emplace(\nT &amp; ref\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-operator_3","title":"function operator=","text":"<pre><code>inline Optional &amp; operator=(\nNoneType )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-value_or","title":"function value_or","text":"<pre><code>inline T &amp; value_or(\nT &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Optional_3_01T_01_6_01_4/#function-or_else","title":"function or_else","text":"<pre><code>template &lt;typename Fn &gt;\ninline T &amp; or_else(\nFn &amp;&amp; fn\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Pin/","title":"batt::Pin","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#public-functions","title":"Public Functions","text":"Name Pin() Pin(std::nullptr_t ) Pin(T * object) Pin(const Pin &amp; other) Pin(Pin &amp;&amp; other) ~Pin() Pin &amp; operator=(const Pin &amp; other) Pin &amp; operator=(Pin &amp;&amp; other) operator bool() const void swap(Pin &amp; other) void release() T * get() const T &amp; operator*() const T * operator-&gt;() const"},{"location":"_autogen/Classes/classbatt_1_1Pin/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Pin;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin","title":"function Pin","text":"<pre><code>inline Pin()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_1","title":"function Pin","text":"<pre><code>inline explicit Pin(\nstd::nullptr_t )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_2","title":"function Pin","text":"<pre><code>inline explicit Pin(\nT * object\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_3","title":"function Pin","text":"<pre><code>inline Pin(\nconst Pin &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_4","title":"function Pin","text":"<pre><code>inline Pin(\nPin &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-pin_5","title":"function ~Pin","text":"<pre><code>inline ~Pin()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator","title":"function operator=","text":"<pre><code>inline Pin &amp; operator=(\nconst Pin &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator_1","title":"function operator=","text":"<pre><code>inline Pin &amp; operator=(\nPin &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nPin &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-release","title":"function release","text":"<pre><code>inline void release()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-get","title":"function get","text":"<pre><code>inline T * get() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator_2","title":"function operator*","text":"<pre><code>inline T &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pin/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/","title":"batt::Pinnable","text":"<p>Inherited by batt::HttpMessageBase&lt; pico_http::Request &gt;, batt::HttpMessageBase&lt; pico_http::Response &gt;, batt::HttpMessageBase&lt; T &gt;, batt::PinnablePtr&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#public-functions","title":"Public Functions","text":"Name Pinnable() =default Pinnable(const Pinnable &amp; ) =deleted Pinnable &amp; operator=(const Pinnable &amp; ) =deleted ~Pinnable() void pin() void unpin()"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pinnable","title":"function Pinnable","text":"<pre><code>Pinnable() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pinnable_1","title":"function Pinnable","text":"<pre><code>Pinnable(\nconst Pinnable &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-operator","title":"function operator=","text":"<pre><code>Pinnable &amp; operator=(\nconst Pinnable &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pinnable_2","title":"function ~Pinnable","text":"<pre><code>inline ~Pinnable()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-pin","title":"function pin","text":"<pre><code>inline void pin()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Pinnable/#function-unpin","title":"function unpin","text":"<pre><code>inline void unpin()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/","title":"batt::PinnablePtr","text":"<p>A raw pointer augmented to support the batt::Pinnable interface, so that a batt::Pin&gt; can be created to block the destruction of the pointer.  More... <p><code>#include &lt;batteries/async/pin.hpp&gt;</code></p> <p>Inherits from batt::Pinnable</p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#public-functions","title":"Public Functions","text":"Name PinnablePtr(T * ptr)Initializes a PinnablePtr pointing to the given object. PinnablePtr() =defaultInitializes a nullptr PinnablePtr. T * get() constReturns the value of the pointer passed in at construction. operator bool() constReturns true iff the pointer is not nullptr. T &amp; operator*() constDereferences the contained pointer; behavior is undefined if the pointer is nullptr. T * operator-&gt;() constProvides access to members of the object pointed to by this."},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::Pinnable</p> Name Pinnable() =default Pinnable(const Pinnable &amp; ) =deleted Pinnable &amp; operator=(const Pinnable &amp; ) =deleted ~Pinnable() void pin() void unpin()"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::PinnablePtr;\n</code></pre> <p>A raw pointer augmented to support the batt::Pinnable interface, so that a batt::Pin&gt; can be created to block the destruction of the pointer."},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#function-pinnableptr","title":"function PinnablePtr","text":"<pre><code>inline explicit PinnablePtr(\nT * ptr\n)\n</code></pre> <p>Initializes a PinnablePtr pointing to the given object. </p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#function-pinnableptr_1","title":"function PinnablePtr","text":"<pre><code>PinnablePtr() =default\n</code></pre> <p>Initializes a nullptr PinnablePtr. </p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#function-get","title":"function get","text":"<pre><code>inline T * get() const\n</code></pre> <p>Returns the value of the pointer passed in at construction. </p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre> <p>Returns true iff the pointer is not nullptr. </p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#function-operator","title":"function operator*","text":"<pre><code>inline T &amp; operator*() const\n</code></pre> <p>Dereferences the contained pointer; behavior is undefined if the pointer is nullptr. </p>"},{"location":"_autogen/Classes/classbatt_1_1PinnablePtr/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;() const\n</code></pre> <p>Provides access to members of the object pointed to by this. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/","title":"batt::PreallocatedTask","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#public-classes","title":"Public Classes","text":"Name class PreallocatedStackAllocator"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#public-types","title":"Public Types","text":"Name using typename std::allocator_traits&lt; boost::asio::associated_allocator_t&lt; CompletionHandlerFn &gt; &gt;::template rebind_alloc&lt; char &gt; byte_allocator_type"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#public-functions","title":"Public Functions","text":"Name template &lt;typename BodyFn ,typename... TaskArgs&gt; PreallocatedTask * make_new(const boost::asio::any_io_executor &amp; ex, CompletionHandlerFn &amp;&amp; completion_handler, StackSize stack_byte_size, BodyFn &amp;&amp; body_fn, TaskArgs &amp;&amp;... task_args) template &lt;typename BodyFn ,typename... TaskArgs&gt;  PreallocatedTask(const boost::asio::any_io_executor &amp; ex, CompletionHandlerFn &amp;&amp; completion_handler, StackSize stack_byte_size, BodyFn &amp;&amp; body_fn, TaskArgs &amp;&amp;... task_args) ~PreallocatedTask() boost::context::stack_context get_stack_context() const Task * task_pointer() Task &amp; task_ref() Task * operator-&gt;() void start()"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename CompletionHandlerFn  =void()&gt;\nclass batt::PreallocatedTask;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#using-byte_allocator_type","title":"using byte_allocator_type","text":"<pre><code>using batt::PreallocatedTask&lt; CompletionHandlerFn &gt;::byte_allocator_type =  typename std::allocator_traits&lt; boost::asio::associated_allocator_t&lt;CompletionHandlerFn&gt; &gt;::template rebind_alloc&lt;char&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-make_new","title":"function make_new","text":"<pre><code>template &lt;typename BodyFn ,\ntypename... TaskArgs&gt;\nstatic inline PreallocatedTask * make_new(\nconst boost::asio::any_io_executor &amp; ex,\nCompletionHandlerFn &amp;&amp; completion_handler,\nStackSize stack_byte_size,\nBodyFn &amp;&amp; body_fn,\nTaskArgs &amp;&amp;... task_args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-preallocatedtask","title":"function PreallocatedTask","text":"<pre><code>template &lt;typename BodyFn ,\ntypename... TaskArgs&gt;\ninline explicit PreallocatedTask(\nconst boost::asio::any_io_executor &amp; ex,\nCompletionHandlerFn &amp;&amp; completion_handler,\nStackSize stack_byte_size,\nBodyFn &amp;&amp; body_fn,\nTaskArgs &amp;&amp;... task_args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-preallocatedtask_1","title":"function ~PreallocatedTask","text":"<pre><code>inline ~PreallocatedTask()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-get_stack_context","title":"function get_stack_context","text":"<pre><code>inline boost::context::stack_context get_stack_context() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-task_pointer","title":"function task_pointer","text":"<pre><code>inline Task * task_pointer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-task_ref","title":"function task_ref","text":"<pre><code>inline Task &amp; task_ref()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline Task * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/","title":"batt::PreallocatedTask::PreallocatedStackAllocator","text":""},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#public-functions","title":"Public Functions","text":"Name PreallocatedStackAllocator() =default PreallocatedStackAllocator(PreallocatedTask * prealloc) PreallocatedStackAllocator(const PreallocatedStackAllocator &amp; ) =default PreallocatedStackAllocator &amp; operator=(const PreallocatedStackAllocator &amp; ) =default boost::context::stack_context allocate() const void deallocate(boost::context::stack_context &amp; ctx) const"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#function-preallocatedstackallocator","title":"function PreallocatedStackAllocator","text":"<pre><code>PreallocatedStackAllocator() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#function-preallocatedstackallocator_1","title":"function PreallocatedStackAllocator","text":"<pre><code>inline explicit PreallocatedStackAllocator(\nPreallocatedTask * prealloc\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#function-preallocatedstackallocator_2","title":"function PreallocatedStackAllocator","text":"<pre><code>PreallocatedStackAllocator(\nconst PreallocatedStackAllocator &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#function-operator","title":"function operator=","text":"<pre><code>PreallocatedStackAllocator &amp; operator=(\nconst PreallocatedStackAllocator &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#function-allocate","title":"function allocate","text":"<pre><code>inline boost::context::stack_context allocate() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PreallocatedTask_1_1PreallocatedStackAllocator/#function-deallocate","title":"function deallocate","text":"<pre><code>inline void deallocate(\nboost::context::stack_context &amp; ctx\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/","title":"batt::PrependBufferSource","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-types","title":"Public Types","text":"Name using std::decay_t&lt; decltype(boost::asio::buffer_sequence_begin(std::declval&lt; ConstBufferSequence &gt;()))&gt; BufferIter"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-functions","title":"Public Functions","text":"Name PrependBufferSource(ConstBufferSequence &amp;&amp; buffers, Src &amp;&amp; rest) usize size() const StatusOr&lt; SmallVec&lt; ConstBuffer, 3 &gt; &gt; fetch_at_least(i64 min_count_i) void consume(i64 count_i) void close_for_read()"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Src ,\ntypename ConstBufferSequence &gt;\nclass batt::PrependBufferSource;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#using-bufferiter","title":"using BufferIter","text":"<pre><code>using batt::PrependBufferSource&lt; Src, ConstBufferSequence &gt;::BufferIter =  std::decay_t&lt;decltype(boost::asio::buffer_sequence_begin(std::declval&lt;ConstBufferSequence&gt;()))&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-prependbuffersource","title":"function PrependBufferSource","text":"<pre><code>inline explicit PrependBufferSource(\nConstBufferSequence &amp;&amp; buffers,\nSrc &amp;&amp; rest\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 3 &gt; &gt; fetch_at_least(\ni64 min_count_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrependBufferSource/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/","title":"batt::PriorityWatch","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#public-types","title":"Public Types","text":"Name using BasicAbstractHandler&lt; detail::PriorityHeapItem&lt; T &gt;, StatusOr&lt; T &gt; &gt; PriorityHandler"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#public-functions","title":"Public Functions","text":"Name Status await_at_least(T min_value) T clamp_min_value(T min_value) T fetch_add(T delta)"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#public-attributes","title":"Public Attributes","text":"Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::PriorityWatch;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#using-priorityhandler","title":"using PriorityHandler","text":"<pre><code>using batt::PriorityWatch&lt; T &gt;::PriorityHandler =  BasicAbstractHandler&lt;detail::PriorityHeapItem&lt;T&gt;, StatusOr&lt;T&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#function-await_at_least","title":"function await_at_least","text":"<pre><code>inline Status await_at_least(\nT min_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#function-clamp_min_value","title":"function clamp_min_value","text":"<pre><code>inline T clamp_min_value(\nT min_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#function-fetch_add","title":"function fetch_add","text":"<pre><code>inline T fetch_add(\nT delta\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#variable-klocked","title":"variable kLocked","text":"<pre><code>static constexpr u32 kLocked = 0x01;\n</code></pre> <p>(INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. </p>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#variable-kopen","title":"variable kOpen","text":"<pre><code>static constexpr u32 kOpen = 0x02;\n</code></pre> <p>(INTERNAL USE ONLY) indicates that the Watch is not closed. </p>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#variable-kwaiting","title":"variable kWaiting","text":"<pre><code>static constexpr u32 kWaiting = 0x04;\n</code></pre> <p>(INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. </p>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#variable-kclosedatend","title":"variable kClosedAtEnd","text":"<pre><code>static constexpr u32 kClosedAtEnd = 0x08;\n</code></pre> <p>(INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true </p>"},{"location":"_autogen/Classes/classbatt_1_1PriorityWatch/#variable-kclosedbeforeend","title":"variable kClosedBeforeEnd","text":"<pre><code>static constexpr u32 kClosedBeforeEnd = 0x10;\n</code></pre> <p>(INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/","title":"batt::PrometheusMetricExporter","text":""},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#public-classes","title":"Public Classes","text":"Name struct Metrics"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#public-types","title":"Public Types","text":"Name using PrometheusMetricExporter Self"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#public-functions","title":"Public Functions","text":"Name Metrics &amp; metrics() PrometheusMetricExporter(const PrometheusMetricExporter &amp; ) =deleted PrometheusMetricExporter &amp; operator=(const PrometheusMetricExporter &amp; ) =deleted PrometheusMetricExporter(boost::asio::io_context &amp; io, MetricRegistry &amp; registry, const boost::asio::ip::tcp::endpoint &amp; endpoint) PrometheusMetricExporter(boost::asio::io_context &amp; io, const boost::asio::ip::tcp::endpoint &amp; endpoint) PrometheusMetricExporter(boost::asio::io_context &amp; io, u16 port) void start() void halt() void join() batt::Status run() batt::Status run_connection(boost::asio::ip::tcp::socket socket)"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#using-self","title":"using Self","text":"<pre><code>using batt::PrometheusMetricExporter::Self =  PrometheusMetricExporter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-metrics","title":"function metrics","text":"<pre><code>static inline Metrics &amp; metrics()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-prometheusmetricexporter","title":"function PrometheusMetricExporter","text":"<pre><code>PrometheusMetricExporter(\nconst PrometheusMetricExporter &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-operator","title":"function operator=","text":"<pre><code>PrometheusMetricExporter &amp; operator=(\nconst PrometheusMetricExporter &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-prometheusmetricexporter_1","title":"function PrometheusMetricExporter","text":"<pre><code>inline explicit PrometheusMetricExporter(\nboost::asio::io_context &amp; io,\nMetricRegistry &amp; registry,\nconst boost::asio::ip::tcp::endpoint &amp; endpoint\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-prometheusmetricexporter_2","title":"function PrometheusMetricExporter","text":"<pre><code>inline explicit PrometheusMetricExporter(\nboost::asio::io_context &amp; io,\nconst boost::asio::ip::tcp::endpoint &amp; endpoint\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-prometheusmetricexporter_3","title":"function PrometheusMetricExporter","text":"<pre><code>inline explicit PrometheusMetricExporter(\nboost::asio::io_context &amp; io,\nu16 port\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-run","title":"function run","text":"<pre><code>inline batt::Status run()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1PrometheusMetricExporter/#function-run_connection","title":"function run_connection","text":"<pre><code>inline batt::Status run_connection(\nboost::asio::ip::tcp::socket socket\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/","title":"batt::Promise","text":"<p>An obligation to provide a value of type T to a Future.  More...</p> <p><code>#include &lt;batteries/async/future_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#public-functions","title":"Public Functions","text":"Name Promise()Constructs a new empty Promise object. bool is_ready() constTests whether the Future value is ready to be read. void set_value(T &amp;&amp; value)Sets the value of the promise, resolving the corresponding Future and unblocking any pending calls to await. void set_value(StatusOr&lt; T &gt; &amp;&amp; value)Sets the value of the promise, resolving the corresponding Future and unblocking any pending calls to await. void set_value(const StatusOr&lt; T &gt; &amp; value)Sets the value of the promise, resolving the corresponding Future and unblocking any pending calls to await. void set_error(const Status &amp; status)Resolves the promise to the given error status. Future&lt; T &gt; get_future() constSame as <code>batt::get_future(*this)</code>."},{"location":"_autogen/Classes/classbatt_1_1Promise/#friends","title":"Friends","text":"Name Future&lt; U &gt; get_future(const Promise&lt; U &gt; &amp; promise)"},{"location":"_autogen/Classes/classbatt_1_1Promise/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Promise;\n</code></pre> <p>An obligation to provide a value of type T to a Future. </p> <p>See: batt::Future</p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-promise","title":"function Promise","text":"<pre><code>Promise()\n</code></pre> <p>Constructs a new empty Promise object. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-is_ready","title":"function is_ready","text":"<pre><code>bool is_ready() const\n</code></pre> <p>Tests whether the Future value is ready to be read. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-set_value","title":"function set_value","text":"<pre><code>void set_value(\nT &amp;&amp; value\n)\n</code></pre> <p>Sets the value of the promise, resolving the corresponding Future and unblocking any pending calls to await. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-set_value_1","title":"function set_value","text":"<pre><code>void set_value(\nStatusOr&lt; T &gt; &amp;&amp; value\n)\n</code></pre> <p>Sets the value of the promise, resolving the corresponding Future and unblocking any pending calls to await. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-set_value_2","title":"function set_value","text":"<pre><code>void set_value(\nconst StatusOr&lt; T &gt; &amp; value\n)\n</code></pre> <p>Sets the value of the promise, resolving the corresponding Future and unblocking any pending calls to await. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-set_error","title":"function set_error","text":"<pre><code>void set_error(\nconst Status &amp; status\n)\n</code></pre> <p>Resolves the promise to the given error status. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#function-get_future","title":"function get_future","text":"<pre><code>inline Future&lt; T &gt; get_future() const\n</code></pre> <p>Same as <code>batt::get_future(*this)</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1Promise/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1Promise/#friend-get_future","title":"friend get_future","text":"<pre><code>friend Future&lt; U &gt; get_future(\nconst Promise&lt; U &gt; &amp; promise\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/","title":"batt::Queue","text":"<p>Unbounded multi-producer/multi-consumer (MPMC) FIFO queue.  More...</p> <p><code>#include &lt;batteries/async/queue.hpp&gt;</code></p> <p>Inherits from batt::QueueBase</p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#public-functions","title":"Public Functions","text":"Name void close()Closes the queue, causing all current/future read operations to fail/unblock immediately. template &lt;typename... Args&gt; Status push(Args &amp;&amp;... args)Emplaces a single instance of T into the back of the queue using the passed arguments. template &lt;typename FactoryFn &gt; Status push_with_lock(FactoryFn &amp;&amp; factory_fn)Atomically invokes the factory_fn to create an instance of T to push into the Queue. template &lt;typename Items &gt; Status push_all(Items &amp;&amp; items)Inserts multiple items atomically into the Queue. template &lt;typename Items &gt; Status consume_all(Items &amp;&amp; items)Move-copies multiple items atomically into the Queue. StatusOr&lt; T &gt; await_next()Reads a single item from the Queue. template &lt;typename Iter &gt; StatusOr&lt; Iter &gt; await_some(Iter &amp;&amp; first_out, Iter &amp;&amp; last_out)Reads a batch of items form the Queue. Optional&lt; T &gt; try_pop_next()Attempts to read a single item from the Queue (non-blocking). T pop_next_or_panic()Reads a single item from the Queue (non-blocking), panicking if the Queue is empty. template &lt;typename CleanupFn  =DoNothing&gt; usize drain(CleanupFn &amp;&amp; cleanup_fn ={})Reads and discards items from the Queue until it is observed to be empty."},{"location":"_autogen/Classes/classbatt_1_1Queue/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::QueueBase</p> Name bool is_open() constTests whether the Queue is in an open state. bool is_closed() constTests whether the Queue is in a closed state. i64 size() constThe number of items currently in the Queue. bool empty() constTests whether this-&gt;size() is zero. template &lt;typename Predicate  =bool(i64)&gt; StatusOr&lt; i64 &gt; await_size_is_truly(Predicate &amp;&amp; predicate)Blocks the current Task/thread until this-&gt;size() satisfies the given predicate. StatusOr&lt; i64 &gt; await_empty()Blocks the current Task/thread until the Queue is empty. void poke()Wakes all waiters with StatusCode::kPoke. <p>Protected Functions inherited from batt::QueueBase</p> Name Status await_one() StatusOr&lt; i64 &gt; await_count_range(i64 min_count, i64 max_count) bool try_acquire() void notify(i64 count) void close_impl()"},{"location":"_autogen/Classes/classbatt_1_1Queue/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Queue;\n</code></pre> <p>Unbounded multi-producer/multi-consumer (MPMC) FIFO queue. </p> <p>See: QueueBase</p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-close","title":"function close","text":"<pre><code>inline void close()\n</code></pre> <p>Closes the queue, causing all current/future read operations to fail/unblock immediately. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-push","title":"function push","text":"<pre><code>template &lt;typename... Args&gt;\ninline Status push(\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Emplaces a single instance of T into the back of the queue using the passed arguments. </p> <p>Return: true if the push succeeded; false if the queue was closed. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-push_with_lock","title":"function push_with_lock","text":"<pre><code>template &lt;typename FactoryFn &gt;\ninline Status push_with_lock(\nFactoryFn &amp;&amp; factory_fn\n)\n</code></pre> <p>Atomically invokes the factory_fn to create an instance of T to push into the Queue. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-push_all","title":"function push_all","text":"<pre><code>template &lt;typename Items &gt;\ninline Status push_all(\nItems &amp;&amp; items\n)\n</code></pre> <p>Inserts multiple items atomically into the Queue. </p> <p>Queue::push_all guarantees that the passed items will be inserted in the given order, with no other items interposed (via concurrent calls to Queue::push or similar).</p> <p><code>items</code> should be an STL sequence; i.e., something that can be iterated via a for-each loop. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-consume_all","title":"function consume_all","text":"<pre><code>template &lt;typename Items &gt;\ninline Status consume_all(\nItems &amp;&amp; items\n)\n</code></pre> <p>Move-copies multiple items atomically into the Queue. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-await_next","title":"function await_next","text":"<pre><code>inline StatusOr&lt; T &gt; await_next()\n</code></pre> <p>Reads a single item from the Queue. </p> <p>Blocks until an item is available or the Queue is closed. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-await_some","title":"function await_some","text":"<pre><code>template &lt;typename Iter &gt;\ninline StatusOr&lt; Iter &gt; await_some(\nIter &amp;&amp; first_out,\nIter &amp;&amp; last_out\n)\n</code></pre> <p>Reads a batch of items form the Queue. </p> <p>Return: The end iterator for the read sequence on success, error status code otherwise. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-try_pop_next","title":"function try_pop_next","text":"<pre><code>inline Optional&lt; T &gt; try_pop_next()\n</code></pre> <p>Attempts to read a single item from the Queue (non-blocking). </p> <p>Return: The extracted item if successful; batt::None otherwise </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-pop_next_or_panic","title":"function pop_next_or_panic","text":"<pre><code>inline T pop_next_or_panic()\n</code></pre> <p>Reads a single item from the Queue (non-blocking), panicking if the Queue is empty. </p>"},{"location":"_autogen/Classes/classbatt_1_1Queue/#function-drain","title":"function drain","text":"<pre><code>template &lt;typename CleanupFn  =DoNothing&gt;\ninline usize drain(\nCleanupFn &amp;&amp; cleanup_fn ={}\n)\n</code></pre> <p>Reads and discards items from the Queue until it is observed to be empty. </p> <p>Parameters: </p> <ul> <li>cleanup_fn (Optional) A function to run on each drained item in the queue</li> </ul> <p>Return: the number of items read. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/","title":"batt::QueueBase","text":"<p>Type-agnostic base class for all Queue types.  More...</p> <p><code>#include &lt;batteries/async/queue.hpp&gt;</code></p> <p>Inherited by batt::Queue&lt; std::tuple&lt; batt::Pin&lt; batt::HttpRequest &gt;, batt::Pin&lt; batt::HttpResponse &gt; &gt; &gt;, batt::Queue&lt; batt::SmallFn &gt;, batt::Queue&lt; batt::Pin&lt; batt::HttpResponse &gt; &gt;, batt::Queue&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#public-functions","title":"Public Functions","text":"Name bool is_open() constTests whether the Queue is in an open state. bool is_closed() constTests whether the Queue is in a closed state. i64 size() constThe number of items currently in the Queue. bool empty() constTests whether this-&gt;size() is zero. template &lt;typename Predicate  =bool(i64)&gt; StatusOr&lt; i64 &gt; await_size_is_truly(Predicate &amp;&amp; predicate)Blocks the current Task/thread until this-&gt;size() satisfies the given predicate. StatusOr&lt; i64 &gt; await_empty()Blocks the current Task/thread until the Queue is empty. void poke()Wakes all waiters with StatusCode::kPoke."},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#protected-functions","title":"Protected Functions","text":"Name Status await_one() StatusOr&lt; i64 &gt; await_count_range(i64 min_count, i64 max_count) bool try_acquire() void notify(i64 count) void close_impl()"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::QueueBase;\n</code></pre> <p>Type-agnostic base class for all Queue types. </p> <p>See: Queue</p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-is_open","title":"function is_open","text":"<pre><code>inline bool is_open() const\n</code></pre> <p>Tests whether the Queue is in an open state. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-is_closed","title":"function is_closed","text":"<pre><code>inline bool is_closed() const\n</code></pre> <p>Tests whether the Queue is in a closed state. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-size","title":"function size","text":"<pre><code>inline i64 size() const\n</code></pre> <p>The number of items currently in the Queue. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre> <p>Tests whether this-&gt;size() is zero. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_size_is_truly","title":"function await_size_is_truly","text":"<pre><code>template &lt;typename Predicate  =bool(i64)&gt;\ninline StatusOr&lt; i64 &gt; await_size_is_truly(\nPredicate &amp;&amp; predicate\n)\n</code></pre> <p>Blocks the current Task/thread until this-&gt;size() satisfies the given predicate. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_empty","title":"function await_empty","text":"<pre><code>inline StatusOr&lt; i64 &gt; await_empty()\n</code></pre> <p>Blocks the current Task/thread until the Queue is empty. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-poke","title":"function poke","text":"<pre><code>inline void poke()\n</code></pre> <p>Wakes all waiters with StatusCode::kPoke. </p>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_one","title":"function await_one","text":"<pre><code>inline Status await_one()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-await_count_range","title":"function await_count_range","text":"<pre><code>inline StatusOr&lt; i64 &gt; await_count_range(\ni64 min_count,\ni64 max_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-try_acquire","title":"function try_acquire","text":"<pre><code>inline bool try_acquire()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-notify","title":"function notify","text":"<pre><code>inline void notify(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1QueueBase/#function-close_impl","title":"function close_impl","text":"<pre><code>inline void close_impl()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/","title":"batt::QueueDepthExporter","text":"<p>Inherits from batt::MetricExporter</p>"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#public-functions","title":"Public Functions","text":"Name QueueDepthExporter(const std::string &amp; name, QueueBase &amp; queue) virtual Token get_name() const override virtual double get_value() const override"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricExporter</p> Name MetricExporter(const MetricExporter &amp; ) =deleted MetricExporter &amp; operator=(const MetricExporter &amp; ) =deleted virtual ~MetricExporter() =default virtual std::string_view get_description() const virtual std::string_view get_type() const virtual const MetricLabelSet &amp; get_labels() const virtual void set_labels(MetricLabelSet &amp;&amp; labels) <p>Protected Functions inherited from batt::MetricExporter</p> Name MetricExporter() =default"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#function-queuedepthexporter","title":"function QueueDepthExporter","text":"<pre><code>inline explicit QueueDepthExporter(\nconst std::string &amp; name,\nQueueBase &amp; queue\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#function-get_name","title":"function get_name","text":"<pre><code>inline virtual Token get_name() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_name</p>"},{"location":"_autogen/Classes/classbatt_1_1QueueDepthExporter/#function-get_value","title":"function get_value","text":"<pre><code>inline virtual double get_value() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_value</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/","title":"batt::RadixQueue","text":"<p>More...</p> <p>Inherits from boost::equality_comparable&lt; RadixQueue&lt; kCapacityInBits &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-classes","title":"Public Classes","text":"Name struct Hash struct Segment"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-types","title":"Public Types","text":"Name using std::conditional_t&lt;(kCapacityInBits&lt;=std::numeric_limits&lt; u16 &gt;::max()), std::conditional_t&lt;(kCapacityInBits&lt;=std::numeric_limits&lt; u8 &gt;::max()), u8, u16 &gt;, std::conditional_t&lt;(kCapacityInBits&lt;=std::numeric_limits&lt; u32 &gt;::max()), u32, u64 &gt; &gt; index_type"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-functions","title":"Public Functions","text":"Name bool operator==(const RadixQueue &amp; other) const RadixQueue() =default bool empty() const bool full() const void clear() void push(u64 radix, u64 value) u64 pop(u64 radix)"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kQueueSize"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#friends","title":"Friends","text":"Name std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const RadixQueue&lt; N_ &gt; &amp; t)"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;usize kCapacityInBits&gt;\nclass batt::RadixQueue;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#using-index_type","title":"using index_type","text":"<pre><code>using batt::RadixQueue&lt; kCapacityInBits &gt;::index_type =  std::conditional_t&lt; (kCapacityInBits &lt;= std::numeric_limits&lt;u16&gt;::max()), std::conditional_t&lt;(kCapacityInBits &lt;= std::numeric_limits&lt;u8&gt;::max()), u8, u16&gt;, std::conditional_t&lt;(kCapacityInBits &lt;= std::numeric_limits&lt;u32&gt;::max()), u32, u64&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-operator","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst RadixQueue &amp; other\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-radixqueue","title":"function RadixQueue","text":"<pre><code>RadixQueue() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-full","title":"function full","text":"<pre><code>inline bool full() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-push","title":"function push","text":"<pre><code>inline void push(\nu64 radix,\nu64 value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#function-pop","title":"function pop","text":"<pre><code>inline u64 pop(\nu64 radix\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#variable-kqueuesize","title":"variable kQueueSize","text":"<pre><code>static constexpr usize kQueueSize = kCapacityInBits / 64;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1RadixQueue/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst RadixQueue&lt; N_ &gt; &amp; t\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/","title":"batt::RangeDumper","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#public-functions","title":"Public Functions","text":"Name template &lt;typename Arg &gt;  RangeDumper(Arg &amp;&amp; arg, Pretty pretty)"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#friends","title":"Friends","text":"Name std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const RangeDumper &amp; t)"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::RangeDumper;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#function-rangedumper","title":"function RangeDumper","text":"<pre><code>template &lt;typename Arg &gt;\ninline explicit RangeDumper(\nArg &amp;&amp; arg,\nPretty pretty\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1RangeDumper/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst RangeDumper &amp; t\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/","title":"batt::RateMetric","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-types","title":"Public Types","text":"Name using RateMetric Self"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-functions","title":"Public Functions","text":"Name const auto &amp; base_time() i64 now_usec() RateMetric() RateMetric(double default_interval_sec) i64 elapsed_usec() constReturns the number of microseconds that have elapsed since the start of the current interval. double elapsed_sec() constReturns the number of seconds that have elapsed since the start of the current interval. void update(T value)Updates the value whose rate of change is being recorded by this metric. double get() constReturns the aggregate rate, since the start of the current interval."},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-attributes","title":"Public Attributes","text":"Name constexpr i64 kDefaultIntervalUsec"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ni64 kDefaultIntervalSec =2&gt;\nclass batt::RateMetric;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#using-self","title":"using Self","text":"<pre><code>using batt::RateMetric&lt; T, kDefaultIntervalSec &gt;::Self =  RateMetric;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-base_time","title":"function base_time","text":"<pre><code>static inline const auto &amp; base_time()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-now_usec","title":"function now_usec","text":"<pre><code>static inline i64 now_usec()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-ratemetric","title":"function RateMetric","text":"<pre><code>inline explicit RateMetric()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-ratemetric_1","title":"function RateMetric","text":"<pre><code>inline explicit RateMetric(\ndouble default_interval_sec\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-elapsed_usec","title":"function elapsed_usec","text":"<pre><code>inline i64 elapsed_usec() const\n</code></pre> <p>Returns the number of microseconds that have elapsed since the start of the current interval. </p>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-elapsed_sec","title":"function elapsed_sec","text":"<pre><code>inline double elapsed_sec() const\n</code></pre> <p>Returns the number of seconds that have elapsed since the start of the current interval. </p>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-update","title":"function update","text":"<pre><code>inline void update(\nT value\n)\n</code></pre> <p>Updates the value whose rate of change is being recorded by this metric. </p>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#function-get","title":"function get","text":"<pre><code>inline double get() const\n</code></pre> <p>Returns the aggregate rate, since the start of the current interval. </p>"},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1RateMetric/#variable-kdefaultintervalusec","title":"variable kDefaultIntervalUsec","text":"<pre><code>static constexpr i64 kDefaultIntervalUsec = kDefaultIntervalSec * 1000 * 1000;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/","title":"batt::ReadWriteMutex","text":"<p>Mutex wrapper for a value of type T, providing exclusive read/write access and non-exclusive read-only access.  More...</p> <p><code>#include &lt;batteries/async/read_write_lock.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#public-classes","title":"Public Classes","text":"Name struct ThreadSafeBaseIsNotSupportedByType Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is."},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#public-types","title":"Public Types","text":"Name using ReadWriteMutex Self"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#public-functions","title":"Public Functions","text":"Name template &lt;typename Self ,typename Base  =typename Self::ThreadSafeBase&gt; Base * thread_safe_base(Self * ptr)(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object. template &lt;typename Self ,typename Base  =typename Self::ThreadSafeBase&gt; const Base * thread_safe_base(const Self * ptr)(INTERNAL USE ONLY) Return a const pointer to the thread-safe base class of the protected object. template &lt;typename Self ,typename Base  =typename Self::ThreadSafeBase,typename  =void&gt; Base * thread_safe_base(const std::unique_ptr&lt; Self &gt; * ptr)(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object (std::unique_ptr variant). ThreadSafeBaseIsNotSupportedByType&lt; T &gt; * thread_safe_base(... )(INTERNAL USE ONLY) Overload that is selected in the \"not supported\" case - designed to produce an error message that elucidates the root cause of the problem. ReadWriteMutex(const ReadWriteMutex &amp; ) =deletedReadWriteMutex is not copy-constructible. ReadWriteMutex &amp; operator=(const ReadWriteMutex &amp; ) =deletedReadWriteMutex is not copy-assignable. ReadWriteMutex() =defaultDefault-constructs a protected instance of T. template &lt;typename... Args,typename  =EnableIfNoShadow&gt;  ReadWriteMutex(Args &amp;&amp;... args)Initializes the protected object by forwarding the args to T's constructor. template &lt;typename Action &gt; decltype(auto) with_read_lock(Action &amp;&amp; action)Performs the specified action while holding a reader lock on the Mutex, by passing a const reference to the protected object to the specified action. template &lt;typename Action &gt; decltype(auto) with_write_lock(Action &amp;&amp; action)Performs the specified action while holding a writer lock on the Mutex, by passing a reference to the protected object to the specified action. auto operator-&gt;()Accesses the protected object's thread-safe base class members. decltype(auto) no_lock()Accesses the protected object's thread-safe base class by reference. decltype(auto) no_lock() constAccesses the protected object's thread-safe base class by pointer."},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#friends","title":"Friends","text":"Name class ScopedReadWriteLockImpl"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::ReadWriteMutex;\n</code></pre> <p>Mutex wrapper for a value of type T, providing exclusive read/write access and non-exclusive read-only access. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#using-self","title":"using Self","text":"<pre><code>using batt::ReadWriteMutex&lt; T &gt;::Self =  ReadWriteMutex;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-thread_safe_base","title":"function thread_safe_base","text":"<pre><code>template &lt;typename Self ,\ntypename Base  =typename Self::ThreadSafeBase&gt;\nstatic inline Base * thread_safe_base(\nSelf * ptr\n)\n</code></pre> <p>(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-thread_safe_base_1","title":"function thread_safe_base","text":"<pre><code>template &lt;typename Self ,\ntypename Base  =typename Self::ThreadSafeBase&gt;\nstatic inline const Base * thread_safe_base(\nconst Self * ptr\n)\n</code></pre> <p>(INTERNAL USE ONLY) Return a const pointer to the thread-safe base class of the protected object. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-thread_safe_base_2","title":"function thread_safe_base","text":"<pre><code>template &lt;typename Self ,\ntypename Base  =typename Self::ThreadSafeBase,\ntypename  =void&gt;\nstatic inline Base * thread_safe_base(\nconst std::unique_ptr&lt; Self &gt; * ptr\n)\n</code></pre> <p>(INTERNAL USE ONLY) Return a pointer to the thread-safe base class of the protected object (std::unique_ptr variant). </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-thread_safe_base_3","title":"function thread_safe_base","text":"<pre><code>static inline ThreadSafeBaseIsNotSupportedByType&lt; T &gt; * thread_safe_base(\n... )\n</code></pre> <p>(INTERNAL USE ONLY) Overload that is selected in the \"not supported\" case - designed to produce an error message that elucidates the root cause of the problem. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-readwritemutex","title":"function ReadWriteMutex","text":"<pre><code>ReadWriteMutex(\nconst ReadWriteMutex &amp; ) =deleted\n</code></pre> <p>ReadWriteMutex is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-operator","title":"function operator=","text":"<pre><code>ReadWriteMutex &amp; operator=(\nconst ReadWriteMutex &amp; ) =deleted\n</code></pre> <p>ReadWriteMutex is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-readwritemutex_1","title":"function ReadWriteMutex","text":"<pre><code>ReadWriteMutex() =default\n</code></pre> <p>Default-constructs a protected instance of T. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-readwritemutex_2","title":"function ReadWriteMutex","text":"<pre><code>template &lt;typename... Args,\ntypename  =EnableIfNoShadow&lt;Self, Args...&gt;&gt;\ninline explicit ReadWriteMutex(\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Initializes the protected object by forwarding the args to T's constructor. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-with_read_lock","title":"function with_read_lock","text":"<pre><code>template &lt;typename Action &gt;\ndecltype(auto) with_read_lock(\nAction &amp;&amp; action\n)\n</code></pre> <p>Performs the specified action while holding a reader lock on the Mutex, by passing a const reference to the protected object to the specified action. </p> <p>Return: The value returned by <code>action</code>. </p> <p>This function first locks the Mutex, guaranteeing that the current Task will have read-only access to the protected object (T). Then it passes a non-const reference to the supplied function, whose signature should be <code>Result (const T&amp; obj)</code>. When <code>action</code> returns, the Mutex reader lock is released, and the return value of <code>action</code> is passed back to the caller.</p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-with_write_lock","title":"function with_write_lock","text":"<pre><code>template &lt;typename Action &gt;\ndecltype(auto) with_write_lock(\nAction &amp;&amp; action\n)\n</code></pre> <p>Performs the specified action while holding a writer lock on the Mutex, by passing a reference to the protected object to the specified action. </p> <p>Return: The value returned by <code>action</code>. </p> <p>This function first locks the Mutex, guaranteeing that the current Task will have exclusive access to the protected object (T). Then it passes a non-const reference to the supplied function, whose signature should be <code>Result (T&amp; obj)</code>. When <code>action</code> returns, the Mutex writer lock is released, and the return value of <code>action</code> is passed back to the caller.</p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline auto operator-&gt;()\n</code></pre> <p>Accesses the protected object's thread-safe base class members. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-no_lock","title":"function no_lock","text":"<pre><code>inline decltype(auto) no_lock()\n</code></pre> <p>Accesses the protected object's thread-safe base class by reference. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#function-no_lock_1","title":"function no_lock","text":"<pre><code>inline decltype(auto) no_lock() const\n</code></pre> <p>Accesses the protected object's thread-safe base class by pointer. </p>"},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1ReadWriteMutex/#friend-scopedreadwritelockimpl","title":"friend ScopedReadWriteLockImpl","text":"<pre><code>friend class ScopedReadWriteLockImpl(\nScopedReadWriteLockImpl );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Ref/","title":"batt::Ref","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-types","title":"Public Types","text":"Name using typename std::conditional_t&lt; batt::HasSeqRequirements&lt; T &gt;{}, batt::SeqItem_Impl&lt; T &gt;, batt::StaticType&lt; void &gt; &gt;::type Item"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-functions","title":"Public Functions","text":"Name template &lt;typename U ,typename  =std::enable_if_t&gt;&gt;  Ref(U &amp; obj_ref) Ref() template &lt;typename U ,typename  =std::enable_if_t&gt;&gt;  Ref(const Ref&lt; U &gt; &amp; that) template &lt;typename U ,typename  =std::enable_if_t&gt;&gt; Ref &amp; operator=(const Ref&lt; U &gt; &amp; that) bool is_valid() const T &amp; get() const T * pointer() const operator T&amp;() const template &lt;typename... Args,typename  =std::enable_if_t&lt;!std::is_same_v, std::tuple\\&gt;&gt;&gt; decltype(auto) operator()(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) poll(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) poll(Args &amp;&amp;... args) template &lt;typename... Args&gt; decltype(auto) peek(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) peek(Args &amp;&amp;... args) template &lt;typename... Args&gt; decltype(auto) next(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) next(Args &amp;&amp;... args) template &lt;typename... Args&gt; decltype(auto) push_frame(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) await_frame_consumed(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) Update(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) ok(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) recycle_pages(Args &amp;&amp;... args) const template &lt;typename... Args&gt; decltype(auto) await_flush(Args &amp;&amp;... args) const"},{"location":"_autogen/Classes/classbatt_1_1Ref/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Ref;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Ref/#using-item","title":"using Item","text":"<pre><code>using batt::Ref&lt; T &gt;::Item =  typename std::conditional_t&lt;batt::HasSeqRequirements&lt;T&gt;{}, batt::SeqItem_Impl&lt;T&gt;, batt::StaticType&lt;void&gt; &gt;::type;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ref","title":"function Ref","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;T*, U*&gt;&gt;&gt;\ninline Ref(\nU &amp; obj_ref\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ref_1","title":"function Ref","text":"<pre><code>inline Ref()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ref_2","title":"function Ref","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;T*, U*&gt;&gt;&gt;\ninline Ref(\nconst Ref&lt; U &gt; &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-operator","title":"function operator=","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;std::is_constructible_v&lt;T*, U*&gt;&gt;&gt;\ninline Ref &amp; operator=(\nconst Ref&lt; U &gt; &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-get","title":"function get","text":"<pre><code>inline T &amp; get() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-pointer","title":"function pointer","text":"<pre><code>inline T * pointer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-operator-t","title":"function operator T&amp;","text":"<pre><code>inline operator T&amp;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-operator_1","title":"function operator()","text":"<pre><code>template &lt;typename... Args,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::tuple&lt;std::ostream&amp;&gt;, std::tuple&lt;Args...&gt;&gt;&gt;&gt;\ninline decltype(auto) operator()(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-poll","title":"function poll","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) poll(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-poll_1","title":"function poll","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) poll(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-peek","title":"function peek","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) peek(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-peek_1","title":"function peek","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) peek(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-next","title":"function next","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) next(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-next_1","title":"function next","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) next(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-push_frame","title":"function push_frame","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) push_frame(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-await_frame_consumed","title":"function await_frame_consumed","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) await_frame_consumed(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-update","title":"function Update","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) Update(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-ok","title":"function ok","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) ok(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-recycle_pages","title":"function recycle_pages","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) recycle_pages(\nArgs &amp;&amp;... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Ref/#function-await_flush","title":"function await_flush","text":"<pre><code>template &lt;typename... Args&gt;\ninline decltype(auto) await_flush(\nArgs &amp;&amp;... args\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/","title":"batt::Runtime","text":""},{"location":"_autogen/Classes/classbatt_1_1Runtime/#public-classes","title":"Public Classes","text":"Name class DefaultScheduler struct WeakNotifySlot"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#public-functions","title":"Public Functions","text":"Name Runtime &amp; instance() void reset() Runtime() TaskScheduler &amp; default_scheduler() boost::asio::any_io_executor schedule_task() TaskScheduler * exchange_task_scheduler(TaskScheduler * new_scheduler) void halt() bool is_halted() const void join() template &lt;typename... Ts&gt; usize get_weak_notify_slot_index(const Ts &amp;... objs) const template &lt;typename... Ts&gt; WeakNotifySlot &amp; get_weak_notify_slot(const Ts &amp;... objs) template &lt;typename... Ts&gt; void notify(const Ts &amp;... objs) template &lt;typename... Ts&gt; Mutex&lt; NoneType &gt;::Lock lock(const Ts &amp;... objs) template &lt;typename CheckCondition ,typename... Ts&gt; auto await_condition(const CheckCondition &amp; check_condition, const Ts &amp;... objs)"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-instance","title":"function instance","text":"<pre><code>static inline Runtime &amp; instance()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-reset","title":"function reset","text":"<pre><code>static inline void reset()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-runtime","title":"function Runtime","text":"<pre><code>inline explicit Runtime()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-default_scheduler","title":"function default_scheduler","text":"<pre><code>inline TaskScheduler &amp; default_scheduler()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-schedule_task","title":"function schedule_task","text":"<pre><code>inline boost::asio::any_io_executor schedule_task()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-exchange_task_scheduler","title":"function exchange_task_scheduler","text":"<pre><code>inline TaskScheduler * exchange_task_scheduler(\nTaskScheduler * new_scheduler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-is_halted","title":"function is_halted","text":"<pre><code>inline bool is_halted() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-get_weak_notify_slot_index","title":"function get_weak_notify_slot_index","text":"<pre><code>template &lt;typename... Ts&gt;\ninline usize get_weak_notify_slot_index(\nconst Ts &amp;... objs\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-get_weak_notify_slot","title":"function get_weak_notify_slot","text":"<pre><code>template &lt;typename... Ts&gt;\ninline WeakNotifySlot &amp; get_weak_notify_slot(\nconst Ts &amp;... objs\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-notify","title":"function notify","text":"<pre><code>template &lt;typename... Ts&gt;\ninline void notify(\nconst Ts &amp;... objs\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-lock","title":"function lock","text":"<pre><code>template &lt;typename... Ts&gt;\ninline Mutex&lt; NoneType &gt;::Lock lock(\nconst Ts &amp;... objs\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime/#function-await_condition","title":"function await_condition","text":"<pre><code>template &lt;typename CheckCondition ,\ntypename... Ts&gt;\ninline auto await_condition(\nconst CheckCondition &amp; check_condition,\nconst Ts &amp;... objs\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/","title":"batt::Runtime::DefaultScheduler","text":"<p>Inherits from batt::TaskScheduler</p>"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#public-functions","title":"Public Functions","text":"Name DefaultScheduler() ~DefaultScheduler() virtual boost::asio::any_io_executor schedule_task() override virtual void halt() override virtual void join() override"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::TaskScheduler</p> Name TaskScheduler(const TaskScheduler &amp; ) =deleted TaskScheduler &amp; operator=(const TaskScheduler &amp; ) =deleted virtual ~TaskScheduler() =default <p>Protected Functions inherited from batt::TaskScheduler</p> Name TaskScheduler() =default"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-defaultscheduler","title":"function DefaultScheduler","text":"<pre><code>inline explicit DefaultScheduler()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-defaultscheduler_1","title":"function ~DefaultScheduler","text":"<pre><code>inline ~DefaultScheduler()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-schedule_task","title":"function schedule_task","text":"<pre><code>inline virtual boost::asio::any_io_executor schedule_task() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::schedule_task</p>"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-halt","title":"function halt","text":"<pre><code>inline virtual void halt() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::halt</p>"},{"location":"_autogen/Classes/classbatt_1_1Runtime_1_1DefaultScheduler/#function-join","title":"function join","text":"<pre><code>inline virtual void join() override\n</code></pre> <p>Reimplements: batt::TaskScheduler::join</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/","title":"batt::ScalableGrant","text":"<p>A claim on some counted resource.  More...</p> <p><code>#include &lt;batteries/async/scalable_grant.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#public-types","title":"Public Types","text":"Name using ScalableGrantIssuer Issuer using Issuer::State State"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#public-functions","title":"Public Functions","text":"Name ScalableGrant() ScalableGrant(const ScalableGrant &amp; ) =deletedScalableGrant is not copy-constructible. ScalableGrant &amp; operator=(const ScalableGrant &amp; ) =deletedScalableGrant is not copy-assignable. ScalableGrant(ScalableGrant &amp;&amp; that)ScalableGrant is move-constructible. ScalableGrant &amp; operator=(ScalableGrant &amp;&amp; ) =deletedScalableGrant is not move-assignable. ~ScalableGrant()Destroys the ScalableGrant, releasing its allocation back to the ScalableGrant::Issuer that created it. const Issuer * get_issuer() constThe ScalableGrant::Issuer from which this ScalableGrant was created. bool empty() constTests whether <code>this-&gt;[size()]()</code> is 0. operator bool() constEquivalent to this-&gt;is_valid(). bool is_valid() constTests whether this ScalableGrant has non-zero size and is connected to an ScalableGrant::Issuer. bool is_revoked() constTests whether revoke has been called on this ScalableGrant. void revoke()Permanently invalidates this ScalableGrant, waking all waiters with error status. u64 size() constThe current count available for spending on this ScalableGrant. StatusOr&lt; ScalableGrant &gt; spend(u64 count, WaitForResource wait_for_resource =WaitForResource::kFalse)Spends part of the grant, returning a new ScalableGrant representing the spent amount if successful; otherwise: u64 spend_all()Spends all of the grant, returning the previous size. ScalableGrant &amp; subsume(ScalableGrant &amp;&amp; that)Increases this grant by that.size() and set that to empty. void swap(ScalableGrant &amp; that)Swaps the values of this and that."},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#friends","title":"Friends","text":"Name class ScalableGrantIssuer"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::ScalableGrant;\n</code></pre> <p>A claim on some counted resource. </p> <p>See: ScalableGrant::Issuer </p> <p>The unit of a Grant's size is not specified and depends on the application context.</p> <p>This class replaces SpinGrant (the prior implementation of the <code>batt::Grant</code> type) with a new implementation that is at least as fast in the no-contention case, and scales gracefully as pressure to issue grants or spend parts of existing grants (blocking) increases (in terms of number of waiting Tasks).</p> <p>In contrast, SpinGrant suffers from \"thundering herd\" problems as the number of Tasks waiting to claim some count increases, significantly degrading performance under heavy contention.</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#using-issuer","title":"using Issuer","text":"<pre><code>using batt::ScalableGrant::Issuer =  ScalableGrantIssuer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#using-state","title":"using State","text":"<pre><code>using batt::ScalableGrant::State =  Issuer::State;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-scalablegrant","title":"function ScalableGrant","text":"<pre><code>inline ScalableGrant()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-scalablegrant_1","title":"function ScalableGrant","text":"<pre><code>ScalableGrant(\nconst ScalableGrant &amp; ) =deleted\n</code></pre> <p>ScalableGrant is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-operator","title":"function operator=","text":"<pre><code>ScalableGrant &amp; operator=(\nconst ScalableGrant &amp; ) =deleted\n</code></pre> <p>ScalableGrant is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-scalablegrant_2","title":"function ScalableGrant","text":"<pre><code>inline ScalableGrant(\nScalableGrant &amp;&amp; that\n)\n</code></pre> <p>ScalableGrant is move-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-operator_1","title":"function operator=","text":"<pre><code>ScalableGrant &amp; operator=(\nScalableGrant &amp;&amp; ) =deleted\n</code></pre> <p>ScalableGrant is not move-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-scalablegrant_3","title":"function ~ScalableGrant","text":"<pre><code>inline ~ScalableGrant()\n</code></pre> <p>Destroys the ScalableGrant, releasing its allocation back to the ScalableGrant::Issuer that created it. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-get_issuer","title":"function get_issuer","text":"<pre><code>inline const Issuer * get_issuer() const\n</code></pre> <p>The ScalableGrant::Issuer from which this ScalableGrant was created. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre> <p>Tests whether <code>this-&gt;[size()]()</code> is 0. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre> <p>Equivalent to this-&gt;is_valid(). </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre> <p>Tests whether this ScalableGrant has non-zero size and is connected to an ScalableGrant::Issuer. </p> <p>A ScalableGrant that has been moved from is no longer valid. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-is_revoked","title":"function is_revoked","text":"<pre><code>inline bool is_revoked() const\n</code></pre> <p>Tests whether revoke has been called on this ScalableGrant. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-revoke","title":"function revoke","text":"<pre><code>inline void revoke()\n</code></pre> <p>Permanently invalidates this ScalableGrant, waking all waiters with error status. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-size","title":"function size","text":"<pre><code>inline u64 size() const\n</code></pre> <p>The current count available for spending on this ScalableGrant. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-spend","title":"function spend","text":"<pre><code>inline StatusOr&lt; ScalableGrant &gt; spend(\nu64 count,\nWaitForResource wait_for_resource =WaitForResource::kFalse\n)\n</code></pre> <p>Spends part of the grant, returning a new ScalableGrant representing the spent amount if successful; otherwise: </p> <ul> <li><code>batt::StatusCode::kGrantUnavailable</code> if the remaining size of this grant isn't big enough</li> <li><code>batt::StatusCode::kGrantRevoked</code> if this ScalableGrant has been revoked</li> <li><code>batt::StatusCode::kFailedPrecondition</code> if this ScalableGrant has been invalidated by a move </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-spend_all","title":"function spend_all","text":"<pre><code>inline u64 spend_all()\n</code></pre> <p>Spends all of the grant, returning the previous size. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-subsume","title":"function subsume","text":"<pre><code>inline ScalableGrant &amp; subsume(\nScalableGrant &amp;&amp; that\n)\n</code></pre> <p>Increases this grant by that.size() and set that to empty. </p> <p>Will panic unless all of the following are true:</p> <ul> <li>this-&gt;get_issuer() != nullptr</li> <li>this-&gt;get_issuer() == that.get_issuer() </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nScalableGrant &amp; that\n)\n</code></pre> <p>Swaps the values of this and that. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrant/#friend-scalablegrantissuer","title":"friend ScalableGrantIssuer","text":"<pre><code>friend class ScalableGrantIssuer(\nScalableGrantIssuer );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/","title":"batt::ScalableGrantIssuer","text":"<p>A pool from which ScalableGrant instances are allocated.  More...</p> <p><code>#include &lt;batteries/async/scalable_grant.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#public-types","title":"Public Types","text":"Name using ScalableGrantIssuer Issuer using Issuer Self"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#public-functions","title":"Public Functions","text":"Name ScalableGrantIssuer()Constructs an empty pool. ScalableGrantIssuer(u64 size)Constructs a pool with the given initial size. ScalableGrantIssuer(const Self &amp; ) =deletedScalableGrant::Issuer is not copy-construcible. Self &amp; operator=(const Self &amp; ) =deletedScalableGrant::Issuer is not copy-assignable. ~ScalableGrantIssuer()Destroys the pool. StatusOr&lt; ScalableGrant &gt; issue_grant(u64 count, WaitForResource wait_for_resource)Allocate a portion of the pool to create a new ScalableGrant. void grow(u64 count)Increase the pool size by the specified amount. void close()Shut down the pool, denying all future issue_grant requests. u64 available() constThe current count available for allocation via issue_grant. u64 total_size() constThe total count ever added to this pool (initial_count + grow(...))."},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#friends","title":"Friends","text":"Name class ScalableGrant"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::ScalableGrantIssuer;\n</code></pre> <p>A pool from which ScalableGrant instances are allocated. </p> <p>See: ScalableGrant</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#using-issuer","title":"using Issuer","text":"<pre><code>using batt::ScalableGrantIssuer::Issuer =  ScalableGrantIssuer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#using-self","title":"using Self","text":"<pre><code>using batt::ScalableGrantIssuer::Self =  Issuer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-scalablegrantissuer","title":"function ScalableGrantIssuer","text":"<pre><code>inline ScalableGrantIssuer()\n</code></pre> <p>Constructs an empty pool. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-scalablegrantissuer_1","title":"function ScalableGrantIssuer","text":"<pre><code>inline explicit ScalableGrantIssuer(\nu64 size\n)\n</code></pre> <p>Constructs a pool with the given initial size. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-scalablegrantissuer_2","title":"function ScalableGrantIssuer","text":"<pre><code>ScalableGrantIssuer(\nconst Self &amp; ) =deleted\n</code></pre> <p>ScalableGrant::Issuer is not copy-construcible. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-operator","title":"function operator=","text":"<pre><code>Self &amp; operator=(\nconst Self &amp; ) =deleted\n</code></pre> <p>ScalableGrant::Issuer is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-scalablegrantissuer_3","title":"function ~ScalableGrantIssuer","text":"<pre><code>inline ~ScalableGrantIssuer()\n</code></pre> <p>Destroys the pool. </p> <p>All ScalableGrant instances issued from this object MUST be released prior to destroying the ScalableGrant::Issuer, or the program will panic. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-issue_grant","title":"function issue_grant","text":"<pre><code>inline StatusOr&lt; ScalableGrant &gt; issue_grant(\nu64 count,\nWaitForResource wait_for_resource\n)\n</code></pre> <p>Allocate a portion of the pool to create a new ScalableGrant. </p> <p>Return: The newly allocated ScalableGrant if successful; <code>batt::StatusCode::kGrantUnavailable</code> if <code>wait_for_resource</code> is false and there is not enought count in the pool to satisfy the request. </p> <p>This function may block or not depending on the value of <code>wait_for_resource</code>.</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-grow","title":"function grow","text":"<pre><code>inline void grow(\nu64 count\n)\n</code></pre> <p>Increase the pool size by the specified amount. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-close","title":"function close","text":"<pre><code>inline void close()\n</code></pre> <p>Shut down the pool, denying all future issue_grant requests. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-available","title":"function available","text":"<pre><code>inline u64 available() const\n</code></pre> <p>The current count available for allocation via issue_grant. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#function-total_size","title":"function total_size","text":"<pre><code>inline u64 total_size() const\n</code></pre> <p>The total count ever added to this pool (initial_count + grow(...)). </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer/#friend-scalablegrant","title":"friend ScalableGrant","text":"<pre><code>friend class ScalableGrant(\nScalableGrant );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/","title":"batt::ScalableGrantIssuer::State","text":"<p>Implements the common mechanisms shared by Issuer and Grant. ## Public Functions</p> Name void wake_all(Issuer * issuer, ConsumerList &amp; to_wake, Status status)Consumes the passed <code>to_wake</code> list, resolving each handler with a freshly issued grant (if <code>status</code> is ok), or the passed error status. State(u64 init_count)Create a new State with the specified initial count. State(State &amp;&amp; that)Transfers all waiters and count from <code>that</code> to newly created State. StatusOr&lt; ScalableGrant &gt; acquire(Issuer * issuer, u64 n, WaitForResource wait_for_resource)Transfer <code>n</code> count to the caller, possibly blocking (if <code>wait_for_resource</code> is true). bool try_acquire(u64 n)Attempt a fast, non-blocking acquisition of count from this State; returns true iff <code>n</code> was successfully subtracted from this State's count. template &lt;typename HandlerFn  =void(StatusOr)&gt; void async_acquire(Issuer * issuer, u64 n, HandlerFn &amp;&amp; handler)Invokes <code>handler</code> as soon as <code>n</code> count can be granted. u64 acquire_all()Acquires all count. ConsumerList release(u64 n)Increases the count of this State by <code>n</code>, returning a list of consumers whose handlers can be invoked (success case). ConsumerList close()Closes this State, unblocking any current waiters and preventing any future waiters from blocking. u64 get_count() constReturns the current count. bool is_closed() constReturns true iff this State is closed, meaning that it can't be waited on. void swap(State &amp; that)Swap this State with <code>that</code>."},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-wake_all","title":"function wake_all","text":"<pre><code>static inline void wake_all(\nIssuer * issuer,\nConsumerList &amp; to_wake,\nStatus status\n)\n</code></pre> <p>Consumes the passed <code>to_wake</code> list, resolving each handler with a freshly issued grant (if <code>status</code> is ok), or the passed error status. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-state","title":"function State","text":"<pre><code>inline explicit State(\nu64 init_count\n)\n</code></pre> <p>Create a new State with the specified initial count. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-state_1","title":"function State","text":"<pre><code>inline State(\nState &amp;&amp; that\n)\n</code></pre> <p>Transfers all waiters and count from <code>that</code> to newly created State. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-acquire","title":"function acquire","text":"<pre><code>inline StatusOr&lt; ScalableGrant &gt; acquire(\nIssuer * issuer,\nu64 n,\nWaitForResource wait_for_resource\n)\n</code></pre> <p>Transfer <code>n</code> count to the caller, possibly blocking (if <code>wait_for_resource</code> is true). </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-try_acquire","title":"function try_acquire","text":"<pre><code>inline bool try_acquire(\nu64 n\n)\n</code></pre> <p>Attempt a fast, non-blocking acquisition of count from this State; returns true iff <code>n</code> was successfully subtracted from this State's count. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-async_acquire","title":"function async_acquire","text":"<pre><code>template &lt;typename HandlerFn  =void(StatusOr&lt;ScalableGrant&gt;)&gt;\nvoid async_acquire(\nIssuer * issuer,\nu64 n,\nHandlerFn &amp;&amp; handler\n)\n</code></pre> <p>Invokes <code>handler</code> as soon as <code>n</code> count can be granted. </p> <p>May invoke <code>handler</code> before returning. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-acquire_all","title":"function acquire_all","text":"<pre><code>inline u64 acquire_all()\n</code></pre> <p>Acquires all count. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-release","title":"function release","text":"<pre><code>inline ConsumerList release(\nu64 n\n)\n</code></pre> <p>Increases the count of this State by <code>n</code>, returning a list of consumers whose handlers can be invoked (success case). </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-close","title":"function close","text":"<pre><code>inline ConsumerList close()\n</code></pre> <p>Closes this State, unblocking any current waiters and preventing any future waiters from blocking. </p> <p>The returned list of waiters should be resolved with StatusCode::kClosed or some more appropriate error status. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-get_count","title":"function get_count","text":"<pre><code>inline u64 get_count() const\n</code></pre> <p>Returns the current count. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-is_closed","title":"function is_closed","text":"<pre><code>inline bool is_closed() const\n</code></pre> <p>Returns true iff this State is closed, meaning that it can't be waited on. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalableGrantIssuer_1_1State/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nState &amp; that\n)\n</code></pre> <p>Swap this State with <code>that</code>. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/","title":"batt::ScalarMetricExporter","text":"<p>Exports a single value metric.  More...</p> <p><code>#include &lt;batteries/metrics/metric_registry.hpp&gt;</code></p> <p>Inherits from batt::MetricExporter</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#public-functions","title":"Public Functions","text":"Name ScalarMetricExporter(const std::string &amp; name, T &amp; metric) virtual Token get_name() const override virtual double get_value() const override"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricExporter</p> Name MetricExporter(const MetricExporter &amp; ) =deleted MetricExporter &amp; operator=(const MetricExporter &amp; ) =deleted virtual ~MetricExporter() =default virtual std::string_view get_description() const virtual std::string_view get_type() const virtual const MetricLabelSet &amp; get_labels() const virtual void set_labels(MetricLabelSet &amp;&amp; labels) <p>Protected Functions inherited from batt::MetricExporter</p> Name MetricExporter() =default"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;class T &gt;\nclass batt::ScalarMetricExporter;\n</code></pre> <p>Exports a single value metric. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#function-scalarmetricexporter","title":"function ScalarMetricExporter","text":"<pre><code>inline explicit ScalarMetricExporter(\nconst std::string &amp; name,\nT &amp; metric\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#function-get_name","title":"function get_name","text":"<pre><code>inline virtual Token get_name() const override\n</code></pre> <p>Return: The metric name. </p> <p>Reimplements: batt::MetricExporter::get_name</p>"},{"location":"_autogen/Classes/classbatt_1_1ScalarMetricExporter/#function-get_value","title":"function get_value","text":"<pre><code>inline virtual double get_value() const override\n</code></pre> <p>Return: The metric value. </p> <p>Reimplements: batt::MetricExporter::get_value</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/","title":"batt::ScopedLock","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#public-functions","title":"Public Functions","text":"Name ScopedLock(Mutex&lt; T &gt; &amp; m)Acquire a lock on the passed Mutex. ScopedLock(const Mutex&lt; std::remove_const_t&lt; T &gt;&gt; &amp; m)Acquire a lock on the passed Mutex. ScopedLock(const ScopedLock &amp; ) =deletedLock is not copy-constructible. ScopedLock &amp; operator=(const ScopedLock &amp; ) =deletedLock is not copy-assignable. ~ScopedLock()Destroy the Lock object, releasing the Mutex. operator bool() constEquivalent to this-&gt;is_held(). T &amp; operator*()Access the locked object. T * get()Access the locked object by pointer. T &amp; value()Access the locked object by reference. T * operator-&gt;()Access members of the locked object."},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::ScopedLock;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-scopedlock","title":"function ScopedLock","text":"<pre><code>inline explicit ScopedLock(\nMutex&lt; T &gt; &amp; m\n)\n</code></pre> <p>Acquire a lock on the passed Mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-scopedlock_1","title":"function ScopedLock","text":"<pre><code>inline explicit ScopedLock(\nconst Mutex&lt; std::remove_const_t&lt; T &gt;&gt; &amp; m\n)\n</code></pre> <p>Acquire a lock on the passed Mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-scopedlock_2","title":"function ScopedLock","text":"<pre><code>ScopedLock(\nconst ScopedLock &amp; ) =deleted\n</code></pre> <p>Lock is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-operator","title":"function operator=","text":"<pre><code>ScopedLock &amp; operator=(\nconst ScopedLock &amp; ) =deleted\n</code></pre> <p>Lock is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-scopedlock_3","title":"function ~ScopedLock","text":"<pre><code>inline ~ScopedLock()\n</code></pre> <p>Destroy the Lock object, releasing the Mutex. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre> <p>Equivalent to this-&gt;is_held(). </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-operator_1","title":"function operator*","text":"<pre><code>inline T &amp; operator*()\n</code></pre> <p>Access the locked object. </p> <p>WARNING: Behavior is undefined unless this-&gt;is_held() is true. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-get","title":"function get","text":"<pre><code>inline T * get()\n</code></pre> <p>Access the locked object by pointer. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-value","title":"function value","text":"<pre><code>inline T &amp; value()\n</code></pre> <p>Access the locked object by reference. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedLock/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;()\n</code></pre> <p>Access members of the locked object. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/","title":"batt::ScopedReadWriteLockImpl","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#public-functions","title":"Public Functions","text":"Name ScopedReadWriteLockImpl(ReadWriteMutex&lt; std::remove_const_t&lt; T &gt;&gt; &amp; mutex) ScopedReadWriteLockImpl(const ScopedReadWriteLockImpl &amp; ) =deleted ScopedReadWriteLockImpl &amp; operator=(const ScopedReadWriteLockImpl &amp; ) =deleted ~ScopedReadWriteLockImpl() =default T * get()Access the locked object by pointer. T &amp; value()Access the locked object by reference. T * operator-&gt;()Access members of the locked object. T &amp; operator*()Access the locked object."},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename LockT &gt;\nclass batt::ScopedReadWriteLockImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-scopedreadwritelockimpl","title":"function ScopedReadWriteLockImpl","text":"<pre><code>inline explicit ScopedReadWriteLockImpl(\nReadWriteMutex&lt; std::remove_const_t&lt; T &gt;&gt; &amp; mutex\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-scopedreadwritelockimpl_1","title":"function ScopedReadWriteLockImpl","text":"<pre><code>ScopedReadWriteLockImpl(\nconst ScopedReadWriteLockImpl &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-operator","title":"function operator=","text":"<pre><code>ScopedReadWriteLockImpl &amp; operator=(\nconst ScopedReadWriteLockImpl &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-scopedreadwritelockimpl_2","title":"function ~ScopedReadWriteLockImpl","text":"<pre><code>~ScopedReadWriteLockImpl() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-get","title":"function get","text":"<pre><code>inline T * get()\n</code></pre> <p>Access the locked object by pointer. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-value","title":"function value","text":"<pre><code>inline T &amp; value()\n</code></pre> <p>Access the locked object by reference. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline T * operator-&gt;()\n</code></pre> <p>Access members of the locked object. </p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedReadWriteLockImpl/#function-operator_1","title":"function operator*","text":"<pre><code>inline T &amp; operator*()\n</code></pre> <p>Access the locked object. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/","title":"batt::ScopedWorkContext","text":"<p>Inherits from batt::WorkContext</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#public-functions","title":"Public Functions","text":"Name void cancel() ~ScopedWorkContext() WorkContext(const WorkContext &amp; ) =deleted WorkContext(WorkerPool &amp; worker_pool)"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::WorkContext</p> Name WorkContext &amp; operator=(const WorkContext &amp; ) =deleted template &lt;typename Fn &gt; decltype(auto) async_run(Fn &amp;&amp; work_fn) void on_work_started() void on_work_finished() void await_done()"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-cancel","title":"function cancel","text":"<pre><code>inline void cancel()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-scopedworkcontext","title":"function ~ScopedWorkContext","text":"<pre><code>inline ~ScopedWorkContext()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-workcontext","title":"function WorkContext","text":"<pre><code>WorkContext(\nconst WorkContext &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkContext/#function-workcontext_1","title":"function WorkContext","text":"<pre><code>inline explicit WorkContext(\nWorkerPool &amp; worker_pool\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/","title":"batt::ScopedWorkerThreadPool","text":""},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#public-types","title":"Public Types","text":"Name using batt::Optional&lt; boost::asio::executor_work_guard&lt; boost::asio::io_context::executor_type &gt; &gt; WorkGuard"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#public-functions","title":"Public Functions","text":"Name ScopedWorkerThreadPool(usize size, std::function&lt; void(usize thread_i)&gt; &amp;&amp; thread_enter_fn =DoNothing{}, std::function&lt; void(usize thread_i)&gt; &amp;&amp; thread_exit_fn =DoNothing{}) WorkerPool &amp; worker_pool() void halt() void join()"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#using-workguard","title":"using WorkGuard","text":"<pre><code>using batt::ScopedWorkerThreadPool::WorkGuard =  batt::Optional&lt;boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#function-scopedworkerthreadpool","title":"function ScopedWorkerThreadPool","text":"<pre><code>inline explicit ScopedWorkerThreadPool(\nusize size,\nstd::function&lt; void(usize thread_i)&gt; &amp;&amp; thread_enter_fn =DoNothing{},\nstd::function&lt; void(usize thread_i)&gt; &amp;&amp; thread_exit_fn =DoNothing{}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#function-worker_pool","title":"function worker_pool","text":"<pre><code>inline WorkerPool &amp; worker_pool()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1ScopedWorkerThreadPool/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/","title":"batt::SeqBufferSource","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-types","title":"Public Types","text":"Name using ConstBuffer Item"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-functions","title":"Public Functions","text":"Name usize size() const StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(i64 min_count) void consume(i64 count) void close_for_read()"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq &gt;\nclass batt::SeqBufferSource;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#using-item","title":"using Item","text":"<pre><code>using batt::SeqBufferSource&lt; Seq &gt;::Item =  ConstBuffer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(\ni64 min_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqBufferSource/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/","title":"batt::SeqRef","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#public-types","title":"Public Types","text":"Name using SeqItem&lt; SeqT &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#public-functions","title":"Public Functions","text":"Name SeqRef(SeqT &amp; seq) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename SeqT &gt;\nclass batt::SeqRef;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#using-item","title":"using Item","text":"<pre><code>using batt::SeqRef&lt; SeqT &gt;::Item =  SeqItem&lt;SeqT&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#function-seqref","title":"function SeqRef","text":"<pre><code>inline explicit SeqRef(\nSeqT &amp; seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SeqRef/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/","title":"batt::SimpleExecutionContext","text":"<p>A minimal multi-threaded execution context implementation, suitable for parallel-compute thread pools.  <code>#include &lt;batteries/async/simple_executor.hpp&gt;</code></p> <p>Inherits from boost::asio::execution_context</p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#public-types","title":"Public Types","text":"Name using SimpleExecutionContext Self Alias for this type. using SimpleExecutor executor_type The executor type for this context; returned by <code>this-&gt;[get_executor()]()</code>."},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#public-functions","title":"Public Functions","text":"Name auto inside_run_on_this_thread()Returns a thread-local data member used to track whether the current thread is inside <code>[run()]()</code> for this context, so that <code>dispatch</code> can decide whether to run the passed function immediately. SimpleExecutionContext() =default ~SimpleExecutionContext() =default auto get_executor()Returns a new executor that schedules work onto this context. auto work_count()Returns the current work count. auto wake()Notifies all threads inside <code>this-&gt;[run()]()</code> by signalling the condition variable. auto on_work_started()Increments the work count by one. auto on_work_finished()Decrements the work count by one. auto stop()Signals to all threads inside <code>this-&gt;[run()]()</code> to exit their event processing loop ASAP. auto is_stopped() constReturns true as soon as <code>this-&gt;[stop()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-stop)</code> is called; this does not indicate that threads have exited <code>this-&gt;[run()]()</code>, only that <code>this-&gt;[stop()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-stop)</code> has been called. auto run()Blocks the current thread processing <code>[post()]()</code>-ed completion handlers while all of the following are true: auto reset()Sets <code>this-&gt;[is_stopped()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-is-stopped)</code> to false to allow threads to enter <code>this-&gt;[run()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run)</code> to resume work processing. auto get_allocator() constAccesses the default allocator directly. template &lt;typename Fn &gt; auto dispatch(Fn &amp;&amp; fn)Runs <code>fn</code> in this context, possibly blocking the caller. template &lt;typename Fn &gt; auto post(Fn &amp;&amp; fn)Runs <code>fn</code> in this context; never blocks the caller. template &lt;typename Fn &gt; auto defer(Fn &amp;&amp; fn)Runs <code>fn</code> in this context as a continuation of the currently executing completion handler; this should be used to avoid contention."},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#using-self","title":"using Self","text":"<pre><code>using batt::SimpleExecutionContext::Self =  SimpleExecutionContext;\n</code></pre> <p>Alias for this type. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#using-executor_type","title":"using executor_type","text":"<pre><code>using batt::SimpleExecutionContext::executor_type =  SimpleExecutor;\n</code></pre> <p>The executor type for this context; returned by <code>this-&gt;[get_executor()]()</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-inside_run_on_this_thread","title":"function inside_run_on_this_thread","text":"<pre><code>static inline auto inside_run_on_this_thread()\n</code></pre> <p>Returns a thread-local data member used to track whether the current thread is inside <code>[run()]()</code> for this context, so that <code>dispatch</code> can decide whether to run the passed function immediately. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-simpleexecutioncontext","title":"function SimpleExecutionContext","text":"<pre><code>SimpleExecutionContext() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-simpleexecutioncontext_1","title":"function ~SimpleExecutionContext","text":"<pre><code>~SimpleExecutionContext() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-get_executor","title":"function get_executor","text":"<pre><code>inline auto get_executor()\n</code></pre> <p>Returns a new executor that schedules work onto this context. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-work_count","title":"function work_count","text":"<pre><code>inline auto work_count()\n</code></pre> <p>Returns the current work count. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-wake","title":"function wake","text":"<pre><code>inline auto wake()\n</code></pre> <p>Notifies all threads inside <code>this-&gt;[run()]()</code> by signalling the condition variable. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-on_work_started","title":"function on_work_started","text":"<pre><code>inline auto on_work_started()\n</code></pre> <p>Increments the work count by one. </p> <p>This is automatically done inside <code>[post()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-post)</code> (or equivalent; i.e., <code>[dispatch()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-dispatch)</code> (within <code>this-&gt;[run()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run)</code>) or <code>defer</code>). </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-on_work_finished","title":"function on_work_finished","text":"<pre><code>inline auto on_work_finished()\n</code></pre> <p>Decrements the work count by one. </p> <p>This is automatically done when posted completion handlers are executed. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-stop","title":"function stop","text":"<pre><code>inline auto stop()\n</code></pre> <p>Signals to all threads inside <code>this-&gt;[run()]()</code> to exit their event processing loop ASAP. </p> <p>Once all threads have exited <code>[run()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run)</code>, <code>this-&gt;[reset()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-reset)</code> must be called before <code>this-&gt;[run()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run)</code> to resume normal processing. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-is_stopped","title":"function is_stopped","text":"<pre><code>inline auto is_stopped() const\n</code></pre> <p>Returns true as soon as <code>this-&gt;[stop()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-stop)</code> is called; this does not indicate that threads have exited <code>this-&gt;[run()]()</code>, only that <code>this-&gt;[stop()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-stop)</code> has been called. </p> <p>Initially <code>false</code> when a context is constructed. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run","title":"function run","text":"<pre><code>inline auto run()\n</code></pre> <p>Blocks the current thread processing <code>[post()]()</code>-ed completion handlers while all of the following are true: </p> <p>Return: The number of handlers processed. </p> <ul> <li>This context's work count is non-zero</li> <li><code>this-&gt;[is_stopped()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-is-stopped)</code> is false</li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-reset","title":"function reset","text":"<pre><code>inline auto reset()\n</code></pre> <p>Sets <code>this-&gt;[is_stopped()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-is-stopped)</code> to false to allow threads to enter <code>this-&gt;[run()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run)</code> to resume work processing. </p> <p>This should only be called once the caller is sure that no thread is inside <code>this-&gt;[run()](/_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-run)</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-get_allocator","title":"function get_allocator","text":"<pre><code>inline auto get_allocator() const\n</code></pre> <p>Accesses the default allocator directly. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-dispatch","title":"function dispatch","text":"<pre><code>template &lt;typename Fn &gt;\nauto dispatch(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Runs <code>fn</code> in this context, possibly blocking the caller. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-post","title":"function post","text":"<pre><code>template &lt;typename Fn &gt;\nauto post(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Runs <code>fn</code> in this context; never blocks the caller. </p>"},{"location":"_autogen/Classes/classbatt_1_1SimpleExecutionContext/#function-defer","title":"function defer","text":"<pre><code>template &lt;typename Fn &gt;\nauto defer(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Runs <code>fn</code> in this context as a continuation of the currently executing completion handler; this should be used to avoid contention. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/","title":"batt::SingleBufferSource","text":"<p>Adapts a single ConstBuffer to be a BufferSource.  <code>#include &lt;batteries/async/buffer_source.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#public-functions","title":"Public Functions","text":"Name SingleBufferSource() =defaultConstructs a BufferSource with zero bytes (empty). SingleBufferSource(const SingleBufferSource &amp; ) =defaultSingleBufferSource is copyable by assignment and move. SingleBufferSource &amp; operator=(const SingleBufferSource &amp; ) =defaultSingleBufferSource is copyable by assignment and move. SingleBufferSource(const ConstBuffer &amp; buffer)Constructs a SingleBufferSource containing exactly the passed buffer. SingleBufferSource(const void * ptr, usize size)Constructs a SingleBufferSource containing <code>size</code> bytes, beginning at <code>ptr</code>. SingleBufferSource(const std::string_view &amp; str)Constructs a SingleBufferSource containing the characters of the passed string. SingleBufferSource &amp; operator=(const ConstBuffer &amp; buffer)Assigns the buffer source to the passed buffer. SingleBufferSource &amp; operator=(const std::string_view &amp; str) usize size() constReturns the current size of the buffer. StatusOr&lt; SmallVec&lt; ConstBuffer, 1 &gt; &gt; fetch_at_least(i64 min_count)Always returns a sequence of size 1, containing the buffer, unless it is empty; then it returns an empty sequence. void consume(i64 count)Advances the buffer by the specified number of bytes (which MUST be &gt;0, or we panic). void close_for_read()Sets the buffer to an empty ConstBuffer."},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-singlebuffersource","title":"function SingleBufferSource","text":"<pre><code>SingleBufferSource() =default\n</code></pre> <p>Constructs a BufferSource with zero bytes (empty). </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-singlebuffersource_1","title":"function SingleBufferSource","text":"<pre><code>SingleBufferSource(\nconst SingleBufferSource &amp; ) =default\n</code></pre> <p>SingleBufferSource is copyable by assignment and move. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-operator","title":"function operator=","text":"<pre><code>SingleBufferSource &amp; operator=(\nconst SingleBufferSource &amp; ) =default\n</code></pre> <p>SingleBufferSource is copyable by assignment and move. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-singlebuffersource_2","title":"function SingleBufferSource","text":"<pre><code>inline explicit SingleBufferSource(\nconst ConstBuffer &amp; buffer\n)\n</code></pre> <p>Constructs a SingleBufferSource containing exactly the passed buffer. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-singlebuffersource_3","title":"function SingleBufferSource","text":"<pre><code>inline explicit SingleBufferSource(\nconst void * ptr,\nusize size\n)\n</code></pre> <p>Constructs a SingleBufferSource containing <code>size</code> bytes, beginning at <code>ptr</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-singlebuffersource_4","title":"function SingleBufferSource","text":"<pre><code>inline explicit SingleBufferSource(\nconst std::string_view &amp; str\n)\n</code></pre> <p>Constructs a SingleBufferSource containing the characters of the passed string. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-operator_1","title":"function operator=","text":"<pre><code>inline SingleBufferSource &amp; operator=(\nconst ConstBuffer &amp; buffer\n)\n</code></pre> <p>Assigns the buffer source to the passed buffer. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-operator_2","title":"function operator=","text":"<pre><code>inline SingleBufferSource &amp; operator=(\nconst std::string_view &amp; str\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre> <p>Returns the current size of the buffer. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 1 &gt; &gt; fetch_at_least(\ni64 min_count\n)\n</code></pre> <p>Always returns a sequence of size 1, containing the buffer, unless it is empty; then it returns an empty sequence. </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre> <p>Advances the buffer by the specified number of bytes (which MUST be &gt;0, or we panic). </p>"},{"location":"_autogen/Classes/classbatt_1_1SingleBufferSource/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre> <p>Sets the buffer to an empty ConstBuffer. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SkipN/","title":"batt::SkipN","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-functions","title":"Public Functions","text":"Name SkipN(Seq &amp;&amp; seq, usize n) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq &gt;\nclass batt::SkipN;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SkipN/#using-item","title":"using Item","text":"<pre><code>using batt::SkipN&lt; Seq &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SkipN/#function-skipn","title":"function SkipN","text":"<pre><code>inline explicit SkipN(\nSeq &amp;&amp; seq,\nusize n\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SkipN/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SkipNode/","title":"batt::SkipNode","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SkipNode/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename KeyT ,\ntypename ValueT ,\ntypename OrderFn ,\ni32 kHeight&gt;\nclass batt::SkipNode;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/","title":"batt::SkipNodeBase","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#public-types","title":"Public Types","text":"Name template &lt;i32 kHeight&gt; using SkipNode&lt; KeyT, ValueT, OrderFn, kHeight &gt; Derived"},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#public-functions","title":"Public Functions","text":"Name SkipNodeBase * allocate(i32 new_node_height)"},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename KeyT ,\ntypename ValueT ,\ntypename OrderFn &gt;\nclass batt::SkipNodeBase;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#using-derived","title":"using Derived","text":"<pre><code>template &lt;i32 kHeight&gt;\nusing batt::SkipNodeBase&lt; KeyT, ValueT, OrderFn &gt;::Derived =  SkipNode&lt;KeyT, ValueT, OrderFn, kHeight&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SkipNodeBase/#function-allocate","title":"function allocate","text":"<pre><code>static inline SkipNodeBase * allocate(\ni32 new_node_height\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SmallFn/","title":"batt::SmallFn","text":"<p>A type-erased container for a callable function-like object with a statically bounded maximum size.  More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SmallFn/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Signature ,\nusize kMaxSize =kCpuCacheLineSize - sizeof(void*),\nbool kMoveOnly =false,\nbool kAllowAlloc =false&gt;\nclass batt::SmallFn;\n</code></pre> <p>A type-erased container for a callable function-like object with a statically bounded maximum size. </p> <p>By default, the static buffer allocated internal to SmallFn is sized such that <code>sizeof(SmallFn)</code> is equal to a single CPU cache line. This class can be used to type-erase both regular copyable types and move-only callable types. UniqueSmallFn can be used to type-erase move-only callable types. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/","title":"batt::SpinGrant","text":"<p>A claim on some counted resource.  More...</p> <p><code>#include &lt;batteries/async/spin_grant_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#public-classes","title":"Public Classes","text":"Name class Issuer A pool from which SpinGrant instances are allocated."},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#public-functions","title":"Public Functions","text":"Name SpinGrant(const SpinGrant &amp; ) =deletedSpinGrant is not copy-constructible. SpinGrant &amp; operator=(const SpinGrant &amp; ) =deletedSpinGrant is not copy-assignable. SpinGrant(SpinGrant &amp;&amp; that)SpinGrant is move-constructible. SpinGrant &amp; operator=(SpinGrant &amp;&amp; ) =deletedSpinGrant is not move-assignable. ~SpinGrant()Destroys the SpinGrant, releasing its allocation back to the SpinGrant::Issuer that created it. const Issuer * get_issuer() constThe SpinGrant::Issuer from which this SpinGrant was created. bool empty() constTests whether <code>this-&gt;[size()]()</code> is 0. operator bool() constEquivalent to this-&gt;is_valid(). bool is_valid() constTests whether this SpinGrant has non-zero size and is connected to an SpinGrant::Issuer. bool is_revoked() constTests whether revoke has been called on this SpinGrant. void revoke()Permanently invalidates this SpinGrant, waking all waiters with error status. u64 size() constThe current count available for spending on this SpinGrant. StatusOr&lt; SpinGrant &gt; spend(u64 count, WaitForResource wait_for_resource =WaitForResource::kFalse)Spends part of the grant, returning a new SpinGrant representing the spent amount if successful; otherwise: u64 spend_all()Spends all of the grant, returning the previous size. SpinGrant &amp; subsume(SpinGrant &amp;&amp; that)Increases this grant by that.size() and set that to empty. void swap(SpinGrant &amp; that)Swaps the values of this and that."},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::SpinGrant;\n</code></pre> <p>A claim on some counted resource. </p> <p>See: SpinGrant::Issuer</p> <p>The unit of a Grant's size is not specified and depends on the application context.</p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-spingrant","title":"function SpinGrant","text":"<pre><code>SpinGrant(\nconst SpinGrant &amp; ) =deleted\n</code></pre> <p>SpinGrant is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-operator","title":"function operator=","text":"<pre><code>SpinGrant &amp; operator=(\nconst SpinGrant &amp; ) =deleted\n</code></pre> <p>SpinGrant is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-spingrant_1","title":"function SpinGrant","text":"<pre><code>inline SpinGrant(\nSpinGrant &amp;&amp; that\n)\n</code></pre> <p>SpinGrant is move-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-operator_1","title":"function operator=","text":"<pre><code>SpinGrant &amp; operator=(\nSpinGrant &amp;&amp; ) =deleted\n</code></pre> <p>SpinGrant is not move-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-spingrant_2","title":"function ~SpinGrant","text":"<pre><code>inline ~SpinGrant()\n</code></pre> <p>Destroys the SpinGrant, releasing its allocation back to the SpinGrant::Issuer that created it. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-get_issuer","title":"function get_issuer","text":"<pre><code>inline const Issuer * get_issuer() const\n</code></pre> <p>The SpinGrant::Issuer from which this SpinGrant was created. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre> <p>Tests whether <code>this-&gt;[size()]()</code> is 0. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre> <p>Equivalent to this-&gt;is_valid(). </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre> <p>Tests whether this SpinGrant has non-zero size and is connected to an SpinGrant::Issuer. </p> <p>A SpinGrant that has been moved from is no longer valid. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-is_revoked","title":"function is_revoked","text":"<pre><code>inline bool is_revoked() const\n</code></pre> <p>Tests whether revoke has been called on this SpinGrant. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-revoke","title":"function revoke","text":"<pre><code>inline void revoke()\n</code></pre> <p>Permanently invalidates this SpinGrant, waking all waiters with error status. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-size","title":"function size","text":"<pre><code>inline u64 size() const\n</code></pre> <p>The current count available for spending on this SpinGrant. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-spend","title":"function spend","text":"<pre><code>inline StatusOr&lt; SpinGrant &gt; spend(\nu64 count,\nWaitForResource wait_for_resource =WaitForResource::kFalse\n)\n</code></pre> <p>Spends part of the grant, returning a new SpinGrant representing the spent amount if successful; otherwise: </p> <ul> <li><code>batt::StatusCode::kGrantUnavailable</code> if the remaining size of this grant isn't big enough</li> <li><code>batt::StatusCode::kGrantRevoked</code> if this SpinGrant has been revoked</li> <li><code>batt::StatusCode::kFailedPrecondition</code> if this SpinGrant has been invalidated by a move </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-spend_all","title":"function spend_all","text":"<pre><code>inline u64 spend_all()\n</code></pre> <p>Spends all of the grant, returning the previous size. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-subsume","title":"function subsume","text":"<pre><code>inline SpinGrant &amp; subsume(\nSpinGrant &amp;&amp; that\n)\n</code></pre> <p>Increases this grant by that.size() and set that to empty. </p> <p>Will panic unless all of the following are true:</p> <ul> <li>this-&gt;get_issuer() != nullptr</li> <li>this-&gt;get_issuer() == that.get_issuer() </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant/#function-swap","title":"function swap","text":"<pre><code>inline void swap(\nSpinGrant &amp; that\n)\n</code></pre> <p>Swaps the values of this and that. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/","title":"batt::SpinGrant::Issuer","text":"<p>A pool from which SpinGrant instances are allocated.  More...</p> <p><code>#include &lt;batteries/async/spin_grant_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#public-functions","title":"Public Functions","text":"Name Issuer() =defaultConstructs an empty pool. Issuer(u64 initial_count)Constructs a pool with the given initial size. Issuer(const Issuer &amp; ) =deletedSpinGrant::Issuer is not copy-construcible. Issuer &amp; operator=(const Issuer &amp; ) =deletedSpinGrant::Issuer is not copy-assignable. ~Issuer()Destroys the pool. StatusOr&lt; SpinGrant &gt; issue_grant(u64 count, WaitForResource wait_for_resource)Allocate a portion of the pool to create a new SpinGrant. void grow(u64 count)Increase the pool size by the specified amount. void close()Shut down the pool, denying all future issue_grant requests. u64 available() constThe current count available for allocation via issue_grant. u64 total_size() constThe total count ever added to this pool (initial_count + grow(...))."},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#friends","title":"Friends","text":"Name class SpinGrant"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::SpinGrant::Issuer;\n</code></pre> <p>A pool from which SpinGrant instances are allocated. </p> <p>See: SpinGrant</p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-issuer","title":"function Issuer","text":"<pre><code>Issuer() =default\n</code></pre> <p>Constructs an empty pool. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-issuer_1","title":"function Issuer","text":"<pre><code>inline explicit Issuer(\nu64 initial_count\n)\n</code></pre> <p>Constructs a pool with the given initial size. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-issuer_2","title":"function Issuer","text":"<pre><code>Issuer(\nconst Issuer &amp; ) =deleted\n</code></pre> <p>SpinGrant::Issuer is not copy-construcible. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-operator","title":"function operator=","text":"<pre><code>Issuer &amp; operator=(\nconst Issuer &amp; ) =deleted\n</code></pre> <p>SpinGrant::Issuer is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-issuer_3","title":"function ~Issuer","text":"<pre><code>inline ~Issuer()\n</code></pre> <p>Destroys the pool. </p> <p>All SpinGrant instances issued from this object MUST be released prior to destroying the SpinGrant::Issuer, or the program will panic. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-issue_grant","title":"function issue_grant","text":"<pre><code>inline StatusOr&lt; SpinGrant &gt; issue_grant(\nu64 count,\nWaitForResource wait_for_resource\n)\n</code></pre> <p>Allocate a portion of the pool to create a new SpinGrant. </p> <p>Return: The newly allocated SpinGrant if successful; <code>batt::StatusCode::kGrantUnavailable</code> if <code>wait_for_resource</code> is false and there is not enought count in the pool to satisfy the request. </p> <p>This function may block or not depending on the value of <code>wait_for_resource</code>.</p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-grow","title":"function grow","text":"<pre><code>inline void grow(\nu64 count\n)\n</code></pre> <p>Increase the pool size by the specified amount. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-close","title":"function close","text":"<pre><code>inline void close()\n</code></pre> <p>Shut down the pool, denying all future issue_grant requests. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-available","title":"function available","text":"<pre><code>inline u64 available() const\n</code></pre> <p>The current count available for allocation via issue_grant. </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#function-total_size","title":"function total_size","text":"<pre><code>inline u64 total_size() const\n</code></pre> <p>The total count ever added to this pool (initial_count + grow(...)). </p>"},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1SpinGrant_1_1Issuer/#friend-spingrant","title":"friend SpinGrant","text":"<pre><code>friend class SpinGrant(\nSpinGrant );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/","title":"batt::SslTransport","text":"<p>An SSL/TLS based transport for HTTPS clients.  <code>#include &lt;batteries/http/ssl_transport.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#public-functions","title":"Public Functions","text":"Name SslTransport(HttpClientHostContext &amp; host_context)Construct a new SslTransport. boost::asio::ip::tcp::endpoint local_endpoint(ErrorCode &amp; ec) constReturns the bound address of the local end of the underlying TCP socket, if connected; otherwise returns an undefined value and sets <code>ec</code> to an error code. boost::asio::ip::tcp::endpoint remote_endpoint(ErrorCode &amp; ec) constReturns the bound address of the remote peer end of the underlying TCP socket, if connected; otherwise returns an undefined value and sets <code>ec</code> to an error code. bool is_open() constReturns true iff the socket is connected and SSL shutdown has not been initiated. void close(ErrorCode &amp; ec)Shuts down the SSL stream (gracefully), then closes the socket. void shutdown(boost::asio::socket_base::shutdown_type mode, ErrorCode &amp; ec)Shuts down the socket in one or both directions. template &lt;typename Handler &gt; void async_connect(const boost::asio::ip::tcp::endpoint &amp; ep, Handler &amp;&amp; handler)Initiates an asynchronous connection and SSL handshake. template &lt;typename MutableBufferSequence ,typename Handler &gt; void async_read_some(MutableBufferSequence &amp;&amp; buffers, Handler &amp;&amp; handler)Initiates an asynchronous read from the stream. template &lt;typename ConstBufferSequence ,typename Handler &gt; void async_write_some(ConstBufferSequence &amp;&amp; buffers, Handler &amp;&amp; handler)Initiates an asynchronous write to the stream."},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-ssltransport","title":"function SslTransport","text":"<pre><code>explicit SslTransport(\nHttpClientHostContext &amp; host_context\n)\n</code></pre> <p>Construct a new SslTransport. </p> <p>The SSL init fn from the passed <code>host_context</code> is used to instantiate and configure the <code>boost::asio::ssl::context</code> that will be used. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-local_endpoint","title":"function local_endpoint","text":"<pre><code>boost::asio::ip::tcp::endpoint local_endpoint(\nErrorCode &amp; ec\n) const\n</code></pre> <p>Returns the bound address of the local end of the underlying TCP socket, if connected; otherwise returns an undefined value and sets <code>ec</code> to an error code. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-remote_endpoint","title":"function remote_endpoint","text":"<pre><code>boost::asio::ip::tcp::endpoint remote_endpoint(\nErrorCode &amp; ec\n) const\n</code></pre> <p>Returns the bound address of the remote peer end of the underlying TCP socket, if connected; otherwise returns an undefined value and sets <code>ec</code> to an error code. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-is_open","title":"function is_open","text":"<pre><code>bool is_open() const\n</code></pre> <p>Returns true iff the socket is connected and SSL shutdown has not been initiated. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-close","title":"function close","text":"<pre><code>void close(\nErrorCode &amp; ec\n)\n</code></pre> <p>Shuts down the SSL stream (gracefully), then closes the socket. </p> <p><code>this-&gt;[is_open()](/_autogen/Classes/classbatt_1_1SslTransport/#function-is-open)</code> will return false immediately upon entering <code>close</code>, even if the SSL protocol shutdown is still running. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-shutdown","title":"function shutdown","text":"<pre><code>void shutdown(\nboost::asio::socket_base::shutdown_type mode,\nErrorCode &amp; ec\n)\n</code></pre> <p>Shuts down the socket in one or both directions. </p> <p>Does not perform SSL protocol shutdown, as this is bi-directional. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-async_connect","title":"function async_connect","text":"<pre><code>template &lt;typename Handler &gt;\ninline void async_connect(\nconst boost::asio::ip::tcp::endpoint &amp; ep,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Initiates an asynchronous connection and SSL handshake. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-async_read_some","title":"function async_read_some","text":"<pre><code>template &lt;typename MutableBufferSequence ,\ntypename Handler &gt;\ninline void async_read_some(\nMutableBufferSequence &amp;&amp; buffers,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Initiates an asynchronous read from the stream. </p>"},{"location":"_autogen/Classes/classbatt_1_1SslTransport/#function-async_write_some","title":"function async_write_some","text":"<pre><code>template &lt;typename ConstBufferSequence ,\ntypename Handler &gt;\ninline void async_write_some(\nConstBufferSequence &amp;&amp; buffers,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Initiates an asynchronous write to the stream. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/","title":"batt::StackAllocator","text":""},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#public-functions","title":"Public Functions","text":"Name StackAllocator() StackAllocator(const StackAllocator &amp; ) =default StackAllocator &amp; operator=(const StackAllocator &amp; ) =default template &lt;typename T ,typename  =EnableIfNoShadow&gt;  StackAllocator(T &amp;&amp; obj) boost::context::stack_context allocate() const void deallocate(boost::context::stack_context &amp; ctx) const"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-stackallocator","title":"function StackAllocator","text":"<pre><code>inline StackAllocator()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-stackallocator_1","title":"function StackAllocator","text":"<pre><code>StackAllocator(\nconst StackAllocator &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-operator","title":"function operator=","text":"<pre><code>StackAllocator &amp; operator=(\nconst StackAllocator &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-stackallocator_2","title":"function StackAllocator","text":"<pre><code>template &lt;typename T ,\ntypename  =EnableIfNoShadow&lt;StackAllocator, T&amp;&amp;&gt;&gt;\ninline explicit StackAllocator(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-allocate","title":"function allocate","text":"<pre><code>inline boost::context::stack_context allocate() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocator/#function-deallocate","title":"function deallocate","text":"<pre><code>inline void deallocate(\nboost::context::stack_context &amp; ctx\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/","title":"batt::StackAllocatorImpl","text":"<p>More...</p> <p>Inherits from batt::AbstractValueImpl&lt; AbstractStackAllocator, StackAllocatorImpl, T &gt;, AbstractType</p>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#public-types","title":"Public Types","text":"Name using AbstractValueImpl&lt; AbstractStackAllocator, StackAllocatorImpl, T &gt; Super"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args,typename  =EnableIfNoShadow&gt;  StackAllocatorImpl(Args &amp;&amp;... args) virtual boost::context::stack_context allocate() override virtual void deallocate(boost::context::stack_context &amp; ctx) override"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::AbstractValueImpl&lt; AbstractStackAllocator, StackAllocatorImpl, T &gt;</p> Name AbstractValueImpl(T &amp;&amp; obj) AbstractType * copy_to(MutableBuffer memory) const override AbstractType * move_to(MutableBuffer memory) override <p>Protected Attributes inherited from batt::AbstractValueImpl&lt; AbstractStackAllocator, StackAllocatorImpl, T &gt;</p> Name T obj_"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::StackAllocatorImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#using-super","title":"using Super","text":"<pre><code>using batt::StackAllocatorImpl&lt; T &gt;::Super =  AbstractValueImpl&lt;AbstractStackAllocator, StackAllocatorImpl, T&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#function-stackallocatorimpl","title":"function StackAllocatorImpl","text":"<pre><code>template &lt;typename... Args,\ntypename  =EnableIfNoShadow&lt;StackAllocatorImpl, Args&amp;&amp;...&gt;&gt;\ninline explicit StackAllocatorImpl(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#function-allocate","title":"function allocate","text":"<pre><code>inline virtual boost::context::stack_context allocate() override\n</code></pre> <p>Reimplements: batt::AbstractStackAllocator::allocate</p>"},{"location":"_autogen/Classes/classbatt_1_1StackAllocatorImpl/#function-deallocate","title":"function deallocate","text":"<pre><code>inline virtual void deallocate(\nboost::context::stack_context &amp; ctx\n) override\n</code></pre> <p>Reimplements: batt::AbstractStackAllocator::deallocate</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/","title":"batt::StateMachineModel","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-types","title":"Public Types","text":"Name enum VisitResult { kFirstTime, kSeenBefore} using StateT state_type using StateHash state_hash_type using StateEqual state_equal_type using StateMachineModel Base using StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; Branch using StateMachineResult Result using StateMachineModelCheckAdvancedOptions AdvancedOptions"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-functions","title":"Public Functions","text":"Name StateMachineModel(const StateMachineModel &amp; ) =deleted StateMachineModel &amp; operator=(const StateMachineModel &amp; ) =deleted virtual ~StateMachineModel() =default StateMachineModel() =default template &lt;typename Checker  =ExhaustiveModelChecker&gt; Result check_model(StaticType&lt; Checker &gt;  ={}) bool state_visited(const state_type &amp; s) const void set_entropy(StateMachineEntropySource &amp;&amp; entropy_source) void reset_visited_states() VisitResult visit(const StateT &amp; state, const Branch &amp; src_branch) virtual state_type initialize() =0 virtual void enter_state(const state_type &amp; ) =0 virtual void step() =0 virtual state_type leave_state() =0 virtual bool check_invariants() =0 virtual bool check_stepwise_invariants() virtual state_type normalize(const state_type &amp; s) virtual double progress_report_interval_seconds() const virtual void report_progress(const Result &amp; ) virtual usize max_concurrency() const virtual std::unique_ptr&lt; StateMachineModel &gt; clone() const virtual AdvancedOptions advanced_options() const usize pick_int(usize min_value, usize max_value) bool pick_branch() template &lt;typename T &gt; T pick_one_of(std::initializer_list&lt; T &gt; values) bool run_one(FakeExecutionContext &amp; context) template &lt;typename... Fn&gt; void do_one_of(Fn &amp;&amp;... actions) StateMachineEntropySource entropy() template &lt;typename Checker &gt; auto check_model(StaticType&lt; Checker &gt; )"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-attributes","title":"Public Attributes","text":"Name std::shared_ptr&lt; std::ostringstream &gt; debug_out"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename StateT ,\ntypename StateHash  =std::hash&lt;StateT&gt;,\ntypename StateEqual  =std::equal_to&lt;StateT&gt;&gt;\nclass batt::StateMachineModel;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#enum-visitresult","title":"enum VisitResult","text":"Enumerator Value Description kFirstTime kSeenBefore"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-state_type","title":"using state_type","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::state_type =  StateT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-state_hash_type","title":"using state_hash_type","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::state_hash_type =  StateHash;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-state_equal_type","title":"using state_equal_type","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::state_equal_type =  StateEqual;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-base","title":"using Base","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::Base =  StateMachineModel;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-branch","title":"using Branch","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::Branch =  StateMachineBranch&lt;StateT, StateHash, StateEqual&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-result","title":"using Result","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::Result =  StateMachineResult;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#using-advancedoptions","title":"using AdvancedOptions","text":"<pre><code>using batt::StateMachineModel&lt; StateT, StateHash, StateEqual &gt;::AdvancedOptions =  StateMachineModelCheckAdvancedOptions;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-statemachinemodel","title":"function StateMachineModel","text":"<pre><code>StateMachineModel(\nconst StateMachineModel &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-operator","title":"function operator=","text":"<pre><code>StateMachineModel &amp; operator=(\nconst StateMachineModel &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-statemachinemodel_1","title":"function ~StateMachineModel","text":"<pre><code>virtual ~StateMachineModel() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-statemachinemodel_2","title":"function StateMachineModel","text":"<pre><code>StateMachineModel() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_model","title":"function check_model","text":"<pre><code>template &lt;typename Checker  =ExhaustiveModelChecker&lt;StateMachineModel&gt;&gt;\nResult check_model(\nStaticType&lt; Checker &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-state_visited","title":"function state_visited","text":"<pre><code>inline bool state_visited(\nconst state_type &amp; s\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-set_entropy","title":"function set_entropy","text":"<pre><code>inline void set_entropy(\nStateMachineEntropySource &amp;&amp; entropy_source\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-reset_visited_states","title":"function reset_visited_states","text":"<pre><code>inline void reset_visited_states()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-visit","title":"function visit","text":"<pre><code>inline VisitResult visit(\nconst StateT &amp; state,\nconst Branch &amp; src_branch\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-initialize","title":"function initialize","text":"<pre><code>virtual state_type initialize() =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-enter_state","title":"function enter_state","text":"<pre><code>virtual void enter_state(\nconst state_type &amp; ) =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-step","title":"function step","text":"<pre><code>virtual void step() =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-leave_state","title":"function leave_state","text":"<pre><code>virtual state_type leave_state() =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_invariants","title":"function check_invariants","text":"<pre><code>virtual bool check_invariants() =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_stepwise_invariants","title":"function check_stepwise_invariants","text":"<pre><code>inline virtual bool check_stepwise_invariants()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-normalize","title":"function normalize","text":"<pre><code>inline virtual state_type normalize(\nconst state_type &amp; s\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-progress_report_interval_seconds","title":"function progress_report_interval_seconds","text":"<pre><code>inline virtual double progress_report_interval_seconds() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-report_progress","title":"function report_progress","text":"<pre><code>inline virtual void report_progress(\nconst Result &amp; )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-max_concurrency","title":"function max_concurrency","text":"<pre><code>inline virtual usize max_concurrency() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-clone","title":"function clone","text":"<pre><code>inline virtual std::unique_ptr&lt; StateMachineModel &gt; clone() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-advanced_options","title":"function advanced_options","text":"<pre><code>inline virtual AdvancedOptions advanced_options() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-pick_int","title":"function pick_int","text":"<pre><code>inline usize pick_int(\nusize min_value,\nusize max_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-pick_branch","title":"function pick_branch","text":"<pre><code>inline bool pick_branch()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-pick_one_of","title":"function pick_one_of","text":"<pre><code>template &lt;typename T &gt;\ninline T pick_one_of(\nstd::initializer_list&lt; T &gt; values\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-run_one","title":"function run_one","text":"<pre><code>inline bool run_one(\nFakeExecutionContext &amp; context\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-do_one_of","title":"function do_one_of","text":"<pre><code>template &lt;typename... Fn&gt;\ninline void do_one_of(\nFn &amp;&amp;... actions\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-entropy","title":"function entropy","text":"<pre><code>inline StateMachineEntropySource entropy()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#function-check_model_1","title":"function check_model","text":"<pre><code>template &lt;typename Checker &gt;\nauto check_model(\nStaticType&lt; Checker &gt; )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StateMachineModel/#variable-debug_out","title":"variable debug_out","text":"<pre><code>std::shared_ptr&lt; std::ostringstream &gt; debug_out = std::make_shared&lt;std::ostringstream&gt;();\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/","title":"batt::StaticTypeMap","text":"<p>Stores a fixed-size set of Value objects, indexed by a set of bounded types (keys).  More...</p> <p><code>#include &lt;batteries/tuples.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#public-types","title":"Public Types","text":"Name using StaticTypeMap Self using std::array&lt; Value, Self::size()&gt; ValueArray using typename ValueArray::iterator iterator using typename ValueArray::const_iterator const_iterator"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#public-functions","title":"Public Functions","text":"Name constexpr usize size()Returns the number of items in the map. StaticTypeMap()Constructs a new StaticTypeMap, value-initializing all items to Value{}. StaticTypeMap(const StaticTypeMap &amp; ) =defaultCopy-constructs a StaticTypeMap instance. StaticTypeMap &amp; operator=(const StaticTypeMap &amp; ) =defaultCopy-assigns a StaticTypeMap instance. template &lt;typename KeyT &gt; Value &amp; get(] StaticType&lt; KeyT &gt; key ={})Returns a (non-const) reference to the value for the given key. template &lt;typename KeyT &gt; const Value &amp; get(] StaticType&lt; KeyT &gt; key ={}) constReturns a (const) reference to the value for the given key. template &lt;typename KeyT &gt; Value &amp; operator[](StaticType&lt; KeyT &gt; key)Returns a (non-const) reference to the value for the given key. template &lt;typename KeyT &gt; const Value &amp; operator[](StaticType&lt; KeyT &gt; key) constReturns a (const) reference to the value for the given key. iterator begin()Returns an iterator to the first value in the map. iterator end()Returns an iterator to one past the last value in the map. const_iterator begin() constReturns an iterator (const) to the first value in the map. const_iterator end() constReturns an iterator (const) to one past the last value in the map."},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename KeyTupleT ,\ntypename Value &gt;\nclass batt::StaticTypeMap;\n</code></pre> <p>Stores a fixed-size set of Value objects, indexed by a set of bounded types (keys). </p> <p>Example:</p> <pre><code> {c++}\nbatt::StaticTypeMap&lt;std::tuple&lt;char, int, bool&gt;, std::string&gt; m;\nm[batt::StaticType&lt;char&gt;{}] = \"char\";\nm[batt::StaticType&lt;int&gt;{}] = \"int\";\nm[batt::StaticType&lt;bool&gt;{}] = \"bool\";\n</code></pre> <p>When used as a range, only the values are iterated. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#using-self","title":"using Self","text":"<pre><code>using batt::StaticTypeMap&lt; KeyTupleT, Value &gt;::Self =  StaticTypeMap;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#using-valuearray","title":"using ValueArray","text":"<pre><code>using batt::StaticTypeMap&lt; KeyTupleT, Value &gt;::ValueArray =  std::array&lt;Value, Self::size()&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#using-iterator","title":"using iterator","text":"<pre><code>using batt::StaticTypeMap&lt; KeyTupleT, Value &gt;::iterator =  typename ValueArray::iterator;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#using-const_iterator","title":"using const_iterator","text":"<pre><code>using batt::StaticTypeMap&lt; KeyTupleT, Value &gt;::const_iterator =  typename ValueArray::const_iterator;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-size","title":"function size","text":"<pre><code>static inline constexpr usize size()\n</code></pre> <p>Returns the number of items in the map. </p> <p>This is the same as the number of elements of the KeyTupleT used to instantiate this class template. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-statictypemap","title":"function StaticTypeMap","text":"<pre><code>inline StaticTypeMap()\n</code></pre> <p>Constructs a new StaticTypeMap, value-initializing all items to Value{}. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-statictypemap_1","title":"function StaticTypeMap","text":"<pre><code>StaticTypeMap(\nconst StaticTypeMap &amp; ) =default\n</code></pre> <p>Copy-constructs a StaticTypeMap instance. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-operator","title":"function operator=","text":"<pre><code>StaticTypeMap &amp; operator=(\nconst StaticTypeMap &amp; ) =default\n</code></pre> <p>Copy-assigns a StaticTypeMap instance. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-get","title":"function get","text":"<pre><code>template &lt;typename KeyT &gt;\ninline Value &amp; get(\n] StaticType&lt; KeyT &gt; key ={}\n)\n</code></pre> <p>Returns a (non-const) reference to the value for the given key. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-get_1","title":"function get","text":"<pre><code>template &lt;typename KeyT &gt;\ninline const Value &amp; get(\n] StaticType&lt; KeyT &gt; key ={}\n) const\n</code></pre> <p>Returns a (const) reference to the value for the given key. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-operator_1","title":"function operator[]","text":"<pre><code>template &lt;typename KeyT &gt;\ninline Value &amp; operator[](\nStaticType&lt; KeyT &gt; key\n)\n</code></pre> <p>Returns a (non-const) reference to the value for the given key. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-operator_2","title":"function operator[]","text":"<pre><code>template &lt;typename KeyT &gt;\ninline const Value &amp; operator[](\nStaticType&lt; KeyT &gt; key\n) const\n</code></pre> <p>Returns a (const) reference to the value for the given key. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-begin","title":"function begin","text":"<pre><code>inline iterator begin()\n</code></pre> <p>Returns an iterator to the first value in the map. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-end","title":"function end","text":"<pre><code>inline iterator end()\n</code></pre> <p>Returns an iterator to one past the last value in the map. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-begin_1","title":"function begin","text":"<pre><code>inline const_iterator begin() const\n</code></pre> <p>Returns an iterator (const) to the first value in the map. </p>"},{"location":"_autogen/Classes/classbatt_1_1StaticTypeMap/#function-end_1","title":"function end","text":"<pre><code>inline const_iterator end() const\n</code></pre> <p>Returns an iterator (const) to one past the last value in the map. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/","title":"batt::StatsMetric","text":"<p>Collect count, total, max and min values for multiple samples.  More...</p> <p><code>#include &lt;batteries/metrics/metric_collectors.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#public-functions","title":"Public Functions","text":"Name StatsMetric() =defaultInitialize empty metric. StatsMetric(T init_val)Initialize non-empty metric. void reset()Reset metric to empty state. template &lt;typename D &gt; void update(D sample)Update count, total, min and max values for a given sample. T count() const T total() const T max() const T min() const"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#friends","title":"Friends","text":"Name class MetricRegistry"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::StatsMetric;\n</code></pre> <p>Collect count, total, max and min values for multiple samples. </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-statsmetric","title":"function StatsMetric","text":"<pre><code>StatsMetric() =default\n</code></pre> <p>Initialize empty metric. </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-statsmetric_1","title":"function StatsMetric","text":"<pre><code>inline explicit StatsMetric(\nT init_val\n)\n</code></pre> <p>Initialize non-empty metric. </p> <p>Parameters: </p> <ul> <li>Initial value </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre> <p>Reset metric to empty state. </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-update","title":"function update","text":"<pre><code>template &lt;typename D &gt;\ninline void update(\nD sample\n)\n</code></pre> <p>Update count, total, min and max values for a given sample. </p> <p>Parameters: </p> <ul> <li>Sample value </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-count","title":"function count","text":"<pre><code>inline T count() const\n</code></pre> <p>Return: Number of samples </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-total","title":"function total","text":"<pre><code>inline T total() const\n</code></pre> <p>Return: Sum of samples </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-max","title":"function max","text":"<pre><code>inline T max() const\n</code></pre> <p>Return: Max sample </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#function-min","title":"function min","text":"<pre><code>inline T min() const\n</code></pre> <p>Return: Min sample </p>"},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1StatsMetric/#friend-metricregistry","title":"friend MetricRegistry","text":"<pre><code>friend class MetricRegistry(\nMetricRegistry );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Status/","title":"batt::Status","text":"<p>Inherits from batt::detail::StatusBase</p> <p>Inherited by batt::StatusOr&lt; Status &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-classes","title":"Public Classes","text":"Name struct CodeEntry struct CodeGroup struct ForceLookup Sentinel type passed to Status constructor to force the passed code enum value to be treated as a non-error_code type."},{"location":"_autogen/Classes/classbatt_1_1Status/#public-types","title":"Public Types","text":"Name using i32 value_type"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-functions","title":"Public Functions","text":"Name template &lt;typename EnumT &gt; const CodeGroup &amp; code_group_for_type() const std::string &amp; unknown_enum_value_message() template &lt;typename EnumT &gt; bool register_codes(const std::vector&lt; std::pair&lt; EnumT, std::string &gt;&gt; &amp; codes) const CodeEntry &amp; get_entry_from_code(value_type value) std::string_view message_from_code(value_type value) usize get_index_of_group(value_type value) usize get_index_within_group(value_type value) Status() Status(const Status &amp; ) =default Status &amp; operator=(const Status &amp; ) =default template &lt;typename EnumT &gt;  Status(ForceLookup , EnumT enum_value) template &lt;typename EnumT ,typename  =std::enable_if_t&gt;&gt;  Status(EnumT enum_value) template &lt;typename EnumT ,typename  =std::enable_if_t::value&gt;,typename  =void&gt;  Status(EnumT enum_value) template &lt;typename EnumT ,typename  =std::enable_if_t::value&gt;,typename  =void,typename  =void&gt;  Status(EnumT enum_value) Status(const StatusOr&lt; NoneType &gt; &amp; status_or) Status &amp; operator=(const StatusOr&lt; NoneType &gt; &amp; status_or) bool ok() const value_type code() const value_type code_index_within_group() const const CodeEntry &amp; code_entry() const std::string_view message() const const CodeGroup &amp; group() const value_type group_index() const void IgnoreError() const void Update(const Status &amp; new_status)"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-attributes","title":"Public Attributes","text":"Name constexpr i32 kGroupSizeBits constexpr i32 kGroupSize constexpr i32 kMaxGroups"},{"location":"_autogen/Classes/classbatt_1_1Status/#friends","title":"Friends","text":"Name class detail::StatusBase"},{"location":"_autogen/Classes/classbatt_1_1Status/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::detail::StatusBase</p> Name StatusBase()"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Status/#using-value_type","title":"using value_type","text":"<pre><code>using batt::Status::value_type =  i32;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Status/#function-code_group_for_type","title":"function code_group_for_type","text":"<pre><code>template &lt;typename EnumT &gt;\nstatic inline const CodeGroup &amp; code_group_for_type()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-unknown_enum_value_message","title":"function unknown_enum_value_message","text":"<pre><code>static inline const std::string &amp; unknown_enum_value_message()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-register_codes","title":"function register_codes","text":"<pre><code>template &lt;typename EnumT &gt;\nstatic inline bool register_codes(\nconst std::vector&lt; std::pair&lt; EnumT, std::string &gt;&gt; &amp; codes\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-get_entry_from_code","title":"function get_entry_from_code","text":"<pre><code>static inline const CodeEntry &amp; get_entry_from_code(\nvalue_type value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-message_from_code","title":"function message_from_code","text":"<pre><code>static inline std::string_view message_from_code(\nvalue_type value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-get_index_of_group","title":"function get_index_of_group","text":"<pre><code>static inline usize get_index_of_group(\nvalue_type value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-get_index_within_group","title":"function get_index_within_group","text":"<pre><code>static inline usize get_index_within_group(\nvalue_type value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status","title":"function Status","text":"<pre><code>inline Status()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_1","title":"function Status","text":"<pre><code>Status(\nconst Status &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-operator","title":"function operator=","text":"<pre><code>Status &amp; operator=(\nconst Status &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_2","title":"function Status","text":"<pre><code>template &lt;typename EnumT &gt;\ninline Status(\nForceLookup ,\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_3","title":"function Status","text":"<pre><code>template &lt;typename EnumT ,\ntypename  =std::enable_if_t&lt;IsStatusEnum&lt;EnumT&gt;&gt;&gt;\ninline Status(\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_4","title":"function Status","text":"<pre><code>template &lt;typename EnumT ,\ntypename  =std::enable_if_t&lt;boost::system::is_error_code_enum&lt;EnumT&gt;::value&gt;,\ntypename  =void&gt;\ninline Status(\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_5","title":"function Status","text":"<pre><code>template &lt;typename EnumT ,\ntypename  =std::enable_if_t&lt;std::is_error_code_enum&lt;EnumT&gt;::value&gt;,\ntypename  =void,\ntypename  =void&gt;\ninline Status(\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-status_6","title":"function Status","text":"<pre><code>inline Status(\nconst StatusOr&lt; NoneType &gt; &amp; status_or\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-operator_1","title":"function operator=","text":"<pre><code>inline Status &amp; operator=(\nconst StatusOr&lt; NoneType &gt; &amp; status_or\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-ok","title":"function ok","text":"<pre><code>inline bool ok() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-code","title":"function code","text":"<pre><code>inline value_type code() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-code_index_within_group","title":"function code_index_within_group","text":"<pre><code>inline value_type code_index_within_group() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-code_entry","title":"function code_entry","text":"<pre><code>inline const CodeEntry &amp; code_entry() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-message","title":"function message","text":"<pre><code>inline std::string_view message() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-group","title":"function group","text":"<pre><code>inline const CodeGroup &amp; group() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-group_index","title":"function group_index","text":"<pre><code>inline value_type group_index() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-ignoreerror","title":"function IgnoreError","text":"<pre><code>inline void IgnoreError() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#function-update","title":"function Update","text":"<pre><code>inline void Update(\nconst Status &amp; new_status\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Status/#variable-kgroupsizebits","title":"variable kGroupSizeBits","text":"<pre><code>static constexpr i32 kGroupSizeBits = 12;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#variable-kgroupsize","title":"variable kGroupSize","text":"<pre><code>static constexpr i32 kGroupSize = i32{1} &lt;&lt; kGroupSizeBits;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#variable-kmaxgroups","title":"variable kMaxGroups","text":"<pre><code>static constexpr i32 kMaxGroups = 0x7fffff00l - kGroupSize;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Status/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1Status/#friend-detailstatusbase","title":"friend detail::StatusBase","text":"<pre><code>friend class detail::StatusBase(\ndetail::StatusBase );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/","title":"batt::StatusOr","text":"<p>More...</p> <p>Inherited by batt::StatusOr&lt; StatusOr&lt; T &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-types","title":"Public Types","text":"Name using T value_type"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-functions","title":"Public Functions","text":"Name StatusOr() StatusOr(const Status &amp; s) StatusOr(StatusOr &amp;&amp; that) StatusOr(const StatusOr &amp; that) StatusOr(const std::decay_t&lt; T &gt; &amp; obj) StatusOr(std::decay_t&lt; T &gt; &amp; obj) StatusOr(std::decay_t&lt; T &gt; &amp;&amp; obj) template &lt;typename U ,typename  =EnableIfNoShadow,typename  =std::enable_if_t&lt;!std::is_same_v, T&gt; &amp;&amp; std::is_constructible_v&gt;,typename  =void&gt;  StatusOr(U &amp;&amp; obj) template &lt;typename U ,typename  =std::enable_if_t&lt;!std::is_same_v, T&gt; &amp;&amp;                                                      std::is_constructible_v&gt;&gt;  StatusOr(StatusOr&lt; U &gt; &amp;&amp; that) template &lt;typename U ,typename  =std::enable_if_t&lt;!std::is_same_v, T&gt; &amp;&amp;                                                      std::is_constructible_v&gt;&gt;  StatusOr(const StatusOr&lt; U &gt; &amp; that) ~StatusOr() StatusOr &amp; operator=(std::decay_t&lt; T &gt; &amp;&amp; obj) StatusOr &amp; operator=(const T &amp; obj) template &lt;typename U ,typename  =std::enable_if_t&lt;!std::is_same_v, T&gt; &amp;&amp;                                                      std::is_constructible_v&gt;&gt; StatusOr &amp; operator=(U &amp;&amp; obj) StatusOr &amp; operator=(const StatusOr &amp; that) StatusOr &amp; operator=(StatusOr &amp;&amp; that) StatusOr &amp; operator=(const Status &amp; new_status) template &lt;typename... Args&gt; void emplace(Args &amp;&amp;... args) template &lt;typename U &gt; void emplace(StatusOr&lt; U &gt; &amp;&amp; that) template &lt;typename U &gt; void emplace(const StatusOr&lt; U &gt; &amp; that) void IgnoreError() const bool ok() const const Status &amp; status() const T &amp; value() const T &amp; value() const T &amp; operator*() const T &amp; operator*() const T operator*() std::add_const_t&lt; std::remove_reference_t&lt; T &gt; &gt; * operator-&gt;() const std::remove_reference_t&lt; T &gt; * operator-&gt;()"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#friends","title":"Friends","text":"Name class StatusOr"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::StatusOr;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#using-value_type","title":"using value_type","text":"<pre><code>using batt::StatusOr&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor","title":"function StatusOr","text":"<pre><code>inline explicit StatusOr()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_1","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nconst Status &amp; s\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_2","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nStatusOr &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_3","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nconst StatusOr &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_4","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nconst std::decay_t&lt; T &gt; &amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_5","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nstd::decay_t&lt; T &gt; &amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_6","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nstd::decay_t&lt; T &gt; &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_7","title":"function StatusOr","text":"<pre><code>template &lt;typename U ,\ntypename  =EnableIfNoShadow&lt;StatusOr, U&amp;&amp;&gt;,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp; std::is_constructible_v&lt;T, U&amp;&amp;&gt;&gt;,\ntypename  =void&gt;\ninline StatusOr(\nU &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_8","title":"function StatusOr","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp;                                                      std::is_constructible_v&lt;T, U&amp;&amp;&gt;&gt;&gt;\ninline StatusOr(\nStatusOr&lt; U &gt; &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_9","title":"function StatusOr","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp;                                                      std::is_constructible_v&lt;T, const U&amp;&gt;&gt;&gt;\ninline StatusOr(\nconst StatusOr&lt; U &gt; &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-statusor_10","title":"function ~StatusOr","text":"<pre><code>inline ~StatusOr()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator","title":"function operator=","text":"<pre><code>inline StatusOr &amp; operator=(\nstd::decay_t&lt; T &gt; &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_1","title":"function operator=","text":"<pre><code>inline StatusOr &amp; operator=(\nconst T &amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_2","title":"function operator=","text":"<pre><code>template &lt;typename U ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp;                                                      std::is_constructible_v&lt;T, U&amp;&amp;&gt;&gt;&gt;\ninline StatusOr &amp; operator=(\nU &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_3","title":"function operator=","text":"<pre><code>inline StatusOr &amp; operator=(\nconst StatusOr &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_4","title":"function operator=","text":"<pre><code>inline StatusOr &amp; operator=(\nStatusOr &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_5","title":"function operator=","text":"<pre><code>inline StatusOr &amp; operator=(\nconst Status &amp; new_status\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-emplace","title":"function emplace","text":"<pre><code>template &lt;typename... Args&gt;\ninline void emplace(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-emplace_1","title":"function emplace","text":"<pre><code>template &lt;typename U &gt;\ninline void emplace(\nStatusOr&lt; U &gt; &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-emplace_2","title":"function emplace","text":"<pre><code>template &lt;typename U &gt;\ninline void emplace(\nconst StatusOr&lt; U &gt; &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-ignoreerror","title":"function IgnoreError","text":"<pre><code>inline void IgnoreError() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-ok","title":"function ok","text":"<pre><code>inline bool ok() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-status","title":"function status","text":"<pre><code>inline const Status &amp; status() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-value","title":"function value","text":"<pre><code>inline T &amp; value()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-value_1","title":"function value","text":"<pre><code>inline const T &amp; value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_6","title":"function operator*","text":"<pre><code>inline T &amp; operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_7","title":"function operator*","text":"<pre><code>inline const T &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator_8","title":"function operator*","text":"<pre><code>inline T operator*()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline std::add_const_t&lt; std::remove_reference_t&lt; T &gt; &gt; * operator-&gt;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#function-operator-_1","title":"function operator-&gt;","text":"<pre><code>inline std::remove_reference_t&lt; T &gt; * operator-&gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1StatusOr/#friend-statusor","title":"friend StatusOr","text":"<pre><code>friend class StatusOr(\nStatusOr );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/","title":"batt::StatusOr&lt; StatusOr&lt; T &gt; &gt;","text":"<p>More...</p> <p>Inherits from batt::StatusOr&lt; T &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#public-functions","title":"Public Functions","text":"Name StatusOr(const StatusOr&lt; T &gt; &amp; status_or) StatusOr(StatusOr&lt; T &gt; &amp;&amp; status_or)"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StatusOr&lt; T &gt;</p> Name using T value_type <p>Public Functions inherited from batt::StatusOr&lt; T &gt;</p> Name ~StatusOr() StatusOr &amp; operator=(std::decay_t&lt; T &gt; &amp;&amp; obj) StatusOr &amp; operator=(const T &amp; obj) template &lt;typename U ,typename  =std::enable_if_t&lt;!std::is_same_v, T&gt; &amp;&amp;                                                      std::is_constructible_v&gt;&gt; StatusOr &amp; operator=(U &amp;&amp; obj) StatusOr &amp; operator=(const StatusOr &amp; that) StatusOr &amp; operator=(StatusOr &amp;&amp; that) StatusOr &amp; operator=(const Status &amp; new_status) template &lt;typename... Args&gt; void emplace(Args &amp;&amp;... args) template &lt;typename U &gt; void emplace(StatusOr&lt; U &gt; &amp;&amp; that) template &lt;typename U &gt; void emplace(const StatusOr&lt; U &gt; &amp; that) void IgnoreError() const bool ok() const const Status &amp; status() const T &amp; value() const T &amp; value() const T &amp; operator*() const T &amp; operator*() const T operator*() std::add_const_t&lt; std::remove_reference_t&lt; T &gt; &gt; * operator-&gt;() const std::remove_reference_t&lt; T &gt; * operator-&gt;()"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::StatusOr&lt; StatusOr&lt; T &gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#function-statusor","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nconst StatusOr&lt; T &gt; &amp; status_or\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01StatusOr_3_01T_01_4_01_4/#function-statusor_1","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nStatusOr&lt; T &gt; &amp;&amp; status_or\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/","title":"batt::StatusOr&lt; Status &gt;","text":"<p>Inherits from batt::Status, batt::detail::StatusBase</p>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#public-functions","title":"Public Functions","text":"Name StatusOr(const Status &amp; status) StatusOr(Status &amp;&amp; status) Status() Status(const Status &amp; ) =default template &lt;typename EnumT &gt;  Status(ForceLookup , EnumT enum_value) template &lt;typename EnumT ,typename  =std::enable_if_t&gt;&gt;  Status(EnumT enum_value) template &lt;typename EnumT ,typename  =std::enable_if_t::value&gt;,typename  =void&gt;  Status(EnumT enum_value) template &lt;typename EnumT ,typename  =std::enable_if_t::value&gt;,typename  =void,typename  =void&gt;  Status(EnumT enum_value) Status(const StatusOr&lt; NoneType &gt; &amp; )"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from batt::Status</p> Name struct CodeEntry struct CodeGroup struct ForceLookup Sentinel type passed to Status constructor to force the passed code enum value to be treated as a non-error_code type. <p>Public Types inherited from batt::Status</p> Name using i32 value_type <p>Public Functions inherited from batt::Status</p> Name template &lt;typename EnumT &gt; const CodeGroup &amp; code_group_for_type() const std::string &amp; unknown_enum_value_message() template &lt;typename EnumT &gt; bool register_codes(const std::vector&lt; std::pair&lt; EnumT, std::string &gt;&gt; &amp; codes) const CodeEntry &amp; get_entry_from_code(value_type value) std::string_view message_from_code(value_type value) usize get_index_of_group(value_type value) usize get_index_within_group(value_type value) Status &amp; operator=(const Status &amp; ) =default Status &amp; operator=(const StatusOr&lt; NoneType &gt; &amp; status_or) bool ok() const value_type code() const value_type code_index_within_group() const const CodeEntry &amp; code_entry() const std::string_view message() const const CodeGroup &amp; group() const value_type group_index() const void IgnoreError() const void Update(const Status &amp; new_status) <p>Public Attributes inherited from batt::Status</p> Name constexpr i32 kGroupSizeBits constexpr i32 kGroupSize constexpr i32 kMaxGroups <p>Friends inherited from batt::Status</p> Name class detail::StatusBase <p>Public Functions inherited from batt::detail::StatusBase</p> Name StatusBase()"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-statusor","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nconst Status &amp; status\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-statusor_1","title":"function StatusOr","text":"<pre><code>inline StatusOr(\nStatus &amp;&amp; status\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status","title":"function Status","text":"<pre><code>inline Status()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_1","title":"function Status","text":"<pre><code>Status(\nconst Status &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_2","title":"function Status","text":"<pre><code>template &lt;typename EnumT &gt;\ninline Status(\nForceLookup ,\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_3","title":"function Status","text":"<pre><code>template &lt;typename EnumT ,\ntypename  =std::enable_if_t&lt;IsStatusEnum&lt;EnumT&gt;&gt;&gt;\ninline Status(\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_4","title":"function Status","text":"<pre><code>template &lt;typename EnumT ,\ntypename  =std::enable_if_t&lt;boost::system::is_error_code_enum&lt;EnumT&gt;::value&gt;,\ntypename  =void&gt;\ninline Status(\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_5","title":"function Status","text":"<pre><code>template &lt;typename EnumT ,\ntypename  =std::enable_if_t&lt;std::is_error_code_enum&lt;EnumT&gt;::value&gt;,\ntypename  =void,\ntypename  =void&gt;\ninline Status(\nEnumT enum_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StatusOr_3_01Status_01_4/#function-status_6","title":"function Status","text":"<pre><code>inline Status(\nconst StatusOr&lt; NoneType &gt; &amp; )\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/","title":"batt::StochasticModelChecker","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-types","title":"Public Types","text":"Name using typename ModelT::Branch Branch using typename Branch::delta_type BranchDelta using typename ModelT::VisitResult VisitResult"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-functions","title":"Public Functions","text":"Name StochasticModelChecker(typename ModelT::Base &amp; model, detail::ParallelModelCheckState&lt; Branch &gt; &amp; mesh, usize shard_i) ~StochasticModelChecker() StateMachineResult run()"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename ModelT &gt;\nclass batt::StochasticModelChecker;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#using-branch","title":"using Branch","text":"<pre><code>using batt::StochasticModelChecker&lt; ModelT &gt;::Branch =  typename ModelT::Branch;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#using-branchdelta","title":"using BranchDelta","text":"<pre><code>using batt::StochasticModelChecker&lt; ModelT &gt;::BranchDelta =  typename Branch::delta_type;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#using-visitresult","title":"using VisitResult","text":"<pre><code>using batt::StochasticModelChecker&lt; ModelT &gt;::VisitResult =  typename ModelT::VisitResult;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#function-stochasticmodelchecker","title":"function StochasticModelChecker","text":"<pre><code>inline explicit StochasticModelChecker(\ntypename ModelT::Base &amp; model,\ndetail::ParallelModelCheckState&lt; Branch &gt; &amp; mesh,\nusize shard_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#function-stochasticmodelchecker_1","title":"function ~StochasticModelChecker","text":"<pre><code>inline ~StochasticModelChecker()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StochasticModelChecker/#function-run","title":"function run","text":"<pre><code>inline StateMachineResult run()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/","title":"batt::StreamBuffer","text":""},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-types","title":"Public Types","text":"Name using boost::asio::any_io_executor executor_type"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-functions","title":"Public Functions","text":"Name StreamBuffer(usize capacity) ~StreamBuffer() usize capacity() const usize size() const usize space() const executor_type get_executor() const StatusOr&lt; SmallVec&lt; MutableBuffer, 2 &gt; &gt; prepare_exactly(i64 exact_count) StatusOr&lt; SmallVec&lt; MutableBuffer, 2 &gt; &gt; prepare_at_least(i64 min_count) template &lt;typename Handler  =void(const ErrorCode&amp; ec, SmallVec)&gt; void async_prepare_at_least(i64 min_count, Handler &amp;&amp; handler) void commit(i64 count) template &lt;typename T &gt; Status write_type(StaticType&lt; T &gt; , const T &amp; value) template &lt;typename ConstBuffers ,typename Handler  =void(const ErrorCode&amp; ec, usize n_bytes_written)&gt; void async_write_some(ConstBuffers &amp;&amp; buffers, Handler &amp;&amp; handler) Status write_all(ConstBuffer buffer) void close_for_write() StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(i64 min_count) void consume(i64 count) template &lt;typename T &gt; StatusOr&lt; std::reference_wrapper&lt; const T &gt; &gt; fetch_type(StaticType&lt; T &gt;  ={}) template &lt;typename T &gt; void consume_type(StaticType&lt; T &gt;  ={}) template &lt;typename T &gt; StatusOr&lt; T &gt; read_type(StaticType&lt; T &gt;  ={}) void close_for_read() void close()"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kTempBufferSize"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#using-executor_type","title":"using executor_type","text":"<pre><code>using batt::StreamBuffer::executor_type =  boost::asio::any_io_executor;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-streambuffer","title":"function StreamBuffer","text":"<pre><code>inline explicit StreamBuffer(\nusize capacity\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-streambuffer_1","title":"function ~StreamBuffer","text":"<pre><code>inline ~StreamBuffer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-capacity","title":"function capacity","text":"<pre><code>inline usize capacity() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-space","title":"function space","text":"<pre><code>inline usize space() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-get_executor","title":"function get_executor","text":"<pre><code>inline executor_type get_executor() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-prepare_exactly","title":"function prepare_exactly","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; MutableBuffer, 2 &gt; &gt; prepare_exactly(\ni64 exact_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-prepare_at_least","title":"function prepare_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; MutableBuffer, 2 &gt; &gt; prepare_at_least(\ni64 min_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-async_prepare_at_least","title":"function async_prepare_at_least","text":"<pre><code>template &lt;typename Handler  =void(const ErrorCode&amp; ec, SmallVec&lt;MutableBuffer, 2&gt;)&gt;\nvoid async_prepare_at_least(\ni64 min_count,\nHandler &amp;&amp; handler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-commit","title":"function commit","text":"<pre><code>inline void commit(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-write_type","title":"function write_type","text":"<pre><code>template &lt;typename T &gt;\nStatus write_type(\nStaticType&lt; T &gt; ,\nconst T &amp; value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-async_write_some","title":"function async_write_some","text":"<pre><code>template &lt;typename ConstBuffers ,\ntypename Handler  =void(const ErrorCode&amp; ec, usize n_bytes_written)&gt;\nvoid async_write_some(\nConstBuffers &amp;&amp; buffers,\nHandler &amp;&amp; handler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-write_all","title":"function write_all","text":"<pre><code>inline Status write_all(\nConstBuffer buffer\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-close_for_write","title":"function close_for_write","text":"<pre><code>inline void close_for_write()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(\ni64 min_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-fetch_type","title":"function fetch_type","text":"<pre><code>template &lt;typename T &gt;\nStatusOr&lt; std::reference_wrapper&lt; const T &gt; &gt; fetch_type(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-consume_type","title":"function consume_type","text":"<pre><code>template &lt;typename T &gt;\nvoid consume_type(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-read_type","title":"function read_type","text":"<pre><code>template &lt;typename T &gt;\nStatusOr&lt; T &gt; read_type(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#function-close","title":"function close","text":"<pre><code>inline void close()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StreamBuffer/#variable-ktempbuffersize","title":"variable kTempBufferSize","text":"<pre><code>static constexpr usize kTempBufferSize = 512;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/","title":"batt::StrongType","text":"<p>More...</p> <p>Inherited by batt::StrongType&lt; T, Tag &gt;::Delta</p>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-classes","title":"Public Classes","text":"Name struct Delta struct Hash"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-types","title":"Public Types","text":"Name using T value_type using Tag tag_type"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-functions","title":"Public Functions","text":"Name constexpr StrongType() constexpr StrongType(T init_value) constexpr T value() const constexpr operator T() const StrongType &amp; operator+=(Delta d) StrongType &amp; operator-=(Delta d)"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename Tag &gt;\nclass batt::StrongType;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StrongType/#using-value_type","title":"using value_type","text":"<pre><code>using batt::StrongType&lt; T, Tag &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#using-tag_type","title":"using tag_type","text":"<pre><code>using batt::StrongType&lt; T, Tag &gt;::tag_type =  Tag;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-strongtype","title":"function StrongType","text":"<pre><code>inline constexpr StrongType()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-strongtype_1","title":"function StrongType","text":"<pre><code>inline explicit constexpr StrongType(\nT init_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-value","title":"function value","text":"<pre><code>inline constexpr T value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-operator-t","title":"function operator T","text":"<pre><code>inline constexpr operator T() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-operator","title":"function operator+=","text":"<pre><code>inline StrongType &amp; operator+=(\nDelta d\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1StrongType/#function-operator-","title":"function operator-=","text":"<pre><code>inline StrongType &amp; operator-=(\nDelta d\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/","title":"batt::SubRangeSeq","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-types","title":"Public Types","text":"Name using decltype(std::declval&lt; T &gt;().front()) Item"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-functions","title":"Public Functions","text":"Name SubRangeSeq(T &amp;&amp; sub_range) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::SubRangeSeq;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#using-item","title":"using Item","text":"<pre><code>using batt::SubRangeSeq&lt; T &gt;::Item =  decltype(std::declval&lt;T&gt;().front());\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#function-subrangeseq","title":"function SubRangeSeq","text":"<pre><code>inline explicit SubRangeSeq(\nT &amp;&amp; sub_range\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1SubRangeSeq/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/","title":"batt::TakeNSource","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#public-functions","title":"Public Functions","text":"Name TakeNSource(Src &amp;&amp; src, usize limit) usize size() const StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(i64 min_count) void consume(i64 count) void close_for_read()"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Src &gt;\nclass batt::TakeNSource;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-takensource","title":"function TakeNSource","text":"<pre><code>inline explicit TakeNSource(\nSrc &amp;&amp; src,\nusize limit\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(\ni64 min_count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TakeNSource/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Task/","title":"batt::Task","text":"<p>A user-space cooperatively scheduled thread of control.  More...</p> <p><code>#include &lt;batteries/async/task_decl.hpp&gt;</code></p> <p>Inherits from boost::intrusive::list_base_hook&lt; boost::intrusive::link_mode&lt; boost::intrusive::auto_unlink &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-classes","title":"Public Classes","text":"Name class ConcurrentTaskList Thread-safe list of tasks. struct DebugTrace Stack trace and debug information collected from a Task. struct Options Optional params for Task creation."},{"location":"_autogen/Classes/classbatt_1_1Task/#public-types","title":"Public Types","text":"Name using ::batt::StrongType&lt; bool, DeferStart_TAG &gt; DeferStart using bool * PointerToBool Must be non-nullptr; if passed to Task::Task, the referent bool is set to true iff the task was started inside the constructor. using ::batt::StrongType&lt; PointerToBool, GetIsStarted_TAG &gt; GetIsStarted using u32 state_type Integer type representing the atomic state of a Task. using ::batt::StrongType&lt; i32, Priority_TAG &gt; Priority using ::batt::StrongType&lt; bool, IsDone_TAG &gt; IsDone using boost::asio::any_io_executor executor_type The executor for a Task; this type is responsible for running the Task via <code>boost::asio::post</code> and/or <code>boost::asio::dispatch</code>. using boost::intrusive::list&lt; Task, boost::intrusive::constant_time_size&lt; false &gt; &gt; TaskList The type of a global linked list of tasks maintained by the Batteries runtime. using std::bitset&lt; kNumStateFlags &gt; StateBitset The bitset type for a state."},{"location":"_autogen/Classes/classbatt_1_1Task/#public-functions","title":"Public Functions","text":"Name constexpr bool strong_typedef_default_value(DeferStart_TAG * ) constexpr PointerToBool strong_typedef_default_value(GetIsStarted_TAG * ) constexpr i32 strong_typedef_default_value(Priority_TAG * ) constexpr bool strong_typedef_default_value(IsDone_TAG * ) Task(const Task &amp; ) =deletedTask is not copy-constructible. Task &amp; operator=(const Task &amp; ) =deletedTask is not copy-assignable. template &lt;typename BodyFn  =void()&gt;  Task(const boost::asio::any_io_executor &amp; ex, StackSize stack_size, BodyFn &amp;&amp; body_fn)Creates a new Task with a custom stack size. template &lt;typename BodyFn  =void(),typename... Args,typename  =EnableIfNoShadow&gt;  Task(const boost::asio::any_io_executor &amp; ex, BodyFn &amp;&amp; body_fn, Args &amp;&amp;... args)Create a new Task, optionally setting name, stack size, stack type, and priority. template &lt;typename BodyFn  =void()&gt;  Task(const boost::asio::any_io_executor &amp; ex, BodyFn &amp;&amp; body_fn)Create a new Task, with default options. template &lt;typename BodyFn  =void(),typename... Args,typename  =EnableIfNoShadow&gt;  Task(ConcurrentTaskList &amp; parent_task_list, const boost::asio::any_io_executor &amp; ex, BodyFn &amp;&amp; body_fn, Args &amp;&amp;... args)Internal use only. template &lt;typename BodyFn  =void()&gt;  Task(ConcurrentTaskList &amp; parent_task_list, const boost::asio::any_io_executor &amp; ex, BodyFn &amp;&amp; body_fn) template &lt;typename BodyFn  =void(),typename OptionsT ,typename  =std::enable_if_t, Options&gt;&gt;&gt;  Task(ConcurrentTaskList &amp; parent_task_list, const boost::asio::any_io_executor &amp; ex, BodyFn &amp;&amp; body_fn, OptionsT &amp;&amp; options)Internal use only. ~Task()Destroys the Task. bool is_started() constReturns true iff this task has been started. void start()Starts the task if not already started. i32 id() constThe unique id number assigned to this Task. std::string_view name() constThe user-friendly name assigned to this Task. Priority get_priority() constThe scheduling priority of this task; higher == more urgent. void set_priority(Priority new_priority)Assigns a new priority to this Task. usize stack_pos() constThe current byte offset of the top of this Task's stack. usize stack_pos_of(const volatile void * ptr) constThe byte offset of the given pointer relative to the base of this Task's stack; return value is undefined if <code>ptr</code> is not on the stack of this Task! void join()Blocks the current Task/thread until this Task has finished. IsDone try_join()Returns whether or not this Task is finished. bool wake()Interrupts a call to sleep on this Task. executor_type get_executor() constThe executor passed in to this Task at construction time. IsDone is_done() constReturns whether or not this Task is finished. template &lt;typename F  =void()&gt; void call_when_done(F &amp;&amp; handler)Attaches a listener callback to the task; this callback will be invoked when the task completes execution. std::string default_name()The name given to a batt::Task if none is passed into the constructor. Priority default_priority()Returns the default task priority (based on the current task priority). usize &amp; nesting_depth()Thread-local counter that limits stack growth while running Tasks via <code>dispatch</code>. constexpr bool is_post_init_state(state_type state)Returns true iff the given state indicates the Task has been initialized. constexpr bool is_pre_start_state(state_type state)Returns true iff the given state is initialized but not started. constexpr bool is_started_state(state_type state)Returns true iff the given state is started. constexpr bool is_running_state(state_type state)Returns true iff the given state is not a suspended state. constexpr bool is_ready_state(state_type state)Returns true iff the task is not currently running, but is ready to be resumed. constexpr bool is_terminal_state(state_type state)Returns true if the passed state represents a fully terminated task. ConcurrentTaskList &amp; all_tasks()Returns a reference to the global task list. Task &amp; current()Returns a reference to the currently running Task, if there is one. template &lt;typename... CtorArgs&gt; void spawn(CtorArgs &amp;&amp;... args)Launch a Task that is a child of the current one. std::string_view current_name()Returns the current task name, or \"\" if there is no current task. i32 current_id()Returns the unique id number of the current Task or thread. Optional&lt; usize &gt; current_stack_pos()Returns the current stack position, if currently inside a task. Optional&lt; usize &gt; current_stack_pos_of(const volatile void * ptr)brief Returns the stack position of <code>ptr</code> relative to the current stack base, if currently inside a task. i32 backtrace_all(bool force, std::ostream &amp; out =std::cerr)Dumps stack traces and debug info from all Tasks and threads to stderr. void yield()Yields control from the current Task/thread, allowing other tasks to run. template &lt;typename Duration  =boost::posix_time::ptime&gt; ErrorCode sleep(const Duration &amp; duration)Puts the current Task/thread to sleep for the specified duration. template &lt;typename R ,typename Fn &gt; R await(Fn &amp;&amp; fn)Suspends the current thread/Task until an asynchronous event occurs. template &lt;typename R ,typename Fn &gt; R await(batt::StaticType&lt; R &gt; , Fn &amp;&amp; fn)Suspends the current thread/Task until an asynchronous event occurs. template &lt;typename T &gt; StatusOr&lt; T &gt; await(const Future&lt; T &gt; &amp; future_result)Suspends the current thread/Task until the passed Future is ready. template &lt;typename AsyncStream ,typename BufferSequence &gt; IOResult&lt; usize &gt; await_read_some(AsyncStream &amp; s, BufferSequence &amp;&amp; buffers)Convenience function that calls <code>async_read_some</code> on the passed stream and awaits the result. template &lt;typename AsyncStream ,typename BufferSequence &gt; IOResult&lt; usize &gt; await_read(AsyncStream &amp; s, BufferSequence &amp;&amp; buffers)Convenience function that calls <code>async_read</code> on the passed stream and awaits the result. template &lt;typename AsyncStream ,typename BufferSequence &gt; IOResult&lt; usize &gt; await_write_some(AsyncStream &amp; s, BufferSequence &amp;&amp; buffers)Convenience function that calls <code>async_write_some</code> on the passed stream and awaits the result. template &lt;typename AsyncStream ,typename BufferSequence &gt; IOResult&lt; usize &gt; await_write(AsyncStream &amp; s, BufferSequence &amp;&amp; buffers)Convenience function that calls <code>async_write</code> on the passed stream and awaits the result. template &lt;typename AsyncStream ,typename Endpoint &gt; ErrorCode await_connect(AsyncStream &amp; s, const Endpoint &amp; endpoint)Convenience function that calls <code>async_connect</code> on the passed stream and awaits the result. template &lt;typename AsyncAcceptor ,typename ProtocolT  =typename AsyncAcceptor::protocol_type,typename StreamT  =typename ProtocolT::socket&gt; IOResult&lt; StreamT &gt; await_accept(AsyncAcceptor &amp; a)Convenience function that calls <code>async_accept</code> on the passed stream and awaits the result. template &lt;typename SignalSetT &gt; IOResult&lt; int &gt; await_signal(SignalSetT &amp; signal_set)Convenience function that calls <code>async_wait</code> on the passed signal_set and awaits the result. Priority current_priority()Returns the priority of the current Task (or the default priority if no Task is active). bool &amp; inside_work_fn()Returns true iff the current Task/thread is inside a Worker's work function. std::atomic&lt; i64 &gt; &amp; create_count() std::atomic&lt; i64 &gt; &amp; destroy_count()"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-attributes","title":"Public Attributes","text":"Name constexpr StackSize kDefaultStackSize The default stack size. constexpr StackType kDefaultStackType The default stack type. constexpr DeferStart kDefaultDeferStart By default, tasks start immediately upon construction. constexpr usize kMaxNestingDepth The upper bound on nesting_depth. constexpr usize kHandlerMemoryBytes The number of bytes to statically allocate for handler memory buffers. constexpr state_type kNeedSignal Set when code within the task requests a signal, because it is awaiting some external async event. constexpr state_type kHaveSignal Set when the continuation generated by an <code>await</code> is invoked. constexpr state_type kSuspended Set when the task is not currently running. constexpr state_type kTerminated Indicates the task has finished execution. constexpr state_type kStackTrace Set to request that the task collect a stack trace the next time it resumes. constexpr state_type kSleepTimerLock Spin-lock bit to serialize access to the sleep timer member of the Task. constexpr state_type kCompletionHandlersLock Spin-lock bit to serialize access to the completions handlers list. constexpr state_type kSleepTimerLockSuspend Used to save the value of the kSleepTimerLock bit when the Task is suspended (e.g., in <code>await</code> or <code>yield</code>). constexpr state_type kCompletionHandlersClosed State bit to indicate that completion handlers should not be added to the list, but called immediately. constexpr state_type kInitialized State bit that indicates all fields have been initialized. constexpr state_type kStarted State bit that indicates all fields have been initialized. constexpr usize kNumStateFlags The number of state flags defined above. DebugInfoFrame * debug_info"},{"location":"_autogen/Classes/classbatt_1_1Task/#friends","title":"Friends","text":"Name class DebugInfoFrame void print_debug_info(DebugInfoFrame * p, std::ostream &amp; out)"},{"location":"_autogen/Classes/classbatt_1_1Task/#detailed-description","title":"Detailed Description","text":"<pre><code>class batt::Task;\n</code></pre> <p>A user-space cooperatively scheduled thread of control. </p> <p>Does not support preemption. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Task/#using-deferstart","title":"using DeferStart","text":"<pre><code>using batt::Task::DeferStart =  ::batt::StrongType&lt; bool , DeferStart_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-pointertobool","title":"using PointerToBool","text":"<pre><code>using batt::Task::PointerToBool =  bool*;\n</code></pre> <p>Must be non-nullptr; if passed to Task::Task, the referent bool is set to true iff the task was started inside the constructor. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-getisstarted","title":"using GetIsStarted","text":"<pre><code>using batt::Task::GetIsStarted =  ::batt::StrongType&lt; PointerToBool , GetIsStarted_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-state_type","title":"using state_type","text":"<pre><code>using batt::Task::state_type =  u32;\n</code></pre> <p>Integer type representing the atomic state of a Task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-priority","title":"using Priority","text":"<pre><code>using batt::Task::Priority =  ::batt::StrongType&lt; i32 , Priority_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-isdone","title":"using IsDone","text":"<pre><code>using batt::Task::IsDone =  ::batt::StrongType&lt; bool , IsDone_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-executor_type","title":"using executor_type","text":"<pre><code>using batt::Task::executor_type =  boost::asio::any_io_executor;\n</code></pre> <p>The executor for a Task; this type is responsible for running the Task via <code>boost::asio::post</code> and/or <code>boost::asio::dispatch</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-tasklist","title":"using TaskList","text":"<pre><code>using batt::Task::TaskList =  boost::intrusive::list&lt;Task, boost::intrusive::constant_time_size&lt;false&gt; &gt;;\n</code></pre> <p>The type of a global linked list of tasks maintained by the Batteries runtime. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#using-statebitset","title":"using StateBitset","text":"<pre><code>using batt::Task::StateBitset =  std::bitset&lt;kNumStateFlags&gt;;\n</code></pre> <p>The bitset type for a state. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Task/#function-strong_typedef_default_value","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr bool strong_typedef_default_value(\nDeferStart_TAG * )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-strong_typedef_default_value_1","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr PointerToBool strong_typedef_default_value(\nGetIsStarted_TAG * )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-strong_typedef_default_value_2","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr i32 strong_typedef_default_value(\nPriority_TAG * )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-strong_typedef_default_value_3","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr bool strong_typedef_default_value(\nIsDone_TAG * )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task","title":"function Task","text":"<pre><code>Task(\nconst Task &amp; ) =deleted\n</code></pre> <p>Task is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-operator","title":"function operator=","text":"<pre><code>Task &amp; operator=(\nconst Task &amp; ) =deleted\n</code></pre> <p>Task is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_1","title":"function Task","text":"<pre><code>template &lt;typename BodyFn  =void()&gt;\ninline explicit Task(\nconst boost::asio::any_io_executor &amp; ex,\nStackSize stack_size,\nBodyFn &amp;&amp; body_fn\n)\n</code></pre> <p>Creates a new Task with a custom stack size. </p> <p>DEPRECATED - pass stack_size after body_fn. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_2","title":"function Task","text":"<pre><code>template &lt;typename BodyFn  =void(),\ntypename... Args,\ntypename  =EnableIfNoShadow&lt;Options, Args...&gt;&gt;\ninline explicit Task(\nconst boost::asio::any_io_executor &amp; ex,\nBodyFn &amp;&amp; body_fn,\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Create a new Task, optionally setting name, stack size, stack type, and priority. </p> <p>The default priority for a Task is the current task priority plus 100; this means that a new Task by default will always \"soft-preempt\" the currently running task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_3","title":"function Task","text":"<pre><code>template &lt;typename BodyFn  =void()&gt;\ninline explicit Task(\nconst boost::asio::any_io_executor &amp; ex,\nBodyFn &amp;&amp; body_fn\n)\n</code></pre> <p>Create a new Task, with default options. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_4","title":"function Task","text":"<pre><code>template &lt;typename BodyFn  =void(),\ntypename... Args,\ntypename  =EnableIfNoShadow&lt;Options, Args...&gt;&gt;\ninline explicit Task(\nConcurrentTaskList &amp; parent_task_list,\nconst boost::asio::any_io_executor &amp; ex,\nBodyFn &amp;&amp; body_fn,\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Internal use only. </p> <p>Supported Args... types:</p> <ul> <li>std::string&amp;&amp; name</li> <li>StackSize</li> <li>StackType</li> <li>Priority</li> <li>DeferStart </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_5","title":"function Task","text":"<pre><code>template &lt;typename BodyFn  =void()&gt;\ninline explicit Task(\nConcurrentTaskList &amp; parent_task_list,\nconst boost::asio::any_io_executor &amp; ex,\nBodyFn &amp;&amp; body_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_6","title":"function Task","text":"<pre><code>template &lt;typename BodyFn  =void(),\ntypename OptionsT ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;OptionsT&gt;, Options&gt;&gt;&gt;\ninline explicit Task(\nConcurrentTaskList &amp; parent_task_list,\nconst boost::asio::any_io_executor &amp; ex,\nBodyFn &amp;&amp; body_fn,\nOptionsT &amp;&amp; options\n)\n</code></pre> <p>Internal use only. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-task_7","title":"function ~Task","text":"<pre><code>inline ~Task()\n</code></pre> <p>Destroys the Task. </p> <p>A Task must be terminated when it is destroyed, or the program will panic. Calling Task::join() prior to destroying a Task object is sufficient. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_started","title":"function is_started","text":"<pre><code>inline bool is_started() const\n</code></pre> <p>Returns true iff this task has been started. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre> <p>Starts the task if not already started. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-id","title":"function id","text":"<pre><code>inline i32 id() const\n</code></pre> <p>The unique id number assigned to this Task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-name","title":"function name","text":"<pre><code>inline std::string_view name() const\n</code></pre> <p>The user-friendly name assigned to this Task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-get_priority","title":"function get_priority","text":"<pre><code>inline Priority get_priority() const\n</code></pre> <p>The scheduling priority of this task; higher == more urgent. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-set_priority","title":"function set_priority","text":"<pre><code>inline void set_priority(\nPriority new_priority\n)\n</code></pre> <p>Assigns a new priority to this Task. </p> <p>This method will not trigger a yield or activation; it only affects future scheduling decisions. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-stack_pos","title":"function stack_pos","text":"<pre><code>inline usize stack_pos() const\n</code></pre> <p>The current byte offset of the top of this Task's stack. </p> <p>This value is only meaningful if this method is called while on the current task. Usually you should just call batt::Task::current_stack_pos() instead. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-stack_pos_of","title":"function stack_pos_of","text":"<pre><code>inline usize stack_pos_of(\nconst volatile void * ptr\n) const\n</code></pre> <p>The byte offset of the given pointer relative to the base of this Task's stack; return value is undefined if <code>ptr</code> is not on the stack of this Task! </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre> <p>Blocks the current Task/thread until this Task has finished. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-try_join","title":"function try_join","text":"<pre><code>inline IsDone try_join()\n</code></pre> <p>Returns whether or not this Task is finished. </p> <p>Equivalent to is_done().</p> <p>This function is guaranteed never to block. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-wake","title":"function wake","text":"<pre><code>inline bool wake()\n</code></pre> <p>Interrupts a call to sleep on this Task. </p> <p>Has no effect if the Task is not inside sleep. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-get_executor","title":"function get_executor","text":"<pre><code>inline executor_type get_executor() const\n</code></pre> <p>The executor passed in to this Task at construction time. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_done","title":"function is_done","text":"<pre><code>inline IsDone is_done() const\n</code></pre> <p>Returns whether or not this Task is finished. </p> <p>Equivalent to try_join(). </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-call_when_done","title":"function call_when_done","text":"<pre><code>template &lt;typename F  =void()&gt;\ninline void call_when_done(\nF &amp;&amp; handler\n)\n</code></pre> <p>Attaches a listener callback to the task; this callback will be invoked when the task completes execution. </p> <p>Parameters: </p> <ul> <li>handler The handler to invoke when the Task has finished; should have the signature <code>void()</code></li> </ul> <p>This method can be thought of as an asynchronous version of batt::Task::join.</p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-default_name","title":"function default_name","text":"<pre><code>static inline std::string default_name()\n</code></pre> <p>The name given to a batt::Task if none is passed into the constructor. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-default_priority","title":"function default_priority","text":"<pre><code>static inline Priority default_priority()\n</code></pre> <p>Returns the default task priority (based on the current task priority). </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-nesting_depth","title":"function nesting_depth","text":"<pre><code>static inline usize &amp; nesting_depth()\n</code></pre> <p>Thread-local counter that limits stack growth while running Tasks via <code>dispatch</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_post_init_state","title":"function is_post_init_state","text":"<pre><code>static inline constexpr bool is_post_init_state(\nstate_type state\n)\n</code></pre> <p>Returns true iff the given state indicates the Task has been initialized. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_pre_start_state","title":"function is_pre_start_state","text":"<pre><code>static inline constexpr bool is_pre_start_state(\nstate_type state\n)\n</code></pre> <p>Returns true iff the given state is initialized but not started. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_started_state","title":"function is_started_state","text":"<pre><code>static inline constexpr bool is_started_state(\nstate_type state\n)\n</code></pre> <p>Returns true iff the given state is started. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_running_state","title":"function is_running_state","text":"<pre><code>static inline constexpr bool is_running_state(\nstate_type state\n)\n</code></pre> <p>Returns true iff the given state is not a suspended state. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_ready_state","title":"function is_ready_state","text":"<pre><code>static inline constexpr bool is_ready_state(\nstate_type state\n)\n</code></pre> <p>Returns true iff the task is not currently running, but is ready to be resumed. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-is_terminal_state","title":"function is_terminal_state","text":"<pre><code>static inline constexpr bool is_terminal_state(\nstate_type state\n)\n</code></pre> <p>Returns true if the passed state represents a fully terminated task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-all_tasks","title":"function all_tasks","text":"<pre><code>static inline ConcurrentTaskList &amp; all_tasks()\n</code></pre> <p>Returns a reference to the global task list. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current","title":"function current","text":"<pre><code>static inline Task &amp; current()\n</code></pre> <p>Returns a reference to the currently running Task, if there is one. </p> <p>WARNING: if this method is called outside of any batt::Task, behavior is undefined. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-spawn","title":"function spawn","text":"<pre><code>template &lt;typename... CtorArgs&gt;\nstatic inline void spawn(\nCtorArgs &amp;&amp;... args\n)\n</code></pre> <p>Launch a Task that is a child of the current one. </p> <p>The new task will automatically be joined when the current Task terminates. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_name","title":"function current_name","text":"<pre><code>static inline std::string_view current_name()\n</code></pre> <p>Returns the current task name, or \"\" if there is no current task. </p> <p>Unlike batt::Task::current(), this method is safe to call outside a task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_id","title":"function current_id","text":"<pre><code>static inline i32 current_id()\n</code></pre> <p>Returns the unique id number of the current Task or thread. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_stack_pos","title":"function current_stack_pos","text":"<pre><code>static inline Optional&lt; usize &gt; current_stack_pos()\n</code></pre> <p>Returns the current stack position, if currently inside a task. </p> <p>Return: If called from inside a task, the current stack position in bytes, else batt::None </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_stack_pos_of","title":"function current_stack_pos_of","text":"<pre><code>static inline Optional&lt; usize &gt; current_stack_pos_of(\nconst volatile void * ptr\n)\n</code></pre> <p>brief Returns the stack position of <code>ptr</code> relative to the current stack base, if currently inside a task. </p> <p>Return: If called from inside a task, the stack offset in bytes of <code>ptr</code>, else batt::None </p> <p>NOTE: If <code>ptr</code> isn't actually on the current task's stack, then this function will still return a number, but it will be essentially a garbage value. It's up to the caller to make sure that <code>ptr</code> points at something on the task stack.</p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-backtrace_all","title":"function backtrace_all","text":"<pre><code>static inline i32 backtrace_all(\nbool force,\nstd::ostream &amp; out =std::cerr\n)\n</code></pre> <p>Dumps stack traces and debug info from all Tasks and threads to stderr. </p> <p>Parameters: </p> <ul> <li>force If true, then this function will attempt to dump debug information for running tasks, even though this may cause data races (if you're debugging a tricky threading issue, sometimes the risk of a crash is outweighed by the benefit of some additional clues about what's going on!)</li> </ul> <p>Return: The number of tasks dumped. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-yield","title":"function yield","text":"<pre><code>static inline void yield()\n</code></pre> <p>Yields control from the current Task/thread, allowing other tasks to run. </p> <p>Suspends the current task and immediately schedules it to resume via <code>boost::asio::post</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-sleep","title":"function sleep","text":"<pre><code>template &lt;typename Duration  =boost::posix_time::ptime&gt;\nstatic inline ErrorCode sleep(\nconst Duration &amp; duration\n)\n</code></pre> <p>Puts the current Task/thread to sleep for the specified duration. </p> <p>Return: <code>batt::ErrorCode{}</code> (no error) if the specified duration passed, else <code>boost::asio::error::operation_aborted</code> (indicating that batt::Task::wake() was called on the given task) </p> <p>This operation can be interrupted by a batt::Task::wake(), in which case a \"cancelled\" error code is returned instead of success (no error).</p> <p>This method is safe to call outside a task; in this case, it is implemented via <code>std::this_task::sleep_for</code>.</p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await","title":"function await","text":"<pre><code>template &lt;typename R ,\ntypename Fn &gt;\nstatic inline R await(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Suspends the current thread/Task until an asynchronous event occurs. </p> <p>The param <code>fn</code> is passed a continuation handler that will cause this Task to wake up, causing await to return an instance of type <code>R</code> constructed from the arguments passed to the handler. For example, <code>await</code> can be used to turn an async socket read into a synchronous call:</p> <pre><code>boost::asio::ip::tcp::socket s;\nusing ReadResult = std::pair&lt;boost::system::error_code, std::size_t&gt;;\nReadResult r = Task::await&lt;ReadResult&gt;([&amp;](auto&amp;&amp; handler) {\ns.async_read_some(buffers, BATT_FORWARD(handler));\n});\nif (r.first) {\nstd::cout &lt;&lt; \"Error! ec=\" &lt;&lt; r.first;\n} else {\nstd::cout &lt;&lt; r.second &lt;&lt; \" bytes were read.\";\n}\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_1","title":"function await","text":"<pre><code>template &lt;typename R ,\ntypename Fn &gt;\nstatic inline R await(\nbatt::StaticType&lt; R &gt; ,\nFn &amp;&amp; fn\n)\n</code></pre> <p>Suspends the current thread/Task until an asynchronous event occurs. </p> <p>This overload takes the return type as an explicit formal parameter (instead of a template parameter). </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_2","title":"function await","text":"<pre><code>template &lt;typename T &gt;\nstatic inline StatusOr&lt; T &gt; await(\nconst Future&lt; T &gt; &amp; future_result\n)\n</code></pre> <p>Suspends the current thread/Task until the passed Future is ready. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_read_some","title":"function await_read_some","text":"<pre><code>template &lt;typename AsyncStream ,\ntypename BufferSequence &gt;\nstatic inline IOResult&lt; usize &gt; await_read_some(\nAsyncStream &amp; s,\nBufferSequence &amp;&amp; buffers\n)\n</code></pre> <p>Convenience function that calls <code>async_read_some</code> on the passed stream and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_read","title":"function await_read","text":"<pre><code>template &lt;typename AsyncStream ,\ntypename BufferSequence &gt;\nstatic inline IOResult&lt; usize &gt; await_read(\nAsyncStream &amp; s,\nBufferSequence &amp;&amp; buffers\n)\n</code></pre> <p>Convenience function that calls <code>async_read</code> on the passed stream and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_write_some","title":"function await_write_some","text":"<pre><code>template &lt;typename AsyncStream ,\ntypename BufferSequence &gt;\nstatic inline IOResult&lt; usize &gt; await_write_some(\nAsyncStream &amp; s,\nBufferSequence &amp;&amp; buffers\n)\n</code></pre> <p>Convenience function that calls <code>async_write_some</code> on the passed stream and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_write","title":"function await_write","text":"<pre><code>template &lt;typename AsyncStream ,\ntypename BufferSequence &gt;\nstatic inline IOResult&lt; usize &gt; await_write(\nAsyncStream &amp; s,\nBufferSequence &amp;&amp; buffers\n)\n</code></pre> <p>Convenience function that calls <code>async_write</code> on the passed stream and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_connect","title":"function await_connect","text":"<pre><code>template &lt;typename AsyncStream ,\ntypename Endpoint &gt;\nstatic inline ErrorCode await_connect(\nAsyncStream &amp; s,\nconst Endpoint &amp; endpoint\n)\n</code></pre> <p>Convenience function that calls <code>async_connect</code> on the passed stream and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_accept","title":"function await_accept","text":"<pre><code>template &lt;typename AsyncAcceptor ,\ntypename ProtocolT  =typename AsyncAcceptor::protocol_type,\ntypename StreamT  =typename ProtocolT::socket&gt;\nstatic inline IOResult&lt; StreamT &gt; await_accept(\nAsyncAcceptor &amp; a\n)\n</code></pre> <p>Convenience function that calls <code>async_accept</code> on the passed stream and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-await_signal","title":"function await_signal","text":"<pre><code>template &lt;typename SignalSetT &gt;\nstatic inline IOResult&lt; int &gt; await_signal(\nSignalSetT &amp; signal_set\n)\n</code></pre> <p>Convenience function that calls <code>async_wait</code> on the passed signal_set and awaits the result. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-current_priority","title":"function current_priority","text":"<pre><code>static inline Priority current_priority()\n</code></pre> <p>Returns the priority of the current Task (or the default priority if no Task is active). </p> <p>NOTE: this function is safe to call outside of a task; in this case, the default priority (0) is returned. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-inside_work_fn","title":"function inside_work_fn","text":"<pre><code>static inline bool &amp; inside_work_fn()\n</code></pre> <p>Returns true iff the current Task/thread is inside a Worker's work function. </p> <p>Used to avoid double-wait deadlocks on the same thread inside parallel algorithms. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-create_count","title":"function create_count","text":"<pre><code>static inline std::atomic&lt; i64 &gt; &amp; create_count()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#function-destroy_count","title":"function destroy_count","text":"<pre><code>static inline std::atomic&lt; i64 &gt; &amp; destroy_count()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kdefaultstacksize","title":"variable kDefaultStackSize","text":"<pre><code>static constexpr StackSize kDefaultStackSize = StackSize{8 * kMiB};\n</code></pre> <p>The default stack size. </p> <p>Be generous and let the MMU take care of the rest... </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kdefaultstacktype","title":"variable kDefaultStackType","text":"<pre><code>static constexpr StackType kDefaultStackType = StackType::kFixedSize;\n</code></pre> <p>The default stack type. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kdefaultdeferstart","title":"variable kDefaultDeferStart","text":"<pre><code>static constexpr DeferStart kDefaultDeferStart = DeferStart{false};\n</code></pre> <p>By default, tasks start immediately upon construction. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kmaxnestingdepth","title":"variable kMaxNestingDepth","text":"<pre><code>static constexpr usize kMaxNestingDepth = 8;\n</code></pre> <p>The upper bound on nesting_depth. </p> <p>When scheduling a task to run via <code>dispatch</code> would increase the nesting depth on the current thread to greater than kMaxNestingDepth, <code>post</code> is used instead. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-khandlermemorybytes","title":"variable kHandlerMemoryBytes","text":"<pre><code>static constexpr usize kHandlerMemoryBytes = 128;\n</code></pre> <p>The number of bytes to statically allocate for handler memory buffers. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kneedsignal","title":"variable kNeedSignal","text":"<pre><code>static constexpr state_type kNeedSignal = state_type{1} &lt;&lt; 0;\n</code></pre> <p>Set when code within the task requests a signal, because it is awaiting some external async event. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-khavesignal","title":"variable kHaveSignal","text":"<pre><code>static constexpr state_type kHaveSignal = state_type{1} &lt;&lt; 1;\n</code></pre> <p>Set when the continuation generated by an <code>await</code> is invoked. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-ksuspended","title":"variable kSuspended","text":"<pre><code>static constexpr state_type kSuspended = state_type{1} &lt;&lt; 2;\n</code></pre> <p>Set when the task is not currently running. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kterminated","title":"variable kTerminated","text":"<pre><code>static constexpr state_type kTerminated = state_type{1} &lt;&lt; 3;\n</code></pre> <p>Indicates the task has finished execution. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kstacktrace","title":"variable kStackTrace","text":"<pre><code>static constexpr state_type kStackTrace = state_type{1} &lt;&lt; 4;\n</code></pre> <p>Set to request that the task collect a stack trace the next time it resumes. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-ksleeptimerlock","title":"variable kSleepTimerLock","text":"<pre><code>static constexpr state_type kSleepTimerLock = state_type{1} &lt;&lt; 5;\n</code></pre> <p>Spin-lock bit to serialize access to the sleep timer member of the Task. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kcompletionhandlerslock","title":"variable kCompletionHandlersLock","text":"<pre><code>static constexpr state_type kCompletionHandlersLock = state_type{1} &lt;&lt; 6;\n</code></pre> <p>Spin-lock bit to serialize access to the completions handlers list. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-ksleeptimerlocksuspend","title":"variable kSleepTimerLockSuspend","text":"<pre><code>static constexpr state_type kSleepTimerLockSuspend = state_type{1} &lt;&lt; 7;\n</code></pre> <p>Used to save the value of the kSleepTimerLock bit when the Task is suspended (e.g., in <code>await</code> or <code>yield</code>). </p> <p>The Task should not hold any spinlocks while it is suspended, so we don't deadlock. Rather, the sleep timer lock is temporarily released while suspended and then re-acquired when the task is resumed. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kcompletionhandlersclosed","title":"variable kCompletionHandlersClosed","text":"<pre><code>static constexpr state_type kCompletionHandlersClosed = state_type{1} &lt;&lt; 8;\n</code></pre> <p>State bit to indicate that completion handlers should not be added to the list, but called immediately. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kinitialized","title":"variable kInitialized","text":"<pre><code>static constexpr state_type kInitialized = state_type{1} &lt;&lt; 9;\n</code></pre> <p>State bit that indicates all fields have been initialized. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-kstarted","title":"variable kStarted","text":"<pre><code>static constexpr state_type kStarted = state_type{1} &lt;&lt; 10;\n</code></pre> <p>State bit that indicates all fields have been initialized. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-knumstateflags","title":"variable kNumStateFlags","text":"<pre><code>static constexpr usize kNumStateFlags = 11;\n</code></pre> <p>The number of state flags defined above. </p>"},{"location":"_autogen/Classes/classbatt_1_1Task/#variable-debug_info","title":"variable debug_info","text":"<pre><code>DebugInfoFrame * debug_info = nullptr;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1Task/#friend-debuginfoframe","title":"friend DebugInfoFrame","text":"<pre><code>friend class DebugInfoFrame(\nDebugInfoFrame );\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task/#friend-print_debug_info","title":"friend print_debug_info","text":"<pre><code>friend void print_debug_info(\nDebugInfoFrame * p,\nstd::ostream &amp; out\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/","title":"batt::TaskScheduler","text":"<p>Inherited by batt::FakeTaskScheduler, batt::NullTaskScheduler, batt::Runtime::DefaultScheduler</p>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#public-functions","title":"Public Functions","text":"Name TaskScheduler(const TaskScheduler &amp; ) =deleted TaskScheduler &amp; operator=(const TaskScheduler &amp; ) =deleted virtual ~TaskScheduler() =default virtual boost::asio::any_io_executor schedule_task() =0 virtual void halt() =0 virtual void join() =0"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#protected-functions","title":"Protected Functions","text":"Name TaskScheduler() =default"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-taskscheduler","title":"function TaskScheduler","text":"<pre><code>TaskScheduler(\nconst TaskScheduler &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-operator","title":"function operator=","text":"<pre><code>TaskScheduler &amp; operator=(\nconst TaskScheduler &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-taskscheduler_1","title":"function ~TaskScheduler","text":"<pre><code>virtual ~TaskScheduler() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-schedule_task","title":"function schedule_task","text":"<pre><code>virtual boost::asio::any_io_executor schedule_task() =0\n</code></pre> <p>Reimplemented by: batt::FakeTaskScheduler::schedule_task, batt::Runtime::DefaultScheduler::schedule_task, batt::NullTaskScheduler::schedule_task</p>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-halt","title":"function halt","text":"<pre><code>virtual void halt() =0\n</code></pre> <p>Reimplemented by: batt::FakeTaskScheduler::halt, batt::Runtime::DefaultScheduler::halt, batt::NullTaskScheduler::halt</p>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-join","title":"function join","text":"<pre><code>virtual void join() =0\n</code></pre> <p>Reimplemented by: batt::FakeTaskScheduler::join, batt::Runtime::DefaultScheduler::join, batt::NullTaskScheduler::join</p>"},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TaskScheduler/#function-taskscheduler_2","title":"function TaskScheduler","text":"<pre><code>TaskScheduler() =default\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/","title":"batt::Task::ConcurrentTaskList","text":"<p>Thread-safe list of tasks.  <code>#include &lt;batteries/async/task_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#public-functions","title":"Public Functions","text":"Name ConcurrentTaskList() =default ConcurrentTaskList(const ConcurrentTaskList &amp; ) =deleted ConcurrentTaskList &amp; operator=(const ConcurrentTaskList &amp; ) =deleted void push_back(Task &amp; task) void unlink(Task &amp; task) void await_empty() template &lt;typename Fn ,typename R  =std::invoke_result_t&gt; R with_lock(Fn &amp;&amp; fn) void dump_log_info(std::string_view label) batt::SmallFn&lt; void(std::ostream &amp;)&gt; debug_info(std::string_view label)Returns a function that prints the contents of this list to an ostream for debugging purposes."},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-concurrenttasklist","title":"function ConcurrentTaskList","text":"<pre><code>ConcurrentTaskList() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-concurrenttasklist_1","title":"function ConcurrentTaskList","text":"<pre><code>ConcurrentTaskList(\nconst ConcurrentTaskList &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-operator","title":"function operator=","text":"<pre><code>ConcurrentTaskList &amp; operator=(\nconst ConcurrentTaskList &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-push_back","title":"function push_back","text":"<pre><code>inline void push_back(\nTask &amp; task\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-unlink","title":"function unlink","text":"<pre><code>inline void unlink(\nTask &amp; task\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-await_empty","title":"function await_empty","text":"<pre><code>inline void await_empty()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-with_lock","title":"function with_lock","text":"<pre><code>template &lt;typename Fn ,\ntypename R  =std::invoke_result_t&lt;Fn&amp;&amp;, TaskList&amp;&gt;&gt;\nR with_lock(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-dump_log_info","title":"function dump_log_info","text":"<pre><code>inline void dump_log_info(\nstd::string_view label\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1ConcurrentTaskList/#function-debug_info","title":"function debug_info","text":"<pre><code>inline batt::SmallFn&lt; void(std::ostream &amp;)&gt; debug_info(\nstd::string_view label\n)\n</code></pre> <p>Returns a function that prints the contents of this list to an ostream for debugging purposes. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/","title":"batt::Task::SpinLockGuard","text":""},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#public-functions","title":"Public Functions","text":"Name SpinLockGuard(Task * task, state_type mask) SpinLockGuard(const SpinLockGuard &amp; ) =deleted SpinLockGuard &amp; operator=(const SpinLockGuard &amp; ) =deleted ~SpinLockGuard() state_type prior_state() const"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-spinlockguard","title":"function SpinLockGuard","text":"<pre><code>inline explicit SpinLockGuard(\nTask * task,\nstate_type mask\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-spinlockguard_1","title":"function SpinLockGuard","text":"<pre><code>SpinLockGuard(\nconst SpinLockGuard &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-operator","title":"function operator=","text":"<pre><code>SpinLockGuard &amp; operator=(\nconst SpinLockGuard &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-spinlockguard_2","title":"function ~SpinLockGuard","text":"<pre><code>inline ~SpinLockGuard()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1SpinLockGuard/#function-prior_state","title":"function prior_state","text":"<pre><code>inline state_type prior_state() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/","title":"batt::Task::Trampoline","text":""},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#public-functions","title":"Public Functions","text":"Name void activate_task(Task * t) Task * get_current_task()"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#function-activate_task","title":"function activate_task","text":"<pre><code>static inline void activate_task(\nTask * t\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Task_1_1Trampoline/#function-get_current_task","title":"function get_current_task","text":"<pre><code>static inline Task * get_current_task()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/","title":"batt::TcpTransport","text":"<p>A thread-safe socket based TCP connection for HTTP clients.  <code>#include &lt;batteries/http/tcp_transport.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#public-functions","title":"Public Functions","text":"Name TcpTransport(HttpClientHostContext &amp; host_context)Construct a new TcpTransport that uses the passed io_context for socket communication. boost::asio::ip::tcp::endpoint local_endpoint(ErrorCode &amp; ec) constReturns the local endpoint associated with this connection, if connected; otherwise returns a default endpoint value and sets the passed ErrorCode value. boost::asio::ip::tcp::endpoint remote_endpoint(ErrorCode &amp; ec) constReturns the remote endpoint associated with this connection, if connected; otherwise returns a default endpoint value and sets the passed ErrorCode value. bool is_open() constReturns true iff this socket is open. void close(ErrorCode &amp; ec)Closes the socket (both directions). void shutdown(boost::asio::socket_base::shutdown_type mode, ErrorCode &amp; ec)Performs a protocol shutdown in one or both directions for the underlying socket. template &lt;typename Handler  =void(const ErrorCode&amp;)&gt; void async_connect(const boost::asio::ip::tcp::endpoint &amp; ep, Handler &amp;&amp; handler)Starts an asynchronous connect operation for this socket, invoking <code>handler</code> when complete. template &lt;typename MutableBufferSequence ,typename Handler  =void(const ErrorCode&amp;, usize)&gt; void async_read_some(MutableBufferSequence &amp;&amp; buffers, Handler &amp;&amp; handler)Starts reading some data from the connection, asychronously. template &lt;typename ConstBufferSequence ,typename Handler  =void(const ErrorCode&amp;, usize)&gt; void async_write_some(ConstBufferSequence &amp;&amp; buffers, Handler &amp;&amp; handler)Starts writing some data to the connection, asychronously."},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-tcptransport","title":"function TcpTransport","text":"<pre><code>inline explicit TcpTransport(\nHttpClientHostContext &amp; host_context\n)\n</code></pre> <p>Construct a new TcpTransport that uses the passed io_context for socket communication. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-local_endpoint","title":"function local_endpoint","text":"<pre><code>inline boost::asio::ip::tcp::endpoint local_endpoint(\nErrorCode &amp; ec\n) const\n</code></pre> <p>Returns the local endpoint associated with this connection, if connected; otherwise returns a default endpoint value and sets the passed ErrorCode value. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-remote_endpoint","title":"function remote_endpoint","text":"<pre><code>inline boost::asio::ip::tcp::endpoint remote_endpoint(\nErrorCode &amp; ec\n) const\n</code></pre> <p>Returns the remote endpoint associated with this connection, if connected; otherwise returns a default endpoint value and sets the passed ErrorCode value. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-is_open","title":"function is_open","text":"<pre><code>inline bool is_open() const\n</code></pre> <p>Returns true iff this socket is open. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-close","title":"function close","text":"<pre><code>inline void close(\nErrorCode &amp; ec\n)\n</code></pre> <p>Closes the socket (both directions). </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-shutdown","title":"function shutdown","text":"<pre><code>inline void shutdown(\nboost::asio::socket_base::shutdown_type mode,\nErrorCode &amp; ec\n)\n</code></pre> <p>Performs a protocol shutdown in one or both directions for the underlying socket. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-async_connect","title":"function async_connect","text":"<pre><code>template &lt;typename Handler  =void(const ErrorCode&amp;)&gt;\ninline void async_connect(\nconst boost::asio::ip::tcp::endpoint &amp; ep,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Starts an asynchronous connect operation for this socket, invoking <code>handler</code> when complete. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-async_read_some","title":"function async_read_some","text":"<pre><code>template &lt;typename MutableBufferSequence ,\ntypename Handler  =void(const ErrorCode&amp;, usize)&gt;\ninline void async_read_some(\nMutableBufferSequence &amp;&amp; buffers,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Starts reading some data from the connection, asychronously. </p>"},{"location":"_autogen/Classes/classbatt_1_1TcpTransport/#function-async_write_some","title":"function async_write_some","text":"<pre><code>template &lt;typename ConstBufferSequence ,\ntypename Handler  =void(const ErrorCode&amp;, usize)&gt;\ninline void async_write_some(\nConstBufferSequence &amp;&amp; buffers,\nHandler &amp;&amp; handler\n)\n</code></pre> <p>Starts writing some data to the connection, asychronously. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/","title":"batt::TypeErasedStorage","text":"<p>More...</p> <p>Inherits from batt::TypeErasedStorageBase&lt; AbstractType, TypedImpl &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-functions","title":"Public Functions","text":"Name TypeErasedStorage() template &lt;typename T ,typename... Args&gt;  TypeErasedStorage(StaticType&lt; T &gt; static_type, Args &amp;&amp;... args) TypeErasedStorage(const TypeErasedStorage &amp; other) TypeErasedStorage(TypeErasedStorage &amp;&amp; other) ~TypeErasedStorage() TypeErasedStorage &amp; operator=(TypeErasedStorage &amp;&amp; other) TypeErasedStorage &amp; operator=(const TypeErasedStorage &amp; other) template &lt;typename T ,typename... Args&gt; AbstractType * emplace(StaticType&lt; T &gt; static_type, Args &amp;&amp;... args) template &lt;typename T ,typename U ,typename  =std::enable_if_t, std::reference_wrapper\\&gt;&gt;&gt; AbstractType * emplace(StaticType&lt; U &gt; , const std::reference_wrapper&lt; T &gt; &amp; ref) void clear() MutableBuffer memory() AbstractType * get() const AbstractValue&lt; AbstractType &gt; * get_abstract() const AbstractValue&lt; AbstractType &gt; * get_abstract() const bool is_valid() const operator bool() const AbstractType * operator-&gt;() const AbstractType &amp; operator*() const"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-attributes","title":"Public Attributes","text":"Name constexpr usize reserved_size"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::TypeErasedStorageBase&lt; AbstractType, TypedImpl &gt;</p> Name template &lt;typename T ,typename... Args&gt; AbstractType * construct_impl(StaticType&lt; T &gt; , MutableBuffer buf, Args &amp;&amp;... args)"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename AbstractType ,\ntemplate&lt; typename &gt; class TypedImpl,\nusize kReservedSize =kCpuCacheLineSize - sizeof(void*),\nusize kAlignment =kCpuCacheLineSize&gt;\nclass batt::TypeErasedStorage;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage","title":"function TypeErasedStorage","text":"<pre><code>inline TypeErasedStorage()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_1","title":"function TypeErasedStorage","text":"<pre><code>template &lt;typename T ,\ntypename... Args&gt;\ninline TypeErasedStorage(\nStaticType&lt; T &gt; static_type,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_2","title":"function TypeErasedStorage","text":"<pre><code>inline TypeErasedStorage(\nconst TypeErasedStorage &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_3","title":"function TypeErasedStorage","text":"<pre><code>inline TypeErasedStorage(\nTypeErasedStorage &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-typeerasedstorage_4","title":"function ~TypeErasedStorage","text":"<pre><code>inline ~TypeErasedStorage()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator","title":"function operator=","text":"<pre><code>inline TypeErasedStorage &amp; operator=(\nTypeErasedStorage &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator_1","title":"function operator=","text":"<pre><code>inline TypeErasedStorage &amp; operator=(\nconst TypeErasedStorage &amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-emplace","title":"function emplace","text":"<pre><code>template &lt;typename T ,\ntypename... Args&gt;\ninline AbstractType * emplace(\nStaticType&lt; T &gt; static_type,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-emplace_1","title":"function emplace","text":"<pre><code>template &lt;typename T ,\ntypename U ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;U&gt;, std::reference_wrapper&lt;T&gt;&gt;&gt;&gt;\ninline AbstractType * emplace(\nStaticType&lt; U &gt; ,\nconst std::reference_wrapper&lt; T &gt; &amp; ref\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-clear","title":"function clear","text":"<pre><code>inline void clear()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-memory","title":"function memory","text":"<pre><code>inline MutableBuffer memory()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-get","title":"function get","text":"<pre><code>inline AbstractType * get() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-get_abstract","title":"function get_abstract","text":"<pre><code>inline AbstractValue&lt; AbstractType &gt; * get_abstract()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-get_abstract_1","title":"function get_abstract","text":"<pre><code>inline const AbstractValue&lt; AbstractType &gt; * get_abstract() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator-","title":"function operator-&gt;","text":"<pre><code>inline AbstractType * operator-&gt;() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#function-operator_2","title":"function operator*","text":"<pre><code>inline AbstractType &amp; operator*() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorage/#variable-reserved_size","title":"variable reserved_size","text":"<pre><code>static constexpr usize reserved_size = kReservedSize;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/","title":"batt::TypeErasedStorageBase","text":"<p>More...</p> <p>Inherited by batt::TypeErasedStorage&lt; batt::AbstractStackAllocator, batt::StackAllocatorImpl &gt;, batt::TypeErasedStorage&lt; AbstractBufferSource, BufferSourceImpl &gt;, batt::TypeErasedStorage&lt; AbstractSeq, SeqImpl &gt;, batt::TypeErasedStorage&lt; AbstractType, TypedImpl, kReservedSize, kAlignment &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#public-functions","title":"Public Functions","text":"Name template &lt;typename T ,typename... Args&gt; AbstractType * construct_impl(StaticType&lt; T &gt; , MutableBuffer buf, Args &amp;&amp;... args)"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename AbstractType ,\ntemplate&lt; typename &gt; class TypedImpl&gt;\nclass batt::TypeErasedStorageBase;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1TypeErasedStorageBase/#function-construct_impl","title":"function construct_impl","text":"<pre><code>template &lt;typename T ,\ntypename... Args&gt;\nstatic inline AbstractType * construct_impl(\nStaticType&lt; T &gt; ,\nMutableBuffer buf,\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/","title":"batt::UniqueHandler","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#public-functions","title":"Public Functions","text":"Name template &lt;typename Fn ,typename  =EnableIfNoShadow,typename  =std::enable_if_t, Args...&gt;::value&gt;&gt;  UniqueHandler(Fn &amp;&amp; fn) UniqueHandler() =default UniqueHandler(const UniqueHandler &amp; ) =deleted UniqueHandler &amp; operator=(const UniqueHandler &amp; ) =deleted UniqueHandler(UniqueHandler &amp;&amp; ) =default UniqueHandler &amp; operator=(UniqueHandler &amp;&amp; ) =default ~UniqueHandler() operator bool() const void operator()(Args... args)"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#friends","title":"Friends","text":"Name std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const UniqueHandler &amp; t)"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Args&gt;\nclass batt::UniqueHandler;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler","title":"function UniqueHandler","text":"<pre><code>template &lt;typename Fn ,\ntypename  =EnableIfNoShadow&lt;UniqueHandler, Fn&gt;,\ntypename  =std::enable_if_t&lt;IsCallable&lt;std::decay_t&lt;Fn&gt;, Args...&gt;::value&gt;&gt;\ninline explicit UniqueHandler(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_1","title":"function UniqueHandler","text":"<pre><code>UniqueHandler() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_2","title":"function UniqueHandler","text":"<pre><code>UniqueHandler(\nconst UniqueHandler &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator","title":"function operator=","text":"<pre><code>UniqueHandler &amp; operator=(\nconst UniqueHandler &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_3","title":"function UniqueHandler","text":"<pre><code>UniqueHandler(\nUniqueHandler &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator_1","title":"function operator=","text":"<pre><code>UniqueHandler &amp; operator=(\nUniqueHandler &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-uniquehandler_4","title":"function ~UniqueHandler","text":"<pre><code>inline ~UniqueHandler()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator-bool","title":"function operator bool","text":"<pre><code>inline explicit operator bool() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#function-operator_2","title":"function operator()","text":"<pre><code>inline void operator()(\nArgs... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1UniqueHandler/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst UniqueHandler &amp; t\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/","title":"batt::VariableExporter","text":"<p>More...</p> <p>Inherits from batt::MetricExporter</p>"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#public-functions","title":"Public Functions","text":"Name VariableExporter(const std::string &amp; name, const T &amp; var) virtual Token get_name() const override virtual double get_value() const override"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricExporter</p> Name MetricExporter(const MetricExporter &amp; ) =deleted MetricExporter &amp; operator=(const MetricExporter &amp; ) =deleted virtual ~MetricExporter() =default virtual std::string_view get_description() const virtual std::string_view get_type() const virtual const MetricLabelSet &amp; get_labels() const virtual void set_labels(MetricLabelSet &amp;&amp; labels) <p>Protected Functions inherited from batt::MetricExporter</p> Name MetricExporter() =default"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::VariableExporter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#function-variableexporter","title":"function VariableExporter","text":"<pre><code>inline explicit VariableExporter(\nconst std::string &amp; name,\nconst T &amp; var\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#function-get_name","title":"function get_name","text":"<pre><code>inline virtual Token get_name() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_name</p>"},{"location":"_autogen/Classes/classbatt_1_1VariableExporter/#function-get_value","title":"function get_value","text":"<pre><code>inline virtual double get_value() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_value</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/","title":"batt::VecSeq","text":"<p>More...</p> <p>Inherits from batt::VecSeqBase&lt; T &gt;, batt::SubRangeSeq&lt; boost::iterator_range&lt; const T * &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#public-functions","title":"Public Functions","text":"Name VecSeq(std::vector&lt; T &gt; &amp;&amp; v)"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::VecSeqBase&lt; T &gt;</p> Name VecSeqBase(std::vector&lt; T &gt; &amp;&amp; v) <p>Public Attributes inherited from batt::VecSeqBase&lt; T &gt;</p> Name std::vector&lt; T &gt; vec <p>Public Types inherited from batt::SubRangeSeq&lt; boost::iterator_range&lt; const T * &gt; &gt;</p> Name using decltype(std::declval&lt; T &gt;().front()) Item <p>Public Functions inherited from batt::SubRangeSeq&lt; boost::iterator_range&lt; const T * &gt; &gt;</p> Name SubRangeSeq(T &amp;&amp; sub_range) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::VecSeq;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1VecSeq/#function-vecseq","title":"function VecSeq","text":"<pre><code>inline explicit VecSeq(\nstd::vector&lt; T &gt; &amp;&amp; v\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/","title":"batt::Watch","text":"<p>A batt::Watch is like a <code>std::atomic</code> that you can block on, synchronously and asynchronously; see also batt::WatchAtomic.  More...</p> <p><code>#include &lt;batteries/async/watch_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#public-functions","title":"Public Functions","text":"Name Watch(const Watch &amp; ) =deletedWatch is not copy-constructible. Watch &amp; operator=(const Watch &amp; ) =deletedWatch is not copy-assignable. Watch() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  Watch(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~Watch()Destroys the Watch, automatically calling Watch::close. void close()Sets the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. bool is_closed() constTests whether the Watch is in a \"closed\" state. void set_value(const T &amp; new_value)Atomically set the value of the Watch. T get_value() constThe current value of the Watch. template &lt;typename Fn &gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. template &lt;typename Handler &gt; void async_wait(const T &amp; last_seen, Handler &amp;&amp; fn)Invokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen)Blocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred)Blocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. template &lt;typename OrderFn  =bool(const T&amp;, const T&amp;)&gt; void clamp_min_value(const T &amp; lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(const T&amp;, const T&amp;)&gt; void clamp_max_value(const T &amp; upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(const T &amp; lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(const T &amp; upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T."},{"location":"_autogen/Classes/classbatt_1_1Watch/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Watch;\n</code></pre> <p>A batt::Watch is like a <code>std::atomic</code> that you can block on, synchronously and asynchronously; see also batt::WatchAtomic. </p> <p>Like <code>std::atomic</code>, it has methods to atomically get/set/increment/etc. But unlike <code>std::atomic</code>, you can also block a task waiting for some condition to be true.</p> <p>Example:</p> <pre><code>#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;  // for BATT_CHECK_OK\n#include &lt;batteries/status.hpp&gt;  // for batt::Status\nint main() {\nbatt::Watch&lt;bool&gt; done{false};\n// Launch some background task that will do stuff, then set `done`\n// to `true` when it is finished.\n//\nlaunch_background_task(&amp;done);\nbatt::Status status = done.await_equal(true);\nBATT_CHECK_OK(status);\nreturn 0;\n}\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch","title":"function Watch","text":"<pre><code>Watch(\nconst Watch &amp; ) =deleted\n</code></pre> <p>Watch is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-operator","title":"function operator=","text":"<pre><code>Watch &amp; operator=(\nconst Watch &amp; ) =deleted\n</code></pre> <p>Watch is not copy-assignable. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch_1","title":"function Watch","text":"<pre><code>Watch() =default\n</code></pre> <p>Constructs a batt::Watch object with a default-initialized value of <code>T</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch_2","title":"function Watch","text":"<pre><code>template &lt;typename Init ,\ntypename  =EnableIfNoShadow&lt;Watch, Init&gt;&gt;\ninline explicit Watch(\nInit &amp;&amp; init_value\n)\n</code></pre> <p>Constructs a batt::Watch object with the given initial value. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-watch_3","title":"function ~Watch","text":"<pre><code>inline ~Watch()\n</code></pre> <p>Destroys the Watch, automatically calling Watch::close. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-close","title":"function close","text":"<pre><code>inline void close()\n</code></pre> <p>Sets the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. </p> <p>This method is safe to call multiple times. The Watch value can still be modified and retrieved after it is closed; this only disables the methods in the \"Synchronization\" category (see Summary section above). </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-is_closed","title":"function is_closed","text":"<pre><code>inline bool is_closed() const\n</code></pre> <p>Tests whether the Watch is in a \"closed\" state. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-set_value","title":"function set_value","text":"<pre><code>inline void set_value(\nconst T &amp; new_value\n)\n</code></pre> <p>Atomically set the value of the Watch. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-get_value","title":"function get_value","text":"<pre><code>inline T get_value() const\n</code></pre> <p>The current value of the Watch. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-modify","title":"function modify","text":"<pre><code>template &lt;typename Fn &gt;\ninline T modify(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Atomically modifies the Watch value by applying the passed transform <code>fn</code>. </p> <p>Return: if <code>T</code> is a primitive integer type (including <code>bool</code>), the new value of the Watch; else, the old value of the Watch</p> <p><code>fn</code>MUST be safe to call multiple times within a single call to <code>modify</code>. This is because <code>modify</code> may be implemented via an atomic compare-and-swap loop.</p> <p>NOTE: This behavior is acknowledged to be less than ideal and will be fixed in the future to be consistent, regardless of <code>T</code></p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-async_wait","title":"function async_wait","text":"<pre><code>template &lt;typename Handler &gt;\ninline void async_wait(\nconst T &amp; last_seen,\nHandler &amp;&amp; fn\n)\n</code></pre> <p>Invokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: </p> <ul> <li>When the Watch value is not equal to the passed value <code>last_seen</code>, invoke <code>fn</code> with the current value of the Watch.</li> <li>When the Watch is closed, invoke <code>fn</code> with <code>batt::StatusCode::kClosed</code>. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-await_not_equal","title":"function await_not_equal","text":"<pre><code>StatusOr&lt; T &gt; await_not_equal(\nconst T &amp; last_seen\n)\n</code></pre> <p>Blocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. </p> <p>Return: On success, the current value of the Watch, which is guaranteed to not equal <code>last_seen</code>, else <code>batt::StatusCode::kClosed</code> if the Watch was closed before a satisfactory value was observed </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-await_true","title":"function await_true","text":"<pre><code>template &lt;typename Pred &gt;\ninline StatusOr&lt; T &gt; await_true(\nPred &amp;&amp; pred\n)\n</code></pre> <p>Blocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. </p> <p>Return: On success, the Watch value for which <code>pred</code> returned <code>true</code>, else <code>batt::StatusCode::kClosed</code> if the Watch was closed before a satisfactory value was observed </p> <p>This is the most general of Watch's blocking getter methods.</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-clamp_min_value","title":"function clamp_min_value","text":"<pre><code>template &lt;typename OrderFn  =bool(const T&amp;, const T&amp;)&gt;\ninline void clamp_min_value(\nconst T &amp; lower_bound,\nOrderFn &amp;&amp; order_fn\n)\n</code></pre> <p>Modify the value to be at least <code>lower_bound</code>. </p> <p>Parameters: </p> <ul> <li>lower_bound The (inclusive) lower bound value to enforce </li> <li>order_fn A callable object taking two T values and returning bool that returns true iff the first argument is less-than the second. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-clamp_max_value","title":"function clamp_max_value","text":"<pre><code>template &lt;typename OrderFn  =bool(const T&amp;, const T&amp;)&gt;\ninline void clamp_max_value(\nconst T &amp; upper_bound,\nOrderFn &amp;&amp; order_fn\n)\n</code></pre> <p>Modify the value to be at most <code>upper_bound</code>. </p> <p>Parameters: </p> <ul> <li>upper_bound The (inclusive) upper bound value to enforce </li> <li>order_fn A callable object taking two T values and returning bool that returns true iff the first argument is less-than the second. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-clamp_min_value_1","title":"function clamp_min_value","text":"<pre><code>inline void clamp_min_value(\nconst T &amp; lower_bound\n)\n</code></pre> <p>Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. </p>"},{"location":"_autogen/Classes/classbatt_1_1Watch/#function-clamp_max_value_1","title":"function clamp_max_value","text":"<pre><code>inline void clamp_max_value(\nconst T &amp; upper_bound\n)\n</code></pre> <p>Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/","title":"batt::WatchAtomic","text":"<p>Watch for atomic primitive type.  More...</p> <p><code>#include &lt;batteries/async/watch_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-types","title":"Public Types","text":"Name using T value_type"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-functions","title":"Public Functions","text":"Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling."},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-attributes","title":"Public Attributes","text":"Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY)"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::WatchAtomic;\n</code></pre> <p>Watch for atomic primitive type. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#using-value_type","title":"using value_type","text":"<pre><code>using batt::WatchAtomic&lt; T &gt;::value_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic","title":"function WatchAtomic","text":"<pre><code>WatchAtomic(\nconst WatchAtomic &amp; ) =deleted\n</code></pre> <p>Watch is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-operator","title":"function operator=","text":"<pre><code>WatchAtomic &amp; operator=(\nconst WatchAtomic &amp; ) =deleted\n</code></pre> <p>Watch is not copy-constructible. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic_1","title":"function WatchAtomic","text":"<pre><code>WatchAtomic() =default\n</code></pre> <p>Constructs a batt::Watch object with a default-initialized value of <code>T</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic_2","title":"function WatchAtomic","text":"<pre><code>template &lt;typename Init ,\ntypename  =EnableIfNoShadow&lt;WatchAtomic, Init&gt;&gt;\ninline explicit WatchAtomic(\nInit &amp;&amp; init_value\n)\n</code></pre> <p>Constructs a batt::Watch object with the given initial value. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-watchatomic_3","title":"function ~WatchAtomic","text":"<pre><code>inline ~WatchAtomic()\n</code></pre> <p>Destroy the Watch, automatically calling Watch::close. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-close","title":"function close","text":"<pre><code>inline void close(\nStatusCode final_status_code =StatusCode::kClosed\n)\n</code></pre> <p>Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. </p> <p>This method is safe to call multiple times. The Watch value can still be modified and retrieved after it is closed; this only disables the methods in the \"Synchronization\" category (see Summary section above). </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-poke","title":"function poke","text":"<pre><code>inline void poke()\n</code></pre> <p>Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-is_poked","title":"function is_poked","text":"<pre><code>inline bool is_poked() const\n</code></pre> <p>Returns true iff there is a pending poke on this object. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre> <p>Resets the 'closed' status of this Watch. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-is_closed","title":"function is_closed","text":"<pre><code>inline bool is_closed() const\n</code></pre> <p>Tests whether the Watch is in a \"closed\" state. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-set_value","title":"function set_value","text":"<pre><code>inline T set_value(\nT arg,\nHoldOwnership  ={}\n)\n</code></pre> <p>Atomically set the value of the Watch. </p> <p>Return: The prior value of the Watch. </p> <p>NOT safe to call when updating the value may cause the Watch to be destroyed on some other thread.</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-set_value_1","title":"function set_value","text":"<pre><code>inline T set_value(\nT arg,\nReleaseOwnership )\n</code></pre> <p>Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. </p> <p>Using this function instead of <code>set_value</code> probably implies its a bad idea to make any future reference to the Watch object after <code>set_value_and_release</code> returns. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-set_value_and_release","title":"function set_value_and_release","text":"<pre><code>inline T set_value_and_release(\nT new_value\n)\n</code></pre> <p>Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-get_value","title":"function get_value","text":"<pre><code>inline T get_value() const\n</code></pre> <p>The current value of the Watch. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_add","title":"function fetch_add","text":"<pre><code>inline T fetch_add(\nT arg,\nHoldOwnership  ={}\n)\n</code></pre> <p>Atomically adds the specified amount to the Watch value, returning the previous value. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_add_1","title":"function fetch_add","text":"<pre><code>inline T fetch_add(\nT arg,\nReleaseOwnership )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_or","title":"function fetch_or","text":"<pre><code>inline T fetch_or(\nT arg,\nHoldOwnership  ={}\n)\n</code></pre> <p>Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_or_1","title":"function fetch_or","text":"<pre><code>inline T fetch_or(\nT arg,\nReleaseOwnership )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_sub","title":"function fetch_sub","text":"<pre><code>inline T fetch_sub(\nT arg,\nHoldOwnership  ={}\n)\n</code></pre> <p>Atomically subtracts the specified amount from the Watch value, returning the previous value. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_sub_1","title":"function fetch_sub","text":"<pre><code>inline T fetch_sub(\nT arg,\nReleaseOwnership )\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_and","title":"function fetch_and","text":"<pre><code>inline T fetch_and(\nT arg,\nHoldOwnership  ={}\n)\n</code></pre> <p>Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-fetch_and_1","title":"function fetch_and","text":"<pre><code>inline T fetch_and(\nT arg,\nReleaseOwnership )\n</code></pre> <p>Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-modify","title":"function modify","text":"<pre><code>template &lt;typename Fn  =T(T)&gt;\ninline T modify(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Atomically modifies the Watch value by applying the passed transform <code>fn</code>. </p> <p>Return: if <code>T</code> is a primitive integer type (including <code>bool</code>), the new value of the Watch; else, the old value of the Watch</p> <p><code>fn</code>MUST be safe to call multiple times within a single call to <code>modify</code>. This is because <code>modify</code> may be implemented via an atomic compare-and-swap loop.</p> <p>NOTE: This behavior is acknowledged to be less than ideal and will be fixed in the future to be consistent, regardless of <code>T</code></p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-compare_exchange","title":"function compare_exchange","text":"<pre><code>inline bool compare_exchange(\nT &amp; old_value,\nT new_value\n)\n</code></pre> <p>Does an atomic compare-and-swap operation on the Watch value. </p> <p>If the watch is equal to <code>old_value</code>, then it will be set to <code>new_value</code> and this function will return true. Otherwise, <code>old_value</code> will be updated with the observed value and this function will return false. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_modify","title":"function await_modify","text":"<pre><code>template &lt;typename Fn  =Optional&lt;T&gt;(T)&gt;\nStatusOr&lt; T &gt; await_modify(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. </p> <p>Return: </p> <ul> <li>If successful, the old (pre-modify) value on which <code>fn</code> finally succeeded</li> <li><code>batt::StatusCode::kClosed</code> if the Watch was closed before <code>fn</code> was successful </li> </ul> <p>Return the old (pre-modify) value on which <code>fn</code> finally succeeded.</p> <p><code>fn</code> should have the signature (T) -&gt; Optional. Returning None indicates <code>fn</code> should not be called again until a new value is available. <p><code>fn</code>MUST be safe to call multiple times within a single call to <code>await_modify</code>. This is because <code>await_modify</code> may be implemented via an atomic compare-and-swap loop.</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-modify_if","title":"function modify_if","text":"<pre><code>template &lt;typename Fn  =Optional&lt;T&gt;(T)&gt;\ninline Optional&lt; T &gt; modify_if(\nFn &amp;&amp; fn\n)\n</code></pre> <p>Conditionally modify the value of the Watch. </p> <p>Return: The final value returned by <code>fn</code>, which is either <code>batt::None</code> or the new Watch value. </p> <p>Retries calling <code>fn</code> on the Watch value until EITHER of:</p> <ul> <li><code>fn</code> returns <code>batt::None</code></li> <li>BOTH of:<ul> <li><code>fn</code> returns a non-<code>batt::None</code> value</li> <li>the Watch value is atomically updated via compare-and-swap <code>fn</code>MUST be safe to call multiple times within a single call to <code>modify_if</code>. This is because <code>modify_if</code> may be implemented via an atomic compare-and-swap loop.</li> </ul> </li> </ul> <p>Unlike batt::Watch::await_modify, this method never puts the current task/thread to sleep; it keeps actively polling the Watch value until it reaches one of the exit criteria described above.</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-async_wait","title":"function async_wait","text":"<pre><code>template &lt;typename Handler &gt;\ninline void async_wait(\nT last_seen,\nHandler &amp;&amp; fn\n) const\n</code></pre> <p>Invokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: </p> <ul> <li>When the Watch value is not equal to the passed value <code>last_seen</code>, invoke <code>fn</code> with the current value of the Watch.</li> <li>When the Watch is closed, invoke <code>fn</code> with <code>batt::StatusCode::kClosed</code>. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_not_equal","title":"function await_not_equal","text":"<pre><code>StatusOr&lt; T &gt; await_not_equal(\nconst T &amp; last_seen\n) const\n</code></pre> <p>Blocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. </p> <p>Return: On success, the current value of the Watch, which is guaranteed to not equal <code>last_seen</code>, else <code>batt::StatusCode::kClosed</code> if the Watch was closed before a satisfactory value was observed </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_true","title":"function await_true","text":"<pre><code>template &lt;typename Pred &gt;\ninline StatusOr&lt; T &gt; await_true(\nPred &amp;&amp; pred\n) const\n</code></pre> <p>Blocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. </p> <p>Return: On success, the Watch value for which <code>pred</code> returned <code>true</code>, else <code>batt::StatusCode::kClosed</code> if the Watch was closed before a satisfactory value was observed </p> <p>This is the most general of Watch's blocking getter methods.</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-await_equal","title":"function await_equal","text":"<pre><code>inline Status await_equal(\nT val\n) const\n</code></pre> <p>Blocks the current task/thread until the Watch contains the specified value. </p> <p>Return: One of the following:</p> <ul> <li><code>batt::OkStatus()</code> if the Watch value was observed to be <code>val</code></li> <li><code>batt::StatusCode::kClosed</code> if the Watch was closed before <code>val</code> was observed </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-clamp_min_value","title":"function clamp_min_value","text":"<pre><code>template &lt;typename OrderFn  =bool(T, T)&gt;\ninline void clamp_min_value(\nT lower_bound,\nOrderFn &amp;&amp; order_fn\n)\n</code></pre> <p>Modify the value to be at least <code>lower_bound</code>. </p> <p>Parameters: </p> <ul> <li>lower_bound The (inclusive) lower bound value to enforce </li> <li>order_fn A callable object taking two T values and returning bool that returns true iff the first argument is less-than the second. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-clamp_max_value","title":"function clamp_max_value","text":"<pre><code>template &lt;typename OrderFn  =bool(T, T)&gt;\ninline void clamp_max_value(\nT upper_bound,\nOrderFn &amp;&amp; order_fn\n)\n</code></pre> <p>Modify the value to be at most <code>upper_bound</code>. </p> <p>Parameters: </p> <ul> <li>upper_bound The (inclusive) upper bound value to enforce </li> <li>order_fn A callable object taking two T values and returning bool that returns true iff the first argument is less-than the second. </li> </ul>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-clamp_min_value_1","title":"function clamp_min_value","text":"<pre><code>inline void clamp_min_value(\nT lower_bound\n)\n</code></pre> <p>Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-clamp_max_value_1","title":"function clamp_max_value","text":"<pre><code>inline void clamp_max_value(\nT upper_bound\n)\n</code></pre> <p>Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#function-poll","title":"function poll","text":"<pre><code>T poll()\n</code></pre> <p>Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-klocked","title":"variable kLocked","text":"<pre><code>static constexpr u32 kLocked = 0x01;\n</code></pre> <p>(INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kopen","title":"variable kOpen","text":"<pre><code>static constexpr u32 kOpen = 0x02;\n</code></pre> <p>(INTERNAL USE ONLY) indicates that the Watch is not closed. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kwaiting","title":"variable kWaiting","text":"<pre><code>static constexpr u32 kWaiting = 0x04;\n</code></pre> <p>(INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kclosedatend","title":"variable kClosedAtEnd","text":"<pre><code>static constexpr u32 kClosedAtEnd = 0x08;\n</code></pre> <p>(INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kclosedbeforeend","title":"variable kClosedBeforeEnd","text":"<pre><code>static constexpr u32 kClosedBeforeEnd = 0x10;\n</code></pre> <p>(INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false </p>"},{"location":"_autogen/Classes/classbatt_1_1WatchAtomic/#variable-kpoked","title":"variable kPoked","text":"<pre><code>static constexpr u32 kPoked = 0x20;\n</code></pre> <p>(INTERNAL USE ONLY) </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/","title":"batt::WatchExporter","text":"<p>More...</p> <p>Inherits from batt::MetricExporter</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#public-functions","title":"Public Functions","text":"Name WatchExporter(const std::string &amp; name, Watch&lt; T &gt; &amp; watch) virtual Token get_name() const override virtual double get_value() const override"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::MetricExporter</p> Name MetricExporter(const MetricExporter &amp; ) =deleted MetricExporter &amp; operator=(const MetricExporter &amp; ) =deleted virtual ~MetricExporter() =default virtual std::string_view get_description() const virtual std::string_view get_type() const virtual const MetricLabelSet &amp; get_labels() const virtual void set_labels(MetricLabelSet &amp;&amp; labels) <p>Protected Functions inherited from batt::MetricExporter</p> Name MetricExporter() =default"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::WatchExporter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#function-watchexporter","title":"function WatchExporter","text":"<pre><code>inline explicit WatchExporter(\nconst std::string &amp; name,\nWatch&lt; T &gt; &amp; watch\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#function-get_name","title":"function get_name","text":"<pre><code>inline virtual Token get_name() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_name</p>"},{"location":"_autogen/Classes/classbatt_1_1WatchExporter/#function-get_value","title":"function get_value","text":"<pre><code>inline virtual double get_value() const override\n</code></pre> <p>Reimplements: batt::MetricExporter::get_value</p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/","title":"batt::Watch&lt; T * &gt;","text":"<p>More...</p> <p>Inherits from batt::WatchAtomic&lt; void * &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#public-types","title":"Public Types","text":"Name using WatchAtomic&lt; void * &gt; Super"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#public-functions","title":"Public Functions","text":"Name Watch() =default Watch(T * init_value) T * set_value(T * new_value) T * set_value_and_release(T * new_value) T * get_value() const template &lt;typename Fn  =T(T)&gt; T * modify(Fn &amp;&amp; fn) template &lt;typename Fn  =Optional(T*)&gt; StatusOr&lt; T * &gt; await_modify(Fn &amp;&amp; fn) template &lt;typename Fn  =Optional(T*)&gt; Optional&lt; T * &gt; modify_if(Fn &amp;&amp; fn) StatusOr&lt; T * &gt; await_not_equal(T * old_value)"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; void * &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; void * &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; void * &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY)"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::Watch&lt; T * &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#using-super","title":"using Super","text":"<pre><code>using batt::Watch&lt; T * &gt;::Super =  WatchAtomic&lt;void*&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-watch","title":"function Watch","text":"<pre><code>Watch() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-watch_1","title":"function Watch","text":"<pre><code>inline explicit Watch(\nT * init_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-set_value","title":"function set_value","text":"<pre><code>inline T * set_value(\nT * new_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-set_value_and_release","title":"function set_value_and_release","text":"<pre><code>inline T * set_value_and_release(\nT * new_value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-get_value","title":"function get_value","text":"<pre><code>inline T * get_value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-modify","title":"function modify","text":"<pre><code>template &lt;typename Fn  =T*(T*)&gt;\ninline T * modify(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-await_modify","title":"function await_modify","text":"<pre><code>template &lt;typename Fn  =Optional&lt;T*&gt;(T*)&gt;\ninline StatusOr&lt; T * &gt; await_modify(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-modify_if","title":"function modify_if","text":"<pre><code>template &lt;typename Fn  =Optional&lt;T*&gt;(T*)&gt;\ninline Optional&lt; T * &gt; modify_if(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01T_01_5_01_4/#function-await_not_equal","title":"function await_not_equal","text":"<pre><code>inline StatusOr&lt; T * &gt; await_not_equal(\nT * old_value\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01bool_01_4/","title":"batt::Watch&lt; bool &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; bool &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01bool_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; bool &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; bool &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; bool &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i16_01_4/","title":"batt::Watch&lt; i16 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; i16 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i16_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; i16 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; i16 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; i16 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i32_01_4/","title":"batt::Watch&lt; i32 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; i32 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i32_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; i32 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; i32 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; i32 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i64_01_4/","title":"batt::Watch&lt; i64 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; i64 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i64_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; i64 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; i64 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; i64 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i8_01_4/","title":"batt::Watch&lt; i8 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; i8 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01i8_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; i8 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; i8 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; i8 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u16_01_4/","title":"batt::Watch&lt; u16 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; u16 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u16_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; u16 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; u16 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; u16 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u32_01_4/","title":"batt::Watch&lt; u32 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; u32 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u32_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; u32 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; u32 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; u32 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u64_01_4/","title":"batt::Watch&lt; u64 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; u64 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u64_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; u64 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; u64 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; u64 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u8_01_4/","title":"batt::Watch&lt; u8 &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; u8 &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01u8_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; u8 &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; u8 &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; u8 &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01void_01_5_01_4/","title":"batt::Watch&lt; void * &gt;","text":"<p>Inherits from batt::WatchAtomic&lt; void * &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1Watch_3_01void_01_5_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::WatchAtomic&lt; void * &gt;</p> Name using T value_type <p>Public Functions inherited from batt::WatchAtomic&lt; void * &gt;</p> Name WatchAtomic(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic &amp; operator=(const WatchAtomic &amp; ) =deletedWatch is not copy-constructible. WatchAtomic() =defaultConstructs a batt::Watch object with a default-initialized value of <code>T</code>. template &lt;typename Init ,typename  =EnableIfNoShadow&gt;  WatchAtomic(Init &amp;&amp; init_value)Constructs a batt::Watch object with the given initial value. ~WatchAtomic()Destroy the Watch, automatically calling Watch::close. void close(StatusCode final_status_code =StatusCode::kClosed)Set the Watch to the \"closed\" state, which disables all blocking/async synchronization on the Watch, immediately unblocking any currently waiting tasks/threads. void poke()Wakes up all observers of this Watch, invoking their handlers with StatusCode::kPoke to indicate they should check their current situation and possibly retry. bool is_poked() constReturns true iff there is a pending poke on this object. void reset()Resets the 'closed' status of this Watch. bool is_closed() constTests whether the Watch is in a \"closed\" state. T set_value(T arg, HoldOwnership  ={})Atomically set the value of the Watch. T set_value(T arg, ReleaseOwnership )Same as set_value, but safe to call even when setting the value may cause the Watch object to be destroyed. T set_value_and_release(T new_value)Deprecated; use <code>this-&gt;set_value(x, [ReleaseOwnership](/_autogen/Classes/structbatt_1_1ReleaseOwnership/){})</code>. T get_value() constThe current value of the Watch. T fetch_add(T arg, HoldOwnership  ={})Atomically adds the specified amount to the Watch value, returning the previous value. T fetch_add(T arg, ReleaseOwnership ) T fetch_or(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-or of the current value and the passed <code>arg</code>, returning the previous value. T fetch_or(T arg, ReleaseOwnership ) T fetch_sub(T arg, HoldOwnership  ={})Atomically subtracts the specified amount from the Watch value, returning the previous value. T fetch_sub(T arg, ReleaseOwnership ) T fetch_and(T arg, HoldOwnership  ={})Atomically sets the Watch value to the bitwise-and of the current value and the passed <code>arg</code>, returning the previous value. T fetch_and(T arg, ReleaseOwnership )Same as <code>this-&gt;fetch_add(arg)</code>, but safe to call when this modification might cause the Watch object to be destroyed. template &lt;typename Fn  =T(T)&gt; T modify(Fn &amp;&amp; fn)Atomically modifies the Watch value by applying the passed transform <code>fn</code>. bool compare_exchange(T &amp; old_value, T new_value)Does an atomic compare-and-swap operation on the Watch value. template &lt;typename Fn  =Optional(T)&gt; StatusOr&lt; T &gt; await_modify(Fn &amp;&amp; fn)Retries <code>fn</code> on the watch value until it succeeds or the watch is closed. template &lt;typename Fn  =Optional(T)&gt; Optional&lt; T &gt; modify_if(Fn &amp;&amp; fn)Conditionally modify the value of the Watch. template &lt;typename Handler &gt; void async_wait(T last_seen, Handler &amp;&amp; fn) constInvokes the passed handler <code>fn</code> with the described value as soon as one of the following conditions is true: StatusOr&lt; T &gt; await_not_equal(const T &amp; last_seen) constBlocks the current task/thread until the Watch value is not equal to <code>last_seen</code>. template &lt;typename Pred &gt; StatusOr&lt; T &gt; await_true(Pred &amp;&amp; pred) constBlocks the current task/thread until the passed predicate function returns <code>true</code> for the current value of the Watch. Status await_equal(T val) constBlocks the current task/thread until the Watch contains the specified value. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_min_value(T lower_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at least <code>lower_bound</code>. template &lt;typename OrderFn  =bool(T, T)&gt; void clamp_max_value(T upper_bound, OrderFn &amp;&amp; order_fn)Modify the value to be at most <code>upper_bound</code>. void clamp_min_value(T lower_bound)Modify the value to be at least <code>lower_bound</code>, using the default ordering for T. void clamp_max_value(T upper_bound)Modify the value to be at most <code>upper_bound</code>, using the default ordering for T. T poll()Yields control of the current task to allow other tasks to potentially modify this Watch, returning the post-resume value of this; for busy-polling. <p>Public Attributes inherited from batt::WatchAtomic&lt; void * &gt;</p> Name constexpr u32 kLocked (INTERNAL USE ONLY) spin-lock bit - indicates the state variable is locked. constexpr u32 kOpen (INTERNAL USE ONLY) indicates that the Watch is not closed. constexpr u32 kWaiting (INTERNAL USE ONLY) indicates that one or more handlers are attached to the Watch, awaiting change notification. constexpr u32 kClosedAtEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition true constexpr u32 kClosedBeforeEnd (INTERNAL USE ONLY) indicates the Watch was closed with end-of-stream condition false constexpr u32 kPoked (INTERNAL USE ONLY) <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/","title":"batt::WorkContext","text":"<p>Inherited by batt::ScopedWorkContext</p>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#public-functions","title":"Public Functions","text":"Name WorkContext(const WorkContext &amp; ) =deleted WorkContext &amp; operator=(const WorkContext &amp; ) =deleted WorkContext(WorkerPool &amp; worker_pool) template &lt;typename Fn &gt; decltype(auto) async_run(Fn &amp;&amp; work_fn) void on_work_started() void on_work_finished() void await_done()"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-workcontext","title":"function WorkContext","text":"<pre><code>WorkContext(\nconst WorkContext &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-operator","title":"function operator=","text":"<pre><code>WorkContext &amp; operator=(\nconst WorkContext &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-workcontext_1","title":"function WorkContext","text":"<pre><code>inline explicit WorkContext(\nWorkerPool &amp; worker_pool\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-async_run","title":"function async_run","text":"<pre><code>template &lt;typename Fn &gt;\ninline decltype(auto) async_run(\nFn &amp;&amp; work_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-on_work_started","title":"function on_work_started","text":"<pre><code>inline void on_work_started()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-on_work_finished","title":"function on_work_finished","text":"<pre><code>inline void on_work_finished()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkContext/#function-await_done","title":"function await_done","text":"<pre><code>inline void await_done()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1Worker/","title":"batt::Worker","text":""},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-types","title":"Public Types","text":"Name using batt::UniqueSmallFn&lt; void(), 256 - 16 &gt; WorkFn"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-functions","title":"Public Functions","text":"Name Worker(boost::asio::any_io_executor ex, std::string &amp;&amp; name =\"Worker::task\")"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-attributes","title":"Public Attributes","text":"Name batt::Queue&lt; WorkFn &gt; work_queue batt::Task task"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Worker/#using-workfn","title":"using WorkFn","text":"<pre><code>using batt::Worker::WorkFn =  batt::UniqueSmallFn&lt;void(), 256 - 16&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Worker/#function-worker","title":"function Worker","text":"<pre><code>inline explicit Worker(\nboost::asio::any_io_executor ex,\nstd::string &amp;&amp; name =\"Worker::task\"\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Worker/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1Worker/#variable-work_queue","title":"variable work_queue","text":"<pre><code>batt::Queue&lt; WorkFn &gt; work_queue;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1Worker/#variable-task","title":"variable task","text":"<pre><code>batt::Task task;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/","title":"batt::WorkerPool","text":""},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#public-functions","title":"Public Functions","text":"Name WorkerPool &amp; default_pool() WorkerPool &amp; null_pool() WorkerPool(usize size, TaskScheduler &amp; scheduler) WorkerPool(std::vector&lt; std::unique_ptr&lt; Worker &gt;&gt; &amp;&amp; workers) template &lt;typename Fn &gt; Status async_run(Fn &amp;&amp; fn) void reset(usize phase_shift =0) usize size() const void halt() void join() ~WorkerPool()"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-default_pool","title":"function default_pool","text":"<pre><code>static inline WorkerPool &amp; default_pool()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-null_pool","title":"function null_pool","text":"<pre><code>static inline WorkerPool &amp; null_pool()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-workerpool","title":"function WorkerPool","text":"<pre><code>inline explicit WorkerPool(\nusize size,\nTaskScheduler &amp; scheduler\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-workerpool_1","title":"function WorkerPool","text":"<pre><code>inline explicit WorkerPool(\nstd::vector&lt; std::unique_ptr&lt; Worker &gt;&gt; &amp;&amp; workers\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-async_run","title":"function async_run","text":"<pre><code>template &lt;typename Fn &gt;\ninline Status async_run(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-reset","title":"function reset","text":"<pre><code>inline void reset(\nusize phase_shift =0\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1WorkerPool/#function-workerpool_2","title":"function ~WorkerPool","text":"<pre><code>inline ~WorkerPool()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/","title":"batt::detail::AbstractCopyFn","text":"<p>More...</p> <p>Inherits from batt::detail::AbstractMoveFn&lt; false, Result, Args... &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#public-functions","title":"Public Functions","text":"Name virtual auto copy(void * memory, usize size) const =0 virtual auto copy_to_move_only(void * memory, usize size) const =0"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::detail::AbstractMoveFn&lt; false, Result, Args... &gt;</p> Name AbstractMoveFn(const AbstractMoveFn &amp; ) =deleted AbstractMoveFn &amp; operator=(const AbstractMoveFn &amp; ) =deleted virtual ~AbstractMoveFn() =default virtual auto invoke(Args... args) =0 virtual auto move(void * storage, usize size) =0 <p>Protected Functions inherited from batt::detail::AbstractMoveFn&lt; false, Result, Args... &gt;</p> Name AbstractMoveFn() =default"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Result ,\ntypename... Args&gt;\nclass batt::detail::AbstractCopyFn;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#function-copy","title":"function copy","text":"<pre><code>virtual auto copy(\nvoid * memory,\nusize size\n) const =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractCopyFn/#function-copy_to_move_only","title":"function copy_to_move_only","text":"<pre><code>virtual auto copy_to_move_only(\nvoid * memory,\nusize size\n) const =0\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/","title":"batt::detail::AbstractMoveFn","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#public-functions","title":"Public Functions","text":"Name AbstractMoveFn(const AbstractMoveFn &amp; ) =deleted AbstractMoveFn &amp; operator=(const AbstractMoveFn &amp; ) =deleted virtual ~AbstractMoveFn() =default virtual auto invoke(Args... args) =0 virtual auto move(void * storage, usize size) =0"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#protected-functions","title":"Protected Functions","text":"Name AbstractMoveFn() =default"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;bool kMoveOnly,\ntypename Result ,\ntypename... Args&gt;\nclass batt::detail::AbstractMoveFn;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-abstractmovefn","title":"function AbstractMoveFn","text":"<pre><code>AbstractMoveFn(\nconst AbstractMoveFn &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-operator","title":"function operator=","text":"<pre><code>AbstractMoveFn &amp; operator=(\nconst AbstractMoveFn &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-abstractmovefn_1","title":"function ~AbstractMoveFn","text":"<pre><code>virtual ~AbstractMoveFn() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-invoke","title":"function invoke","text":"<pre><code>virtual auto invoke(\nArgs... args\n) =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-move","title":"function move","text":"<pre><code>virtual auto move(\nvoid * storage,\nusize size\n) =0\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AbstractMoveFn/#function-abstractmovefn_2","title":"function AbstractMoveFn","text":"<pre><code>AbstractMoveFn() =default\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/","title":"batt::detail::AllocFnWrapper","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#public-types","title":"Public Types","text":"Name using AllocFnWrapper Self using std::conditional_t&lt; kMoveOnly, std::unique_ptr&lt; Fn &gt;, std::shared_ptr&lt; Fn &gt; &gt; Pointer"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#public-functions","title":"Public Functions","text":"Name template &lt;typename... FnInit&gt; Pointer wrap_fn(std::true_type , FnInit &amp;&amp;... init) template &lt;typename... FnInit&gt; Pointer wrap_fn(std::false_type , FnInit &amp;&amp;... init) template &lt;typename... FnInit&gt;  AllocFnWrapper(FnInit &amp;&amp;... init) AllocFnWrapper(const AllocFnWrapper &amp; ) =default AllocFnWrapper &amp; operator=(const AllocFnWrapper &amp; ) =default AllocFnWrapper(AllocFnWrapper &amp;&amp; ) =default AllocFnWrapper &amp; operator=(AllocFnWrapper &amp;&amp; ) =default Result operator()(Args... args) const"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#public-attributes","title":"Public Attributes","text":"Name constexpr std::integral_constant&lt; bool, kMoveOnly &gt; move_only"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn ,\nbool kMoveOnly,\ntypename Result ,\ntypename... Args&gt;\nclass batt::detail::AllocFnWrapper;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#using-self","title":"using Self","text":"<pre><code>using batt::detail::AllocFnWrapper&lt; Fn, kMoveOnly, Result, Args &gt;::Self =  AllocFnWrapper;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#using-pointer","title":"using Pointer","text":"<pre><code>using batt::detail::AllocFnWrapper&lt; Fn, kMoveOnly, Result, Args &gt;::Pointer =  std::conditional_t&lt;kMoveOnly, std::unique_ptr&lt;Fn&gt;, std::shared_ptr&lt;Fn&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-wrap_fn","title":"function wrap_fn","text":"<pre><code>template &lt;typename... FnInit&gt;\nstatic inline Pointer wrap_fn(\nstd::true_type ,\nFnInit &amp;&amp;... init\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-wrap_fn_1","title":"function wrap_fn","text":"<pre><code>template &lt;typename... FnInit&gt;\nstatic inline Pointer wrap_fn(\nstd::false_type ,\nFnInit &amp;&amp;... init\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-allocfnwrapper","title":"function AllocFnWrapper","text":"<pre><code>template &lt;typename... FnInit&gt;\ninline explicit AllocFnWrapper(\nFnInit &amp;&amp;... init\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-allocfnwrapper_1","title":"function AllocFnWrapper","text":"<pre><code>AllocFnWrapper(\nconst AllocFnWrapper &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-operator","title":"function operator=","text":"<pre><code>AllocFnWrapper &amp; operator=(\nconst AllocFnWrapper &amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-allocfnwrapper_2","title":"function AllocFnWrapper","text":"<pre><code>AllocFnWrapper(\nAllocFnWrapper &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-operator_1","title":"function operator=","text":"<pre><code>AllocFnWrapper &amp; operator=(\nAllocFnWrapper &amp;&amp; ) =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#function-operator_2","title":"function operator()","text":"<pre><code>inline Result operator()(\nArgs... args\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1AllocFnWrapper/#variable-move_only","title":"variable move_only","text":"<pre><code>static constexpr std::integral_constant&lt; bool, kMoveOnly &gt; move_only = {};\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/","title":"batt::detail::CopyFnImpl","text":"<p>More...</p> <p>Inherits from batt::detail::MoveFnImpl&lt; Fn, false, Result, Args... &gt;, AbstractFn&lt; kMoveOnly, Result, Args... &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-types","title":"Public Types","text":"Name using CopyFnImpl self_type"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-functions","title":"Public Functions","text":"Name AbstractFn&lt; false, Result, Args... &gt; * copy(void * memory, usize size) const override AbstractFn&lt; true, Result, Args... &gt; * copy_to_move_only(void * memory, usize size) const override"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::detail::MoveFnImpl&lt; Fn, false, Result, Args... &gt;</p> Name template &lt;typename FnRef &gt;  MoveFnImpl(FnRef &amp;&amp; ref) Result invoke(Args... args) override AbstractFn&lt; kMoveOnly, Result, Args... &gt; * move(void * memory, usize size) override <p>Protected Attributes inherited from batt::detail::MoveFnImpl&lt; Fn, false, Result, Args... &gt;</p> Name Fn fn_"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn ,\ntypename Result ,\ntypename... Args&gt;\nclass batt::detail::CopyFnImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#using-self_type","title":"using self_type","text":"<pre><code>using batt::detail::CopyFnImpl&lt; Fn, Result, Args &gt;::self_type =  CopyFnImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#function-copy","title":"function copy","text":"<pre><code>inline AbstractFn&lt; false, Result, Args... &gt; * copy(\nvoid * memory,\nusize size\n) const override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1CopyFnImpl/#function-copy_to_move_only","title":"function copy_to_move_only","text":"<pre><code>inline AbstractFn&lt; true, Result, Args... &gt; * copy_to_move_only(\nvoid * memory,\nusize size\n) const override\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1FutureImpl/","title":"batt::detail::FutureImpl","text":"<p>More...</p> <p>Inherits from batt::Latch&lt; T &gt;, batt::RefCounted&lt; Latch&lt; T &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1FutureImpl/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from batt::Latch&lt; T &gt;</p> Name class AsyncGetHandler <p>Public Types inherited from batt::Latch&lt; T &gt;</p> Name enum u32 State { kInitial, kSetting, kReady}The possible states for the Latch. <p>Public Functions inherited from batt::Latch&lt; T &gt;</p> Name Latch() =defaultDefault-constructs an empty Latch. Latch(const Latch &amp; ) =deletedLatch is not copy/move-constructible. Latch &amp; operator=(const Latch &amp; ) =deletedLatch is not copy/move-assignable. bool set_error(const batt::Status &amp; status)Sets the Latch to an error status value. template &lt;typename... Args&gt; bool set_value(Args &amp;&amp;... args)Sets the value, closing the latch. bool is_ready() constReturns true iff the latch is in the ready state. StatusOr&lt; T &gt; await()Block the current task until the Latch is ready, then return the set value (or Status). StatusOr&lt; T &gt; await()Block the current task until the Latch is ready, then return the set value (or Status) via move. StatusOr&lt; T &gt; poll()Same as await(), except this method never blocks; if the Latch isn't ready yet, it immediately returns <code>StatusCode::kUnavailable</code>. StatusOr&lt; T &gt; get_ready_value_or_panic()Returns the value of the Latch (non-blocking), panicking if it is not in the ready state. StatusOr&lt; T &gt; get_ready_value_or_panic()Returns the value of the Latch (non-blocking) via move, panicking if it is not in the ready state. template &lt;typename Handler &gt; void async_get(Handler &amp;&amp; handler)Invokes <code>handler</code> when the Latch value is set (i.e., when it enters the ready state); invokes handler immediately if the Latch is ready when this method is called. void invalidate()Force the latch into an invalid state (for testing mostly)."},{"location":"_autogen/Classes/classbatt_1_1detail_1_1FutureImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::detail::FutureImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/","title":"batt::detail::HttpClientRequestContext","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#public-functions","title":"Public Functions","text":"Name HttpClientRequestContext() Status set_params() template &lt;typename... Rest&gt; Status set_params(const HttpHeader &amp; hdr, Rest &amp;&amp;... rest) template &lt;typename... Rest&gt; Status set_params(HttpData &amp;&amp; data, Rest &amp;&amp;... rest) template &lt;typename... Rest&gt; Status set_params(HttpClient &amp; client, Rest &amp;&amp;... rest) template &lt;typename... Rest&gt; Status set_params(HttpResponse * response, Rest &amp;&amp;... rest) template &lt;typename... Rest&gt; Status set_params(const HttpVersion &amp; version, Rest &amp;&amp;... rest) Status set_version(const HttpVersion &amp; version) Status set_method(std::string_view method) Status set_path(std::string_view path) Status set_url(const UrlParse &amp; url) void set_header(const HttpHeader &amp; hdr) void set_data(HttpData &amp;&amp; data) HttpResponse * get_response_object() const void set_response_object(HttpResponse * response) const HttpRequest * get_request_object() const HttpRequest * get_request_object() Status submit()"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-httpclientrequestcontext","title":"function HttpClientRequestContext","text":"<pre><code>inline explicit HttpClientRequestContext()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params","title":"function set_params","text":"<pre><code>inline Status set_params()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_1","title":"function set_params","text":"<pre><code>template &lt;typename... Rest&gt;\ninline Status set_params(\nconst HttpHeader &amp; hdr,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_2","title":"function set_params","text":"<pre><code>template &lt;typename... Rest&gt;\ninline Status set_params(\nHttpData &amp;&amp; data,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_3","title":"function set_params","text":"<pre><code>template &lt;typename... Rest&gt;\ninline Status set_params(\nHttpClient &amp; client,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_4","title":"function set_params","text":"<pre><code>template &lt;typename... Rest&gt;\ninline Status set_params(\nHttpResponse * response,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_params_5","title":"function set_params","text":"<pre><code>template &lt;typename... Rest&gt;\ninline Status set_params(\nconst HttpVersion &amp; version,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_version","title":"function set_version","text":"<pre><code>inline Status set_version(\nconst HttpVersion &amp; version\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_method","title":"function set_method","text":"<pre><code>inline Status set_method(\nstd::string_view method\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_path","title":"function set_path","text":"<pre><code>inline Status set_path(\nstd::string_view path\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_url","title":"function set_url","text":"<pre><code>inline Status set_url(\nconst UrlParse &amp; url\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_header","title":"function set_header","text":"<pre><code>inline void set_header(\nconst HttpHeader &amp; hdr\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_data","title":"function set_data","text":"<pre><code>inline void set_data(\nHttpData &amp;&amp; data\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-get_response_object","title":"function get_response_object","text":"<pre><code>inline HttpResponse * get_response_object() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-set_response_object","title":"function set_response_object","text":"<pre><code>inline void set_response_object(\nHttpResponse * response\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-get_request_object","title":"function get_request_object","text":"<pre><code>inline const HttpRequest * get_request_object() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-get_request_object_1","title":"function get_request_object","text":"<pre><code>inline HttpRequest * get_request_object()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1HttpClientRequestContext/#function-submit","title":"function submit","text":"<pre><code>inline Status submit()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/","title":"batt::detail::MoveFnImpl","text":"<p>More...</p> <p>Inherits from AbstractFn&lt; kMoveOnly, Result, Args... &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-types","title":"Public Types","text":"Name using MoveFnImpl self_type"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-functions","title":"Public Functions","text":"Name template &lt;typename FnRef &gt;  MoveFnImpl(FnRef &amp;&amp; ref) Result invoke(Args... args) override AbstractFn&lt; kMoveOnly, Result, Args... &gt; * move(void * memory, usize size) override"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#protected-attributes","title":"Protected Attributes","text":"Name Fn fn_"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn ,\nbool kMoveOnly,\ntypename Result ,\ntypename... Args&gt;\nclass batt::detail::MoveFnImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#using-self_type","title":"using self_type","text":"<pre><code>using batt::detail::MoveFnImpl&lt; Fn, kMoveOnly, Result, Args &gt;::self_type =  MoveFnImpl;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#function-movefnimpl","title":"function MoveFnImpl","text":"<pre><code>template &lt;typename FnRef &gt;\ninline explicit MoveFnImpl(\nFnRef &amp;&amp; ref\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#function-invoke","title":"function invoke","text":"<pre><code>inline Result invoke(\nArgs... args\n) override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#function-move","title":"function move","text":"<pre><code>inline AbstractFn&lt; kMoveOnly, Result, Args... &gt; * move(\nvoid * memory,\nusize size\n) override\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1MoveFnImpl/#variable-fn_","title":"variable fn_","text":"<pre><code>Fn fn_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/","title":"batt::detail::NotOkStatusWrapper","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#public-functions","title":"Public Functions","text":"Name NotOkStatusWrapper(usize this_size, const char * file, int line, const Status &amp; status, bool vlog_is_on) ~NotOkStatusWrapper() operator Status() template &lt;typename T &gt;  operator StatusOr&lt; T &gt;() NotOkStatusWrapper &amp; operator&lt;&lt;(LogLevel new_level) template &lt;typename T &gt; NotOkStatusWrapper &amp; operator&lt;&lt;(T &amp;&amp; val)"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-notokstatuswrapper","title":"function NotOkStatusWrapper","text":"<pre><code>inline explicit NotOkStatusWrapper(\nusize this_size,\nconst char * file,\nint line,\nconst Status &amp; status,\nbool vlog_is_on\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-notokstatuswrapper_1","title":"function ~NotOkStatusWrapper","text":"<pre><code>inline ~NotOkStatusWrapper()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator-status","title":"function operator Status","text":"<pre><code>inline operator Status()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator-statusor-t","title":"function operator StatusOr&lt; T &gt;","text":"<pre><code>template &lt;typename T &gt;\ninline operator StatusOr&lt; T &gt;()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline NotOkStatusWrapper &amp; operator&lt;&lt;(\nLogLevel new_level\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1NotOkStatusWrapper/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline NotOkStatusWrapper &amp; operator&lt;&lt;(\nT &amp;&amp; val\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalBase/","title":"batt::detail::OptionalBase","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalBase/#protected-functions","title":"Protected Functions","text":"Name void * storage_address() const void * storage_address() const"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::detail::OptionalBase;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalBase/#function-storage_address","title":"function storage_address","text":"<pre><code>inline void * storage_address()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalBase/#function-storage_address_1","title":"function storage_address","text":"<pre><code>inline const void * storage_address() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalEmptyBase/","title":"batt::detail::OptionalEmptyBase","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalEmptyBase/#protected-functions","title":"Protected Functions","text":"Name void * storage_address() const void * storage_address() const"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalEmptyBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::detail::OptionalEmptyBase;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalEmptyBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalEmptyBase/#function-storage_address","title":"function storage_address","text":"<pre><code>inline void * storage_address()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1OptionalEmptyBase/#function-storage_address_1","title":"function storage_address","text":"<pre><code>inline const void * storage_address() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/","title":"batt::detail::ParallelModelCheckState","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-types","title":"Public Types","text":"Name using ModelCheckShardMetrics ShardMetrics"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-functions","title":"Public Functions","text":"Name ParallelModelCheckState(usize n_shards) usize find_shard(const Branch &amp; branch) const void send(usize src_i, usize dst_i, Branch &amp;&amp; branch) void flush_all(usize src_i) void queue_push(usize dst_i, std::vector&lt; Branch &gt; * branch) StatusOr&lt; usize &gt; recv(usize shard_i, std::deque&lt; Branch &gt; &amp; local_queue) void close_all(usize shard_i, bool allow_pending =false) void finished(usize shard_i) ShardMetrics &amp; metrics(usize shard_i) Status wait_for_other_shards()"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-attributes","title":"Public Attributes","text":"Name constexpr u64 kStallEpochUnit constexpr u64 kStallCountMask constexpr u64 kStallEpochMask const usize shard_count const usize hash_space_per_shard Watch&lt; usize &gt; barrier_ std::atomic&lt; i64 &gt; queue_push_count std::atomic&lt; i64 &gt; queue_pop_count std::vector&lt; std::unique_ptr&lt; std::atomic&lt; bool &gt;[]&gt; &gt; stalled std::vector&lt; std::unique_ptr&lt; Queue&lt; std::vector&lt; Branch &gt; &gt; &gt; &gt; recv_queues std::vector&lt; CpuCacheLineIsolated&lt; std::vector&lt; std::vector&lt; Branch &gt; &gt; &gt; &gt; send_queues std::vector&lt; CpuCacheLineIsolated&lt; ShardMetrics &gt; &gt; shard_metrics CpuCacheLineIsolated&lt; std::atomic&lt; i64 &gt; &gt; total_pending_count std::vector&lt; CpuCacheLineIsolated&lt; i64 &gt; &gt; local_consume_count"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Branch &gt;\nclass batt::detail::ParallelModelCheckState;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#using-shardmetrics","title":"using ShardMetrics","text":"<pre><code>using batt::detail::ParallelModelCheckState&lt; Branch &gt;::ShardMetrics =  ModelCheckShardMetrics;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-parallelmodelcheckstate","title":"function ParallelModelCheckState","text":"<pre><code>inline explicit ParallelModelCheckState(\nusize n_shards\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-find_shard","title":"function find_shard","text":"<pre><code>inline usize find_shard(\nconst Branch &amp; branch\n) const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-send","title":"function send","text":"<pre><code>inline void send(\nusize src_i,\nusize dst_i,\nBranch &amp;&amp; branch\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-flush_all","title":"function flush_all","text":"<pre><code>inline void flush_all(\nusize src_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-queue_push","title":"function queue_push","text":"<pre><code>inline void queue_push(\nusize dst_i,\nstd::vector&lt; Branch &gt; * branch\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-recv","title":"function recv","text":"<pre><code>inline StatusOr&lt; usize &gt; recv(\nusize shard_i,\nstd::deque&lt; Branch &gt; &amp; local_queue\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-close_all","title":"function close_all","text":"<pre><code>inline void close_all(\nusize shard_i,\nbool allow_pending =false\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-finished","title":"function finished","text":"<pre><code>inline void finished(\nusize shard_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-metrics","title":"function metrics","text":"<pre><code>inline ShardMetrics &amp; metrics(\nusize shard_i\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#function-wait_for_other_shards","title":"function wait_for_other_shards","text":"<pre><code>inline Status wait_for_other_shards()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-kstallepochunit","title":"variable kStallEpochUnit","text":"<pre><code>static constexpr u64 kStallEpochUnit = u64{1} &lt;&lt; 32;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-kstallcountmask","title":"variable kStallCountMask","text":"<pre><code>static constexpr u64 kStallCountMask = kStallEpochUnit - 1;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-kstallepochmask","title":"variable kStallEpochMask","text":"<pre><code>static constexpr u64 kStallEpochMask = ~kStallCountMask;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-shard_count","title":"variable shard_count","text":"<pre><code>const usize shard_count;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-hash_space_per_shard","title":"variable hash_space_per_shard","text":"<pre><code>const usize hash_space_per_shard = std::numeric_limits&lt;usize&gt;::max() / this-&gt;shard_count;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-barrier_","title":"variable barrier_","text":"<pre><code>Watch&lt; usize &gt; barrier_ {this-&gt;shard_count};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-queue_push_count","title":"variable queue_push_count","text":"<pre><code>std::atomic&lt; i64 &gt; queue_push_count {0};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-queue_pop_count","title":"variable queue_pop_count","text":"<pre><code>std::atomic&lt; i64 &gt; queue_pop_count {0};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-stalled","title":"variable stalled","text":"<pre><code>std::vector&lt; std::unique_ptr&lt; std::atomic&lt; bool &gt;[]&gt; &gt; stalled;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-recv_queues","title":"variable recv_queues","text":"<pre><code>std::vector&lt; std::unique_ptr&lt; Queue&lt; std::vector&lt; Branch &gt; &gt; &gt; &gt; recv_queues;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-send_queues","title":"variable send_queues","text":"<pre><code>std::vector&lt; CpuCacheLineIsolated&lt; std::vector&lt; std::vector&lt; Branch &gt; &gt; &gt; &gt; send_queues;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-shard_metrics","title":"variable shard_metrics","text":"<pre><code>std::vector&lt; CpuCacheLineIsolated&lt; ShardMetrics &gt; &gt; shard_metrics;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-total_pending_count","title":"variable total_pending_count","text":"<pre><code>CpuCacheLineIsolated&lt; std::atomic&lt; i64 &gt; &gt; total_pending_count {0};\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1ParallelModelCheckState/#variable-local_consume_count","title":"variable local_consume_count","text":"<pre><code>std::vector&lt; CpuCacheLineIsolated&lt; i64 &gt; &gt; local_consume_count;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/","title":"batt::detail::PriorityHeap","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#public-types","title":"Public Types","text":"Name using PriorityHeap Self using PriorityHeapItem&lt; IntT &gt; Item using boost::container::static_vector&lt; Item **, kStackSize &gt; StackVec"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#public-functions","title":"Public Functions","text":"Name BATT_ALWAYS_INLINE Item ** swap_child(Item * parent, usize i, const std::array&lt; Item , 2 &gt; &amp; children) BATT_ALWAYS_INLINE Item ** swap_left(Item * parent, const std::array&lt; Item , 2 &gt; &amp; children) BATT_ALWAYS_INLINE Item ** swap_right(Item * parent, const std::array&lt; Item , 2 &gt; &amp; children) BATT_ALWAYS_INLINE i32 depth_upper_bound(usize path) BATT_ALWAYS_INLINE usize get_top_mask(usize path) template &lt;typename Fn &gt; BATT_ALWAYS_INLINE void path_to_bottom(usize size, Fn &amp;&amp; fn) template &lt;typename Fn &gt; BATT_ALWAYS_INLINE void path_from_bottom(usize size, Fn &amp;&amp; fn) PriorityHeap() =default PriorityHeap(const PriorityHeap &amp; ) =deleted PriorityHeap &amp; operator=(const PriorityHeap &amp; ) =deleted ~PriorityHeap() =default PriorityHeap(PriorityHeap &amp;&amp; other) bool empty() const usize size() const const Optional&lt; IntT &gt; &amp; min_value() const const Item * top() const void insert(Item * item) Item * remove() bool check_invariants(StackVec * stack, usize * count =nullptr) void dump(std::ostream &amp; out, Item * parent =nullptr, int depth =0)"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kStackSize"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename IntT &gt;\nclass batt::detail::PriorityHeap;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#using-self","title":"using Self","text":"<pre><code>using batt::detail::PriorityHeap&lt; IntT &gt;::Self =  PriorityHeap;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#using-item","title":"using Item","text":"<pre><code>using batt::detail::PriorityHeap&lt; IntT &gt;::Item =  PriorityHeapItem&lt;IntT&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#using-stackvec","title":"using StackVec","text":"<pre><code>using batt::detail::PriorityHeap&lt; IntT &gt;::StackVec =  boost::container::static_vector&lt;Item**, kStackSize&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-swap_child","title":"function swap_child","text":"<pre><code>static inline BATT_ALWAYS_INLINE Item ** swap_child(\nItem ** parent,\nusize i,\nconst std::array&lt; Item *, 2 &gt; &amp; children\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-swap_left","title":"function swap_left","text":"<pre><code>static inline BATT_ALWAYS_INLINE Item ** swap_left(\nItem ** parent,\nconst std::array&lt; Item *, 2 &gt; &amp; children\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-swap_right","title":"function swap_right","text":"<pre><code>static inline BATT_ALWAYS_INLINE Item ** swap_right(\nItem ** parent,\nconst std::array&lt; Item *, 2 &gt; &amp; children\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-depth_upper_bound","title":"function depth_upper_bound","text":"<pre><code>static inline BATT_ALWAYS_INLINE i32 depth_upper_bound(\nusize path\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-get_top_mask","title":"function get_top_mask","text":"<pre><code>static inline BATT_ALWAYS_INLINE usize get_top_mask(\nusize path\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-path_to_bottom","title":"function path_to_bottom","text":"<pre><code>template &lt;typename Fn &gt;\nstatic inline BATT_ALWAYS_INLINE void path_to_bottom(\nusize size,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-path_from_bottom","title":"function path_from_bottom","text":"<pre><code>template &lt;typename Fn &gt;\nstatic inline BATT_ALWAYS_INLINE void path_from_bottom(\nusize size,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-priorityheap","title":"function PriorityHeap","text":"<pre><code>PriorityHeap() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-priorityheap_1","title":"function PriorityHeap","text":"<pre><code>PriorityHeap(\nconst PriorityHeap &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-operator","title":"function operator=","text":"<pre><code>PriorityHeap &amp; operator=(\nconst PriorityHeap &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-priorityheap_2","title":"function ~PriorityHeap","text":"<pre><code>~PriorityHeap() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-priorityheap_3","title":"function PriorityHeap","text":"<pre><code>inline PriorityHeap(\nPriorityHeap &amp;&amp; other\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-min_value","title":"function min_value","text":"<pre><code>inline const Optional&lt; IntT &gt; &amp; min_value() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-top","title":"function top","text":"<pre><code>inline const Item * top() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-insert","title":"function insert","text":"<pre><code>inline void insert(\nItem * item\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-remove","title":"function remove","text":"<pre><code>inline Item * remove()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-check_invariants","title":"function check_invariants","text":"<pre><code>inline bool check_invariants(\nStackVec * stack,\nusize * count =nullptr\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#function-dump","title":"function dump","text":"<pre><code>inline void dump(\nstd::ostream &amp; out,\nItem * parent =nullptr,\nint depth =0\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeap/#variable-kstacksize","title":"variable kStackSize","text":"<pre><code>static constexpr usize kStackSize = sizeof(usize) * (8 );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/","title":"batt::detail::PriorityHeapItem","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#public-types","title":"Public Types","text":"Name using IntT order_type"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#public-functions","title":"Public Functions","text":"Name PriorityHeapItem(IntT order) PriorityHeapItem() =default PriorityHeapItem(const PriorityHeapItem &amp; ) =deleted PriorityHeapItem &amp; operator=(const PriorityHeapItem &amp; ) =deleted IntT order() const bool is_linked() const"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#friends","title":"Friends","text":"Name class PriorityHeap&lt; IntT &gt;"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename IntT &gt;\nclass batt::detail::PriorityHeapItem;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#using-order_type","title":"using order_type","text":"<pre><code>using batt::detail::PriorityHeapItem&lt; IntT &gt;::order_type =  IntT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#function-priorityheapitem","title":"function PriorityHeapItem","text":"<pre><code>inline explicit PriorityHeapItem(\nIntT order\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#function-priorityheapitem_1","title":"function PriorityHeapItem","text":"<pre><code>PriorityHeapItem() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#function-priorityheapitem_2","title":"function PriorityHeapItem","text":"<pre><code>PriorityHeapItem(\nconst PriorityHeapItem &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#function-operator","title":"function operator=","text":"<pre><code>PriorityHeapItem &amp; operator=(\nconst PriorityHeapItem &amp; ) =deleted\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#function-order","title":"function order","text":"<pre><code>inline IntT order() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#function-is_linked","title":"function is_linked","text":"<pre><code>inline bool is_linked() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItem/#friend-priorityheap-intt","title":"friend PriorityHeap&lt; IntT &gt;","text":"<pre><code>friend class PriorityHeap&lt; IntT &gt;(\nPriorityHeap&lt; IntT &gt; );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/","title":"batt::detail::PriorityHeapItemList","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#public-types","title":"Public Types","text":"Name using PriorityHeapItem&lt; IntT &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#public-functions","title":"Public Functions","text":"Name void insert(Item * item)"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename IntT &gt;\nclass batt::detail::PriorityHeapItemList;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#using-item","title":"using Item","text":"<pre><code>using batt::detail::PriorityHeapItemList&lt; IntT &gt;::Item =  PriorityHeapItem&lt;IntT&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1PriorityHeapItemList/#function-insert","title":"function insert","text":"<pre><code>inline void insert(\nItem * item\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/","title":"batt::detail::SigInfoHandler","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-types","title":"Public Types","text":"Name using batt::Optional&lt; boost::asio::executor_work_guard&lt; boost::asio::io_context::executor_type &gt; &gt; WorkGuard"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-functions","title":"Public Functions","text":"Name SigInfoHandler &amp; instance() SigInfoHandler() void start() void halt() void join() void wait_for_signal() void handle_signal(const boost::system::error_code &amp; ec, int signal_n)"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-attributes","title":"Public Attributes","text":"Name constexpr int kSignalNum"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#using-workguard","title":"using WorkGuard","text":"<pre><code>using batt::detail::SigInfoHandler::WorkGuard =  batt::Optional&lt;boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-instance","title":"function instance","text":"<pre><code>static inline SigInfoHandler &amp; instance()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-siginfohandler","title":"function SigInfoHandler","text":"<pre><code>inline SigInfoHandler()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-start","title":"function start","text":"<pre><code>inline void start()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-halt","title":"function halt","text":"<pre><code>inline void halt()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-join","title":"function join","text":"<pre><code>inline void join()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-wait_for_signal","title":"function wait_for_signal","text":"<pre><code>inline void wait_for_signal()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#function-handle_signal","title":"function handle_signal","text":"<pre><code>inline void handle_signal(\nconst boost::system::error_code &amp; ec,\nint signal_n\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1SigInfoHandler/#variable-ksignalnum","title":"variable kSignalNum","text":"<pre><code>static constexpr int kSignalNum =\n0;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/","title":"batt::detail::StatusBase","text":"<p>Inherited by batt::Status</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/#public-functions","title":"Public Functions","text":"Name StatusBase()"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusBase/#function-statusbase","title":"function StatusBase","text":"<pre><code>inline StatusBase()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/","title":"batt::detail::StatusOrValueContainer","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#public-types","title":"Public Types","text":"Name using StatusOrValueContainer Self"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args&gt; void construct(Args &amp;&amp;... args) void construct(const Self &amp; that) void construct(Self &amp;&amp; that) T * pointer() const T * pointer() const T &amp; reference() const T &amp; reference() const void destroy()"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::detail::StatusOrValueContainer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#using-self","title":"using Self","text":"<pre><code>using batt::detail::StatusOrValueContainer&lt; T &gt;::Self =  StatusOrValueContainer;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-construct","title":"function construct","text":"<pre><code>template &lt;typename... Args&gt;\ninline void construct(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-construct_1","title":"function construct","text":"<pre><code>inline void construct(\nconst Self &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-construct_2","title":"function construct","text":"<pre><code>inline void construct(\nSelf &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-pointer","title":"function pointer","text":"<pre><code>inline T * pointer()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-pointer_1","title":"function pointer","text":"<pre><code>inline const T * pointer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-reference","title":"function reference","text":"<pre><code>inline T &amp; reference()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-reference_1","title":"function reference","text":"<pre><code>inline const T &amp; reference() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer/#function-destroy","title":"function destroy","text":"<pre><code>inline void destroy()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/","title":"batt::detail::StatusOrValueContainer&lt; T &amp; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#public-types","title":"Public Types","text":"Name using StatusOrValueContainer&lt; T &amp; &gt; Self"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#public-functions","title":"Public Functions","text":"Name void construct(T &amp; value) void construct(const Self &amp; that) void construct(Self &amp;&amp; that) T * pointer() const T &amp; reference() const void destroy()"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::detail::StatusOrValueContainer&lt; T &amp; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#using-self","title":"using Self","text":"<pre><code>using batt::detail::StatusOrValueContainer&lt; T &amp; &gt;::Self =  StatusOrValueContainer&lt;T&amp;&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-construct","title":"function construct","text":"<pre><code>inline void construct(\nT &amp; value\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-construct_1","title":"function construct","text":"<pre><code>inline void construct(\nconst Self &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-construct_2","title":"function construct","text":"<pre><code>inline void construct(\nSelf &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-pointer","title":"function pointer","text":"<pre><code>inline T * pointer() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-reference","title":"function reference","text":"<pre><code>inline T &amp; reference() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1detail_1_1StatusOrValueContainer_3_01T_01_6_01_4/#function-destroy","title":"function destroy","text":"<pre><code>inline void destroy()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/","title":"batt::kAllowAlloc","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#public-types","title":"Public Types","text":"Name using SmallFn&lt; auto(Args...) -&gt;Result, kMaxSize, kMoveOnly, kAllowAlloc &gt; self_type using Result result_type"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#public-functions","title":"Public Functions","text":"Name SmallFn() =default template &lt;typename Fn ,typename  =EnableIfNoShadow,typename  =std::enable_if_t{}&gt;&gt;  SmallFn(Fn &amp;&amp; fn) SmallFn(self_type &amp;&amp; that) SmallFn(const self_type &amp; that)"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#public-attributes","title":"Public Attributes","text":"Name copy_to_move_only storage_ AbstractFn * impl_"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#friends","title":"Friends","text":"Name class SmallFn"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Args,\ntypename Result ,\nusize kMaxSize,\nbool kMoveOnly,\nbool kAllowAlloc&gt;\nclass batt::kAllowAlloc;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#using-self_type","title":"using self_type","text":"<pre><code>using batt::kAllowAlloc&lt; Args, Result, kMaxSize, kMoveOnly, kAllowAlloc &gt;::self_type =  SmallFn&lt;auto(Args...)-&gt;Result, kMaxSize, kMoveOnly, kAllowAlloc&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#using-result_type","title":"using result_type","text":"<pre><code>using batt::kAllowAlloc&lt; Args, Result, kMaxSize, kMoveOnly, kAllowAlloc &gt;::result_type =  Result;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#function-smallfn","title":"function SmallFn","text":"<pre><code>SmallFn() =default\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#function-smallfn_1","title":"function SmallFn","text":"<pre><code>template &lt;typename Fn ,\ntypename  =EnableIfNoShadow&lt;self_type, Fn&gt;,\ntypename  =std::enable_if_t&lt;IsCallable&lt;Fn, Args...&gt;{}&gt;&gt;\ninline SmallFn(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#function-smallfn_2","title":"function SmallFn","text":"<pre><code>inline SmallFn(\nself_type &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#function-smallfn_3","title":"function SmallFn","text":"<pre><code>inline SmallFn(\nconst self_type &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#variable-storage_","title":"variable storage_","text":"<pre><code>copy_to_move_only storage_;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#variable-impl_","title":"variable impl_","text":"<pre><code>AbstractFn * impl_ = nullptr;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1kAllowAlloc/#friend-smallfn","title":"friend SmallFn","text":"<pre><code>friend class SmallFn(\nSmallFn );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/","title":"batt::seq::Attach","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item using Data UserData"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-functions","title":"Public Functions","text":"Name Attach(Seq &amp;&amp; seq, Data &amp;&amp; data) Data &amp; user_data() const Data &amp; user_data() const Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Data &gt;\nclass batt::seq::Attach;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Attach&lt; Seq, Data &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#using-userdata","title":"using UserData","text":"<pre><code>using batt::seq::Attach&lt; Seq, Data &gt;::UserData =  Data;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-attach","title":"function Attach","text":"<pre><code>inline explicit Attach(\nSeq &amp;&amp; seq,\nData &amp;&amp; data\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-user_data","title":"function user_data","text":"<pre><code>inline Data &amp; user_data()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-user_data_1","title":"function user_data","text":"<pre><code>inline const Data &amp; user_data() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Attach/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/","title":"batt::seq::CacheNext","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-functions","title":"Public Functions","text":"Name CacheNext(Seq &amp;&amp; seq) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq &gt;\nclass batt::seq::CacheNext;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#using-item","title":"using Item","text":"<pre><code>using batt::seq::CacheNext&lt; Seq &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#function-cachenext","title":"function CacheNext","text":"<pre><code>inline explicit CacheNext(\nSeq &amp;&amp; seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1CacheNext/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/","title":"batt::seq::Chain","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; SeqItem&lt; Seq1 &gt;, SeqItem&lt; Seq2 &gt; &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-functions","title":"Public Functions","text":"Name Chain(Seq1 &amp;&amp; seq1, Seq2 &amp;&amp; seq2) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq1 ,\ntypename Seq2 &gt;\nclass batt::seq::Chain;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Chain&lt; Seq1, Seq2 &gt;::Item =  std::common_type_t&lt;SeqItem&lt;Seq1&gt;, SeqItem&lt;Seq2&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#function-chain","title":"function Chain","text":"<pre><code>inline explicit Chain(\nSeq1 &amp;&amp; seq1,\nSeq2 &amp;&amp; seq2\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Chain/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/","title":"batt::seq::Empty","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-types","title":"Public Types","text":"Name using T Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-functions","title":"Public Functions","text":"Name Optional&lt; T &gt; peek() Optional&lt; T &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::seq::Empty;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Empty&lt; T &gt;::Item =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; T &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Empty/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; T &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/","title":"batt::seq::Filter","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-functions","title":"Public Functions","text":"Name Filter(Seq &amp;&amp; seq, Predicate &amp;&amp; predicate) Filter(Filter &amp;&amp; that) Filter &amp; operator=(Filter &amp;&amp; that) Filter(const Filter &amp; that) Filter &amp; operator=(const Filter &amp; that) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Predicate &gt;\nclass batt::seq::Filter;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Filter&lt; Seq, Predicate &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-filter","title":"function Filter","text":"<pre><code>inline explicit Filter(\nSeq &amp;&amp; seq,\nPredicate &amp;&amp; predicate\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-filter_1","title":"function Filter","text":"<pre><code>inline Filter(\nFilter &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-operator","title":"function operator=","text":"<pre><code>inline Filter &amp; operator=(\nFilter &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-filter_2","title":"function Filter","text":"<pre><code>inline Filter(\nconst Filter &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-operator_1","title":"function operator=","text":"<pre><code>inline Filter &amp; operator=(\nconst Filter &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Filter/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/","title":"batt::seq::FilterMap","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-types","title":"Public Types","text":"Name using decltype(filter_map_impl&lt; Seq, Fn &gt;(std::declval&lt; Seq &gt;(), std::declval&lt; Fn &gt;())) impl_type using SeqItem&lt; impl_type &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-functions","title":"Public Functions","text":"Name FilterMap(Seq &amp;&amp; seq, Fn &amp;&amp; fn) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nclass batt::seq::FilterMap;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#using-impl_type","title":"using impl_type","text":"<pre><code>using batt::seq::FilterMap&lt; Seq, Fn &gt;::impl_type =  decltype(filter_map_impl&lt;Seq, Fn&gt;(std::declval&lt;Seq&gt;(), std::declval&lt;Fn&gt;()));\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#using-item","title":"using Item","text":"<pre><code>using batt::seq::FilterMap&lt; Seq, Fn &gt;::Item =  SeqItem&lt;impl_type&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#function-filtermap","title":"function FilterMap","text":"<pre><code>inline explicit FilterMap(\nSeq &amp;&amp; seq,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1FilterMap/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/","title":"batt::seq::Flatten","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-types","title":"Public Types","text":"Name using InnerSeqT InnerSeq using SeqItem&lt; InnerSeq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-functions","title":"Public Functions","text":"Name Flatten(OuterSeq &amp;&amp; outer) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename OuterSeq ,\ntypename InnerSeqT  =std::decay_t&lt;SeqItem&lt;OuterSeq&gt;&gt;&gt;\nclass batt::seq::Flatten;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#using-innerseq","title":"using InnerSeq","text":"<pre><code>using batt::seq::Flatten&lt; OuterSeq, InnerSeqT &gt;::InnerSeq =  InnerSeqT;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Flatten&lt; OuterSeq, InnerSeqT &gt;::Item =  SeqItem&lt;InnerSeq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#function-flatten","title":"function Flatten","text":"<pre><code>inline explicit Flatten(\nOuterSeq &amp;&amp; outer\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Flatten/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/","title":"batt::seq::Fuse","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; OptionalItem using typename std::decay_t&lt; OptionalItem &gt;::value_type Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-functions","title":"Public Functions","text":"Name Fuse(Seq &amp;&amp; seq) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq &gt;\nclass batt::seq::Fuse;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#using-optionalitem","title":"using OptionalItem","text":"<pre><code>using batt::seq::Fuse&lt; Seq &gt;::OptionalItem =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Fuse&lt; Seq &gt;::Item =  typename std::decay_t&lt;OptionalItem&gt;::value_type;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#function-fuse","title":"function Fuse","text":"<pre><code>inline explicit Fuse(\nSeq &amp;&amp; seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Fuse/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/","title":"batt::seq::GroupBy","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-classes","title":"Public Classes","text":"Name class SubGroup"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; SubGroupItem using SubGroup Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-functions","title":"Public Functions","text":"Name void detach(SubGroup * sub_group, bool skip_advance) GroupBy(Seq &amp;&amp; seq, GroupEq &amp;&amp; group_eq) GroupBy(Seq &amp;&amp; seq, GroupEq &amp;&amp; group_eq, Optional&lt; SubGroupItem &gt; &amp;&amp; next_item) ~GroupBy() GroupBy(GroupBy &amp;&amp; that) GroupBy &amp; operator=(GroupBy &amp;&amp; that) GroupBy(const GroupBy &amp; that) GroupBy &amp; operator=(const GroupBy &amp; that) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename GroupEq &gt;\nclass batt::seq::GroupBy;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#using-subgroupitem","title":"using SubGroupItem","text":"<pre><code>using batt::seq::GroupBy&lt; Seq, GroupEq &gt;::SubGroupItem =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#using-item","title":"using Item","text":"<pre><code>using batt::seq::GroupBy&lt; Seq, GroupEq &gt;::Item =  SubGroup;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-detach","title":"function detach","text":"<pre><code>static inline void detach(\nSubGroup * sub_group,\nbool skip_advance\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby","title":"function GroupBy","text":"<pre><code>inline explicit GroupBy(\nSeq &amp;&amp; seq,\nGroupEq &amp;&amp; group_eq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_1","title":"function GroupBy","text":"<pre><code>inline explicit GroupBy(\nSeq &amp;&amp; seq,\nGroupEq &amp;&amp; group_eq,\nOptional&lt; SubGroupItem &gt; &amp;&amp; next_item\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_2","title":"function ~GroupBy","text":"<pre><code>inline ~GroupBy()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_3","title":"function GroupBy","text":"<pre><code>inline GroupBy(\nGroupBy &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-operator","title":"function operator=","text":"<pre><code>inline GroupBy &amp; operator=(\nGroupBy &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-groupby_4","title":"function GroupBy","text":"<pre><code>inline GroupBy(\nconst GroupBy &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-operator_1","title":"function operator=","text":"<pre><code>inline GroupBy &amp; operator=(\nconst GroupBy &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/","title":"batt::seq::GroupBy::SubGroup","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-functions","title":"Public Functions","text":"Name SubGroup(SubGroup &amp;&amp; that) SubGroup(const SubGroup &amp; that) ~SubGroup() SubGroup &amp; operator=(SubGroup &amp;&amp; that) SubGroup &amp; operator=(const SubGroup &amp; that) bool is_detached() const Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#friends","title":"Friends","text":"Name class GroupBy&lt; Seq, GroupEq &gt;"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#using-item","title":"using Item","text":"<pre><code>using batt::seq::GroupBy&lt; Seq, GroupEq &gt;::SubGroup::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-subgroup","title":"function SubGroup","text":"<pre><code>inline SubGroup(\nSubGroup &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-subgroup_1","title":"function SubGroup","text":"<pre><code>inline SubGroup(\nconst SubGroup &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-subgroup_2","title":"function ~SubGroup","text":"<pre><code>inline ~SubGroup()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-operator","title":"function operator=","text":"<pre><code>inline SubGroup &amp; operator=(\nSubGroup &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-operator_1","title":"function operator=","text":"<pre><code>inline SubGroup &amp; operator=(\nconst SubGroup &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-is_detached","title":"function is_detached","text":"<pre><code>inline bool is_detached() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1GroupBy_1_1SubGroup/#friend-groupby-seq-groupeq","title":"friend GroupBy&lt; Seq, GroupEq &gt;","text":"<pre><code>friend class GroupBy&lt; Seq, GroupEq &gt;(\nGroupBy&lt; Seq, GroupEq &gt; );\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/","title":"batt::seq::InspectAdjacent","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-functions","title":"Public Functions","text":"Name InspectAdjacent(Seq &amp;&amp; seq, Fn &amp;&amp; fn) InspectAdjacent(InspectAdjacent &amp;&amp; that) InspectAdjacent &amp; operator=(InspectAdjacent &amp;&amp; that) InspectAdjacent(const InspectAdjacent &amp; that) InspectAdjacent &amp; operator=(const InspectAdjacent &amp; that) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nclass batt::seq::InspectAdjacent;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#using-item","title":"using Item","text":"<pre><code>using batt::seq::InspectAdjacent&lt; Seq, Fn &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-inspectadjacent","title":"function InspectAdjacent","text":"<pre><code>inline explicit InspectAdjacent(\nSeq &amp;&amp; seq,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-inspectadjacent_1","title":"function InspectAdjacent","text":"<pre><code>inline InspectAdjacent(\nInspectAdjacent &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-operator","title":"function operator=","text":"<pre><code>inline InspectAdjacent &amp; operator=(\nInspectAdjacent &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-inspectadjacent_2","title":"function InspectAdjacent","text":"<pre><code>inline InspectAdjacent(\nconst InspectAdjacent &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-operator_1","title":"function operator=","text":"<pre><code>inline InspectAdjacent &amp; operator=(\nconst InspectAdjacent &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1InspectAdjacent/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/","title":"batt::seq::KMergeBy","text":"<p>More...</p> <p>Inherits from batt::seq::detail::HeapOrder&lt; Compare &gt;, std::conditional_t&lt; can_be_empty_base&lt; Compare &gt;(), HeapOrderEmptyBase&lt; Compare &gt;, HeapOrderBase&lt; Compare &gt; &gt;</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-functions","title":"Public Functions","text":"Name template &lt;typename KSeqs &gt;  KMergeBy(KSeqs &amp;&amp; k_seqs, Compare &amp;&amp; compare) KMergeBy(const KMergeBy &amp; that) KMergeBy &amp; operator=(const KMergeBy &amp; that) Optional&lt; Item &gt; next() Optional&lt; Item &gt; peek()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::seq::detail::HeapOrder&lt; Compare &gt;</p> Name template &lt;typename L ,typename R &gt; bool operator()(L * l, R * r) const HeapOrder &amp; order() const HeapOrder &amp; order() const"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Compare &gt;\nclass batt::seq::KMergeBy;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#using-item","title":"using Item","text":"<pre><code>using batt::seq::KMergeBy&lt; Seq, Compare &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-kmergeby","title":"function KMergeBy","text":"<pre><code>template &lt;typename KSeqs &gt;\ninline explicit KMergeBy(\nKSeqs &amp;&amp; k_seqs,\nCompare &amp;&amp; compare\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-kmergeby_1","title":"function KMergeBy","text":"<pre><code>inline KMergeBy(\nconst KMergeBy &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-operator","title":"function operator=","text":"<pre><code>inline KMergeBy &amp; operator=(\nconst KMergeBy &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1KMergeBy/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/","title":"batt::seq::Lazy","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-types","title":"Public Types","text":"Name using decltype(std::declval&lt; Fn &gt;()()) Seq using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-functions","title":"Public Functions","text":"Name Lazy(Fn &amp;&amp; fn) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nclass batt::seq::Lazy;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#using-seq","title":"using Seq","text":"<pre><code>using batt::seq::Lazy&lt; Fn &gt;::Seq =  decltype(std::declval&lt;Fn&gt;()());\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Lazy&lt; Fn &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#function-lazy","title":"function Lazy","text":"<pre><code>inline explicit Lazy(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Lazy/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/","title":"batt::seq::Map","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-types","title":"Public Types","text":"Name using batt::DecayRValueRef&lt; std::invoke_result_t&lt; MapFn, SeqItem&lt; Seq &gt; &gt;&gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-functions","title":"Public Functions","text":"Name Map(Seq &amp;&amp; seq, MapFn &amp;&amp; map_fn) Map(Map &amp;&amp; that) Map(const Map &amp; that) Map &amp; operator=(Map &amp;&amp; that) Map &amp; operator=(const Map &amp; that) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename MapFn &gt;\nclass batt::seq::Map;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Map&lt; Seq, MapFn &gt;::Item =  batt::DecayRValueRef&lt;std::invoke_result_t&lt;MapFn, SeqItem&lt;Seq&gt; &gt;&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-map","title":"function Map","text":"<pre><code>inline explicit Map(\nSeq &amp;&amp; seq,\nMapFn &amp;&amp; map_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-map_1","title":"function Map","text":"<pre><code>inline Map(\nMap &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-map_2","title":"function Map","text":"<pre><code>inline Map(\nconst Map &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-operator","title":"function operator=","text":"<pre><code>inline Map &amp; operator=(\nMap &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-operator_1","title":"function operator=","text":"<pre><code>inline Map &amp; operator=(\nconst Map &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Map/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/","title":"batt::seq::MapAdjacent","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-types","title":"Public Types","text":"Name using decltype(std::declval&lt; Fn &amp; &gt;()(std::declval&lt; const SeqItem&lt; Seq &gt; &amp; &gt;(), std::declval&lt; const SeqItem&lt; Seq &gt; &amp; &gt;())) Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-functions","title":"Public Functions","text":"Name MapAdjacent(Seq &amp;&amp; seq, Fn &amp;&amp; fn) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nclass batt::seq::MapAdjacent;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#using-item","title":"using Item","text":"<pre><code>using batt::seq::MapAdjacent&lt; Seq, Fn &gt;::Item =  decltype(std::declval&lt;Fn&amp;&gt;()(std::declval&lt;const SeqItem&lt;Seq&gt;&amp;&gt;(), std::declval&lt;const SeqItem&lt;Seq&gt;&amp;&gt;()));\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#function-mapadjacent","title":"function MapAdjacent","text":"<pre><code>inline explicit MapAdjacent(\nSeq &amp;&amp; seq,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapAdjacent/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/","title":"batt::seq::MapFold","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-types","title":"Public Types","text":"Name using std::tuple_element_t&lt; 1, std::invoke_result_t&lt; MapFn, State, SeqItem&lt; Seq &gt; &gt;&gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-functions","title":"Public Functions","text":"Name MapFold(Seq &amp;&amp; seq, State &amp;&amp; state, MapFn &amp;&amp; map_fn) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename State ,\ntypename MapFn &gt;\nclass batt::seq::MapFold;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#using-item","title":"using Item","text":"<pre><code>using batt::seq::MapFold&lt; Seq, State, MapFn &gt;::Item =  std::tuple_element_t&lt;1, std::invoke_result_t&lt;MapFn, State, SeqItem&lt;Seq&gt; &gt;&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#function-mapfold","title":"function MapFold","text":"<pre><code>inline explicit MapFold(\nSeq &amp;&amp; seq,\nState &amp;&amp; state,\nMapFn &amp;&amp; map_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapFold/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/","title":"batt::seq::MapPairwise","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-types","title":"Public Types","text":"Name using std::invoke_result_t&lt; MapFn, SeqItem&lt; LeftSeq &gt;, SeqItem&lt; RightSeq &gt; &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-functions","title":"Public Functions","text":"Name MapPairwise(LeftSeq &amp;&amp; left, RightSeq &amp;&amp; right, MapFn &amp;&amp; map_fn) MapPairwise(MapPairwise &amp;&amp; that) MapPairwise(const MapPairwise &amp; that) MapPairwise &amp; operator=(MapPairwise &amp;&amp; that) MapPairwise &amp; operator=(const MapPairwise &amp; that) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename LeftSeq ,\ntypename RightSeq ,\ntypename MapFn &gt;\nclass batt::seq::MapPairwise;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#using-item","title":"using Item","text":"<pre><code>using batt::seq::MapPairwise&lt; LeftSeq, RightSeq, MapFn &gt;::Item =  std::invoke_result_t&lt;MapFn, SeqItem&lt;LeftSeq&gt;, SeqItem&lt;RightSeq&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-mappairwise","title":"function MapPairwise","text":"<pre><code>inline explicit MapPairwise(\nLeftSeq &amp;&amp; left,\nRightSeq &amp;&amp; right,\nMapFn &amp;&amp; map_fn\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-mappairwise_1","title":"function MapPairwise","text":"<pre><code>inline MapPairwise(\nMapPairwise &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-mappairwise_2","title":"function MapPairwise","text":"<pre><code>inline MapPairwise(\nconst MapPairwise &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-operator","title":"function operator=","text":"<pre><code>inline MapPairwise &amp; operator=(\nMapPairwise &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-operator_1","title":"function operator=","text":"<pre><code>inline MapPairwise &amp; operator=(\nconst MapPairwise &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MapPairwise/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/","title":"batt::seq::MergeBy","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-types","title":"Public Types","text":"Name using std::conditional_t&lt; std::is_same_v&lt; SeqItem&lt; LeftSeq &gt;, SeqItem&lt; RightSeq &gt; &gt;, SeqItem&lt; LeftSeq &gt;, std::conditional_t&lt; std::is_same_v&lt; std::decay_t&lt; SeqItem&lt; LeftSeq &gt; &gt;, std::decay_t&lt; SeqItem&lt; RightSeq &gt; &gt;&gt;, std::decay_t&lt; SeqItem&lt; LeftSeq &gt; &gt;, std::variant&lt; std::decay_t&lt; SeqItem&lt; LeftSeq &gt; &gt;, std::decay_t&lt; SeqItem&lt; RightSeq &gt; &gt;&gt; &gt;&gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-functions","title":"Public Functions","text":"Name MergeBy(LeftSeq &amp;&amp; left, RightSeq &amp;&amp; right, Compare &amp;&amp; compare) MergeBy(MergeBy &amp;&amp; that) MergeBy &amp; operator=(MergeBy &amp;&amp; that) MergeBy(const MergeBy &amp; that) MergeBy &amp; operator=(const MergeBy &amp; that) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename LeftSeq ,\ntypename RightSeq ,\ntypename Compare &gt;\nclass batt::seq::MergeBy;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#using-item","title":"using Item","text":"<pre><code>using batt::seq::MergeBy&lt; LeftSeq, RightSeq, Compare &gt;::Item =  std::conditional_t&lt; std::is_same_v&lt;SeqItem&lt;LeftSeq&gt;, SeqItem&lt;RightSeq&gt; &gt;, SeqItem&lt;LeftSeq&gt;, std::conditional_t&lt; std::is_same_v&lt;std::decay_t&lt;SeqItem&lt;LeftSeq&gt; &gt;, std::decay_t&lt;SeqItem&lt;RightSeq&gt; &gt;&gt;, std::decay_t&lt;SeqItem&lt;LeftSeq&gt; &gt;, std::variant&lt;std::decay_t&lt;SeqItem&lt;LeftSeq&gt; &gt;, std::decay_t&lt;SeqItem&lt;RightSeq&gt; &gt;&gt; &gt;&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-mergeby","title":"function MergeBy","text":"<pre><code>inline explicit MergeBy(\nLeftSeq &amp;&amp; left,\nRightSeq &amp;&amp; right,\nCompare &amp;&amp; compare\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-mergeby_1","title":"function MergeBy","text":"<pre><code>inline MergeBy(\nMergeBy &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-operator","title":"function operator=","text":"<pre><code>inline MergeBy &amp; operator=(\nMergeBy &amp;&amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-mergeby_2","title":"function MergeBy","text":"<pre><code>inline MergeBy(\nconst MergeBy &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-operator_1","title":"function operator=","text":"<pre><code>inline MergeBy &amp; operator=(\nconst MergeBy &amp; that\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1MergeBy/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/","title":"batt::seq::Printable","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-functions","title":"Public Functions","text":"Name Printable(Seq &amp;&amp; seq) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next() void operator()(std::ostream &amp; out)"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq &gt;\nclass batt::seq::Printable;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Printable&lt; Seq &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-printable","title":"function Printable","text":"<pre><code>inline explicit Printable(\nSeq &amp;&amp; seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Printable/#function-operator","title":"function operator()","text":"<pre><code>inline void operator()(\nstd::ostream &amp; out\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/","title":"batt::seq::SingleItem","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-types","title":"Public Types","text":"Name using T Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-functions","title":"Public Functions","text":"Name SingleItem(T &amp;&amp; item) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nclass batt::seq::SingleItem;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#using-item","title":"using Item","text":"<pre><code>using batt::seq::SingleItem&lt; T &gt;::Item =  T;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#function-singleitem","title":"function SingleItem","text":"<pre><code>inline explicit SingleItem(\nT &amp;&amp; item\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1SingleItem/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/","title":"batt::seq::Splice","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-types","title":"Public Types","text":"Name using std::add_lvalue_reference_t&lt; OuterSeq &gt; OuterSeqRef using Chain&lt; TakeN&lt; OuterSeqRef &gt;, Chain&lt; InnerSeq, OuterSeqRef &gt; &gt; Impl using SeqItem&lt; Impl &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-functions","title":"Public Functions","text":"Name Splice(OuterSeq &amp;&amp; outer_seq, usize n, InnerSeq &amp;&amp; inner_seq) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename OuterSeq ,\ntypename InnerSeq &gt;\nclass batt::seq::Splice;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#using-outerseqref","title":"using OuterSeqRef","text":"<pre><code>using batt::seq::Splice&lt; OuterSeq, InnerSeq &gt;::OuterSeqRef =  std::add_lvalue_reference_t&lt;OuterSeq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#using-impl","title":"using Impl","text":"<pre><code>using batt::seq::Splice&lt; OuterSeq, InnerSeq &gt;::Impl =  Chain&lt;TakeN&lt;OuterSeqRef&gt;, Chain&lt;InnerSeq, OuterSeqRef&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Splice&lt; OuterSeq, InnerSeq &gt;::Item =  SeqItem&lt;Impl&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#function-splice","title":"function Splice","text":"<pre><code>inline explicit Splice(\nOuterSeq &amp;&amp; outer_seq,\nusize n,\nInnerSeq &amp;&amp; inner_seq\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Splice/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/","title":"batt::seq::StatusOk","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-types","title":"Public Types","text":"Name using std::decay_t&lt; RemoveStatusOr&lt; SeqItem&lt; SeqT &gt; &gt;&gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args,typename  =batt::EnableIfNoShadow&gt;  StatusOk(Args &amp;&amp;... args) bool ok() const const Status &amp; status() const Status status() Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename SeqT &gt;\nclass batt::seq::StatusOk;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#using-item","title":"using Item","text":"<pre><code>using batt::seq::StatusOk&lt; SeqT &gt;::Item =  std::decay_t&lt;RemoveStatusOr&lt;SeqItem&lt;SeqT&gt; &gt;&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-statusok","title":"function StatusOk","text":"<pre><code>template &lt;typename... Args,\ntypename  =batt::EnableIfNoShadow&lt;StatusOk, Args...&gt;&gt;\ninline explicit StatusOk(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-ok","title":"function ok","text":"<pre><code>inline bool ok() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-status","title":"function status","text":"<pre><code>inline const Status &amp; status() const\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-status_1","title":"function status","text":"<pre><code>inline Status status()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1StatusOk/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/","title":"batt::seq::TakeN","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-functions","title":"Public Functions","text":"Name TakeN(Seq &amp;&amp; seq, usize n) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq &gt;\nclass batt::seq::TakeN;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#using-item","title":"using Item","text":"<pre><code>using batt::seq::TakeN&lt; Seq &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#function-taken","title":"function TakeN","text":"<pre><code>inline explicit TakeN(\nSeq &amp;&amp; seq,\nusize n\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeN/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/","title":"batt::seq::TakeWhile","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-types","title":"Public Types","text":"Name using SeqItem&lt; Seq &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-functions","title":"Public Functions","text":"Name TakeWhile(Seq &amp;&amp; seq, Predicate &amp;&amp; predicate) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq ,\ntypename Predicate &gt;\nclass batt::seq::TakeWhile;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#using-item","title":"using Item","text":"<pre><code>using batt::seq::TakeWhile&lt; Seq, Predicate &gt;::Item =  SeqItem&lt;Seq&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#function-takewhile","title":"function TakeWhile","text":"<pre><code>inline explicit TakeWhile(\nSeq &amp;&amp; seq,\nPredicate &amp;&amp; predicate\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1TakeWhile/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/","title":"batt::seq::Zip","text":"<p>More...</p>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#public-types","title":"Public Types","text":"Name using std::tuple&lt; SeqItem&lt; Seqs &gt;... &gt; Item"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#public-functions","title":"Public Functions","text":"Name Zip(Seqs &amp;&amp;... seqs) Optional&lt; Item &gt; peek() Optional&lt; Item &gt; next()"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Seqs&gt;\nclass batt::seq::Zip;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#using-item","title":"using Item","text":"<pre><code>using batt::seq::Zip&lt; Seqs &gt;::Item =  std::tuple&lt;SeqItem&lt;Seqs&gt;...&gt;;\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#function-zip","title":"function Zip","text":"<pre><code>inline explicit Zip(\nSeqs &amp;&amp;... seqs\n)\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#function-peek","title":"function peek","text":"<pre><code>inline Optional&lt; Item &gt; peek()\n</code></pre>"},{"location":"_autogen/Classes/classbatt_1_1seq_1_1Zip/#function-next","title":"function next","text":"<pre><code>inline Optional&lt; Item &gt; next()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1BasicAbstractHandler_1_1Deleter/","title":"batt::BasicAbstractHandler::Deleter","text":"<p>Deleter for use in std::unique_ptr.  <code>#include &lt;batteries/async/handler.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1BasicAbstractHandler_1_1Deleter/#public-functions","title":"Public Functions","text":"Name void operator()(Self * handler) const"},{"location":"_autogen/Classes/structbatt_1_1BasicAbstractHandler_1_1Deleter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicAbstractHandler_1_1Deleter/#function-operator","title":"function operator()","text":"<pre><code>inline void operator()(\nSelf * handler\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/","title":"batt::BasicInterval","text":"<p>A set of totally ordered values, defined by a lower and upper bound.  More...</p> <p><code>#include &lt;batteries/interval.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-classes","title":"Public Classes","text":"Name struct LexicographicalOrder Total order that sorts intervals first by lower bound, then by upper bound (i.e., by \"dictionary order\"). struct LinearOrder Partial order on Interval values that corresponds to a strict ordering on a one dimensional number line."},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-types","title":"Public Types","text":"Name using Traits traits_type using seq::Reverse&lt; LinearOrder &gt; ReverseLinearOrder The reverse of LinearOrder (for max-heaps). using seq::Reverse&lt; LexicographicalOrder &gt; ReverseLexicographicalOrder Reverse of LexicographicalOrder; so max-heap functions can be used to implement a min-heap."},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-functions","title":"Public Functions","text":"Name auto size() constReturns the size of the interval as defined by Traits (usually integer difference). bool empty() constReturns true iff the interval contains no elements. template &lt;typename V &gt; bool contains(const V &amp; item) constReturns true iff the interval contains the passed item. template &lt;typename ThatTraits &gt; bool adjacent_to(const BasicInterval&lt; ThatTraits &gt; &amp; that) constReturns true iff no non-empty interval can be constructed between <code>this</code> and <code>that</code>. template &lt;typename ThatTraits &gt; BasicInterval union_with(const BasicInterval&lt; ThatTraits &gt; &amp; that) constReturns the interval representing the set-union between <code>this</code>, <code>that</code>, and any non-empty interval that can be formed in between. template &lt;typename ThatTraits &gt; bool overlaps(const BasicInterval&lt; ThatTraits &gt; &amp; that) constReturns true iff the minimal bounding range for <code>this</code> and <code>that</code> is non-empty. template &lt;typename ThatTraits &gt; BasicInterval intersection_with(const BasicInterval&lt; ThatTraits &gt; &amp; that) constReturns the interval representing the set of values that are in both <code>this</code> and <code>that</code>. SmallVec&lt; BasicInterval, 2 &gt; without(const BasicInterval &amp; that) constReturns the interval representing <code>this</code>, with any overlap with <code>that</code> removed. template &lt;typename DiffT &gt; BasicInterval shift_up(const DiffT &amp; d) constAdd the given amount to both lower and upper bounds and return the resulting interval. template &lt;typename DiffT &gt; BasicInterval shift_down(const DiffT &amp; d) constSubtract the given amount from both lower and upper bounds and return the resulting interval."},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-attributes","title":"Public Attributes","text":"Name Traits::lower_bound_type lower_bound Traits::upper_bound_type upper_bound"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friends","title":"Friends","text":"Name bool operator==(const BasicInterval&lt; TraitsL &gt; &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) bool operator!=(const BasicInterval&lt; TraitsL &gt; &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const BasicInterval&lt; TraitsT &gt; &amp; t)"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Traits &gt;\nstruct batt::BasicInterval;\n</code></pre> <p>A set of totally ordered values, defined by a lower and upper bound. </p> <p>See: Interval, CInterval </p> <p>Example:</p> <pre><code>#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/interval.hpp&gt;\nint main()\n{\nbatt::Interval&lt;int&gt; i{3, 7};\nBATT_CHECK_EQ(i.size(), 4);\nBATT_CHECK(i.contains(3));\nBATT_CHECK(i.contains(6));\nBATT_CHECK(!i.contains(2));\nBATT_CHECK(!i.contains(7));\nBATT_CHECK((batt::Interval&lt;int&gt;{5, 5}).empty());\nreturn 0;\n}\n</code></pre> <p>Filename: examples/interval.cpp</p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#using-traits_type","title":"using traits_type","text":"<pre><code>using batt::BasicInterval&lt; Traits &gt;::traits_type =  Traits;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#using-reverselinearorder","title":"using ReverseLinearOrder","text":"<pre><code>using batt::BasicInterval&lt; Traits &gt;::ReverseLinearOrder =  seq::Reverse&lt;LinearOrder&gt;;\n</code></pre> <p>The reverse of LinearOrder (for max-heaps). </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#using-reverselexicographicalorder","title":"using ReverseLexicographicalOrder","text":"<pre><code>using batt::BasicInterval&lt; Traits &gt;::ReverseLexicographicalOrder =  seq::Reverse&lt;LexicographicalOrder&gt;;\n</code></pre> <p>Reverse of LexicographicalOrder; so max-heap functions can be used to implement a min-heap. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-size","title":"function size","text":"<pre><code>inline auto size() const\n</code></pre> <p>Returns the size of the interval as defined by Traits (usually integer difference). </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre> <p>Returns true iff the interval contains no elements. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-contains","title":"function contains","text":"<pre><code>template &lt;typename V &gt;\ninline bool contains(\nconst V &amp; item\n) const\n</code></pre> <p>Returns true iff the interval contains the passed item. </p> <p>Parameters: </p> <ul> <li>item The value to test for membership. </li> </ul>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-adjacent_to","title":"function adjacent_to","text":"<pre><code>template &lt;typename ThatTraits &gt;\ninline bool adjacent_to(\nconst BasicInterval&lt; ThatTraits &gt; &amp; that\n) const\n</code></pre> <p>Returns true iff no non-empty interval can be constructed between <code>this</code> and <code>that</code>. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-union_with","title":"function union_with","text":"<pre><code>template &lt;typename ThatTraits &gt;\ninline BasicInterval union_with(\nconst BasicInterval&lt; ThatTraits &gt; &amp; that\n) const\n</code></pre> <p>Returns the interval representing the set-union between <code>this</code>, <code>that</code>, and any non-empty interval that can be formed in between. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-overlaps","title":"function overlaps","text":"<pre><code>template &lt;typename ThatTraits &gt;\ninline bool overlaps(\nconst BasicInterval&lt; ThatTraits &gt; &amp; that\n) const\n</code></pre> <p>Returns true iff the minimal bounding range for <code>this</code> and <code>that</code> is non-empty. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-intersection_with","title":"function intersection_with","text":"<pre><code>template &lt;typename ThatTraits &gt;\ninline BasicInterval intersection_with(\nconst BasicInterval&lt; ThatTraits &gt; &amp; that\n) const\n</code></pre> <p>Returns the interval representing the set of values that are in both <code>this</code> and <code>that</code>. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-without","title":"function without","text":"<pre><code>inline SmallVec&lt; BasicInterval, 2 &gt; without(\nconst BasicInterval &amp; that\n) const\n</code></pre> <p>Returns the interval representing <code>this</code>, with any overlap with <code>that</code> removed. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-shift_up","title":"function shift_up","text":"<pre><code>template &lt;typename DiffT &gt;\ninline BasicInterval shift_up(\nconst DiffT &amp; d\n) const\n</code></pre> <p>Add the given amount to both lower and upper bounds and return the resulting interval. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#function-shift_down","title":"function shift_down","text":"<pre><code>template &lt;typename DiffT &gt;\ninline BasicInterval shift_down(\nconst DiffT &amp; d\n) const\n</code></pre> <p>Subtract the given amount from both lower and upper bounds and return the resulting interval. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#variable-lower_bound","title":"variable lower_bound","text":"<pre><code>Traits::lower_bound_type lower_bound;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#variable-upper_bound","title":"variable upper_bound","text":"<pre><code>Traits::upper_bound_type upper_bound;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friend-operator","title":"friend operator==","text":"<pre><code>friend bool operator==(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n);\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friend-operator_1","title":"friend operator!=","text":"<pre><code>friend bool operator!=(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n);\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval/#friend-operator_2","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst BasicInterval&lt; TraitsT &gt; &amp; t\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/","title":"batt::BasicInterval::LexicographicalOrder","text":"<p>Total order that sorts intervals first by lower bound, then by upper bound (i.e., by \"dictionary order\").  <code>#include &lt;batteries/interval.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/#public-functions","title":"Public Functions","text":"Name template &lt;typename TraitsL ,typename TraitsR &gt; bool operator()(const BasicInterval&lt; TraitsL &gt; &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) const"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LexicographicalOrder/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename TraitsL ,\ntypename TraitsR &gt;\ninline bool operator()(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/","title":"batt::BasicInterval::LinearOrder","text":"<p>Partial order on Interval values that corresponds to a strict ordering on a one dimensional number line.  More...</p> <p><code>#include &lt;batteries/interval.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#public-functions","title":"Public Functions","text":"Name template &lt;typename TraitsL ,typename TraitsR &gt; bool operator()(const BasicInterval&lt; TraitsL &gt; &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) const template &lt;typename L ,typename TraitsR ,typename  =std::enable_if_t&lt;!std::is_base_of_v, L&gt;&gt;&gt; bool operator()(const L &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) const template &lt;typename TraitsL ,typename R ,typename  =std::enable_if_t&lt;!std::is_base_of_v, R&gt;&gt;&gt; bool operator()(const BasicInterval&lt; TraitsL &gt; &amp; l, const R &amp; r) const"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#detailed-description","title":"Detailed Description","text":"<pre><code>struct batt::BasicInterval::LinearOrder;\n</code></pre> <p>Partial order on Interval values that corresponds to a strict ordering on a one dimensional number line. </p> <p>Any pair of intervals that overlap are considered \"equal\" under this ordering.</p> <p>Requires that the lower bound of the \"greater\" interval is greater than or equal to the upper bound of the \"lesser.\" </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename TraitsL ,\ntypename TraitsR &gt;\ninline bool operator()(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#function-operator_1","title":"function operator()","text":"<pre><code>template &lt;typename L ,\ntypename TraitsR ,\ntypename  =std::enable_if_t&lt;!std::is_base_of_v&lt;BasicInterval&lt;TraitsR&gt;, L&gt;&gt;&gt;\ninline bool operator()(\nconst L &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1BasicInterval_1_1LinearOrder/#function-operator_2","title":"function operator()","text":"<pre><code>template &lt;typename TraitsL ,\ntypename R ,\ntypename  =std::enable_if_t&lt;!std::is_base_of_v&lt;BasicInterval&lt;TraitsL&gt;, R&gt;&gt;&gt;\ninline bool operator()(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst R &amp; r\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/","title":"batt::BasicMCSMutex::Metrics","text":"<p>Metric counters for measuring behavior of MCSMutex locks.  More...</p> <p><code>#include &lt;batteries/async/mcs_lock.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#public-functions","title":"Public Functions","text":"Name void reset()Sets all counters back to zero. Metrics &amp; operator+=(const Metrics &amp; other)Add the counts in <code>other</code> to <code>this</code>."},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#public-attributes","title":"Public Attributes","text":"Name usize acquire_count The total number of lock acquire operations. usize fast_acquire_count The number of lock acquires that were able to take the fast path (single atomic exchange operation). usize spin_acquire_count The number of lock acquires that succeeded without falling back to a Futex wait. usize wait_acquire_count The number of lock acquires that did at least one Futex wait before succeeding. usize init_acquire_spin_count The total number of pre-Futex-wait spin attempts inside acquire. usize wait_acquire_spin_count The total number of post-Futex-wait spin attempts inside acquire. usize wait_acquire_futex_count The total number of Futex-wait operations during acquire. usize release_count The total number of lock release operations. usize fast_release_count The number of times release was able to take the fast path (single CAS operation). usize direct_release_count The number of times release was able to signal the next lock in the queue directly without spinning. usize spin_release_count The number of times release needed to enter a spin loop to load the next pointer. usize wait_next_spin_count The total number of spin iterations in release."},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#detailed-description","title":"Detailed Description","text":"<pre><code>struct batt::BasicMCSMutex::Metrics;\n</code></pre> <p>Metric counters for measuring behavior of MCSMutex locks. </p> <p>These are only updatd if kMetricsEnabled is true. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#function-reset","title":"function reset","text":"<pre><code>inline void reset()\n</code></pre> <p>Sets all counters back to zero. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#function-operator","title":"function operator+=","text":"<pre><code>inline Metrics &amp; operator+=(\nconst Metrics &amp; other\n)\n</code></pre> <p>Add the counts in <code>other</code> to <code>this</code>. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-acquire_count","title":"variable acquire_count","text":"<pre><code>usize acquire_count = 0;\n</code></pre> <p>The total number of lock acquire operations. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-fast_acquire_count","title":"variable fast_acquire_count","text":"<pre><code>usize fast_acquire_count = 0;\n</code></pre> <p>The number of lock acquires that were able to take the fast path (single atomic exchange operation). </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-spin_acquire_count","title":"variable spin_acquire_count","text":"<pre><code>usize spin_acquire_count = 0;\n</code></pre> <p>The number of lock acquires that succeeded without falling back to a Futex wait. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-wait_acquire_count","title":"variable wait_acquire_count","text":"<pre><code>usize wait_acquire_count = 0;\n</code></pre> <p>The number of lock acquires that did at least one Futex wait before succeeding. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-init_acquire_spin_count","title":"variable init_acquire_spin_count","text":"<pre><code>usize init_acquire_spin_count = 0;\n</code></pre> <p>The total number of pre-Futex-wait spin attempts inside acquire. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-wait_acquire_spin_count","title":"variable wait_acquire_spin_count","text":"<pre><code>usize wait_acquire_spin_count = 0;\n</code></pre> <p>The total number of post-Futex-wait spin attempts inside acquire. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-wait_acquire_futex_count","title":"variable wait_acquire_futex_count","text":"<pre><code>usize wait_acquire_futex_count = 0;\n</code></pre> <p>The total number of Futex-wait operations during acquire. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-release_count","title":"variable release_count","text":"<pre><code>usize release_count = 0;\n</code></pre> <p>The total number of lock release operations. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-fast_release_count","title":"variable fast_release_count","text":"<pre><code>usize fast_release_count = 0;\n</code></pre> <p>The number of times release was able to take the fast path (single CAS operation). </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-direct_release_count","title":"variable direct_release_count","text":"<pre><code>usize direct_release_count = 0;\n</code></pre> <p>The number of times release was able to signal the next lock in the queue directly without spinning. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-spin_release_count","title":"variable spin_release_count","text":"<pre><code>usize spin_release_count = 0;\n</code></pre> <p>The number of times release needed to enter a spin loop to load the next pointer. </p>"},{"location":"_autogen/Classes/structbatt_1_1BasicMCSMutex_1_1Metrics/#variable-wait_next_spin_count","title":"variable wait_next_spin_count","text":"<pre><code>usize wait_next_spin_count = 0;\n</code></pre> <p>The total number of spin iterations in release. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1ByteSwap/","title":"batt::ByteSwap","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1ByteSwap/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;int kBits&gt;\nstruct batt::ByteSwap;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1DecayRValueRefImpl/","title":"batt::DecayRValueRefImpl","text":"<p>More...</p> <p>Inherits from std::conditional_t&lt; std::is_rvalue_reference_v&lt; T &gt;, std::decay&lt; T &gt;, batt::StaticType&lt; T &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1DecayRValueRefImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::DecayRValueRefImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1DefaultInitialized/","title":"batt::DefaultInitialized","text":"<p>A single type that implicitly converts to any default-constructible type (via batt::make_default()).  <code>#include &lt;batteries/utility.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1DefaultInitialized/#public-functions","title":"Public Functions","text":"Name template &lt;typename T &gt;  operator T() const"},{"location":"_autogen/Classes/structbatt_1_1DefaultInitialized/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1DefaultInitialized/#function-operator-t","title":"function operator T","text":"<pre><code>template &lt;typename T &gt;\ninline operator T() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1DefaultStatusIsRetryableImpl/","title":"batt::DefaultStatusIsRetryableImpl","text":""},{"location":"_autogen/Classes/structbatt_1_1DefaultStatusIsRetryableImpl/#public-functions","title":"Public Functions","text":"Name bool operator()(const Status &amp; s) const"},{"location":"_autogen/Classes/structbatt_1_1DefaultStatusIsRetryableImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1DefaultStatusIsRetryableImpl/#function-operator","title":"function operator()","text":"<pre><code>inline bool operator()(\nconst Status &amp; s\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference/","title":"batt::Difference","text":"<p>Type trait that maps subtractable type <code>T</code> to the difference type.  More...</p> <p><code>#include &lt;batteries/type_traits.hpp&gt;</code></p> <p>Inherits from batt::StaticType&lt; decltype(std::declval&lt; T &gt;() - std::declval&lt; T &gt;())&gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; decltype(std::declval&lt; T &gt;() - std::declval&lt; T &gt;())&gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1Difference/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::Difference;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Difference/#type-trait-that-maps-subtractable-type-t-to-the-difference-type","title":"Type trait that maps subtractable type <code>T</code> to the difference type.","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01std_1_1pair_3_01A_00_01B_01_4_01_4/","title":"batt::Difference&lt; std::pair&lt; A, B &gt; &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticType&lt; std::pair&lt; Difference&lt; A &gt;::type, Difference&lt; B &gt;::type &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01std_1_1pair_3_01A_00_01B_01_4_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; std::pair&lt; Difference&lt; A &gt;::type, Difference&lt; B &gt;::type &gt; &gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01std_1_1pair_3_01A_00_01B_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename A ,\ntypename B &gt;\nstruct batt::Difference&lt; std::pair&lt; A, B &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","title":"batt::Difference&lt; std::tuple&lt; Ts... &gt; &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticType&lt; std::tuple&lt; Difference&lt; Ts &gt;::type... &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; std::tuple&lt; Difference&lt; Ts &gt;::type... &gt; &gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Ts&gt;\nstruct batt::Difference&lt; std::tuple&lt; Ts... &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01char_01_4/","title":"batt::Difference&lt; unsigned char &gt;","text":"<p>Inherits from batt::StaticType&lt; char &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01char_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; char &gt;</p> Name using T type <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01long_01_4/","title":"batt::Difference&lt; unsigned long &gt;","text":"<p>Inherits from batt::StaticType&lt; long &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01long_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; long &gt;</p> Name using T type <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01long_01long_01_4/","title":"batt::Difference&lt; unsigned long long &gt;","text":"<p>Inherits from batt::StaticType&lt; long long &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01long_01long_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; long long &gt;</p> Name using T type <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01short_01_4/","title":"batt::Difference&lt; unsigned short &gt;","text":"<p>Inherits from batt::StaticType&lt; short &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1Difference_3_01unsigned_01short_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; short &gt;</p> Name using T type <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/","title":"batt::DoNothing","text":""},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-types","title":"Public Types","text":"Name using void result_type"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args&gt; void operator()(Args &amp;&amp; ...) const"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#using-result_type","title":"using result_type","text":"<pre><code>using batt::DoNothing::result_type =  void;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1DoNothing/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename... Args&gt;\ninline void operator()(\nArgs &amp;&amp; ...\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1DumpReadWriteLockState/","title":"batt::DumpReadWriteLockState","text":""},{"location":"_autogen/Classes/structbatt_1_1DumpReadWriteLockState/#public-attributes","title":"Public Attributes","text":"Name u32 state_value"},{"location":"_autogen/Classes/structbatt_1_1DumpReadWriteLockState/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1DumpReadWriteLockState/#variable-state_value","title":"variable state_value","text":"<pre><code>u32 state_value;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/","title":"batt::EscapedStringLiteral","text":""},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-functions","title":"Public Functions","text":"Name std::atomic&lt; usize &gt; &amp; max_show_length()"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-attributes","title":"Public Attributes","text":"Name std::string_view str"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#function-max_show_length","title":"function max_show_length","text":"<pre><code>static inline std::atomic&lt; usize &gt; &amp; max_show_length()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1EscapedStringLiteral/#variable-str","title":"variable str","text":"<pre><code>std::string_view str;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/","title":"batt::ExponentialBackoff","text":""},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-functions","title":"Public Functions","text":"Name ExponentialBackoff with_default_params()"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-attributes","title":"Public Attributes","text":"Name u64 max_attempts u64 initial_delay_usec u64 backoff_factor u64 backoff_divisor u64 max_delay_usec"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#function-with_default_params","title":"function with_default_params","text":"<pre><code>static inline ExponentialBackoff with_default_params()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-max_attempts","title":"variable max_attempts","text":"<pre><code>u64 max_attempts;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-initial_delay_usec","title":"variable initial_delay_usec","text":"<pre><code>u64 initial_delay_usec;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-backoff_factor","title":"variable backoff_factor","text":"<pre><code>u64 backoff_factor;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-backoff_divisor","title":"variable backoff_divisor","text":"<pre><code>u64 backoff_divisor;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ExponentialBackoff/#variable-max_delay_usec","title":"variable max_delay_usec","text":"<pre><code>u64 max_delay_usec;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/","title":"batt::FakeExecutionContext::AlwaysReturnZero","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/#public-functions","title":"Public Functions","text":"Name usize operator()(usize ) const"},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeExecutionContext_1_1AlwaysReturnZero/#function-operator","title":"function operator()","text":"<pre><code>inline usize operator()(\nusize ) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/","title":"batt::FakeTimeService::TimerInstance","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#public-classes","title":"Public Classes","text":"Name struct Impl"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#public-attributes","title":"Public Attributes","text":"Name std::shared_ptr&lt; Impl &gt; impl"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance/#variable-impl","title":"variable impl","text":"<pre><code>std::shared_ptr&lt; Impl &gt; impl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/","title":"batt::FakeTimeService::TimerInstance::Impl","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-functions","title":"Public Functions","text":"Name Impl(FakeTimeService * service, boost::asio::any_io_executor ex, TimePoint expire, UniqueHandler&lt; ErrorCode &gt; h)"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-attributes","title":"Public Attributes","text":"Name FakeTimeService * service_instance boost::asio::any_io_executor executor TimePoint expires_at UniqueHandler&lt; ErrorCode &gt; handler"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#function-impl","title":"function Impl","text":"<pre><code>inline explicit Impl(\nFakeTimeService * service,\nboost::asio::any_io_executor ex,\nTimePoint expire,\nUniqueHandler&lt; ErrorCode &gt; h\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-service_instance","title":"variable service_instance","text":"<pre><code>FakeTimeService * service_instance;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-executor","title":"variable executor","text":"<pre><code>boost::asio::any_io_executor executor;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-expires_at","title":"variable expires_at","text":"<pre><code>TimePoint expires_at;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1FakeTimeService_1_1TimerInstance_1_1Impl/#variable-handler","title":"variable handler","text":"<pre><code>UniqueHandler&lt; ErrorCode &gt; handler;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/","title":"batt::GreatestLowerBound","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#public-attributes","title":"Public Attributes","text":"Name T value"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::GreatestLowerBound;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1GreatestLowerBound/#variable-value","title":"variable value","text":"<pre><code>T value;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/","title":"batt::HexByteDumper","text":""},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/#public-attributes","title":"Public Attributes","text":"Name std::string_view bytes"},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HexByteDumper/#variable-bytes","title":"variable bytes","text":"<pre><code>std::string_view bytes;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/","title":"batt::HistogramMetric::Bucket","text":"<p>Represents a single histogram bucket for reporting.  <code>#include &lt;batteries/metrics/metric_collectors.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#public-functions","title":"Public Functions","text":"Name Bucket() =deleted Bucket(T upper, T count, T total)"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#public-attributes","title":"Public Attributes","text":"Name const T upper Bucket's upper-bound. const T count Bucket's counted number of samples. const T total Bucket's total sum of samples."},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#function-bucket","title":"function Bucket","text":"<pre><code>Bucket() =deleted\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#function-bucket_1","title":"function Bucket","text":"<pre><code>inline explicit Bucket(\nT upper,\nT count,\nT total\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#variable-upper","title":"variable upper","text":"<pre><code>const T upper;\n</code></pre> <p>Bucket's upper-bound. </p>"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#variable-count","title":"variable count","text":"<pre><code>const T count;\n</code></pre> <p>Bucket's counted number of samples. </p>"},{"location":"_autogen/Classes/structbatt_1_1HistogramMetric_1_1Bucket/#variable-total","title":"variable total","text":"<pre><code>const T total;\n</code></pre> <p>Bucket's total sum of samples. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HoldOwnership/","title":"batt::HoldOwnership","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/","title":"batt::HostAddress","text":""},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#public-attributes","title":"Public Attributes","text":"Name std::string scheme std::string hostname Optional&lt; i64 &gt; port"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#friends","title":"Friends","text":"Name usize hash_value(const HostAddress &amp; host_key)"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#variable-scheme","title":"variable scheme","text":"<pre><code>std::string scheme;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#variable-hostname","title":"variable hostname","text":"<pre><code>std::string hostname;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#variable-port","title":"variable port","text":"<pre><code>Optional&lt; i64 &gt; port;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/structbatt_1_1HostAddress/#friend-hash_value","title":"friend hash_value","text":"<pre><code>friend usize hash_value(\nconst HostAddress &amp; host_key\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HttpData/","title":"batt::HttpData","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-functions","title":"Public Functions","text":"Name bool empty() const usize size() const StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(i64 min_count) void consume(i64 count) void close_for_read()"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-attributes","title":"Public Attributes","text":"Name BufferSource source"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-empty","title":"function empty","text":"<pre><code>inline bool empty() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-size","title":"function size","text":"<pre><code>inline usize size() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-fetch_at_least","title":"function fetch_at_least","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; ConstBuffer, 2 &gt; &gt; fetch_at_least(\ni64 min_count\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-consume","title":"function consume","text":"<pre><code>inline void consume(\ni64 count\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#function-close_for_read","title":"function close_for_read","text":"<pre><code>inline void close_for_read()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpData/#variable-source","title":"variable source","text":"<pre><code>BufferSource source;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/","title":"batt::HttpMessageInfo","text":"<p>A summary of information about a response message that is necessary for the connection to correctly handle it.  <code>#include &lt;batteries/http/http_message_info_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#public-functions","title":"Public Functions","text":"Name HttpMessageInfo(const pico_http::Response &amp; response) HttpMessageInfo(const pico_http::Request &amp; request) HttpMessageInfo(int major_version, int minor_version, const batt::SmallVecBase&lt; pico_http::MessageHeader &gt; &amp; headers) bool is_valid() const HttpData get_data(StreamBuffer &amp; input_buffer)"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#public-attributes","title":"Public Attributes","text":"Name Optional&lt; usize &gt; content_length Set from the <code>Content-Length</code> header, if present. bool keep_alive Set to true if <code>Connection: keep-alive</code> was set, or if the HTTP version is 1.1 or later and there is no explicit <code>Connection: close</code> header. bool chunked_encoding Set to true if <code>Transfer-Encoding: chunked</code> is present."},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#function-httpmessageinfo","title":"function HttpMessageInfo","text":"<pre><code>inline explicit HttpMessageInfo(\nconst pico_http::Response &amp; response\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#function-httpmessageinfo_1","title":"function HttpMessageInfo","text":"<pre><code>inline explicit HttpMessageInfo(\nconst pico_http::Request &amp; request\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#function-httpmessageinfo_2","title":"function HttpMessageInfo","text":"<pre><code>inline HttpMessageInfo(\nint major_version,\nint minor_version,\nconst batt::SmallVecBase&lt; pico_http::MessageHeader &gt; &amp; headers\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#function-is_valid","title":"function is_valid","text":"<pre><code>inline bool is_valid() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#function-get_data","title":"function get_data","text":"<pre><code>inline HttpData get_data(\nStreamBuffer &amp; input_buffer\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#variable-content_length","title":"variable content_length","text":"<pre><code>Optional&lt; usize &gt; content_length;\n</code></pre> <p>Set from the <code>Content-Length</code> header, if present. </p>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#variable-keep_alive","title":"variable keep_alive","text":"<pre><code>bool keep_alive;\n</code></pre> <p>Set to true if <code>Connection: keep-alive</code> was set, or if the HTTP version is 1.1 or later and there is no explicit <code>Connection: close</code> header. </p>"},{"location":"_autogen/Classes/structbatt_1_1HttpMessageInfo/#variable-chunked_encoding","title":"variable chunked_encoding","text":"<pre><code>bool chunked_encoding;\n</code></pre> <p>Set to true if <code>Transfer-Encoding: chunked</code> is present. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/","title":"batt::HttpServerSettings","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#public-functions","title":"Public Functions","text":"Name HttpServerSettings with_default_values()Returns a settings object with default values."},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kDefaultMaxConnections constexpr i32 kDefaultIdleConnectionTimeoutMs constexpr usize kDefaultConnectionBufferSize usize max_connections usize max_requests_per_connection i32 idle_connection_timeout_ms usize connection_buffer_size"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#function-with_default_values","title":"function with_default_values","text":"<pre><code>static inline HttpServerSettings with_default_values()\n</code></pre> <p>Returns a settings object with default values. </p>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-kdefaultmaxconnections","title":"variable kDefaultMaxConnections","text":"<pre><code>static constexpr usize kDefaultMaxConnections = 1024;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-kdefaultidleconnectiontimeoutms","title":"variable kDefaultIdleConnectionTimeoutMs","text":"<pre><code>static constexpr i32 kDefaultIdleConnectionTimeoutMs = 60 * 1000;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-kdefaultconnectionbuffersize","title":"variable kDefaultConnectionBufferSize","text":"<pre><code>static constexpr usize kDefaultConnectionBufferSize = 16 * kKiB;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-max_connections","title":"variable max_connections","text":"<pre><code>usize max_connections;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-max_requests_per_connection","title":"variable max_requests_per_connection","text":"<pre><code>usize max_requests_per_connection;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-idle_connection_timeout_ms","title":"variable idle_connection_timeout_ms","text":"<pre><code>i32 idle_connection_timeout_ms;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpServerSettings/#variable-connection_buffer_size","title":"variable connection_buffer_size","text":"<pre><code>usize connection_buffer_size;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/","title":"batt::HttpVersion","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#public-attributes","title":"Public Attributes","text":"Name i32 major_version i32 minor_version"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#variable-major_version","title":"variable major_version","text":"<pre><code>i32 major_version;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1HttpVersion/#variable-minor_version","title":"variable minor_version","text":"<pre><code>i32 minor_version;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IClosed/","title":"batt::IClosed","text":"<p>More...</p> <p>Inherits from batt::IntervalTraits&lt; T, T, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, seq::NaturalOrder, seq::NaturalEquals &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1IClosed/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U  =T&gt;\nstruct batt::IClosed;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IClosedOpen/","title":"batt::IClosedOpen","text":"<p>More...</p> <p>Inherits from batt::IntervalTraits&lt; T, T, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, seq::NaturalOrder, seq::NaturalEquals &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1IClosedOpen/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U  =T&gt;\nstruct batt::IClosedOpen;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1InPlaceInitType/","title":"batt::InPlaceInitType","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits/","title":"batt::IntervalTraits","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U ,\nInclusiveLowerBound kLowerInclusive,\nInclusiveUpperBound kUpperInclusive,\ntypename OrderFn ,\ntypename EqualFn &gt;\nstruct batt::IntervalTraits;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/","title":"batt::IntervalTraitsBase","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-types","title":"Public Types","text":"Name using IntervalTraitsBase Base"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-functions","title":"Public Functions","text":"Name template &lt;typename T0 ,typename T1 &gt; bool less_than(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; std::common_type_t&lt; T0, T1 &gt; min(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; std::common_type_t&lt; T0, T1 &gt; max(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool not_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool greater_than(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool less_or_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool greater_or_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool x_included_by_lower(const T0 &amp; x, const T1 &amp; lower) template &lt;typename T0 ,typename T1 &gt; bool upper_includes_x(const T0 &amp; upper, const T1 &amp; x) template &lt;typename T0 ,typename T1 &gt; bool lower_excludes_x(const T0 &amp; lower, const T0 &amp; x) template &lt;typename T0 ,typename T1 &gt; bool x_excluded_by_upper(const T0 &amp; x, const T1 &amp; upper) template &lt;typename T0 ,typename T1 &gt; bool x_excluded_by_lower(const T0 &amp; x, const T1 &amp; lower) template &lt;typename T0 ,typename T1 &gt; bool upper_excludes_x(const T0 &amp; upper, const T1 &amp; x)"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Derived ,\ntypename OrderFn ,\ntypename EqualFn &gt;\nstruct batt::IntervalTraitsBase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#using-base","title":"using Base","text":"<pre><code>using batt::IntervalTraitsBase&lt; Derived, OrderFn, EqualFn &gt;::Base =  IntervalTraitsBase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-less_than","title":"function less_than","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool less_than(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-min","title":"function min","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline std::common_type_t&lt; T0, T1 &gt; min(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-max","title":"function max","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline std::common_type_t&lt; T0, T1 &gt; max(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-equal","title":"function equal","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool equal(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-not_equal","title":"function not_equal","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool not_equal(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-greater_than","title":"function greater_than","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool greater_than(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-less_or_equal","title":"function less_or_equal","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool less_or_equal(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-greater_or_equal","title":"function greater_or_equal","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool greater_or_equal(\nconst T0 &amp; left,\nconst T1 &amp; right\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-x_included_by_lower","title":"function x_included_by_lower","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool x_included_by_lower(\nconst T0 &amp; x,\nconst T1 &amp; lower\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-upper_includes_x","title":"function upper_includes_x","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool upper_includes_x(\nconst T0 &amp; upper,\nconst T1 &amp; x\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-lower_excludes_x","title":"function lower_excludes_x","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool lower_excludes_x(\nconst T0 &amp; lower,\nconst T0 &amp; x\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-x_excluded_by_upper","title":"function x_excluded_by_upper","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool x_excluded_by_upper(\nconst T0 &amp; x,\nconst T1 &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-x_excluded_by_lower","title":"function x_excluded_by_lower","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool x_excluded_by_lower(\nconst T0 &amp; x,\nconst T1 &amp; lower\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraitsBase/#function-upper_excludes_x","title":"function upper_excludes_x","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\nstatic inline bool upper_excludes_x(\nconst T0 &amp; upper,\nconst T1 &amp; x\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/","title":"batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;","text":"<p>More...</p> <p>Inherits from batt::IntervalTraitsBase&lt; IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;, OrderFn, EqualFn &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-types","title":"Public Types","text":"Name using T lower_bound_type using U upper_bound_type using IntervalTraits Self"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-functions","title":"Public Functions","text":"Name std::ptrdiff_t size(const T &amp; lower, const U &amp; upper) bool empty(const T &amp; lower, const U &amp; upper) template &lt;typename V &gt; bool lower_includes_x(const T &amp; lower, const V &amp; x) template &lt;typename V &gt; bool x_included_by_upper(const V &amp; x, const U &amp; upper) template &lt;typename T1 ,typename U1 &gt; bool adjacent(const T &amp; a_lower, const U &amp; a_upper, const T1 &amp; b_lower, const U1 &amp; b_upper) char left_bracket() char right_bracket()"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-attributes","title":"Public Attributes","text":"Name constexpr InclusiveLowerBound inclusive_lower_bound constexpr InclusiveUpperBound inclusive_upper_bound"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::IntervalTraitsBase&lt; IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;, OrderFn, EqualFn &gt;</p> Name using IntervalTraitsBase Base <p>Public Functions inherited from batt::IntervalTraitsBase&lt; IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;, OrderFn, EqualFn &gt;</p> Name template &lt;typename T0 ,typename T1 &gt; bool less_than(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; std::common_type_t&lt; T0, T1 &gt; min(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; std::common_type_t&lt; T0, T1 &gt; max(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool not_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool greater_than(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool less_or_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool greater_or_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool x_included_by_lower(const T0 &amp; x, const T1 &amp; lower) template &lt;typename T0 ,typename T1 &gt; bool upper_includes_x(const T0 &amp; upper, const T1 &amp; x) template &lt;typename T0 ,typename T1 &gt; bool lower_excludes_x(const T0 &amp; lower, const T0 &amp; x) template &lt;typename T0 ,typename T1 &gt; bool x_excluded_by_upper(const T0 &amp; x, const T1 &amp; upper) template &lt;typename T0 ,typename T1 &gt; bool x_excluded_by_lower(const T0 &amp; x, const T1 &amp; lower) template &lt;typename T0 ,typename T1 &gt; bool upper_excludes_x(const T0 &amp; upper, const T1 &amp; x)"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U ,\ntypename OrderFn ,\ntypename EqualFn &gt;\nstruct batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#using-lower_bound_type","title":"using lower_bound_type","text":"<pre><code>using batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;::lower_bound_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#using-upper_bound_type","title":"using upper_bound_type","text":"<pre><code>using batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;::upper_bound_type =  U;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#using-self","title":"using Self","text":"<pre><code>using batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;::Self =  IntervalTraits;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-size","title":"function size","text":"<pre><code>static inline std::ptrdiff_t size(\nconst T &amp; lower,\nconst U &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-empty","title":"function empty","text":"<pre><code>static inline bool empty(\nconst T &amp; lower,\nconst U &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-lower_includes_x","title":"function lower_includes_x","text":"<pre><code>template &lt;typename V &gt;\nstatic inline bool lower_includes_x(\nconst T &amp; lower,\nconst V &amp; x\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-x_included_by_upper","title":"function x_included_by_upper","text":"<pre><code>template &lt;typename V &gt;\nstatic inline bool x_included_by_upper(\nconst V &amp; x,\nconst U &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-adjacent","title":"function adjacent","text":"<pre><code>template &lt;typename T1 ,\ntypename U1 &gt;\nstatic inline bool adjacent(\nconst T &amp; a_lower,\nconst U &amp; a_upper,\nconst T1 &amp; b_lower,\nconst U1 &amp; b_upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-left_bracket","title":"function left_bracket","text":"<pre><code>static inline char left_bracket()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#function-right_bracket","title":"function right_bracket","text":"<pre><code>static inline char right_bracket()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#variable-inclusive_lower_bound","title":"variable inclusive_lower_bound","text":"<pre><code>static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound::kTrue;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperB57a6bdf13058733c8143857b98d05eeb/#variable-inclusive_upper_bound","title":"variable inclusive_upper_bound","text":"<pre><code>static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound::kTrue;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/","title":"batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;","text":"<p>More...</p> <p>Inherits from batt::IntervalTraitsBase&lt; IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;, OrderFn, EqualFn &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-types","title":"Public Types","text":"Name using T lower_bound_type using U upper_bound_type using IntervalTraits Self"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-functions","title":"Public Functions","text":"Name std::ptrdiff_t size(const T &amp; lower, const U &amp; upper) bool empty(const T &amp; lower, const U &amp; upper) template &lt;typename V &gt; bool lower_includes_x(const T &amp; lower, const V &amp; x) template &lt;typename V &gt; bool x_included_by_upper(const V &amp; x, const U &amp; upper) template &lt;typename T1 ,typename U1 &gt; bool adjacent(const T &amp; a_lower, const U &amp; a_upper, const T1 &amp; b_lower, const U1 &amp; b_upper) char left_bracket() char right_bracket()"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-attributes","title":"Public Attributes","text":"Name constexpr InclusiveLowerBound inclusive_lower_bound constexpr InclusiveUpperBound inclusive_upper_bound"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::IntervalTraitsBase&lt; IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;, OrderFn, EqualFn &gt;</p> Name using IntervalTraitsBase Base <p>Public Functions inherited from batt::IntervalTraitsBase&lt; IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;, OrderFn, EqualFn &gt;</p> Name template &lt;typename T0 ,typename T1 &gt; bool less_than(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; std::common_type_t&lt; T0, T1 &gt; min(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; std::common_type_t&lt; T0, T1 &gt; max(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool not_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool greater_than(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool less_or_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool greater_or_equal(const T0 &amp; left, const T1 &amp; right) template &lt;typename T0 ,typename T1 &gt; bool x_included_by_lower(const T0 &amp; x, const T1 &amp; lower) template &lt;typename T0 ,typename T1 &gt; bool upper_includes_x(const T0 &amp; upper, const T1 &amp; x) template &lt;typename T0 ,typename T1 &gt; bool lower_excludes_x(const T0 &amp; lower, const T0 &amp; x) template &lt;typename T0 ,typename T1 &gt; bool x_excluded_by_upper(const T0 &amp; x, const T1 &amp; upper) template &lt;typename T0 ,typename T1 &gt; bool x_excluded_by_lower(const T0 &amp; x, const T1 &amp; lower) template &lt;typename T0 ,typename T1 &gt; bool upper_excludes_x(const T0 &amp; upper, const T1 &amp; x)"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U ,\ntypename OrderFn ,\ntypename EqualFn &gt;\nstruct batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#using-lower_bound_type","title":"using lower_bound_type","text":"<pre><code>using batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;::lower_bound_type =  T;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#using-upper_bound_type","title":"using upper_bound_type","text":"<pre><code>using batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;::upper_bound_type =  U;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#using-self","title":"using Self","text":"<pre><code>using batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt;::Self =  IntervalTraits;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-size","title":"function size","text":"<pre><code>static inline std::ptrdiff_t size(\nconst T &amp; lower,\nconst U &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-empty","title":"function empty","text":"<pre><code>static inline bool empty(\nconst T &amp; lower,\nconst U &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-lower_includes_x","title":"function lower_includes_x","text":"<pre><code>template &lt;typename V &gt;\nstatic inline bool lower_includes_x(\nconst T &amp; lower,\nconst V &amp; x\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-x_included_by_upper","title":"function x_included_by_upper","text":"<pre><code>template &lt;typename V &gt;\nstatic inline bool x_included_by_upper(\nconst V &amp; x,\nconst U &amp; upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-adjacent","title":"function adjacent","text":"<pre><code>template &lt;typename T1 ,\ntypename U1 &gt;\nstatic inline bool adjacent(\nconst T &amp; a_lower,\nconst U &amp; a_upper,\nconst T1 &amp; b_lower,\nconst U1 &amp; b_upper\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-left_bracket","title":"function left_bracket","text":"<pre><code>static inline char left_bracket()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#function-right_bracket","title":"function right_bracket","text":"<pre><code>static inline char right_bracket()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#variable-inclusive_lower_bound","title":"variable inclusive_lower_bound","text":"<pre><code>static constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound::kTrue;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1IntervalTraits_3_01T_00_01U_00_01InclusiveLowerBound_1_1kTrue_00_01InclusiveUpperBf372c7b412dcf8f48278ee8c5dbf848c/#variable-inclusive_upper_bound","title":"variable inclusive_upper_bound","text":"<pre><code>static constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound::kFalse;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq/","title":"batt::IsBoxedSeq","text":"<p>More...</p> <p>Inherits from std::false_type</p>"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::IsBoxedSeq;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq_3_01BoxedSeq_3_01T_01_4_01_4/","title":"batt::IsBoxedSeq&lt; BoxedSeq&lt; T &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::true_type</p>"},{"location":"_autogen/Classes/structbatt_1_1IsBoxedSeq_3_01BoxedSeq_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::IsBoxedSeq&lt; BoxedSeq&lt; T &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IsTuple/","title":"batt::IsTuple","text":"<p>More...</p> <p>Inherits from std::false_type</p>"},{"location":"_autogen/Classes/structbatt_1_1IsTuple/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::IsTuple;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IsTuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","title":"batt::IsTuple&lt; std::tuple&lt; Ts... &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::true_type</p>"},{"location":"_autogen/Classes/structbatt_1_1IsTuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Ts&gt;\nstruct batt::IsTuple&lt; std::tuple&lt; Ts... &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IsVariant/","title":"batt::IsVariant","text":"<p>More...</p> <p>Inherits from std::false_type</p>"},{"location":"_autogen/Classes/structbatt_1_1IsVariant/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::IsVariant;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1IsVariant_3_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/","title":"batt::IsVariant&lt; std::variant&lt; Ts... &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::true_type</p>"},{"location":"_autogen/Classes/structbatt_1_1IsVariant_3_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Ts&gt;\nstruct batt::IsVariant&lt; std::variant&lt; Ts... &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/","title":"batt::LeastUpperBound","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#public-attributes","title":"Public Attributes","text":"Name T value"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::LeastUpperBound;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1LeastUpperBound/#variable-value","title":"variable value","text":"<pre><code>T value;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1MapTuple/","title":"batt::MapTuple","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1MapTuple/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;template&lt; typename &gt; class PerTypeT,\ntypename TupleT &gt;\nstruct batt::MapTuple;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1MapTuple_3_01PerTypeT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","title":"batt::MapTuple&lt; PerTypeT, std::tuple&lt; Ts... &gt; &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticType&lt; std::tuple&lt; PerTypeT&lt; Ts &gt;... &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1MapTuple_3_01PerTypeT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; std::tuple&lt; PerTypeT&lt; Ts &gt;... &gt; &gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1MapTuple_3_01PerTypeT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;template&lt; typename &gt; class PerTypeT,\ntypename... Ts&gt;\nstruct batt::MapTuple&lt; PerTypeT, std::tuple&lt; Ts... &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/","title":"batt::MetricLabel","text":""},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#public-attributes","title":"Public Attributes","text":"Name Token key Token value"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#variable-key","title":"variable key","text":"<pre><code>Token key;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1MetricLabel/#variable-value","title":"variable value","text":"<pre><code>Token value;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple/","title":"batt::MorphTuple","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;template&lt; typename... &gt; class TemplateT,\ntypename TupleT &gt;\nstruct batt::MorphTuple;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple_3_01TemplateT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/","title":"batt::MorphTuple&lt; TemplateT, std::tuple&lt; Ts... &gt; &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticType&lt; TemplateT&lt; Ts... &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple_3_01TemplateT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; TemplateT&lt; Ts... &gt; &gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1MorphTuple_3_01TemplateT_00_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;template&lt; typename... &gt; class TemplateT,\ntypename... Ts&gt;\nstruct batt::MorphTuple&lt; TemplateT, std::tuple&lt; Ts... &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Mutex_1_1ThreadSafeBaseIsNotSupportedByType/","title":"batt::Mutex::ThreadSafeBaseIsNotSupportedByType","text":"<p>Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is.  More...</p> <p><code>#include &lt;batteries/async/mutex.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1Mutex_1_1ThreadSafeBaseIsNotSupportedByType/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename &gt;\nstruct batt::Mutex::ThreadSafeBaseIsNotSupportedByType;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Mutex_1_1ThreadSafeBaseIsNotSupportedByType/#returned-by-mutexthread_safe_base-when-no-lock-access-isnt-enabled-the-name-of-this-type-is-designed-to-produce-a-compilation-error-that-makes-it-obvious-what-the-problem-is","title":"Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is.","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1NoneType/","title":"batt::NoneType","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/","title":"batt::NoopDeleter","text":""},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/#public-functions","title":"Public Functions","text":"Name template &lt;typename T &gt; void operator()(T * ) const"},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1NoopDeleter/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename T &gt;\ninline void operator()(\nT * ) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1PrometheusMetricExporter_1_1Metrics/","title":"batt::PrometheusMetricExporter::Metrics","text":""},{"location":"_autogen/Classes/structbatt_1_1PrometheusMetricExporter_1_1Metrics/#public-attributes","title":"Public Attributes","text":"Name CountMetric&lt; u64 &gt; export_count"},{"location":"_autogen/Classes/structbatt_1_1PrometheusMetricExporter_1_1Metrics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1PrometheusMetricExporter_1_1Metrics/#variable-export_count","title":"variable export_count","text":"<pre><code>CountMetric&lt; u64 &gt; export_count {0};\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/","title":"batt::RadixQueue::Hash","text":""},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-types","title":"Public Types","text":"Name using usize value_type"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-functions","title":"Public Functions","text":"Name usize operator()(const RadixQueue &amp; r) const"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#using-value_type","title":"using value_type","text":"<pre><code>using batt::RadixQueue&lt; kCapacityInBits &gt;::Hash::value_type =  usize;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Hash/#function-operator","title":"function operator()","text":"<pre><code>inline usize operator()(\nconst RadixQueue &amp; r\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/","title":"batt::RadixQueue::Segment","text":""},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#public-attributes","title":"Public Attributes","text":"Name u64 radix u64 value"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#friends","title":"Friends","text":"Name std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Segment &amp; t)"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#variable-radix","title":"variable radix","text":"<pre><code>u64 radix = 1;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#variable-value","title":"variable value","text":"<pre><code>u64 value = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#friends_1","title":"Friends","text":""},{"location":"_autogen/Classes/structbatt_1_1RadixQueue_1_1Segment/#friend-operator","title":"friend operator&lt;&lt;","text":"<pre><code>friend std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Segment &amp; t\n);\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1ReadWriteMutex_1_1ThreadSafeBaseIsNotSupportedByType/","title":"batt::ReadWriteMutex::ThreadSafeBaseIsNotSupportedByType","text":"<p>Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is.  More...</p> <p><code>#include &lt;batteries/async/read_write_lock.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1ReadWriteMutex_1_1ThreadSafeBaseIsNotSupportedByType/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename &gt;\nstruct batt::ReadWriteMutex::ThreadSafeBaseIsNotSupportedByType;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ReadWriteMutex_1_1ThreadSafeBaseIsNotSupportedByType/#returned-by-mutexthread_safe_base-when-no-lock-access-isnt-enabled-the-name-of-this-type-is-designed-to-produce-a-compilation-error-that-makes-it-obvious-what-the-problem-is","title":"Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is.","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1ReleaseOwnership/","title":"batt::ReleaseOwnership","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl/","title":"batt::RemoveStatusOrImpl","text":"<p>More...</p> <p>Inherits from batt::StaticType&lt; T &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; T &gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::RemoveStatusOrImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/","title":"batt::RemoveStatusOrImpl&lt; StatusOr&lt; T &gt; &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticType&lt; T &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::StaticType&lt; T &gt;</p> Name using T type"},{"location":"_autogen/Classes/structbatt_1_1RemoveStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::RemoveStatusOrImpl&lt; StatusOr&lt; T &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1RetryState/","title":"batt::RetryState","text":""},{"location":"_autogen/Classes/structbatt_1_1RetryState/#public-attributes","title":"Public Attributes","text":"Name bool should_retry u64 n_attempts u64 prev_delay_usec u64 next_delay_usec"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-should_retry","title":"variable should_retry","text":"<pre><code>bool should_retry = false;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-n_attempts","title":"variable n_attempts","text":"<pre><code>u64 n_attempts = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-prev_delay_usec","title":"variable prev_delay_usec","text":"<pre><code>u64 prev_delay_usec = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1RetryState/#variable-next_delay_usec","title":"variable next_delay_usec","text":"<pre><code>u64 next_delay_usec = 0;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Runtime_1_1WeakNotifySlot/","title":"batt::Runtime::WeakNotifySlot","text":""},{"location":"_autogen/Classes/structbatt_1_1Runtime_1_1WeakNotifySlot/#public-attributes","title":"Public Attributes","text":"Name Watch&lt; u64 &gt; counter Mutex&lt; NoneType &gt; mutex"},{"location":"_autogen/Classes/structbatt_1_1Runtime_1_1WeakNotifySlot/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Runtime_1_1WeakNotifySlot/#variable-counter","title":"variable counter","text":"<pre><code>Watch&lt; u64 &gt; counter;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Runtime_1_1WeakNotifySlot/#variable-mutex","title":"variable mutex","text":"<pre><code>Mutex&lt; NoneType &gt; mutex;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1ScalableGrantIssuer_1_1ConsumerBase/","title":"batt::ScalableGrantIssuer::ConsumerBase","text":"<p>Base for consumer handler type; adds list node and count needed. Inherits from boost::intrusive::slist_base_hook&lt; boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1ScalableGrantIssuer_1_1ConsumerBase/#public-attributes","title":"Public Attributes","text":"Name u64 needed"},{"location":"_autogen/Classes/structbatt_1_1ScalableGrantIssuer_1_1ConsumerBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1ScalableGrantIssuer_1_1ConsumerBase/#variable-needed","title":"variable needed","text":"<pre><code>u64 needed = 0;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/","title":"batt::SeqItem_Impl","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#public-types","title":"Public Types","text":"Name using typename std::decay_t&lt; T &gt;::Item type"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::SeqItem_Impl;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1SeqItem__Impl/#using-type","title":"using type","text":"<pre><code>using batt::SeqItem_Impl&lt; T &gt;::type =  typename std::decay_t&lt;T&gt;::Item;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1SharedPtrImpl/","title":"batt::SharedPtrImpl","text":"<p>More...</p> <p>Inherits from std::conditional&lt; IsRefCounted&lt; T &gt;{}, boost::intrusive_ptr&lt; std::remove_reference_t&lt; T &gt; &gt;, std::shared_ptr&lt; std::remove_reference_t&lt; T &gt; &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1SharedPtrImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::SharedPtrImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/","title":"batt::SizeDumper","text":"<p>Wrapper around <code>usize</code> (<code>std::size_t</code>) that prints as human-readable sizes.  <code>#include &lt;batteries/stream_util.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#public-types","title":"Public Types","text":"Name enum UnitBase { kLog2 = 2, kLog10 = 10}"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#public-functions","title":"Public Functions","text":"Name std::string format(UnitBase base, i32 &amp; parts, i32 &amp; ord, usize &amp; error) const"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#public-attributes","title":"Public Attributes","text":"Name usize value The size value to be printed. bool exact If false, then <code>value</code> will be printed rounded off to the nearest human-friendly unit (mb, kb, etc.); if true, then a longer string will be printed to capture the exact value."},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#enum-unitbase","title":"enum UnitBase","text":"Enumerator Value Description kLog2 2 kLog10 10"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#function-format","title":"function format","text":"<pre><code>inline std::string format(\nUnitBase base,\ni32 &amp; parts,\ni32 &amp; ord,\nusize &amp; error\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#variable-value","title":"variable value","text":"<pre><code>usize value;\n</code></pre> <p>The size value to be printed. </p>"},{"location":"_autogen/Classes/structbatt_1_1SizeDumper/#variable-exact","title":"variable exact","text":"<pre><code>bool exact;\n</code></pre> <p>If false, then <code>value</code> will be printed rounded off to the nearest human-friendly unit (mb, kb, etc.); if true, then a longer string will be printed to capture the exact value. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/","title":"batt::SkipNBinder","text":""},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/#public-attributes","title":"Public Attributes","text":"Name usize n"},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1SkipNBinder/#variable-n","title":"variable n","text":"<pre><code>usize n;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/","title":"batt::StateMachineBranch","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-types","title":"Public Types","text":"Name using StateT state_type using StateHash state_hash_type using StateEqual state_equal_type using RadixQueue&lt; StateMachineTraits&lt; StateT &gt;::kRadixQueueSize &gt; delta_type"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-attributes","title":"Public Attributes","text":"Name state_type snapshot delta_type delta"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename StateT ,\ntypename StateHash ,\ntypename StateEqual &gt;\nstruct batt::StateMachineBranch;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-state_type","title":"using state_type","text":"<pre><code>using batt::StateMachineBranch&lt; StateT, StateHash, StateEqual &gt;::state_type =  StateT;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-state_hash_type","title":"using state_hash_type","text":"<pre><code>using batt::StateMachineBranch&lt; StateT, StateHash, StateEqual &gt;::state_hash_type =  StateHash;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-state_equal_type","title":"using state_equal_type","text":"<pre><code>using batt::StateMachineBranch&lt; StateT, StateHash, StateEqual &gt;::state_equal_type =  StateEqual;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#using-delta_type","title":"using delta_type","text":"<pre><code>using batt::StateMachineBranch&lt; StateT, StateHash, StateEqual &gt;::delta_type =  RadixQueue&lt;StateMachineTraits&lt;StateT&gt;::kRadixQueueSize&gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#variable-snapshot","title":"variable snapshot","text":"<pre><code>state_type snapshot;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineBranch/#variable-delta","title":"variable delta","text":"<pre><code>delta_type delta;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/","title":"batt::StateMachineModelCheckAdvancedOptions","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-types","title":"Public Types","text":"Name using StateMachineModelCheckAdvancedOptions Self"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-functions","title":"Public Functions","text":"Name Self with_default_values()"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-attributes","title":"Public Attributes","text":"Name bool pin_shard_to_cpu usize max_loop_iterations_between_flush usize max_loop_iterations_between_update i64 min_running_time_ms Optional&lt; usize &gt; starting_seed"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#using-self","title":"using Self","text":"<pre><code>using batt::StateMachineModelCheckAdvancedOptions::Self =  StateMachineModelCheckAdvancedOptions;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#function-with_default_values","title":"function with_default_values","text":"<pre><code>static inline Self with_default_values()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-pin_shard_to_cpu","title":"variable pin_shard_to_cpu","text":"<pre><code>bool pin_shard_to_cpu;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-max_loop_iterations_between_flush","title":"variable max_loop_iterations_between_flush","text":"<pre><code>usize max_loop_iterations_between_flush;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-max_loop_iterations_between_update","title":"variable max_loop_iterations_between_update","text":"<pre><code>usize max_loop_iterations_between_update;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-min_running_time_ms","title":"variable min_running_time_ms","text":"<pre><code>i64 min_running_time_ms;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineModelCheckAdvancedOptions/#variable-starting_seed","title":"variable starting_seed","text":"<pre><code>Optional&lt; usize &gt; starting_seed;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/","title":"batt::StateMachineResult","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-functions","title":"Public Functions","text":"Name void update_elapsed_time() double compute_rate(usize count) const void update_rates()"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-attributes","title":"Public Attributes","text":"Name bool ok usize branch_push_count usize branch_pop_count usize branch_miss_count usize state_count usize self_branch_count std::chrono::steady_clock::time_point start_time usize elapsed_ms double states_per_second double branch_pop_per_second double branch_push_per_second std::bitset&lt; 64 &gt; shards Optional&lt; usize &gt; seed"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#function-update_elapsed_time","title":"function update_elapsed_time","text":"<pre><code>inline void update_elapsed_time()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#function-compute_rate","title":"function compute_rate","text":"<pre><code>inline double compute_rate(\nusize count\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#function-update_rates","title":"function update_rates","text":"<pre><code>inline void update_rates()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-ok","title":"variable ok","text":"<pre><code>bool ok = false;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_push_count","title":"variable branch_push_count","text":"<pre><code>usize branch_push_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_pop_count","title":"variable branch_pop_count","text":"<pre><code>usize branch_pop_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_miss_count","title":"variable branch_miss_count","text":"<pre><code>usize branch_miss_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-state_count","title":"variable state_count","text":"<pre><code>usize state_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-self_branch_count","title":"variable self_branch_count","text":"<pre><code>usize self_branch_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-start_time","title":"variable start_time","text":"<pre><code>std::chrono::steady_clock::time_point start_time;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-elapsed_ms","title":"variable elapsed_ms","text":"<pre><code>usize elapsed_ms = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-states_per_second","title":"variable states_per_second","text":"<pre><code>double states_per_second = 0.0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_pop_per_second","title":"variable branch_pop_per_second","text":"<pre><code>double branch_pop_per_second = 0.0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-branch_push_per_second","title":"variable branch_push_per_second","text":"<pre><code>double branch_push_per_second = 0.0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-shards","title":"variable shards","text":"<pre><code>std::bitset&lt; 64 &gt; shards {0};\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineResult/#variable-seed","title":"variable seed","text":"<pre><code>Optional&lt; usize &gt; seed;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/","title":"batt::StateMachineTraits","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#public-attributes","title":"Public Attributes","text":"Name constexpr usize kRadixQueueSize"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename StateT &gt;\nstruct batt::StateMachineTraits;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StateMachineTraits/#variable-kradixqueuesize","title":"variable kRadixQueueSize","text":"<pre><code>static constexpr usize kRadixQueueSize = 256;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticBinaryAssertion/","title":"batt::StaticBinaryAssertion","text":"<p>More...</p> <p>Inherits from std::integral_constant&lt; bool, kCondition &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticBinaryAssertion/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U ,\nT left,\ntypename Op ,\nU right,\nbool kCondition&gt;\nstruct batt::StaticBinaryAssertion;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticSameTypeAssertion/","title":"batt::StaticSameTypeAssertion","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticSameTypeAssertion/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\nstruct batt::StaticSameTypeAssertion;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticType/","title":"batt::StaticType","text":"<p>More...</p> <p>Inherited by batt::RemoveStatusOrImpl&lt; T &gt;, batt::RemoveStatusOrImpl&lt; StatusOr&lt; T &gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#public-types","title":"Public Types","text":"Name using T type"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::StaticType;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StaticType/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StaticType/#using-type","title":"using type","text":"<pre><code>using batt::StaticType&lt; T &gt;::type =  T;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/","title":"batt::StaticValue","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-functions","title":"Public Functions","text":"Name constexpr StaticValue() =default constexpr operator T() const"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-attributes","title":"Public Attributes","text":"Name constexpr T value"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\nT kValue&gt;\nstruct batt::StaticValue;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#function-staticvalue","title":"function StaticValue","text":"<pre><code>constexpr StaticValue() =default\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#function-operator-t","title":"function operator T","text":"<pre><code>inline constexpr operator T() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StaticValue/#variable-value","title":"variable value","text":"<pre><code>static constexpr T value = kValue;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/","title":"batt::Status::CodeEntry","text":""},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#public-attributes","title":"Public Attributes","text":"Name value_type code int enum_value std::string message"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#variable-code","title":"variable code","text":"<pre><code>value_type code;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#variable-enum_value","title":"variable enum_value","text":"<pre><code>int enum_value;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeEntry/#variable-message","title":"variable message","text":"<pre><code>std::string message;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/","title":"batt::Status::CodeGroup","text":""},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#public-functions","title":"Public Functions","text":"Name const char * name() const"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#public-attributes","title":"Public Attributes","text":"Name std::type_index enum_type_index usize index int min_enum_value std::vector&lt; usize &gt; enum_value_to_code std::vector&lt; CodeEntry &gt; entries"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#function-name","title":"function name","text":"<pre><code>inline const char * name() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-enum_type_index","title":"variable enum_type_index","text":"<pre><code>std::type_index enum_type_index {typeid(int)};\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-index","title":"variable index","text":"<pre><code>usize index;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-min_enum_value","title":"variable min_enum_value","text":"<pre><code>int min_enum_value;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-enum_value_to_code","title":"variable enum_value_to_code","text":"<pre><code>std::vector&lt; usize &gt; enum_value_to_code;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1CodeGroup/#variable-entries","title":"variable entries","text":"<pre><code>std::vector&lt; CodeEntry &gt; entries;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Status_1_1ForceLookup/","title":"batt::Status::ForceLookup","text":"<p>Sentinel type passed to Status constructor to force the passed code enum value to be treated as a non-error_code type.  <code>#include &lt;batteries/status.hpp&gt;</code></p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/","title":"batt::StrongType::Delta","text":"<p>Inherits from batt::StrongType&lt; T, Tag &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#public-functions","title":"Public Functions","text":"Name Delta(StrongType value) constexpr StrongType() constexpr StrongType(T init_value)"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Classes inherited from batt::StrongType&lt; T, Tag &gt;</p> Name struct Delta struct Hash <p>Public Types inherited from batt::StrongType&lt; T, Tag &gt;</p> Name using T value_type using Tag tag_type <p>Public Functions inherited from batt::StrongType&lt; T, Tag &gt;</p> Name constexpr T value() const constexpr operator T() const StrongType &amp; operator+=(Delta d) StrongType &amp; operator-=(Delta d)"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#function-delta","title":"function Delta","text":"<pre><code>inline Delta(\nStrongType value\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#function-strongtype","title":"function StrongType","text":"<pre><code>inline constexpr StrongType()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Delta/#function-strongtype_1","title":"function StrongType","text":"<pre><code>inline explicit constexpr StrongType(\nT init_value\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/","title":"batt::StrongType::Hash","text":""},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-types","title":"Public Types","text":"Name using typename std::hash&lt; T &gt;::result_type result_type"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-functions","title":"Public Functions","text":"Name result_type operator()(const StrongType &amp; obj) const"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#using-result_type","title":"using result_type","text":"<pre><code>using batt::StrongType&lt; T, Tag &gt;::Hash::result_type =  typename std::hash&lt;T&gt;::result_type;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1StrongType_1_1Hash/#function-operator","title":"function operator()","text":"<pre><code>inline result_type operator()(\nconst StrongType &amp; obj\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/","title":"batt::TaskSleepImpl","text":""},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/#public-functions","title":"Public Functions","text":"Name template &lt;typename DurationT &gt; void operator()(DurationT &amp;&amp; duration) const"},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1TaskSleepImpl/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename DurationT &gt;\ninline void operator()(\nDurationT &amp;&amp; duration\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/","title":"batt::Task::DebugTrace","text":"<p>Stack trace and debug information collected from a Task.  <code>#include &lt;batteries/async/task_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#public-attributes","title":"Public Attributes","text":"Name boost::stacktrace::stacktrace stack_trace std::string debug_info StateBitset state_bits isize stack_growth_bytes"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-stack_trace","title":"variable stack_trace","text":"<pre><code>boost::stacktrace::stacktrace stack_trace;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-debug_info","title":"variable debug_info","text":"<pre><code>std::string debug_info;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-state_bits","title":"variable state_bits","text":"<pre><code>StateBitset state_bits;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1DebugTrace/#variable-stack_growth_bytes","title":"variable stack_growth_bytes","text":"<pre><code>isize stack_growth_bytes;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/","title":"batt::Task::Options","text":"<p>Optional params for Task creation.  <code>#include &lt;batteries/async/task_decl.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#public-functions","title":"Public Functions","text":"Name template &lt;typename... Args&gt; Options from_args(Args &amp;&amp;... args) Options &amp; set_params() template &lt;typename... Args&gt; Options &amp; set_params(std::string &amp;&amp; name, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(const char * name, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(StackSize stack_size, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(StackType stack_type, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(Priority priority, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(DeferStart defer_start, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(GetIsStarted get_is_started, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(const StackAllocator &amp; stack_allocator, Args &amp;&amp;... args) template &lt;typename... Args&gt; Options &amp; set_params(StackAllocator &amp;&amp; stack_allocator, Args &amp;&amp;... args) std::string get_name() std::string get_name() const std::string get_name() const StackAllocator get_task_stack_allocator() const StackSize get_stack_size() const StackType get_stack_type() const Priority get_priority() const DeferStart get_defer_start() const void set_is_started(bool is_started) const"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#public-attributes","title":"Public Attributes","text":"Name Optional&lt; std::string &gt; name Optional&lt; StackSize &gt; stack_size Optional&lt; StackType &gt; stack_type Optional&lt; Priority &gt; priority Optional&lt; DeferStart &gt; defer_start Optional&lt; GetIsStarted &gt; get_is_started Optional&lt; StackAllocator &gt; stack_allocator"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-from_args","title":"function from_args","text":"<pre><code>template &lt;typename... Args&gt;\nstatic inline Options from_args(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params","title":"function set_params","text":"<pre><code>inline Options &amp; set_params()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_1","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nstd::string &amp;&amp; name,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_2","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nconst char * name,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_3","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nStackSize stack_size,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_4","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nStackType stack_type,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_5","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nPriority priority,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_6","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nDeferStart defer_start,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_7","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nGetIsStarted get_is_started,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_8","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nconst StackAllocator &amp; stack_allocator,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_params_9","title":"function set_params","text":"<pre><code>template &lt;typename... Args&gt;\ninline Options &amp; set_params(\nStackAllocator &amp;&amp; stack_allocator,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_name","title":"function get_name","text":"<pre><code>inline std::string get_name()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_name_1","title":"function get_name","text":"<pre><code>inline std::string get_name() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_name_2","title":"function get_name","text":"<pre><code>inline std::string get_name() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_task_stack_allocator","title":"function get_task_stack_allocator","text":"<pre><code>inline StackAllocator get_task_stack_allocator() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_stack_size","title":"function get_stack_size","text":"<pre><code>inline StackSize get_stack_size() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_stack_type","title":"function get_stack_type","text":"<pre><code>inline StackType get_stack_type() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_priority","title":"function get_priority","text":"<pre><code>inline Priority get_priority() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-get_defer_start","title":"function get_defer_start","text":"<pre><code>inline DeferStart get_defer_start() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#function-set_is_started","title":"function set_is_started","text":"<pre><code>inline void set_is_started(\nbool is_started\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-name","title":"variable name","text":"<pre><code>Optional&lt; std::string &gt; name;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-stack_size","title":"variable stack_size","text":"<pre><code>Optional&lt; StackSize &gt; stack_size;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-stack_type","title":"variable stack_type","text":"<pre><code>Optional&lt; StackType &gt; stack_type;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-priority","title":"variable priority","text":"<pre><code>Optional&lt; Priority &gt; priority;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-defer_start","title":"variable defer_start","text":"<pre><code>Optional&lt; DeferStart &gt; defer_start;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-get_is_started","title":"variable get_is_started","text":"<pre><code>Optional&lt; GetIsStarted &gt; get_is_started;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1Task_1_1Options/#variable-stack_allocator","title":"variable stack_allocator","text":"<pre><code>Optional&lt; StackAllocator &gt; stack_allocator;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/","title":"batt::ThreadPoolConfig","text":""},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/#public-attributes","title":"Public Attributes","text":"Name usize thread_count usize cpu_group_size usize first_cpu bool pin"},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/#variable-thread_count","title":"variable thread_count","text":"<pre><code>usize thread_count;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/#variable-cpu_group_size","title":"variable cpu_group_size","text":"<pre><code>usize cpu_group_size;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/#variable-first_cpu","title":"variable first_cpu","text":"<pre><code>usize first_cpu;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1ThreadPoolConfig/#variable-pin","title":"variable pin","text":"<pre><code>bool pin;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf/","title":"batt::TupleIndexOf","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename TupleT ,\ntypename T &gt;\nstruct batt::TupleIndexOf;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01First_00_01Rest_8_8_8_01_4_00_01T_01_4/","title":"batt::TupleIndexOf&lt; std::tuple&lt; First, Rest... &gt;, T &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticValue&lt; decltype((1u+TupleIndexOf&lt; std::tuple&lt; Rest... &gt;, T &gt;::value)),((1u+TupleIndexOf&lt; std::tuple&lt; Rest... &gt;, T &gt;::value))&gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01First_00_01Rest_8_8_8_01_4_00_01T_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::StaticValue&lt; decltype((1u+TupleIndexOf&lt; std::tuple&lt; Rest... &gt;, T &gt;::value)),((1u+TupleIndexOf&lt; std::tuple&lt; Rest... &gt;, T &gt;::value))&gt;</p> Name constexpr StaticValue() =default constexpr operator T() const <p>Public Attributes inherited from batt::StaticValue&lt; decltype((1u+TupleIndexOf&lt; std::tuple&lt; Rest... &gt;, T &gt;::value)),((1u+TupleIndexOf&lt; std::tuple&lt; Rest... &gt;, T &gt;::value))&gt;</p> Name constexpr T value"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01First_00_01Rest_8_8_8_01_4_00_01T_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename First ,\ntypename... Rest&gt;\nstruct batt::TupleIndexOf&lt; std::tuple&lt; First, Rest... &gt;, T &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01T_00_01Rest_8_8_8_01_4_00_01T_01_4/","title":"batt::TupleIndexOf&lt; std::tuple&lt; T, Rest... &gt;, T &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticValue&lt; decltype(0u),(0u)&gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01T_00_01Rest_8_8_8_01_4_00_01T_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::StaticValue&lt; decltype(0u),(0u)&gt;</p> Name constexpr StaticValue() =default constexpr operator T() const <p>Public Attributes inherited from batt::StaticValue&lt; decltype(0u),(0u)&gt;</p> Name constexpr T value"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_01T_00_01Rest_8_8_8_01_4_00_01T_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename... Rest&gt;\nstruct batt::TupleIndexOf&lt; std::tuple&lt; T, Rest... &gt;, T &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_4_00_01T_01_4/","title":"batt::TupleIndexOf&lt; std::tuple&lt;&gt;, T &gt;","text":"<p>More...</p> <p>Inherits from batt::StaticValue&lt; decltype(0u),(0u)&gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_4_00_01T_01_4/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from batt::StaticValue&lt; decltype(0u),(0u)&gt;</p> Name constexpr StaticValue() =default constexpr operator T() const <p>Public Attributes inherited from batt::StaticValue&lt; decltype(0u),(0u)&gt;</p> Name constexpr T value"},{"location":"_autogen/Classes/structbatt_1_1TupleIndexOf_3_01std_1_1tuple_3_4_00_01T_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::TupleIndexOf&lt; std::tuple&lt;&gt;, T &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/","title":"batt::UrlParse","text":""},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#public-attributes","title":"Public Attributes","text":"Name std::string_view scheme std::string_view user std::string_view host Optional&lt; i64 &gt; port std::string_view path std::string_view query std::string_view fragment"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-scheme","title":"variable scheme","text":"<pre><code>std::string_view scheme;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-user","title":"variable user","text":"<pre><code>std::string_view user;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-host","title":"variable host","text":"<pre><code>std::string_view host;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-port","title":"variable port","text":"<pre><code>Optional&lt; i64 &gt; port;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-path","title":"variable path","text":"<pre><code>std::string_view path;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-query","title":"variable query","text":"<pre><code>std::string_view query;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1UrlParse/#variable-fragment","title":"variable fragment","text":"<pre><code>std::string_view fragment;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/","title":"batt::VecSeqBase","text":"<p>More...</p> <p>Inherited by batt::VecSeq&lt; T &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-functions","title":"Public Functions","text":"Name VecSeqBase(std::vector&lt; T &gt; &amp;&amp; v)"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-attributes","title":"Public Attributes","text":"Name std::vector&lt; T &gt; vec"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::VecSeqBase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#function-vecseqbase","title":"function VecSeqBase","text":"<pre><code>inline explicit VecSeqBase(\nstd::vector&lt; T &gt; &amp;&amp; v\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1VecSeqBase/#variable-vec","title":"variable vec","text":"<pre><code>std::vector&lt; T &gt; vec;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/","title":"batt::WorkSliceParams","text":""},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-functions","title":"Public Functions","text":"Name WorkSliceParams from_worker_pool(WorkerPool &amp; worker_pool)"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-attributes","title":"Public Attributes","text":"Name constexpr TaskSize kDefaultMinTaskSize TaskSize min_task_size TaskCount max_tasks"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#function-from_worker_pool","title":"function from_worker_pool","text":"<pre><code>static inline WorkSliceParams from_worker_pool(\nWorkerPool &amp; worker_pool\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#variable-kdefaultmintasksize","title":"variable kDefaultMinTaskSize","text":"<pre><code>static constexpr TaskSize kDefaultMinTaskSize {512};\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#variable-min_task_size","title":"variable min_task_size","text":"<pre><code>TaskSize min_task_size;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSliceParams/#variable-max_tasks","title":"variable max_tasks","text":"<pre><code>TaskCount max_tasks;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/","title":"batt::WorkSlicePlan","text":""},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-functions","title":"Public Functions","text":"Name WorkSlicePlan(const WorkSliceParams &amp; params, InputSize input_size) template &lt;typename Iter &gt;  WorkSlicePlan(const WorkSliceParams &amp; params, const Iter &amp; first, const Iter &amp; last)"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-attributes","title":"Public Attributes","text":"Name InputSize input_size TaskSize task_size TaskCount n_tasks"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#function-worksliceplan","title":"function WorkSlicePlan","text":"<pre><code>inline explicit WorkSlicePlan(\nconst WorkSliceParams &amp; params,\nInputSize input_size\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#function-worksliceplan_1","title":"function WorkSlicePlan","text":"<pre><code>template &lt;typename Iter &gt;\nexplicit WorkSlicePlan(\nconst WorkSliceParams &amp; params,\nconst Iter &amp; first,\nconst Iter &amp; last\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#variable-input_size","title":"variable input_size","text":"<pre><code>InputSize input_size;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#variable-task_size","title":"variable task_size","text":"<pre><code>TaskSize task_size;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1WorkSlicePlan/#variable-n_tasks","title":"variable n_tasks","text":"<pre><code>TaskCount n_tasks;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseHelper/","title":"batt::detail::EmptyBaseHelper","text":"<p>More...</p> <p>Inherits from T</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseHelper/#public-attributes","title":"Public Attributes","text":"Name char bytes"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseHelper/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::EmptyBaseHelper;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseHelper/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseHelper/#variable-bytes","title":"variable bytes","text":"<pre><code>char bytes;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseTestCase/","title":"batt::detail::EmptyBaseTestCase","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseTestCase2/","title":"batt::detail::EmptyBaseTestCase2","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseTestCase2/#public-attributes","title":"Public Attributes","text":"Name char ch"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseTestCase2/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1EmptyBaseTestCase2/#variable-ch","title":"variable ch","text":"<pre><code>char ch;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl/","title":"batt::detail::FirstMatchImpl","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename CaseTuple ,\ntypename ArgsTuple &gt;\nstruct batt::detail::FirstMatchImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/","title":"batt::detail::FirstMatchImpl&lt; std::tuple&lt; CaseFirst, CaseRest... &gt;, std::tuple&lt; Args... &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::conditional_t&lt; IsCallable&lt; CaseFirst, Args &amp;&amp;... &gt;{}, std::integral_constant&lt; usize, 0 &gt;, std::integral_constant&lt; usize, 1+FirstMatchImpl&lt; std::tuple&lt; CaseRest... &gt;, std::tuple&lt; Args... &gt; &gt;{}&gt; &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#public-functions","title":"Public Functions","text":"Name template &lt;typename Cases &gt; decltype(auto) operator()(Cases &amp;&amp; cases, Args &amp;&amp;... args) const"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename CaseFirst ,\ntypename... CaseRest,\ntypename... Args&gt;\nstruct batt::detail::FirstMatchImpl&lt; std::tuple&lt; CaseFirst, CaseRest... &gt;, std::tuple&lt; Args... &gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_01CaseFirst_00_01CaseRest_8_8_8_01_4_0ef0b86a15b721fa11026a803059cf332/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename Cases &gt;\ninline decltype(auto) operator()(\nCases &amp;&amp; cases,\nArgs &amp;&amp;... args\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_4_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4/","title":"batt::detail::FirstMatchImpl&lt; std::tuple&lt;&gt;, std::tuple&lt; Args... &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::integral_constant&lt; usize, 0 &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstMatchImpl_3_01std_1_1tuple_3_4_00_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... Args&gt;\nstruct batt::detail::FirstMatchImpl&lt; std::tuple&lt;&gt;, std::tuple&lt; Args... &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/","title":"batt::detail::FirstPhase","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-types","title":"Public Types","text":"Name using SecondPhase NextPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-functions","title":"Public Functions","text":"Name const char * name() template &lt;typename Src0 ,typename Src1 &gt; const Src0 &amp; fixed_iter(const Src0 &amp; src_0, const Src1 &amp; ) template &lt;typename Src0 ,typename Src1 &gt; const Src1 &amp; search_iter(const Src0 &amp; , const Src1 &amp; src_1) template &lt;typename Fixed ,typename Search &gt; const Fixed &amp; src_0_iter(const Fixed &amp; fixed, const Search &amp; ) template &lt;typename Fixed ,typename Search &gt; const Search &amp; src_1_iter(const Fixed &amp; , const Search &amp; search)"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#using-nextphase","title":"using NextPhase","text":"<pre><code>using batt::detail::FirstPhase::NextPhase =  SecondPhase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-name","title":"function name","text":"<pre><code>static inline const char * name()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-fixed_iter","title":"function fixed_iter","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 &gt;\nstatic inline const Src0 &amp; fixed_iter(\nconst Src0 &amp; src_0,\nconst Src1 &amp; )\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-search_iter","title":"function search_iter","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 &gt;\nstatic inline const Src1 &amp; search_iter(\nconst Src0 &amp; ,\nconst Src1 &amp; src_1\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-src_0_iter","title":"function src_0_iter","text":"<pre><code>template &lt;typename Fixed ,\ntypename Search &gt;\nstatic inline const Fixed &amp; src_0_iter(\nconst Fixed &amp; fixed,\nconst Search &amp; )\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1FirstPhase/#function-src_1_iter","title":"function src_1_iter","text":"<pre><code>template &lt;typename Fixed ,\ntypename Search &gt;\nstatic inline const Search &amp; src_1_iter(\nconst Fixed &amp; ,\nconst Search &amp; search\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl/","title":"batt::detail::IsStatusOrImpl","text":"<p>More...</p> <p>Inherits from std::false_type</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::IsStatusOrImpl;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/","title":"batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::true_type</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl_3_01StatusOr_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl_3_01StatusOr_3_01T_01_6_01_4_01_4/","title":"batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &amp; &gt; &gt;","text":"<p>More...</p> <p>Inherits from std::true_type</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1IsStatusOrImpl_3_01StatusOr_3_01T_01_6_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &amp; &gt; &gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/","title":"batt::detail::ModelCheckShardMetrics","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#public-attributes","title":"Public Attributes","text":"Name i64 stall_count i64 flush_count i64 send_count i64 recv_count"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-stall_count","title":"variable stall_count","text":"<pre><code>i64 stall_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-flush_count","title":"variable flush_count","text":"<pre><code>i64 flush_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-send_count","title":"variable send_count","text":"<pre><code>i64 send_count = 0;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ModelCheckShardMetrics/#variable-recv_count","title":"variable recv_count","text":"<pre><code>i64 recv_count = 0;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/","title":"batt::detail::NullableImpl","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#public-types","title":"Public Types","text":"Name using std::optional&lt; T &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::NullableImpl;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl/#using-type","title":"using type","text":"<pre><code>using batt::detail::NullableImpl&lt; T &gt;::type =  std::optional&lt;T&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/","title":"batt::detail::NullableImpl&lt; T * &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#public-types","title":"Public Types","text":"Name using T * type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::NullableImpl&lt; T * &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01T_01_5_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::NullableImpl&lt; T * &gt;::type =  T*;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/","title":"batt::detail::NullableImpl&lt; std::optional&lt; T &gt; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#public-types","title":"Public Types","text":"Name using std::optional&lt; T &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::NullableImpl&lt; std::optional&lt; T &gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1optional_3_01T_01_4_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::NullableImpl&lt; std::optional&lt; T &gt; &gt;::type =  std::optional&lt;T&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/","title":"batt::detail::NullableImpl&lt; std::shared_ptr&lt; T &gt; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#public-types","title":"Public Types","text":"Name using std::shared_ptr&lt; T &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::NullableImpl&lt; std::shared_ptr&lt; T &gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1shared__ptr_3_01T_01_4_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::NullableImpl&lt; std::shared_ptr&lt; T &gt; &gt;::type =  std::shared_ptr&lt;T&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/","title":"batt::detail::NullableImpl&lt; std::unique_ptr&lt; T &gt; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#public-types","title":"Public Types","text":"Name using std::unique_ptr&lt; T &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::detail::NullableImpl&lt; std::unique_ptr&lt; T &gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1NullableImpl_3_01std_1_1unique__ptr_3_01T_01_4_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::NullableImpl&lt; std::unique_ptr&lt; T &gt; &gt;::type =  std::unique_ptr&lt;T&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/","title":"batt::detail::SecondPhase","text":"<p>Inherited by batt::detail::ThirdPhase</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-types","title":"Public Types","text":"Name using ThirdPhase NextPhase"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-functions","title":"Public Functions","text":"Name const char * name() template &lt;typename Src0 ,typename Src1 &gt; const Src1 &amp; fixed_iter(const Src0 &amp; , const Src1 &amp; src_1) template &lt;typename Src0 ,typename Src1 &gt; const Src0 &amp; search_iter(const Src0 &amp; src_0, const Src1 &amp; ) template &lt;typename Fixed ,typename Search &gt; const Search &amp; src_0_iter(const Fixed &amp; , const Search &amp; search) template &lt;typename Fixed ,typename Search &gt; const Fixed &amp; src_1_iter(const Fixed &amp; fixed, const Search &amp; )"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#using-nextphase","title":"using NextPhase","text":"<pre><code>using batt::detail::SecondPhase::NextPhase =  ThirdPhase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-name","title":"function name","text":"<pre><code>static inline const char * name()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-fixed_iter","title":"function fixed_iter","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 &gt;\nstatic inline const Src1 &amp; fixed_iter(\nconst Src0 &amp; ,\nconst Src1 &amp; src_1\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-search_iter","title":"function search_iter","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 &gt;\nstatic inline const Src0 &amp; search_iter(\nconst Src0 &amp; src_0,\nconst Src1 &amp; )\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-src_0_iter","title":"function src_0_iter","text":"<pre><code>template &lt;typename Fixed ,\ntypename Search &gt;\nstatic inline const Search &amp; src_0_iter(\nconst Fixed &amp; ,\nconst Search &amp; search\n)\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1SecondPhase/#function-src_1_iter","title":"function src_1_iter","text":"<pre><code>template &lt;typename Fixed ,\ntypename Search &gt;\nstatic inline const Fixed &amp; src_1_iter(\nconst Fixed &amp; fixed,\nconst Search &amp; )\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/","title":"batt::detail::ThirdPhase","text":"<p>Inherits from batt::detail::SecondPhase</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#public-functions","title":"Public Functions","text":"Name const char * name()"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Types inherited from batt::detail::SecondPhase</p> Name using ThirdPhase NextPhase <p>Public Functions inherited from batt::detail::SecondPhase</p> Name template &lt;typename Src0 ,typename Src1 &gt; const Src1 &amp; fixed_iter(const Src0 &amp; , const Src1 &amp; src_1) template &lt;typename Src0 ,typename Src1 &gt; const Src0 &amp; search_iter(const Src0 &amp; src_0, const Src1 &amp; ) template &lt;typename Fixed ,typename Search &gt; const Search &amp; src_0_iter(const Fixed &amp; , const Search &amp; search) template &lt;typename Fixed ,typename Search &gt; const Fixed &amp; src_1_iter(const Fixed &amp; fixed, const Search &amp; )"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1ThirdPhase/#function-name","title":"function name","text":"<pre><code>static inline const char * name()\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult/","title":"batt::detail::VisitorResult","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename Variant &gt;\nstruct batt::detail::VisitorResult;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/","title":"batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; decltype(std::declval&lt; Visitor &gt;()(std::declval&lt; Ts &gt;()))... &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename... Ts&gt;\nstruct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &gt;::type =  std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts &gt;()))...&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/","title":"batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; decltype(std::declval&lt; Visitor &gt;()(std::declval&lt; Ts &amp; &gt;()))... &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename... Ts&gt;\nstruct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp; &gt;::type =  std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts &amp; &gt;()))...&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/","title":"batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp;&amp; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; decltype(std::declval&lt; Visitor &gt;()(std::declval&lt; Ts &amp;&amp; &gt;()))... &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename... Ts&gt;\nstruct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp;&amp; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_6_6_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp;&amp; &gt;::type =  std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts &amp;&amp; &gt;()))...&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/","title":"batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; decltype(std::declval&lt; Visitor &gt;()(std::declval&lt; Ts const &gt;()))... &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename... Ts&gt;\nstruct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &gt;::type =  std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts const &gt;()))...&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/","title":"batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; decltype(std::declval&lt; Visitor &gt;()(std::declval&lt; Ts const  &amp; &gt;()))... &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename... Ts&gt;\nstruct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp; &gt;::type =  std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts const&amp; &gt;()))...&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/","title":"batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp;&amp; &gt;","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#public-types","title":"Public Types","text":"Name using std::common_type_t&lt; decltype(std::declval&lt; Visitor &gt;()(std::declval&lt; Ts const  &amp;&amp; &gt;()))... &gt; type"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Visitor ,\ntypename... Ts&gt;\nstruct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp;&amp; &gt;;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1detail_1_1VisitorResult_3_01Visitor_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01const_01_6_6_01_4/#using-type","title":"using type","text":"<pre><code>using batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp;&amp; &gt;::type =  std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts const&amp;&amp; &gt;()))...&gt;;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1features_1_1State/","title":"batt::features::State","text":"<p>Captures the normative feature mask plus the stack trace where the global singleton instance of this type was initialized.  <code>#include &lt;batteries/config.hpp&gt;</code></p>"},{"location":"_autogen/Classes/structbatt_1_1features_1_1State/#public-attributes","title":"Public Attributes","text":"Name boost::stacktrace::stacktrace init_trace const mask_type mask"},{"location":"_autogen/Classes/structbatt_1_1features_1_1State/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1features_1_1State/#variable-init_trace","title":"variable init_trace","text":"<pre><code>boost::stacktrace::stacktrace init_trace;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1features_1_1State/#variable-mask","title":"variable mask","text":"<pre><code>const mask_type mask = get_feature_mask();\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/","title":"batt::seq::Addition","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/#public-functions","title":"Public Functions","text":"Name template &lt;typename L ,typename R &gt; decltype(auto) operator()(L &amp;&amp; l, R &amp;&amp; r) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Addition/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename L ,\ntypename R &gt;\ninline decltype(auto) operator()(\nL &amp;&amp; l,\nR &amp;&amp; r\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AllBinder/","title":"batt::seq::AllBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AnyBinder/","title":"batt::seq::AnyBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/","title":"batt::seq::ApplyBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#public-attributes","title":"Public Attributes","text":"Name SeqFn seq_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename SeqFn &gt;\nstruct batt::seq::ApplyBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ApplyBinder/#variable-seq_fn","title":"variable seq_fn","text":"<pre><code>SeqFn seq_fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/","title":"batt::seq::AttachBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#public-attributes","title":"Public Attributes","text":"Name D data"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename D &gt;\nstruct batt::seq::AttachBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1AttachBinder/#variable-data","title":"variable data","text":"<pre><code>D data;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1BoxedBinder/","title":"batt::seq::BoxedBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1CacheNextBinder/","title":"batt::seq::CacheNextBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/","title":"batt::seq::ChainBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#public-attributes","title":"Public Attributes","text":"Name Seq2 seq2"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Seq2 &gt;\nstruct batt::seq::ChainBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ChainBinder/#variable-seq2","title":"variable seq2","text":"<pre><code>Seq2 seq2;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Collect/","title":"batt::seq::Collect","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Collect/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T &gt;\nstruct batt::seq::Collect;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1CollectVec/","title":"batt::seq::CollectVec","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Consume/","title":"batt::seq::Consume","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1CountBinder/","title":"batt::seq::CountBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/","title":"batt::seq::DecayItem","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/#public-functions","title":"Public Functions","text":"Name template &lt;typename T &gt; std::decay_t&lt; T &gt; operator()(T &amp;&amp; val) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1DecayItem/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename T &gt;\ninline std::decay_t&lt; T &gt; operator()(\nT &amp;&amp; val\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/","title":"batt::seq::Deref","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/#public-functions","title":"Public Functions","text":"Name template &lt;typename T &gt; auto operator()(T &amp;&amp; val) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Deref/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename T &gt;\ninline auto operator()(\nT &amp;&amp; val\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/","title":"batt::seq::FilterBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#public-attributes","title":"Public Attributes","text":"Name Predicate predicate"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Predicate &gt;\nstruct batt::seq::FilterBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterBinder/#variable-predicate","title":"variable predicate","text":"<pre><code>Predicate predicate;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/","title":"batt::seq::FilterMapBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#public-attributes","title":"Public Attributes","text":"Name Fn fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nstruct batt::seq::FilterMapBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FilterMapBinder/#variable-fn","title":"variable fn","text":"<pre><code>Fn fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FirstBinder/","title":"batt::seq::FirstBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FlattenBinder/","title":"batt::seq::FlattenBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/","title":"batt::seq::ForEachBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#public-attributes","title":"Public Attributes","text":"Name Fn fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nstruct batt::seq::ForEachBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ForEachBinder/#variable-fn","title":"variable fn","text":"<pre><code>Fn fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1FuseBinder/","title":"batt::seq::FuseBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/","title":"batt::seq::GroupByBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#public-attributes","title":"Public Attributes","text":"Name GroupEq group_eq"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename GroupEq &gt;\nstruct batt::seq::GroupByBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1GroupByBinder/#variable-group_eq","title":"variable group_eq","text":"<pre><code>GroupEq group_eq;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/","title":"batt::seq::InnerReduceBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#public-attributes","title":"Public Attributes","text":"Name ReduceFn reduce_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename ReduceFn &gt;\nstruct batt::seq::InnerReduceBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InnerReduceBinder/#variable-reduce_fn","title":"variable reduce_fn","text":"<pre><code>ReduceFn reduce_fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/","title":"batt::seq::InspectAdjacentBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#public-attributes","title":"Public Attributes","text":"Name Fn fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nstruct batt::seq::InspectAdjacentBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1InspectAdjacentBinder/#variable-fn","title":"variable fn","text":"<pre><code>Fn fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/","title":"batt::seq::IsNotFalse","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/#public-functions","title":"Public Functions","text":"Name template &lt;typename T &gt; bool operator()(T &amp;&amp; val) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsNotFalse/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator()(\nT &amp;&amp; val\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/","title":"batt::seq::IsSortedBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#public-attributes","title":"Public Attributes","text":"Name Compare compare"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Compare &gt;\nstruct batt::seq::IsSortedBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1IsSortedBinder/#variable-compare","title":"variable compare","text":"<pre><code>Compare compare;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/","title":"batt::seq::KMergeByBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#public-attributes","title":"Public Attributes","text":"Name Compare compare"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Compare &gt;\nstruct batt::seq::KMergeByBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1KMergeByBinder/#variable-compare","title":"variable compare","text":"<pre><code>Compare compare;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1LastBinder/","title":"batt::seq::LastBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/","title":"batt::seq::MapAdjacentBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#public-attributes","title":"Public Attributes","text":"Name Fn fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nstruct batt::seq::MapAdjacentBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapAdjacentBinder/#variable-fn","title":"variable fn","text":"<pre><code>Fn fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/","title":"batt::seq::MapBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#public-attributes","title":"Public Attributes","text":"Name MapFn map_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename MapFn &gt;\nstruct batt::seq::MapBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapBinder/#variable-map_fn","title":"variable map_fn","text":"<pre><code>MapFn map_fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/","title":"batt::seq::MapFoldBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#public-attributes","title":"Public Attributes","text":"Name State state MapFn map_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename State ,\ntypename MapFn &gt;\nstruct batt::seq::MapFoldBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#variable-state","title":"variable state","text":"<pre><code>State state;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapFoldBinder/#variable-map_fn","title":"variable map_fn","text":"<pre><code>MapFn map_fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/","title":"batt::seq::MapPairwiseBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#public-attributes","title":"Public Attributes","text":"Name RightSeq right MapFn map_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename RightSeq ,\ntypename MapFn &gt;\nstruct batt::seq::MapPairwiseBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#variable-right","title":"variable right","text":"<pre><code>RightSeq right;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MapPairwiseBinder/#variable-map_fn","title":"variable map_fn","text":"<pre><code>MapFn map_fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/","title":"batt::seq::MergeByBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#public-attributes","title":"Public Attributes","text":"Name RightSeq right Compare compare"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename RightSeq ,\ntypename Compare &gt;\nstruct batt::seq::MergeByBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#variable-right","title":"variable right","text":"<pre><code>RightSeq right;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeByBinder/#variable-compare","title":"variable compare","text":"<pre><code>Compare compare;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/","title":"batt::seq::MergeBy::ToItem","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#public-functions","title":"Public Functions","text":"Name template &lt;typename T ,typename  =std::enable_if_t&lt;!std::is_same_v&gt;&gt; Item operator()(T &amp;&amp; item) const template &lt;typename T ,typename  =std::enable_if_t&gt;,typename  =void&gt; Item operator()(T &amp;&amp; item) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;Item, T&amp;&amp;&gt;&gt;&gt;\ninline Item operator()(\nT &amp;&amp; item\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1MergeBy_1_1ToItem/#function-operator_1","title":"function operator()","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;Item, T&amp;&amp;&gt;&gt;,\ntypename  =void&gt;\ninline Item operator()(\nT &amp;&amp; item\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/","title":"batt::seq::NaturalEquals","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/#public-functions","title":"Public Functions","text":"Name template &lt;typename L ,typename R &gt; bool operator()(L &amp;&amp; l, R &amp;&amp; r) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalEquals/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename L ,\ntypename R &gt;\ninline bool operator()(\nL &amp;&amp; l,\nR &amp;&amp; r\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/","title":"batt::seq::NaturalOrder","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/#public-functions","title":"Public Functions","text":"Name template &lt;typename L ,typename R &gt; bool operator()(L &amp;&amp; l, R &amp;&amp; r) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1NaturalOrder/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename L ,\ntypename R &gt;\ninline bool operator()(\nL &amp;&amp; l,\nR &amp;&amp; r\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/","title":"batt::seq::PrependBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#public-attributes","title":"Public Attributes","text":"Name Item item"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Item &gt;\nstruct batt::seq::PrependBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrependBinder/#variable-item","title":"variable item","text":"<pre><code>Item item;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/","title":"batt::seq::PrintOut","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#public-attributes","title":"Public Attributes","text":"Name std::ostream &amp; out std::string_view sep"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#variable-out","title":"variable out","text":"<pre><code>std::ostream &amp; out;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintOut/#variable-sep","title":"variable sep","text":"<pre><code>std::string_view sep;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1PrintableBinder/","title":"batt::seq::PrintableBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ProductBinder/","title":"batt::seq::ProductBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/","title":"batt::seq::ReduceBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#public-attributes","title":"Public Attributes","text":"Name State state ReduceFn reduce_fn"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename State ,\ntypename ReduceFn &gt;\nstruct batt::seq::ReduceBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#variable-state","title":"variable state","text":"<pre><code>State state;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ReduceBinder/#variable-reduce_fn","title":"variable reduce_fn","text":"<pre><code>ReduceFn reduce_fn;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/","title":"batt::seq::Reverse","text":"<p>More...</p> <p>Inherits from Fn</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#public-functions","title":"Public Functions","text":"Name template &lt;typename Left ,typename Right &gt; decltype(auto) operator()(Left &amp;&amp; left, Right &amp;&amp; right) const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Fn &gt;\nstruct batt::seq::Reverse;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1Reverse/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename Left ,\ntypename Right &gt;\ninline decltype(auto) operator()(\nLeft &amp;&amp; left,\nRight &amp;&amp; right\n) const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/","title":"batt::seq::RollingBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#public-attributes","title":"Public Attributes","text":"Name BinaryFn binary_fn T initial"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename T ,\ntypename BinaryFn &gt;\nstruct batt::seq::RollingBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#variable-binary_fn","title":"variable binary_fn","text":"<pre><code>BinaryFn binary_fn;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingBinder/#variable-initial","title":"variable initial","text":"<pre><code>T initial;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1RollingSumBinder/","title":"batt::seq::RollingSumBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/","title":"batt::seq::SpliceBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#public-attributes","title":"Public Attributes","text":"Name usize n InnerSeq inner_seq"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename InnerSeq &gt;\nstruct batt::seq::SpliceBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#variable-n","title":"variable n","text":"<pre><code>usize n;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SpliceBinder/#variable-inner_seq","title":"variable inner_seq","text":"<pre><code>InnerSeq inner_seq;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1StatusOkBinder/","title":"batt::seq::StatusOkBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1SumBinder/","title":"batt::seq::SumBinder","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/","title":"batt::seq::TakeNBinder","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/#public-attributes","title":"Public Attributes","text":"Name usize n"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeNBinder/#variable-n","title":"variable n","text":"<pre><code>usize n;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/","title":"batt::seq::TakeWhileBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#public-attributes","title":"Public Attributes","text":"Name Predicate predicate"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Predicate &gt;\nstruct batt::seq::TakeWhileBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1TakeWhileBinder/#variable-predicate","title":"variable predicate","text":"<pre><code>Predicate predicate;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/","title":"batt::seq::WriteToBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#public-attributes","title":"Public Attributes","text":"Name AsyncWriteStream dst"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename AsyncWriteStream &gt;\nstruct batt::seq::WriteToBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1WriteToBinder/#variable-dst","title":"variable dst","text":"<pre><code>AsyncWriteStream dst;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ZipBinder/","title":"batt::seq::ZipBinder","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ZipBinder/#public-attributes","title":"Public Attributes","text":"Name std::tuple&lt; OtherSeqs... &gt; other_seqs"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ZipBinder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename... OtherSeqs&gt;\nstruct batt::seq::ZipBinder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ZipBinder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1ZipBinder/#variable-other_seqs","title":"variable other_seqs","text":"<pre><code>std::tuple&lt; OtherSeqs... &gt; other_seqs;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/","title":"batt::seq::detail::HeapOrder","text":"<p>More...</p> <p>Inherits from std::conditional_t&lt; can_be_empty_base&lt; Compare &gt;(), HeapOrderEmptyBase&lt; Compare &gt;, HeapOrderBase&lt; Compare &gt; &gt;</p> <p>Inherited by batt::seq::KMergeBy&lt; Seq, Compare &gt;</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/#public-functions","title":"Public Functions","text":"Name template &lt;typename L ,typename R &gt; bool operator()(L * l, R * r) const HeapOrder &amp; order() const HeapOrder &amp; order() const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Compare &gt;\nstruct batt::seq::detail::HeapOrder;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/#function-operator","title":"function operator()","text":"<pre><code>template &lt;typename L ,\ntypename R &gt;\ninline bool operator()(\nL * l,\nR * r\n) const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/#function-order","title":"function order","text":"<pre><code>inline HeapOrder &amp; order()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrder/#function-order_1","title":"function order","text":"<pre><code>inline const HeapOrder &amp; order() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/","title":"batt::seq::detail::HeapOrderBase","text":"<p>More...</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#public-functions","title":"Public Functions","text":"Name Compare &amp; compare() const Compare &amp; compare() const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#public-attributes","title":"Public Attributes","text":"Name Compare compare_"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Compare &gt;\nstruct batt::seq::detail::HeapOrderBase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#function-compare","title":"function compare","text":"<pre><code>inline Compare &amp; compare()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#function-compare_1","title":"function compare","text":"<pre><code>inline const Compare &amp; compare() const\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderBase/#variable-compare_","title":"variable compare_","text":"<pre><code>Compare compare_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderEmptyBase/","title":"batt::seq::detail::HeapOrderEmptyBase","text":"<p>More...</p> <p>Inherits from Compare</p>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderEmptyBase/#public-functions","title":"Public Functions","text":"Name Compare &amp; compare() const Compare &amp; compare() const"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderEmptyBase/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Compare &gt;\nstruct batt::seq::detail::HeapOrderEmptyBase;\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderEmptyBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderEmptyBase/#function-compare","title":"function compare","text":"<pre><code>inline Compare &amp; compare()\n</code></pre>"},{"location":"_autogen/Classes/structbatt_1_1seq_1_1detail_1_1HeapOrderEmptyBase/#function-compare_1","title":"function compare","text":"<pre><code>inline const Compare &amp; compare() const\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/","title":"pico_http::ChunkedDecoder","text":""},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#public-attributes","title":"Public Attributes","text":"Name usize bytes_left_in_chunk bool consume_trailer i8 hex_count_ i8 state_"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-bytes_left_in_chunk","title":"variable bytes_left_in_chunk","text":"<pre><code>usize bytes_left_in_chunk;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-consume_trailer","title":"variable consume_trailer","text":"<pre><code>bool consume_trailer;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-hex_count_","title":"variable hex_count_","text":"<pre><code>i8 hex_count_;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1ChunkedDecoder/#variable-state_","title":"variable state_","text":"<pre><code>i8 state_;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/","title":"pico_http::DecodeResult","text":""},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#public-attributes","title":"Public Attributes","text":"Name bool done usize bytes_consumed"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#variable-done","title":"variable done","text":"<pre><code>bool done;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1DecodeResult/#variable-bytes_consumed","title":"variable bytes_consumed","text":"<pre><code>usize bytes_consumed;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/","title":"pico_http::MessageHeader","text":""},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#public-functions","title":"Public Functions","text":"Name MessageHeader() =default MessageHeader(std::string_view name, std::string_view value)"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#public-attributes","title":"Public Attributes","text":"Name std::string_view name std::string_view value"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#function-messageheader","title":"function MessageHeader","text":"<pre><code>MessageHeader() =default\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#function-messageheader_1","title":"function MessageHeader","text":"<pre><code>inline MessageHeader(\nstd::string_view name,\nstd::string_view value\n)\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#variable-name","title":"variable name","text":"<pre><code>std::string_view name;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1MessageHeader/#variable-value","title":"variable value","text":"<pre><code>std::string_view value;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structpico__http_1_1Request/","title":"pico_http::Request","text":""},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-functions","title":"Public Functions","text":"Name int parse(const char * buf, usize len, usize last_len =0) int parse(const batt::ConstBuffer &amp; buf)"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-attributes","title":"Public Attributes","text":"Name std::string_view method std::string_view path int major_version int minor_version batt::SmallVec&lt; MessageHeader, kDefaultNumHeaders &gt; headers"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1Request/#function-parse","title":"function parse","text":"<pre><code>inline int parse(\nconst char * buf,\nusize len,\nusize last_len =0\n)\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Request/#function-parse_1","title":"function parse","text":"<pre><code>inline int parse(\nconst batt::ConstBuffer &amp; buf\n)\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Request/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-method","title":"variable method","text":"<pre><code>std::string_view method;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-path","title":"variable path","text":"<pre><code>std::string_view path;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-major_version","title":"variable major_version","text":"<pre><code>int major_version;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-minor_version","title":"variable minor_version","text":"<pre><code>int minor_version;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Request/#variable-headers","title":"variable headers","text":"<pre><code>batt::SmallVec&lt; MessageHeader, kDefaultNumHeaders &gt; headers;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Classes/structpico__http_1_1Response/","title":"pico_http::Response","text":""},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-functions","title":"Public Functions","text":"Name int parse(const char * buf, usize len, usize last_len =0) int parse(const batt::ConstBuffer &amp; buf)"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-attributes","title":"Public Attributes","text":"Name int major_version int minor_version int status std::string_view message batt::SmallVec&lt; MessageHeader, kDefaultNumHeaders &gt; headers"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1Response/#function-parse","title":"function parse","text":"<pre><code>inline int parse(\nconst char * buf,\nusize len,\nusize last_len =0\n)\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Response/#function-parse_1","title":"function parse","text":"<pre><code>inline int parse(\nconst batt::ConstBuffer &amp; buf\n)\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Response/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-major_version","title":"variable major_version","text":"<pre><code>int major_version;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-minor_version","title":"variable minor_version","text":"<pre><code>int minor_version;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-status","title":"variable status","text":"<pre><code>int status;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-message","title":"variable message","text":"<pre><code>std::string_view message;\n</code></pre>"},{"location":"_autogen/Classes/structpico__http_1_1Response/#variable-headers","title":"variable headers","text":"<pre><code>batt::SmallVec&lt; MessageHeader, kDefaultNumHeaders &gt; headers;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Examples/","title":"Examples","text":"<p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/","title":"Files","text":"<ul> <li>file README.md </li> <li>dir batteries <ul> <li>file batteries/assert.cpp </li> <li>file batteries/assert.hpp </li> <li>file batteries/assert_impl.hpp </li> <li>file batteries/atomic_counter_gauge.hpp </li> <li>dir batteries/algo <ul> <li>file batteries/algo/parallel_accumulate.hpp </li> <li>file batteries/algo/parallel_copy.hpp </li> <li>file batteries/algo/parallel_merge.hpp </li> <li>file batteries/algo/parallel_running_total.hpp </li> <li>file batteries/algo/parallel_transform.hpp </li> <li>file batteries/algo/running_total.cpp </li> <li>file batteries/algo/running_total.hpp </li> <li>file batteries/algo/running_total_impl.hpp </li> </ul> </li> <li>dir batteries/asio <ul> <li>file batteries/asio/any_io_executor.hpp </li> <li>file batteries/asio/deadline_timer.hpp </li> <li>file batteries/asio/execution_context.hpp </li> <li>file batteries/asio/io_context.hpp </li> <li>file batteries/asio/ip_tcp.hpp </li> <li>file batteries/asio/post.hpp </li> <li>file batteries/asio/system_executor.hpp </li> </ul> </li> <li>dir batteries/async <ul> <li>file batteries/async/async_run_task.hpp </li> <li>file batteries/async/backoff.cpp </li> <li>file batteries/async/backoff.hpp </li> <li>file batteries/async/backoff_decl.hpp </li> <li>file batteries/async/backoff_impl.hpp </li> <li>file batteries/async/basic_executor.hpp </li> <li>file batteries/async/buffer_source.cpp </li> <li>file batteries/async/buffer_source.hpp </li> <li>file batteries/async/buffer_source_impl.hpp </li> <li>file batteries/async/buffered_channel.hpp </li> <li>file batteries/async/cancel_token.cpp </li> <li>file batteries/async/cancel_token.hpp </li> <li>file batteries/async/cancel_token_impl.hpp </li> <li>file batteries/async/channel.hpp </li> <li>file batteries/async/continuation.hpp </li> <li>file batteries/async/debug_info.cpp </li> <li>file batteries/async/debug_info.hpp </li> <li>file batteries/async/debug_info_decl.hpp </li> <li>file batteries/async/debug_info_impl.hpp </li> <li>file batteries/async/dump_tasks.hpp </li> <li>file batteries/async/fake_execution_context.cpp </li> <li>file batteries/async/fake_execution_context.hpp </li> <li>file batteries/async/fake_execution_context_decl.hpp </li> <li>file batteries/async/fake_execution_context_impl.hpp </li> <li>file batteries/async/fake_executor.cpp </li> <li>file batteries/async/fake_executor.hpp </li> <li>file batteries/async/fake_executor_decl.hpp </li> <li>file batteries/async/fake_executor_impl.hpp </li> <li>file batteries/async/fake_task_scheduler.hpp </li> <li>file batteries/async/fake_time_service.cpp </li> <li>file batteries/async/fake_time_service.hpp </li> <li>file batteries/async/fake_time_service_decl.hpp </li> <li>file batteries/async/fake_time_service_impl.hpp </li> <li>file batteries/async/fetch.hpp </li> <li>file batteries/async/futex.hpp </li> <li>file batteries/async/future.cpp </li> <li>file batteries/async/future.hpp </li> <li>file batteries/async/future_decl.hpp </li> <li>file batteries/async/future_impl.hpp </li> <li>file batteries/async/grant.hpp </li> <li>file batteries/async/handler.hpp </li> <li>file batteries/async/inline_sub_task.hpp </li> <li>file batteries/async/io_result.hpp </li> <li>file batteries/async/latch.cpp </li> <li>file batteries/async/latch.hpp </li> <li>file batteries/async/latch_decl.hpp </li> <li>file batteries/async/latch_impl.hpp </li> <li>file batteries/async/lazy_latch.cpp </li> <li>file batteries/async/lazy_latch.hpp </li> <li>file batteries/async/lazy_latch_decl.hpp </li> <li>file batteries/async/lazy_latch_impl.hpp </li> <li>file batteries/async/mcs_lock.hpp </li> <li>file batteries/async/mutex.cpp </li> <li>file batteries/async/mutex.hpp </li> <li>file batteries/async/mutex_impl.hpp </li> <li>file batteries/async/pin.hpp </li> <li>file batteries/async/preallocated_task.hpp </li> <li>file batteries/async/priority_watch.hpp </li> <li>file batteries/async/queue.hpp </li> <li>file batteries/async/rate_limiter.hpp </li> <li>file batteries/async/read_write_lock.hpp </li> <li>file batteries/async/runtime.hpp </li> <li>file batteries/async/scalable_grant.cpp </li> <li>file batteries/async/scalable_grant.hpp </li> <li>file batteries/async/scalable_grant_impl.hpp </li> <li>file batteries/async/simple_executor.cpp </li> <li>file batteries/async/simple_executor.hpp </li> <li>file batteries/async/simple_executor_impl.hpp </li> <li>file batteries/async/single_thread_executor.hpp </li> <li>file batteries/async/slice_work.cpp </li> <li>file batteries/async/slice_work.hpp </li> <li>file batteries/async/slice_work_impl.hpp </li> <li>file batteries/async/spin_grant.cpp </li> <li>file batteries/async/spin_grant.hpp </li> <li>file batteries/async/spin_grant_decl.hpp </li> <li>file batteries/async/spin_grant_impl.hpp </li> <li>file batteries/async/stream_buffer.cpp </li> <li>file batteries/async/stream_buffer.hpp </li> <li>file batteries/async/stream_buffer_impl.hpp </li> <li>file batteries/async/task.cpp </li> <li>file batteries/async/task.hpp </li> <li>file batteries/async/task_decl.hpp </li> <li>file batteries/async/task_impl.hpp </li> <li>file batteries/async/task_scheduler.hpp </li> <li>file batteries/async/types.hpp </li> <li>file batteries/async/watch.cpp </li> <li>file batteries/async/watch.hpp </li> <li>file batteries/async/watch_decl.hpp </li> <li>file batteries/async/watch_impl.hpp </li> <li>file batteries/async/work_context.cpp </li> <li>file batteries/async/work_context.hpp </li> <li>file batteries/async/work_context_impl.hpp </li> <li>file batteries/async/worker.hpp </li> <li>file batteries/async/worker_pool.cpp </li> <li>file batteries/async/worker_pool.hpp </li> <li>file batteries/async/worker_pool_impl.hpp </li> </ul> </li> <li>dir batteries/http <ul> <li>file batteries/http/host_address.hpp </li> <li>file batteries/http/http_chunk_decoder.hpp </li> <li>file batteries/http/http_chunk_encoder.hpp </li> <li>file batteries/http/http_client.cpp </li> <li>file batteries/http/http_client.hpp </li> <li>file batteries/http/http_client_connection.cpp </li> <li>file batteries/http/http_client_connection.hpp </li> <li>file batteries/http/http_client_connection_decl.hpp </li> <li>file batteries/http/http_client_connection_impl.hpp </li> <li>file batteries/http/http_client_host_context.cpp </li> <li>file batteries/http/http_client_host_context.hpp </li> <li>file batteries/http/http_client_host_context_decl.hpp </li> <li>file batteries/http/http_client_host_context_impl.hpp </li> <li>file batteries/http/http_client_impl.hpp </li> <li>file batteries/http/http_data.hpp </li> <li>file batteries/http/http_header.hpp </li> <li>file batteries/http/http_message_base.hpp </li> <li>file batteries/http/http_message_info.cpp </li> <li>file batteries/http/http_message_info.hpp </li> <li>file batteries/http/http_message_info_decl.hpp </li> <li>file batteries/http/http_message_info_impl.hpp </li> <li>file batteries/http/http_request.hpp </li> <li>file batteries/http/http_response.hpp </li> <li>file batteries/http/http_server.cpp </li> <li>file batteries/http/http_server.hpp </li> <li>file batteries/http/http_server_connection.cpp </li> <li>file batteries/http/http_server_connection.hpp </li> <li>file batteries/http/http_server_connection_decl.hpp </li> <li>file batteries/http/http_server_connection_impl.hpp </li> <li>file batteries/http/http_server_decl.hpp </li> <li>file batteries/http/http_server_impl.hpp </li> <li>file batteries/http/http_server_settings.cpp </li> <li>file batteries/http/http_server_settings.hpp </li> <li>file batteries/http/http_server_settings_decl.hpp </li> <li>file batteries/http/http_server_settings_impl.hpp </li> <li>file batteries/http/http_version.hpp </li> <li>file batteries/http/ssl_transport.cpp </li> <li>file batteries/http/ssl_transport.hpp </li> <li>file batteries/http/ssl_transport_impl.hpp </li> <li>file batteries/http/tcp_transport.hpp </li> </ul> </li> <li>dir batteries/metrics <ul> <li>file batteries/metrics/metric_collectors.hpp </li> <li>file batteries/metrics/metric_collectors_impl.hpp </li> <li>file batteries/metrics/metric_csv_formatter.cpp </li> <li>file batteries/metrics/metric_csv_formatter.hpp </li> <li>file batteries/metrics/metric_csv_formatter_impl.hpp </li> <li>file batteries/metrics/metric_dumper.cpp </li> <li>file batteries/metrics/metric_dumper.hpp </li> <li>file batteries/metrics/metric_dumper_impl.hpp </li> <li>file batteries/metrics/metric_formatter.hpp </li> <li>file batteries/metrics/metric_formatter_impl.hpp </li> <li>file batteries/metrics/metric_otel_formatter.cpp </li> <li>file batteries/metrics/metric_otel_formatter.hpp </li> <li>file batteries/metrics/metric_otel_formatter_impl.hpp </li> <li>file batteries/metrics/metric_registry.cpp </li> <li>file batteries/metrics/metric_registry.hpp </li> <li>file batteries/metrics/metric_registry_impl.hpp </li> <li>file batteries/metrics/prometheus_exporter.hpp </li> </ul> </li> <li>dir batteries/pico_http <ul> <li>file batteries/pico_http/parser.cpp </li> <li>file batteries/pico_http/parser.hpp </li> <li>file batteries/pico_http/parser_decl.hpp </li> <li>file batteries/pico_http/parser_impl.hpp </li> </ul> </li> <li>dir batteries/protobuf <ul> <li>file batteries/protobuf/stream_buffer_input_stream.hpp </li> <li>file batteries/protobuf/stream_buffer_output_stream.hpp </li> </ul> </li> <li>dir batteries/seq <ul> <li>file batteries/seq/addition.hpp </li> <li>file batteries/seq/all_true.hpp </li> <li>file batteries/seq/any_true.hpp </li> <li>file batteries/seq/apply.hpp </li> <li>file batteries/seq/attach.hpp </li> <li>file batteries/seq/boxed.hpp </li> <li>file batteries/seq/cache_next.hpp </li> <li>file batteries/seq/chain.hpp </li> <li>file batteries/seq/collect.hpp </li> <li>file batteries/seq/collect_vec.hpp </li> <li>file batteries/seq/consume.hpp </li> <li>file batteries/seq/count.hpp </li> <li>file batteries/seq/decay.hpp </li> <li>file batteries/seq/deref.hpp </li> <li>file batteries/seq/emplace_back.hpp </li> <li>file batteries/seq/empty.hpp </li> <li>file batteries/seq/filter.hpp </li> <li>file batteries/seq/filter_map.hpp </li> <li>file batteries/seq/first.hpp </li> <li>file batteries/seq/flatten.hpp </li> <li>file batteries/seq/for_each.hpp </li> <li>file batteries/seq/fuse.hpp </li> <li>file batteries/seq/group_by.hpp </li> <li>file batteries/seq/inner_reduce.hpp </li> <li>file batteries/seq/inspect.hpp </li> <li>file batteries/seq/inspect_adjacent.hpp </li> <li>file batteries/seq/is_sorted.hpp </li> <li>file batteries/seq/kmerge.hpp </li> <li>file batteries/seq/last.hpp </li> <li>file batteries/seq/lazy.hpp </li> <li>file batteries/seq/loop_control.hpp </li> <li>file batteries/seq/map.hpp </li> <li>file batteries/seq/map_adjacent.hpp </li> <li>file batteries/seq/map_fold.hpp </li> <li>file batteries/seq/map_pairwise.hpp </li> <li>file batteries/seq/merge_by.hpp </li> <li>file batteries/seq/natural_equals.hpp </li> <li>file batteries/seq/natural_order.hpp </li> <li>file batteries/seq/prepend.hpp </li> <li>file batteries/seq/print_out.hpp </li> <li>file batteries/seq/printable.hpp </li> <li>file batteries/seq/product.hpp </li> <li>file batteries/seq/reduce.hpp </li> <li>file batteries/seq/requirements.hpp </li> <li>file batteries/seq/reverse.hpp </li> <li>file batteries/seq/rolling.hpp </li> <li>file batteries/seq/rolling_sum.hpp </li> <li>file batteries/seq/seq_item.hpp </li> <li>file batteries/seq/skip_n.hpp </li> <li>file batteries/seq/splice.hpp </li> <li>file batteries/seq/status_ok.hpp </li> <li>file batteries/seq/sub_range_seq.hpp </li> <li>file batteries/seq/sum.hpp </li> <li>file batteries/seq/take_n.hpp </li> <li>file batteries/seq/take_while.hpp </li> <li>file batteries/seq/zip.hpp </li> </ul> </li> <li>dir batteries/state_machine_model <ul> <li>file batteries/state_machine_model/advanced_options.hpp </li> <li>file batteries/state_machine_model/entropy_source.hpp </li> <li>file batteries/state_machine_model/exhaustive_model_checker.hpp </li> <li>file batteries/state_machine_model/parallel_model_check_state.hpp </li> <li>file batteries/state_machine_model/state_machine_result.hpp </li> <li>file batteries/state_machine_model/state_machine_traits.hpp </li> <li>file batteries/state_machine_model/stochastic_model_checker.hpp </li> <li>file batteries/state_machine_model/verbose.hpp </li> </ul> </li> <li>file batteries/bool_status.hpp </li> <li>file batteries/bounds.hpp </li> <li>file batteries/buffer.hpp </li> <li>file batteries/case_of.hpp </li> <li>file batteries/checked_cast.hpp </li> <li>file batteries/compare.hpp </li> <li>file batteries/config.hpp </li> <li>file batteries/constants.hpp </li> <li>file batteries/cpu_align.hpp </li> <li>file batteries/do_nothing.hpp </li> <li>file batteries/endian.hpp </li> <li>file batteries/env.hpp </li> <li>file batteries/finally.hpp </li> <li>file batteries/hash.hpp </li> <li>file batteries/hint.hpp </li> <li>file batteries/instance_counter.hpp </li> <li>file batteries/int_types.hpp </li> <li>file batteries/interval.hpp </li> <li>file batteries/interval_traits.hpp </li> <li>file batteries/logging.hpp </li> <li>file batteries/make_printable.hpp </li> <li>file batteries/math.hpp </li> <li>file batteries/no_destruct.hpp </li> <li>file batteries/nullable.hpp </li> <li>file batteries/operators.hpp </li> <li>file batteries/optional.hpp </li> <li>file batteries/pointers.hpp </li> <li>file batteries/radix_queue.hpp </li> <li>file batteries/ref.hpp </li> <li>file batteries/require.hpp </li> <li>file batteries/segv.hpp </li> <li>file batteries/seq.hpp </li> <li>file batteries/shared_ptr.hpp </li> <li>file batteries/skip_list.hpp </li> <li>file batteries/slice.hpp </li> <li>file batteries/small_fn.hpp </li> <li>file batteries/small_vec.hpp </li> <li>file batteries/stacktrace.hpp </li> <li>file batteries/state_machine_model.hpp </li> <li>file batteries/static_assert.hpp </li> <li>file batteries/static_dispatch.hpp </li> <li>file batteries/status.cpp </li> <li>file batteries/status.hpp </li> <li>file batteries/status_impl.hpp </li> <li>file batteries/stream_util.hpp </li> <li>file batteries/strict.hpp </li> <li>file batteries/strong_typedef.hpp </li> <li>file batteries/suppress.hpp </li> <li>file batteries/syscall_retry.hpp </li> <li>file batteries/token.hpp </li> <li>file batteries/tuples.hpp </li> <li>file batteries/type_erasure.hpp </li> <li>file batteries/type_traits.hpp </li> <li>file batteries/url_parse.hpp </li> <li>file batteries/utility.hpp </li> </ul> </li> <li>file batteries.hpp </li> </ul> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/README_8md/","title":"README.md","text":""},{"location":"_autogen/Files/README_8md/#source-code","title":"Source code","text":"<p><pre><code># NOTICE\nThe contents of this directory were copied and modified from the [Pico HTTP Parser](https://github.com/h2o/picohttpparser) project under the terms of the MIT License.\nThe original copyright notice is preserved in the source files, and also quoted here:\n</code></pre> /  * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,  *                         Shigeo Mitsunari  *  * The software is licensed under either the MIT License (below) or the Perl  * license.  *  * Permission is hereby granted, free of charge, to any person obtaining a copy  * of this software and associated documentation files (the \"Software\"), to  * deal in the Software without restriction, including without limitation the  * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or  * sell copies of the Software, and to permit persons to whom the Software is  * furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice shall be included in  * all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS  * IN THE SOFTWARE.  / <pre><code>DO NOT remove this notice from the files in this directory!\n\nThe Pico HTTP Parser and H2O projects are amazing and awesome; you should definitely support the authors and the project!!!\n</code></pre></p> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/addition_8hpp/","title":"batteries/seq/addition.hpp","text":""},{"location":"_autogen/Files/addition_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/addition_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::Addition"},{"location":"_autogen/Files/addition_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ADDITION_HPP"},{"location":"_autogen/Files/addition_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/addition_8hpp/#define-batteries_seq_addition_hpp","title":"define BATTERIES_SEQ_ADDITION_HPP","text":"<pre><code>#define BATTERIES_SEQ_ADDITION_HPP()\n</code></pre>"},{"location":"_autogen/Files/addition_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ADDITION_HPP\n#define BATTERIES_SEQ_ADDITION_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\nstruct Addition {\ntemplate &lt;typename L, typename R&gt;\ndecltype(auto) operator()(L&amp;&amp; l, R&amp;&amp; r) const\n{\nreturn BATT_FORWARD(l) + BATT_FORWARD(r);\n}\n};\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ADDITION_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/advanced__options_8hpp/","title":"batteries/state_machine_model/advanced_options.hpp","text":""},{"location":"_autogen/Files/advanced__options_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/advanced__options_8hpp/#classes","title":"Classes","text":"Name struct batt::StateMachineModelCheckAdvancedOptions"},{"location":"_autogen/Files/advanced__options_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP"},{"location":"_autogen/Files/advanced__options_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/advanced__options_8hpp/#define-batteries_state_machine_model_advanced_options_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP()\n</code></pre>"},{"location":"_autogen/Files/advanced__options_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\nnamespace batt {\nstruct StateMachineModelCheckAdvancedOptions {\nusing Self = StateMachineModelCheckAdvancedOptions;\nbool pin_shard_to_cpu;\nusize max_loop_iterations_between_flush;\nusize max_loop_iterations_between_update;\ni64 min_running_time_ms;\nOptional&lt;usize&gt; starting_seed;\nstatic Self with_default_values()\n{\nreturn Self{\n.pin_shard_to_cpu = true,\n.max_loop_iterations_between_flush = 16,\n.max_loop_iterations_between_update = 4096,\n.min_running_time_ms = 1000,\n.starting_seed = None,\n};\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_ADVANCED_OPTIONS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/all__true_8hpp/","title":"batteries/seq/all_true.hpp","text":""},{"location":"_autogen/Files/all__true_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/all__true_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::AllBinder"},{"location":"_autogen/Files/all__true_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ALL_TRUE_HPP"},{"location":"_autogen/Files/all__true_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/all__true_8hpp/#define-batteries_seq_all_true_hpp","title":"define BATTERIES_SEQ_ALL_TRUE_HPP","text":"<pre><code>#define BATTERIES_SEQ_ALL_TRUE_HPP()\n</code></pre>"},{"location":"_autogen/Files/all__true_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ALL_TRUE_HPP\n#define BATTERIES_SEQ_ALL_TRUE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/loop_control.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// all_true\n//\nstruct AllBinder {\n};\ninline AllBinder all_true()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, AllBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::all_true) Sequences may not be captured implicitly by reference.\");\nbool ans = true;\nBATT_FORWARD(seq) | for_each([&amp;ans](auto&amp;&amp; item) {\nif (!bool{item}) {\nans = false;\nreturn LoopControl::kBreak;\n}\nreturn LoopControl::kContinue;\n});\nreturn ans;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ALL_TRUE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/any__io__executor_8hpp/","title":"batteries/asio/any_io_executor.hpp","text":""},{"location":"_autogen/Files/any__io__executor_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_ANY_IO_EXECUTOR_HPP"},{"location":"_autogen/Files/any__io__executor_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/any__io__executor_8hpp/#define-batteries_asio_any_io_executor_hpp","title":"define BATTERIES_ASIO_ANY_IO_EXECUTOR_HPP","text":"<pre><code>#define BATTERIES_ASIO_ANY_IO_EXECUTOR_HPP()\n</code></pre>"},{"location":"_autogen/Files/any__io__executor_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASIO_ANY_IO_EXECUTOR_HPP\n#define BATTERIES_ASIO_ANY_IO_EXECUTOR_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_GCC(\"-Woverloaded-virtual\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Woverloaded-virtual\")\n//\n#include &lt;boost/asio/any_io_executor.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_ANY_IO_EXECUTOR_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/any__true_8hpp/","title":"batteries/seq/any_true.hpp","text":""},{"location":"_autogen/Files/any__true_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/any__true_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::AnyBinder"},{"location":"_autogen/Files/any__true_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ANY_TRUE_HPP"},{"location":"_autogen/Files/any__true_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/any__true_8hpp/#define-batteries_seq_any_true_hpp","title":"define BATTERIES_SEQ_ANY_TRUE_HPP","text":"<pre><code>#define BATTERIES_SEQ_ANY_TRUE_HPP()\n</code></pre>"},{"location":"_autogen/Files/any__true_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ANY_TRUE_HPP\n#define BATTERIES_SEQ_ANY_TRUE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/loop_control.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// any_true\n//\nstruct AnyBinder {\n};\ninline AnyBinder any_true()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, AnyBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::any_true) Sequences may not be captured implicitly by reference.\");\nbool ans = false;\nBATT_FORWARD(seq) | for_each([&amp;ans](auto&amp;&amp; item) {\nif (bool{item}) {\nans = true;\nreturn LoopControl::kBreak;\n}\nreturn LoopControl::kContinue;\n});\nreturn ans;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ANY_TRUE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/apply_8hpp/","title":"batteries/seq/apply.hpp","text":""},{"location":"_autogen/Files/apply_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/apply_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::ApplyBinder"},{"location":"_autogen/Files/apply_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_APPLY_HPP"},{"location":"_autogen/Files/apply_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/apply_8hpp/#define-batteries_seq_apply_hpp","title":"define BATTERIES_SEQ_APPLY_HPP","text":"<pre><code>#define BATTERIES_SEQ_APPLY_HPP()\n</code></pre>"},{"location":"_autogen/Files/apply_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_APPLY_HPP\n#define BATTERIES_SEQ_APPLY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// apply(seq_function) - apply a function to an entire sequence.\n//\n// Not to be confused with map, which applies some function to each item.\n//\ntemplate &lt;typename SeqFn&gt;\nstruct ApplyBinder {\nSeqFn seq_fn;\n};\ntemplate &lt;typename SeqFn&gt;\ninline ApplyBinder&lt;SeqFn&gt; apply(SeqFn&amp;&amp; seq_fn)\n{\nreturn {BATT_FORWARD(seq_fn)};\n}\ntemplate &lt;typename Seq, typename SeqFn&gt;\n[[nodiscard]] inline decltype(auto) operator|(Seq&amp;&amp; seq, ApplyBinder&lt;SeqFn&gt;&amp;&amp; binder)\n{\nreturn BATT_FORWARD(binder.seq_fn)(BATT_FORWARD(seq));\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_APPLY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/assert_8cpp/","title":"batteries/assert.cpp","text":""},{"location":"_autogen/Files/assert_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/assert_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/assert_8hpp/","title":"batteries/assert.hpp","text":""},{"location":"_autogen/Files/assert_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/assert_8hpp/#defines","title":"Defines","text":"Name BATT_FAIL_CHECK_OUT BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name) BATT_NORETURN BATT_UNREACHABLE() BATT_THIS_FUNCTION BATT_CHECK_RELATION(left, op, right) BATT_CHECK_IMPLIES(p, q) BATT_CHECK(x) This is only a test... BATT_CHECK_EQ(x, y) BATT_CHECK_NE(x, y) BATT_CHECK_GE(x, y) BATT_CHECK_GT(x, y) BATT_CHECK_LE(x, y) BATT_CHECK_LT(x, y) BATT_CHECK_FAIL() BATT_CHECK_IN_RANGE(low, x, high) BATT_ASSERT_DISABLED(ignored_inputs) BATT_ASSERT(x) BATT_ASSERT_EQ(x, y) BATT_ASSERT_NE(x, y) BATT_ASSERT_GE(x, y) BATT_ASSERT_GT(x, y) BATT_ASSERT_LE(x, y) BATT_ASSERT_LT(x, y) BATT_ASSERT_IMPLIES(p, q) BATT_ASSERT_IN_RANGE(low, x, high) BATT_ASSERT_NOT_NULLPTR(x) BATT_CHECK_NOT_NULLPTR(x) BATT_PANIC() BATT_INSPECT(expr) BATT_UNTESTED_LINE() BATT_UNTESTED_COND(x)"},{"location":"_autogen/Files/assert_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/assert_8hpp/#define-batt_fail_check_out","title":"define BATT_FAIL_CHECK_OUT","text":"<pre><code>#define BATT_FAIL_CHECK_OUT()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_fail_check_message","title":"define BATT_FAIL_CHECK_MESSAGE","text":"<pre><code>#define BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_noreturn","title":"define BATT_NORETURN","text":"<pre><code>#define BATT_NORETURN()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_unreachable","title":"define BATT_UNREACHABLE","text":"<pre><code>#define BATT_UNREACHABLE()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_this_function","title":"define BATT_THIS_FUNCTION","text":"<pre><code>#define BATT_THIS_FUNCTION()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_relation","title":"define BATT_CHECK_RELATION","text":"<pre><code>#define BATT_CHECK_RELATION(left, op, right)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_implies","title":"define BATT_CHECK_IMPLIES","text":"<pre><code>#define BATT_CHECK_IMPLIES(p, q)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check","title":"define BATT_CHECK","text":"<pre><code>#define BATT_CHECK(x)\n</code></pre> <p>This is only a test... </p> <p>Parameters: </p> <ul> <li>x The expression to test. </li> </ul>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_eq","title":"define BATT_CHECK_EQ","text":"<pre><code>#define BATT_CHECK_EQ(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_ne","title":"define BATT_CHECK_NE","text":"<pre><code>#define BATT_CHECK_NE(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_ge","title":"define BATT_CHECK_GE","text":"<pre><code>#define BATT_CHECK_GE(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_gt","title":"define BATT_CHECK_GT","text":"<pre><code>#define BATT_CHECK_GT(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_le","title":"define BATT_CHECK_LE","text":"<pre><code>#define BATT_CHECK_LE(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_lt","title":"define BATT_CHECK_LT","text":"<pre><code>#define BATT_CHECK_LT(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_fail","title":"define BATT_CHECK_FAIL","text":"<pre><code>#define BATT_CHECK_FAIL()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_in_range","title":"define BATT_CHECK_IN_RANGE","text":"<pre><code>#define BATT_CHECK_IN_RANGE(low, x, high)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_disabled","title":"define BATT_ASSERT_DISABLED","text":"<pre><code>#define BATT_ASSERT_DISABLED(ignored_inputs)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert","title":"define BATT_ASSERT","text":"<pre><code>#define BATT_ASSERT(x)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_eq","title":"define BATT_ASSERT_EQ","text":"<pre><code>#define BATT_ASSERT_EQ(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_ne","title":"define BATT_ASSERT_NE","text":"<pre><code>#define BATT_ASSERT_NE(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_ge","title":"define BATT_ASSERT_GE","text":"<pre><code>#define BATT_ASSERT_GE(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_gt","title":"define BATT_ASSERT_GT","text":"<pre><code>#define BATT_ASSERT_GT(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_le","title":"define BATT_ASSERT_LE","text":"<pre><code>#define BATT_ASSERT_LE(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_lt","title":"define BATT_ASSERT_LT","text":"<pre><code>#define BATT_ASSERT_LT(x, y)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_implies","title":"define BATT_ASSERT_IMPLIES","text":"<pre><code>#define BATT_ASSERT_IMPLIES(p, q)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_in_range","title":"define BATT_ASSERT_IN_RANGE","text":"<pre><code>#define BATT_ASSERT_IN_RANGE(low, x, high)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_assert_not_nullptr","title":"define BATT_ASSERT_NOT_NULLPTR","text":"<pre><code>#define BATT_ASSERT_NOT_NULLPTR(x)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_check_not_nullptr","title":"define BATT_CHECK_NOT_NULLPTR","text":"<pre><code>#define BATT_CHECK_NOT_NULLPTR(x)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_panic","title":"define BATT_PANIC","text":"<pre><code>#define BATT_PANIC()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_inspect","title":"define BATT_INSPECT","text":"<pre><code>#define BATT_INSPECT(expr)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_untested_line","title":"define BATT_UNTESTED_LINE","text":"<pre><code>#define BATT_UNTESTED_LINE()\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#define-batt_untested_cond","title":"define BATT_UNTESTED_COND","text":"<pre><code>#define BATT_UNTESTED_COND(x)\n</code></pre>"},{"location":"_autogen/Files/assert_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifdef BOOST_STACKTRACE_USE_NOOP\n#undef BOOST_STACKTRACE_USE_NOOP\n#endif  // BOOST_STACKTRACE_USE_NOOP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/make_printable.hpp&gt;\n#include &lt;batteries/stacktrace.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#ifdef BATT_FAIL_CHECK_OUT\n#error This macro is deprecated; use BATT_WITH_GLOG\n#endif\n#if BATT_WITH_GLOG\n#define BATT_FAIL_CHECK_OUT BATT_LOG_ERROR()\n#else\n#define BATT_FAIL_CHECK_OUT std::cerr\n#endif\nnamespace batt {\n// =============================================================================\n// ASSERT and CHECK macros with ostream-style message appending, stack trace on\n// failure, branch prediction hinting, and human-friendly messages.\n//\n// BATT_ASSERT* statements are only enabled when NDEBUG is not defined.\n// BATT_CHECK* statements are always enabled.\n//\n#define BATT_FAIL_CHECK_MESSAGE(left_str, left_val, op_str, right_str, right_val, file, line, fn_name)       \\\n    BATT_FAIL_CHECK_OUT &lt;&lt; \"FATAL: \" &lt;&lt; file &lt;&lt; \":\" &lt;&lt; line &lt;&lt; \": Assertion failed: \" &lt;&lt; left_str &lt;&lt; \" \"     \\\n                        &lt;&lt; op_str &lt;&lt; \" \" &lt;&lt; right_str &lt;&lt; \"\\n (in `\" &lt;&lt; fn_name &lt;&lt; \"`)\\n\\n\"                   \\\n                        &lt;&lt; \"  \" &lt;&lt; left_str &lt;&lt; \" == \" &lt;&lt; ::batt::make_printable(left_val) &lt;&lt; ::std::endl     \\\n                        &lt;&lt; ::std::endl                                                                       \\\n                        &lt;&lt; \"  \" &lt;&lt; right_str &lt;&lt; \" == \" &lt;&lt; ::batt::make_printable(right_val) &lt;&lt; ::std::endl   \\\n                        &lt;&lt; ::std::endl\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#if defined(__GNUC__)\n#define BATT_NORETURN __attribute__((noreturn))\n#define BATT_UNREACHABLE __builtin_unreachable\n#elif defined(__clang__)\n#define BATT_NORETURN _Noreturn\n#define BATT_UNREACHABLE __builtin_unreachable\n#elif defined(_MSC_VER)\n#define BATT_NORETURN [[noreturn]]\n#define BATT_UNREACHABLE() __assume(0)\n#else\n#define BATT_NORETURN\n#define BATT_UNREACHABLE() (void)0\n#endif\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nBATT_NORETURN void fail_check_exit();\nstd::atomic&lt;bool&gt;&amp; fail_check_exit_entered();\nstd::atomic&lt;bool&gt;&amp; fail_check_spin_lock();\ntemplate &lt;typename... Ts&gt;\ninline bool ignore(Ts&amp;&amp;...)\n{\nreturn false;\n}\nbool lock_fail_check_mutex();\n#ifdef BATT_PLATFORM_IS_WINDOWS\n#define BATT_THIS_FUNCTION __FUNCTION__\n#else\n#define BATT_THIS_FUNCTION __PRETTY_FUNCTION__\n#endif\n#define BATT_CHECK_RELATION(left, op, right)                                                                 \\\n    for (; !BATT_HINT_TRUE((left)op(right)) &amp;&amp; BATT_HINT_TRUE(::batt::lock_fail_check_mutex());              \\\n         ::batt::fail_check_exit())                                                                          \\\n    BATT_FAIL_CHECK_MESSAGE(#left, (left), #op, #right, (right), __FILE__, __LINE__, BATT_THIS_FUNCTION)\n#define BATT_CHECK_IMPLIES(p, q)                                                                             \\\n    for (; !BATT_HINT_TRUE(!(p) || (q)) &amp;&amp; BATT_HINT_TRUE(::batt::lock_fail_check_mutex());                  \\\n         ::batt::fail_check_exit())                                                                          \\\n    BATT_FAIL_CHECK_MESSAGE(#p, (p), \"implies\", #q, (q), __FILE__, __LINE__, BATT_THIS_FUNCTION)\n#define BATT_CHECK(x) BATT_CHECK_RELATION(bool{x}, ==, true)\n#define BATT_CHECK_EQ(x, y) BATT_CHECK_RELATION(x, ==, y)\n#define BATT_CHECK_NE(x, y) BATT_CHECK_RELATION(x, !=, y)\n#define BATT_CHECK_GE(x, y) BATT_CHECK_RELATION(x, &gt;=, y)\n#define BATT_CHECK_GT(x, y) BATT_CHECK_RELATION(x, &gt;, y)\n#define BATT_CHECK_LE(x, y) BATT_CHECK_RELATION(x, &lt;=, y)\n#define BATT_CHECK_LT(x, y) BATT_CHECK_RELATION(x, &lt;, y)\n#define BATT_CHECK_FAIL() BATT_CHECK(false)\n#define BATT_CHECK_IN_RANGE(low, x, high)                                                                    \\\n    [&amp;](auto&amp;&amp; Actual_Value) {                                                                               \\\n        BATT_CHECK_LE(low, Actual_Value)                                                                     \\\n            &lt;&lt; \"Expression \" &lt;&lt; #x &lt;&lt; \" == \" &lt;&lt; Actual_Value &lt;&lt; \" is out-of-range\";                          \\\n        BATT_CHECK_LT(Actual_Value, high)                                                                    \\\n            &lt;&lt; \"Expression \" &lt;&lt; #x &lt;&lt; \" == \" &lt;&lt; Actual_Value &lt;&lt; \" is out-of-range\";                          \\\n    }(x)\n#define BATT_ASSERT_DISABLED(ignored_inputs)                                                                 \\\n    if (false &amp;&amp; ignored_inputs)                                                                             \\\n    BATT_FAIL_CHECK_OUT &lt;&lt; \"\"\n#if BATT_WITH_ASSERTS  //==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#define BATT_ASSERT(x) BATT_CHECK(x)\n#define BATT_ASSERT_EQ(x, y) BATT_CHECK_EQ(x, y)\n#define BATT_ASSERT_NE(x, y) BATT_CHECK_NE(x, y)\n#define BATT_ASSERT_GE(x, y) BATT_CHECK_GE(x, y)\n#define BATT_ASSERT_GT(x, y) BATT_CHECK_GT(x, y)\n#define BATT_ASSERT_LE(x, y) BATT_CHECK_LE(x, y)\n#define BATT_ASSERT_LT(x, y) BATT_CHECK_LT(x, y)\n#define BATT_ASSERT_IMPLIES(p, q) BATT_CHECK_IMPLIES(p, q)\n#define BATT_ASSERT_IN_RANGE(low, x, high) BATT_CHECK_IN_RANGE(low, x, high)\n#else  // !BATT_WITH_ASSERTS  ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#define BATT_ASSERT(x) BATT_ASSERT_DISABLED(::batt::ignore((x)))\n#define BATT_ASSERT_EQ(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) == (y)))\n#define BATT_ASSERT_NE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) != (y)))\n#define BATT_ASSERT_GE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) &gt;= (y)))\n#define BATT_ASSERT_GT(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) &gt; (y)))\n#define BATT_ASSERT_LE(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) &lt;= (y)))\n#define BATT_ASSERT_LT(x, y) BATT_ASSERT_DISABLED(::batt::ignore((x), (y), (x) &lt; (y)))\n#define BATT_ASSERT_IMPLIES(p, q) BATT_ASSERT_DISABLED(::batt::ignore((p), (q), !(p), bool(q)))\n#define BATT_ASSERT_IN_RANGE(low, x, high)                                                                   \\\n    BATT_ASSERT_DISABLED(::batt::ignore((low), (x), (high), (low) &lt;= (x), (x) &lt; (high)))\n#endif  // (BATT_WITH_ASSERTS) ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#define BATT_ASSERT_NOT_NULLPTR(x) BATT_ASSERT(x != nullptr)\n#define BATT_CHECK_NOT_NULLPTR(x) BATT_CHECK(x != nullptr)\n#define BATT_PANIC()                                                                                         \\\n    for (bool one_time = true; one_time; one_time = false, ::batt::fail_check_exit(), BATT_UNREACHABLE())    \\\n    BATT_FAIL_CHECK_OUT &lt;&lt; \"*** PANIC *** At:\\n\" &lt;&lt; __FILE__ &lt;&lt; \":\" &lt;&lt; __LINE__ &lt;&lt; \":\" &lt;&lt; std::endl\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BATT_INSPECT(expr) : expand to debug-friendly stream insertion expression.\n// TODO [tastolfi 2021-10-20] Update docs for assert.hpp to include BATT_INSPECT\n//\n#define BATT_INSPECT(expr) \" \" &lt;&lt; #expr &lt;&lt; \" == \" &lt;&lt; (expr)\n#define BATT_UNTESTED_LINE() BATT_PANIC() &lt;&lt; \"Add test point!\"\n#define BATT_UNTESTED_COND(x) BATT_CHECK(!(x)) &lt;&lt; \"Add test point!\"\n}  // namespace batt\n#include &lt;batteries/segv.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/assert_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/assert__impl_8hpp/","title":"batteries/assert_impl.hpp","text":""},{"location":"_autogen/Files/assert__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/assert__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASSERT_IMPL_HPP"},{"location":"_autogen/Files/assert__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/assert__impl_8hpp/#define-batteries_assert_impl_hpp","title":"define BATTERIES_ASSERT_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASSERT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/assert__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_ASSERT_IMPL_HPP\n#define BATTERIES_ASSERT_IMPL_HPP\n#include &lt;atomic&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_NORETURN BATT_INLINE_IMPL void fail_check_exit()\n{\nfail_check_exit_entered().store(true);\nBATT_FAIL_CHECK_OUT &lt;&lt; std::endl &lt;&lt; std::endl;\nstd::abort();\nBATT_UNREACHABLE();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::atomic&lt;bool&gt;&amp; fail_check_exit_entered()\n{\nstatic std::atomic&lt;bool&gt; entered_{false};\nreturn entered_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::atomic&lt;bool&gt;&amp; fail_check_spin_lock()\n{\nstatic std::atomic&lt;bool&gt; spin_lock_{false};\nreturn spin_lock_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool lock_fail_check_mutex()\n{\nstd::atomic&lt;bool&gt;&amp; spin_lock = fail_check_spin_lock();\nthread_local bool locked_by_this_thread = false;\nif (!locked_by_this_thread) {\nwhile (!spin_lock.exchange(true)) {\ncontinue;\n}\nlocked_by_this_thread = true;\nreturn true;\n}\nreturn false;\n}\n}  //namespace batt\n#endif  // BATTERIES_ASSERT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/async__run__task_8hpp/","title":"batteries/async/async_run_task.hpp","text":""},{"location":"_autogen/Files/async__run__task_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/async__run__task_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_ASYNC_RUN_TASK_HPP"},{"location":"_autogen/Files/async__run__task_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/async__run__task_8hpp/#define-batteries_async_async_run_task_hpp","title":"define BATTERIES_ASYNC_ASYNC_RUN_TASK_HPP","text":"<pre><code>#define BATTERIES_ASYNC_ASYNC_RUN_TASK_HPP()\n</code></pre>"},{"location":"_autogen/Files/async__run__task_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_ASYNC_RUN_TASK_HPP\n#define BATTERIES_ASYNC_ASYNC_RUN_TASK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/preallocated_task.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\ntemplate &lt;typename BodyFn = void(), typename... TaskArgsAndHandler&gt;\nTask* async_run_task(const boost::asio::any_io_executor&amp; ex, StackSize stack_byte_size, BodyFn&amp;&amp; body_fn,\nTaskArgsAndHandler&amp;&amp;... task_args_and_handler)\n{\nauto* preallocated_task = rotate_args_right(\n[](auto&amp;&amp; completion_handler, const boost::asio::any_io_executor&amp; ex, StackSize stack_byte_size,\nBodyFn&amp;&amp; body_fn, auto&amp;&amp;... task_args) {\nusing CompletionHandlerFn = std::decay_t&lt;decltype(completion_handler)&gt;;\nstatic_assert(std::is_same_v&lt;decltype(completion_handler), CompletionHandlerFn&amp;&amp;&gt;);\nreturn PreallocatedTask&lt;CompletionHandlerFn&gt;::make_new(ex, BATT_FORWARD(completion_handler),\nstack_byte_size, BATT_FORWARD(body_fn),\nBATT_FORWARD(task_args)...);\n},\nex, stack_byte_size, BATT_FORWARD(body_fn), BATT_FORWARD(task_args_and_handler)...);\nreturn preallocated_task-&gt;task_pointer();\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_ASYNC_RUN_TASK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/","title":"batteries/atomic_counter_gauge.hpp","text":""},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/#classes","title":"Classes","text":"Name class batt::AtomicCounterGauge An atomic variable that maintains a gauge-like value, which can rise and fall over time, by means of two monotonic counters: one for increases, one for decreases. class batt::AtomicCounterGauge::State A value of the atomic variable that implements AtomicCounterGauge."},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ATOMIC_COUNTER_GAUGE_HPP"},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/#define-batteries_atomic_counter_gauge_hpp","title":"define BATTERIES_ATOMIC_COUNTER_GAUGE_HPP","text":"<pre><code>#define BATTERIES_ATOMIC_COUNTER_GAUGE_HPP()\n</code></pre>"},{"location":"_autogen/Files/atomic__counter__gauge_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ATOMIC_COUNTER_GAUGE_HPP\n#define BATTERIES_ATOMIC_COUNTER_GAUGE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\ntemplate &lt;typename IntT&gt;\nclass AtomicCounterGauge\n{\npublic:\nusing Self = AtomicCounterGauge;\nusing value_type = IntT;\n//                      |-------------------------kNumBits--------------------------|\n//                      |--------kNumCountBits--------|--------kNumCountBits--------|\n//                      | |                           | |-----kAddOverflowShift-----|\n//                      | |                           |----------kSubShift----------|\n//                      | |-------------------kSubOverflowShift---------------------|\n//\n// kHalfMask          = |                             |11111111111111111111111111111|\n// kCountMask         = |                             | 1111111111111111111111111111|\n// kGaugeMask         = |                             | 1111111111111111111111111111|\n//\n// kAddIncrement      = |                             |                            1|\n// kAddOverflow       = |                             |10000000000000000000000000000|\n// kAddMask           = |                             |11111111111111111111111111111|\n//\n// kSubIncrement      = |                            1|00000000000000000000000000000|\n// kSubOverflow       = |10000000000000000000000000000|00000000000000000000000000000|\n// kSubMask           = |11111111111111111111111111111|00000000000000000000000000000|\n//\nstatic constexpr usize kNumBits = sizeof(IntT) * 8;\nstatic constexpr usize kNumCountBits = kNumBits / 2;\nstatic_assert(kNumCountBits * 2 == kNumBits);\nstatic constexpr value_type kHalfMask = ((value_type{1} &lt;&lt; kNumCountBits) - 1);\nstatic constexpr value_type kCountMask = (value_type{1} &lt;&lt; (kNumCountBits - 1)) - 1;\nstatic constexpr value_type kGaugeMask = kCountMask;\nstatic constexpr usize kAddShift = 0;\nstatic constexpr usize kAddOverflowShift = kNumCountBits - 1;\nstatic constexpr usize kSubShift = kNumCountBits;\nstatic constexpr usize kSubOverflowShift = kNumBits - 1;\nstatic constexpr value_type kAddIncrement = value_type{1} &lt;&lt; kAddShift;\nstatic constexpr value_type kAddOverflow = value_type{1} &lt;&lt; kAddOverflowShift;\nstatic constexpr value_type kAddMask = kHalfMask &lt;&lt; kAddShift;\nstatic constexpr value_type kSubIncrement = value_type{1} &lt;&lt; kSubShift;\nstatic constexpr value_type kSubOverflow = value_type{1} &lt;&lt; kSubOverflowShift;\nstatic constexpr value_type kSubMask = kHalfMask &lt;&lt; kSubShift;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nclass State\n{\npublic:\nfriend class AtomicCounterGauge&lt;IntT&gt;;\n//----- --- -- -  -  -   -\nstatic State from_counts(value_type add_count, value_type sub_count) noexcept\n{\nreturn State{value_type(                       //\n((add_count &amp; kGaugeMask) &lt;&lt; kAddShift) |  //\n((sub_count &amp; kGaugeMask) &lt;&lt; kSubShift)    //\n)};\n}\nstatic State from_gauge(value_type gauge_value) noexcept\n{\nreturn State::from_counts(gauge_value, 0);\n}\nstatic value_type normalize(value_type observed_state) noexcept\n{\n// Extract and align the overflow (most-significant) bits of both the add and subtract counters.\n//\nconst value_type add_overflow = (observed_state &amp; kAddOverflow) &gt;&gt; kAddShift;\nconst value_type sub_overflow = (observed_state &amp; kSubOverflow) &gt;&gt; kSubShift;\n// Iff the overflow bits of add and sub counters are *both* set, then set the common overflow bit.\n//\nconst value_type common_overflow = add_overflow &amp; sub_overflow;\n// Subtract any common overflow from both counters.\n//\nconst value_type normalized_state =\nobserved_state &amp; ~((common_overflow &lt;&lt; kAddShift) | (common_overflow &lt;&lt; kSubShift));\nreturn normalized_state;\n}\n//----- --- -- -  -  -   -\nexplicit State(value_type value) noexcept : value_{value}\n{\n}\n//----- --- -- -  -  -   -\nvalue_type get_gauge() const noexcept\n{\nreturn (this-&gt;impl_add_count() - this-&gt;impl_sub_count()) &amp; kGaugeMask;\n}\nvalue_type get_add_count() const noexcept\n{\nreturn ((this-&gt;value_ &gt;&gt; kAddShift) &amp; kCountMask);\n}\nvalue_type get_sub_count() const noexcept\n{\nreturn ((this-&gt;value_ &gt;&gt; kSubShift) &amp; kCountMask);\n}\nvalue_type value() const noexcept\n{\nreturn this-&gt;value_;\n}\n//----- --- -- -  -  -   -\nprivate:\nvalue_type impl_add_count() const noexcept\n{\nreturn ((this-&gt;value_ &gt;&gt; kAddShift) &amp; kHalfMask);\n}\nvalue_type impl_sub_count() const noexcept\n{\nreturn ((this-&gt;value_ &gt;&gt; kSubShift) &amp; kHalfMask);\n}\n//----- --- -- -  -  -   -\nvalue_type value_;\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit AtomicCounterGauge(value_type initial_value = 0) noexcept\n: state_{State::from_gauge(initial_value).value()}\n{\n}\nexplicit AtomicCounterGauge(State initial_state) noexcept : state_{initial_state.value()}\n{\n}\nState load() noexcept\n{\nreturn State{this-&gt;state_.load()};\n}\nvoid store(value_type new_value) noexcept\n{\nthis-&gt;store(State::from_gauge(new_value));\n}\nvoid store(State new_state) noexcept\n{\nthis-&gt;state_.store(new_state.value());\n}\nState exchange(State new_state) noexcept\n{\nreturn State{this-&gt;state_.exchange(new_state.value())};\n}\nState exchange(value_type new_value) noexcept\n{\nreturn this-&gt;exchange(State::from_gauge(new_value));\n}\nState fetch_add(value_type delta) noexcept\n{\ndelta = (delta &amp; kCountMask) &lt;&lt; kAddShift;\nconst value_type old_state = this-&gt;state_.fetch_add(delta);\nconst value_type new_state = old_state + delta;\nBATT_CHECK_LE((u64)State{old_state}.impl_add_count(),                    //\n(u64)State{new_state}.impl_add_count())                    //\n&lt;&lt; \"Add (positive) counter overflow detected! old_state=\"            //\n&lt;&lt; std::bitset&lt;kNumBits&gt;{State{old_state}.value()} &lt;&lt; \" new_state=\"  //\n&lt;&lt; std::bitset&lt;kNumBits&gt;{State{new_state}.value()};\nthis-&gt;normalize(new_state);\nreturn State{old_state};\n}\nState increment() noexcept\n{\nreturn this-&gt;fetch_add(1);\n}\nState fetch_sub(value_type delta) noexcept\n{\ndelta = (delta &amp; kCountMask) &lt;&lt; kSubShift;\nconst value_type old_state = this-&gt;state_.fetch_add(delta);\nconst value_type new_state = old_state + delta;\nBATT_CHECK_LE((u64)State{old_state}.impl_sub_count(),                    //\n(u64)State{new_state}.impl_sub_count())                    //\n&lt;&lt; \"Sub (negative) counter overflow detected! old_state=\"            //\n&lt;&lt; std::bitset&lt;kNumBits&gt;{State{old_state}.value()} &lt;&lt; \" new_state=\"  //\n&lt;&lt; std::bitset&lt;kNumBits&gt;{State{new_state}.value()};\nthis-&gt;normalize(new_state);\nreturn State{old_state};\n}\nState decrement() noexcept\n{\nreturn this-&gt;fetch_sub(1);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nvalue_type normalize(value_type observed_state) noexcept\n{\nfor (;;) {\nconst value_type normalized_state = State::normalize(observed_state);\nif (BATT_HINT_TRUE(normalized_state == observed_state) ||\nthis-&gt;state_.compare_exchange_weak(observed_state, normalized_state)) {\nreturn normalized_state;\n}\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstd::atomic&lt;value_type&gt; state_;\n};\n}  //namespace batt\n#endif  // BATTERIES_ATOMIC_COUNTER_GAUGE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/attach_8hpp/","title":"batteries/seq/attach.hpp","text":""},{"location":"_autogen/Files/attach_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/attach_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Attach struct batt::seq::AttachBinder"},{"location":"_autogen/Files/attach_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ATTACH_HPP"},{"location":"_autogen/Files/attach_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/attach_8hpp/#define-batteries_seq_attach_hpp","title":"define BATTERIES_SEQ_ATTACH_HPP","text":"<pre><code>#define BATTERIES_SEQ_ATTACH_HPP()\n</code></pre>"},{"location":"_autogen/Files/attach_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ATTACH_HPP\n#define BATTERIES_SEQ_ATTACH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// attach(user_data) - attach a value to a sequence\n//\ntemplate &lt;typename Seq, typename Data&gt;\nclass Attach\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nusing UserData = Data;\nexplicit Attach(Seq&amp;&amp; seq, Data&amp;&amp; data) noexcept : seq_(BATT_FORWARD(seq)), data_(BATT_FORWARD(data))\n{\n}\nData&amp; user_data()\n{\nreturn data_;\n}\nconst Data&amp; user_data() const\n{\nreturn data_;\n}\nOptional&lt;Item&gt; peek()\n{\nreturn seq_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn seq_.next();\n}\nprivate:\nSeq seq_;\nData data_;\n};\ntemplate &lt;typename D&gt;\nstruct AttachBinder {\nD data;\n};\ntemplate &lt;typename D&gt;\ninline AttachBinder&lt;D&gt; attach(D&amp;&amp; data)\n{\nreturn {BATT_FORWARD(data)};\n}\ntemplate &lt;typename Seq, typename D&gt;\n[[nodiscard]] inline auto operator|(Seq&amp;&amp; seq, AttachBinder&lt;D&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;Seq&gt;, Seq&gt;, \"attach may not be used with references\");\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;D&gt;, D&gt;, \"attach may not be used with references\");\nreturn Attach&lt;Seq, D&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.data)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ATTACH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/backoff_8cpp/","title":"batteries/async/backoff.cpp","text":""},{"location":"_autogen/Files/backoff_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/backoff.hpp&gt;\n//\n#include &lt;batteries/async/backoff_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/backoff_8hpp/","title":"batteries/async/backoff.hpp","text":""},{"location":"_autogen/Files/backoff_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/backoff_decl.hpp&gt;\n#include &lt;batteries/async/backoff.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/backoff_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/backoff__decl_8hpp/","title":"batteries/async/backoff_decl.hpp","text":""},{"location":"_autogen/Files/backoff__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/backoff__decl_8hpp/#classes","title":"Classes","text":"Name struct batt::RetryState struct batt::ExponentialBackoff struct batt::TaskSleepImpl struct batt::DefaultStatusIsRetryableImpl"},{"location":"_autogen/Files/backoff__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_BACKOFF_DECL_HPP"},{"location":"_autogen/Files/backoff__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/backoff__decl_8hpp/#define-batteries_async_backoff_decl_hpp","title":"define BATTERIES_ASYNC_BACKOFF_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_BACKOFF_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/backoff__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BACKOFF_DECL_HPP\n#define BATTERIES_ASYNC_BACKOFF_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/task_decl.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wdeprecated-declarations\")\n#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#include &lt;type_traits&gt;\nnamespace batt {\nstruct TaskSleepImpl;\nstruct DefaultStatusIsRetryableImpl;\n// Try an action until it succeeds, according to the specified RetryPolicy, which controls the maximum number\n// of retries and the delay (if any) between retries.\n//\n// A RetryPolicy type must be passable via ADL to some overload of the free function `update_retry_state`,\n// which takes a (mutable) reference to an instance of `RetryState` and the policy object as its two\n// arguments.\n//\n// `action_fn` should return `batt::Status` or some type that is convertible to `batt::Status` via\n// `batt::to_status`.  For example, batt::StatusOr&lt;T&gt;, batt::Status, and boost::system::error_code are all\n// allowable return types.\n//\ntemplate &lt;typename RetryPolicy, typename ActionFn, typename Result = std::invoke_result_t&lt;ActionFn&gt;,\ntypename SleepImpl = TaskSleepImpl, typename StatusIsRetryableImpl = DefaultStatusIsRetryableImpl&gt;\nResult with_retry_policy(RetryPolicy&amp;&amp; policy, std::string_view action_name, ActionFn&amp;&amp; action_fn,\nSleepImpl&amp;&amp; sleep_impl = {}, StatusIsRetryableImpl&amp;&amp; status_is_retryable_impl = {});\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// State variables passed into `update_retry_state` along with a RetryPolicy object in order to update the\n// backoff delay.\n//\nstruct RetryState {\nbool should_retry = false;\nu64 n_attempts = 0;\nu64 prev_delay_usec = 0;\nu64 next_delay_usec = 0;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// A retry policy that implements simple exponential backoff and retry with no jitter.\n//\nstruct ExponentialBackoff {\n// 0 means no maximum.\n//\nu64 max_attempts;\n// How long to wait after the first failed attempt.\n//\nu64 initial_delay_usec;\n// How much to increase after each failed attempt:\n//   next_delay = prev_delay * backoff_factor / backoff_divisor.\n//\nu64 backoff_factor;\nu64 backoff_divisor;\n// The maximum delay.\n//\nu64 max_delay_usec;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic ExponentialBackoff with_default_params();\n};\n// Increase the delay interval by the constant factor specified in `policy`; `RetryState::should_retry` will\n// be true until `RetryState::n_attempts` exceeds `ExponentialBackoff::max_attempts`.\n//\nvoid update_retry_state(RetryState&amp; state, const ExponentialBackoff&amp; policy);\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// The default sleep implementation for `with_retry_policy`.\n//\nstruct TaskSleepImpl {\ntemplate &lt;typename DurationT&gt;\nvoid operator()(DurationT&amp;&amp; duration) const\n{\nTask::sleep(BATT_FORWARD(duration));\n}\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// The default 'status_is_retryable' implementation for `with_retry_policy`.\n//\nstruct DefaultStatusIsRetryableImpl {\nbool operator()(const Status&amp; s) const\n{\nreturn status_is_retryable(s);\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_BACKOFF_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/backoff__impl_8hpp/","title":"batteries/async/backoff_impl.hpp","text":""},{"location":"_autogen/Files/backoff__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/backoff__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_BACKOFF_IMPL_HPP"},{"location":"_autogen/Files/backoff__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/backoff__impl_8hpp/#define-batteries_async_backoff_impl_hpp","title":"define BATTERIES_ASYNC_BACKOFF_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_BACKOFF_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/backoff__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BACKOFF_IMPL_HPP\n#define BATTERIES_ASYNC_BACKOFF_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ ExponentialBackoff ExponentialBackoff::with_default_params()\n{\nExponentialBackoff p;\np.max_attempts = 40;\np.initial_delay_usec = 10;\np.backoff_factor = 2;\np.backoff_divisor = 1;\np.max_delay_usec = 250 * 1000;  // 250ms\nreturn p;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void update_retry_state(RetryState&amp; state, const ExponentialBackoff&amp; policy)\n{\nif (policy.max_attempts != 0 &amp;&amp; state.n_attempts &gt;= policy.max_attempts) {\nstate.should_retry = false;\nreturn;\n}\nstate.should_retry = true;\nstate.n_attempts += 1;\nstate.prev_delay_usec = state.next_delay_usec;\nif (state.n_attempts == 1) {\nstate.next_delay_usec = policy.initial_delay_usec;\n} else {\nstate.next_delay_usec = std::min(\npolicy.max_delay_usec, state.prev_delay_usec * policy.backoff_factor / policy.backoff_divisor);\n}\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_BACKOFF_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/basic__executor_8hpp/","title":"batteries/async/basic_executor.hpp","text":""},{"location":"_autogen/Files/basic__executor_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/basic__executor_8hpp/#classes","title":"Classes","text":"Name class batt::BasicExecutor"},{"location":"_autogen/Files/basic__executor_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_BASIC_EXECUTOR_HPP"},{"location":"_autogen/Files/basic__executor_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/basic__executor_8hpp/#define-batteries_async_basic_executor_hpp","title":"define BATTERIES_ASYNC_BASIC_EXECUTOR_HPP","text":"<pre><code>#define BATTERIES_ASYNC_BASIC_EXECUTOR_HPP()\n</code></pre>"},{"location":"_autogen/Files/basic__executor_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BASIC_EXECUTOR_HPP\n#define BATTERIES_ASYNC_BASIC_EXECUTOR_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/asio/execution_context.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename ContextT, typename OutstandingWorkP, typename BlockingP, typename RelationshipP&gt;\nclass BasicExecutor\n{\npublic:\nusing Self = BasicExecutor;\nusing context_type = ContextT;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr explicit BasicExecutor() noexcept : context_{nullptr}\n{\n}\nconstexpr explicit BasicExecutor(ContextT* context) noexcept : context_{context}\n{\nif (std::is_same_v&lt;OutstandingWorkP, boost::asio::execution::outstanding_work_t::tracked_t&gt;) {\nthis-&gt;on_work_started();\n}\n}\nconstexpr BasicExecutor(const Self&amp; other) noexcept : Self{other.context_}\n{\n}\nconstexpr BasicExecutor(Self&amp;&amp; other) noexcept : context_{other.context_}\n{\nother.context_ = nullptr;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nSelf&amp; operator=(const Self&amp; other) noexcept\n{\nSelf tmp{other};\nthis-&gt;swap(tmp);\nreturn *this;\n}\nSelf&amp; operator=(Self&amp;&amp; other) noexcept\n{\nSelf tmp{std::move(other)};\nthis-&gt;swap(tmp);\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n~BasicExecutor() noexcept\n{\nif (std::is_same_v&lt;OutstandingWorkP, boost::asio::execution::outstanding_work_t::tracked_t&gt;) {\nthis-&gt;on_work_finished();\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid swap(Self&amp; other)\n{\nstd::swap(this-&gt;context_, other.context_);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nContextT&amp; context() const\n{\nreturn *this-&gt;context_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::blocking_t::possibly_t) const\n{\nreturn BasicExecutor&lt;ContextT, OutstandingWorkP, boost::asio::execution::blocking_t::possibly_t,\nRelationshipP&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::blocking_t::never_t) const\n{\nreturn BasicExecutor&lt;ContextT, OutstandingWorkP, boost::asio::execution::blocking_t::never_t,\nRelationshipP&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::relationship_t::fork_t) const\n{\nreturn BasicExecutor&lt;ContextT, OutstandingWorkP, BlockingP,\nboost::asio::execution::relationship_t::fork_t&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::relationship_t::continuation_t) const\n{\nreturn BasicExecutor&lt;ContextT, OutstandingWorkP, BlockingP,\nboost::asio::execution::relationship_t::continuation_t&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::outstanding_work_t::tracked_t) const\n{\nreturn BasicExecutor&lt;ContextT, boost::asio::execution::outstanding_work_t::tracked_t, BlockingP,\nRelationshipP&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::outstanding_work_t::untracked_t) const\n{\nreturn BasicExecutor&lt;ContextT, boost::asio::execution::outstanding_work_t::untracked_t, BlockingP,\nRelationshipP&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename OtherAllocator&gt;\nconstexpr Self require(boost::asio::execution::allocator_t&lt;OtherAllocator&gt;) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self require(boost::asio::execution::allocator_t&lt;void&gt;) const\n{\nreturn *this;\n}\n//----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nconstexpr auto prefer(boost::asio::execution::prefer_only&lt;T&gt;) const\n{\nreturn this-&gt;require(T{});\n}\n//----- --- -- -  -  -   -\nstatic constexpr auto query(boost::asio::execution::mapping_t) noexcept  //\n-&gt; boost::asio::execution::mapping_t;\nstatic constexpr auto query(boost::asio::execution::outstanding_work_t) noexcept  //\n-&gt; boost::asio::execution::outstanding_work_t;\nconstexpr auto query(boost::asio::execution::blocking_t) const noexcept  //\n-&gt; boost::asio::execution::blocking_t;\nconstexpr auto query(boost::asio::execution::relationship_t) const noexcept  //\n-&gt; boost::asio::execution::relationship_t;\ntemplate &lt;typename OtherAllocator&gt;\nconstexpr auto query(boost::asio::execution::allocator_t&lt;OtherAllocator&gt;) const noexcept  //\n-&gt; std::allocator&lt;void&gt;;\nconstexpr auto query(boost::asio::execution::allocator_t&lt;void&gt;) const noexcept  //\n-&gt; std::allocator&lt;void&gt;;\nauto query(boost::asio::execution::context_t) const noexcept  //\n-&gt; ContextT&amp;;\nauto query(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;) const noexcept  //\n-&gt; boost::asio::execution_context&amp;;\n//----- --- -- -  -  -   -\nvoid on_work_started() const noexcept;\nvoid on_work_finished() const noexcept;\ntemplate &lt;typename Fn&gt;\nvoid execute(Fn&amp;&amp; fn) const noexcept;\ntemplate &lt;typename Fn, typename FnAllocator&gt;\nvoid dispatch(Fn&amp;&amp; fn, FnAllocator&amp;&amp;) const noexcept;\ntemplate &lt;typename Fn, typename FnAllocator&gt;\nvoid post(Fn&amp;&amp; fn, FnAllocator&amp;&amp;) const noexcept;\ntemplate &lt;typename Fn, typename FnAllocator&gt;\nvoid defer(Fn&amp;&amp; fn, FnAllocator&amp;&amp;) const noexcept;\nprivate:\nContextT* context_;\n};\n}  //namespace batt\n#include &lt;batteries/async/basic_executor.ipp&gt;\n#endif  // BATTERIES_ASYNC_BASIC_EXECUTOR_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/batteries_8hpp/","title":"batteries.hpp","text":""},{"location":"_autogen/Files/batteries_8hpp/#source-code","title":"Source code","text":"<pre><code>// Convenience header to include all of the Batteries library.\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/algo/parallel_accumulate.hpp&gt;\n#include &lt;batteries/algo/parallel_copy.hpp&gt;\n#include &lt;batteries/algo/parallel_merge.hpp&gt;\n#include &lt;batteries/algo/parallel_running_total.hpp&gt;\n#include &lt;batteries/algo/parallel_transform.hpp&gt;\n#include &lt;batteries/algo/running_total.hpp&gt;\n#include &lt;batteries/asio/any_io_executor.hpp&gt;\n#include &lt;batteries/asio/deadline_timer.hpp&gt;\n#include &lt;batteries/asio/execution_context.hpp&gt;\n#include &lt;batteries/asio/io_context.hpp&gt;\n#include &lt;batteries/asio/ip_tcp.hpp&gt;\n#include &lt;batteries/asio/post.hpp&gt;\n#include &lt;batteries/asio/system_executor.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/backoff.hpp&gt;\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/async/buffered_channel.hpp&gt;\n#include &lt;batteries/async/channel.hpp&gt;\n#include &lt;batteries/async/continuation.hpp&gt;\n#include &lt;batteries/async/debug_info.hpp&gt;\n#include &lt;batteries/async/dump_tasks.hpp&gt;\n#include &lt;batteries/async/fake_execution_context.hpp&gt;\n#include &lt;batteries/async/fake_executor.hpp&gt;\n#include &lt;batteries/async/fake_task_scheduler.hpp&gt;\n#include &lt;batteries/async/fake_time_service.hpp&gt;\n#include &lt;batteries/async/fetch.hpp&gt;\n#include &lt;batteries/async/future.hpp&gt;\n#include &lt;batteries/async/grant.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/latch.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/pin.hpp&gt;\n#include &lt;batteries/async/priority_watch.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/rate_limiter.hpp&gt;\n#include &lt;batteries/async/runtime.hpp&gt;\n#include &lt;batteries/async/single_thread_executor.hpp&gt;\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/task_scheduler.hpp&gt;\n#include &lt;batteries/async/types.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/worker.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/bounds.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/case_of.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/compare.hpp&gt;\n#include &lt;batteries/constants.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/do_nothing.hpp&gt;\n#include &lt;batteries/endian.hpp&gt;\n#include &lt;batteries/env.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/hash.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/http/host_address.hpp&gt;\n#include &lt;batteries/http/http_chunk_decoder.hpp&gt;\n#include &lt;batteries/http/http_chunk_encoder.hpp&gt;\n#include &lt;batteries/http/http_client.hpp&gt;\n#include &lt;batteries/http/http_client_connection.hpp&gt;\n#include &lt;batteries/http/http_client_host_context.hpp&gt;\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_header.hpp&gt;\n#include &lt;batteries/http/http_message_base.hpp&gt;\n#include &lt;batteries/http/http_request.hpp&gt;\n#include &lt;batteries/http/http_response.hpp&gt;\n#include &lt;batteries/http/http_server.hpp&gt;\n#include &lt;batteries/http/http_version.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/interval.hpp&gt;\n#include &lt;batteries/interval_traits.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/make_printable.hpp&gt;\n#include &lt;batteries/math.hpp&gt;\n#include &lt;batteries/metrics/metric_collectors.hpp&gt;\n#include &lt;batteries/metrics/metric_csv_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_dumper.hpp&gt;\n#include &lt;batteries/metrics/metric_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_otel_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\n#include &lt;batteries/no_destruct.hpp&gt;\n#include &lt;batteries/nullable.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/pico_http/parser.hpp&gt;\n#include &lt;batteries/pointers.hpp&gt;\n#include &lt;batteries/protobuf/stream_buffer_input_stream.hpp&gt;\n#include &lt;batteries/protobuf/stream_buffer_output_stream.hpp&gt;\n#include &lt;batteries/radix_queue.hpp&gt;\n#include &lt;batteries/ref.hpp&gt;\n#include &lt;batteries/require.hpp&gt;\n#include &lt;batteries/segv.hpp&gt;\n#include &lt;batteries/seq.hpp&gt;\n#include &lt;batteries/seq/addition.hpp&gt;\n#include &lt;batteries/seq/all_true.hpp&gt;\n#include &lt;batteries/seq/any_true.hpp&gt;\n#include &lt;batteries/seq/apply.hpp&gt;\n#include &lt;batteries/seq/attach.hpp&gt;\n#include &lt;batteries/seq/boxed.hpp&gt;\n#include &lt;batteries/seq/cache_next.hpp&gt;\n#include &lt;batteries/seq/chain.hpp&gt;\n#include &lt;batteries/seq/collect.hpp&gt;\n#include &lt;batteries/seq/collect_vec.hpp&gt;\n#include &lt;batteries/seq/consume.hpp&gt;\n#include &lt;batteries/seq/count.hpp&gt;\n#include &lt;batteries/seq/decay.hpp&gt;\n#include &lt;batteries/seq/deref.hpp&gt;\n#include &lt;batteries/seq/emplace_back.hpp&gt;\n#include &lt;batteries/seq/empty.hpp&gt;\n#include &lt;batteries/seq/filter.hpp&gt;\n#include &lt;batteries/seq/filter_map.hpp&gt;\n#include &lt;batteries/seq/first.hpp&gt;\n#include &lt;batteries/seq/flatten.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/fuse.hpp&gt;\n#include &lt;batteries/seq/group_by.hpp&gt;\n#include &lt;batteries/seq/inner_reduce.hpp&gt;\n#include &lt;batteries/seq/inspect.hpp&gt;\n#include &lt;batteries/seq/inspect_adjacent.hpp&gt;\n#include &lt;batteries/seq/is_sorted.hpp&gt;\n#include &lt;batteries/seq/kmerge.hpp&gt;\n#include &lt;batteries/seq/last.hpp&gt;\n#include &lt;batteries/seq/lazy.hpp&gt;\n#include &lt;batteries/seq/loop_control.hpp&gt;\n#include &lt;batteries/seq/map.hpp&gt;\n#include &lt;batteries/seq/map_adjacent.hpp&gt;\n#include &lt;batteries/seq/map_fold.hpp&gt;\n#include &lt;batteries/seq/map_pairwise.hpp&gt;\n#include &lt;batteries/seq/merge_by.hpp&gt;\n#include &lt;batteries/seq/natural_equals.hpp&gt;\n#include &lt;batteries/seq/natural_order.hpp&gt;\n#include &lt;batteries/seq/prepend.hpp&gt;\n#include &lt;batteries/seq/print_out.hpp&gt;\n#include &lt;batteries/seq/printable.hpp&gt;\n#include &lt;batteries/seq/product.hpp&gt;\n#include &lt;batteries/seq/reduce.hpp&gt;\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/seq/reverse.hpp&gt;\n#include &lt;batteries/seq/rolling.hpp&gt;\n#include &lt;batteries/seq/rolling_sum.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/seq/skip_n.hpp&gt;\n#include &lt;batteries/seq/splice.hpp&gt;\n#include &lt;batteries/seq/status_ok.hpp&gt;\n#include &lt;batteries/seq/sub_range_seq.hpp&gt;\n#include &lt;batteries/seq/sum.hpp&gt;\n#include &lt;batteries/seq/take_n.hpp&gt;\n#include &lt;batteries/seq/take_while.hpp&gt;\n#include &lt;batteries/seq/zip.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/slice.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/stacktrace.hpp&gt;\n#include &lt;batteries/state_machine_model.hpp&gt;\n#include &lt;batteries/state_machine_model/advanced_options.hpp&gt;\n#include &lt;batteries/state_machine_model/entropy_source.hpp&gt;\n#include &lt;batteries/state_machine_model/exhaustive_model_checker.hpp&gt;\n#include &lt;batteries/state_machine_model/parallel_model_check_state.hpp&gt;\n#include &lt;batteries/state_machine_model/state_machine_result.hpp&gt;\n#include &lt;batteries/state_machine_model/state_machine_traits.hpp&gt;\n#include &lt;batteries/state_machine_model/stochastic_model_checker.hpp&gt;\n#include &lt;batteries/state_machine_model/verbose.hpp&gt;\n#include &lt;batteries/static_assert.hpp&gt;\n#include &lt;batteries/static_dispatch.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/strict.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/syscall_retry.hpp&gt;\n#include &lt;batteries/token.hpp&gt;\n#include &lt;batteries/tuples.hpp&gt;\n#include &lt;batteries/type_erasure.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/url_parse.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/bool__status_8hpp/","title":"batteries/bool_status.hpp","text":""},{"location":"_autogen/Files/bool__status_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/bool__status_8hpp/#defines","title":"Defines","text":"Name BATTERIES_BOOL_STATUS_HPP"},{"location":"_autogen/Files/bool__status_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/bool__status_8hpp/#define-batteries_bool_status_hpp","title":"define BATTERIES_BOOL_STATUS_HPP","text":"<pre><code>#define BATTERIES_BOOL_STATUS_HPP()\n</code></pre>"},{"location":"_autogen/Files/bool__status_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_BOOL_STATUS_HPP\n#define BATTERIES_BOOL_STATUS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;ostream&gt;\nnamespace batt {\nenum struct BoolStatus : i8 {\nkUnknown = -1,\nkFalse = 0,\nkTrue = 1,\n};\ninline constexpr BoolStatus bool_status_from(bool b) noexcept\n{\nif (b) {\nreturn BoolStatus::kTrue;\n}\nreturn BoolStatus::kFalse;\n}\ninline constexpr BoolStatus operator||(BoolStatus left, BoolStatus right) noexcept\n{\nswitch (left) {\ncase BoolStatus::kFalse:\nreturn right;\ncase BoolStatus::kTrue:\nreturn BoolStatus::kTrue;\ncase BoolStatus::kUnknown:  // fall-through\ndefault:\nswitch (right) {\ncase BoolStatus::kTrue:\nreturn BoolStatus::kTrue;\ncase BoolStatus::kFalse:    // fall-through\ncase BoolStatus::kUnknown:  // fall-through\ndefault:\nreturn BoolStatus::kUnknown;\n}\n}\n}\ninline constexpr BoolStatus operator&amp;&amp;(BoolStatus left, BoolStatus right) noexcept\n{\nswitch (left) {\ncase BoolStatus::kTrue:\nreturn right;\ncase BoolStatus::kFalse:\nreturn BoolStatus::kFalse;\ncase BoolStatus::kUnknown:  // fall-through\ndefault:\nswitch (right) {\ncase BoolStatus::kFalse:\nreturn BoolStatus::kFalse;\ncase BoolStatus::kTrue:     // fall-through\ncase BoolStatus::kUnknown:  // fall-through\ndefault:\nreturn BoolStatus::kUnknown;\n}\n}\n}\ninline constexpr BoolStatus operator!(BoolStatus b) noexcept\n{\nswitch (b) {\ncase BoolStatus::kFalse:\nreturn BoolStatus::kTrue;\ncase BoolStatus::kTrue:\nreturn BoolStatus::kFalse;\ncase BoolStatus::kUnknown:  // fall-through\ndefault:\nreturn BoolStatus::kUnknown;\n}\n}\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const BoolStatus&amp; t) noexcept\n{\nswitch (t) {\ncase BoolStatus::kFalse:\nreturn out &lt;&lt; \"False\";\ncase BoolStatus::kTrue:\nreturn out &lt;&lt; \"True\";\ncase BoolStatus::kUnknown:  // fall-through\ndefault:\nbreak;\n}\nreturn out &lt;&lt; \"Unknown\";\n}\n}  //namespace batt\n#endif  // BATTERIES_BOOL_STATUS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/bounds_8hpp/","title":"batteries/bounds.hpp","text":""},{"location":"_autogen/Files/bounds_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/bounds_8hpp/#classes","title":"Classes","text":"Name struct batt::LeastUpperBound struct batt::GreatestLowerBound"},{"location":"_autogen/Files/bounds_8hpp/#defines","title":"Defines","text":"Name BATTERIES_BOUNDS_HPP BATT_DEFINE_INT_BOUNDS(type)"},{"location":"_autogen/Files/bounds_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/bounds_8hpp/#define-batteries_bounds_hpp","title":"define BATTERIES_BOUNDS_HPP","text":"<pre><code>#define BATTERIES_BOUNDS_HPP()\n</code></pre>"},{"location":"_autogen/Files/bounds_8hpp/#define-batt_define_int_bounds","title":"define BATT_DEFINE_INT_BOUNDS","text":"<pre><code>#define BATT_DEFINE_INT_BOUNDS(type)\n</code></pre>"},{"location":"_autogen/Files/bounds_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_BOUNDS_HPP\n#define BATTERIES_BOUNDS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/operators.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nenum struct InclusiveLowerBound : bool { kFalse = false, kTrue = true };\nenum struct InclusiveUpperBound : bool { kFalse = false, kTrue = true };\n#define BATT_DEFINE_INT_BOUNDS(type)                                                                         \\\n    inline type least_upper_bound(type n)                                                                    \\\n    {                                                                                                        \\\n        return n + 1;                                                                                        \\\n    }                                                                                                        \\\n    inline type greatest_lower_bound(type n)                                                                 \\\n    {                                                                                                        \\\n        return n - 1;                                                                                        \\\n    }\nBATT_DEFINE_INT_BOUNDS(i8)\nBATT_DEFINE_INT_BOUNDS(i16)\nBATT_DEFINE_INT_BOUNDS(i32)\nBATT_DEFINE_INT_BOUNDS(i64)\nBATT_DEFINE_INT_BOUNDS(u8)\nBATT_DEFINE_INT_BOUNDS(u16)\nBATT_DEFINE_INT_BOUNDS(u32)\nBATT_DEFINE_INT_BOUNDS(u64)\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename T&gt;\nstruct LeastUpperBound {\nT value;\n};\ntemplate &lt;typename T&gt;\nLeastUpperBound&lt;std::decay_t&lt;T&gt;&gt; least_upper_bound(T&amp;&amp; value)\n{\nreturn {BATT_FORWARD(value)};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename U&gt;\ninline bool operator&lt;(const T&amp; left, const LeastUpperBound&lt;U&gt;&amp; right)\n{\n// left &lt;= right\n//\nreturn !(right.value &lt; left);\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator&lt;(const LeastUpperBound&lt;T&gt;&amp; left, const U&amp; right)\n{\nreturn left.value &lt; right;\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator&lt;(const LeastUpperBound&lt;T&gt;&amp; left, const LeastUpperBound&lt;U&gt;&amp; right)\n{\nreturn left.value &lt; right.value;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const T&amp;, const LeastUpperBound&lt;U&gt;&amp;)\n{\nreturn false;\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const LeastUpperBound&lt;T&gt;&amp;, const U&amp;)\n{\nreturn false;\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const LeastUpperBound&lt;T&gt;&amp; left, const LeastUpperBound&lt;U&gt;&amp; right)\n{\nreturn left.value == right.value;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nBATT_TOTALLY_ORDERED((template &lt;typename T, typename U&gt; inline), T, LeastUpperBound&lt;U&gt;)\nBATT_TOTALLY_ORDERED((template &lt;typename T, typename U&gt; inline), LeastUpperBound&lt;T&gt;, U)\nBATT_TOTALLY_ORDERED((template &lt;typename T, typename U&gt; inline), LeastUpperBound&lt;T&gt;, LeastUpperBound&lt;U&gt;)\nBATT_EQUALITY_COMPARABLE((template &lt;typename T, typename U&gt; inline), T, LeastUpperBound&lt;U&gt;)\nBATT_EQUALITY_COMPARABLE((template &lt;typename T, typename U&gt; inline), LeastUpperBound&lt;T&gt;, U)\nBATT_EQUALITY_COMPARABLE((template &lt;typename T, typename U&gt; inline), LeastUpperBound&lt;T&gt;, LeastUpperBound&lt;U&gt;)\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename T&gt;\nstruct GreatestLowerBound {\nT value;\n};\ntemplate &lt;typename T, typename U&gt;\nGreatestLowerBound&lt;std::decay_t&lt;T&gt;&gt; greatest_lower_bound(T&amp;&amp; value)\n{\nreturn {BATT_FORWARD(value)};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename U&gt;\ninline bool operator&lt;(const T&amp; left, const GreatestLowerBound&lt;U&gt;&amp; right)\n{\nreturn left &lt; right.value;\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator&lt;(const GreatestLowerBound&lt;T&gt;&amp; left, const U&amp; right)\n{\n// left &lt;= right\n//\nreturn !(right.value &lt; left);\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator&lt;(const GreatestLowerBound&lt;T&gt;&amp; left, const GreatestLowerBound&lt;U&gt;&amp; right)\n{\nreturn left.value &lt; right.value;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const T&amp;, const GreatestLowerBound&lt;U&gt;&amp;)\n{\nreturn false;\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const GreatestLowerBound&lt;T&gt;&amp;, const U&amp;)\n{\nreturn false;\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const GreatestLowerBound&lt;T&gt;&amp; left, const GreatestLowerBound&lt;U&gt;&amp; right)\n{\nreturn left.value == right.value;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nBATT_TOTALLY_ORDERED((template &lt;typename T, typename U&gt; inline), T, GreatestLowerBound&lt;U&gt;)\nBATT_TOTALLY_ORDERED((template &lt;typename T, typename U&gt; inline), GreatestLowerBound&lt;T&gt;, U)\nBATT_TOTALLY_ORDERED((template &lt;typename T, typename U&gt; inline), GreatestLowerBound&lt;T&gt;, GreatestLowerBound&lt;U&gt;)\nBATT_EQUALITY_COMPARABLE((template &lt;typename T, typename U&gt; inline), T, GreatestLowerBound&lt;U&gt;)\nBATT_EQUALITY_COMPARABLE((template &lt;typename T, typename U&gt; inline), GreatestLowerBound&lt;T&gt;, U)\nBATT_EQUALITY_COMPARABLE((template &lt;typename T, typename U&gt; inline), GreatestLowerBound&lt;T&gt;,\nGreatestLowerBound&lt;U&gt;)\n}  // namespace batt\n#endif  // BATTERIES_BOUNDS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/boxed_8hpp/","title":"batteries/seq/boxed.hpp","text":""},{"location":"_autogen/Files/boxed_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/boxed_8hpp/#classes","title":"Classes","text":"Name class batt::BoxedSeq class batt::BoxedSeq::AbstractSeq class batt::BoxedSeq::SeqImpl struct batt::IsBoxedSeq struct batt::IsBoxedSeq&lt; BoxedSeq&lt; T &gt; &gt; struct batt::seq::BoxedBinder"},{"location":"_autogen/Files/boxed_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_BOXED_HPP"},{"location":"_autogen/Files/boxed_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/boxed_8hpp/#define-batteries_seq_boxed_hpp","title":"define BATTERIES_SEQ_BOXED_HPP","text":"<pre><code>#define BATTERIES_SEQ_BOXED_HPP()\n</code></pre>"},{"location":"_autogen/Files/boxed_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_BOXED_HPP\n#define BATTERIES_SEQ_BOXED_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/type_erasure.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nclass Status;\nenum struct StatusCode;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BoxedSeq&lt;ItemT&gt;\n//\ntemplate &lt;typename ItemT&gt;\nclass BoxedSeq\n{\npublic:\nclass AbstractSeq;\ntemplate &lt;typename T&gt;\nclass SeqImpl;\nusing storage_type = TypeErasedStorage&lt;AbstractSeq, SeqImpl&gt;;\nclass AbstractSeq : public AbstractValue&lt;AbstractSeq&gt;\n{\npublic:\nAbstractSeq() = default;\nAbstractSeq(const AbstractSeq&amp;) = delete;\nAbstractSeq&amp; operator=(const AbstractSeq&amp;) = delete;\nvirtual ~AbstractSeq() = default;\nvirtual Optional&lt;ItemT&gt; peek() = 0;\nvirtual Optional&lt;ItemT&gt; next() = 0;\n};\ntemplate &lt;typename T&gt;\nclass SeqImpl : public AbstractValueImpl&lt;AbstractSeq, SeqImpl, T&gt;\n{\npublic:\nusing Super = AbstractValueImpl&lt;AbstractSeq, SeqImpl, T&gt;;\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;T&gt;, T&gt;, \"BoxedSeq&lt;T&amp;&gt; is not supported\");\nexplicit SeqImpl(T&amp;&amp; seq) noexcept : Super{BATT_FORWARD(seq)}\n{\n}\nOptional&lt;ItemT&gt; peek() override\n{\nreturn this-&gt;obj_.peek();\n}\nOptional&lt;ItemT&gt; next() override\n{\nreturn this-&gt;obj_.next();\n}\n};\nusing Item = ItemT;\nBoxedSeq() = default;\ntemplate &lt;typename T,                                  //\ntypename = EnableIfNoShadow&lt;BoxedSeq, T&amp;&amp;&gt;,  //\ntypename = EnableIfSeq&lt;T&gt;,                   //\ntypename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;T&gt;, Status&gt; &amp;&amp;\n!std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusCode&gt;&gt;&gt;\nexplicit BoxedSeq(T&amp;&amp; seq) : storage_{StaticType&lt;T&gt;{}, BATT_FORWARD(seq)}\n{\nstatic_assert(std::is_same&lt;T, std::decay_t&lt;T&gt;&gt;{}, \"BoxedSeq may not be used to capture a reference\");\n}\ntemplate &lt;typename U, typename = std::enable_if_t&lt;!std::is_same_v&lt;ItemT, U&gt;&gt;&gt;\nBoxedSeq(const BoxedSeq&lt;U&gt;&amp; other_seq) = delete;\ntemplate &lt;typename U, typename = std::enable_if_t&lt;!std::is_same_v&lt;ItemT, U&gt;&gt;&gt;\nBoxedSeq(BoxedSeq&lt;U&gt;&amp;&amp; other_seq) = delete;\n// Copyable.\n//\nBoxedSeq(BoxedSeq&amp;&amp;) = default;\nBoxedSeq(const BoxedSeq&amp; that) = default;\nBoxedSeq&amp; operator=(BoxedSeq&amp;&amp;) = default;\nBoxedSeq&amp; operator=(const BoxedSeq&amp; that) = default;\nbool is_valid() const\n{\nreturn this-&gt;storage_.is_valid();\n}\nexplicit operator bool() const\n{\nreturn this-&gt;is_valid();\n}\nOptional&lt;Item&gt; peek()\n{\nreturn this-&gt;storage_-&gt;peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn this-&gt;storage_-&gt;next();\n}\nprivate:\nstorage_type storage_;\n};\ntemplate &lt;typename T&gt;\nstruct IsBoxedSeq : std::false_type {\n};\ntemplate &lt;typename T&gt;\nstruct IsBoxedSeq&lt;BoxedSeq&lt;T&gt;&gt; : std::true_type {\n};\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// boxed\n//\nstruct BoxedBinder {\n};\ninline BoxedBinder boxed()\n{\nreturn {};\n}\ntemplate &lt;\ntypename Seq, typename = EnableIfSeq&lt;Seq&gt;,\ntypename Item = typename std::conditional_t&lt;has_seq_requirements&lt;Seq&gt;(),  //\n/*then*/ SeqItem_Impl&lt;Seq&gt;, /*else*/ StaticType&lt;void&gt;&gt;::type&gt;\n[[nodiscard]] inline BoxedSeq&lt;Item&gt; operator|(Seq&amp;&amp; seq, BoxedBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"Boxed sequences may not be captured implicitly by reference.\");\nreturn BoxedSeq&lt;Item&gt;{BATT_FORWARD(seq)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_BOXED_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/buffer_8hpp/","title":"batteries/buffer.hpp","text":""},{"location":"_autogen/Files/buffer_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/buffer_8hpp/#classes","title":"Classes","text":"Name class batt::ManagedBuffer class batt::BufferViewImpl class batt::ConstBufferView class batt::MutableBufferView"},{"location":"_autogen/Files/buffer_8hpp/#defines","title":"Defines","text":"Name BATTERIES_BUFFER_HPP"},{"location":"_autogen/Files/buffer_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/buffer_8hpp/#define-batteries_buffer_hpp","title":"define BATTERIES_BUFFER_HPP","text":"<pre><code>#define BATTERIES_BUFFER_HPP()\n</code></pre>"},{"location":"_autogen/Files/buffer_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_BUFFER_HPP\n#define BATTERIES_BUFFER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/interval.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/asio/buffer.hpp&gt;\n#include &lt;array&gt;\n#include &lt;string_view&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nusing ConstBuffer = boost::asio::const_buffer;\nusing MutableBuffer = boost::asio::mutable_buffer;\ntemplate &lt;typename... Args&gt;\ndecltype(auto) make_buffer(Args&amp;&amp;... args)\n{\nreturn boost::asio::buffer(BATT_FORWARD(args)...);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\ninline ConstBuffer buffer_from_struct(const T&amp; val)\n{\nreturn ConstBuffer{&amp;val, sizeof(T)};\n}\ninline std::string_view as_str(const ConstBuffer&amp; buffer)\n{\nreturn std::string_view{static_cast&lt;const char*&gt;(buffer.data()), buffer.size()};\n}\ntemplate &lt;typename T&gt;\ninline std::string_view bytes_from_struct(const T&amp; val)\n{\nreturn as_str(buffer_from_struct(val));\n}\ntemplate &lt;typename T&gt;\ninline MutableBuffer mutable_buffer_from_struct(T&amp; val)\n{\nreturn MutableBuffer{&amp;val, sizeof(T)};\n}\ninline ConstBuffer resize_buffer(const ConstBuffer&amp; b, usize s)\n{\nreturn ConstBuffer{b.data(), std::min(s, b.size())};\n}\ninline MutableBuffer resize_buffer(const MutableBuffer&amp; b, usize s)\n{\nreturn MutableBuffer{b.data(), std::min(s, b.size())};\n}\nnamespace detail {\ntemplate &lt;typename BufferT, typename SizeT&gt;\ninline BufferT slice_buffer_impl(const BufferT&amp; buffer, const Interval&lt;SizeT&gt;&amp; slice)\n{\nusing ByteT = std::conditional_t&lt;std::is_same_v&lt;BufferT, ConstBuffer&gt;, const u8, u8&gt;;\nByteT* const bytes = static_cast&lt;ByteT*&gt;(buffer.data());\nconst SizeT begin_i = std::clamp&lt;SizeT&gt;(slice.lower_bound, 0, static_cast&lt;SizeT&gt;(buffer.size()));\nconst SizeT end_i = std::clamp&lt;SizeT&gt;(slice.upper_bound, 0, static_cast&lt;SizeT&gt;(buffer.size()));\nByteT* const first = bytes + begin_i;\nByteT* const last = bytes + end_i;\nif (first &lt; last) {\nreturn BufferT{first, BATT_CHECKED_CAST(usize, last - first)};\n}\nreturn BufferT{first, 0};\n}\n}  // namespace detail\ntemplate &lt;typename SizeT&gt;\ninline ConstBuffer slice_buffer(const ConstBuffer&amp; b, const Interval&lt;SizeT&gt;&amp; slice)\n{\nreturn detail::slice_buffer_impl&lt;ConstBuffer&gt;(b, slice);\n}\ntemplate &lt;typename SizeT&gt;\ninline MutableBuffer slice_buffer(const MutableBuffer&amp; b, const Interval&lt;SizeT&gt;&amp; slice)\n{\nreturn detail::slice_buffer_impl&lt;MutableBuffer&gt;(b, slice);\n}\ntemplate &lt;typename VecT&gt;\ninline void consume_buffers(VecT&amp; buffers, usize count)\n{\nwhile (count &gt; 0) {\nBATT_CHECK(!buffers.empty());\nif (buffers.front().size() &gt; count) {\nbuffers.front() += count;\nbreak;\n}\ncount -= buffers.front().size();\nbuffers.erase(buffers.begin());\n}\n}\ntemplate &lt;typename Iter&gt;\ninline std::pair&lt;Iter, usize /*offset*/&gt; consume_buffers_iter(const std::pair&lt;Iter, usize /*offset*/&gt;&amp; pos,\nconst Iter&amp; last, usize count)\n{\nIter first = pos.first;\nusize offset = pos.second;\nwhile (count &gt; 0 &amp;&amp; first != last) {\nConstBuffer front{*first};\nfront += offset;\noffset = 0;\nif (front.size() &gt; count) {\nreturn std::make_pair(first, count);\n}\ncount -= front.size();\n++first;\n}\nreturn std::make_pair(first, 0);\n}\ntemplate &lt;typename VecT&gt;\ninline VecT consume_buffers_copy(const VecT&amp; buffers, usize count)\n{\nVecT copy = buffers;\nconsume_buffers(copy, count);\nreturn copy;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nclass MutableBufferView;\nclass ConstBufferView;\nclass ManagedBuffer : public RefCounted&lt;ManagedBuffer&gt;\n{\npublic:\nstatic constexpr usize kCapacity = 4096;\nchar* data()\n{\nreturn this-&gt;storage_.data();\n}\nconst char* data() const\n{\nreturn this-&gt;storage_.data();\n}\nusize size() const\n{\nreturn this-&gt;storage_.size();\n}\nprivate:\nstd::array&lt;char, ManagedBuffer::kCapacity&gt; storage_;\n};\nclass BufferViewImpl\n{\npublic:\nusing Self = BufferViewImpl;\nexplicit BufferViewImpl(SharedPtr&lt;ManagedBuffer&gt;&amp;&amp; buffer, usize offset = 0) noexcept\n: buffer_{std::move(buffer)}\n, offset_{offset}\n, length_{this-&gt;buffer_-&gt;size() - this-&gt;offset_}\n{\n}\nexplicit BufferViewImpl(SharedPtr&lt;ManagedBuffer&gt;&amp;&amp; buffer, usize offset, usize length) noexcept\n: buffer_{std::move(buffer)}\n, offset_{offset}\n, length_{length}\n{\n}\nvoid* data() const\n{\nreturn this-&gt;buffer_-&gt;data() + this-&gt;offset_;\n}\nusize size() const\n{\nreturn this-&gt;length_;\n}\nSelf&amp; operator+=(usize delta)\n{\ndelta = std::min(delta, this-&gt;length_);\nthis-&gt;offset_ += delta;\nthis-&gt;length_ -= delta;\nreturn *this;\n}\nbool append(Self&amp;&amp; next)\n{\nif (this-&gt;buffer_ == next.buffer_ &amp;&amp; this-&gt;offset_ + this-&gt;length_ == next.offset_) {\nthis-&gt;length_ += next.length_;\nreturn true;\n}\nreturn false;\n}\nprivate:\nSharedPtr&lt;ManagedBuffer&gt; buffer_;\nusize offset_;\nusize length_;\n};\nclass ConstBufferView\n{\npublic:\nfriend class MutableBufferView;\nConstBufferView(const ConstBufferView&amp;) = default;\nConstBufferView&amp; operator=(const ConstBufferView&amp;) = default;\nexplicit ConstBufferView(SharedPtr&lt;ManagedBuffer&gt;&amp;&amp; buffer, usize offset = 0) noexcept\n: impl_{std::move(buffer), offset}\n{\n}\nexplicit ConstBufferView(SharedPtr&lt;ManagedBuffer&gt;&amp;&amp; buffer, usize offset, usize length) noexcept\n: impl_{std::move(buffer), offset, length}\n{\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nConstBufferView(const MutableBufferView&amp; other) noexcept;\nConstBufferView(MutableBufferView&amp;&amp; other) noexcept;\nConstBufferView&amp; operator=(const MutableBufferView&amp; other);\nConstBufferView&amp; operator=(MutableBufferView&amp;&amp; other);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\noperator ConstBuffer() const\n{\nreturn ConstBuffer{this-&gt;data(), this-&gt;size()};\n}\nConstBufferView&amp; operator+=(usize delta)\n{\nthis-&gt;impl_ += delta;\nreturn *this;\n}\nconst void* data() const\n{\nreturn this-&gt;impl_.data();\n}\nusize size() const\n{\nreturn this-&gt;impl_.size();\n}\nbool append(ConstBufferView&amp;&amp; next)\n{\nreturn this-&gt;impl_.append(std::move(next.impl_));\n}\nbool append(MutableBufferView&amp;&amp; next);\nprivate:\nBufferViewImpl impl_;\n};\nclass MutableBufferView\n{\npublic:\nfriend class ConstBufferView;\nMutableBufferView(const MutableBufferView&amp;) = default;\nMutableBufferView&amp; operator=(const MutableBufferView&amp;) = default;\nexplicit MutableBufferView(SharedPtr&lt;ManagedBuffer&gt;&amp;&amp; buffer, usize offset = 0) noexcept\n: impl_{std::move(buffer), offset}\n{\n}\nexplicit MutableBufferView(SharedPtr&lt;ManagedBuffer&gt;&amp;&amp; buffer, usize offset, usize length) noexcept\n: impl_{std::move(buffer), offset, length}\n{\n}\noperator MutableBuffer() const\n{\nreturn MutableBuffer{this-&gt;data(), this-&gt;size()};\n}\noperator ConstBuffer() const\n{\nreturn ConstBuffer{this-&gt;data(), this-&gt;size()};\n}\nMutableBufferView&amp; operator+=(usize delta)\n{\nthis-&gt;impl_ += delta;\nreturn *this;\n}\nvoid* data() const\n{\nreturn this-&gt;impl_.data();\n}\nusize size() const\n{\nreturn this-&gt;impl_.size();\n}\nbool append(ConstBufferView&amp;&amp; next)\n{\nreturn this-&gt;impl_.append(std::move(next.impl_));\n}\nbool append(MutableBufferView&amp;&amp; next)\n{\nreturn this-&gt;impl_.append(std::move(next.impl_));\n}\nprivate:\nBufferViewImpl impl_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline ConstBufferView::ConstBufferView(const MutableBufferView&amp; other) noexcept : impl_{other.impl_}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline ConstBufferView::ConstBufferView(MutableBufferView&amp;&amp; other) noexcept : impl_{std::move(other.impl_)}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline ConstBufferView&amp; ConstBufferView::operator=(const MutableBufferView&amp; other)\n{\nthis-&gt;impl_ = other.impl_;\nreturn *this;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline ConstBufferView&amp; ConstBufferView::operator=(MutableBufferView&amp;&amp; other)\n{\nthis-&gt;impl_ = std::move(other.impl_);\nreturn *this;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline bool ConstBufferView::append(MutableBufferView&amp;&amp; next)\n{\nreturn this-&gt;impl_.append(std::move(next.impl_));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;usize kLength, usize... kIndex&gt;\nconstexpr std::array&lt;char, kLength - 1&gt; array_from_c_str(const char (&amp;c_str)[kLength],\nstd::index_sequence&lt;kIndex...&gt;)\n{\nreturn {{c_str[kIndex]...}};\n}\ntemplate &lt;usize kLength&gt;\nconstexpr std::array&lt;char, kLength - 1&gt; array_from_c_str(const char (&amp;c_str)[kLength])\n{\nreturn array_from_c_str(c_str, std::make_index_sequence&lt;kLength - 1&gt;());\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ninline ConstBuffer as_const_buffer(const ConstBuffer&amp; buffer)\n{\nreturn buffer;\n}\ninline ConstBuffer as_const_buffer(const MutableBuffer&amp; buffer)\n{\nreturn buffer;\n}\ninline ConstBuffer as_const_buffer(const std::string_view&amp; str)\n{\nreturn ConstBuffer{str.data(), str.size()};\n}\ninline ConstBuffer as_const_buffer(const std::string&amp; str)\n{\nreturn ConstBuffer{str.data(), str.size()};\n}\ntemplate &lt;usize kSize&gt;\ninline ConstBuffer as_const_buffer(const std::array&lt;char, kSize&gt;&amp; arr)\n{\nreturn ConstBuffer{arr.data(), arr.size()};\n}\ntemplate &lt;usize kSize&gt;\ninline ConstBuffer as_const_buffer(const std::array&lt;u8, kSize&gt;&amp; arr)\n{\nreturn ConstBuffer{arr.data(), arr.size()};\n}\ninline ConstBuffer as_const_buffer(const std::vector&lt;char&gt;&amp; vec)\n{\nreturn ConstBuffer{vec.data(), vec.size()};\n}\ninline ConstBuffer as_const_buffer(const std::vector&lt;u8&gt;&amp; vec)\n{\nreturn ConstBuffer{vec.data(), vec.size()};\n}\ninline ConstBuffer as_const_buffer(const SmallVecBase&lt;char&gt;&amp; vec)\n{\nreturn ConstBuffer{vec.data(), vec.size()};\n}\ninline ConstBuffer as_const_buffer(const SmallVecBase&lt;u8&gt;&amp; vec)\n{\nreturn ConstBuffer{vec.data(), vec.size()};\n}\ntemplate &lt;usize kLength&gt;\ninline ConstBuffer as_const_buffer(const char (&amp;c_str)[kLength])\n{\nreturn ConstBuffer{&amp;c_str, kLength - 1};\n}\n}  // namespace batt\n#endif  // BATTERIES_BUFFER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/buffer__source_8cpp/","title":"batteries/async/buffer_source.cpp","text":""},{"location":"_autogen/Files/buffer__source_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/buffer_source.hpp&gt;\n//\n#include &lt;batteries/async/buffer_source_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/buffer__source_8hpp/","title":"batteries/async/buffer_source.hpp","text":""},{"location":"_autogen/Files/buffer__source_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail batt::seq"},{"location":"_autogen/Files/buffer__source_8hpp/#classes","title":"Classes","text":"Name class batt::SingleBufferSource Adapts a single ConstBuffer to be a BufferSource. class batt::BufferSource class batt::SeqBufferSource class batt::TakeNSource class batt::FilterBufferSource class batt::MapBufferSource struct batt::seq::WriteToBinder class batt::PrependBufferSource"},{"location":"_autogen/Files/buffer__source_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_BUFFER_SOURCE_HPP"},{"location":"_autogen/Files/buffer__source_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/buffer__source_8hpp/#define-batteries_async_buffer_source_hpp","title":"define BATTERIES_ASYNC_BUFFER_SOURCE_HPP","text":"<pre><code>#define BATTERIES_ASYNC_BUFFER_SOURCE_HPP()\n</code></pre>"},{"location":"_autogen/Files/buffer__source_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BUFFER_SOURCE_HPP\n#define BATTERIES_ASYNC_BUFFER_SOURCE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/task_decl.hpp&gt;\n#include &lt;batteries/seq/collect_vec.hpp&gt;\n#include &lt;batteries/seq/consume.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/prepend.hpp&gt;\n#include &lt;batteries/seq/print_out.hpp&gt;\n#include &lt;batteries/seq/skip_n.hpp&gt;\n#include &lt;batteries/seq/take_n.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/type_erasure.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/asio/buffer.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nnamespace detail {\ntemplate &lt;typename T&gt;\ninline std::false_type has_const_buffer_sequence_requirements_impl(...)\n{\nreturn {};\n}\ntemplate &lt;typename T,\ntypename ElementT = decltype(*boost::asio::buffer_sequence_begin(std::declval&lt;T&gt;())),  //\ntypename = std::enable_if_t&lt;                                                           //\nstd::is_same_v&lt;decltype(boost::asio::buffer_sequence_begin(std::declval&lt;T&gt;())),    //\ndecltype(boost::asio::buffer_sequence_end(std::declval&lt;T&gt;()))&gt; &amp;&amp;   //\nstd::is_convertible_v&lt;ElementT, boost::asio::const_buffer&gt;&gt;&gt;\ninline std::true_type has_const_buffer_sequence_requirements_impl(std::decay_t&lt;T&gt;*)\n{\nreturn {};\n}\n}  // namespace detail\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nusing HasConstBufferSequenceRequirements =\ndecltype(detail::has_const_buffer_sequence_requirements_impl&lt;T&gt;(nullptr));\ntemplate &lt;typename T&gt;\ninline constexpr bool has_const_buffer_sequence_requirements(StaticType&lt;T&gt; = {})\n{\nreturn HasConstBufferSequenceRequirements&lt;T&gt;{};\n}\ntemplate &lt;typename T&gt;\nusing EnableIfConstBufferSequence = std::enable_if_t&lt;has_const_buffer_sequence_requirements&lt;T&gt;()&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nnamespace detail {\ntemplate &lt;typename T&gt;\ninline std::false_type has_buffer_source_requirements_impl(...)\n{\nreturn {};\n}\ntemplate &lt;typename T,\ntypename = std::enable_if_t&lt;                                                           //\nstd::is_same_v&lt;decltype(std::declval&lt;T&gt;().size()), usize&gt; &amp;&amp;                       //\nstd::is_same_v&lt;decltype(std::declval&lt;T&gt;().consume(std::declval&lt;i64&gt;())), void&gt; &amp;&amp;  //\nstd::is_same_v&lt;decltype(std::declval&lt;T&gt;().close_for_read()), void&gt; &amp;&amp;\nHasConstBufferSequenceRequirements&lt;\ndecltype(*(std::declval&lt;T&gt;().fetch_at_least(std::declval&lt;i64&gt;())))&gt;{}&gt;&gt;\ninline std::true_type has_buffer_source_requirements_impl(std::decay_t&lt;T&gt;*)\n{\nreturn {};\n}\n}  // namespace detail\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nusing HasBufferSourceRequirements = decltype(detail::has_buffer_source_requirements_impl&lt;T&gt;(nullptr));\ntemplate &lt;typename T&gt;\ninline constexpr bool has_buffer_source_requirements(StaticType&lt;T&gt; = {})\n{\nreturn HasBufferSourceRequirements&lt;T&gt;{};\n}\ntemplate &lt;typename T&gt;\nusing EnableIfBufferSource = std::enable_if_t&lt;has_buffer_source_requirements&lt;T&gt;()&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nclass SingleBufferSource\n{\npublic:\nSingleBufferSource() = default;\nSingleBufferSource(const SingleBufferSource&amp;) = default;\nSingleBufferSource&amp; operator=(const SingleBufferSource&amp;) = default;\nexplicit SingleBufferSource(const ConstBuffer&amp; buffer) noexcept : buffer_{buffer}\n{\n}\nexplicit SingleBufferSource(const void* ptr, usize size) noexcept : buffer_{ptr, size}\n{\n}\nexplicit SingleBufferSource(const std::string_view&amp; str) noexcept : buffer_{str.data(), str.size()}\n{\n}\nSingleBufferSource&amp; operator=(const ConstBuffer&amp; buffer) noexcept\n{\nthis-&gt;buffer_ = buffer;\nreturn *this;\n}\nSingleBufferSource&amp; operator=(const std::string_view&amp; str) noexcept\n{\nthis-&gt;buffer_ = ConstBuffer{str.data(), str.size()};\nreturn *this;\n}\nusize size() const\n{\nreturn this-&gt;buffer_.size();\n}\nStatusOr&lt;SmallVec&lt;ConstBuffer, 1&gt;&gt; fetch_at_least(i64 min_count)\n{\nif (min_count &gt; static_cast&lt;i64&gt;(this-&gt;buffer_.size())) {\nreturn {StatusCode::kEndOfStream};\n}\nif (this-&gt;buffer_.size() == 0u) {\nreturn {SmallVec&lt;ConstBuffer, 1&gt;{}};\n}\nreturn {{this-&gt;buffer_}};\n}\nvoid consume(i64 count)\n{\nBATT_CHECK_GE(count, 0);\nthis-&gt;buffer_ += count;\n}\nvoid close_for_read()\n{\nthis-&gt;buffer_ = {};\n}\nprivate:\nConstBuffer buffer_;\n};\nstatic_assert(has_buffer_source_requirements&lt;SingleBufferSource&gt;());\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// A type-erased no-copy input stream.\n//\n// Instead of a traditional (copying) input stream, which copies data into caller-supplied buffers,\n// BufferSource provides the `fetch_at_least` operation, which returns one or more pre-populated data buffers\n// owned by the BufferSource.  The caller is guaranteed that these buffers remain valid until the next\n// non-const member function is invoked on the BufferSource.\n//\n// To make dealing with byte streams easier, BufferSource values can be modified/transformed via a select\n// subset of `batt::seq` operators:\n//\n// - seq::take_n(byte_count)\n// - seq::skip_n(byte_count)\n// - seq::prepend(const_buffer_sequence)\n// - seq::for_each(fn) (fn takes ConstBuffer)\n// - seq::collect_vec() =&gt; std::vector&lt;char&gt;\n// - seq::print_out(std::ostream)\n// - seq::consume()\n//\n// In addition, a new operator is defined for BufferSource, seq::write_to(AsyncWriteStream):\n//\n// ```c++\n// batt::BufferSource data_to_send;\n// boost::asio::ip::tcp::socket dst_stream;\n//\n// // Write all the data to the stream.\n// //\n// StatusOr&lt;usize&gt; result = data_to_send | batt::seq::write_to(dst_stream);\n// ```\n//\nclass BufferSource\n{\npublic:\nBufferSource() = default;\ntemplate &lt;typename T, typename = EnableIfNoShadow&lt;BufferSource, T&amp;&amp;&gt;,\ntypename = EnableIfBufferSource&lt;UnwrapRefType&lt;T&gt;&gt;,\ntypename = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, T&gt;&gt;&gt;\n/*implicit*/ BufferSource(T&amp;&amp; obj) noexcept;\nexplicit BufferSource(const ConstBuffer&amp; buffer) noexcept : BufferSource{SingleBufferSource{buffer}}\n{\n}\nexplicit BufferSource(const void* ptr, usize size) noexcept : BufferSource{SingleBufferSource{ptr, size}}\n{\n}\nexplicit BufferSource(const std::string_view&amp; str) noexcept : BufferSource{SingleBufferSource{str}}\n{\n}\n// Returns true iff this object contains a valid BufferSource impl.\n//\nexplicit operator bool() const;\n// Release the type-erased impl object; post-condition: `bool{*this} == false`.\n//\nvoid clear();\n// The current number of bytes available as consumable data.  This should be used as an optimization hint\n// only; the next call to `fetch_*` may return more bytes than the last returned value of size.\n// Specifically, callers should not count on `size()` returning 0 being an indication that the next call\n// to `fetch_at_least` will block.\n//\nusize size() const;\n// Returns a ConstBufferSequence containing at least `min_count` bytes of data.\n//\n// This method may block the current task if there isn't enough data available to satisfy\n// the request (i.e., if `this-&gt;size() &lt; min_count`).\n//\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; fetch_at_least(i64 min_count);\n// Consume the specified number of bytes from the front of the stream so that future calls to\n// `fetch_at_least` will not return the same data.\n//\nvoid consume(i64 count);\n// Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods).  This\n// signals to the buffer (and all other clients of this object) that no more data will be read/consumed.\n//\nvoid close_for_read();\nprivate:\nclass AbstractBufferSource;\ntemplate &lt;typename T&gt;\nclass BufferSourceImpl;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nTypeErasedStorage&lt;AbstractBufferSource, BufferSourceImpl&gt; impl_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Adapts a Seq of Item = ConstBuffer to a BufferSource impl, allowing it to be wrapped via the BufferSource\n// class.\n//\ntemplate &lt;typename Seq&gt;\nclass SeqBufferSource\n{\npublic:\nusing Item = ConstBuffer;\nstatic_assert(std::is_convertible_v&lt;SeqItem&lt;Seq&gt;, ConstBuffer&gt;, \"\");\nusize size() const\n{\nreturn boost::asio::buffer_size(this-&gt;active_buffers_);\n}\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; fetch_at_least(i64 min_count)\n{\nusize active_size = boost::asio::buffer_size(this-&gt;active_buffers_);\nwhile (active_size &lt; min_count) {\nOptional&lt;ConstBuffer&gt; next_buffer = this-&gt;seq_.next();\nif (next_buffer == None) {\nreturn {StatusCode::kEndOfStream};\n}\nactive_size += next_buffer-&gt;size();\nthis-&gt;active_buffers_.emplace_back(std::move(*next_buffer));\n}\nreturn this-&gt;active_buffers_;\n}\nvoid consume(i64 count)\n{\nconsume_buffers(this-&gt;active_buffers_, count);\n}\nvoid close_for_read()\n{\nwhile (this-&gt;seq_.next()) {\ncontinue;\n}\nthis-&gt;active_buffers_.clear();\n}\nprivate:\nSeq seq_;\nSmallVec&lt;ConstBuffer, 2&gt; active_buffers_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::take_n(byte_count)\n//\ntemplate &lt;typename Src&gt;\nclass TakeNSource\n{\npublic:\nexplicit TakeNSource(Src&amp;&amp; src, usize limit) noexcept : limit_{limit}, src_{BATT_FORWARD(src)}\n{\n}\nusize size() const\n{\nreturn std::min(this-&gt;limit_, this-&gt;src_.size());\n}\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; fetch_at_least(i64 min_count)\n{\nBATT_ASSERT_GE(min_count, 0);\n// If we will be limited to an amount of data that is smaller than the requested minimum, just return\n// end-of-stream.\n//\nif (this-&gt;limit_ &lt; static_cast&lt;usize&gt;(min_count)) {\nreturn {StatusCode::kEndOfStream};\n}\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; buffers = this-&gt;src_.fetch_at_least(min_count);\nBATT_REQUIRE_OK(buffers);\nusize n_fetched = boost::asio::buffer_size(*buffers);\n// Trim data from the end of the fetched range until we are under our limit.\n//\nwhile (n_fetched &gt; this-&gt;limit_ &amp;&amp; !buffers-&gt;empty()) {\nConstBuffer&amp; last_buffer = buffers-&gt;back();\nconst usize extra_bytes = n_fetched - this-&gt;limit_;\nif (last_buffer.size() &lt;= extra_bytes) {\nn_fetched -= last_buffer.size();\nbuffers-&gt;pop_back();\n} else {\nn_fetched -= extra_bytes;\nlast_buffer = ConstBuffer{last_buffer.data(), last_buffer.size() - extra_bytes};\n}\n}\nreturn buffers;\n}\nvoid consume(i64 count)\n{\nconst usize n_to_consume = std::min(BATT_CHECKED_CAST(usize, count), this-&gt;limit_);\nthis-&gt;src_.consume(BATT_CHECKED_CAST(usize, n_to_consume));\nthis-&gt;limit_ -= n_to_consume;\n}\nvoid close_for_read()\n{\nthis-&gt;limit_ = 0;\n}\nprivate:\nusize limit_;\nSrc src_;\n};\ntemplate &lt;typename Src, typename = EnableIfBufferSource&lt;Src&gt;&gt;\nTakeNSource&lt;Src&gt; operator|(Src&amp;&amp; src, seq::TakeNBinder binder)\n{\nreturn TakeNSource&lt;Src&gt;{BATT_FORWARD(src), binder.n};\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::skip_n(byte_count)\n//\ntemplate &lt;typename Src, typename = EnableIfBufferSource&lt;Src&gt;&gt;\nvoid operator|(Src&amp;&amp; /*src*/, SkipNBinder /*binder*/)\n{\n// TODO [tastolfi 2022-03-23]\nBATT_PANIC() &lt;&lt; \"TODO [tastolfi 2022-03-28] implement me!\";\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::filter(StatusOr&lt;ConstBufferSequence&gt;(ConstBufferSequence))\n//\ntemplate &lt;typename Src, typename MapFn&gt;\nclass FilterBufferSource\n{\npublic:\n// TODO [tastolfi 2022-06-22]\nprivate:\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::map(void(BufferSource&amp; src, BufferSink&amp; dst))\n//\ntemplate &lt;typename Src, typename MapFn&gt;\nclass MapBufferSource\n{\npublic:\n// TODO [tastolfi 2022-06-22]\nprivate:\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::for_each()\n//\ntemplate &lt;typename Src, typename Fn, typename = EnableIfBufferSource&lt;Src&gt;&gt;\ninline StatusOr&lt;seq::LoopControl&gt; operator|(Src&amp;&amp; src, seq::ForEachBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nfor (;;) {\nauto fetched = src.fetch_at_least(1);\nif (fetched.status() == StatusCode::kEndOfStream) {\nbreak;\n}\nBATT_REQUIRE_OK(fetched);\nusize n_to_consume = 0;\nfor (const ConstBuffer&amp; buffer : *fetched) {\nn_to_consume += buffer.size();\nif (BATT_HINT_FALSE(seq::run_loop_fn(binder.fn, buffer) == seq::kBreak)) {\nreturn seq::kBreak;\n}\n}\nif (n_to_consume == 0) {\nbreak;\n}\nsrc.consume(n_to_consume);\n}\nreturn seq::kContinue;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::collect_vec()\n//\ntemplate &lt;typename Src, typename = EnableIfBufferSource&lt;Src&gt;&gt;\ninline StatusOr&lt;std::vector&lt;char&gt;&gt; operator|(Src&amp;&amp; src, seq::CollectVec)\n{\nstd::vector&lt;char&gt; bytes;\nStatusOr&lt;seq::LoopControl&gt; result =\nBATT_FORWARD(src) | seq::for_each([&amp;bytes](const ConstBuffer&amp; buffer) {\nconst char* data_begin = static_cast&lt;const char*&gt;(buffer.data());\nconst char* data_end = data_begin + buffer.size();\nbytes.insert(bytes.end(), data_begin, data_end);\n});\nBATT_REQUIRE_OK(result);\nreturn bytes;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::print_out(out)\n//\ntemplate &lt;typename Src, typename = EnableIfBufferSource&lt;Src&gt;&gt;\ninline Status operator|(Src&amp;&amp; src, seq::PrintOut p)\n{\nreturn (BATT_FORWARD(src) | seq::for_each([&amp;](const ConstBuffer&amp; buffer) {\np.out.write(static_cast&lt;const char*&gt;(buffer.data()), buffer.size());\n}))\n.status();\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::consume()\ntemplate &lt;typename Src, typename = EnableIfBufferSource&lt;Src&gt;&gt;\ninline Status operator|(Src&amp;&amp; src, seq::Consume)\n{\nStatusOr&lt;seq::LoopControl&gt; result = BATT_FORWARD(src) | seq::for_each([](auto&amp;&amp;...) noexcept {\n// nom, nom, nom...\n});\nBATT_REQUIRE_OK(result);\nBATT_CHECK_EQ(*result, seq::kContinue);\nreturn OkStatus();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nnamespace seq {\ntemplate &lt;typename AsyncWriteStream&gt;\nstruct WriteToBinder {\nAsyncWriteStream dst;\n};\ntemplate &lt;typename AsyncWriteStream&gt;\ninline auto write_to(AsyncWriteStream&amp;&amp; dst)\n{\nreturn WriteToBinder&lt;AsyncWriteStream&gt;{BATT_FORWARD(dst)};\n}\n}  // namespace seq\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::write_to(async_write_stream)\n//\ntemplate &lt;typename Src, typename AsyncWriteStream, typename = EnableIfBufferSource&lt;Src&gt;&gt;\nStatusOr&lt;usize&gt; operator|(Src&amp;&amp; src, seq::WriteToBinder&lt;AsyncWriteStream&gt;&amp;&amp; binder)\n{\nusize bytes_transferred = 0;\nfor (;;) {\nauto fetched = src.fetch_at_least(1);\nif (fetched.status() == StatusCode::kEndOfStream) {\nbreak;\n}\nBATT_REQUIRE_OK(fetched);\nIOResult&lt;usize&gt; bytes_written = Task::await_write_some(binder.dst, *fetched);\nBATT_REQUIRE_OK(bytes_written);\nbytes_transferred += *bytes_written;\nsrc.consume(*bytes_written);\n}\nreturn bytes_transferred;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BufferSource | seq::prepend(buffers)\n//\ntemplate &lt;typename Src, typename ConstBufferSequence&gt;\nclass PrependBufferSource\n{\npublic:\nusing BufferIter =\nstd::decay_t&lt;decltype(boost::asio::buffer_sequence_begin(std::declval&lt;ConstBufferSequence&gt;()))&gt;;\nexplicit PrependBufferSource(ConstBufferSequence&amp;&amp; buffers, Src&amp;&amp; rest) noexcept\n: first_{BATT_FORWARD(buffers)}\n, first_buffer_index_{0}\n, first_buffer_offset_{0}\n, first_bytes_remaining_{boost::asio::buffer_size(this-&gt;first_)}\n, rest_{BATT_FORWARD(rest)}\n{\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;ConstBufferSequence&gt;, ConstBufferSequence&gt;,\n\"PrependBufferSource may not capture ConstBufferSequence reference types!\");\n}\nusize size() const\n{\nreturn this-&gt;first_bytes_remaining_ + this-&gt;rest_.size();\n}\nStatusOr&lt;SmallVec&lt;ConstBuffer, 3&gt;&gt; fetch_at_least(i64 min_count_i)\n{\nconst usize min_count_z = BATT_CHECKED_CAST(usize, min_count_i);\nSmallVec&lt;ConstBuffer, 3&gt; buffer;\nif (this-&gt;first_bytes_remaining_ &gt; 0) {\nconst auto first_begin = boost::asio::buffer_sequence_begin(this-&gt;first_);\nconst auto first_end = boost::asio::buffer_sequence_end(this-&gt;first_);\nconst auto first_iter = std::next(first_begin, this-&gt;first_buffer_index_);\nBATT_CHECK_NE(first_iter, first_end)\n&lt;&lt; \"If bytes_remaining &gt; 0, then the unread buffer sequence should be non-empty\";\nbuffer.insert(buffer.end(), first_iter, first_end);\nBATT_CHECK(!buffer.empty());\nbuffer.front() += this-&gt;first_buffer_offset_;\n}\nconst usize rest_min_count = min_count_z - std::min(this-&gt;first_bytes_remaining_, min_count_z);\nauto fetched_from_rest = this-&gt;rest_.fetch_at_least(rest_min_count);\nif (buffer.empty() || fetched_from_rest.status() != StatusCode::kEndOfStream) {\nBATT_REQUIRE_OK(fetched_from_rest);\n}\nif (fetched_from_rest.ok()) {\nbuffer.insert(buffer.end(),  //\nboost::asio::buffer_sequence_begin(*fetched_from_rest),\nboost::asio::buffer_sequence_end(*fetched_from_rest));\n}\nreturn buffer;\n}\nvoid consume(i64 count_i)\n{\nconst usize count_z = BATT_CHECKED_CAST(usize, count_i);\nconst usize consume_from_first = std::min(this-&gt;first_bytes_remaining_, count_z);\nconst usize consume_from_rest = count_z - consume_from_first;\nconst auto first_begin = boost::asio::buffer_sequence_begin(this-&gt;first_);\nconst auto first_end = boost::asio::buffer_sequence_end(this-&gt;first_);\nauto first_iter = std::next(first_begin, this-&gt;first_buffer_index_);\nstd::tie(first_iter, this-&gt;first_buffer_offset_) = consume_buffers_iter(\nstd::make_pair(first_iter, this-&gt;first_buffer_offset_), first_end, consume_from_first);\nthis-&gt;first_buffer_index_ = std::distance(first_begin, first_iter);\nthis-&gt;first_bytes_remaining_ -= consume_from_first;\nif (consume_from_rest &gt; 0) {\nthis-&gt;rest_.consume(consume_from_rest);\n}\n}\nvoid close_for_read()\n{\nthis-&gt;first_buffer_index_ = std::distance(boost::asio::buffer_sequence_begin(this-&gt;first_),\nboost::asio::buffer_sequence_end(this-&gt;first_));\nthis-&gt;first_buffer_offset_ = 0;\nthis-&gt;first_bytes_remaining_ = 0;\nthis-&gt;rest_.close_for_read();\n}\nprivate:\nConstBufferSequence first_;\n// How far into the buffer sequence `first_` is the first unread data?\n//\nusize first_buffer_index_;\n// How far within the current buffer the first unread data?\n//\nusize first_buffer_offset_;\n// How much data in `first` has not yet been consumed?\n//\nusize first_bytes_remaining_;\n// What follows `first_`.\n//\nSrc rest_;\n};\ntemplate &lt;typename Src, typename ConstBufferSequence,  //\ntypename = EnableIfBufferSource&lt;Src&gt;,        //\ntypename = EnableIfConstBufferSequence&lt;ConstBufferSequence&gt;&gt;\ninline auto operator|(Src&amp;&amp; src, seq::PrependBinder&lt;ConstBufferSequence&gt;&amp;&amp; binder)\n{\nreturn PrependBufferSource&lt;Src, ConstBufferSequence&gt;{BATT_FORWARD(binder.item), BATT_FORWARD(src)};\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_BUFFER_SOURCE_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/buffer_source.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/buffer_source_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/buffer__source__impl_8hpp/","title":"batteries/async/buffer_source_impl.hpp","text":""},{"location":"_autogen/Files/buffer__source__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/buffer__source__impl_8hpp/#define-batteries_async_buffer_source_impl_hpp","title":"define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/buffer__source__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP\n#define BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL BufferSource::operator bool() const\n{\nreturn bool{this-&gt;impl_};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize BufferSource::size() const\n{\nreturn this-&gt;impl_-&gt;size();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; BufferSource::fetch_at_least(i64 min_count)\n{\nreturn this-&gt;impl_-&gt;fetch_at_least(min_count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void BufferSource::consume(i64 count)\n{\nreturn this-&gt;impl_-&gt;consume(count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void BufferSource::close_for_read()\n{\nreturn this-&gt;impl_-&gt;close_for_read();\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_BUFFER_SOURCE_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/buffered__channel_8hpp/","title":"batteries/async/buffered_channel.hpp","text":""},{"location":"_autogen/Files/buffered__channel_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/buffered__channel_8hpp/#classes","title":"Classes","text":"Name class batt::BufferedChannel"},{"location":"_autogen/Files/buffered__channel_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_BUFFERED_CHANNEL_HPP"},{"location":"_autogen/Files/buffered__channel_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/buffered__channel_8hpp/#define-batteries_async_buffered_channel_hpp","title":"define BATTERIES_ASYNC_BUFFERED_CHANNEL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_BUFFERED_CHANNEL_HPP()\n</code></pre>"},{"location":"_autogen/Files/buffered__channel_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_BUFFERED_CHANNEL_HPP\n#define BATTERIES_ASYNC_BUFFERED_CHANNEL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/channel.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass BufferedChannel\n{\npublic:\nusing value_type = T;\nBufferedChannel() = default;\nBufferedChannel(const BufferedChannel&amp;) = delete;\nBufferedChannel&amp; operator=(const BufferedChannel&amp;) = delete;\n~BufferedChannel() noexcept = default;\nStatus get_last_status() const noexcept\n{\nreturn this-&gt;last_status_;\n}\nbool is_active() const\n{\nreturn this-&gt;channel_.is_active();\n}\nvoid await_inactive() noexcept\n{\nthis-&gt;channel_.await_inactive();\n}\ntemplate &lt;typename Handler = void(StatusOr&lt;T&amp;&gt;)&gt;\nvoid async_read(Handler&amp;&amp; handler)\n{\nthis-&gt;channel_.async_read(BATT_FORWARD(handler));\n}\nStatusOr&lt;T&amp;&gt; read()\n{\nreturn this-&gt;channel_.read();\n}\nvoid consume()\n{\nthis-&gt;channel_.consume();\n}\nvoid close_for_read()\n{\nthis-&gt;channel_.close_for_read();\n}\ntemplate &lt;typename... ArgsAndHandler&gt;\nvoid async_write(ArgsAndHandler&amp;&amp;... args_and_handler)\n{\nstatic_assert(sizeof...(ArgsAndHandler) &gt; 0, \"\");\n// Rotate the args one place to the right, to bring the handler to the front of the arg list.\n//\nrotate_args_right(\n[this](auto&amp;&amp; handler, auto&amp;&amp;... args) {\nthis-&gt;async_write_impl(BATT_FORWARD(handler), BATT_FORWARD(args)...);\n},\nBATT_FORWARD(args_and_handler)...);\n}\ntemplate &lt;typename... Args&gt;\nStatus write(Args&amp;&amp;... args)\n{\nthis-&gt;channel_.await_inactive();\nreturn this-&gt;write_assuming_inactive(BATT_FORWARD(args)...);\n}\nvoid close_for_write()\n{\nthis-&gt;channel_.close_for_write();\n}\nprivate:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename... Args&gt;\nStatus write_assuming_inactive(Args&amp;&amp;... args)\n{\nStatus local_status;\nstd::swap(this-&gt;last_status_, local_status);\nT&amp; value = this-&gt;buffer_.emplace(BATT_FORWARD(args)...);\nthis-&gt;channel_.async_write(value, [this](const Status&amp; status) {\nthis-&gt;last_status_ = status;\n});\nreturn local_status;\n}\ntemplate &lt;typename Handler, typename... Args&gt;\nvoid async_write_impl(Handler&amp;&amp; handler, Args&amp;&amp;... args)\n{\nthis-&gt;channel_.async_wait_inactive(\nbind_handler(BATT_FORWARD(handler),\n[this, args_tuple = std::make_tuple(BATT_FORWARD(args)...)](auto&amp;&amp; handler) mutable {\nStatus status = std::apply(\n[this](auto&amp;&amp;... args) {\nreturn this-&gt;write_assuming_inactive(BATT_FORWARD(args)...);\n},\nstd::move(args_tuple));\nBATT_FORWARD(handler)(status);\n}));\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nChannel&lt;T&gt; channel_;\nOptional&lt;T&gt; buffer_;\nStatus last_status_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_BUFFERED_CHANNEL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/cache__next_8hpp/","title":"batteries/seq/cache_next.hpp","text":""},{"location":"_autogen/Files/cache__next_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/cache__next_8hpp/#classes","title":"Classes","text":"Name class batt::seq::CacheNext struct batt::seq::CacheNextBinder"},{"location":"_autogen/Files/cache__next_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_CACHE_NEXT_HPP"},{"location":"_autogen/Files/cache__next_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/cache__next_8hpp/#define-batteries_seq_cache_next_hpp","title":"define BATTERIES_SEQ_CACHE_NEXT_HPP","text":"<pre><code>#define BATTERIES_SEQ_CACHE_NEXT_HPP()\n</code></pre>"},{"location":"_autogen/Files/cache__next_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_CACHE_NEXT_HPP\n#define BATTERIES_SEQ_CACHE_NEXT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// cache_next() - Adapts any sequence to cache the next item so that repeated\n// calls to peek will be fast.\n//\ntemplate &lt;typename Seq&gt;\nclass CacheNext\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit CacheNext(Seq&amp;&amp; seq) noexcept : seq_(BATT_FORWARD(seq))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (!cached_) {\ncached_ = seq_.next();\n}\nreturn *cached_;\n}\nOptional&lt;Item&gt; next()\n{\nOptional&lt;Item&gt; item = [&amp;] {\nif (cached_) {\nreturn std::move(*cached_);\n}\nreturn seq_.next();\n}();\ncached_ = None;\nreturn item;\n}\nprivate:\nSeq seq_;\nOptional&lt;Optional&lt;Item&gt;&gt; cached_;\n};\nstruct CacheNextBinder {\n};\ninline CacheNextBinder cache_next()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, CacheNextBinder)\n{\nreturn CacheNext&lt;Seq&gt;{BATT_FORWARD(seq)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_CACHE_NEXT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/cancel__token_8cpp/","title":"batteries/async/cancel_token.cpp","text":""},{"location":"_autogen/Files/cancel__token_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/cancel_token.hpp&gt;\n//\n#include &lt;batteries/async/cancel_token_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/cancel__token_8hpp/","title":"batteries/async/cancel_token.hpp","text":""},{"location":"_autogen/Files/cancel__token_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/cancel__token_8hpp/#classes","title":"Classes","text":"Name class batt::CancelToken Enables effective cancellation of arbitrary async operations. class batt::CancelToken::Impl class batt::CancelToken::HandlerImpl"},{"location":"_autogen/Files/cancel__token_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_CANCEL_TOKEN_HPP"},{"location":"_autogen/Files/cancel__token_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/cancel__token_8hpp/#define-batteries_async_cancel_token_hpp","title":"define BATTERIES_ASYNC_CANCEL_TOKEN_HPP","text":"<pre><code>#define BATTERIES_ASYNC_CANCEL_TOKEN_HPP()\n</code></pre>"},{"location":"_autogen/Files/cancel__token_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_CANCEL_TOKEN_HPP\n#define BATTERIES_ASYNC_CANCEL_TOKEN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;bitset&gt;\n#include &lt;functional&gt;\n#include &lt;ostream&gt;\nnamespace batt {\n// Forward-declarations.\n//\nclass CancelToken;\nusize hash_value(const CancelToken&amp; cancel_token);\nbool operator==(const CancelToken&amp; l, const CancelToken&amp; r);\nbool operator!=(const CancelToken&amp; l, const CancelToken&amp; r);\nbool operator&lt;(const CancelToken&amp; l, const CancelToken&amp; r);\nbool operator&gt;(const CancelToken&amp; l, const CancelToken&amp; r);\nbool operator&lt;=(const CancelToken&amp; l, const CancelToken&amp; r);\nbool operator&gt;=(const CancelToken&amp; l, const CancelToken&amp; r);\nclass CancelToken\n{\npublic:\nfriend usize hash_value(const CancelToken&amp; cancel_token);\nfriend bool operator==(const CancelToken&amp; l, const CancelToken&amp; r);\nfriend bool operator&lt;(const CancelToken&amp; l, const CancelToken&amp; r);\nfriend bool operator!=(const CancelToken&amp; l, const CancelToken&amp; r);\nfriend bool operator&gt;(const CancelToken&amp; l, const CancelToken&amp; r);\nfriend bool operator&lt;=(const CancelToken&amp; l, const CancelToken&amp; r);\nfriend bool operator&gt;=(const CancelToken&amp; l, const CancelToken&amp; r);\nstatic constexpr u32 kIdle = 0;\nstatic constexpr u32 kActiveHandler = 1;\nstatic constexpr u32 kResolving = 2;\nstatic constexpr u32 kCompleted = 4;\nstatic constexpr u32 kCancelled = 8;\nstatic constexpr bool is_idle_state(u32 value)\n{\nreturn (value &amp; (kActiveHandler | kResolving | kCompleted)) == 0;\n}\nstatic constexpr bool is_cancelled_state(u32 value)\n{\nreturn (value &amp; kCancelled) != 0;\n}\nstatic constexpr bool is_completed_state(u32 value)\n{\nreturn (value &amp; kCompleted) != 0;\n}\nstatic constexpr bool is_resolved_state(u32 value)\n{\nreturn (value &amp; (kCompleted | kCancelled)) != 0;\n}\n//----- --- -- -  -  -   -\nclass Impl : public batt::RefCounted&lt;Impl&gt;\n{\npublic:\nbool is_cancelled() const noexcept\n{\nreturn (this-&gt;state_.get_value() &amp; kCancelled) == kCancelled;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nbatt::HandlerMemory&lt;2 * kCpuCacheLineSize - sizeof(batt::Watch&lt;u32&gt;)&gt; memory_;\nbatt::Watch&lt;u32&gt; state_{kIdle};\n};\n//----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nclass HandlerImpl\n{\npublic:\nexplicit HandlerImpl(batt::SharedPtr&lt;Impl&gt;&amp;&amp; impl, batt::Optional&lt;T&gt;&amp; result) noexcept;\nHandlerImpl(const HandlerImpl&amp;) = default;\nHandlerImpl&amp; operator=(const HandlerImpl&amp;) = default;\ntemplate &lt;typename... Args&gt;\nvoid operator()(Args&amp;&amp;... args) const noexcept;\nbool is_cancelled() const noexcept\n{\nreturn this-&gt;impl_-&gt;is_cancelled();\n}\nprivate:\nbatt::SharedPtr&lt;Impl&gt; impl_;\nbatt::Optional&lt;T&gt;* result_;\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic const CancelToken&amp; none() noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n/*implicit*/ CancelToken(NoneType) noexcept;\nCancelToken() = default;\nCancelToken(const CancelToken&amp;) = default;\nCancelToken&amp; operator=(const CancelToken&amp;) = default;\nCancelToken&amp; operator=(const NoneType&amp;) noexcept;\n//----- --- -- -  -  -   -\ntemplate &lt;typename T, typename Fn&gt;\nbatt::StatusOr&lt;T&gt; await(Fn&amp;&amp; fn) const noexcept;\ntemplate &lt;typename Fn&gt;\nbatt::Status await(Fn&amp;&amp; fn) const noexcept\n{\nreturn this-&gt;await&lt;batt::Status&gt;(BATT_FORWARD(fn));\n}\nvoid cancel() const noexcept;\nbool is_valid() const noexcept;\nbool is_cancelled() const noexcept;\nexplicit operator bool() const noexcept;\nSmallFn&lt;void(std::ostream&amp;)&gt; debug_info() const noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\ntemplate &lt;typename T&gt;\nauto make_handler(batt::Optional&lt;T&gt;&amp; result) const noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nbatt::SharedPtr&lt;Impl&gt; impl_{new Impl};\n};\ntemplate &lt;typename T&gt;\ninline bool is_cancelled(const CancelToken::HandlerImpl&lt;T&gt;&amp; handler)\n{\nreturn handler.is_cancelled();\n}\ntemplate &lt;typename T&gt;\ninline bool is_cancelled(const CustomAllocHandler&lt;CancelToken::HandlerImpl&lt;T&gt;&gt;&amp; handler)\n{\nreturn is_cancelled(handler.get_handler());\n}\ninline usize hash_value(const CancelToken&amp; cancel_token)\n{\nreturn std::hash&lt;void*&gt;{}(cancel_token.impl_.get());\n}\ninline bool operator==(const CancelToken&amp; l, const CancelToken&amp; r)\n{\nreturn l.impl_ == r.impl_;\n}\ninline bool operator!=(const CancelToken&amp; l, const CancelToken&amp; r)\n{\nreturn !(l == r);\n}\ninline bool operator&lt;(const CancelToken&amp; l, const CancelToken&amp; r)\n{\nreturn l.impl_ &lt; r.impl_;\n}\ninline bool operator&gt;(const CancelToken&amp; l, const CancelToken&amp; r)\n{\nreturn r &lt; l;\n}\ninline bool operator&lt;=(const CancelToken&amp; l, const CancelToken&amp; r)\n{\nreturn !(r &lt; l);\n}\ninline bool operator&gt;=(const CancelToken&amp; l, const CancelToken&amp; r)\n{\nreturn !(l &lt; r);\n}\n}  // namespace batt\n#include &lt;batteries/async/cancel_token.ipp&gt;\n#endif  // BATTERIES_ASYNC_CANCEL_TOKEN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/cancel_token_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/cancel__token__impl_8hpp/","title":"batteries/async/cancel_token_impl.hpp","text":""},{"location":"_autogen/Files/cancel__token__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/cancel__token__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_CANCEL_TOKEN_IMPL_HPP"},{"location":"_autogen/Files/cancel__token__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/cancel__token__impl_8hpp/#define-batteries_async_cancel_token_impl_hpp","title":"define BATTERIES_ASYNC_CANCEL_TOKEN_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_CANCEL_TOKEN_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/cancel__token__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_CANCEL_TOKEN_IMPL_HPP\n#define BATTERIES_ASYNC_CANCEL_TOKEN_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ const CancelToken&amp; CancelToken::none() noexcept\n{\nstatic const CancelToken none_{None};\nreturn none_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*implicit*/ CancelToken::CancelToken(NoneType) noexcept : impl_{nullptr}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL CancelToken&amp; CancelToken::operator=(const NoneType&amp;) noexcept\n{\nthis-&gt;impl_ = nullptr;\nreturn *this;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void CancelToken::cancel() const noexcept\n{\nBATT_CHECK_NOT_NULLPTR(this-&gt;impl_);\nthis-&gt;impl_-&gt;state_.fetch_or(kCancelled);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool CancelToken::is_valid() const noexcept\n{\nreturn this-&gt;impl_ != nullptr;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool CancelToken::is_cancelled() const noexcept\n{\nBATT_CHECK_NOT_NULLPTR(this-&gt;impl_);\nreturn this-&gt;impl_-&gt;is_cancelled();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ CancelToken::operator bool() const noexcept\n{\nreturn this-&gt;is_valid();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SmallFn&lt;void(std::ostream&amp;)&gt; CancelToken::debug_info() const noexcept\n{\nreturn [impl = this-&gt;impl_](std::ostream&amp; out) {\nif (impl) {\nout &lt;&lt; \"CancelToken{state=\" &lt;&lt; std::bitset&lt;8&gt;{impl-&gt;state_.get_value()} &lt;&lt; \",}\";\n} else {\nout &lt;&lt; \"CancelToken{None}\";\n}\n};\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_CANCEL_TOKEN_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/case__of_8hpp/","title":"batteries/case_of.hpp","text":""},{"location":"_autogen/Files/case__of_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/case__of_8hpp/#classes","title":"Classes","text":"Name struct batt::detail::FirstMatchImpl&lt; std::tuple&lt; CaseFirst, CaseRest... &gt;, std::tuple&lt; Args... &gt; &gt; struct batt::detail::FirstMatchImpl&lt; std::tuple&lt;&gt;, std::tuple&lt; Args... &gt; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp;&amp; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp;&amp; &gt; class batt::CaseOfVisitor"},{"location":"_autogen/Files/case__of_8hpp/#defines","title":"Defines","text":"Name BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier) BATT_CASE_OF_VISITOR_INVOKE(qualifier)"},{"location":"_autogen/Files/case__of_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/case__of_8hpp/#define-batt_specialize_visitor_result","title":"define BATT_SPECIALIZE_VISITOR_RESULT","text":"<pre><code>#define BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier)\n</code></pre>"},{"location":"_autogen/Files/case__of_8hpp/#define-batt_case_of_visitor_invoke","title":"define BATT_CASE_OF_VISITOR_INVOKE","text":"<pre><code>#define BATT_CASE_OF_VISITOR_INVOKE(qualifier)\n</code></pre>"},{"location":"_autogen/Files/case__of_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;variant&gt;\nnamespace batt {\n// =============================================================================\nnamespace detail {\ntemplate &lt;typename CaseTuple, typename ArgsTuple&gt;\nstruct FirstMatchImpl;\ntemplate &lt;typename CaseFirst, typename... CaseRest, typename... Args&gt;\nstruct FirstMatchImpl&lt;std::tuple&lt;CaseFirst, CaseRest...&gt;, std::tuple&lt;Args...&gt;&gt;\n: std::conditional_t&lt;IsCallable&lt;CaseFirst, Args&amp;&amp;...&gt;{},  //\nstd::integral_constant&lt;usize, 0&gt;,    //\nstd::integral_constant&lt;\nusize, 1 + FirstMatchImpl&lt;std::tuple&lt;CaseRest...&gt;, std::tuple&lt;Args...&gt;&gt;{}&gt;  //\n&gt; {\ntemplate &lt;typename Cases&gt;\ndecltype(auto) operator()(Cases&amp;&amp; cases, Args&amp;&amp;... args) const\n{\nstatic_assert(FirstMatchImpl::value &lt; std::tuple_size_v&lt;std::decay_t&lt;decltype(cases)&gt;&gt;,\n\"Unhandled case in case_of\");\nreturn std::get&lt;FirstMatchImpl::value&gt;(BATT_FORWARD(cases))(BATT_FORWARD(args)...);\n}\n};\ntemplate &lt;typename... Args&gt;\nstruct FirstMatchImpl&lt;std::tuple&lt;&gt;, std::tuple&lt;Args...&gt;&gt; : std::integral_constant&lt;usize, 0&gt; {\n};\n// The result type of a visitor is defined to be the std::common_type_t&lt;...&gt;\n// over the individual results of applying the visitor to a given variant\n// reference expression.  We must propagate const-ness and value category\n// from the variant to the case expression while computing this type.\n//\ntemplate &lt;typename Visitor, typename Variant&gt;\nstruct VisitorResult;\n// This must be instantiated for each possible value category:\n//  std::variant&lt;Ts...&gt;&amp;\n//  std::variant&lt;Ts...&gt; const&amp;\n//  std::variant&lt;Ts...&gt;&amp;&amp;\n//  std::variant&lt;Ts...&gt; const&amp;&amp;\n//\n#define BATT_SPECIALIZE_VISITOR_RESULT(ref_qualifier)                                                        \\\n    template &lt;typename Visitor, typename... Ts&gt;                                                              \\\n    struct VisitorResult&lt;Visitor, std::variant&lt;Ts...&gt; ref_qualifier&gt; {                                       \\\n        using type =                                                                                         \\\n            std::common_type_t&lt;decltype(std::declval&lt;Visitor&gt;()(std::declval&lt;Ts ref_qualifier&gt;()))...&gt;;      \\\n    }\nBATT_SPECIALIZE_VISITOR_RESULT(BATT_EXPANDS_TO_NOTHING);\nBATT_SPECIALIZE_VISITOR_RESULT(const);\nBATT_SPECIALIZE_VISITOR_RESULT(&amp;);\nBATT_SPECIALIZE_VISITOR_RESULT(const&amp;);\nBATT_SPECIALIZE_VISITOR_RESULT(&amp;&amp;);\nBATT_SPECIALIZE_VISITOR_RESULT(const&amp;&amp;);\ntemplate &lt;typename Visitor, typename VariantArg&gt;\nusing VisitorResultT = typename VisitorResult&lt;Visitor, VariantArg&gt;::type;\n#undef BATT_SPECIALIZE_VISITOR_RESULT\n}  // namespace detail\ntemplate &lt;typename... Cases&gt;\nclass CaseOfVisitor\n{\npublic:\nusing CaseTuple = std::tuple&lt;Cases...&gt;;\ntemplate &lt;typename... CaseArgs&gt;\nexplicit CaseOfVisitor(CaseArgs&amp;&amp;... case_args) noexcept : cases_{BATT_FORWARD(case_args)...}\n{\n}\ntemplate &lt;typename... Args&gt;\nusing FirstMatch = detail::FirstMatchImpl&lt;CaseTuple, std::tuple&lt;Args...&gt;&gt;;\n#define BATT_CASE_OF_VISITOR_INVOKE(qualifier)                                                               \\\n    template &lt;typename... Args&gt;                                                                              \\\n    decltype(auto) operator()(Args&amp;&amp;... args) qualifier                                                      \\\n    {                                                                                                        \\\n        return FirstMatch&lt;Args...&gt;{}(cases_, BATT_FORWARD(args)...);                                         \\\n    }\nBATT_CASE_OF_VISITOR_INVOKE(&amp;)\nBATT_CASE_OF_VISITOR_INVOKE(&amp;&amp;)\nBATT_CASE_OF_VISITOR_INVOKE(const&amp;)\nBATT_CASE_OF_VISITOR_INVOKE(const&amp;&amp;)\n#undef BATT_CASE_OF_VISITOR_INVOKE\nprivate:\nCaseTuple cases_;\n};\ntemplate &lt;typename... Cases&gt;\nCaseOfVisitor&lt;Cases&amp;&amp;...&gt; make_case_of_visitor(Cases&amp;&amp;... cases)\n{\nreturn CaseOfVisitor&lt;Cases&amp;&amp;...&gt;{BATT_FORWARD(cases)...};\n}\n// =============================================================================\ntemplate &lt;typename VarType, typename... Cases&gt;\ndecltype(auto) case_of(VarType&amp;&amp; v, Cases&amp;&amp;... cases)\n{\nstatic_assert(IsVariant&lt;std::decay_t&lt;VarType&gt;&gt;{}, \"case_of must be applied to a variant.\");\nusing Visitor = CaseOfVisitor&lt;Cases&amp;&amp;...&gt;;\nusing Result = detail::VisitorResultT&lt;Visitor, VarType&gt;;\nreturn std::visit(\n[&amp;](auto&amp;&amp; val) -&gt; Result {\nreturn Visitor{BATT_FORWARD(cases)...}(BATT_FORWARD(val));\n},\nBATT_FORWARD(v));\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Returns true iff the current case of the passed variant is equal to the template parameter `T`.\n//\ntemplate &lt;typename T, typename Var&gt;\nbool is_case(Var&amp;&amp; v)\n{\nreturn case_of(\nstd::forward&lt;Var&gt;(v),  //\n[](const std::decay_t&lt;T&gt;&amp;) {\nreturn true;\n},\n[](const auto&amp;) {\nreturn false;\n});\n}\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/chain_8hpp/","title":"batteries/seq/chain.hpp","text":""},{"location":"_autogen/Files/chain_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/chain_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Chain struct batt::seq::ChainBinder"},{"location":"_autogen/Files/chain_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_CHAIN_HPP"},{"location":"_autogen/Files/chain_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/chain_8hpp/#define-batteries_seq_chain_hpp","title":"define BATTERIES_SEQ_CHAIN_HPP","text":"<pre><code>#define BATTERIES_SEQ_CHAIN_HPP()\n</code></pre>"},{"location":"_autogen/Files/chain_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_CHAIN_HPP\n#define BATTERIES_SEQ_CHAIN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// chain\n//\ntemplate &lt;typename Seq1, typename Seq2&gt;\nclass Chain\n{\npublic:\nusing Item = std::common_type_t&lt;SeqItem&lt;Seq1&gt;, SeqItem&lt;Seq2&gt;&gt;;\nexplicit Chain(Seq1&amp;&amp; seq1, Seq2&amp;&amp; seq2) noexcept : seq1_(BATT_FORWARD(seq1)), seq2_(BATT_FORWARD(seq2))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (seq1_) {\nreturn seq1_-&gt;peek();\n}\nreturn seq2_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nif (seq1_) {\nauto item = seq1_-&gt;next();\nif (item) {\nreturn item;\n}\nseq1_ = None;\n}\nreturn seq2_.next();\n}\nprivate:\nOptional&lt;Seq1&gt; seq1_;\nSeq2 seq2_;\n};\ntemplate &lt;typename Seq2&gt;\nstruct ChainBinder {\nSeq2 seq2;\n};\ntemplate &lt;typename Seq2&gt;\nChainBinder&lt;Seq2&gt; chain(Seq2&amp;&amp; seq2)\n{\nreturn {BATT_FORWARD(seq2)};\n}\ntemplate &lt;typename Seq1, typename Seq2&gt;\n[[nodiscard]] Chain&lt;Seq1, Seq2&gt; operator|(Seq1&amp;&amp; seq1, ChainBinder&lt;Seq2&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq1, std::decay_t&lt;Seq1&gt;&gt;,\n\"Concatenated sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;Seq2, std::decay_t&lt;Seq2&gt;&gt;,\n\"Concatenated sequences may not be captured implicitly by reference.\");\nreturn Chain&lt;Seq1, Seq2&gt;{BATT_FORWARD(seq1), BATT_FORWARD(binder.seq2)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_CHAIN_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/channel_8hpp/","title":"batteries/async/channel.hpp","text":""},{"location":"_autogen/Files/channel_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/channel_8hpp/#classes","title":"Classes","text":"Name class batt::Channel A Channel is a one-way, unbuffered, SPSC (single-producer, single consumer) communication/synchronization primitive."},{"location":"_autogen/Files/channel_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_CHANNEL_HPP"},{"location":"_autogen/Files/channel_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/channel_8hpp/#define-batteries_async_channel_hpp","title":"define BATTERIES_ASYNC_CHANNEL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_CHANNEL_HPP()\n</code></pre>"},{"location":"_autogen/Files/channel_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_CHANNEL_HPP\n#define BATTERIES_ASYNC_CHANNEL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass Channel\n{\npublic:\ntemplate &lt;typename Handler,\ntypename = std::enable_if_t&lt;std::is_invocable_v&lt;Handler&amp;&amp;, const Status&amp;, T&amp;&gt;&gt;&gt;\nstatic void invoke_write_handler(Handler&amp;&amp; handler, const batt::Status&amp; status,\nT&amp; value) noexcept(noexcept(BATT_FORWARD(handler)(status, value)))\n{\nBATT_FORWARD(handler)(status, value);\n}\ntemplate &lt;typename Handler,\ntypename = std::enable_if_t&lt;!std::is_invocable_v&lt;Handler&amp;&amp;, const Status&amp;, T&amp;&gt; &amp;&amp;\nstd::is_invocable_v&lt;Handler&amp;&amp;, const Status&amp;&gt;&gt;,\ntypename = void&gt;\nstatic void invoke_write_handler(Handler&amp;&amp; handler, const batt::Status&amp; status,\nT&amp; /*value*/) noexcept(noexcept(BATT_FORWARD(handler)(status)))\n{\nBATT_FORWARD(handler)(status);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nChannel()\n{\n}\nChannel(const Channel&amp;) = delete;\nChannel&amp; operator=(const Channel&amp;) = delete;\n~Channel()\n{\nthis-&gt;close_for_write();\nthis-&gt;await_inactive();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nbool is_active() const;\nvoid await_inactive() noexcept\n{\nthis-&gt;read_count_.await_equal(this-&gt;write_count_.get_value()).IgnoreError();\n}\ntemplate &lt;typename Handler&gt;\nvoid async_wait_inactive(Handler&amp;&amp; handler) noexcept\n{\nconst i32 observed_read_count = this-&gt;read_count_.get_value();\nthis-&gt;async_wait_inactive_impl(observed_read_count, BATT_FORWARD(handler));\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Handler = void(StatusOr&lt;T&amp;&gt;)&gt;\nvoid async_read(Handler&amp;&amp; handler);\nStatusOr&lt;T&amp;&gt; read();\nvoid consume();\nvoid close_for_read();\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Handler = void(Status, T&amp;)&gt;\nvoid async_write(T&amp; value, Handler&amp;&amp; handler);\nStatus write(T&amp; value);\nvoid close_for_write();\nprivate:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Handler&gt;\nvoid async_wait_inactive_impl(i32 observed_read_count, Handler&amp;&amp; handler) noexcept\n{\nif (observed_read_count == this-&gt;write_count_.get_value()) {\nBATT_FORWARD(handler)();\n} else {\nthis-&gt;read_count_.async_wait(\nobserved_read_count,\nbind_handler(BATT_FORWARD(handler), [this](auto&amp;&amp; handler, StatusOr&lt;i32&gt; new_read_count) {\nthis-&gt;async_wait_inactive_impl(*new_read_count, BATT_FORWARD(handler));\n}));\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nWatch&lt;i32&gt; read_count_{0};\nWatch&lt;i32&gt; write_count_{0};\nT* value_ = nullptr;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ntemplate &lt;typename Handler&gt;\nvoid Channel&lt;T&gt;::async_read(Handler&amp;&amp; handler)\n{\nif (this-&gt;read_count_.is_closed()) {\nhandler(StatusOr&lt;T&amp;&gt;{StatusCode::kClosed});\nreturn;\n}\nconst i32 observed_write_count = this-&gt;write_count_.get_value();\nconst i32 observed_read_count = this-&gt;read_count_.get_value();\nif (observed_write_count &gt; observed_read_count) {\nhandler(StatusOr&lt;T&amp;&gt;{*this-&gt;value_});\nreturn;\n}\nthis-&gt;write_count_.async_wait(\nobserved_write_count,\nbind_handler(BATT_FORWARD(handler),\n[this, observed_read_count](Handler&amp;&amp; handler, StatusOr&lt;i32&gt; updated_write_count) {\nif (!updated_write_count.ok()) {\nhandler(StatusOr&lt;T&amp;&gt;{updated_write_count.status()});\nreturn;\n}\nBATT_CHECK_GT(*updated_write_count, observed_read_count);\nhandler(StatusOr&lt;T&amp;&gt;{*this-&gt;value_});\n}));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ntemplate &lt;typename Handler&gt;\nvoid Channel&lt;T&gt;::async_write(T&amp; value, Handler&amp;&amp; handler)\n{\nBATT_CHECK(!this-&gt;is_active());\nif (this-&gt;write_count_.is_closed()) {\nChannel::invoke_write_handler(BATT_FORWARD(handler), Status{StatusCode::kClosed}, value);\nreturn;\n}\nthis-&gt;value_ = &amp;value;\nconst i32 last_seen = this-&gt;read_count_.get_value();\nconst i32 target = this-&gt;write_count_.fetch_add(1) + 1;\nBATT_CHECK_EQ(last_seen + 1, target);\nthis-&gt;read_count_.async_wait(\nlast_seen,\nbind_handler(BATT_FORWARD(handler), [this, target](auto&amp;&amp; handler, StatusOr&lt;i32&gt; observed) {\nif (observed.ok()) {\nBATT_CHECK_EQ(target, *observed);\nBATT_CHECK_NOT_NULLPTR(this-&gt;value_);\n}\nT* const consumed_value = this-&gt;value_;\nthis-&gt;value_ = nullptr;\nChannel::invoke_write_handler(BATT_FORWARD(handler), observed.status(), *consumed_value);\n}));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ninline bool Channel&lt;T&gt;::is_active() const\n{\nreturn (this-&gt;write_count_.get_value() - this-&gt;read_count_.get_value()) &gt; 0;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ninline StatusOr&lt;T&amp;&gt; Channel&lt;T&gt;::read()\n{\nBATT_DEBUG_INFO(\"Channel::read()\" &lt;&lt; BATT_INSPECT(this-&gt;write_count_.get_value())\n&lt;&lt; BATT_INSPECT(this-&gt;read_count_.get_value()));\nStatusOr&lt;i64&gt; result = this-&gt;write_count_.await_not_equal(this-&gt;read_count_.get_value());\nBATT_REQUIRE_OK(result);\nreturn *this-&gt;value_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ninline void Channel&lt;T&gt;::consume()\n{\nBATT_CHECK(this-&gt;is_active());\nthis-&gt;read_count_.fetch_add(1);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ninline Status Channel&lt;T&gt;::write(T&amp; value)\n{\nBATT_CHECK(!this-&gt;is_active());\nif (this-&gt;write_count_.is_closed()) {\nreturn {StatusCode::kClosed};\n}\nthis-&gt;value_ = &amp;value;\nauto on_scope_exit = batt::finally([&amp;] {\nthis-&gt;value_ = nullptr;\n});\nconst i32 target = this-&gt;write_count_.fetch_add(1) + 1;\nBATT_DEBUG_INFO(\"Channel::write()\" &lt;&lt; BATT_INSPECT(this-&gt;write_count_.get_value())\n&lt;&lt; BATT_INSPECT(this-&gt;read_count_.get_value())\n&lt;&lt; BATT_INSPECT(target));\nStatus consumed = this-&gt;read_count_.await_equal(target);\nBATT_REQUIRE_OK(consumed);\nreturn OkStatus();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ninline void Channel&lt;T&gt;::close_for_read()\n{\nthis-&gt;read_count_.close();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ninline void Channel&lt;T&gt;::close_for_write()\n{\nthis-&gt;write_count_.close();\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_CHANNEL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/checked__cast_8hpp/","title":"batteries/checked_cast.hpp","text":""},{"location":"_autogen/Files/checked__cast_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/checked__cast_8hpp/#defines","title":"Defines","text":"Name BATTERIES_CHECKED_CAST_HPP BATT_CHECKED_CAST(dst_type, src_val)"},{"location":"_autogen/Files/checked__cast_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/checked__cast_8hpp/#define-batteries_checked_cast_hpp","title":"define BATTERIES_CHECKED_CAST_HPP","text":"<pre><code>#define BATTERIES_CHECKED_CAST_HPP()\n</code></pre>"},{"location":"_autogen/Files/checked__cast_8hpp/#define-batt_checked_cast","title":"define BATT_CHECKED_CAST","text":"<pre><code>#define BATT_CHECKED_CAST(dst_type, src_val)\n</code></pre>"},{"location":"_autogen/Files/checked__cast_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_CHECKED_CAST_HPP\n#define BATTERIES_CHECKED_CAST_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\n// Coerce between integral types, panicking if there is a loss of precision.\n//\ntemplate &lt;typename ToType, typename FromType,\ntypename = std::enable_if_t&lt;std::is_signed_v&lt;ToType&gt; == std::is_signed_v&lt;FromType&gt;&gt;&gt;\nToType checked_cast(FromType val, const char* file = \"\", int line = 0)\n{\nstatic_assert(std::is_integral_v&lt;ToType&gt; &amp;&amp; std::is_integral_v&lt;FromType&gt;,\n\"checked_cast can only be used with builtin integer types\");\nstatic_assert(std::is_signed_v&lt;ToType&gt; == std::is_signed_v&lt;FromType&gt;,\n\"checked_cast can not add or remove signed-ness to a type\");\nif (sizeof(ToType) &lt; sizeof(FromType)) {\nBATT_CHECK_EQ(static_cast&lt;FromType&gt;(static_cast&lt;ToType&gt;(val)), val)\n&lt;&lt; \" from \" &lt;&lt; file &lt;&lt; \":\" &lt;&lt; line;\n}\nreturn static_cast&lt;ToType&gt;(val);\n}\n// Go from unsigned to signed.\n//\ntemplate &lt;typename ToType, typename FromType,\ntypename = std::enable_if_t&lt;std::is_signed_v&lt;ToType&gt; &amp;&amp; !std::is_signed_v&lt;FromType&gt;&gt;,\ntypename = void&gt;\nToType checked_cast(FromType val, const char* file = \"\", int line = 0)\n{\nstatic_assert(std::is_integral_v&lt;ToType&gt; &amp;&amp; std::is_integral_v&lt;FromType&gt;,\n\"checked_cast can only be used with builtin integer types\");\n// If going from an unsigned to a larger signed, just coerce.\n//\nif (sizeof(FromType) &lt; sizeof(ToType)) {\nreturn static_cast&lt;ToType&gt;(val);\n}\nstatic constexpr isize kToBits = sizeof(ToType) * 8;\nstatic constexpr FromType kRetainedMask = (FromType{1} &lt;&lt; (kToBits - 1)) - 1;\nBATT_CHECK_EQ((val &amp; kRetainedMask), val) &lt;&lt; \" from \" &lt;&lt; file &lt;&lt; \":\" &lt;&lt; line;\nreturn static_cast&lt;ToType&gt;(val);\n}\n// Go from signed to unsigned\n//\ntemplate &lt;typename ToType, typename FromType,\ntypename = std::enable_if_t&lt;!std::is_signed_v&lt;ToType&gt; &amp;&amp; std::is_signed_v&lt;FromType&gt;&gt;,\ntypename = void, typename = void&gt;\nToType checked_cast(FromType val, const char* file = \"\", int line = 0)\n{\nstatic_assert(std::is_integral_v&lt;ToType&gt; &amp;&amp; std::is_integral_v&lt;FromType&gt;,\n\"checked_cast can only be used with builtin integer types\");\n// Panic if val is negative; otherwise, coerce to the same-sized unsigned type (which is always safe) and\n// do an unsigned-to-unsigned checked_cast.\n//\nBATT_CHECK_GE(val, 0) &lt;&lt; \" from \" &lt;&lt; file &lt;&lt; \":\" &lt;&lt; line;\nreturn checked_cast&lt;ToType&gt;(static_cast&lt;std::make_unsigned_t&lt;FromType&gt;&gt;(val), file, line);\n}\n#define BATT_CHECKED_CAST(dst_type, src_val) ::batt::checked_cast&lt;dst_type&gt;(src_val, __FILE__, __LINE__)\n}  // namespace batt\n#endif  // BATTERIES_CHECKED_CAST_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/collect_8hpp/","title":"batteries/seq/collect.hpp","text":""},{"location":"_autogen/Files/collect_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/collect_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::Collect"},{"location":"_autogen/Files/collect_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_COLLECT_HPP"},{"location":"_autogen/Files/collect_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/collect_8hpp/#define-batteries_seq_collect_hpp","title":"define BATTERIES_SEQ_COLLECT_HPP","text":"<pre><code>#define BATTERIES_SEQ_COLLECT_HPP()\n</code></pre>"},{"location":"_autogen/Files/collect_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_COLLECT_HPP\n#define BATTERIES_SEQ_COLLECT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// collect\n//\ntemplate &lt;typename T&gt;\nstruct Collect {\n};\ntemplate &lt;typename T&gt;\ninline Collect&lt;T&gt; collect(StaticType&lt;T&gt; = {})\n{\nreturn {};\n}\ntemplate &lt;typename Seq, typename T&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, Collect&lt;T&gt;)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::collect) Sequences may not be captured implicitly by reference.\");\nT v;\nBATT_FORWARD(seq) | for_each([&amp;v](auto&amp;&amp; item) {\nv.emplace_back(BATT_FORWARD(item));\n});\nreturn std::move(v);\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_COLLECT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/collect__vec_8hpp/","title":"batteries/seq/collect_vec.hpp","text":""},{"location":"_autogen/Files/collect__vec_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/collect__vec_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::CollectVec"},{"location":"_autogen/Files/collect__vec_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_COLLECT_VEC_HPP"},{"location":"_autogen/Files/collect__vec_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/collect__vec_8hpp/#define-batteries_seq_collect_vec_hpp","title":"define BATTERIES_SEQ_COLLECT_VEC_HPP","text":"<pre><code>#define BATTERIES_SEQ_COLLECT_VEC_HPP()\n</code></pre>"},{"location":"_autogen/Files/collect__vec_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_COLLECT_VEC_HPP\n#define BATTERIES_SEQ_COLLECT_VEC_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// collect_vec\n//\nstruct CollectVec {\n};\ninline CollectVec collect_vec()\n{\nreturn {};\n}\ntemplate &lt;typename Seq, typename = EnableIfSeq&lt;Seq&gt;&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, CollectVec)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::collect_vec) Sequences may not be captured implicitly by reference.\");\nstd::vector&lt;SeqItem&lt;Seq&gt;&gt; v;\nBATT_FORWARD(seq) | for_each([&amp;v](auto&amp;&amp; item) {\nv.emplace_back(BATT_FORWARD(item));\n});\nreturn v;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_COLLECT_VEC_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/compare_8hpp/","title":"batteries/compare.hpp","text":""},{"location":"_autogen/Files/compare_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/compare_8hpp/#defines","title":"Defines","text":"Name BATTERIES_COMPARE_HPP"},{"location":"_autogen/Files/compare_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/compare_8hpp/#define-batteries_compare_hpp","title":"define BATTERIES_COMPARE_HPP","text":"<pre><code>#define BATTERIES_COMPARE_HPP()\n</code></pre>"},{"location":"_autogen/Files/compare_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_COMPARE_HPP\n#define BATTERIES_COMPARE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/bounds.hpp&gt;\n#include &lt;batteries/endian.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n#include &lt;ostream&gt;\n#include &lt;string_view&gt;\nnamespace batt {\nenum struct Order : i8 {\nLess = -1,\nEqual = 0,\nGreater = 1,\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Order t)\n{\nswitch (t) {\ncase Order::Less:\nreturn out &lt;&lt; \"Less\";\ncase Order::Equal:\nreturn out &lt;&lt; \"Equal\";\ncase Order::Greater:\nreturn out &lt;&lt; \"Greater\";\ndefault:\nbreak;\n}\nreturn out &lt;&lt; \"BAD batt::OrderValue (\" &lt;&lt; (int)t &lt;&lt; \")!!!\";\n}\ninline Order compare(const std::string_view&amp; a, const std::string_view&amp; b) noexcept\n{\nconst usize len = std::min(a.size(), b.size());\nconst auto result = std::memcmp(a.data(), b.data(), len);\nif (result == 0) {\nif (a.size() &lt; b.size()) {\nreturn Order::Less;\n}\nif (a.size() == b.size()) {\nreturn Order::Equal;\n}\nreturn Order::Greater;\n} else if (result &lt; 0) {\nreturn Order::Less;\n} else {\nreturn Order::Greater;\n}\n}\n}  //namespace batt\n#endif  // BATTERIES_COMPARE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/config_8hpp/","title":"batteries/config.hpp","text":""},{"location":"_autogen/Files/config_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::features"},{"location":"_autogen/Files/config_8hpp/#classes","title":"Classes","text":"Name struct batt::features::State Captures the normative feature mask plus the stack trace where the global singleton instance of this type was initialized."},{"location":"_autogen/Files/config_8hpp/#defines","title":"Defines","text":"Name BATTERIES_CONFIG_HPP BATT_CPP_20 BATT_HEADER_ONLY BATT_INLINE_IMPL BATT_SEQ_SPECIALIZE_ALGORITHMS BATT_MUTEX_NO_LEGACY_API Set to 1 to disable Mutex::lock(). BATT_WITH_GLOG Define this preprocessor symbol to enable optional support for Google Log (GLOG). BATT_WITH_PROTOBUF Define this preprocessor symbol to enable optional support for Google Protocol Buffers (protobuf). BATT_COMPILER_IS_GCC BATT_IF_GCC(expr) BATT_COMPILER_IS_CLANG BATT_IF_CLANG(expr) BATT_COMPILER_IS_MSVC BATT_IF_MSVC(expr) BATT_IS_DEBUG_BUILD BATT_WITH_ASSERTS Enables BATT_ASSERTs explicitly (instead of inferring from -DNDEBUG)"},{"location":"_autogen/Files/config_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/config_8hpp/#define-batteries_config_hpp","title":"define BATTERIES_CONFIG_HPP","text":"<pre><code>#define BATTERIES_CONFIG_HPP()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_cpp_20","title":"define BATT_CPP_20","text":"<pre><code>#define BATT_CPP_20()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_header_only","title":"define BATT_HEADER_ONLY","text":"<pre><code>#define BATT_HEADER_ONLY()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_inline_impl","title":"define BATT_INLINE_IMPL","text":"<pre><code>#define BATT_INLINE_IMPL()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_seq_specialize_algorithms","title":"define BATT_SEQ_SPECIALIZE_ALGORITHMS","text":"<pre><code>#define BATT_SEQ_SPECIALIZE_ALGORITHMS()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_mutex_no_legacy_api","title":"define BATT_MUTEX_NO_LEGACY_API","text":"<pre><code>#define BATT_MUTEX_NO_LEGACY_API()\n</code></pre> <p>Set to 1 to disable Mutex::lock()."},{"location":"_autogen/Files/config_8hpp/#define-batt_with_glog","title":"define BATT_WITH_GLOG","text":"<pre><code>#define BATT_WITH_GLOG()\n</code></pre> <p>Define this preprocessor symbol to enable optional support for Google Log (GLOG). </p> <p>NOTE: when using Conan to install Batteries in a downstream project, this shouldn't be defined directly; instead add the following to the downstream <code>conanfile.py</code>:</p> <pre><code>def configure(self):\n...\nself.options[\"batteries\"].with_glog = True\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_with_protobuf","title":"define BATT_WITH_PROTOBUF","text":"<pre><code>#define BATT_WITH_PROTOBUF()\n</code></pre> <p>Define this preprocessor symbol to enable optional support for Google Protocol Buffers (protobuf). </p> <p>NOTE: when using Conan to install Batteries in a downstream project, this shouldn't be defined directly; instead add the following to the downstream <code>conanfile.py</code>:</p> <pre><code>def configure(self):\n...\nself.options[\"batteries\"].with_protobuf = True\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_compiler_is_gcc","title":"define BATT_COMPILER_IS_GCC","text":"<pre><code>#define BATT_COMPILER_IS_GCC()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_if_gcc","title":"define BATT_IF_GCC","text":"<pre><code>#define BATT_IF_GCC(expr)\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_compiler_is_clang","title":"define BATT_COMPILER_IS_CLANG","text":"<pre><code>#define BATT_COMPILER_IS_CLANG()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_if_clang","title":"define BATT_IF_CLANG","text":"<pre><code>#define BATT_IF_CLANG(expr)\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_compiler_is_msvc","title":"define BATT_COMPILER_IS_MSVC","text":"<pre><code>#define BATT_COMPILER_IS_MSVC()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_if_msvc","title":"define BATT_IF_MSVC","text":"<pre><code>#define BATT_IF_MSVC(expr)\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_is_debug_build","title":"define BATT_IS_DEBUG_BUILD","text":"<pre><code>#define BATT_IS_DEBUG_BUILD()\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#define-batt_with_asserts","title":"define BATT_WITH_ASSERTS","text":"<pre><code>#define BATT_WITH_ASSERTS()\n</code></pre> <p>Enables BATT_ASSERTs explicitly (instead of inferring from -DNDEBUG) </p> <p>NOTE: when using Conan to install Batteries in a downstream project, this shouldn't be defined directly; instead add the following to the downstream <code>conanfile.py</code>:</p> <pre><code>def configure(self):\n...\nself.options[\"batteries\"].with_asserts = True\n</code></pre>"},{"location":"_autogen/Files/config_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_CONFIG_HPP\n#define BATTERIES_CONFIG_HPP\n//----- --- -- -  -  -   -\n// IMPORTANT: This is the only batteries header that is allowed to be included from config.hpp!\n//\n#include &lt;batteries/stacktrace.hpp&gt;\n//\n//----- --- -- -  -  -   -\n#include &lt;bitset&gt;\n#include &lt;exception&gt;\n#include &lt;iostream&gt;\n#if __cplusplus &lt; 201703L\n#error Batteries requires C++17 or later!\n#endif\n#if __cplusplus &gt; 201703L\n#define BATT_CPP_20 1\n#else\n#define BATT_CPP_20 0\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifndef BATT_HEADER_ONLY\n#define BATT_HEADER_ONLY 1\n#endif\n#if BATT_HEADER_ONLY\n#define BATT_INLINE_IMPL inline\n#else\n#define BATT_INLINE_IMPL\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#define BATT_SEQ_SPECIALIZE_ALGORITHMS 0\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifndef BATT_MUTEX_NO_LEGACY_API\n#define BATT_MUTEX_NO_LEGACY_API 0\n#endif  // BATT_MUTEX_NO_LEGACY_API\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifndef BATT_WITH_GLOG\n#define BATT_WITH_GLOG 0\n#endif  // BATT_WITH_GLOG\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifndef BATT_WITH_PROTOBUF\n#define BATT_WITH_PROTOBUF 0\n#endif  // BATT_WITH_PROTOBUF\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BATT_COMPILER_IS_&lt;CC&gt; - set to 1 if the compiler is &lt;CC&gt;, else set to 0\n//\n// &lt;CC&gt; is one of:\n//  - CLANG\n//  - GCC\n//  - MSVC\n//\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n#define BATT_COMPILER_IS_GCC 1\n#define BATT_IF_GCC(expr) expr\n// This causes a lot of false positives, so disable.\n//\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#else\n#define BATT_COMPILER_IS_GCC 0\n#define BATT_IF_GCC(expr)\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#if defined(__clang__)\n#define BATT_COMPILER_IS_CLANG 1\n#define BATT_IF_CLANG(expr) expr\n#else\n#define BATT_COMPILER_IS_CLANG 0\n#define BATT_IF_CLANG(expr)\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#if defined(_MSC_VER)\n#define BATT_COMPILER_IS_MSVC 1\n#define BATT_IF_MSVC(expr) expr\n#else\n#define BATT_COMPILER_IS_MSVC 0\n#define BATT_IF_MSVC(expr)\n#endif\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// BATT_PLATFORM_IS_&lt;OS&gt; - defined iff the current platform is &lt;OS&gt;\n//\n// &lt;OS&gt; is one of:\n//  - APPLE\n//  - LINUX\n//  - WINDOWS\n//\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifdef __APPLE__\n#define BATT_PLATFORM_IS_APPLE 1\n#else\n#undef BATT_PLATFORM_IS_APPLE\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifdef __linux__\n#define BATT_PLATFORM_IS_LINUX 1\n#else\n#undef BATT_PLATFORM_IS_LINUX\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#if defined(_WIN32) || defined(_WIN64)\n#define BATT_PLATFORM_IS_WINDOWS 1\n#else\n#undef BATT_PLATFORM_IS_WINDOWS\n#endif\n#ifdef BATT_PLATFORM_IS_WINDOWS\n#undef min\n#undef max\n#endif\n#ifndef BATT_IS_DEBUG_BUILD\n#ifdef NDEBUG\n#define BATT_IS_DEBUG_BUILD 0\n#else\n#define BATT_IS_DEBUG_BUILD 1\n#endif\n#endif\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#ifndef BATT_WITH_ASSERTS\n#define BATT_WITH_ASSERTS BATT_IS_DEBUG_BUILD\n#endif  // BATT_WITH_ASSERTS\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\nnamespace batt {\nnamespace features {\nenum Feature {\nkHeaderOnly = 0,\nkSeqSpecializeAlgorithms,\nkWithGlog,\nkWithProtobuf,\nkCompilerGCC,\nkCompilerClang,\nkWithAsserts,\n// Not a feature - used to check that we have enough bits in the mask int type.\n//\nkNumFeatures,\n};\nusing mask_type = unsigned long long;\n// Make sure that the int type is big enough.\n//\nstatic_assert(features::kNumFeatures &lt;= (sizeof(mask_type) * 8));\ninline constexpr mask_type get_feature_mask()\n{\nconstexpr mask_type enabled = 1;\nmask_type mask = 0;\nif (BATT_HEADER_ONLY) {\nmask |= (enabled &lt;&lt; features::kHeaderOnly);\n}\nif (BATT_SEQ_SPECIALIZE_ALGORITHMS) {\nmask |= (enabled &lt;&lt; features::kSeqSpecializeAlgorithms);\n}\nif (BATT_WITH_GLOG) {\nmask |= (enabled &lt;&lt; features::kWithGlog);\n}\nif (BATT_WITH_PROTOBUF) {\nmask |= (enabled &lt;&lt; features::kWithProtobuf);\n}\nif (BATT_COMPILER_IS_GCC) {\nmask |= (enabled &lt;&lt; features::kCompilerGCC);\n}\nif (BATT_COMPILER_IS_CLANG) {\nmask |= (enabled &lt;&lt; features::kCompilerClang);\n}\nif (BATT_WITH_ASSERTS) {\nmask |= (enabled &lt;&lt; features::kWithAsserts);\n}\nreturn mask;\n}\nstruct State {\nboost::stacktrace::stacktrace init_trace;\nconst mask_type mask = get_feature_mask();\n};\ninline const State&amp; get_global_state()\n{\nstatic const State state;\nreturn state;\n}\ninline bool check_local_feature_state()\n{\nconst State&amp; global_state = features::get_global_state();\nif (get_feature_mask() != global_state.mask) {\nstd::cerr &lt;&lt; \"FATAL: feature mask does not match!\\n\\nfile:\" &lt;&lt; __FILE__\n&lt;&lt; \", mask=\" &lt;&lt; std::bitset&lt;features::kNumFeatures&gt;{features::get_feature_mask()}\n&lt;&lt; \"\\n\\nglobal mask=\" &lt;&lt; std::bitset&lt;features::kNumFeatures&gt;{global_state.mask}\n&lt;&lt; \"\\n\\nglobal state initialized at: \\n\\n\"\n&lt;&lt; global_state.init_trace &lt;&lt; \"\\n\"\n&lt;&lt; std::endl;\nstd::terminate();\n}\nreturn true;\n}\n}  // namespace features\nnamespace {\n[[maybe_unused]] const bool feature_mask_check_for_module = features::check_local_feature_state();\n}  // namespace\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#if defined(BATT_PLATFORM_IS_LINUX)\n#define BATT_PLATFORM_SUPPORTS_DEATH_TESTS 1\n#elif defined(BATT_PLATFORM_IS_APPLE)\n#define BATT_PLATFORM_SUPPORTS_DEATH_TESTS 1\n#elif defined(BATT_PLATFORM_IS_WINDOWS)\n#define BATT_PLATFORM_SUPPORTS_DEATH_TESTS 0\n#else\n#error Please define BATT_PLATFORM_SUPPORTS_DEATH_TESTS for your platform\n#endif\n}  // namespace batt\n#endif  // BATTERIES_CONFIG_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/constants_8hpp/","title":"batteries/constants.hpp","text":""},{"location":"_autogen/Files/constants_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::constants"},{"location":"_autogen/Files/constants_8hpp/#defines","title":"Defines","text":"Name BATTERIES_CONSTANTS_HPP"},{"location":"_autogen/Files/constants_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/constants_8hpp/#define-batteries_constants_hpp","title":"define BATTERIES_CONSTANTS_HPP","text":"<pre><code>#define BATTERIES_CONSTANTS_HPP()\n</code></pre>"},{"location":"_autogen/Files/constants_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_CONSTANTS_HPP\n#define BATTERIES_CONSTANTS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\nnamespace constants {\nconstexpr u64 kKB = 1000ull;\nconstexpr u64 kMB = 1000ull * kKB;\nconstexpr u64 kGB = 1000ull * kMB;\nconstexpr u64 kTB = 1000ull * kGB;\nconstexpr u64 kPB = 1000ull * kTB;\nconstexpr u64 kEB = 1000ull * kPB;\nconstexpr u64 kKiB = 1024ull;\nconstexpr u64 kMiB = 1024ull * kKiB;\nconstexpr u64 kGiB = 1024ull * kMiB;\nconstexpr u64 kTiB = 1024ull * kGiB;\nconstexpr u64 kPiB = 1024ull * kTiB;\nconstexpr u64 kEiB = 1024ull * kPiB;\n}  // namespace constants\nusing namespace constants;\n}  // namespace batt\n#endif  // BATTERIES_CONSTANTS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/consume_8hpp/","title":"batteries/seq/consume.hpp","text":""},{"location":"_autogen/Files/consume_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/consume_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::Consume"},{"location":"_autogen/Files/consume_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_CONSUME_HPP"},{"location":"_autogen/Files/consume_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/consume_8hpp/#define-batteries_seq_consume_hpp","title":"define BATTERIES_SEQ_CONSUME_HPP","text":"<pre><code>#define BATTERIES_SEQ_CONSUME_HPP()\n</code></pre>"},{"location":"_autogen/Files/consume_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_CONSUME_HPP\n#define BATTERIES_SEQ_CONSUME_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/requirements.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// consume\n//\nstruct Consume {\n};\ninline auto consume()\n{\nreturn Consume{};\n}\ntemplate &lt;typename Seq, typename = EnableIfSeq&lt;Seq&gt;&gt;\nvoid operator|(Seq&amp;&amp; seq, Consume&amp;&amp;)\n{\nLoopControl result = BATT_FORWARD(seq) | for_each([](auto&amp;&amp;...) noexcept {\n// nom, nom, nom...\n});\nBATT_CHECK_EQ(result, kContinue);\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_CONSUME_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/continuation_8hpp/","title":"batteries/async/continuation.hpp","text":""},{"location":"_autogen/Files/continuation_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/continuation_8hpp/#classes","title":"Classes","text":"Name class batt::AbstractStackAllocator class batt::StackAllocatorImpl class batt::StackAllocator"},{"location":"_autogen/Files/continuation_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_CONTINUATION_HPP"},{"location":"_autogen/Files/continuation_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/continuation_8hpp/#define-batteries_async_continuation_hpp","title":"define BATTERIES_ASYNC_CONTINUATION_HPP","text":"<pre><code>#define BATTERIES_ASYNC_CONTINUATION_HPP()\n</code></pre>"},{"location":"_autogen/Files/continuation_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_CONTINUATION_HPP\n#define BATTERIES_ASYNC_CONTINUATION_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/math.hpp&gt;\n#include &lt;batteries/static_assert.hpp&gt;\n#include &lt;batteries/static_dispatch.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\n#include &lt;batteries/type_erasure.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#if !defined(NDEBUG) &amp;&amp; BATT_PLATFORM_IS_LINUX\n#define BOOST_USE_VALGRIND 1\n#endif\n#include &lt;boost/context/continuation.hpp&gt;\n#include &lt;boost/context/fixedsize_stack.hpp&gt;\n#include &lt;boost/context/pooled_fixedsize_stack.hpp&gt;\n#include &lt;boost/context/protected_fixedsize_stack.hpp&gt;\n#include &lt;array&gt;\nnamespace batt {\nusing Continuation = boost::context::continuation;\nclass AbstractStackAllocator : public AbstractValue&lt;AbstractStackAllocator&gt;\n{\npublic:\nAbstractStackAllocator(const AbstractStackAllocator&amp;) = delete;\nAbstractStackAllocator&amp; operator=(const AbstractStackAllocator&amp;) = delete;\nvirtual ~AbstractStackAllocator() = default;\nvirtual boost::context::stack_context allocate() = 0;\nvirtual void deallocate(boost::context::stack_context&amp;) = 0;\nprotected:\nAbstractStackAllocator() = default;\n};\ntemplate &lt;typename T&gt;\nclass StackAllocatorImpl : public AbstractValueImpl&lt;AbstractStackAllocator, StackAllocatorImpl, T&gt;\n{\npublic:\nusing Super = AbstractValueImpl&lt;AbstractStackAllocator, StackAllocatorImpl, T&gt;;\ntemplate &lt;typename... Args, typename = EnableIfNoShadow&lt;StackAllocatorImpl, Args&amp;&amp;...&gt;&gt;\nexplicit StackAllocatorImpl(Args&amp;&amp;... args) : Super(BATT_FORWARD(args)...)\n{\n}\nboost::context::stack_context allocate() override\n{\nreturn this-&gt;Super::obj_.allocate();\n}\nvoid deallocate(boost::context::stack_context&amp; ctx) override\n{\nreturn this-&gt;Super::obj_.deallocate(ctx);\n}\n};\nclass StackAllocator\n{\npublic:\nStackAllocator() noexcept : storage_{}\n{\n}\nStackAllocator(const StackAllocator&amp;) = default;\nStackAllocator&amp; operator=(const StackAllocator&amp;) = default;\ntemplate &lt;typename T, typename = EnableIfNoShadow&lt;StackAllocator, T&amp;&amp;&gt;&gt;\nexplicit StackAllocator(T&amp;&amp; obj) : storage_{StaticType&lt;std::decay_t&lt;T&gt;&gt;{}, BATT_FORWARD(obj)}\n{\n}\nboost::context::stack_context allocate() const\n{\nreturn this-&gt;storage_-&gt;allocate();\n}\nvoid deallocate(boost::context::stack_context&amp; ctx) const\n{\nreturn this-&gt;storage_-&gt;deallocate(ctx);\n}\nprivate:\nTypeErasedStorage&lt;AbstractStackAllocator, StackAllocatorImpl&gt; storage_;\n};\n#ifdef BOOST_USE_VALGRIND\nBATT_STATIC_ASSERT_EQ(sizeof(void*) * 3, sizeof(boost::context::stack_context));\n#else\nBATT_STATIC_ASSERT_EQ(sizeof(void*) * 2, sizeof(boost::context::stack_context));\n#endif\nenum struct StackType {\nkFixedSize = 0,\nkProtectedFixedSize = 1,\nkPooledFixedSize = 2,\nkMaxValue,\n};\nBATT_STRONG_TYPEDEF(usize, StackSize);\nconstexpr usize kMinStackSizeLog2 = 10u;\nconstexpr usize kMaxStackSizeLog2 = 32u;\ntemplate &lt;typename T&gt;\ninline const StackAllocator&amp; get_stack_allocator_with_type(StackSize stack_size)\n{\nstatic const std::array&lt;StackAllocator, kMaxStackSizeLog2&gt; instance = [] {\nstd::array&lt;StackAllocator, kMaxStackSizeLog2&gt; a;\nusize z = 1;\nfor (usize i = 0; i &lt; a.size(); ++i) {\nif (i &gt;= kMinStackSizeLog2) {\nBATT_CHECK_EQ(z, usize{1} &lt;&lt; i);\na[i] = StackAllocator{T{usize{1} &lt;&lt; i}};\n}\nz *= 2;\n}\nreturn a;\n}();\nconst usize n = std::max&lt;usize&gt;(kMinStackSizeLog2, log2_ceil(stack_size));\nBATT_CHECK_GE(n, kMinStackSizeLog2);\nBATT_CHECK_LT(n, instance.size());\nBATT_CHECK_GE(usize{1} &lt;&lt; n, stack_size);\nreturn instance[n];\n}\ninline const StackAllocator&amp; get_stack_allocator(StackSize stack_size, StackType stack_type)\n{\nswitch (stack_type) {\ncase StackType::kFixedSize:\nreturn get_stack_allocator_with_type&lt;boost::context::fixedsize_stack&gt;(stack_size);\ncase StackType::kProtectedFixedSize:\nreturn get_stack_allocator_with_type&lt;boost::context::protected_fixedsize_stack&gt;(stack_size);\ncase StackType::kPooledFixedSize:\nBATT_PANIC() &lt;&lt; \"This stack allocator type is not thread-safe; do not use yet!\";\nreturn get_stack_allocator_with_type&lt;boost::context::pooled_fixedsize_stack&gt;(stack_size);\ncase StackType::kMaxValue:  // fall-through\ndefault:\nbreak;\n}\nBATT_PANIC() &lt;&lt; \"Bad stack type: \" &lt;&lt; static_cast&lt;int&gt;(stack_type);\nBATT_UNREACHABLE();\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename Fn&gt;\ninline Continuation callcc(StackAllocator&amp;&amp; stack_allocator, Fn&amp;&amp; fn)\n{\nreturn boost::context::callcc(std::allocator_arg, std::move(stack_allocator), BATT_FORWARD(fn));\n}\ntemplate &lt;typename Fn&gt;\ninline Continuation callcc(StackSize stack_size, StackType stack_type, Fn&amp;&amp; fn)\n{\nreturn callcc(make_copy(get_stack_allocator(stack_size, stack_type)), BATT_FORWARD(fn));\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_CONTINUATION_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/count_8hpp/","title":"batteries/seq/count.hpp","text":""},{"location":"_autogen/Files/count_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/count_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::CountBinder"},{"location":"_autogen/Files/count_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_COUNT_HPP"},{"location":"_autogen/Files/count_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/count_8hpp/#define-batteries_seq_count_hpp","title":"define BATTERIES_SEQ_COUNT_HPP","text":"<pre><code>#define BATTERIES_SEQ_COUNT_HPP()\n</code></pre>"},{"location":"_autogen/Files/count_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_COUNT_HPP\n#define BATTERIES_SEQ_COUNT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// count\n//\nstruct CountBinder {\n};\ninline CountBinder count()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\nBATT_MAYBE_UNUSED usize operator|(Seq&amp;&amp; seq, CountBinder)\n{\nusize n = 0;\nauto loop_body = [&amp;n](auto&amp;&amp;...) noexcept {\n++n;\n};\nBATT_FORWARD(seq) | for_each(loop_body);\nreturn n;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_COUNT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/cpu__align_8hpp/","title":"batteries/cpu_align.hpp","text":""},{"location":"_autogen/Files/cpu__align_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/cpu__align_8hpp/#classes","title":"Classes","text":"Name class batt::CpuCacheLineIsolated struct batt::ThreadPoolConfig"},{"location":"_autogen/Files/cpu__align_8hpp/#defines","title":"Defines","text":"Name BATT_CPU_ALIGN_HPP"},{"location":"_autogen/Files/cpu__align_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/cpu__align_8hpp/#define-batt_cpu_align_hpp","title":"define BATT_CPU_ALIGN_HPP","text":"<pre><code>#define BATT_CPU_ALIGN_HPP()\n</code></pre>"},{"location":"_autogen/Files/cpu__align_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATT_CPU_ALIGN_HPP\n#define BATT_CPU_ALIGN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;thread&gt;\n#ifdef __linux__\n#include &lt;sched.h&gt;\n#endif  // __linux__\nnamespace batt {\nconstexpr auto kCpuCacheLineSize = usize{64};\n// An instance of `T` guaranteed not to reside in the same cache lines as any other object.\n//\ntemplate &lt;typename T&gt;\nclass CpuCacheLineIsolated\n{\npublic:\n// The contained type.\n//\nusing value_type = T;\n// The size of T rounded up to the nearest multiple of cache line size.\n//\nstatic constexpr usize kIsolatedSize =\n(sizeof(T) + kCpuCacheLineSize - 1) - ((sizeof(T) + kCpuCacheLineSize - 1) % kCpuCacheLineSize);\n// If the passed pointer is constructed within a CpuCacheLineIsolated&lt;T&gt;, return a pointer to the outer\n// object. Else, behavior is undefined.\n//\nstatic CpuCacheLineIsolated* pointer_from(T* inner_obj)\n{\nreturn reinterpret_cast&lt;CpuCacheLineIsolated*&gt;(inner_obj);\n}\nstatic const CpuCacheLineIsolated* pointer_from(const T* inner_obj)\n{\nreturn reinterpret_cast&lt;const CpuCacheLineIsolated*&gt;(inner_obj);\n}\n// Default-construct the object.\n//\nCpuCacheLineIsolated() noexcept(noexcept(T{}))\n{\nnew (&amp;storage_) T{};\n}\n// Pass-through construct the object from arbitrary arguments.\n//\ntemplate &lt;typename... Args, typename = EnableIfNoShadow&lt;CpuCacheLineIsolated, Args...&gt;&gt;\nexplicit CpuCacheLineIsolated(Args&amp;&amp;... args) noexcept(noexcept(T(std::forward&lt;Args&gt;(args)...)))\n{\nnew (&amp;storage_) T(std::forward&lt;Args&gt;(args)...);\n}\n// Construct the object by copying from `that`.\n//\nCpuCacheLineIsolated(const CpuCacheLineIsolated&amp; that)\n#if !BATT_COMPILER_IS_MSVC\nnoexcept(noexcept(T(that.value())))\n#endif  // BATT_COMPILER_IS_MSVC\n{\nnew (&amp;storage_) T(that.value());\n}\n// Construct the object by moving from `that`.\n//\nCpuCacheLineIsolated(CpuCacheLineIsolated&amp;&amp; that) noexcept(noexcept(T(std::move(that).value())))\n{\nnew (&amp;storage_) T(std::move(that).value());\n}\n// Assign a new value to the object from the object contained within `that`.\n//\nCpuCacheLineIsolated&amp; operator=(const CpuCacheLineIsolated&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;value() = that.value();\n}\nreturn *this;\n}\n// Pass-through assignment from any type assignable to T.\n//\ntemplate &lt;typename V, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;V&gt;, CpuCacheLineIsolated&gt;&gt;&gt;\nCpuCacheLineIsolated&amp; operator=(V&amp;&amp; val) noexcept(\nnoexcept(std::declval&lt;CpuCacheLineIsolated*&gt;()-&gt;value() = std::forward&lt;V&gt;(val)))\n{\nthis-&gt;value() = std::forward&lt;V&gt;(val);\nreturn *this;\n}\n// Move a new value to the object from the object contained within `that`.\n//\nCpuCacheLineIsolated&amp; operator=(CpuCacheLineIsolated&amp;&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;value() = std::move(that).value();\n}\nreturn *this;\n}\n// Destroy the object.\n//\n~CpuCacheLineIsolated() noexcept\n{\nvalue().~T();\n}\n// Return a pointer to the isolated object.\n//\nT* get()\n{\nreturn reinterpret_cast&lt;T*&gt;(&amp;storage_);\n}\nconst T* get() const\n{\nreturn reinterpret_cast&lt;const T*&gt;(&amp;storage_);\n}\n// Return a reference to the isolated object.\n//\nT&amp; value() &amp; noexcept\n{\nreturn *reinterpret_cast&lt;T*&gt;(&amp;storage_);\n}\nconst T&amp; value() const&amp; noexcept\n{\nreturn *reinterpret_cast&lt;const T*&gt;(&amp;storage_);\n}\nT&amp;&amp; value() &amp;&amp; noexcept\n{\nreturn std::move(*reinterpret_cast&lt;T*&gt;(&amp;storage_));\n}\nconst T&amp;&amp; value() const&amp;&amp; = delete;\n// Member-dereference the isolated object.\n//\nT* operator-&gt;()\n{\nreturn this-&gt;get();\n}\nconst T* operator-&gt;() const\n{\nreturn this-&gt;get();\n}\n// Dereference the isolated object.\n//\nT&amp; operator*() &amp;\n{\nreturn this-&gt;value();\n}\nconst T&amp; operator*() const&amp;\n{\nreturn this-&gt;value();\n}\nT&amp;&amp; operator*() &amp;&amp;\n{\nreturn std::move(this-&gt;value());\n}\nprivate:\n// The properly padded and aligned storage to hold the isolated object.\n//\nstd::aligned_storage_t&lt;kIsolatedSize, kCpuCacheLineSize&gt; storage_;\n};\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const CpuCacheLineIsolated&lt;T&gt;&amp; t)\n{\nreturn out &lt;&lt; make_printable(t.value());\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ninline Status pin_thread_to_cpu(usize cpu_i)\n{\n#ifdef __linux__\ncpu_set_t mask;\nCPU_ZERO(&amp;mask);\nCPU_SET(cpu_i, &amp;mask);\nconst int retval = sched_setaffinity(0, sizeof(mask), &amp;mask);\nreturn status_from_retval(retval);\n#else\n(void)cpu_i;\nreturn StatusCode::kUnimplemented;\n#endif  //__linux__\n}\ntemplate &lt;typename IntRange&gt;\ninline Status pin_thread_to_cpu_set(const IntRange&amp; cpu_i_set)\n{\n#ifdef __linux__\ncpu_set_t mask;\nCPU_ZERO(&amp;mask);\nfor (usize cpu_i : cpu_i_set) {\nCPU_SET(cpu_i, &amp;mask);\n}\nconst int retval = sched_setaffinity(0, sizeof(mask), &amp;mask);\nreturn status_from_retval(retval);\n#else\n(void)cpu_i_set;\nreturn StatusCode::kUnimplemented;\n#endif  //__linux__\n}\nstruct ThreadPoolConfig {\nusize thread_count;\nusize cpu_group_size;\nusize first_cpu;\nbool pin;\n};\ninline Status pin_thread_i_of_config(usize i, const ThreadPoolConfig&amp; config,\nconst std::string_view&amp; pool_name = \"\")\n{\nstatic const usize cpu_count = std::thread::hardware_concurrency();\nif (i &gt;= config.thread_count) {\nreturn StatusCode::kInvalidArgument;\n}\nif (!config.pin) {\nreturn OkStatus();\n}\n// The position of this thread within its CPU group.\n//\nconst usize group_position = i % config.cpu_group_size;\n// The first CPU within this thread's CPU group.\n//\nconst usize group_first = i - group_position + config.first_cpu;\n// The last CPU in the group.\n//\nconst usize group_last = group_first + config.cpu_group_size;\n// Build the CPU set to pin this worker thread.\n//\nstd::vector&lt;int&gt; cpu_set;\nfor (usize j = group_first; j &lt; group_last; ++j) {\ncpu_set.emplace_back(static_cast&lt;int&gt;(j % cpu_count));\n}\nBATT_VLOG(1) &lt;&lt; pool_name &lt;&lt; \"[\" &lt;&lt; i &lt;&lt; \"]: cpu \" &lt;&lt; batt::dump_range(cpu_set);\nreturn pin_thread_to_cpu_set(cpu_set);\n}\n}  // namespace batt\n#endif  // BATT_CPU_ALIGN_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/deadline__timer_8hpp/","title":"batteries/asio/deadline_timer.hpp","text":""},{"location":"_autogen/Files/deadline__timer_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_DEADLINE_TIMER_HPP"},{"location":"_autogen/Files/deadline__timer_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/deadline__timer_8hpp/#define-batteries_asio_deadline_timer_hpp","title":"define BATTERIES_ASIO_DEADLINE_TIMER_HPP","text":"<pre><code>#define BATTERIES_ASIO_DEADLINE_TIMER_HPP()\n</code></pre>"},{"location":"_autogen/Files/deadline__timer_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_ASIO_DEADLINE_TIMER_HPP\n#define BATTERIES_ASIO_DEADLINE_TIMER_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/deadline_timer.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_DEADLINE_TIMER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/debug__info_8cpp/","title":"batteries/async/debug_info.cpp","text":""},{"location":"_autogen/Files/debug__info_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/debug_info.hpp&gt;\n//\n#include &lt;batteries/async/debug_info_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/debug__info_8hpp/","title":"batteries/async/debug_info.hpp","text":""},{"location":"_autogen/Files/debug__info_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/debug_info_decl.hpp&gt;\n#include &lt;batteries/async/debug_info.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/debug_info_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/debug__info__decl_8hpp/","title":"batteries/async/debug_info_decl.hpp","text":""},{"location":"_autogen/Files/debug__info__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/debug__info__decl_8hpp/#classes","title":"Classes","text":"Name class batt::DebugInfoFrame"},{"location":"_autogen/Files/debug__info__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP BATT_DEBUG_INFO(expr)"},{"location":"_autogen/Files/debug__info__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/debug__info__decl_8hpp/#define-batteries_async_debug_info_decl_hpp","title":"define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/debug__info__decl_8hpp/#define-batt_debug_info","title":"define BATT_DEBUG_INFO","text":"<pre><code>#define BATT_DEBUG_INFO(expr)\n</code></pre>"},{"location":"_autogen/Files/debug__info__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP\n#define BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task_decl.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/slice.hpp&gt;\n#include &lt;array&gt;\n#include &lt;functional&gt;\n#include &lt;ostream&gt;\nnamespace batt {\nconstexpr usize kMaxDebugInfoThreads = 32;\nclass DebugInfoFrame;\n// Print the stack of DebugInfoFrame objects for the current task/thread.\n//\nvoid this_task_debug_info(std::ostream&amp; out);\n// Print the given stack of DebugInfoFrame objects.\n//\nvoid print_debug_info(DebugInfoFrame* p, std::ostream&amp; out);\n// Print DebugInfoFrame stacks for all (non-Task) threads.\n//\nvoid print_all_threads_debug_info(std::ostream&amp; out);\n// Shortens the passed source code file name by applying heuristics.\n//\nconst char* shortened_source_file(const char* raw);\n// A stack-local linked list node that captures diagnostic information.  This class should most often not be\n// used directly; see `BATT_DEBUG_INFO` below.\n//\nclass DebugInfoFrame\n{\npublic:\n// A fixed-sized slice of pointers to DebugInfoFrame stack tops; indexed by the thread id.\n//\nstatic Slice&lt;DebugInfoFrame*&gt; all_threads();\n// (Thread-Local) A read/write reference to the top-of-stack debug info frame for the current thread.\n//\nstatic DebugInfoFrame*&amp; top();\n// `Fn` is a callable object with signature `void (std::ostream&amp;)`.\n// `fn` should print human readable diagnostic information to the passed stream when invoked.\n//\n// When a DebugInfoFrame is created, it automatically links to the thread/Task-local \"top\"\n// DebugInfoFrame*, forming a stack.  *WARNING*: this means it will create problems if you try to create a\n// DebugInfoFrame in one block scope and then move it to another one for destruction.  In most cases, you\n// should just use the BATT_DEBUG_INFO macro inside a function to create a DebugInfoFrame implicitly.\n//\ntemplate &lt;typename Fn&gt;\nexplicit DebugInfoFrame(Fn&amp;&amp; fn) noexcept;\n// Pop this frame from the top of the stack, restoring the old top frame.\n//\n~DebugInfoFrame() noexcept;\n// Declare as friend so `print_debug_info` can traverse the chain of `prev_` pointers.\n//\nfriend void print_debug_info(DebugInfoFrame* p, std::ostream&amp; out);\nprivate:\n// The diagnostic information emitter function passed in at construction time.\n//\nstd::function&lt;void(std::ostream&amp;, const void*)&gt; print_info_;\n// The previous top-of-stack, when this object was created.\n//\nDebugInfoFrame* prev_;\n};\n// Create a local variable that passively reports human-readable debugging information in response to\n// generating a backtrace of all Tasks/threads.\n//\n// Example:\n// ```\n// void called_from_a_thread(int n) {\n//   for (int i=0; i&lt;n; ++i) {\n//     BATT_DEBUG_INFO(\"loop iteration \" &lt;&lt; i &lt;&lt; \" of \" &lt;&lt; n);\n//   }\n// }\n// ```\n//\n#define BATT_DEBUG_INFO(expr)                                                                                \\\n    ::batt::DebugInfoFrame BOOST_PP_CAT(debug_info_BATTERIES_, __LINE__)                                     \\\n    {                                                                                                        \\\n        [&amp;](std::ostream&amp; out, const void* frame) {                                                          \\\n            out &lt;&lt; \" \" &lt;&lt; expr &lt;&lt; std::endl                                                                  \\\n                &lt;&lt; \"    at \" &lt;&lt; ::batt::shortened_source_file(__FILE__) &lt;&lt; \":\" &lt;&lt; __LINE__ &lt;&lt; std::endl      \\\n                &lt;&lt; \"    in \" &lt;&lt; BATT_THIS_FUNCTION &lt;&lt; std::endl                                             \\\n                &lt;&lt; \"    stack offset: \" &lt;&lt; ::batt::Task::current_stack_pos_of(frame) &lt;&lt; std::endl;           \\\n        }                                                                                                    \\\n    }\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_DEBUG_INFO_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/debug__info__impl_8hpp/","title":"batteries/async/debug_info_impl.hpp","text":""},{"location":"_autogen/Files/debug__info__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/debug__info__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP"},{"location":"_autogen/Files/debug__info__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/debug__info__impl_8hpp/#define-batteries_async_debug_info_impl_hpp","title":"define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/debug__info__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP\n#define BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/segv.hpp&gt;\n#include &lt;array&gt;\n#include &lt;cstring&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Slice&lt;DebugInfoFrame*&gt; DebugInfoFrame::all_threads()\n{\nstatic auto p_ = [] {\nstd::array&lt;DebugInfoFrame*, kMaxDebugInfoThreads&gt; p;\np.fill(nullptr);\nreturn p;\n}();\nreturn as_slice(p_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL DebugInfoFrame*&amp; DebugInfoFrame::top()\n{\nthread_local DebugInfoFrame* ptr = nullptr;\nif (Task::current_ptr()) {\nreturn Task::current().debug_info;\n}\nconst auto i = this_thread_id();\nif ((usize)i &lt; all_threads().size()) {\nreturn all_threads()[i];\n}\nreturn ptr;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL DebugInfoFrame::~DebugInfoFrame() noexcept\n{\ntop() = this-&gt;prev_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void print_debug_info(DebugInfoFrame* p, std::ostream&amp; out)\n{\nusize depth = 0;\nwhile (p) {\nout &lt;&lt; \" \" &lt;&lt; depth &lt;&lt; \".\";\np-&gt;print_info_(out, p);\np = p-&gt;prev_;\ndepth += 1;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void print_all_threads_debug_info(std::ostream&amp; out)\n{\nconst auto&amp; a = DebugInfoFrame::all_threads();\nfor (std::size_t i = 0; i &lt; a.size(); ++i) {\nif (a[i]) {\nout &lt;&lt; \"DEBUG (thread:\" &lt;&lt; i &lt;&lt; \")\" &lt;&lt; std::endl;\nprint_debug_info(a[i], out);\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const char* shortened_source_file(const char* raw)\n{\nstatic const std::string kIncludeDir = \"/include/\";\nstatic const std::string kSrcDir = \"/src/\";\nstatic const std::string kSourceDir = \"/source/\";\nif (!raw) {\nreturn \"\";\n}\nfor (;;) {\nbool found = false;\nfor (const std::string&amp; pattern : {kIncludeDir, kSrcDir, kSourceDir}) {\nconst char* pos = std::strstr(raw, pattern.c_str());\nif (pos) {\nraw = pos + pattern.length();\nfound = true;\nbreak;\n}\n}\nif (!found) {\nbreak;\n}\n}\nreturn raw;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void this_task_debug_info(std::ostream&amp; out)\n{\nprint_debug_info(DebugInfoFrame::top(), out);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const bool kTaskDebugInfoSegvCallbackInstalled = [] {\nextra_segv_debug_info_callback() = &amp;this_task_debug_info;\nreturn true;\n}();\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_DEBUG_INFO_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/decay_8hpp/","title":"batteries/seq/decay.hpp","text":""},{"location":"_autogen/Files/decay_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/decay_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::DecayItem"},{"location":"_autogen/Files/decay_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_DECAY_HPP"},{"location":"_autogen/Files/decay_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/decay_8hpp/#define-batteries_seq_decay_hpp","title":"define BATTERIES_SEQ_DECAY_HPP","text":"<pre><code>#define BATTERIES_SEQ_DECAY_HPP()\n</code></pre>"},{"location":"_autogen/Files/decay_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_DECAY_HPP\n#define BATTERIES_SEQ_DECAY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/map.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// decayed\n//\nstruct DecayItem {\ntemplate &lt;typename T&gt;\nstd::decay_t&lt;T&gt; operator()(T&amp;&amp; val) const\n{\nreturn BATT_FORWARD(val);\n}\n};\ninline auto decayed()\n{\nreturn map(DecayItem{});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_DECAY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/deref_8hpp/","title":"batteries/seq/deref.hpp","text":""},{"location":"_autogen/Files/deref_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/deref_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::Deref"},{"location":"_autogen/Files/deref_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_DEREF_HPP"},{"location":"_autogen/Files/deref_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/deref_8hpp/#define-batteries_seq_deref_hpp","title":"define BATTERIES_SEQ_DEREF_HPP","text":"<pre><code>#define BATTERIES_SEQ_DEREF_HPP()\n</code></pre>"},{"location":"_autogen/Files/deref_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_DEREF_HPP\n#define BATTERIES_SEQ_DEREF_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/map.hpp&gt;\nnamespace batt {\nnamespace seq {\nstruct Deref {\ntemplate &lt;typename T&gt;\nauto operator()(T&amp;&amp; val) const\n{\nreturn *val;\n}\n};\ninline auto deref()\n{\nreturn map(Deref{});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_DEREF_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dir_0985703d1fb34e0edc7cc330d020d62d/","title":"batteries/seq","text":""},{"location":"_autogen/Files/dir_0985703d1fb34e0edc7cc330d020d62d/#files","title":"Files","text":"Name batteries/seq/addition.hpp batteries/seq/all_true.hpp batteries/seq/any_true.hpp batteries/seq/apply.hpp batteries/seq/attach.hpp batteries/seq/boxed.hpp batteries/seq/cache_next.hpp batteries/seq/chain.hpp batteries/seq/collect.hpp batteries/seq/collect_vec.hpp batteries/seq/consume.hpp batteries/seq/count.hpp batteries/seq/decay.hpp batteries/seq/deref.hpp batteries/seq/emplace_back.hpp batteries/seq/empty.hpp batteries/seq/filter.hpp batteries/seq/filter_map.hpp batteries/seq/first.hpp batteries/seq/flatten.hpp batteries/seq/for_each.hpp batteries/seq/fuse.hpp batteries/seq/group_by.hpp batteries/seq/inner_reduce.hpp batteries/seq/inspect.hpp batteries/seq/inspect_adjacent.hpp batteries/seq/is_sorted.hpp batteries/seq/kmerge.hpp batteries/seq/last.hpp batteries/seq/lazy.hpp batteries/seq/loop_control.hpp batteries/seq/map.hpp batteries/seq/map_adjacent.hpp batteries/seq/map_fold.hpp batteries/seq/map_pairwise.hpp batteries/seq/merge_by.hpp batteries/seq/natural_equals.hpp batteries/seq/natural_order.hpp batteries/seq/prepend.hpp batteries/seq/print_out.hpp batteries/seq/printable.hpp batteries/seq/product.hpp batteries/seq/reduce.hpp batteries/seq/requirements.hpp batteries/seq/reverse.hpp batteries/seq/rolling.hpp batteries/seq/rolling_sum.hpp batteries/seq/seq_item.hpp batteries/seq/skip_n.hpp batteries/seq/splice.hpp batteries/seq/status_ok.hpp batteries/seq/sub_range_seq.hpp batteries/seq/sum.hpp batteries/seq/take_n.hpp batteries/seq/take_while.hpp batteries/seq/zip.hpp <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dir_23237b2d5d682108d256c42b41036300/","title":"batteries/algo","text":""},{"location":"_autogen/Files/dir_23237b2d5d682108d256c42b41036300/#files","title":"Files","text":"Name batteries/algo/parallel_accumulate.hpp batteries/algo/parallel_copy.hpp batteries/algo/parallel_merge.hpp batteries/algo/parallel_running_total.hpp batteries/algo/parallel_transform.hpp batteries/algo/running_total.cpp batteries/algo/running_total.hpp batteries/algo/running_total_impl.hpp <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/dir_5ba863940ce6067bb787d1b849676df9/","title":"batteries/metrics","text":""},{"location":"_autogen/Files/dir_5ba863940ce6067bb787d1b849676df9/#files","title":"Files","text":"Name batteries/metrics/metric_collectors.hpp batteries/metrics/metric_collectors_impl.hpp batteries/metrics/metric_csv_formatter.cpp batteries/metrics/metric_csv_formatter.hpp batteries/metrics/metric_csv_formatter_impl.hpp batteries/metrics/metric_dumper.cpp batteries/metrics/metric_dumper.hpp batteries/metrics/metric_dumper_impl.hpp batteries/metrics/metric_formatter.hpp batteries/metrics/metric_formatter_impl.hpp batteries/metrics/metric_otel_formatter.cpp batteries/metrics/metric_otel_formatter.hpp batteries/metrics/metric_otel_formatter_impl.hpp batteries/metrics/metric_registry.cpp batteries/metrics/metric_registry.hpp batteries/metrics/metric_registry_impl.hpp batteries/metrics/prometheus_exporter.hpp <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dir_8bf407c613839f4cc467ff11f969a954/","title":"batteries/asio","text":""},{"location":"_autogen/Files/dir_8bf407c613839f4cc467ff11f969a954/#files","title":"Files","text":"Name batteries/asio/any_io_executor.hpp batteries/asio/deadline_timer.hpp batteries/asio/execution_context.hpp batteries/asio/io_context.hpp batteries/asio/ip_tcp.hpp batteries/asio/post.hpp batteries/asio/system_executor.hpp <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/","title":"batteries/http","text":""},{"location":"_autogen/Files/dir_9b7f6a4fee6d4e32025f5ad2daa53829/#files","title":"Files","text":"Name batteries/http/host_address.hpp batteries/http/http_chunk_decoder.hpp batteries/http/http_chunk_encoder.hpp batteries/http/http_client.cpp batteries/http/http_client.hpp batteries/http/http_client_connection.cpp batteries/http/http_client_connection.hpp batteries/http/http_client_connection_decl.hpp batteries/http/http_client_connection_impl.hpp batteries/http/http_client_host_context.cpp batteries/http/http_client_host_context.hpp batteries/http/http_client_host_context_decl.hpp batteries/http/http_client_host_context_impl.hpp batteries/http/http_client_impl.hpp batteries/http/http_data.hpp batteries/http/http_header.hpp batteries/http/http_message_base.hpp batteries/http/http_message_info.cpp batteries/http/http_message_info.hpp batteries/http/http_message_info_decl.hpp batteries/http/http_message_info_impl.hpp batteries/http/http_request.hpp batteries/http/http_response.hpp batteries/http/http_server.cpp batteries/http/http_server.hpp batteries/http/http_server_connection.cpp batteries/http/http_server_connection.hpp batteries/http/http_server_connection_decl.hpp batteries/http/http_server_connection_impl.hpp batteries/http/http_server_decl.hpp batteries/http/http_server_impl.hpp batteries/http/http_server_settings.cpp batteries/http/http_server_settings.hpp batteries/http/http_server_settings_decl.hpp batteries/http/http_server_settings_impl.hpp batteries/http/http_version.hpp batteries/http/ssl_transport.cpp batteries/http/ssl_transport.hpp batteries/http/ssl_transport_impl.hpp batteries/http/tcp_transport.hpp <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/dir_a632bc4ac9c412aedbec832ef7391aeb/","title":"batteries/state_machine_model","text":""},{"location":"_autogen/Files/dir_a632bc4ac9c412aedbec832ef7391aeb/#files","title":"Files","text":"Name batteries/state_machine_model/advanced_options.hpp batteries/state_machine_model/entropy_source.hpp batteries/state_machine_model/exhaustive_model_checker.hpp batteries/state_machine_model/parallel_model_check_state.hpp batteries/state_machine_model/state_machine_result.hpp batteries/state_machine_model/state_machine_traits.hpp batteries/state_machine_model/stochastic_model_checker.hpp batteries/state_machine_model/verbose.hpp <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dir_ad31cac107356ba3b876e0559a878901/","title":"batteries/protobuf","text":""},{"location":"_autogen/Files/dir_ad31cac107356ba3b876e0559a878901/#files","title":"Files","text":"Name batteries/protobuf/stream_buffer_input_stream.hpp batteries/protobuf/stream_buffer_output_stream.hpp <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/","title":"batteries","text":""},{"location":"_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#directories","title":"Directories","text":"Name batteries/algo batteries/asio batteries/async batteries/http batteries/metrics batteries/pico_http batteries/protobuf batteries/seq batteries/state_machine_model"},{"location":"_autogen/Files/dir_af4e2857c92a31b60ebae85174ebeccb/#files","title":"Files","text":"Name batteries/assert.cpp batteries/assert.hpp batteries/assert_impl.hpp batteries/atomic_counter_gauge.hpp batteries/bool_status.hpp batteries/bounds.hpp batteries/buffer.hpp batteries/case_of.hpp batteries/checked_cast.hpp batteries/compare.hpp batteries/config.hpp batteries/constants.hpp batteries/cpu_align.hpp batteries/do_nothing.hpp batteries/endian.hpp batteries/env.hpp batteries/finally.hpp batteries/hash.hpp batteries/hint.hpp batteries/instance_counter.hpp batteries/int_types.hpp batteries/interval.hpp batteries/interval_traits.hpp batteries/logging.hpp batteries/make_printable.hpp batteries/math.hpp batteries/no_destruct.hpp batteries/nullable.hpp batteries/operators.hpp batteries/optional.hpp batteries/pointers.hpp batteries/radix_queue.hpp batteries/ref.hpp batteries/require.hpp batteries/segv.hpp batteries/seq.hpp batteries/shared_ptr.hpp batteries/skip_list.hpp batteries/slice.hpp batteries/small_fn.hpp batteries/small_vec.hpp batteries/stacktrace.hpp batteries/state_machine_model.hpp batteries/static_assert.hpp batteries/static_dispatch.hpp batteries/status.cpp batteries/status.hpp batteries/status_impl.hpp batteries/stream_util.hpp batteries/strict.hpp batteries/strong_typedef.hpp batteries/suppress.hpp batteries/syscall_retry.hpp batteries/token.hpp batteries/tuples.hpp batteries/type_erasure.hpp batteries/type_traits.hpp batteries/url_parse.hpp batteries/utility.hpp <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/dir_c14a1d4d12bee09dc523319537c13e97/","title":"batteries/pico_http","text":""},{"location":"_autogen/Files/dir_c14a1d4d12bee09dc523319537c13e97/#files","title":"Files","text":"Name batteries/pico_http/parser.cpp batteries/pico_http/parser.hpp batteries/pico_http/parser_decl.hpp batteries/pico_http/parser_impl.hpp <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dir_faaa2176564b41e79cedcf3028f42662/","title":"batteries/async","text":""},{"location":"_autogen/Files/dir_faaa2176564b41e79cedcf3028f42662/#files","title":"Files","text":"Name batteries/async/async_run_task.hpp batteries/async/backoff.cpp batteries/async/backoff.hpp batteries/async/backoff_decl.hpp batteries/async/backoff_impl.hpp batteries/async/basic_executor.hpp batteries/async/buffer_source.cpp batteries/async/buffer_source.hpp batteries/async/buffer_source_impl.hpp batteries/async/buffered_channel.hpp batteries/async/cancel_token.cpp batteries/async/cancel_token.hpp batteries/async/cancel_token_impl.hpp batteries/async/channel.hpp batteries/async/continuation.hpp batteries/async/debug_info.cpp batteries/async/debug_info.hpp batteries/async/debug_info_decl.hpp batteries/async/debug_info_impl.hpp batteries/async/dump_tasks.hpp batteries/async/fake_execution_context.cpp batteries/async/fake_execution_context.hpp batteries/async/fake_execution_context_decl.hpp batteries/async/fake_execution_context_impl.hpp batteries/async/fake_executor.cpp batteries/async/fake_executor.hpp batteries/async/fake_executor_decl.hpp batteries/async/fake_executor_impl.hpp batteries/async/fake_task_scheduler.hpp batteries/async/fake_time_service.cpp batteries/async/fake_time_service.hpp batteries/async/fake_time_service_decl.hpp batteries/async/fake_time_service_impl.hpp batteries/async/fetch.hpp batteries/async/futex.hpp batteries/async/future.cpp batteries/async/future.hpp batteries/async/future_decl.hpp batteries/async/future_impl.hpp batteries/async/grant.hpp batteries/async/handler.hpp batteries/async/inline_sub_task.hpp batteries/async/io_result.hpp batteries/async/latch.cpp batteries/async/latch.hpp batteries/async/latch_decl.hpp batteries/async/latch_impl.hpp batteries/async/lazy_latch.cpp batteries/async/lazy_latch.hpp batteries/async/lazy_latch_decl.hpp batteries/async/lazy_latch_impl.hpp batteries/async/mcs_lock.hpp batteries/async/mutex.cpp batteries/async/mutex.hpp batteries/async/mutex_impl.hpp batteries/async/pin.hpp batteries/async/preallocated_task.hpp batteries/async/priority_watch.hpp batteries/async/queue.hpp batteries/async/rate_limiter.hpp batteries/async/read_write_lock.hpp batteries/async/runtime.hpp batteries/async/scalable_grant.cpp batteries/async/scalable_grant.hpp batteries/async/scalable_grant_impl.hpp batteries/async/simple_executor.cpp batteries/async/simple_executor.hpp batteries/async/simple_executor_impl.hpp batteries/async/single_thread_executor.hpp batteries/async/slice_work.cpp batteries/async/slice_work.hpp batteries/async/slice_work_impl.hpp batteries/async/spin_grant.cpp batteries/async/spin_grant.hpp batteries/async/spin_grant_decl.hpp batteries/async/spin_grant_impl.hpp batteries/async/stream_buffer.cpp batteries/async/stream_buffer.hpp batteries/async/stream_buffer_impl.hpp batteries/async/task.cpp batteries/async/task.hpp batteries/async/task_decl.hpp batteries/async/task_impl.hpp batteries/async/task_scheduler.hpp batteries/async/types.hpp batteries/async/watch.cpp batteries/async/watch.hpp batteries/async/watch_decl.hpp batteries/async/watch_impl.hpp batteries/async/work_context.cpp batteries/async/work_context.hpp batteries/async/work_context_impl.hpp batteries/async/worker.hpp batteries/async/worker_pool.cpp batteries/async/worker_pool.hpp batteries/async/worker_pool_impl.hpp <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/do__nothing_8hpp/","title":"batteries/do_nothing.hpp","text":""},{"location":"_autogen/Files/do__nothing_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/do__nothing_8hpp/#classes","title":"Classes","text":"Name struct batt::DoNothing"},{"location":"_autogen/Files/do__nothing_8hpp/#defines","title":"Defines","text":"Name BATTERIES_DO_NOTHING_HPP"},{"location":"_autogen/Files/do__nothing_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/do__nothing_8hpp/#define-batteries_do_nothing_hpp","title":"define BATTERIES_DO_NOTHING_HPP","text":"<pre><code>#define BATTERIES_DO_NOTHING_HPP()\n</code></pre>"},{"location":"_autogen/Files/do__nothing_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_DO_NOTHING_HPP\n#define BATTERIES_DO_NOTHING_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\ntemplate &lt;typename... Args&gt;\nconstexpr void do_nothing(Args&amp;&amp;...) noexcept\n{\n}\nstruct DoNothing {\nusing result_type = void;\ntemplate &lt;typename... Args&gt;\nvoid operator()(Args&amp;&amp;...) const noexcept\n{\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_DO_NOTHING_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/dump__tasks_8hpp/","title":"batteries/async/dump_tasks.hpp","text":""},{"location":"_autogen/Files/dump__tasks_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/dump__tasks_8hpp/#classes","title":"Classes","text":"Name class batt::detail::SigInfoHandler"},{"location":"_autogen/Files/dump__tasks_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_DUMP_TASKS_HPP"},{"location":"_autogen/Files/dump__tasks_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/dump__tasks_8hpp/#define-batteries_async_dump_tasks_hpp","title":"define BATTERIES_ASYNC_DUMP_TASKS_HPP","text":"<pre><code>#define BATTERIES_ASYNC_DUMP_TASKS_HPP()\n</code></pre>"},{"location":"_autogen/Files/dump__tasks_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_DUMP_TASKS_HPP\n#define BATTERIES_ASYNC_DUMP_TASKS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;boost/asio/executor_work_guard.hpp&gt;\n#include &lt;boost/asio/io_context.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/signal_set.hpp&gt;\n#include &lt;boost/exception/diagnostic_information.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;thread&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace detail {\nclass SigInfoHandler\n{\npublic:\nstatic constexpr int kSignalNum =\n#if defined(BATT_PLATFORM_IS_LINUX)\nSIGUSR1\n#elif defined(BATT_PLATFORM_IS_APPLE)\nSIGINFO\n#else\n0\n#endif\n;\nusing WorkGuard =\nbatt::Optional&lt;boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;&gt;;\nstatic SigInfoHandler&amp; instance()\n{\nstatic std::aligned_storage_t&lt;sizeof(SigInfoHandler)&gt; storage_;\nstatic SigInfoHandler* instance_ = [] {\ntry {\nreturn new (&amp;storage_) SigInfoHandler;\n} catch (...) {\nBATT_PANIC() &lt;&lt; boost::current_exception_diagnostic_information();\nBATT_UNREACHABLE();\n}\n}();\nreturn *instance_;\n}\nSigInfoHandler()\n{\nthis-&gt;sig_info_thread_.detach();\n}\nvoid start()\n{\nBATT_CHECK(this-&gt;sig_info_);\n#ifdef BATT_PLATFORM_IS_WINDOWS\nBATT_LOG_WARNING() &lt;&lt; \"Signal handling not yet supported on Windows\";\n#else   // BATT_PLATFORM_IS_WINDOWS\nthis-&gt;wait_for_signal();\n#endif  // BATT_PLATFORM_IS_WINDOWS\n}\nvoid halt()\n{\nconst bool halted_prior = this-&gt;halted_.exchange(true);\nif (halted_prior) {\nreturn;\n}\n#ifndef BATT_PLATFORM_IS_WINDOWS\n{\nbatt::ErrorCode ec;\nthis-&gt;sig_info_-&gt;cancel(ec);\n}\n#endif  // BATT_PLATFORM_IS_WINDOWS\nthis-&gt;sig_info_work_guard_ = None;\nthis-&gt;sig_info_io_.stop();\nBATT_LOG_INFO() &lt;&lt; \"signal handlers cancelled\";\n}\nvoid join()\n{\nif (this-&gt;sig_info_thread_.joinable()) {\nthis-&gt;sig_info_thread_.join();\n}\n}\nvoid wait_for_signal()\n{\nthis-&gt;last_sig_info_ = std::chrono::steady_clock::now();\nthis-&gt;sig_info_-&gt;async_wait([this](auto&amp;&amp;... args) {\nreturn this-&gt;handle_signal(BATT_FORWARD(args)...);\n});\n}\nvoid handle_signal(const boost::system::error_code&amp; ec, int signal_n)\n{\nif (ec || this-&gt;halted_.load()) {\nreturn;\n}\nusing namespace std::literals::chrono_literals;\nconst bool force = (std::chrono::steady_clock::now() - this-&gt;last_sig_info_) &lt;= 5s;\nstd::cerr &lt;&lt; \"[batt::SigInfoHandler::operator()(\" &lt;&lt; signal_n &lt;&lt; \"); force=\" &lt;&lt; force &lt;&lt; \"]\"\n&lt;&lt; std::endl;\nbatt::Task::backtrace_all(force);\nthis-&gt;last_sig_info_ = std::chrono::steady_clock::now();\nthis-&gt;wait_for_signal();\n}\nprivate:\nstd::atomic&lt;bool&gt; halted_{false};\nboost::asio::io_context sig_info_io_;\nOptional&lt;WorkGuard&gt; sig_info_work_guard_{this-&gt;sig_info_io_.get_executor()};\nOptional&lt;boost::asio::signal_set&gt; sig_info_{this-&gt;sig_info_io_, SigInfoHandler::kSignalNum};\nstd::chrono::steady_clock::time_point last_sig_info_ = std::chrono::steady_clock::now();\nstd::thread sig_info_thread_{[this] {\nthis-&gt;sig_info_io_.run();\n}};\n};\n}  // namespace detail\ninline bool enable_dump_tasks()\n{\nstatic bool initialized_ = [] {\n#ifdef BATT_PLATFORM_IS_WINDOWS\nBATT_LOG_WARNING() &lt;&lt; \"Signal handling not yet supported on Windows\";\n#else   // BATT_PLATFORM_IS_WINDOWS\ndetail::SigInfoHandler::instance().start();\n#endif  // BATT_PLATFORM_IS_WINDOWS\nreturn true;\n}();\nreturn initialized_;\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_DUMP_TASKS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/emplace__back_8hpp/","title":"batteries/seq/emplace_back.hpp","text":""},{"location":"_autogen/Files/emplace__back_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/emplace__back_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_EMPLACE_BACK_HPP"},{"location":"_autogen/Files/emplace__back_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/emplace__back_8hpp/#define-batteries_seq_emplace_back_hpp","title":"define BATTERIES_SEQ_EMPLACE_BACK_HPP","text":"<pre><code>#define BATTERIES_SEQ_EMPLACE_BACK_HPP()\n</code></pre>"},{"location":"_autogen/Files/emplace__back_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_EMPLACE_BACK_HPP\n#define BATTERIES_SEQ_EMPLACE_BACK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// emplace_back\ntemplate &lt;typename Container&gt;\ninline auto emplace_back(Container* dst)\n{\nreturn for_each([dst](auto&amp;&amp; item) {\ndst-&gt;emplace_back(BATT_FORWARD(item));\n});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_EMPLACE_BACK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/empty_8hpp/","title":"batteries/seq/empty.hpp","text":""},{"location":"_autogen/Files/empty_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/empty_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Empty"},{"location":"_autogen/Files/empty_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_EMPTY_HPP"},{"location":"_autogen/Files/empty_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/empty_8hpp/#define-batteries_seq_empty_hpp","title":"define BATTERIES_SEQ_EMPTY_HPP","text":"<pre><code>#define BATTERIES_SEQ_EMPTY_HPP()\n</code></pre>"},{"location":"_autogen/Files/empty_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_EMPTY_HPP\n#define BATTERIES_SEQ_EMPTY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nclass Empty\n{\npublic:\nusing Item = T;\nOptional&lt;T&gt; peek()\n{\nreturn None;\n}\nOptional&lt;T&gt; next()\n{\nreturn None;\n}\n};\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_EMPTY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/endian_8hpp/","title":"batteries/endian.hpp","text":""},{"location":"_autogen/Files/endian_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/endian_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ENDIAN_HPP BATT_DEFINE_BIG_ENDIAN_LESS_THAN(bits)"},{"location":"_autogen/Files/endian_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/endian_8hpp/#define-batteries_endian_hpp","title":"define BATTERIES_ENDIAN_HPP","text":"<pre><code>#define BATTERIES_ENDIAN_HPP()\n</code></pre>"},{"location":"_autogen/Files/endian_8hpp/#define-batt_define_big_endian_less_than","title":"define BATT_DEFINE_BIG_ENDIAN_LESS_THAN","text":"<pre><code>#define BATT_DEFINE_BIG_ENDIAN_LESS_THAN(bits)\n</code></pre>"},{"location":"_autogen/Files/endian_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ENDIAN_HPP\n#define BATTERIES_ENDIAN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/endian/conversion.hpp&gt;\n#include &lt;boost/preprocessor/cat.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;int kBits&gt;\nstruct ByteSwap;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// GCC, Clang\n//\n#if BATT_COMPILER_IS_GCC || BATT_COMPILER_IS_CLANG\ntemplate &lt;&gt;\nstruct ByteSwap&lt;16&gt; {\nBATT_ALWAYS_INLINE u16 operator()(u16 value) const\n{\nreturn __builtin_bswap16(value);\n}\n};\ntemplate &lt;&gt;\nstruct ByteSwap&lt;32&gt; {\nBATT_ALWAYS_INLINE u32 operator()(u32 value) const\n{\nreturn __builtin_bswap32(value);\n}\n};\ntemplate &lt;&gt;\nstruct ByteSwap&lt;64&gt; {\nBATT_ALWAYS_INLINE u64 operator()(u64 value) const\n{\nreturn __builtin_bswap64(value);\n}\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// MSVC\n//\n#elif BATT_COMPILER_IS_MSVC\ntemplate &lt;&gt;\nstruct ByteSwap&lt;16&gt; {\nBATT_ALWAYS_INLINE u16 operator()(u16 value) const\n{\nreturn _byteswap_ushort(value);\n}\n};\ntemplate &lt;&gt;\nstruct ByteSwap&lt;32&gt; {\nBATT_ALWAYS_INLINE u32 operator()(u32 value) const\n{\nreturn _byteswap_ulong(value);\n}\n};\ntemplate &lt;&gt;\nstruct ByteSwap&lt;64&gt; {\nBATT_ALWAYS_INLINE u64 operator()(u64 value) const\n{\nreturn _byteswap_uint64(value);\n}\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#else\n#error Please define ByteSwap for your compiler!\n#endif\n#define BATT_DEFINE_BIG_ENDIAN_LESS_THAN(bits)                                                               \\\n    inline bool big_endian_less_than(BOOST_PP_CAT(u, bits) a, BOOST_PP_CAT(u, bits) b)                       \\\n    {                                                                                                        \\\n        if (boost::endian::order::little == boost::endian::order::native) {                                  \\\n            return ByteSwap&lt;bits&gt;{}(a) &lt; ByteSwap&lt;bits&gt;{}(b);                                                \\\n        }                                                                                                    \\\n        return a &lt; b;                                                                                        \\\n    }\nBATT_DEFINE_BIG_ENDIAN_LESS_THAN(16)\nBATT_DEFINE_BIG_ENDIAN_LESS_THAN(32)\nBATT_DEFINE_BIG_ENDIAN_LESS_THAN(64)\n#undef BATT_DEFINE_BIG_ENDIAN_LESS_THAN\n}  //namespace batt\n#endif  // BATTERIES_ENDIAN_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/entropy__source_8hpp/","title":"batteries/state_machine_model/entropy_source.hpp","text":""},{"location":"_autogen/Files/entropy__source_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/entropy__source_8hpp/#classes","title":"Classes","text":"Name class batt::BasicStateMachineEntropySource"},{"location":"_autogen/Files/entropy__source_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP"},{"location":"_autogen/Files/entropy__source_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/entropy__source_8hpp/#define-batteries_state_machine_model_entropy_source_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP()\n</code></pre>"},{"location":"_autogen/Files/entropy__source_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/fake_executor.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/static_dispatch.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;initializer_list&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\nnamespace batt {\n// Forward-declaration.\n//\ntemplate &lt;typename Fn&gt;\nclass BasicStateMachineEntropySource;\n// A type-erased entropy source.\n//\nusing StateMachineEntropySource =\nBasicStateMachineEntropySource&lt;std::function&lt;usize(usize min_value, usize max_value)&gt;&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename Fn&gt;\nclass BasicStateMachineEntropySource\n{\npublic:\nusing PickIntFn = Fn;\n// Allow default construction if `Fn` permits.\n//\nBasicStateMachineEntropySource() = default;\n// Constructs a new entropy source from the given `pick_int` function.\n//\nexplicit BasicStateMachineEntropySource(PickIntFn&amp;&amp; pick_int_fn) noexcept\n: pick_int_{BATT_FORWARD(pick_int_fn)}\n{\n}\n// Returns an integer `i` non-deterministically, such that `i &gt;= min_value &amp;&amp; i &lt;= max_value`.\n//\nusize pick_int(usize min_value, usize max_value) const\n{\nreturn this-&gt;pick_int_(min_value, max_value);\n}\n// Returns false or true.\n//\nbool pick_branch() const\n{\nreturn this-&gt;pick_int(0, 1) == 0;\n}\n// Returns one of the items in `values`, using `pick_int`.\n//\ntemplate &lt;typename T&gt;\nT pick_one_of(std::initializer_list&lt;T&gt; values) const\n{\nconst usize index = this-&gt;pick_int(0, values.size() - 1);\nreturn *(values.begin() + index);\n}\n// If there is at least one runnable completion handler in `context`, one such handler is selected (via\n// `pick_int`) and invoked, and this function returns true.  Else false is returned.\n//\nbool run_one(FakeExecutionContext&amp; context) const\n{\nUniqueHandler&lt;&gt; handler = context.pop_ready_handler([this](usize count) {\nreturn this-&gt;pick_int(0, count - 1);\n});\nif (!handler) {\nreturn false;\n}\nhandler();\nreturn true;\n}\n// Performs one of the passed action functions.  Each `Fn` in `actions...` must be callable with no\n// arguments and its return type must be ignorable.\n//\ntemplate &lt;typename... ActionFn&gt;\nvoid do_one_of(ActionFn&amp;&amp;... actions) const\n{\nauto actions_tuple = std::forward_as_tuple(BATT_FORWARD(actions)...);\nstatic_dispatch&lt;usize, 0, sizeof...(ActionFn)&gt;(\nthis-&gt;pick_int(0, sizeof...(ActionFn) - 1), [&amp;](auto kI) {\nstd::get&lt;decltype(kI)::value&gt;(std::move(actions_tuple))();\n});\n}\nprivate:\nPickIntFn pick_int_;\n};\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_ENTROPY_SOURCE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/env_8hpp/","title":"batteries/env.hpp","text":""},{"location":"_autogen/Files/env_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/env_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ENV_HPP"},{"location":"_autogen/Files/env_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/env_8hpp/#define-batteries_env_hpp","title":"define BATTERIES_ENV_HPP","text":"<pre><code>#define BATTERIES_ENV_HPP()\n</code></pre>"},{"location":"_autogen/Files/env_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ENV_HPP\n#define BATTERIES_ENV_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;cstddef&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nOptional&lt;T&gt; getenv_as(const char* var_name)\n{\nBATT_VLOG(1) &lt;&lt; \"reading env variable '\" &lt;&lt; var_name &lt;&lt; \"'\";\nconst char* var_value = std::getenv(var_name);\nif (var_value == nullptr) {\nBATT_VLOG(1) &lt;&lt; \"... not set\";\nreturn None;\n}\nauto result = batt::from_string&lt;T&gt;(var_value);\nBATT_VLOG(1) &lt;&lt; \"... value is '\" &lt;&lt; var_value &lt;&lt; \"'; parsing as \" &lt;&lt; typeid(T).name() &lt;&lt; \" == \" &lt;&lt; result;\nreturn result;\n}\n}  // namespace batt\n#endif  // BATTERIES_ENV_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/execution__context_8hpp/","title":"batteries/asio/execution_context.hpp","text":""},{"location":"_autogen/Files/execution__context_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_EXECUTION_CONTEXT_HPP"},{"location":"_autogen/Files/execution__context_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/execution__context_8hpp/#define-batteries_asio_execution_context_hpp","title":"define BATTERIES_ASIO_EXECUTION_CONTEXT_HPP","text":"<pre><code>#define BATTERIES_ASIO_EXECUTION_CONTEXT_HPP()\n</code></pre>"},{"location":"_autogen/Files/execution__context_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASIO_EXECUTION_CONTEXT_HPP\n#define BATTERIES_ASIO_EXECUTION_CONTEXT_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_GCC(\"-Woverloaded-virtual\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/execution_context.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_EXECUTION_CONTEXT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/","title":"batteries/state_machine_model/exhaustive_model_checker.hpp","text":""},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#classes","title":"Classes","text":"Name struct batt::StateMachineBranch class batt::ExhaustiveModelChecker"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#define-batteries_state_machine_model_exhaustive_model_checker_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP()\n</code></pre>"},{"location":"_autogen/Files/exhaustive__model__checker_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/state_machine_model/advanced_options.hpp&gt;\n#include &lt;batteries/state_machine_model/parallel_model_check_state.hpp&gt;\n#include &lt;batteries/state_machine_model/state_machine_result.hpp&gt;\n#include &lt;batteries/state_machine_model/state_machine_traits.hpp&gt;\n#include &lt;batteries/state_machine_model/verbose.hpp&gt;\n#include &lt;batteries/radix_queue.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename StateT, typename StateHash, typename StateEqual&gt;\nstruct StateMachineBranch {\nusing state_type = StateT;\nusing state_hash_type = StateHash;\nusing state_equal_type = StateEqual;\nusing delta_type = RadixQueue&lt;StateMachineTraits&lt;StateT&gt;::kRadixQueueSize&gt;;\nstate_type snapshot;\ndelta_type delta;\n};\ntemplate &lt;typename StateT, typename StateHash, typename StateEqual&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const StateMachineBranch&lt;StateT, StateHash, StateEqual&gt;&amp; t)\n{\nreturn out &lt;&lt; \"Branch{\" &lt;&lt; std::endl\n&lt;&lt; pretty_print_indent() &lt;&lt; \".snapshot=\" &lt;&lt; make_printable(t.snapshot) &lt;&lt; \",\" &lt;&lt; std::endl\n&lt;&lt; pretty_print_indent() &lt;&lt; \".delta=\" &lt;&lt; t.delta &lt;&lt; \",\" &lt;&lt; std::endl\n&lt;&lt; \"}\";\n}\ntemplate &lt;typename StateT, typename StateHash, typename StateEqual&gt;\ninline bool operator==(const StateMachineBranch&lt;StateT, StateHash, StateEqual&gt;&amp; l,\nconst StateMachineBranch&lt;StateT, StateHash, StateEqual&gt;&amp; r)\n{\nreturn StateEqual{}(l.snapshot, r.snapshot) &amp;&amp; l.delta == r.delta;\n}\ntemplate &lt;typename StateT, typename StateHash, typename StateEqual&gt;\ninline usize hash_value(const StateMachineBranch&lt;StateT, StateHash, StateEqual&gt;&amp; branch)\n{\nreturn hash(StateHash{}(branch.snapshot), branch.delta);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename ModelT&gt;\nclass ExhaustiveModelChecker\n{\npublic:\nusing StateMachineModel = ModelT;\nusing Branch = typename StateMachineModel::Branch;\nusing StateT = typename StateMachineModel::state_type;\nusing Result = StateMachineResult;\nusing AdvancedOptions = StateMachineModelCheckAdvancedOptions;\nusing BranchDelta = typename Branch::delta_type;\nusing VisitResult = typename StateMachineModel::VisitResult;\nBATT_STRONG_TYPEDEF(bool, ForceSend);\nexplicit ExhaustiveModelChecker(StateMachineModel&amp; model, detail::ParallelModelCheckState&lt;Branch&gt;&amp; mesh,\nusize shard_i) noexcept;\n~ExhaustiveModelChecker() noexcept;\nResult run();\nusize pick_int(usize min_value, usize max_value);\nprivate:\nvoid explore(Branch&amp;&amp; branch, ForceSend force_send = ForceSend{false});\nvoid enter_loop(usize loop_counter);\nbool pop_next();\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStateMachineModel&amp; model_;\nconst AdvancedOptions options_ = this-&gt;model_.advanced_options();\ndetail::ParallelModelCheckState&lt;Branch&gt;&amp; mesh_;\nconst usize shard_i_;\nOptional&lt;Branch&gt; current_branch_;\nBranchDelta history_;\nstd::deque&lt;Branch&gt; queue_;\nResult result_;\nusize progress_reports_ = 0;\n};\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\ninline ExhaustiveModelChecker&lt;ModelT&gt;::ExhaustiveModelChecker(StateMachineModel&amp; model,\ndetail::ParallelModelCheckState&lt;Branch&gt;&amp; mesh,\nusize shard_i) noexcept\n: model_{model}\n, mesh_{mesh}\n, shard_i_{shard_i}\n{\nBATT_CHECK_GT(this-&gt;mesh_.shard_count, 0u);\nBATT_CHECK_LT(this-&gt;shard_i_, this-&gt;mesh_.shard_count);\nthis-&gt;model_.set_entropy(StateMachineEntropySource{[this](usize min_value, usize max_value) {\nreturn this-&gt;pick_int(min_value, max_value);\n}});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\ninline ExhaustiveModelChecker&lt;ModelT&gt;::~ExhaustiveModelChecker() noexcept\n{\nthis-&gt;model_.set_entropy(StateMachineEntropySource{});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\ninline usize ExhaustiveModelChecker&lt;ModelT&gt;::pick_int(usize min_value, usize max_value)\n{\nif (min_value == max_value) {\nreturn min_value;\n}\nBATT_CHECK_LT(min_value, max_value);\nconst usize radix = max_value - min_value + 1;\nif (!this-&gt;current_branch_-&gt;delta.empty()) {\nauto before = this-&gt;current_branch_-&gt;delta;\nconst usize value = this-&gt;current_branch_-&gt;delta.pop(radix);\nthis-&gt;history_.push(radix, value);\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \"pick_int(\" &lt;&lt; min_value &lt;&lt; \",\" &lt;&lt; max_value &lt;&lt; \") [delta=\" &lt;&lt; before\n&lt;&lt; \"] returning branch value: \" &lt;&lt; (min_value + value);\nreturn min_value + value;\n}\nfor (usize value = 1; value &lt; radix; ++value) {\nBranch to_explore{\n.snapshot = this-&gt;current_branch_-&gt;snapshot,\n.delta = this-&gt;history_,\n};\nto_explore.delta.push(radix, value);\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \"pick_int(\" &lt;&lt; min_value &lt;&lt; \",\" &lt;&lt; max_value &lt;&lt; \") -&gt; \" &lt;&lt; min_value\n&lt;&lt; \"; queuing new branch: \" &lt;&lt; (min_value + value)\n&lt;&lt; \" [delta=\" &lt;&lt; to_explore.delta &lt;&lt; \"]\";\nthis-&gt;explore(std::move(to_explore));\n}\nthis-&gt;history_.push(radix, /*value=*/0);\nreturn /*value=*/min_value;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\ninline void ExhaustiveModelChecker&lt;ModelT&gt;::explore(Branch&amp;&amp; branch, ForceSend force_send)\n{\nconst usize dst_i = this-&gt;mesh_.find_shard(branch);\n// Update cross-shard branch hit rate stats.\n//\nif (dst_i != this-&gt;shard_i_) {\nthis-&gt;result_.branch_miss_count += 1;\n}\nif (dst_i == this-&gt;shard_i_ &amp;&amp; !force_send) {\nthis-&gt;result_.branch_push_count += 1;\nthis-&gt;queue_.emplace_back(std::move(branch));\n} else {\nthis-&gt;mesh_.send(/*src_i=*/this-&gt;shard_i_, /*dst_i=*/dst_i, std::move(branch));\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\nvoid ExhaustiveModelChecker&lt;ModelT&gt;::enter_loop(usize loop_counter)\n{\n// Flush outbound queues to other shards periodically to try to prevent stalls.\n//\nif (((loop_counter + 1) % this-&gt;options_.max_loop_iterations_between_flush) == 0) {\nif (this-&gt;mesh_.shard_count &gt; 1) {\nthis-&gt;mesh_.flush_all(this-&gt;shard_i_);\n}\n}\n// Update elapsed time and send a progress report if necessary.\n//\nif (((loop_counter + 1) % this-&gt;options_.max_loop_iterations_between_update) == 0) {\nthis-&gt;result_.update_elapsed_time();\nconst double elapsed_seconds = double(this-&gt;result_.elapsed_ms) / 1000.0;\nconst usize required_reports = elapsed_seconds / this-&gt;model_.progress_report_interval_seconds();\nif (this-&gt;progress_reports_ &lt; required_reports) {\nthis-&gt;progress_reports_ += 1;\nthis-&gt;model_.report_progress(this-&gt;result_);\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\nbool ExhaustiveModelChecker&lt;ModelT&gt;::pop_next()\n{\nfor (;;) {\nwhile (this-&gt;queue_.empty()) {\nconst usize size_before = this-&gt;queue_.size();\nStatusOr&lt;usize&gt; n_recv = this-&gt;mesh_.recv(this-&gt;shard_i_, this-&gt;queue_);\nif (!n_recv.ok()) {\nif (n_recv.status() != batt::StatusCode::kClosed) {\nthis-&gt;result_.ok = false;\n}\nreturn false;\n}\nconst usize size_after = this-&gt;queue_.size();\nBATT_CHECK_EQ(size_before, 0u);\nBATT_CHECK_GT(*n_recv, 0u);\nBATT_CHECK_EQ(size_after - size_before, *n_recv);\n// Deduplicate incoming branches.\n//\nauto first_duplicate =\nstd::remove_if(this-&gt;queue_.begin(), this-&gt;queue_.end(), [&amp;](const Branch&amp; branch) {\nconst bool is_duplicate =\nbranch.delta.empty() &amp;&amp;\n(this-&gt;model_.visit(branch.snapshot, /*src_branch=*/Branch{}\n// TODO [tastolfi 2022-01-24] restore the trace history when\n// merging `visited_` sets at the end of a parallel run.\n) == VisitResult::kSeenBefore);\nreturn is_duplicate;\n});\nthis-&gt;queue_.erase(first_duplicate, this-&gt;queue_.end());\nthis-&gt;result_.branch_push_count += this-&gt;queue_.size();\n}\nBATT_CHECK(!this-&gt;queue_.empty());\nauto&amp; next_branch = this-&gt;queue_.front();\nconst usize branch_shard_i = this-&gt;mesh_.find_shard(next_branch);\nBATT_CHECK_EQ(branch_shard_i, this-&gt;shard_i_);\n// Pop the next branch of the state graph to explore.\n//\nthis-&gt;current_branch_ = std::move(next_branch);\nthis-&gt;history_.clear();\nthis-&gt;queue_.pop_front();\nthis-&gt;result_.branch_pop_count += 1;\nreturn true;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ModelT&gt;\nauto ExhaustiveModelChecker&lt;ModelT&gt;::run() -&gt; Result\n{\n// Clear current state.\n//\nthis-&gt;progress_reports_ = 0;\nthis-&gt;current_branch_ = None;\nthis-&gt;history_.clear();\nthis-&gt;model_.reset_visited_states();\nthis-&gt;queue_.clear();\n// Initialize new state and seed the BFS for model checking.\n//\n{\nStateT s = this-&gt;model_.normalize(this-&gt;model_.initialize());\nthis-&gt;explore(\nBranch{\n.snapshot = std::move(s),\n.delta = BranchDelta{},\n},\nForceSend{true});\n}\nthis-&gt;mesh_.flush_all(this-&gt;shard_i_);\nBATT_CHECK_OK(this-&gt;mesh_.wait_for_other_shards());\nBATT_CHECK_GT(this-&gt;mesh_.total_pending_count-&gt;load(), 0);\nthis-&gt;result_.ok = true;\nthis-&gt;result_.state_count = 1;\nthis-&gt;result_.start_time = std::chrono::steady_clock::now();\nconst auto notify_finished = finally([&amp;] {\nthis-&gt;mesh_.finished(this-&gt;shard_i_);\nthis-&gt;result_.update_elapsed_time();\nthis-&gt;model_.report_progress(this-&gt;result_);\n});\nfor (usize loop_counter = 0;; ++loop_counter) {\n// Perform top-of-loop maintenance tasks.\n//\nthis-&gt;enter_loop(loop_counter);\n// Pop the next branch off the queue (this may block on other shards if the local queue is empty).\n//\nif (!this-&gt;pop_next()) {\nbreak;\n}\n// Enter the new state.\n//\nthis-&gt;model_.enter_state(this-&gt;current_branch_-&gt;snapshot);\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \" branch=\" &lt;&lt; this-&gt;current_branch_-&gt;delta;\n// We should have already checked invariants for this state before enqueuing it for the first time\n// (and the initial state should always pass invariant checks), but one can never be too sure...\n//\nif (!this-&gt;model_.check_invariants()) {\nthis-&gt;result_.ok = false;\nbreak;\n}\n// Expand the \"out-edges\" of this node of the graph.\n//\nthis-&gt;model_.step();\n// Make sure the state machine hasn't violated any of its invariants.\n//\nif (!this-&gt;model_.check_invariants()) {\nthis-&gt;result_.ok = false;\nbreak;\n}\n// Grab the new state and normalize it.\n//\nStateT after = this-&gt;model_.normalize(this-&gt;model_.leave_state());\nif (after == this-&gt;current_branch_-&gt;snapshot) {\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \"(no state change) pruning self-branch\";\nthis-&gt;result_.self_branch_count += 1;\ncontinue;\n}\n// If this is the first time we are visiting the new state, add it to the queue and note how we\n// discovered it in the trace.\n//\nif (this-&gt;model_.visit(after, /*src_branch=*/Branch{\n.snapshot = this-&gt;current_branch_-&gt;snapshot,\n.delta = this-&gt;history_,\n}) == VisitResult::kFirstTime) {\nthis-&gt;result_.state_count += 1;\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \"new state discovered\";\n// This is the branch (or \"out-edge\") that represents choosing 0 for all non-deterministic\n// variables inside `step()`.  We added all the non-0 branches already inside\n// `pick_int`.\n//\nthis-&gt;explore(Branch{\n.snapshot = after,\n.delta = BranchDelta{},\n});\n} else {\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \"state already visited; pruning\";\n}\n}\nreturn this-&gt;result_;\n}\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_EXHAUSTIVE_MODEL_CHECKER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/fake__execution__context_8cpp/","title":"batteries/async/fake_execution_context.cpp","text":""},{"location":"_autogen/Files/fake__execution__context_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/fake_execution_context.hpp&gt;\n//\n#include &lt;batteries/async/fake_execution_context_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__execution__context_8hpp/","title":"batteries/async/fake_execution_context.hpp","text":""},{"location":"_autogen/Files/fake__execution__context_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/fake_execution_context_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/fake_execution_context_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/","title":"batteries/async/fake_execution_context_decl.hpp","text":""},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#classes","title":"Classes","text":"Name class batt::FakeExecutionContext struct batt::FakeExecutionContext::AlwaysReturnZero"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#define-batteries_async_fake_execution_context_decl_hpp","title":"define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__execution__context__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP\n#define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/asio/execution_context.hpp&gt;\n#include &lt;batteries/asio/system_executor.hpp&gt;\n#include &lt;batteries/async/fake_time_service_decl.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/watch_decl.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;vector&gt;\nnamespace batt {\ntemplate &lt;typename OutstandingWorkP&gt;\nclass BasicFakeExecutor;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// A drop-in replacement for boost::asio::io_context, suitable for fake-testing in unit tests.\n//\n// Unlike a \"real\" execution context, this class doesn't\n//\nclass FakeExecutionContext : public boost::asio::execution_context\n{\npublic:\ntemplate &lt;typename OutstandingWorkP&gt;\nfriend class BasicFakeExecutor;\nstruct AlwaysReturnZero {\nusize operator()(usize) const\n{\nreturn 0;\n}\n};\nusing executor_type = BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;;\nFakeExecutionContext() noexcept;\n~FakeExecutionContext() = default;\nexecutor_type get_executor();\n// The current work count.\n//\nWatch&lt;i64&gt;&amp; work_count();\n// Add a ready-to-run completion handler to the context.  This handler is never run automatically by the\n// FakeExecutionContext; it must be removed via `pop_ready_handler` and run by the client code.\n//\nvoid push_ready_handler(UniqueHandler&lt;&gt;&amp;&amp; handler);\n// Passes `picker` the current number of ready-to-run completion handlers for this executor; picker then\n// returns some non-negative integer smaller than this number.  This method then removes that handler from\n// the ready set and returns it.\n//\nUniqueHandler&lt;&gt; pop_ready_handler(const std::function&lt;usize(usize)&gt;&amp; picker = AlwaysReturnZero{});\n// Access the default allocator directly.\n//\nstd::allocator&lt;void&gt; get_allocator() const\n{\nreturn this-&gt;allocator_;\n}\n// Shortcut to pop an arbitrary ready handler and run it.\n//\nbool poll_one();\n// Shortcut to pop all ready handlers and run them.\n//\nusize poll();\n// Shortcut to wait for ready handlers and run them, while work count is &gt; 0.\n//\nusize run();\n// For compatibility with boost::asio::io_context.\n//\nvoid reset();\n// Creates a default pseudo-random number generator to select which handler should come next, and then run\n// with that event ordering.\n//\nusize run_with_random_seed(usize seed);\nprivate:\nWatch&lt;i64&gt; work_count_{0};\nWatch&lt;i64&gt; push_ready_count_{0};\nWatch&lt;i64&gt; pop_ready_count_{0};\nstd::allocator&lt;void&gt; allocator_;\nstd::mutex mutex_;\nstd::vector&lt;UniqueHandler&lt;&gt;&gt; ready_to_run_;\nFakeTimeService&amp; time_service_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/","title":"batteries/async/fake_execution_context_impl.hpp","text":""},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#define-batteries_async_fake_execution_context_impl_hpp","title":"define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__execution__context__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP\n#define BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/fake_execution_context_decl.hpp&gt;\n#include &lt;batteries/async/fake_executor.hpp&gt;\n#include &lt;batteries/async/fake_time_service.hpp&gt;\n#include &lt;random&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL FakeExecutionContext::FakeExecutionContext() noexcept\n: time_service_{boost::asio::make_service&lt;batt::FakeTimeService&gt;(*this)}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL FakeExecutor FakeExecutionContext::get_executor()\n{\nreturn FakeExecutor{this};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Watch&lt;i64&gt;&amp; FakeExecutionContext::work_count()\n{\nBATT_CHECK_GE(this-&gt;work_count_.get_value(), 0);\nreturn this-&gt;work_count_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void FakeExecutionContext::push_ready_handler(UniqueHandler&lt;&gt;&amp;&amp; handler)\n{\nif (!handler) {\nreturn;\n}\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;ready_to_run_.emplace_back(std::move(handler));\n}\nthis-&gt;push_ready_count_.fetch_add(1);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL UniqueHandler&lt;&gt; FakeExecutionContext::pop_ready_handler(\nconst std::function&lt;usize(usize)&gt;&amp; picker)\n{\nUniqueHandler&lt;&gt; popped_handler;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nif (this-&gt;ready_to_run_.empty()) {\nreturn UniqueHandler&lt;&gt;{};\n}\nconst usize next_i = picker(this-&gt;ready_to_run_.size());\nBATT_CHECK_LT(next_i, this-&gt;ready_to_run_.size());\npopped_handler = std::move(this-&gt;ready_to_run_[next_i]);\nif (next_i != this-&gt;ready_to_run_.size() - 1) {\nthis-&gt;ready_to_run_[next_i] = std::move(this-&gt;ready_to_run_.back());\n}\nthis-&gt;ready_to_run_.pop_back();\n}\nthis-&gt;pop_ready_count_.fetch_add(1);\nreturn popped_handler;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool FakeExecutionContext::poll_one()\n{\nUniqueHandler&lt;&gt; handler = this-&gt;pop_ready_handler([](usize) {\nreturn usize{0};\n});\nif (!handler) {\nreturn false;\n}\nhandler();\nreturn true;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize FakeExecutionContext::poll()\n{\nusize count = 0;\nwhile (this-&gt;poll_one()) {\ncount += 1;\n}\nreturn count;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize FakeExecutionContext::run()\n{\nBATT_PANIC() &lt;&lt; \"TODO [tastolfi 2022-01-19] implement me\";\nBATT_UNREACHABLE();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void FakeExecutionContext::reset()\n{\n// Nothing to do.\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize FakeExecutionContext::run_with_random_seed(usize seed)\n{\nusize count = 0;\nstd::default_random_engine rng{(unsigned)seed};\n// Prime the RNG so that the first values we use aren't obviously related to seed.\n//\nfor (usize primer = 0; primer &lt; sizeof(usize) * 8; ++primer) {\n(void)rng();\n}\nstd::uniform_int_distribution&lt;int&gt; pick_branch{0, 1};\nfor (;;) {\nOptional&lt;FakeTimeService::TimePoint&gt; next_timer_expires_at =\nthis-&gt;time_service_.next_expiration_time();\nif (next_timer_expires_at &amp;&amp; pick_branch(rng) == 1) {\nthis-&gt;time_service_.advance_time(*next_timer_expires_at - this-&gt;time_service_.now());\n} else {\nauto next = this-&gt;pop_ready_handler([&amp;](usize n) -&gt; usize {\nif (n == 0) {\nreturn 0;\n}\nstd::uniform_int_distribution&lt;usize&gt; pick_i{0, n - 1};\nreturn pick_i(rng);\n});\nif (!next &amp;&amp; !this-&gt;time_service_.has_scheduled_timers()) {\nbreak;\n}\nnext();\n}\n++count;\n}\nreturn count;\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_EXECUTION_CONTEXT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__executor_8cpp/","title":"batteries/async/fake_executor.cpp","text":""},{"location":"_autogen/Files/fake__executor_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/fake_executor.hpp&gt;\n//\n#include &lt;batteries/async/fake_executor_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__executor_8hpp/","title":"batteries/async/fake_executor.hpp","text":""},{"location":"_autogen/Files/fake__executor_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/fake_executor_decl.hpp&gt;\n//\n#include &lt;batteries/async/fake_executor.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/fake_executor_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__executor__decl_8hpp/","title":"batteries/async/fake_executor_decl.hpp","text":""},{"location":"_autogen/Files/fake__executor__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#classes","title":"Classes","text":"Name class batt::BasicFakeExecutor"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__executor__decl_8hpp/#define-batteries_async_fake_executor_decl_hpp","title":"define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__executor__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP\n#define BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/asio/any_io_executor.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;memory&gt;\nnamespace batt {\nclass FakeExecutionContext;\ntemplate &lt;typename OutstandingWorkP&gt;\nclass BasicFakeExecutor;\nusing FakeExecutor = BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename OutstandingWorkP&gt;\nconstexpr bool operator==(const BasicFakeExecutor&lt;OutstandingWorkP&gt;&amp; l,\nconst BasicFakeExecutor&lt;OutstandingWorkP&gt;&amp; r) noexcept;\ntemplate &lt;typename OutstandingWorkP&gt;\nconstexpr bool operator!=(const BasicFakeExecutor&lt;OutstandingWorkP&gt;&amp; l,\nconst BasicFakeExecutor&lt;OutstandingWorkP&gt;&amp; r) noexcept;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename OutstandingWorkP&gt;\nclass BasicFakeExecutor\n{\npublic:\nusing Self = BasicFakeExecutor;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr explicit BasicFakeExecutor() noexcept : context_{nullptr}\n{\n}\nconstexpr explicit BasicFakeExecutor(FakeExecutionContext* context) noexcept : context_{context}\n{\nif (std::is_same_v&lt;OutstandingWorkP, boost::asio::execution::outstanding_work_t::tracked_t&gt;) {\nthis-&gt;on_work_started();\n}\n}\nconstexpr BasicFakeExecutor(const Self&amp; other) noexcept : Self{other.context_}\n{\n}\nconstexpr BasicFakeExecutor(Self&amp;&amp; other) noexcept : context_{other.context_}\n{\nother.context_ = nullptr;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nSelf&amp; operator=(const Self&amp; other) noexcept\n{\nSelf tmp{other};\nthis-&gt;swap(tmp);\nreturn *this;\n}\nSelf&amp; operator=(Self&amp;&amp; other) noexcept\n{\nSelf tmp{std::move(other)};\nthis-&gt;swap(tmp);\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n~BasicFakeExecutor() noexcept\n{\nif (std::is_same_v&lt;OutstandingWorkP, boost::asio::execution::outstanding_work_t::tracked_t&gt;) {\nthis-&gt;on_work_finished();\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid swap(Self&amp; other)\n{\nstd::swap(this-&gt;context_, other.context_);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nFakeExecutionContext&amp; context() const\n{\nreturn *this-&gt;context_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self require(boost::asio::execution::blocking_t::possibly_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self require(boost::asio::execution::blocking_t::never_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self require(boost::asio::execution::relationship_t::fork_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self require(boost::asio::execution::relationship_t::continuation_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::outstanding_work_t::tracked_t) const\n{\nreturn BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto require(boost::asio::execution::outstanding_work_t::untracked_t) const\n{\nreturn BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename OtherAllocator&gt;\nconstexpr Self require(boost::asio::execution::allocator_t&lt;OtherAllocator&gt;) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self require(boost::asio::execution::allocator_t&lt;void&gt;) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self prefer(boost::asio::execution::blocking_t::possibly_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self prefer(boost::asio::execution::blocking_t::never_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self prefer(boost::asio::execution::relationship_t::fork_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self prefer(boost::asio::execution::relationship_t::continuation_t) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto prefer(boost::asio::execution::outstanding_work_t::tracked_t) const\n{\nreturn BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr auto prefer(boost::asio::execution::outstanding_work_t::untracked_t) const\n{\nreturn BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;{this-&gt;context_};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename OtherAllocator&gt;\nconstexpr Self prefer(boost::asio::execution::allocator_t&lt;OtherAllocator&gt;) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr Self prefer(boost::asio::execution::allocator_t&lt;void&gt;) const\n{\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr boost::asio::execution::mapping_t query(boost::asio::execution::mapping_t) noexcept\n{\nreturn boost::asio::execution::mapping.thread;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nFakeExecutionContext&amp; query(boost::asio::execution::context_t) const noexcept;\nboost::asio::execution_context&amp; query(\nboost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;) const noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr boost::asio::execution::blocking_t query(boost::asio::execution::blocking_t) const noexcept\n{\nreturn boost::asio::execution::blocking_t(boost::asio::execution::blocking.never);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconstexpr boost::asio::execution::relationship_t query(\nboost::asio::execution::relationship_t) const noexcept\n{\nreturn boost::asio::execution::relationship_t(boost::asio::execution::relationship.continuation);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nstatic constexpr boost::asio::execution::outstanding_work_t query(\nboost::asio::execution::outstanding_work_t) noexcept\n{\nreturn (std::is_same_v&lt;OutstandingWorkP, boost::asio::execution::outstanding_work_t::tracked_t&gt;)\n? boost::asio::execution::outstanding_work_t(\nboost::asio::execution::outstanding_work.tracked)\n: boost::asio::execution::outstanding_work_t(\nboost::asio::execution::outstanding_work.untracked);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename OtherAllocator&gt;\nconstexpr std::allocator&lt;void&gt; query(boost::asio::execution::allocator_t&lt;OtherAllocator&gt;) const noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nconstexpr std::allocator&lt;void&gt; query(boost::asio::execution::allocator_t&lt;void&gt;) const noexcept;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid on_work_started() const;\nvoid on_work_finished() const;\ntemplate &lt;typename Fn&gt;\nvoid execute(Fn&amp;&amp; fn) const;\ntemplate &lt;typename Fn, typename FnAllocator&gt;\nvoid dispatch(Fn&amp;&amp; fn, FnAllocator&amp;&amp;) const\n{\nthis-&gt;execute(fn);\n}\ntemplate &lt;typename Fn, typename FnAllocator&gt;\nvoid post(Fn&amp;&amp; fn, FnAllocator&amp;&amp;) const\n{\nthis-&gt;execute(fn);\n}\ntemplate &lt;typename Fn, typename FnAllocator&gt;\nvoid defer(Fn&amp;&amp; fn, FnAllocator&amp;&amp;) const\n{\nthis-&gt;execute(fn);\n}\nprivate:\nFakeExecutionContext* context_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_EXECUTOR_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__executor__impl_8hpp/","title":"batteries/async/fake_executor_impl.hpp","text":""},{"location":"_autogen/Files/fake__executor__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__executor__impl_8hpp/#define-batteries_async_fake_executor_impl_hpp","title":"define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__executor__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP\n#define BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename OutstandingWorkP&gt;\nBATT_INLINE_IMPL FakeExecutionContext&amp; BasicFakeExecutor&lt;OutstandingWorkP&gt;::query(\nboost::asio::execution::context_t) const noexcept\n{\nreturn *this-&gt;context_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename OutstandingWorkP&gt;\nBATT_INLINE_IMPL boost::asio::execution_context&amp; BasicFakeExecutor&lt;OutstandingWorkP&gt;::query(\nboost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;) const noexcept\n{\nreturn *this-&gt;context_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename OutstandingWorkP&gt;\nBATT_INLINE_IMPL void BasicFakeExecutor&lt;OutstandingWorkP&gt;::on_work_started() const\n{\nif (this-&gt;context_ != nullptr) {\nBATT_CHECK_NE(this-&gt;context_-&gt;work_count_.fetch_add(1) + 1u, 0u);\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename OutstandingWorkP&gt;\nBATT_INLINE_IMPL void BasicFakeExecutor&lt;OutstandingWorkP&gt;::on_work_finished() const\n{\nif (this-&gt;context_ != nullptr) {\nBATT_CHECK_GT(this-&gt;context_-&gt;work_count_.fetch_sub(1), 0u);\n}\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Explicit instantiations.\n//\ntemplate class BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t&gt;;\ntemplate class BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;;\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n// Type requirement checks.\nstatic_assert(std::is_constructible&lt;boost::asio::any_io_executor, FakeExecutor&gt;{},\n\"If this check fails, hopefully one or more of the following more scoped checks will fail as \"\n\"well, which will help with debugging!\");\nstatic_assert(\nstd::is_same_v&lt;bool, decltype(std::declval&lt;const FakeExecutor&gt;() == std::declval&lt;const FakeExecutor&gt;())&gt;,\n\"\");\nstatic_assert(\nstd::is_same_v&lt;bool, decltype(std::declval&lt;const FakeExecutor&gt;() != std::declval&lt;const FakeExecutor&gt;())&gt;,\n\"\");\nstatic_assert(std::is_nothrow_copy_constructible&lt;FakeExecutor&gt;::value, \"\");\nstatic_assert(std::is_nothrow_destructible&lt;FakeExecutor&gt;::value, \"\");\nstatic_assert(boost::asio::traits::equality_comparable&lt;FakeExecutor&gt;::is_valid, \"\");\nstatic_assert(boost::asio::traits::equality_comparable&lt;FakeExecutor&gt;::is_noexcept, \"\");\nstatic_assert(boost::asio::execution::is_executor_v&lt;FakeExecutor&gt;, \"\");\nstatic_assert(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;::is_applicable_property_v&lt;\nFakeExecutor&gt;,\n\"\");\nstatic_assert(\nboost::asio::can_query&lt;FakeExecutor,\nboost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;&gt;::value ||\ntrue,\n\"\");\nstatic_assert(boost::asio::is_applicable_property_v&lt;\nFakeExecutor, boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;&gt;,\n\"\");\nstatic_assert(boost::asio::execution::detail::supportable_properties&lt;\n0, void(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;)&gt;::\ntemplate is_valid_target&lt;FakeExecutor&gt;::value ||\ntrue,\n\"\");\nstatic_assert(\nboost::asio::execution::detail::is_valid_target_executor&lt;\nFakeExecutor, void(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;)&gt;::value,\n\"\");\nstatic_assert(std::is_same_v&lt;decltype(boost::asio::query(\nstd::declval&lt;const FakeExecutor&gt;(),\nboost::asio::execution::context_as&lt;boost::asio::execution_context&amp;&gt;)),\nboost::asio::execution_context&amp;&gt;,\n\"\");\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_EXECUTOR_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/","title":"batteries/async/fake_task_scheduler.hpp","text":""},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#classes","title":"Classes","text":"Name class batt::FakeTaskScheduler class batt::FakeTaskScheduler::ScopeGuard"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#define-batteries_async_fake_task_scheduler_hpp","title":"define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__task__scheduler_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP\n#define BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/fake_execution_context.hpp&gt;\n#include &lt;batteries/async/fake_executor.hpp&gt;\n#include &lt;batteries/async/runtime.hpp&gt;\n#include &lt;batteries/async/task_scheduler.hpp&gt;\nnamespace batt {\n// A TaskScheduler that embeds a FakeExecutionContext; for model-based simulation testing.\n//\nclass FakeTaskScheduler : public TaskScheduler\n{\npublic:\nclass ScopeGuard;\nFakeTaskScheduler() = default;\nFakeExecutionContext&amp; get_context()\n{\nreturn this-&gt;context_;\n}\nFakeExecutor get_executor()\n{\nreturn this-&gt;context_.get_executor();\n}\n// Select an executor to run a new task.\n//\nboost::asio::any_io_executor schedule_task() override\n{\nreturn this-&gt;get_executor();\n}\n// Request shutdown of all threads/executors owned by this scheduler.  Does not wait for shutdown\n// to complete; see TaskScheduler::join().\n//\nvoid halt() override\n{\n// Nothing to do.\n}\n// Wait for shutdown of all threads/executors owned by this scheduler.  Does not initiate shutdown\n// per se, just waits for shutdown to complete.  See TaskScheduler::halt().\n//\nvoid join() override\n{\n// Nothing to do.\n}\nprivate:\nFakeExecutionContext context_;\n};\nclass FakeTaskScheduler::ScopeGuard\n{\npublic:\nScopeGuard(const ScopeGuard&amp;) = delete;\nScopeGuard&amp; operator=(const ScopeGuard&amp;) = delete;\nexplicit ScopeGuard(FakeTaskScheduler&amp; scheduler) noexcept\n: saved_{Runtime::instance().exchange_task_scheduler(&amp;scheduler)}\n{\n}\n~ScopeGuard() noexcept\n{\n(void)Runtime::instance().exchange_task_scheduler(this-&gt;saved_);\n}\nprivate:\nTaskScheduler* saved_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_TASK_SCHEDULER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__time__service_8cpp/","title":"batteries/async/fake_time_service.cpp","text":""},{"location":"_autogen/Files/fake__time__service_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/fake_time_service.hpp&gt;\n//\n#include &lt;batteries/async/fake_time_service_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__time__service_8hpp/","title":"batteries/async/fake_time_service.hpp","text":""},{"location":"_autogen/Files/fake__time__service_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/fake_time_service_decl.hpp&gt;\n#include &lt;batteries/async/fake_time_service.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/fake_time_service_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/","title":"batteries/async/fake_time_service_decl.hpp","text":""},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#classes","title":"Classes","text":"Name class batt::FakeTimeService struct batt::FakeTimeService::TimerInstance struct batt::FakeTimeService::TimerInstance::Impl class batt::FakeTimeService::State"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#define-batteries_async_fake_time_service_decl_hpp","title":"define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__time__service__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP\n#define BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/bounds.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/asio/any_io_executor.hpp&gt;\n#include &lt;batteries/asio/execution_context.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wswitch-enum\")\n//\n#include &lt;boost/date_time/posix_time/ptime.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#if defined(__GNUC__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#if __GNUC__ &gt;= 9\n#pragma GCC diagnostic ignored \"-Wdeprecated-copy\"\n#endif  // __GNUC__ &gt;= 9\n#endif  // __GNUC__\n#include &lt;boost/heap/d_ary_heap.hpp&gt;\n#include &lt;boost/heap/policies.hpp&gt;\n#include &lt;memory&gt;\nnamespace batt {\nclass FakeExecutionContext;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// A time/timer service that virtualizes the passage of time, to implement simulations and tests.\n//\nclass FakeTimeService : public boost::asio::execution_context::service\n{\npublic:\nusing Self = FakeTimeService;\nusing TimePoint = boost::posix_time::ptime;\nusing Duration = boost::posix_time::time_duration;\nstruct TimerInstance {\nstruct Impl {\nFakeTimeService* service_instance;\nboost::asio::any_io_executor executor;\nTimePoint expires_at;\nUniqueHandler&lt;ErrorCode&gt; handler;\nexplicit Impl(FakeTimeService* service, boost::asio::any_io_executor ex, TimePoint expire,\nUniqueHandler&lt;ErrorCode&gt; h)\n: service_instance{service}\n, executor{ex}\n, expires_at{expire}\n, handler{std::move(h)}\n{\n}\n};\nstd::shared_ptr&lt;Impl&gt; impl;\n};\nusing TimerQueue = boost::heap::d_ary_heap&lt;TimerInstance,                         //\nboost::heap::arity&lt;2&gt;,                 //\nboost::heap::compare&lt;std::greater&lt;&gt;&gt;,  //\nboost::heap::mutable_&lt;true&gt;            //\n&gt;;\nclass State\n{\npublic:\nusing Lock = std::unique_lock&lt;std::mutex&gt;;\nState();\nTimePoint now();\ntemplate &lt;typename HandlerFn&gt;\nvoid schedule_timer(FakeTimeService* service_instance, const boost::asio::any_io_executor&amp; executor,\nTimePoint expires_at, HandlerFn&amp;&amp; fn);\n//\n// ^^ TODO [tastolfi 2022-01-14] return a timer id of some sort so we can implement cancel\nvoid advance_time(Duration delta);\nbool has_scheduled_timers() noexcept;\nOptional&lt;TimePoint&gt; next_expiration_time() noexcept;\nprivate:\nstd::mutex mutex_;\nTimePoint fake_time_;\nTimerQueue timer_queue_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic boost::asio::execution_context::id id;\nstatic State&amp; state()\n{\nstatic State instance_;\nreturn instance_;\n}\nstatic TimePoint now()\n{\nreturn Self::state().now();\n}\nstatic void advance_time(Duration delta)\n{\nSelf::state().advance_time(delta);\n}\nstatic bool has_scheduled_timers() noexcept\n{\nreturn Self::state().has_scheduled_timers();\n}\nstatic Optional&lt;TimePoint&gt; next_expiration_time() noexcept\n{\nreturn Self::state().next_expiration_time();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit FakeTimeService(boost::asio::execution_context&amp; context);\nvoid shutdown() override;\ntemplate &lt;typename HandlerFn&gt;\nvoid async_wait(const boost::asio::any_io_executor&amp; executor, TimePoint expires_at, HandlerFn&amp;&amp; fn)\n{\nSelf::state().schedule_timer(this, executor, expires_at, BATT_FORWARD(fn));\n}\n};\nbool operator&lt;(const FakeTimeService::TimerInstance&amp; l, const FakeTimeService::TimerInstance&amp; r);\nBATT_TOTALLY_ORDERED((inline), FakeTimeService::TimerInstance, FakeTimeService::TimerInstance)\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_TIME_SERVICE_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/","title":"batteries/async/fake_time_service_impl.hpp","text":""},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#define-batteries_async_fake_time_service_impl_hpp","title":"define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/fake__time__service__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP\n#define BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/asio/post.hpp&gt;\n#include &lt;batteries/async/fake_execution_context.hpp&gt;\n#include &lt;boost/asio/time_traits.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ boost::asio::execution_context::id FakeTimeService::id;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ FakeTimeService::FakeTimeService(boost::asio::execution_context&amp; context)\n: boost::asio::execution_context::service{context}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool operator&lt;(const FakeTimeService::TimerInstance&amp; l,\nconst FakeTimeService::TimerInstance&amp; r)\n{\nreturn (l.impl == nullptr &amp;&amp; r.impl != nullptr) ||\n((l.impl != nullptr &amp;&amp; r.impl != nullptr) &amp;&amp; (l.impl-&gt;expires_at &lt; r.impl-&gt;expires_at));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL FakeTimeService::State::State() : fake_time_{boost::asio::time_traits&lt;TimePoint&gt;::now()}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto FakeTimeService::State::now() -&gt; TimePoint\n{\nLock lock{this-&gt;mutex_};\nreturn this-&gt;fake_time_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void FakeTimeService::State::advance_time(Duration delta)\n{\nstd::vector&lt;TimerInstance&gt; expired_timers;\n{\nLock lock{this-&gt;mutex_};\nthis-&gt;fake_time_ += delta;\nwhile (!this-&gt;timer_queue_.empty() &amp;&amp; this-&gt;timer_queue_.top().impl-&gt;expires_at &lt;= this-&gt;fake_time_) {\nexpired_timers.emplace_back(this-&gt;timer_queue_.top());\ntimer_queue_.pop();\n}\n}\nfor (TimerInstance&amp; timer : expired_timers) {\nboost::asio::post(timer.impl-&gt;executor, std::bind(std::move(timer.impl-&gt;handler), ErrorCode{}));\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void FakeTimeService::shutdown() /*override*/\n{\n// TODO [tastolfi 2022-01-14] how to cancel timers associated with this?\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool FakeTimeService::State::has_scheduled_timers() noexcept\n{\nLock lock{this-&gt;mutex_};\nreturn !this-&gt;timer_queue_.empty();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto FakeTimeService::State::next_expiration_time() noexcept -&gt; Optional&lt;TimePoint&gt;\n{\nLock lock{this-&gt;mutex_};\nif (timer_queue_.empty()) {\nreturn None;\n}\nreturn this-&gt;timer_queue_.top().impl-&gt;expires_at;\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FAKE_TIME_SERVICE_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/fetch_8hpp/","title":"batteries/async/fetch.hpp","text":""},{"location":"_autogen/Files/fetch_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/fetch_8hpp/#classes","title":"Classes","text":"Name class batt::BasicScopedChunk A fetched chunk of data that is automatically consumed (partially or entirely) when it goes out of scope."},{"location":"_autogen/Files/fetch_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FETCH_HPP"},{"location":"_autogen/Files/fetch_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fetch_8hpp/#define-batteries_async_fetch_hpp","title":"define BATTERIES_ASYNC_FETCH_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FETCH_HPP()\n</code></pre>"},{"location":"_autogen/Files/fetch_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FETCH_HPP\n#define BATTERIES_ASYNC_FETCH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/pin.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/pointers.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/asio/buffer.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstddef&gt;\n#include &lt;limits&gt;\nnamespace batt {\ntemplate &lt;typename AsyncFetchStreamT&gt;\nclass BasicScopedChunk\n{\npublic:\nstatic constexpr usize kLocalStorageSize = 48;\nusing stream_type = AsyncFetchStreamT;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nBasicScopedChunk() = default;\nBasicScopedChunk(const BasicScopedChunk&amp;) = delete;\nBasicScopedChunk&amp; operator=(const BasicScopedChunk&amp;) = delete;\nBasicScopedChunk(BasicScopedChunk&amp;&amp; other) noexcept\n: source_{std::move(other.source_)}\n, local_storage_{std::move(other.local_storage_)}\n, buffer_{other.buffer_}\n{\n// The buffer_ in the other object should be cleared.\n//\nother.buffer_ = boost::asio::const_buffer{nullptr, 0};\n// Check to see whether we need to fix up buffer_ to point to the local_storage_ buffer.\n//\nif (!this-&gt;local_storage_.empty()) {\nthis-&gt;buffer_ =\nboost::asio::const_buffer{this-&gt;local_storage_.data(), this-&gt;local_storage_.size()};\n}\n}\nBasicScopedChunk&amp; operator=(BasicScopedChunk&amp;&amp; other) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;other)) {\nthis-&gt;source_ = std::move(other.source_);\nthis-&gt;local_storage_ = std::move(other.local_storage_);\nthis-&gt;buffer_ = other.buffer_;\n// The buffer_ in the other object should be cleared.\n//\nother.buffer_ = boost::asio::const_buffer{nullptr, 0};\n// Check to see whether we need to fix up buffer_ to point to the local_storage_ buffer.\n//\nif (!this-&gt;local_storage_.empty()) {\nthis-&gt;buffer_ =\nboost::asio::const_buffer{this-&gt;local_storage_.data(), this-&gt;local_storage_.size()};\n}\n}\nreturn *this;\n}\nexplicit BasicScopedChunk(stream_type* source, const boost::asio::const_buffer&amp; buffer) noexcept\n: source_{source}\n, local_storage_{}\n, buffer_{buffer}\n{\n}\nexplicit BasicScopedChunk(stream_type* source, batt::SmallVec&lt;char, kLocalStorageSize&gt;&amp;&amp; storage) noexcept\n: source_{source}\n, local_storage_{std::move(storage)}\n, buffer_{this-&gt;local_storage_.data(), this-&gt;local_storage_.size()}\n{\n}\n~BasicScopedChunk() noexcept\n{\nthis-&gt;consume();\n}\nconst void* data() const noexcept\n{\nreturn this-&gt;buffer_.data();\n}\nusize size() const noexcept\n{\nreturn this-&gt;buffer_.size();\n}\nconst boost::asio::const_buffer&amp; buffer() const noexcept\n{\nreturn this-&gt;buffer_;\n}\nbool empty() const noexcept\n{\nreturn !this-&gt;source_ || this-&gt;buffer_.size() == 0;\n}\nvoid back_up(usize n = std::numeric_limits&lt;usize&gt;::max()) noexcept\n{\nn = std::min(n, this-&gt;size());\nthis-&gt;buffer_ = boost::asio::const_buffer{this-&gt;data(), this-&gt;size() - n};\n}\nvoid consume() noexcept\n{\n// Important: we must look at whether source_ is nullptr, regardless of whether this-&gt;empty()\n// returns true, since each async_fetch must be paired with a call to consume, even if we are\n// consuming 0 bytes.\n//\nif (this-&gt;source_) {\nstream_type* const local_source = this-&gt;source_.release();\nlocal_source-&gt;consume(this-&gt;buffer_.size());\nthis-&gt;buffer_ = boost::asio::const_buffer{};\n}\n}\nprivate:\nbatt::UniqueNonOwningPtr&lt;stream_type&gt; source_;\nbatt::SmallVec&lt;char, kLocalStorageSize&gt; local_storage_;\nboost::asio::const_buffer buffer_;\n};\ntemplate &lt;typename AsyncFetchStreamT, typename ScopedChunk = BasicScopedChunk&lt;AsyncFetchStreamT&gt;,\ntypename ConstBufferSequence = typename AsyncFetchStreamT::const_buffers_type&gt;\nbatt::StatusOr&lt;ScopedChunk&gt; fetch_chunk(AsyncFetchStreamT&amp; stream, usize min_size)\n{\nif (min_size == 0) {\nreturn {batt::StatusCode::kInvalidArgument};\n}\nauto result =\nbatt::Task::await&lt;batt::IOResult&lt;ConstBufferSequence&gt;&gt;([&amp;stream, min_size](auto&amp;&amp; handler) {  //\nstream.async_fetch(min_size, BATT_FORWARD(handler));\n});\nBATT_REQUIRE_OK(result);\nConstBufferSequence&amp; buffers = result.value();\nauto next_iter = boost::asio::buffer_sequence_begin(buffers);\nconst auto last_iter = boost::asio::buffer_sequence_end(buffers);\nBATT_CHECK_NE(next_iter, last_iter);\nConstBuffer first_chunk = *next_iter;\nif (first_chunk.size() &gt;= min_size) {\nreturn ScopedChunk{&amp;stream, boost::asio::const_buffer{*next_iter}};\n}\n// We need to gather the fetched buffers into a single chunk.\n//\nusize bytes_remaining = min_size;\nusize offset = 0;\nbatt::SmallVec&lt;char, ScopedChunk::kLocalStorageSize&gt; storage(min_size);\nwhile (bytes_remaining &gt; 0 &amp;&amp; next_iter != last_iter) {\nconst usize bytes_to_copy = std::min(bytes_remaining, next_iter-&gt;size());\nstd::memcpy(storage.data() + offset, next_iter-&gt;data(), bytes_to_copy);\nbytes_remaining -= bytes_to_copy;\noffset += bytes_to_copy;\n++next_iter;\n}\nBATT_CHECK_EQ(bytes_remaining, 0u) &lt;&lt; \"The stream returned less than the minimum fetch size!\";\nreturn ScopedChunk{&amp;stream, std::move(storage)};\n}\nenum struct TransferStep { kNone, kFetch, kWrite };\ntemplate &lt;typename From, typename To&gt;\ninline StatusOr&lt;usize&gt; transfer_chunked_data(From&amp; from, To&amp; to, TransferStep&amp; step)\n{\nusize bytes_transferred = 0;\nfor (;;) {\nstep = TransferStep::kFetch;\nauto chunk = from.fetch_chunk();\nif (!chunk.ok()) {\nif (chunk.status() != boost::asio::error::eof) {\nreturn chunk.status();\n}\nbreak;\n}\nstep = TransferStep::kWrite;\nauto n_written = to.write(chunk-&gt;buffer());\nBATT_REQUIRE_OK(n_written);\nif (*n_written == 0) {\nreturn {batt::StatusCode::kClosedBeforeEndOfStream};\n}\nchunk-&gt;back_up(chunk-&gt;size() - *n_written);\nbytes_transferred += *n_written;\n}\nreturn bytes_transferred;\n}\ntemplate &lt;typename From, typename To&gt;\ninline StatusOr&lt;usize&gt; transfer_chunked_data(From&amp; from, To&amp; to)\n{\nTransferStep step = TransferStep::kNone;\nreturn transfer_chunked_data(from, to, step);\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FETCH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/filter_8hpp/","title":"batteries/seq/filter.hpp","text":""},{"location":"_autogen/Files/filter_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/filter_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Filter struct batt::seq::FilterBinder"},{"location":"_autogen/Files/filter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_FILTER_HPP"},{"location":"_autogen/Files/filter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/filter_8hpp/#define-batteries_seq_filter_hpp","title":"define BATTERIES_SEQ_FILTER_HPP","text":"<pre><code>#define BATTERIES_SEQ_FILTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/filter_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_FILTER_HPP\n#define BATTERIES_SEQ_FILTER_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// filter\n//\ntemplate &lt;typename Seq, typename Predicate&gt;\nclass Filter\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit Filter(Seq&amp;&amp; seq, Predicate&amp;&amp; predicate) noexcept\n: seq_(BATT_FORWARD(seq))\n, predicate_(BATT_FORWARD(predicate))\n{\n}\nFilter(Filter&amp;&amp; that) noexcept : seq_(BATT_FORWARD(that.seq_)), predicate_(BATT_FORWARD(*that.predicate_))\n{\n}\nFilter&amp; operator=(Filter&amp;&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nseq_ = BATT_FORWARD(that.seq_);\npredicate_.emplace(BATT_FORWARD(*that.predicate_));\n}\nreturn *this;\n}\nFilter(const Filter&amp; that) : seq_(that.seq_), predicate_(*that.predicate_)\n{\n}\nFilter&amp; operator=(const Filter&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nseq_ = that.seq_;\npredicate_.emplace(*that.predicate_);\n}\nreturn *this;\n}\nOptional&lt;Item&gt; peek()\n{\nfor (;;) {\nOptional&lt;Item&gt; item = this-&gt;seq_.peek();\nif (!item || (*this-&gt;predicate_)(*item)) {\nreturn item;\n}\n(void)this-&gt;seq_.next();\n}\n}\nOptional&lt;Item&gt; next()\n{\nfor (;;) {\nOptional&lt;Item&gt; item = this-&gt;seq_.next();\nif (!item || (*this-&gt;predicate_)(*item)) {\nreturn item;\n}\n}\n}\n//--------------------------\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename Seq_, typename Pred, typename EachFn&gt;\nfriend LoopControl operator|(Filter&lt;Seq_, Pred&gt;&amp;&amp; filter_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nSeq seq_;\nOptional&lt;Predicate&gt; predicate_;\n};\ntemplate &lt;typename Predicate&gt;\nstruct FilterBinder {\nPredicate predicate;\n};\ntemplate &lt;typename Predicate&gt;\nFilterBinder&lt;Predicate&gt; filter(Predicate&amp;&amp; predicate)\n{\nreturn {BATT_FORWARD(predicate)};\n}\ntemplate &lt;typename Seq, typename Predicate&gt;\n[[nodiscard]] Filter&lt;Seq, Predicate&gt; operator|(Seq&amp;&amp; seq, FilterBinder&lt;Predicate&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"Filtered sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;Predicate, std::decay_t&lt;Predicate&gt;&gt;,\n\"Predicate functions may not be captured implicitly by reference.\");\nreturn Filter&lt;Seq, Predicate&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.predicate)};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename Seq, typename Pred, typename EachFn&gt;\nLoopControl operator|(Filter&lt;Seq, Pred&gt;&amp;&amp; filter_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder)\n{\nauto&amp; pred_fn = *filter_seq.predicate_;\nauto loop_body = [&amp;](auto&amp;&amp; item) -&gt; LoopControl {\nif (!pred_fn(item)) {\nreturn kContinue;\n}\nreturn run_loop_fn(binder.fn, item);\n};\nreturn std::forward&lt;Seq&gt;(filter_seq.seq_) | for_each(loop_body);\n}\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_FILTER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/filter__map_8hpp/","title":"batteries/seq/filter_map.hpp","text":""},{"location":"_autogen/Files/filter__map_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/filter__map_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::IsNotFalse class batt::seq::FilterMap struct batt::seq::FilterMapBinder"},{"location":"_autogen/Files/filter__map_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_FILTER_MAP_HPP"},{"location":"_autogen/Files/filter__map_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/filter__map_8hpp/#define-batteries_seq_filter_map_hpp","title":"define BATTERIES_SEQ_FILTER_MAP_HPP","text":"<pre><code>#define BATTERIES_SEQ_FILTER_MAP_HPP()\n</code></pre>"},{"location":"_autogen/Files/filter__map_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_FILTER_MAP_HPP\n#define BATTERIES_SEQ_FILTER_MAP_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/seq/deref.hpp&gt;\n#include &lt;batteries/seq/filter.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/map.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// filter_map\n//\nstruct IsNotFalse {\ntemplate &lt;typename T&gt;\nbool operator()(T&amp;&amp; val) const\n{\nreturn bool{val};\n}\n};\ntemplate &lt;typename Seq, typename Fn&gt;\nauto filter_map_impl(Seq&amp;&amp; seq, Fn&amp;&amp; fn)\n{\nreturn BATT_FORWARD(seq)        //\n| map(BATT_FORWARD(fn))  //\n| filter(IsNotFalse{})   //\n| deref();\n}\ntemplate &lt;typename Seq, typename Fn&gt;\nclass FilterMap\n{\npublic:\nusing impl_type = decltype(filter_map_impl&lt;Seq, Fn&gt;(std::declval&lt;Seq&gt;(), std::declval&lt;Fn&gt;()));\nusing Item = SeqItem&lt;impl_type&gt;;\nexplicit FilterMap(Seq&amp;&amp; seq, Fn&amp;&amp; fn) noexcept\n: impl_{filter_map_impl(BATT_FORWARD(seq), BATT_FORWARD(fn))}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn impl_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn impl_.next();\n}\n//--------------------------------\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename Seq_, typename MapFn, typename EachFn&gt;\nfriend LoopControl operator|(FilterMap&lt;Seq_, MapFn&gt;&amp;&amp; filter_map_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nimpl_type impl_;\n};\ntemplate &lt;typename Fn&gt;\nstruct FilterMapBinder {\nFn fn;\n};\ntemplate &lt;typename Fn&gt;\nFilterMapBinder&lt;Fn&gt; filter_map(Fn&amp;&amp; fn)\n{\nreturn {BATT_FORWARD(fn)};\n}\ntemplate &lt;typename Seq, typename Fn&gt;\n[[nodiscard]] FilterMap&lt;Seq, Fn&gt; operator|(Seq&amp;&amp; seq, FilterMapBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"Filtered/mapped sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;Fn, std::decay_t&lt;Fn&gt;&gt;,\n\"Filter/map functions may not be captured implicitly by reference.\");\nreturn FilterMap&lt;Seq, Fn&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.fn)};\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// filter_map(...) | for_each(...)\n//\ntemplate &lt;typename Seq, typename MapFn, typename EachFn&gt;\nLoopControl operator|(FilterMap&lt;Seq, MapFn&gt;&amp;&amp; filter_map_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder)\n{\nreturn BATT_FORWARD(filter_map_seq.impl_) | BATT_FORWARD(binder);\n}\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_FILTER_MAP_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/finally_8hpp/","title":"batteries/finally.hpp","text":""},{"location":"_autogen/Files/finally_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/finally_8hpp/#classes","title":"Classes","text":"Name class batt::FinalAct"},{"location":"_autogen/Files/finally_8hpp/#defines","title":"Defines","text":"Name BATTERIES_FINALLY_HPP"},{"location":"_autogen/Files/finally_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/finally_8hpp/#define-batteries_finally_hpp","title":"define BATTERIES_FINALLY_HPP","text":"<pre><code>#define BATTERIES_FINALLY_HPP()\n</code></pre>"},{"location":"_autogen/Files/finally_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_FINALLY_HPP\n#define BATTERIES_FINALLY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;optional&gt;\n#include &lt;utility&gt;\nnamespace batt {\ntemplate &lt;typename Fn&gt;\nclass FinalAct\n{\npublic:\nFinalAct(const FinalAct&amp;) = delete;\nFinalAct&amp; operator=(const FinalAct&amp;) = delete;\n// Moves a final act to a more narrow scope in order to invoke it early.\n//\nFinalAct(FinalAct&amp;&amp; that) noexcept : fn_{that.fn_}\n{\nthat.cancel();\n}\ntemplate &lt;typename FnArg, typename = EnableIfNoShadow&lt;FinalAct, FnArg&amp;&amp;&gt;&gt;\nexplicit FinalAct(FnArg&amp;&amp; arg) noexcept : fn_{BATT_FORWARD(arg)}\n{\n}\n~FinalAct() noexcept\n{\nif (fn_) {\nauto local_copy = std::move(fn_);\n(*local_copy)();\n}\n}\nvoid cancel()\n{\nfn_ = std::nullopt;\n}\nprivate:\nstd::optional&lt;Fn&gt; fn_;\n};\ntemplate &lt;typename Fn&gt;\nauto finally(Fn&amp;&amp; fn) noexcept -&gt; FinalAct&lt;std::decay_t&lt;Fn&gt;&gt;\n{\nreturn FinalAct&lt;std::decay_t&lt;Fn&gt;&gt;{BATT_FORWARD(fn)};\n}\n}  // namespace batt\n#endif  // BATTERIES_FINALLY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/first_8hpp/","title":"batteries/seq/first.hpp","text":""},{"location":"_autogen/Files/first_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/first_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::FirstBinder"},{"location":"_autogen/Files/first_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_FIRST_HPP"},{"location":"_autogen/Files/first_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/first_8hpp/#define-batteries_seq_first_hpp","title":"define BATTERIES_SEQ_FIRST_HPP","text":"<pre><code>#define BATTERIES_SEQ_FIRST_HPP()\n</code></pre>"},{"location":"_autogen/Files/first_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_FIRST_HPP\n#define BATTERIES_SEQ_FIRST_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// first\n//\nstruct FirstBinder {\n};\ninline FirstBinder first()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, FirstBinder)\n{\nreturn seq.peek();\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_FIRST_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/flatten_8hpp/","title":"batteries/seq/flatten.hpp","text":""},{"location":"_autogen/Files/flatten_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/flatten_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Flatten struct batt::seq::FlattenBinder"},{"location":"_autogen/Files/flatten_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_FLATTEN_HPP"},{"location":"_autogen/Files/flatten_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/flatten_8hpp/#define-batteries_seq_flatten_hpp","title":"define BATTERIES_SEQ_FLATTEN_HPP","text":"<pre><code>#define BATTERIES_SEQ_FLATTEN_HPP()\n</code></pre>"},{"location":"_autogen/Files/flatten_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_FLATTEN_HPP\n#define BATTERIES_SEQ_FLATTEN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/count.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// flatten - turns Seq&lt;Seq&lt;T&gt;&gt; into Seq&lt;T&gt; by concatenating\n//\ntemplate &lt;typename OuterSeq, typename InnerSeqT = std::decay_t&lt;SeqItem&lt;OuterSeq&gt;&gt;&gt;\nclass Flatten\n{\npublic:\nusing InnerSeq = InnerSeqT;\nusing Item = SeqItem&lt;InnerSeq&gt;;\nexplicit Flatten(OuterSeq&amp;&amp; outer) noexcept : outer_(BATT_FORWARD(outer)), inner_(outer_.next())\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn impl(/*consume_item=*/false);\n}\nOptional&lt;Item&gt; next()\n{\nreturn impl(/*consume_item=*/true);\n}\n//----------------\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename OuterSeq_, typename Fn&gt;\nfriend LoopControl operator|(Flatten&lt;OuterSeq_&gt;&amp;&amp; flatten_seq, ForEachBinder&lt;Fn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nOptional&lt;Item&gt; impl(bool consume_item)\n{\nif (!inner_) {\nreturn None;\n}\nfor (;;) {\nauto v = consume_item ? inner_-&gt;next() : inner_-&gt;peek();\nif (v) {\nreturn v;\n}\nauto next_inner = outer_.next();\nif (next_inner) {\ninner_.emplace(std::move(*next_inner));\n} else {\ninner_ = None;\nreturn None;\n}\n}\n}\nOuterSeq outer_;\nOptional&lt;InnerSeq&gt; inner_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstruct FlattenBinder {\n};\ninline FlattenBinder flatten()\n{\nreturn {};\n}\ntemplate &lt;typename OuterSeq&gt;\n[[nodiscard]] Flatten&lt;OuterSeq&gt; operator|(OuterSeq&amp;&amp; seq, FlattenBinder)\n{\nstatic_assert(std::is_same_v&lt;OuterSeq, std::decay_t&lt;OuterSeq&gt;&gt;,\n\"Flattened sequences may not be captured implicitly by reference.\");\nreturn Flatten&lt;OuterSeq&gt;{BATT_FORWARD(seq)};\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// flatten() | for_each(...)\n//\ntemplate &lt;typename OuterSeq, typename Fn&gt;\nLoopControl operator|(Flatten&lt;OuterSeq&gt;&amp;&amp; flatten_seq, ForEachBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nusing InnerSeq = typename Flatten&lt;OuterSeq&gt;::InnerSeq;\nif (flatten_seq.inner_) {\nLoopControl control = std::forward&lt;InnerSeq&gt;(*flatten_seq.inner_) | for_each(binder.fn);\nif (BATT_HINT_FALSE(control == kBreak)) {\nreturn kBreak;\n}\nflatten_seq.inner_ = None;\n}\nauto loop_body = [&amp;binder](auto&amp;&amp; inner_seq) -&gt; LoopControl {\nreturn BATT_FORWARD(inner_seq) | for_each(binder.fn);\n};\nreturn std::forward&lt;OuterSeq&gt;(flatten_seq.outer_) | for_each(loop_body);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// flatten() | count()\n//\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_FLATTEN_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/for__each_8hpp/","title":"batteries/seq/for_each.hpp","text":""},{"location":"_autogen/Files/for__each_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/for__each_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::ForEachBinder"},{"location":"_autogen/Files/for__each_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_FOR_EACH_HPP"},{"location":"_autogen/Files/for__each_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/for__each_8hpp/#define-batteries_seq_for_each_hpp","title":"define BATTERIES_SEQ_FOR_EACH_HPP","text":"<pre><code>#define BATTERIES_SEQ_FOR_EACH_HPP()\n</code></pre>"},{"location":"_autogen/Files/for__each_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_FOR_EACH_HPP\n#define BATTERIES_SEQ_FOR_EACH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/loop_control.hpp&gt;\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// for_each\n//\ntemplate &lt;typename Fn&gt;\nstruct ForEachBinder {\nFn fn;\n};\ntemplate &lt;typename Fn&gt;\nForEachBinder&lt;Fn&gt; for_each(Fn&amp;&amp; fn)\n{\nreturn {BATT_FORWARD(fn)};\n}\ntemplate &lt;typename Seq, typename Fn, typename = EnableIfSeq&lt;Seq&gt;&gt;\nLoopControl operator|(Seq&amp;&amp; seq, ForEachBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nfor (;;) {\nauto n = seq.next();\nif (!n) {\nbreak;\n}\nif (BATT_HINT_FALSE(run_loop_fn(binder.fn, *n) == kBreak)) {\nreturn kBreak;\n}\n}\nreturn kContinue;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_FOR_EACH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/fuse_8hpp/","title":"batteries/seq/fuse.hpp","text":""},{"location":"_autogen/Files/fuse_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/fuse_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Fuse struct batt::seq::FuseBinder"},{"location":"_autogen/Files/fuse_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_FUSE_HPP"},{"location":"_autogen/Files/fuse_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/fuse_8hpp/#define-batteries_seq_fuse_hpp","title":"define BATTERIES_SEQ_FUSE_HPP","text":"<pre><code>#define BATTERIES_SEQ_FUSE_HPP()\n</code></pre>"},{"location":"_autogen/Files/fuse_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_FUSE_HPP\n#define BATTERIES_SEQ_FUSE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// fuse() - Seq&lt;Optional&lt;T&gt;&gt; =&gt; Seq&lt;T&gt;; take T while Optional&lt;T&gt; != None\n//\ntemplate &lt;typename Seq&gt;\nclass Fuse\n{\npublic:\nusing OptionalItem = SeqItem&lt;Seq&gt;;\nusing Item = typename std::decay_t&lt;OptionalItem&gt;::value_type;\nexplicit Fuse(Seq&amp;&amp; seq) noexcept : seq_(BATT_FORWARD(seq))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (fused_) {\nreturn None;\n}\nreturn *seq_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nif (fused_) {\nreturn None;\n}\nOptional&lt;Optional&lt;Item&gt;&gt; opt_item = seq_.next();\nif (!opt_item) {\nfused_ = true;\nreturn None;\n}\nif (!*opt_item) {\nfused_ = true;\nreturn None;\n}\nreturn std::move(*opt_item);\n}\nprivate:\nbool fused_ = false;\nSeq seq_;\n};\nstruct FuseBinder {\n};\ninline FuseBinder fuse()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] Fuse&lt;Seq&gt; operator|(Seq&amp;&amp; seq, FuseBinder)\n{\nreturn Fuse&lt;Seq&gt;{BATT_FORWARD(seq)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_FUSE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/futex_8hpp/","title":"batteries/async/futex.hpp","text":""},{"location":"_autogen/Files/futex_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/futex_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FUTEX_HPP"},{"location":"_autogen/Files/futex_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/futex_8hpp/#define-batteries_async_futex_hpp","title":"define BATTERIES_ASYNC_FUTEX_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FUTEX_HPP()\n</code></pre>"},{"location":"_autogen/Files/futex_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_ASYNC_FUTEX_HPP\n#define BATTERIES_ASYNC_FUTEX_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/syscall_retry.hpp&gt;\n#ifdef BATT_PLATFORM_IS_LINUX\n#include &lt;linux/futex.h&gt;\n#include &lt;sched.h&gt;\n#include &lt;sys/syscall.h&gt;\n#endif\n#include &lt;atomic&gt;\n#include &lt;thread&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\n#if defined(BATT_PLATFORM_IS_LINUX)\nstatic_assert(std::is_same_v&lt;int, i32&gt;);\ninline int futex_impl(u32* uaddr, i32 futex_op, u32 val, const struct timespec* timeout, u32* uaddr2,\nu32 val3)\n{\nreturn syscall_retry([&amp;] {\nreturn syscall(SYS_futex, uaddr, futex_op, val, timeout, uaddr2, val3);\n});\n}\ninline int futex_wait(std::atomic&lt;u32&gt;* var, u32 last_seen)\n{\nstatic_assert(sizeof(std::atomic&lt;u32&gt;) == sizeof(u32));\nreturn futex_impl((u32*)var, FUTEX_WAIT_PRIVATE, last_seen, NULL, NULL, 0);\n}\ninline int futex_notify(std::atomic&lt;u32&gt;* var, u32 count = 1)\n{\nstatic_assert(sizeof(std::atomic&lt;u32&gt;) == sizeof(u32));\nreturn futex_impl((u32*)var, FUTEX_WAKE_PRIVATE, count, NULL, NULL, 0);\n}\ninline void spin_yield()\n{\nsched_yield();\n}\n#else\ninline int futex_wait(std::atomic&lt;u32&gt;*, u32)\n{\nreturn 0;\n}\ninline int futex_notify(std::atomic&lt;u32&gt;*, u32 = 1)\n{\nreturn 0;\n}\ninline void spin_yield()\n{\nstd::this_thread::yield();\n}\n#endif\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_FUTEX_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/future_8cpp/","title":"batteries/async/future.cpp","text":""},{"location":"_autogen/Files/future_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/future.hpp&gt;\n//\n#include &lt;batteries/async/future_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/future_8hpp/","title":"batteries/async/future.hpp","text":""},{"location":"_autogen/Files/future_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/future_decl.hpp&gt;\n//\n#include &lt;batteries/async/future.ipp&gt;\n//\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/future_impl.hpp&gt;\n#endif\n#include &lt;batteries/async/latch.hpp&gt;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/future__decl_8hpp/","title":"batteries/async/future_decl.hpp","text":""},{"location":"_autogen/Files/future__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/future__decl_8hpp/#classes","title":"Classes","text":"Name class batt::detail::FutureImpl class batt::Promise An obligation to provide a value of type T to a Future. class batt::Future A value of type T that will be provided at some point in the future."},{"location":"_autogen/Files/future__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FUTURE_DECL_HPP"},{"location":"_autogen/Files/future__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/future__decl_8hpp/#define-batteries_async_future_decl_hpp","title":"define BATTERIES_ASYNC_FUTURE_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FUTURE_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/future__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FUTURE_DECL_HPP\n#define BATTERIES_ASYNC_FUTURE_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/latch_decl.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;memory&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace detail {\ntemplate &lt;typename T&gt;\nclass FutureImpl : public Latch&lt;T&gt;\n{\npublic:\nusing Latch&lt;T&gt;::Latch;\n};\n}  // namespace detail\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+------------\ntemplate &lt;typename T&gt;\nclass Promise;\ntemplate &lt;typename T&gt;\nclass Future;\ntemplate &lt;typename T&gt;\nFuture&lt;T&gt; get_future(const Promise&lt;T&gt;&amp; promise);\ntemplate &lt;typename T&gt;\nclass Promise\n{\npublic:\ntemplate &lt;typename U&gt;\nfriend Future&lt;U&gt; get_future(const Promise&lt;U&gt;&amp; promise);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nPromise();\nbool is_ready() const;\nvoid set_value(T&amp;&amp; value);\nvoid set_value(StatusOr&lt;T&gt;&amp;&amp; value);\nvoid set_value(const StatusOr&lt;T&gt;&amp; value);\nvoid set_error(const Status&amp; status);\nFuture&lt;T&gt; get_future() const\n{\nreturn ::batt::get_future(*this);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nboost::intrusive_ptr&lt;detail::FutureImpl&lt;T&gt;&gt; impl_;\n};\ntemplate &lt;typename T&gt;\nclass Future\n{\npublic:\ntemplate &lt;typename... Args&gt;\nstatic Future from_value(Args&amp;&amp;... args) noexcept\n{\nPromise&lt;T&gt; p;\np.set_value(T(BATT_FORWARD(args)...));\nreturn p.get_future();\n}\nstatic Future from_error(const Status&amp; status) noexcept\n{\nPromise&lt;T&gt; p;\np.set_error(status);\nreturn p.get_future();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -9\ntemplate &lt;typename Handler&gt;\nvoid async_wait(Handler&amp;&amp; handler) const;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// To retrieve the value of the future, use `StatusOr&lt;T&gt; result = Task::await(future);`\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename U&gt;\nfriend Future&lt;U&gt; get_future(const Promise&lt;U&gt;&amp; promise);\nbool is_ready() const;\nStatusOr&lt;T&gt; await() const;\ntemplate &lt;typename Fn, typename U = RemoveStatusOr&lt;std::invoke_result_t&lt;Fn, T&amp;&gt;&gt;&gt;\nFuture&lt;U&gt; and_then(Fn&amp;&amp; fn)\n{\nPromise&lt;U&gt; promise;\nFuture&lt;U&gt; future = promise.get_future();\nthis-&gt;async_wait(bind_handler(BATT_FORWARD(fn),\n[promise = std::move(promise)](Fn&amp;&amp; fn, StatusOr&lt;T&gt; result) mutable {\nif (result.ok()) {\npromise.set_value(BATT_FORWARD(fn)(*result));\n} else {\npromise.set_error(result.status());\n}\n}));\nreturn future;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nexplicit Future(boost::intrusive_ptr&lt;detail::FutureImpl&lt;T&gt;&gt;&amp;&amp; impl) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::intrusive_ptr&lt;detail::FutureImpl&lt;T&gt;&gt; impl_;\n};\ntemplate &lt;typename T&gt;\nFuture&lt;T&gt; get_future(const Promise&lt;T&gt;&amp; promise);\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FUTURE_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/future__impl_8hpp/","title":"batteries/async/future_impl.hpp","text":""},{"location":"_autogen/Files/future__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/future__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_FUTURE_IMPL_HPP"},{"location":"_autogen/Files/future__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/future__impl_8hpp/#define-batteries_async_future_impl_hpp","title":"define BATTERIES_ASYNC_FUTURE_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_FUTURE_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/future__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_FUTURE_IMPL_HPP\n#define BATTERIES_ASYNC_FUTURE_IMPL_HPP\nnamespace batt {\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_FUTURE_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/grant_8hpp/","title":"batteries/async/grant.hpp","text":""},{"location":"_autogen/Files/grant_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/grant_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_GRANT_HPP"},{"location":"_autogen/Files/grant_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/grant_8hpp/#define-batteries_async_grant_hpp","title":"define BATTERIES_ASYNC_GRANT_HPP","text":"<pre><code>#define BATTERIES_ASYNC_GRANT_HPP()\n</code></pre>"},{"location":"_autogen/Files/grant_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_GRANT_HPP\n#define BATTERIES_ASYNC_GRANT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/scalable_grant.hpp&gt;\nnamespace batt {\nusing Grant = ScalableGrant;\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_GRANT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/group__by_8hpp/","title":"batteries/seq/group_by.hpp","text":""},{"location":"_autogen/Files/group__by_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/group__by_8hpp/#classes","title":"Classes","text":"Name class batt::seq::GroupBy class batt::seq::GroupBy::SubGroup struct batt::seq::GroupByBinder"},{"location":"_autogen/Files/group__by_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_GROUP_BY_HPP"},{"location":"_autogen/Files/group__by_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/group__by_8hpp/#define-batteries_seq_group_by_hpp","title":"define BATTERIES_SEQ_GROUP_BY_HPP","text":"<pre><code>#define BATTERIES_SEQ_GROUP_BY_HPP()\n</code></pre>"},{"location":"_autogen/Files/group__by_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_GROUP_BY_HPP\n#define BATTERIES_SEQ_GROUP_BY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/consume.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// group_by\n//\ntemplate &lt;typename Seq, typename GroupEq&gt;\nclass GroupBy\n{\npublic:\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;, \"GroupBy is not supported for Seq references.\");\nclass SubGroup;\nstatic void detach(SubGroup*, bool);\nusing SubGroupItem = SeqItem&lt;Seq&gt;;\nusing Item = SubGroup;\nexplicit GroupBy(Seq&amp;&amp; seq, GroupEq&amp;&amp; group_eq) noexcept\n: seq_(BATT_FORWARD(seq))\n, group_eq_(BATT_FORWARD(group_eq))\n, next_item_(seq_.next())\n{\n}\nexplicit GroupBy(Seq&amp;&amp; seq, GroupEq&amp;&amp; group_eq, Optional&lt;SubGroupItem&gt;&amp;&amp; next_item) noexcept\n: seq_(BATT_FORWARD(seq))\n, group_eq_(BATT_FORWARD(group_eq))\n, next_item_(std::move(next_item))\n{\n}\n~GroupBy() noexcept\n{\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\ndetach(this-&gt;sub_group_, /*skip_advance=*/true);\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// We need custom copy and move constructors because `sub_group_` contains a\n// back-reference to the GroupBy sequence object that needs to be fixed up\n// when we copy/move.\n//\nGroupBy(GroupBy&amp;&amp; that) noexcept\n: seq_(std::move(that.seq_))\n, group_eq_(std::move(that.group_eq_))\n, next_item_(std::move(that.next_item_))\n{\nmove_sub_group(std::move(that));\n}\nGroupBy&amp; operator=(GroupBy&amp;&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\ndetach(this-&gt;sub_group_, /*skip_advance=*/true);\nthis-&gt;seq_ = BATT_FORWARD(that.seq_);\nthis-&gt;group_eq_.emplace(BATT_FORWARD(*that.group_eq_));\nthis-&gt;next_item_ = BATT_FORWARD(that.next_item_);\nmove_sub_group(std::move(that));\n}\nreturn *this;\n}\nGroupBy(const GroupBy&amp; that) noexcept\n: seq_(that.seq_)\n, group_eq_(that.group_eq_)\n, next_item_(that.next_item_)\n{\ncopy_sub_group(that);\n}\nGroupBy&amp; operator=(const GroupBy&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\ndetach(this-&gt;sub_group_, /*skip_advance=*/true);\nthis-&gt;seq_ = that.seq_;\nthis-&gt;group_eq_.emplace(*that.group_eq_);\nthis-&gt;next_item_ = that.next_item_;\nthis-&gt;sub_group_ = nullptr;\ncopy_sub_group(that);\n}\nreturn *this;\n}\n//\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nOptional&lt;Item&gt; peek();\nOptional&lt;Item&gt; next();\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename Seq_, typename GroupEq_, typename Fn&gt;\nfriend LoopControl operator|(GroupBy&lt;Seq_, GroupEq_&gt;&amp;&amp; group_by_seq, ForEachBinder&lt;Fn&gt;&amp;&amp; binder);\ntemplate &lt;typename Seq_, typename GroupEq_, typename Fn&gt;\nfriend LoopControl operator|(typename GroupBy&lt;Seq_, GroupEq_&gt;::SubGroup&amp;&amp; sub_group,\nForEachBinder&lt;Fn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nvoid move_sub_group(GroupBy&amp;&amp; that)\n{\nif (that.sub_group_) {\nthis-&gt;sub_group_ = that.sub_group_;\nthis-&gt;sub_group_-&gt;group_by_ = this;\n} else {\nthis-&gt;sub_group_ = nullptr;\n}\nthat.sub_group_ = nullptr;\n}\nvoid copy_sub_group(const GroupBy&amp; that)\n{\nBATT_ASSERT(this-&gt;sub_group_ == nullptr);\nif (that.sub_group_) {\nSubGroup{&amp;this-&gt;sub_group_, this} | consume();\n}\nBATT_ASSERT(this-&gt;sub_group_ == nullptr);\n}\nOptional&lt;SubGroupItem&gt; sub_group_peek()\n{\nreturn next_item_;\n}\nOptional&lt;SubGroupItem&gt; sub_group_next();\nSubGroup* sub_group_ = nullptr;\nSeq seq_;\nOptional&lt;GroupEq&gt; group_eq_;\nOptional&lt;SeqItem&lt;Seq&gt;&gt; next_item_;\n};\ntemplate &lt;typename Seq, typename GroupEq&gt;\nclass GroupBy&lt;Seq, GroupEq&gt;::SubGroup\n{\npublic:\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;, \"\");\nfriend class GroupBy&lt;Seq, GroupEq&gt;;\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename Seq_, typename GroupEq_, typename Fn&gt;\nfriend LoopControl operator|(GroupBy&lt;Seq_, GroupEq_&gt;&amp;&amp; group_by_seq, ForEachBinder&lt;Fn&gt;&amp;&amp; binder);\ntemplate &lt;typename Seq_, typename GroupEq_, typename Fn&gt;\nfriend LoopControl operator|(typename GroupBy&lt;Seq_, GroupEq_&gt;::SubGroup&amp;&amp; sub_group,\nForEachBinder&lt;Fn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nusing Item = SeqItem&lt;Seq&gt;;\nprivate:\nexplicit SubGroup(SubGroup** sub_group_out, GroupBy* group_by) noexcept\n: private_group_by_{}\n, group_by_{group_by}\n{\nif (private_group_by_) {\nprivate_group_by_-&gt;sub_group_ = this;\n}\nif (sub_group_out) {\n*sub_group_out = this;\n}\n}\ntemplate &lt;typename... PrivateGroupByArgs&gt;\nexplicit SubGroup(SubGroup** sub_group_out, std::nullptr_t,\nPrivateGroupByArgs&amp;&amp;... private_group_by_args) noexcept\n: private_group_by_{InPlaceInit, BATT_FORWARD(private_group_by_args)...}\n, group_by_{private_group_by_.get_ptr()}\n{\nprivate_group_by_-&gt;sub_group_ = this;\nif (sub_group_out) {\n*sub_group_out = this;\n}\n}\npublic:\nSubGroup(SubGroup&amp;&amp; that) noexcept : group_by_{nullptr}\n{\nmove_impl(std::move(that));\n}\nSubGroup(const SubGroup&amp; that) noexcept : group_by_{nullptr}\n{\ncopy_impl(that);\n}\n~SubGroup() noexcept\n{\nif (this-&gt;group_by_) {\nGroupBy::detach(this, /*skip_advance=*/false);\n}\n}\nSubGroup&amp; operator=(SubGroup&amp;&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nif (this-&gt;group_by_) {\nGroupBy::detach(this, /*skip_advance=*/false);\n}\nmove_impl(std::move(that));\n}\nreturn *this;\n}\nSubGroup&amp; operator=(const SubGroup&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nif (this-&gt;group_by_) {\nGroupBy::detach(this, /*skip_advance=*/false);\n}\ncopy_impl(that);\n}\nreturn *this;\n}\nbool is_detached() const noexcept\n{\nif (this-&gt;group_by_ == nullptr) {\nreturn true;\n}\nBATT_ASSERT_IMPLIES(bool{this-&gt;private_group_by_},\nthis-&gt;group_by_ == this-&gt;private_group_by_.get_ptr());\nreturn bool{private_group_by_};\n}\nOptional&lt;Item&gt; peek()\n{\nif (!group_by_) {\nreturn None;\n}\nreturn group_by_-&gt;sub_group_peek();\n}\nOptional&lt;Item&gt; next()\n{\nif (!group_by_) {\nreturn None;\n}\nreturn group_by_-&gt;sub_group_next();\n}\nprivate:\nvoid move_impl(SubGroup&amp;&amp; that)\n{\nif (!that.group_by_) {\nthis-&gt;group_by_ = nullptr;\nthis-&gt;private_group_by_ = None;\nreturn;\n}\nif (that.private_group_by_) {\n{\nGroupBy&amp; that_group_by = *that.private_group_by_;\nthis-&gt;private_group_by_.emplace(std::move(that_group_by.seq_),\nstd::move(*that_group_by.group_eq_),\nstd::move(that_group_by.next_item_));\nthat_group_by.sub_group_ = nullptr;\n}\nthat.private_group_by_ = None;\nthis-&gt;group_by_ = this-&gt;private_group_by_.get_ptr();\n} else {\nthis-&gt;private_group_by_ = None;\nthis-&gt;group_by_ = that.group_by_;\n}\nthis-&gt;group_by_-&gt;sub_group_ = this;\nthat.group_by_ = nullptr;\n}\nvoid copy_impl(const SubGroup&amp; that)\n{\nif (!that.group_by_) {\nthis-&gt;group_by_ = nullptr;\nthis-&gt;private_group_by_ = None;\nreturn;\n}\nthis-&gt;private_group_by_.emplace(batt::make_copy(that.group_by_-&gt;seq_),\nbatt::make_copy(*that.group_by_-&gt;group_eq_),\nbatt::make_copy(that.group_by_-&gt;next_item_));\nthis-&gt;group_by_ = this-&gt;private_group_by_.get_ptr();\nthis-&gt;group_by_-&gt;sub_group_ = this;\n}\n// If this SubGroup is detached, private_group_by_ holds the GroupBy object to\n// which this-&gt;group_by_ points (if any).\n//\nOptional&lt;GroupBy&gt; private_group_by_;\n// If nullptr, then this SubGroup has been consumed.  Otherwise, points to the\n// sequence state for this SubGroup.\n//\nGroupBy* group_by_ = nullptr;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// If *p_sub_group points to a SubGroup that is attached to an external GroupBy\n// object, copy its external state into the sub group and set the GroupBy\n// sub_group_ pointer to nullptr.\n//\ntemplate &lt;typename Seq, typename GroupEq&gt;\ninline void GroupBy&lt;Seq, GroupEq&gt;::detach(SubGroup* sub_group, bool skip_advance)\n{\nif (!sub_group || sub_group-&gt;is_detached()) {\nreturn;\n}\nBATT_ASSERT(!sub_group-&gt;private_group_by_);\nBATT_ASSERT_NOT_NULLPTR(sub_group-&gt;group_by_);\nBATT_ASSERT_EQ(sub_group-&gt;group_by_-&gt;sub_group_, sub_group);\nsub_group-&gt;private_group_by_.emplace(batt::make_copy(sub_group-&gt;group_by_-&gt;seq_),\nbatt::make_copy(*sub_group-&gt;group_by_-&gt;group_eq_),\nbatt::make_copy(sub_group-&gt;group_by_-&gt;next_item_));\nif (skip_advance) {\nsub_group-&gt;group_by_-&gt;sub_group_ = nullptr;\n} else {\nGroupBy* const group_by = sub_group-&gt;group_by_;\nSubGroup{&amp;group_by-&gt;sub_group_, group_by} | consume();\nBATT_ASSERT(group_by-&gt;sub_group_ == nullptr);\n}\nsub_group-&gt;group_by_ = sub_group-&gt;private_group_by_.get_ptr();\nsub_group-&gt;group_by_-&gt;sub_group_ = sub_group;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Seq, typename GroupEq&gt;\ninline Optional&lt;typename GroupBy&lt;Seq, GroupEq&gt;::SubGroupItem&gt; GroupBy&lt;Seq, GroupEq&gt;::sub_group_next()\n{\nif (!next_item_) {\nBATT_ASSERT(this-&gt;sub_group_ == nullptr);\nreturn None;\n}\nOptional&lt;SeqItem&lt;Seq&gt;&gt; item = std::move(next_item_);\nnext_item_ = this-&gt;seq_.next();\nif (!next_item_ || !(*group_eq_)(*item, *next_item_)) {\nthis-&gt;sub_group_-&gt;group_by_ = nullptr;\nthis-&gt;sub_group_-&gt;private_group_by_ = None;\nthis-&gt;sub_group_ = nullptr;\n}\nreturn item;\n}\ntemplate &lt;typename Seq, typename GroupEq&gt;\ninline Optional&lt;typename GroupBy&lt;Seq, GroupEq&gt;::SubGroup&gt; GroupBy&lt;Seq, GroupEq&gt;::peek()\n{\nif (this-&gt;sub_group_ == nullptr) {\nif (!this-&gt;next_item_) {\nreturn None;\n}\nreturn {SubGroup{nullptr, nullptr, batt::make_copy(seq_), batt::make_copy(*group_eq_),\nbatt::make_copy(next_item_)}};\n}\nreturn GroupBy{static_cast&lt;const GroupBy&amp;&gt;(*this)}.peek();\n}\ntemplate &lt;typename Seq, typename GroupEq&gt;\ninline Optional&lt;typename GroupBy&lt;Seq, GroupEq&gt;::SubGroup&gt; GroupBy&lt;Seq, GroupEq&gt;::next()\n{\nif (this-&gt;sub_group_ != nullptr) {\ndetach(this-&gt;sub_group_, /*skip_advance=*/false);\n}\nBATT_ASSERT(this-&gt;sub_group_ == nullptr);\nif (!this-&gt;next_item_) {\nreturn None;\n}\nreturn {SubGroup{&amp;this-&gt;sub_group_, this}};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename GroupEq&gt;\nstruct GroupByBinder {\nGroupEq group_eq;\n};\ntemplate &lt;typename GroupEq&gt;\nGroupByBinder&lt;GroupEq&gt; group_by(GroupEq&amp;&amp; group_eq)\n{\nreturn {BATT_FORWARD(group_eq)};\n}\ntemplate &lt;typename Seq, typename GroupEq&gt;\n[[nodiscard]] GroupBy&lt;Seq, GroupEq&gt; operator|(Seq&amp;&amp; seq, GroupByBinder&lt;GroupEq&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"Grouped sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;GroupEq, std::decay_t&lt;GroupEq&gt;&gt;,\n\"Grouping functions may not be captured implicitly by reference.\");\nreturn GroupBy&lt;Seq, GroupEq&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.group_eq)};\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Seq, typename GroupEq, typename Fn&gt;\nLoopControl operator|(GroupBy&lt;Seq, GroupEq&gt;&amp;&amp; group_by_seq, ForEachBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nusing SubGroup = typename GroupBy&lt;Seq, GroupEq&gt;::SubGroup;\nwhile (group_by_seq.next_item_) {\nif (group_by_seq.sub_group_ != nullptr) {\ngroup_by_seq.detach(group_by_seq.sub_group_, /*skip_advance=*/false);\n}\nBATT_ASSERT(group_by_seq.sub_group_ == nullptr);\nif (BATT_HINT_FALSE(run_loop_fn(binder.fn, SubGroup{&amp;group_by_seq.sub_group_, &amp;group_by_seq}) ==\nkBreak)) {\nreturn kBreak;\n}\n}\nreturn kContinue;\n}\ntemplate &lt;typename Seq, typename GroupEq, typename Fn&gt;\nLoopControl operator|(typename GroupBy&lt;Seq, GroupEq&gt;::SubGroup&amp;&amp; sub_group, ForEachBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nGroupBy&lt;Seq, GroupEq&gt;* p_group_by = sub_group.group_by_;\nif (!p_group_by || !p_group_by-&gt;next_item_) {\nreturn kContinue;\n}\nauto&amp; group_by_seq = *p_group_by;\nauto&amp; group_eq = *group_by_seq.group_eq_;\nLoopControl first_result = run_loop_fn(binder.fn, *group_by_seq.next_item_);\nif (BATT_HINT_FALSE(first_result == kBreak)) {\ngroup_by_seq.next_item_ = group_by_seq.seq_.next();\nreturn kBreak;\n}\nOptional&lt;SeqItem&lt;Seq&gt;&gt; prev_item = std::move(group_by_seq.next_item_);\ngroup_by_seq.next_item_ = None;\nauto loop_body = [&amp;](auto&amp;&amp; item) -&gt; LoopControl {\nif (group_eq(*prev_item, item)) {\nLoopControl item_result = run_loop_fn(binder.fn, item);\nprev_item = BATT_FORWARD(item);\nreturn item_result;\n}\ngroup_by_seq.next_item_ = BATT_FORWARD(item);\nsub_group.group_by_ = nullptr;\nsub_group.private_group_by_ = None;\ngroup_by_seq.sub_group_ = nullptr;\nreturn kBreak;\n};\nLoopControl rest_result = group_by_seq.seq_ | for_each(loop_body);\nif (sub_group.group_by_ == nullptr) {\nreturn kContinue;\n}\nreturn rest_result;\n}\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_GROUP_BY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/handler_8hpp/","title":"batteries/async/handler.hpp","text":""},{"location":"_autogen/Files/handler_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/handler_8hpp/#classes","title":"Classes","text":"Name class batt::BasicAbstractHandler A type-erased async completion handler with linked list pointers. struct batt::BasicAbstractHandler::Deleter Deleter for use in std::unique_ptr. class batt::BasicHandlerImpl class batt::UniqueHandler class batt::HandlerBinder class batt::HandlerMemoryBase Abstract base for HandlerMemory. class batt::HandlerMemory A chunk of memory that can be attached to an async completion handler. class batt::HandlerAllocator An allocator associated with a completion handler. class batt::CustomAllocHandler Wrapper for an async completion handler type <code>Handler</code>."},{"location":"_autogen/Files/handler_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_HANDLER_HPP"},{"location":"_autogen/Files/handler_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/handler_8hpp/#define-batteries_async_handler_hpp","title":"define BATTERIES_ASYNC_HANDLER_HPP","text":"<pre><code>#define BATTERIES_ASYNC_HANDLER_HPP()\n</code></pre>"},{"location":"_autogen/Files/handler_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_HANDLER_HPP\n#define BATTERIES_ASYNC_HANDLER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/static_assert.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/asio/associated_allocator.hpp&gt;\n#include &lt;boost/asio/associated_executor.hpp&gt;\n#include &lt;boost/asio/post.hpp&gt;\n#include &lt;boost/intrusive/options.hpp&gt;\n#include &lt;boost/intrusive/slist.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nusing DefaultHandlerBase = boost::intrusive::slist_base_hook&lt;boost::intrusive::cache_last&lt;true&gt;,\nboost::intrusive::constant_time_size&lt;true&gt;&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename Base, typename... Args&gt;\nclass BasicAbstractHandler : public Base\n{\npublic:\nusing Self = BasicAbstractHandler;\nstruct Deleter {\nvoid operator()(Self* handler) const\n{\nif (handler != nullptr) {\nhandler-&gt;destroy();\n}\n}\n};\nBasicAbstractHandler(const Self&amp;) = delete;\nSelf&amp; operator=(const Self&amp;) = delete;\nvirtual void notify(Args... args) = 0;\nvirtual void destroy() = 0;\nvirtual void dump(std::ostream&amp; out) = 0;\nprotected:\nBasicAbstractHandler() = default;\n// The handler should only be deleted from inside `notify`.\n//\nvirtual ~BasicAbstractHandler() = default;\n};\ntemplate &lt;typename... Args&gt;\nusing AbstractHandler = BasicAbstractHandler&lt;DefaultHandlerBase, Args...&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename HandlerFn, typename Base, typename... Args&gt;\nclass BasicHandlerImpl : public BasicAbstractHandler&lt;Base, Args...&gt;\n{\npublic:\nusing Self = BasicHandlerImpl;\nstatic_assert(std::is_same_v&lt;HandlerFn, std::decay_t&lt;HandlerFn&gt;&gt;,\n\"HandlerFn may not be a reference type\");\nstatic_assert(batt::IsCallable&lt;HandlerFn, Args...&gt;{}, \"HandlerFn must be callable with (Args...)\");\nusing allocator_type = typename std::allocator_traits&lt;\nboost::asio::associated_allocator_t&lt;HandlerFn&gt;&gt;::template rebind_alloc&lt;Self&gt;;\ntemplate &lt;typename HandlerFnArg&gt;\nstatic Self* make_new(HandlerFnArg&amp;&amp; h)\n{\nallocator_type local_allocator = std::move(boost::asio::get_associated_allocator(h));\nvoid* memory = local_allocator.allocate(1);\nreturn new (memory) Self{BATT_FORWARD(h)};\n}\ntemplate &lt;typename HandlerFnArg&gt;\nstatic Self* make_new(HandlerFnArg&amp;&amp; h, usize extra_bytes)\n{\nallocator_type local_allocator = std::move(boost::asio::get_associated_allocator(h));\nvoid* memory = local_allocator.allocate(1 + (extra_bytes + sizeof(Self) - 1) / sizeof(Self));\nreturn new (memory) Self{BATT_FORWARD(h)};\n}\ntemplate &lt;typename HandlerFnArg, typename = batt::EnableIfNoShadow&lt;Self, HandlerFnArg&amp;&amp;&gt;&gt;\nexplicit BasicHandlerImpl(HandlerFnArg&amp;&amp; h) noexcept : fn_(BATT_FORWARD(h))\n{\n}\nvoid notify(Args... args) override\n{\nthis-&gt;consume_impl([&amp;](auto&amp;&amp; local_fn) {\nstd::move(local_fn)(BATT_FORWARD(args)...);\n});\n}\nvoid destroy() override\n{\nthis-&gt;consume_impl([](auto&amp;&amp; /*local_fn*/) { /* do nothing */ });\n}\nvoid dump(std::ostream&amp; out) override\n{\nout &lt;&lt; \"HandlerImpl&lt;\" &lt;&lt; name_of(StaticType&lt;HandlerFn&gt;{}) &lt;&lt; \"&gt;{}\";\n}\nHandlerFn&amp; get_fn()\n{\nreturn this-&gt;fn_;\n}\nprivate:\ntemplate &lt;typename FnAction&gt;\nvoid consume_impl(FnAction&amp;&amp; fn_action)\n{\nallocator_type local_allocator = std::move(boost::asio::get_associated_allocator(this-&gt;fn_));\nHandlerFn local_fn = std::move(this-&gt;fn_);\nthis-&gt;~Self();\nlocal_allocator.deallocate(this, 1);\nBATT_FORWARD(fn_action)(BATT_FORWARD(local_fn));\n}\nHandlerFn fn_;\n};\ntemplate &lt;typename HandlerFn, typename... Args&gt;\nusing HandlerImpl = BasicHandlerImpl&lt;HandlerFn, DefaultHandlerBase, Args...&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename... Args&gt;\nclass UniqueHandler\n{\npublic:\ntemplate &lt;typename Fn, typename = EnableIfNoShadow&lt;UniqueHandler, Fn&gt;,\ntypename = std::enable_if_t&lt;IsCallable&lt;std::decay_t&lt;Fn&gt;, Args...&gt;::value&gt;&gt;\nexplicit UniqueHandler(Fn&amp;&amp; fn) noexcept\n: handler_{HandlerImpl&lt;std::decay_t&lt;Fn&gt;, Args...&gt;::make_new(BATT_FORWARD(fn))}\n{\n}\nUniqueHandler() = default;\nUniqueHandler(const UniqueHandler&amp;) = delete;\nUniqueHandler&amp; operator=(const UniqueHandler&amp;) = delete;\nUniqueHandler(UniqueHandler&amp;&amp;) = default;\nUniqueHandler&amp; operator=(UniqueHandler&amp;&amp;) = default;\n~UniqueHandler() noexcept\n{\n}\nexplicit operator bool() const\n{\nreturn this-&gt;handler_ != nullptr;\n}\nvoid operator()(Args... args)\n{\nif (this-&gt;handler_ != nullptr) {\nauto* local_handler = this-&gt;handler_.release();\nlocal_handler-&gt;notify(BATT_FORWARD(args)...);\n}\n}\nfriend inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const UniqueHandler&amp; t)\n{\nif (t.handler_ == nullptr) {\nreturn out &lt;&lt; \"&lt;nullptr&gt;\";\n}\nout &lt;&lt; (void*)t.handler_.get() &lt;&lt; \": \";\nt.handler_-&gt;dump(out);\nreturn out;\n}\nprivate:\nstd::unique_ptr&lt;AbstractHandler&lt;Args...&gt;, typename AbstractHandler&lt;Args...&gt;::Deleter&gt; handler_;\n};\nBATT_STATIC_ASSERT_EQ(sizeof(UniqueHandler&lt;&gt;), sizeof(void*));\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename Base, typename... Args&gt;\nusing BasicHandlerList = boost::intrusive::slist&lt;BasicAbstractHandler&lt;Base, Args...&gt;,  //\nboost::intrusive::cache_last&lt;true&gt;,   //\nboost::intrusive::constant_time_size&lt;true&gt;&gt;;\ntemplate &lt;typename... Args&gt;\nusing HandlerList = BasicHandlerList&lt;DefaultHandlerBase, Args...&gt;;\ntemplate &lt;typename Base, typename... Args&gt;\ninline void push_handler_prealloc(boost::intrusive::slist&lt;BasicAbstractHandler&lt;Base, Args...&gt;,  //\nboost::intrusive::cache_last&lt;true&gt;,   //\nboost::intrusive::constant_time_size&lt;true&gt;&gt;* list,\nBasicAbstractHandler&lt;Base, Args...&gt;* handler)\n{\nlist-&gt;push_back(*handler);\n}\ntemplate &lt;typename... Args, typename Base, typename HandlerFn&gt;\ninline void push_handler(boost::intrusive::slist&lt;BasicAbstractHandler&lt;Base, Args...&gt;,  //\nboost::intrusive::cache_last&lt;true&gt;,   //\nboost::intrusive::constant_time_size&lt;true&gt;&gt;* list,\nHandlerFn&amp;&amp; fn)\n{\npush_handler_prealloc(list, BasicHandlerImpl&lt;HandlerFn, Base, Args...&gt;::make_new(BATT_FORWARD(fn)));\n}\ntemplate &lt;typename... Params, typename... Args, typename Base&gt;\ninline void invoke_all_handlers(boost::intrusive::slist&lt;BasicAbstractHandler&lt;Base, Params...&gt;,  //\nboost::intrusive::cache_last&lt;true&gt;,     //\nboost::intrusive::constant_time_size&lt;true&gt;&gt;* handlers,\nArgs&amp;&amp;... args)\n{\nwhile (!handlers-&gt;empty()) {\nBasicAbstractHandler&lt;Base, Params...&gt;&amp; l = handlers-&gt;front();\nhandlers-&gt;pop_front();\nl.notify(args...);\n}\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename InnerFn, typename OuterFn&gt;\nclass HandlerBinder\n{\npublic:\nusing allocator_type = boost::asio::associated_allocator_t&lt;InnerFn&gt;;\ntemplate &lt;typename InnerFnArg, typename OuterFnArg&gt;\nexplicit HandlerBinder(InnerFnArg&amp;&amp; inner, OuterFnArg&amp;&amp; outer)\n: inner_fn_{BATT_FORWARD(inner)}\n, outer_fn_{BATT_FORWARD(outer)}\n{\n}\nallocator_type get_allocator() const noexcept\n{\nreturn boost::asio::get_associated_allocator(this-&gt;inner_fn_);\n}\ntemplate &lt;typename... Args,\ntypename = std::enable_if_t&lt;batt::IsCallable&lt;OuterFn&amp;&amp;, InnerFn&amp;&amp;, Args&amp;&amp;...&gt;{}&gt;&gt;\nvoid operator()(Args&amp;&amp;... args) noexcept(noexcept(std::declval&lt;HandlerBinder*&gt;()-&gt;outer_fn_(\nBATT_FORWARD(std::declval&lt;HandlerBinder*&gt;()-&gt;inner_fn_), std::declval&lt;Args&gt;()...)))\n{\nthis-&gt;outer_fn_(BATT_FORWARD(this-&gt;inner_fn_), BATT_FORWARD(args)...);\n}\nInnerFn inner_fn_;\nOuterFn outer_fn_;\n};\ntemplate &lt;typename InnerFn, typename OuterFn&gt;\nHandlerBinder&lt;std::decay_t&lt;InnerFn&gt;, std::decay_t&lt;OuterFn&gt;&gt; bind_handler(InnerFn&amp;&amp; inner, OuterFn&amp;&amp; outer)\n{\nreturn HandlerBinder&lt;std::decay_t&lt;InnerFn&gt;, std::decay_t&lt;OuterFn&gt;&gt;{BATT_FORWARD(inner),\nBATT_FORWARD(outer)};\n}\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\nBATT_SUPPRESS_IF_GCC(\"-Wfree-nonheap-object\")\nclass HandlerMemoryBase\n{\npublic:\nexplicit HandlerMemoryBase(const MutableBuffer&amp; buffer) noexcept : buffer_{buffer}\n{\n}\nexplicit HandlerMemoryBase(void* ptr, usize size) noexcept : buffer_{ptr, size}\n{\n}\nHandlerMemoryBase(const HandlerMemoryBase&amp;) = delete;\nHandlerMemoryBase&amp; operator=(const HandlerMemoryBase&amp;) = delete;\nvirtual ~HandlerMemoryBase() = default;\nvoid* allocate(usize size)\n{\nif (!this-&gt;in_use_ &amp;&amp; size &lt;= this-&gt;buffer_.size()) {\nthis-&gt;in_use_ = true;\nreturn this-&gt;buffer_.data();\n} else {\nreturn ::operator new(size);\n}\n}\nvoid deallocate(void* pointer) noexcept\n{\nif (pointer == this-&gt;buffer_.data()) {\nthis-&gt;in_use_ = false;\n} else {\n::operator delete(pointer);\n}\n}\nbool in_use() const noexcept\n{\nreturn this-&gt;in_use_;\n}\nprivate:\n// The handler memory.\n//\nMutableBuffer buffer_;\n// Tracks whether the memory is currently in use.\n//\nbool in_use_ = false;\n};\ntemplate &lt;usize kSize&gt;\nclass HandlerMemory : public HandlerMemoryBase\n{\npublic:\nHandlerMemory() noexcept : HandlerMemoryBase{&amp;this-&gt;storage_, sizeof(this-&gt;storage_)}\n{\n}\nHandlerMemory(const HandlerMemory&amp;) = delete;\nHandlerMemory&amp; operator=(const HandlerMemory&amp;) = delete;\nprivate:\n// The memory.\n//\nstd::aligned_storage_t&lt;kSize&gt; storage_;\n};\ntemplate &lt;typename T&gt;\nclass HandlerAllocator;\ntemplate &lt;typename T, typename U&gt;\nbool operator==(const HandlerAllocator&lt;T&gt;&amp; left, const HandlerAllocator&lt;U&gt;&amp; right) noexcept;\ntemplate &lt;typename T, typename U&gt;\nbool operator!=(const HandlerAllocator&lt;T&gt;&amp; left, const HandlerAllocator&lt;U&gt;&amp; right) noexcept;\ntemplate &lt;typename T&gt;\nclass HandlerAllocator\n{\npublic:\ntemplate &lt;typename T_, typename U&gt;\nfriend bool operator==(const HandlerAllocator&lt;T_&gt;&amp; left, const HandlerAllocator&lt;U&gt;&amp; right) noexcept;\ntemplate &lt;typename T_, typename U&gt;\nfriend bool operator!=(const HandlerAllocator&lt;T_&gt;&amp; left, const HandlerAllocator&lt;U&gt;&amp; right) noexcept;\nusing value_type = T;\nexplicit HandlerAllocator(HandlerMemoryBase&amp; mem) : memory_(mem)\n{\n}\ntemplate &lt;typename U&gt;\nHandlerAllocator(const HandlerAllocator&lt;U&gt;&amp; that) noexcept : memory_(that.memory_)\n{\n}\nT* allocate(usize n) const\n{\nreturn static_cast&lt;T*&gt;(this-&gt;memory_.allocate(sizeof(T) * n));\n}\nvoid deallocate(T* p, usize /*n*/) const\n{\nreturn this-&gt;memory_.deallocate(p);\n}\nprivate:\ntemplate &lt;typename&gt;\nfriend class HandlerAllocator;\n// The attached memory.\n//\nHandlerMemoryBase&amp; memory_;\n};\ntemplate &lt;typename T, typename U&gt;\nbool operator==(const HandlerAllocator&lt;T&gt;&amp; left, const HandlerAllocator&lt;U&gt;&amp; right) noexcept\n{\nreturn &amp;left.memory_ == &amp;right.memory_;\n}\ntemplate &lt;typename T, typename U&gt;\nbool operator!=(const HandlerAllocator&lt;T&gt;&amp; left, const HandlerAllocator&lt;U&gt;&amp; right) noexcept\n{\nreturn !(left == right);\n}\ntemplate &lt;typename Handler&gt;\nclass CustomAllocHandler\n{\npublic:\nusing allocator_type = HandlerAllocator&lt;Handler&gt;;\ntemplate &lt;typename HandlerArg&gt;\nCustomAllocHandler(HandlerMemoryBase&amp; m, HandlerArg&amp;&amp; h)\n: memory_{&amp;m}\n, handler_(std::forward&lt;HandlerArg&gt;(h))\n{\n}\nallocator_type get_allocator() const noexcept\n{\nreturn allocator_type{*this-&gt;memory_};\n}\ntemplate &lt;typename... Args&gt;\nvoid operator()(Args&amp;&amp;... args) noexcept(noexcept(std::declval&lt;Handler&amp;&gt;()(std::declval&lt;Args&gt;()...)))\n{\nhandler_(std::forward&lt;Args&gt;(args)...);\n}\nconst Handler&amp; get_handler() const noexcept\n{\nreturn this-&gt;handler_;\n}\nprivate:\n// The attached memory.\n//\nHandlerMemoryBase* memory_;\n// The wrapped completion handler.\n//\nHandler handler_;\n};\ntemplate &lt;typename Handler&gt;\ninline CustomAllocHandler&lt;std::decay_t&lt;Handler&gt;&gt; make_custom_alloc_handler(HandlerMemoryBase&amp; m, Handler&amp;&amp; h)\n{\nreturn CustomAllocHandler&lt;std::decay_t&lt;Handler&gt;&gt;{m, std::forward&lt;Handler&gt;(h)};\n}\ntemplate &lt;typename Handler, typename... Args&gt;\nvoid post_handler(Handler&amp;&amp; handler, Args&amp;&amp;... args) noexcept\n{\nauto executor = boost::asio::get_associated_executor(handler);\nboost::asio::post(                                                                 //\nexecutor,                                                                      //\nbind_handler(                                                                  //\nBATT_FORWARD(handler),                                                     //\n[args = std::make_tuple(BATT_FORWARD(args)...)](auto&amp;&amp; handler) mutable {  //\nstd::apply(BATT_FORWARD(handler), std::move(args));\n}));\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_HANDLER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/hash_8hpp/","title":"batteries/hash.hpp","text":""},{"location":"_autogen/Files/hash_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/hash_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HASH_HPP"},{"location":"_autogen/Files/hash_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/hash_8hpp/#define-batteries_hash_hpp","title":"define BATTERIES_HASH_HPP","text":"<pre><code>#define BATTERIES_HASH_HPP()\n</code></pre>"},{"location":"_autogen/Files/hash_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HASH_HPP\n#define BATTERIES_HASH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/functional/hash.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ninline usize hash()\n{\nreturn 0;\n}\ntemplate &lt;typename T&gt;\nusize hash(T&amp;&amp; obj)\n{\nreturn boost::hash&lt;T&gt;{}(BATT_FORWARD(obj));\n}\ntemplate &lt;typename T, typename HashT = typename std::decay_t&lt;T&gt;::Hash&gt;\nusize hash_value(T&amp;&amp; obj)\n{\nstatic const HashT hash_impl;\nreturn hash_impl(obj);\n}\ntemplate &lt;typename First, typename... Rest&gt;\nusize hash(First&amp;&amp; first, Rest&amp;&amp;... rest)\n{\nusize seed = batt::hash(BATT_FORWARD(first));\nboost::hash_combine(seed, batt::hash(BATT_FORWARD(rest)...));\nreturn seed;\n}\n}  // namespace batt\n#endif  // BATTERIES_HASH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/hint_8hpp/","title":"batteries/hint.hpp","text":""},{"location":"_autogen/Files/hint_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/hint_8hpp/#defines","title":"Defines","text":"Name BATT_HINT_TRUE(expr) BATT_HINT_FALSE(expr)"},{"location":"_autogen/Files/hint_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/hint_8hpp/#define-batt_hint_true","title":"define BATT_HINT_TRUE","text":"<pre><code>#define BATT_HINT_TRUE(expr)\n</code></pre>"},{"location":"_autogen/Files/hint_8hpp/#define-batt_hint_false","title":"define BATT_HINT_FALSE","text":"<pre><code>#define BATT_HINT_FALSE(expr)\n</code></pre>"},{"location":"_autogen/Files/hint_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\n// =============================================================================\n// Branch prediction hints.\n//\n#ifdef BATT_PLATFORM_IS_WINDOWS\n#define BATT_HINT_TRUE(expr) static_cast&lt;bool&gt;(expr)\n#define BATT_HINT_FALSE(expr) static_cast&lt;bool&gt;(expr)\n#else\n#define BATT_HINT_TRUE(expr) __builtin_expect(static_cast&lt;bool&gt;(expr), 1)\n#define BATT_HINT_FALSE(expr) __builtin_expect(static_cast&lt;bool&gt;(expr), 0)\n#endif\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/host__address_8hpp/","title":"batteries/http/host_address.hpp","text":""},{"location":"_autogen/Files/host__address_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/host__address_8hpp/#classes","title":"Classes","text":"Name struct batt::HostAddress"},{"location":"_autogen/Files/host__address_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HOST_ADDRESS_HPP"},{"location":"_autogen/Files/host__address_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/host__address_8hpp/#define-batteries_http_host_address_hpp","title":"define BATTERIES_HTTP_HOST_ADDRESS_HPP","text":"<pre><code>#define BATTERIES_HTTP_HOST_ADDRESS_HPP()\n</code></pre>"},{"location":"_autogen/Files/host__address_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HOST_ADDRESS_HPP\n#define BATTERIES_HTTP_HOST_ADDRESS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;boost/asio/ip/tcp.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#include &lt;boost/functional/hash.hpp&gt;\n#include &lt;string&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nstruct HostAddress {\nstd::string scheme;\nstd::string hostname;\nOptional&lt;i64&gt; port;\nfriend usize hash_value(const HostAddress&amp; host_key);\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;SmallVec&lt;boost::asio::ip::tcp::endpoint&gt;&gt; await_resolve(\nboost::asio::ip::tcp::resolver&amp; resolver, const HostAddress&amp; host_address)\n{\nauto hosts = Task::await&lt;IOResult&lt;boost::asio::ip::tcp::resolver::results_type&gt;&gt;([&amp;](auto&amp;&amp; handler) {\nresolver.async_resolve(host_address.hostname, host_address.scheme, BATT_FORWARD(handler));\n});\nBATT_REQUIRE_OK(hosts);\nSmallVec&lt;boost::asio::ip::tcp::endpoint&gt; endpoints;\nfor (const auto&amp; result : *hosts) {\nauto endpoint = result.endpoint();\nif (host_address.port) {\nendpoint.port(*host_address.port);\n}\nendpoints.emplace_back(std::move(endpoint));\n}\nreturn endpoints;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;SmallVec&lt;boost::asio::ip::tcp::endpoint&gt;&gt; await_resolve(boost::asio::io_context&amp; io,\nconst HostAddress&amp; host_address)\n{\nboost::asio::ip::tcp::resolver resolver{io};\nreturn await_resolve(resolver, host_address);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline usize hash_value(const HostAddress&amp; host_key)\n{\nusize seed = 0;\nboost::hash_combine(seed, host_key.scheme);\nboost::hash_combine(seed, host_key.hostname);\nboost::hash_combine(seed, host_key.port.value_or(-1));\nreturn seed;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline bool operator==(const HostAddress&amp; l, const HostAddress&amp; r)\n{\nreturn l.scheme == r.scheme &amp;&amp; l.hostname == r.hostname &amp;&amp; l.port == r.port;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline bool operator!=(const HostAddress&amp; l, const HostAddress&amp; r)\n{\nreturn !(l == r);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const HostAddress&amp; t)\n{\nreturn out &lt;&lt; \"HostAddress{.scheme=\" &lt;&lt; batt::c_str_literal(t.scheme)\n&lt;&lt; \", .hostname=\" &lt;&lt; batt::c_str_literal(t.hostname) &lt;&lt; \", .port=\" &lt;&lt; t.port &lt;&lt; \",}\";\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HOST_ADDRESS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/","title":"batteries/http/http_chunk_decoder.hpp","text":""},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#classes","title":"Classes","text":"Name class batt::HttpChunkDecoder BufferSource transformer that decodes HTTP chunked content fetched from <code>Src</code>."},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#define-batteries_http_http_chunk_decoder_hpp","title":"define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__chunk__decoder_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP\n#define BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/pico_http/parser.hpp&gt;\nnamespace batt {\ntemplate &lt;typename Src&gt;\nclass HttpChunkDecoder\n{\npublic:\nstatic constexpr usize kBufferVecPreAlloc = 2;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit HttpChunkDecoder(Src&amp;&amp; src,\nIncludeHttpTrailer consume_trailer = IncludeHttpTrailer{false}) noexcept\n: src_{BATT_FORWARD(src)}\n{\nstd::memset(&amp;this-&gt;decoder_checkpoint_, 0, sizeof(pico_http::ChunkedDecoder));\nthis-&gt;decoder_checkpoint_.consume_trailer = consume_trailer;\nthis-&gt;decoder_latest_ = this-&gt;decoder_checkpoint_;\n}\n// The current number of bytes available as consumable data.\n//\nusize size() const\n{\nreturn this-&gt;output_available_ - this-&gt;output_consumed_;\n}\n// The decoder has completed.\n//\nbool done() const\n{\nreturn this-&gt;done_;\n}\n// Returns a ConstBufferSequence containing at least `min_count` bytes of data.\n//\n// This method may block the current task if there isn't enough data available to satisfy\n// the request (i.e., if `this-&gt;size() &lt; min_count`).\n//\nStatusOr&lt;SmallVec&lt;ConstBuffer, kBufferVecPreAlloc&gt;&gt; fetch_at_least(const i64 min_count_i)\n{\nconst usize min_count = BATT_CHECKED_CAST(usize, min_count_i);\n// Keep decoding chunks from the src stream until we have at least the minimum amount of bytes.\n//\nwhile (this-&gt;size() &lt; min_count) {\nif (this-&gt;done_) {\nif (this-&gt;size() == 0) {\nthis-&gt;release_decoded_chunks();\n}\nreturn {StatusCode::kEndOfStream};\n}\n// Calculate the minimum count we will need to fetch from `src_` to make up the difference between\n// `this-&gt;size()` and `min_count`.\n//\nconst i64 src_min_count = BATT_CHECKED_CAST(i64, this-&gt;decoded_src_size_) +\n(min_count_i - BATT_CHECKED_CAST(i64, this-&gt;size()));\n// Fetch more source data.\n//\nauto fetched = this-&gt;src_.fetch_at_least(src_min_count);\n// Handle the case where the src stream ends before we fetch enough data to satisfy `min_count`.\n//\nif (!fetched.ok() &amp;&amp; fetched.status() == StatusCode::kEndOfStream &amp;&amp; !this-&gt;done_) {\nif (this-&gt;size() == 0) {\nthis-&gt;release_decoded_chunks();\n}\nreturn {StatusCode::kClosedBeforeEndOfStream};\n}\n// All other fetch errors are fatal for the decoded stream.\n//\nBATT_REQUIRE_OK(fetched);\n// Rewind the decoder and re-parse the fetched src data.\n//\nthis-&gt;decoded_src_size_ = 0;\nthis-&gt;decoded_chunks_.clear();\nthis-&gt;decoder_latest_ = this-&gt;decoder_checkpoint_;\nusize n_to_consume_from_src = 0;\nconst auto on_loop_exit = finally([&amp;] {\nif (n_to_consume_from_src &gt; 0) {\nthis-&gt;consume_from_src(n_to_consume_from_src);\n}\nthis-&gt;output_available_ = boost::asio::buffer_size(this-&gt;decoded_chunks_);\n});\nfor (ConstBuffer src_buffer : *fetched) {\nStatusOr&lt;pico_http::DecodeResult&gt; result =\npico_http::decode_chunked(&amp;this-&gt;decoder_latest_, src_buffer, &amp;this-&gt;decoded_chunks_);\nBATT_REQUIRE_OK(result);\nthis-&gt;decoded_src_size_ += result-&gt;bytes_consumed;\n// On a chunk-by-chunk basis, consume data from src once we have \"proven\" that the\n// corresponding point in the decoded stream has been consumed by the application.\n//\nif (this-&gt;output_consumed_ != 0) {\nconst usize decoded_size = boost::asio::buffer_size(this-&gt;decoded_chunks_);\nif (this-&gt;output_consumed_ &gt;= decoded_size) {\nthis-&gt;output_consumed_ -= decoded_size;\nthis-&gt;decoded_chunks_.clear();\nthis-&gt;decoder_checkpoint_ = this-&gt;decoder_latest_;\n// Add all the counts to consume and just make a single call to `this-&gt;src_.consume`\n// at the end of the outer loop.\n//\nn_to_consume_from_src += result-&gt;bytes_consumed;\n//\n// this-&gt;decoded_src_size_ will be adjusted later, when we call\n// `this-&gt;consume_from_src(...)`.\n}\n}\n// Stop decoding chunks once the decoder tells us we've reached end-of-stream.  This only\n// breaks out of the inner loop; we'll go back up to the top and if we have enough decoded\n// data (&gt;= min_count), return successfully, else return StatusCode::kEndOfStream.\n//\nif (result-&gt;done) {\nthis-&gt;done_ = true;\nbreak;\n}\n}\n}\nreturn consume_buffers_copy(this-&gt;decoded_chunks_, this-&gt;output_consumed_);\n}\n// Consume the specified number of bytes from the front of the stream so that future calls to\n// `fetch_at_least` will not return the same data.\n//\nvoid consume(i64 count)\n{\nthis-&gt;output_consumed_ += count;\nBATT_CHECK_LE(this-&gt;output_consumed_, this-&gt;output_available_);\nif (this-&gt;output_consumed_ == this-&gt;output_available_) {\nthis-&gt;release_decoded_chunks();\n}\n}\n// Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods).  This\n// signals to the buffer (and all other clients of this object) that no more data will be read/consumed.\n//\nvoid close_for_read()\n{\nthis-&gt;release_decoded_chunks();\n}\nprivate:\nvoid release_decoded_chunks()\n{\nthis-&gt;output_available_ = 0;\nthis-&gt;output_consumed_ = 0;\nthis-&gt;decoded_chunks_.clear();\nthis-&gt;decoder_checkpoint_ = this-&gt;decoder_latest_;\nthis-&gt;consume_from_src(this-&gt;decoded_src_size_);\n}\nvoid consume_from_src(usize count)\n{\nthis-&gt;decoded_src_size_ -= count;\nthis-&gt;src_.consume(count);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nSrc src_;\npico_http::ChunkedDecoder decoder_checkpoint_;\npico_http::ChunkedDecoder decoder_latest_;\nbool done_ = false;\nusize decoded_src_size_ = 0;\nusize output_available_ = 0;\nusize output_consumed_ = 0;\nSmallVec&lt;ConstBuffer, kBufferVecPreAlloc&gt; decoded_chunks_;\n};\nstatic_assert(has_buffer_source_requirements&lt;HttpChunkDecoder&lt;StreamBuffer&amp;&gt;&gt;(), \"\");\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_CHUNK_DECODER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/","title":"batteries/http/http_chunk_encoder.hpp","text":""},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#define-batteries_http_http_chunk_encoder_hpp","title":"define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__chunk__encoder_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP\n#define BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;array&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Src, typename AsyncWriteStream&gt;\ninline Status http_encode_chunked(Src&amp;&amp; src, AsyncWriteStream&amp;&amp; dst,\nIncludeHttpTrailer include_trailer = IncludeHttpTrailer{false})\n{\nstatic const std::array&lt;char, 16&gt; hex_digits = {'0', '1', '2', '3', '4', '5', '6', '7',\n'8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\nstatic const ConstBuffer last_chunk{\"\\r\\n0\\r\\n\", 5};\nstatic const ConstBuffer last_chunk_with_trailer{\"\\r\\n0\\r\\n\\r\\n\", 7};\nconst auto encode_hex = [](u64 n, char* dst) -&gt; char* {\nif (n == 0) {\n*dst = '0';\nreturn dst + 1;\n}\ni32 bit_offset = sizeof(u64) * 8 - 4;\nwhile ((n &amp; (u64{0b1111} &lt;&lt; bit_offset)) == 0) {\nbit_offset -= 4;\n}\ndo {\n*dst = hex_digits[(n &gt;&gt; bit_offset) &amp; 0b1111];\n++dst;\nbit_offset -= 4;\n} while (bit_offset &gt;= 0);\nreturn dst;\n};\nstd::array&lt;char, sizeof(u64) * 2 + 4&gt; header_storage;\nbool first_chunk = true;\nfor (;;) {\nauto fetched_chunks = src.fetch_at_least(1);\nif (fetched_chunks.status() == StatusCode::kEndOfStream) {\nIOResult&lt;usize&gt; result = Task::await_write(dst, [&amp;] {\nif (include_trailer) {\nreturn last_chunk_with_trailer;\n} else {\nreturn last_chunk;\n}\n}());\nBATT_REQUIRE_OK(result);\nreturn OkStatus();\n}\nBATT_REQUIRE_OK(fetched_chunks);\nusize n_consumed = 0;\nauto on_scope_exit = finally([&amp;] {\nsrc.consume(n_consumed);\n});\nfor (ConstBuffer chunk : *fetched_chunks) {\nchar* const header_begin = header_storage.data();\nchar* header_end = header_begin;\nif (!first_chunk) {\nheader_end[0] = '\\r';\nheader_end[1] = '\\n';\nheader_end += 2;\n}\nfirst_chunk = false;\nheader_end = encode_hex(chunk.size(), header_end);\nheader_end[0] = '\\r';\nheader_end[1] = '\\n';\nheader_end += 2;\nSmallVec&lt;ConstBuffer, 2&gt; data;\ndata.emplace_back(ConstBuffer{header_begin, BATT_CHECKED_CAST(usize, header_end - header_begin)});\nif (chunk.size() &gt; 0) {\ndata.emplace_back(chunk);\n}\nIOResult&lt;usize&gt; result = Task::await_write(dst, data);\nBATT_REQUIRE_OK(result);\nBATT_CHECK_GT(chunk.size(), 0);\nn_consumed += chunk.size();\n}\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_CHUNK_ENCODER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client_8cpp/","title":"batteries/http/http_client.cpp","text":""},{"location":"_autogen/Files/http__client_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client.hpp&gt;\n//\n#include &lt;batteries/http/http_client_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client_8hpp/","title":"batteries/http/http_client.hpp","text":""},{"location":"_autogen/Files/http__client_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/http__client_8hpp/#classes","title":"Classes","text":"Name class batt::HttpClient An HTTP/1.1 client implementation. class batt::DefaultHttpClient A singleton instance of HttpClient; contains an io_context and thread pool (size == 1). class batt::detail::HttpClientRequestContext"},{"location":"_autogen/Files/http__client_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_CLIENT_HPP"},{"location":"_autogen/Files/http__client_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__client_8hpp/#define-batteries_http_client_hpp","title":"define BATTERIES_HTTP_CLIENT_HPP","text":"<pre><code>#define BATTERIES_HTTP_CLIENT_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__client_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_CLIENT_HPP\n#define BATTERIES_HTTP_CLIENT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/host_address.hpp&gt;\n#include &lt;batteries/http/http_client_connection_decl.hpp&gt;\n#include &lt;batteries/http/http_client_host_context_decl.hpp&gt;\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_header.hpp&gt;\n#include &lt;batteries/http/http_request.hpp&gt;\n#include &lt;batteries/http/http_response.hpp&gt;\n#include &lt;batteries/http/http_version.hpp&gt;\n#include &lt;batteries/pico_http/parser.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/case_of.hpp&gt;\n#include &lt;batteries/no_destruct.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/url_parse.hpp&gt;\n#include &lt;boost/asio/executor_work_guard.hpp&gt;\n#include &lt;boost/asio/ip/tcp.hpp&gt;\n#include &lt;boost/functional/hash.hpp&gt;\n#include &lt;unordered_map&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nclass HttpClient\n{\npublic:\nBATT_STRONG_TYPEDEF(bool, CreateIfNotFound);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr boost::asio::ssl::context::method kDefaultSslMethod = boost::asio::ssl::context::tlsv12;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit HttpClient(boost::asio::io_context&amp; io) noexcept;\nboost::asio::io_context&amp; get_io_context() const noexcept\n{\nreturn this-&gt;io_;\n}\nstd::function&lt;void(Optional&lt;boost::asio::ssl::context&gt;&amp;, const HostAddress&amp;)&gt; get_ssl_init_fn()\nconst noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;ssl_init_fn_mutex_};\nreturn this-&gt;ssl_init_fn_;\n}\nvoid set_ssl_init_fn(\nstd::function&lt;void(Optional&lt;boost::asio::ssl::context&gt;&amp;, const HostAddress&amp;)&gt;&amp;&amp; fn) noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;ssl_init_fn_mutex_};\nthis-&gt;ssl_init_fn_ = std::move(fn);\n}\nStatus submit_request(const HostAddress&amp; host_address, Pin&lt;HttpRequest&gt;&amp;&amp; request,\nPin&lt;HttpResponse&gt;&amp;&amp; response);\nusize get_default_max_connections_per_host() const noexcept;\nvoid set_default_max_connections_per_host(usize max_connections) noexcept;\nvoid set_max_connections_per_host(const HostAddress&amp; host_address, usize max_connections) noexcept;\ni32 get_default_connection_timeout_ms() const noexcept;\nvoid set_default_connection_timeout_ms(i32 timeout_ms) noexcept;\nusize count_active_connections() const noexcept;\nusize count_active_connections_for_host(const HostAddress&amp; host_address) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nSharedPtr&lt;HttpClientHostContext&gt; find_host_context(const HostAddress&amp; host_address,\nCreateIfNotFound create = CreateIfNotFound{true});\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::asio::io_context&amp; io_;\nmutable std::mutex ssl_init_fn_mutex_;\nstd::function&lt;void(Optional&lt;boost::asio::ssl::context&gt;&amp;, const HostAddress&amp;)&gt; ssl_init_fn_ =\n[](Optional&lt;boost::asio::ssl::context&gt;&amp; context, const HostAddress&amp;) {\ncontext.emplace(HttpClient::kDefaultSslMethod);\n};\nstd::atomic&lt;usize&gt; default_max_connections_per_host_;\nstd::atomic&lt;usize&gt; default_connection_timeout_ms_;\nMutex&lt;std::unordered_map&lt;HostAddress, SharedPtr&lt;HttpClientHostContext&gt;, boost::hash&lt;HostAddress&gt;&gt;&gt;\nhost_contexts_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nclass DefaultHttpClient\n{\npublic:\nstatic HttpClient&amp; get()\n{\n// Use NoDestruct to avoid shutdown problems.\n//\nstatic NoDestruct&lt;DefaultHttpClient&gt; default_client_;\nreturn default_client_-&gt;client_;\n}\nprivate:\nboost::asio::io_context io_;\nOptional&lt;boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;&gt; work_guard_{\nthis-&gt;io_.get_executor()};\nHttpClient client_{this-&gt;io_};\nstd::thread io_thread_{[this] {\nthis-&gt;io_.run();\n}};\n};\nnamespace detail {\nclass HttpClientRequestContext\n{\npublic:\nexplicit HttpClientRequestContext()\n{\nthis-&gt;set_version(HttpVersion{1, 1}).IgnoreError();\nthis-&gt;request_.async_set_message(this-&gt;message_);\nthis-&gt;request_.async_set_data(this-&gt;data_);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStatus set_params()\n{\nreturn OkStatus();\n}\ntemplate &lt;typename... Rest&gt;\nStatus set_params(const HttpHeader&amp; hdr, Rest&amp;&amp;... rest)\n{\nthis-&gt;set_header(hdr);\nthis-&gt;message_.headers.push_back(hdr);\nreturn this-&gt;set_params(BATT_FORWARD(rest)...);\n}\ntemplate &lt;typename... Rest&gt;\nStatus set_params(HttpData&amp;&amp; data, Rest&amp;&amp;... rest)\n{\nthis-&gt;set_data(std::move(data));\nreturn this-&gt;set_params(BATT_FORWARD(rest)...);\n}\ntemplate &lt;typename... Rest&gt;\nStatus set_params(HttpClient&amp; client, Rest&amp;&amp;... rest)\n{\nthis-&gt;client_ = &amp;client;\nreturn this-&gt;set_params(BATT_FORWARD(rest)...);\n}\ntemplate &lt;typename... Rest&gt;\nStatus set_params(HttpResponse* response, Rest&amp;&amp;... rest)\n{\nBATT_CHECK_NOT_NULLPTR(response);\nthis-&gt;set_response_object(response);\nreturn this-&gt;set_params(BATT_FORWARD(rest)...);\n}\ntemplate &lt;typename... Rest&gt;\nStatus set_params(const HttpVersion&amp; version, Rest&amp;&amp;... rest)\n{\nStatus result = this-&gt;set_version(version);\nBATT_REQUIRE_OK(result);\nreturn this-&gt;set_params(BATT_FORWARD(rest)...);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStatus set_version(const HttpVersion&amp; version)\n{\nthis-&gt;message_.major_version = version.major_version;\nthis-&gt;message_.minor_version = version.minor_version;\nreturn OkStatus();\n}\nStatus set_method(std::string_view method)\n{\nthis-&gt;message_.method = method;\nreturn OkStatus();\n}\nStatus set_path(std::string_view path)\n{\nthis-&gt;message_.path = path;\nreturn OkStatus();\n}\nStatus set_url(const UrlParse&amp; url)\n{\nthis-&gt;host_address_.scheme = url.scheme;\nthis-&gt;host_address_.hostname = url.host;\nthis-&gt;host_address_.port = url.port;\nusize needed = url.path.size();\nif (!url.query.empty()) {\nneeded += 1 + url.query.size();\n}\nif (!url.fragment.empty()) {\nneeded += 1 + url.fragment.size();\n}\nthis-&gt;path_.reserve(needed);\nthis-&gt;path_ = url.path;\nif (!url.query.empty()) {\nthis-&gt;path_ += \"?\";\nthis-&gt;path_ += url.query;\n}\nif (!url.fragment.empty()) {\nthis-&gt;path_ += \"#\";\nthis-&gt;path_ += url.fragment;\n}\nthis-&gt;message_.path = this-&gt;path_;\nreturn OkStatus();\n}\nvoid set_header(const HttpHeader&amp; hdr)\n{\nthis-&gt;message_.headers.push_back(hdr);\n}\nvoid set_data(HttpData&amp;&amp; data)\n{\nthis-&gt;data_ = std::move(data);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nHttpResponse* get_response_object() const noexcept\n{\nreturn this-&gt;response_;\n}\nvoid set_response_object(HttpResponse* response) noexcept\n{\nthis-&gt;response_ = response;\n}\nconst HttpRequest* get_request_object() const noexcept\n{\nreturn &amp;this-&gt;request_;\n}\nHttpRequest* get_request_object() noexcept\n{\nreturn &amp;this-&gt;request_;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStatus submit()\n{\nBATT_CHECK_NOT_NULLPTR(this-&gt;client_);\nBATT_CHECK_NOT_NULLPTR(this-&gt;response_);\n// TODO [tastolfi 2022-03-29] Check headers and adjust `this-&gt;data_` accordingly.\nthis-&gt;request_.state().set_value(HttpRequest::kInitialized);\nreturn this-&gt;client_-&gt;submit_request(this-&gt;host_address_, make_pin(&amp;this-&gt;request_),\nmake_pin(this-&gt;response_));\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nHttpClient* client_ = &amp;DefaultHttpClient::get();\nstd::string path_;\nstd::string content_length_;\nHostAddress host_address_;\npico_http::Request message_;\nHttpData data_;\nHttpRequest request_;\nHttpResponse* response_ = nullptr;\n};  // class HttpClientRequestContext\n}  // namespace detail\ntemplate &lt;typename... Params&gt;\nStatusOr&lt;std::unique_ptr&lt;HttpResponse&gt;&gt; http_request(std::string_view method, std::string_view url,\nParams&amp;&amp;... params)\n{\nStatusOr&lt;UrlParse&gt; url_parse = parse_url(url);\nBATT_REQUIRE_OK(url_parse);\n// Create a request context object to hold all the things we may need to submit the request.\n//\ndetail::HttpClientRequestContext context;\n// Initialize the request from args.\n//\nStatus method_status = context.set_method(method);\nBATT_REQUIRE_OK(method_status);\nStatus path_status = context.set_url(*url_parse);\nBATT_REQUIRE_OK(path_status);\nStatus params_status = context.set_params(BATT_FORWARD(params)...);\nBATT_REQUIRE_OK(params_status);\n// If the caller did not pass an HttpResponse object to receive the response, then create one to\n// use/return.\n//\nstd::unique_ptr&lt;HttpResponse&gt; new_response;\nif (context.get_response_object() == nullptr) {\nnew_response = std::make_unique&lt;HttpResponse&gt;();\ncontext.set_response_object(new_response.get());\n}\n// The request is now ready to go!\n//\nStatus submitted = context.submit();\nBATT_REQUIRE_OK(submitted);\n//----- --- -- -  -  -   -\n// Before we can return, we must make sure that the context object is not in use by the HttpClient.\n//----- --- -- -  -  -   -\nHttpRequest* const request = context.get_request_object();\nHttpResponse* const response = context.get_response_object();\n// Await notification from the HttpClient that our request has been fully consumed.\n//\nStatus request_consumed = request-&gt;state().await_equal(HttpRequest::kConsumed);\nif (!request_consumed.ok()) {\nBATT_REQUIRE_OK(request-&gt;get_status());\n}\nBATT_REQUIRE_OK(request_consumed);\n// Await notification from the HttpClient that the response has been read and parsed; this is not required\n// for object/reference lifetime issues (like `request` above), but rather so that any errors in the\n// response can be reported via StatusCode from this function.\n//\n// TODO [tastolfi 2022-05-06] Should we provide an option to skip this step?\n//\nStatus response_received = response-&gt;state().await_equal(HttpResponse::kInitialized);\nif (!response_received.ok()) {\nBATT_REQUIRE_OK(response-&gt;get_status());\n}\nBATT_REQUIRE_OK(response_received);\n// Return the response that was created on behalf of the caller, if there was one.  NOTE: if this is\n// nullptr, that isn't an error, it just means that the caller supplied their own HttpResponse object\n// pointer.\n//\nreturn new_response;\n}\ntemplate &lt;typename... Params&gt;\nStatusOr&lt;std::unique_ptr&lt;HttpResponse&gt;&gt; http_get(std::string_view url, Params&amp;&amp;... params)\n{\nreturn http_request(\"GET\", url, BATT_FORWARD(params)...);\n}\ntemplate &lt;typename... Params&gt;\nStatusOr&lt;std::unique_ptr&lt;HttpResponse&gt;&gt; http_post(std::string_view url, Params&amp;&amp;... params)\n{\nreturn http_request(\"POST\", url, BATT_FORWARD(params)...);\n}\ntemplate &lt;typename... Params&gt;\nStatusOr&lt;std::unique_ptr&lt;HttpResponse&gt;&gt; http_put(std::string_view url, Params&amp;&amp;... params)\n{\nreturn http_request(\"PUT\", url, BATT_FORWARD(params)...);\n}\ntemplate &lt;typename... Params&gt;\nStatusOr&lt;std::unique_ptr&lt;HttpResponse&gt;&gt; http_delete(std::string_view url, Params&amp;&amp;... params)\n{\nreturn http_request(\"DELETE\", url, BATT_FORWARD(params)...);\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_CLIENT_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client_connection_impl.hpp&gt;\n#include &lt;batteries/http/http_client_host_context_impl.hpp&gt;\n#include &lt;batteries/http/http_client_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__connection_8cpp/","title":"batteries/http/http_client_connection.cpp","text":""},{"location":"_autogen/Files/http__client__connection_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client_connection.hpp&gt;\n//\n#include &lt;batteries/http/http_client_connection_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__connection_8hpp/","title":"batteries/http/http_client_connection.hpp","text":""},{"location":"_autogen/Files/http__client__connection_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_client_connection_decl.hpp&gt;\n#include &lt;batteries/http/http_client_connection.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client_connection_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/","title":"batteries/http/http_client_connection_decl.hpp","text":""},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#classes","title":"Classes","text":"Name class batt::BasicHttpClientConnection"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#define-batteries_http_http_client_connection_decl_hpp","title":"define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__client__connection__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP\n#define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_request.hpp&gt;\n#include &lt;batteries/http/http_response.hpp&gt;\n#include &lt;batteries/http/ssl_transport.hpp&gt;\n#include &lt;batteries/http/tcp_transport.hpp&gt;\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/asio/deadline_timer.hpp&gt;\n#include &lt;batteries/asio/ip_tcp.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\nnamespace batt {\nclass HttpClientHostContext;\ntemplate &lt;typename Transport&gt;\nclass BasicHttpClientConnection\n{\npublic:\nstatic void spawn(HttpClientHostContext&amp; context, Watch&lt;usize&gt;&amp; active_connections) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nexplicit BasicHttpClientConnection(HttpClientHostContext&amp; context) noexcept;\nvoid run();\nStatus process_requests();\nStatus fill_input_buffer();\nStatus process_responses();\nStatus open_connection();\nvoid halt() noexcept;\nStatusOr&lt;i32&gt; read_next_response(pico_http::Response&amp; response);\nboost::asio::io_context&amp; get_io_context();\nStatusOr&lt;boost::asio::ip::tcp::endpoint&gt; local_endpoint() const noexcept;\nStatusOr&lt;boost::asio::ip::tcp::endpoint&gt; remote_endpoint() const noexcept;\nvoid idle_connection_timeout_task_main();\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nHttpClientHostContext&amp; context_;\ni32 idle_connection_timeout_ms_;\nTransport transport_;\nboost::asio::deadline_timer idle_timer_;\nQueue&lt;Pin&lt;HttpResponse&gt;&gt; response_queue_;\nStreamBuffer input_buffer_{16 * 1024};\nWatch&lt;usize&gt; response_count_{0};\nWatch&lt;u64&gt; activity_{0};\n};\nusing HttpClientConnection = BasicHttpClientConnection&lt;TcpTransport&gt;;\nusing HttpsClientConnection = BasicHttpClientConnection&lt;SslTransport&gt;;\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/","title":"batteries/http/http_client_connection_impl.hpp","text":""},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#define-batteries_http_http_client_connection_impl_hpp","title":"define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__client__connection__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_CLIENT_CONNECTION_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__host__context_8cpp/","title":"batteries/http/http_client_host_context.cpp","text":""},{"location":"_autogen/Files/http__client__host__context_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client_host_context.hpp&gt;\n//\n#include &lt;batteries/http/http_client_host_context_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__host__context_8hpp/","title":"batteries/http/http_client_host_context.hpp","text":""},{"location":"_autogen/Files/http__client__host__context_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_client_host_context_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client_host_context_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/","title":"batteries/http/http_client_host_context_decl.hpp","text":""},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#classes","title":"Classes","text":"Name class batt::HttpClientHostContext"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#define-batteries_http_http_client_host_context_decl_hpp","title":"define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__client__host__context__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP\n#define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/host_address.hpp&gt;\n#include &lt;batteries/async/pin.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;boost/asio/ssl/context.hpp&gt;\n#include &lt;tuple&gt;\nnamespace batt {\nclass HttpClient;\nclass HttpRequest;\nclass HttpResponse;\nclass HttpClientHostContext : public RefCounted&lt;HttpClientHostContext&gt;\n{\npublic:\nstatic constexpr usize kDefaultMaxConnections = 2;\nstatic constexpr usize kDefaultIdleConnectionTimeoutMs = 60 * 1000;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit HttpClientHostContext(HttpClient&amp; client, const HostAddress&amp; host_address) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::asio::io_context&amp; get_io_context() noexcept;\nstd::function&lt;void(Optional&lt;boost::asio::ssl::context&gt;&amp;, const HostAddress&amp;)&gt;  //\nget_ssl_init_fn() const noexcept;\nHttpClient&amp; client() const noexcept;\nvoid set_max_connections(usize n) noexcept\n{\nthis-&gt;max_connections_.store(n);\n}\nvoid set_connection_timeout_ms(i32 timeout_ms) noexcept\n{\nthis-&gt;connection_timeout_ms_.store(timeout_ms);\n}\ni32 get_connection_timeout_ms() const noexcept\n{\nreturn this-&gt;connection_timeout_ms_.load();\n}\nusize count_active_connections() const noexcept\n{\nreturn this-&gt;active_connections_.get_value();\n}\nStatus submit_request(Pin&lt;HttpRequest&gt;&amp;&amp; request, Pin&lt;HttpResponse&gt;&amp;&amp; response) noexcept;\nvoid halt();\nvoid join();\nbool can_grow() const;\nconst HostAddress&amp; host_address() const noexcept;\nStatusOr&lt;std::tuple&lt;Pin&lt;HttpRequest&gt;, Pin&lt;HttpResponse&gt;&gt;&gt; await_next_request() noexcept;\nprivate:\nvoid host_task_main();\nvoid create_connection();\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nHttpClient&amp; client_;\nHostAddress host_address_;\nQueue&lt;std::tuple&lt;Pin&lt;HttpRequest&gt;, Pin&lt;HttpResponse&gt;&gt;&gt; request_queue_;\nWatch&lt;usize&gt; active_connections_;\nstd::atomic&lt;usize&gt; max_connections_;\nstd::atomic&lt;i32&gt; connection_timeout_ms_;\nTask task_;\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/","title":"batteries/http/http_client_host_context_impl.hpp","text":""},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#define-batteries_http_http_client_host_context_impl_hpp","title":"define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__client__host__context__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_client.hpp&gt;\n#include &lt;batteries/http/http_client_connection_decl.hpp&gt;\n#include &lt;batteries/http/http_client_host_context_decl.hpp&gt;\n#include &lt;batteries/http/http_client_connection.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_client_impl.hpp&gt;\n#endif\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpClientHostContext::HttpClientHostContext(\nHttpClient&amp; client, const HostAddress&amp; host_addr) noexcept\n: client_{client}\n, host_address_{host_addr}\n, request_queue_{}\n, active_connections_{0}\n, max_connections_{this-&gt;client_.get_default_max_connections_per_host()}\n, connection_timeout_ms_{this-&gt;client_.get_default_connection_timeout_ms()}\n, task_{this-&gt;client_.get_io_context().get_executor(),\n[this] {\nthis-&gt;host_task_main();\n},\n\"HttpClientHostContext::host_task_main\"}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL boost::asio::io_context&amp; HttpClientHostContext::get_io_context() noexcept\n{\nreturn this-&gt;client_.get_io_context();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nstd::function&lt;void(Optional&lt;boost::asio::ssl::context&gt;&amp;, const HostAddress&amp;)&gt;\nHttpClientHostContext::get_ssl_init_fn() const noexcept\n{\nreturn this-&gt;client_.get_ssl_init_fn();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpClientHostContext::submit_request(Pin&lt;HttpRequest&gt;&amp;&amp; request,\nPin&lt;HttpResponse&gt;&amp;&amp; response) noexcept\n{\nBATT_VLOG(1) &lt;&lt; \"Request submitted...\";\nreturn this-&gt;request_queue_.push(std::make_tuple(std::move(request), std::move(response)));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientHostContext::halt()\n{\nthis-&gt;request_queue_.close();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientHostContext::join()\n{\nthis-&gt;task_.join();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool HttpClientHostContext::can_grow() const\n{\nreturn this-&gt;active_connections_.get_value() &lt; this-&gt;max_connections_.load();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const HostAddress&amp; HttpClientHostContext::host_address() const noexcept\n{\nreturn this-&gt;host_address_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;std::tuple&lt;Pin&lt;HttpRequest&gt;, Pin&lt;HttpResponse&gt;&gt;&gt;\nHttpClientHostContext::await_next_request() noexcept\n{\nBATT_VLOG(1) &lt;&lt; \"Awaiting next request (client host context)\";\nauto on_scope_exit = batt::finally([&amp;] {\nBATT_VLOG(1) &lt;&lt; \"Request submitted &amp; claimed by connection\";\n});\nreturn this-&gt;request_queue_.await_next();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientHostContext::host_task_main()\n{\nStatus status = [&amp;]() -&gt; Status {\nstd::atomic&lt;bool&gt; done{false};\nboost::asio::deadline_timer heartbeat_timer{this-&gt;get_io_context()};\n// Launch a task to repeatedly wait for a configured interval and then poke the request queue to wake\n// any tasks waiting for work to do.\n//\nTask heartbeat_task{\n//\nthis-&gt;get_io_context().get_executor(),\n[&amp;done, &amp;heartbeat_timer, this] {\nwhile (!done.load()) {\nthis-&gt;request_queue_.poke();\nErrorCode ec = Task::await&lt;ErrorCode&gt;([&amp;](auto&amp;&amp; handler) {\nconst auto timeout_ms = (this-&gt;connection_timeout_ms_.load() + 3) / 4;\nBATT_VLOG(1) &lt;&lt; \"Sleeping for \" &lt;&lt; timeout_ms &lt;&lt; \"ms\";\nErrorCode ec;\nheartbeat_timer.expires_from_now(boost::posix_time::milliseconds(timeout_ms), ec);\nif (ec) {\nBATT_FORWARD(handler)(ec);\n} else {\nheartbeat_timer.async_wait(BATT_FORWARD(handler));\n}\n});\n// Cancelling the timer also means we are done.\n//\nif (ec) {\nbreak;\n}\n}\n},\n\"HttpClientHostContext::heartbeat_task\"};\nauto on_scope_exit = batt::finally([&amp;] {\ndone.store(true);\n{\nboost::system::error_code ec;\nheartbeat_timer.cancel(ec);\n}\nthis-&gt;request_queue_.close();\nheartbeat_task.join();\n});\nfor (;;) {\nconst usize queue_depth = this-&gt;request_queue_.size();\nif (queue_depth &gt; 0 &amp;&amp; this-&gt;can_grow()) {\nthis-&gt;create_connection();\n}\nBATT_DEBUG_INFO(\"HttpClientHostContext::host_task_main waiting for queue depth to change;\"\n&lt;&lt; BATT_INSPECT(queue_depth));\nStatusOr&lt;i64&gt; new_queue_depth = this-&gt;request_queue_.await_size_is_truly([&amp;](i64 size) {\nreturn size != BATT_CHECKED_CAST(i64, queue_depth);\n});\nif (new_queue_depth.status() == StatusCode::kPoke) {\ncontinue;\n}\nBATT_REQUIRE_OK(new_queue_depth);\n}\n}();\nstatus.IgnoreError();  // TODO [tastolfi 2022-03-17] do something better!\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClientHostContext::create_connection()\n{\nif (this-&gt;host_address_.scheme == \"http\") {\nHttpClientConnection::spawn(*this, this-&gt;active_connections_);\n} else if (this-&gt;host_address_.scheme == \"https\") {\nHttpsClientConnection::spawn(*this, this-&gt;active_connections_);\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_CLIENT_HOST_CONTEXT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__client__impl_8hpp/","title":"batteries/http/http_client_impl.hpp","text":""},{"location":"_autogen/Files/http__client__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__client__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_CLIENT_IMPL_HPP"},{"location":"_autogen/Files/http__client__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__client__impl_8hpp/#define-batteries_http_client_impl_hpp","title":"define BATTERIES_HTTP_CLIENT_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_CLIENT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__client__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_CLIENT_IMPL_HPP\n#define BATTERIES_HTTP_CLIENT_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_client_host_context.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpClient::HttpClient(boost::asio::io_context&amp; io) noexcept\n: io_{io}\n, default_max_connections_per_host_{HttpClientHostContext::kDefaultMaxConnections}\n, default_connection_timeout_ms_{HttpClientHostContext::kDefaultIdleConnectionTimeoutMs}\n, host_contexts_{}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpClient::submit_request(const HostAddress&amp; host_address,\nPin&lt;HttpRequest&gt;&amp;&amp; request, Pin&lt;HttpResponse&gt;&amp;&amp; response)\n{\nBATT_CHECK_NOT_NULLPTR(request);\nBATT_CHECK_NOT_NULLPTR(response);\nSharedPtr&lt;HttpClientHostContext&gt; host_context = this-&gt;find_host_context(host_address);\nreturn host_context-&gt;submit_request(std::move(request), std::move(response));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize HttpClient::get_default_max_connections_per_host() const noexcept\n{\nreturn this-&gt;default_max_connections_per_host_.load();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClient::set_default_max_connections_per_host(usize max_connections) noexcept\n{\nthis-&gt;default_max_connections_per_host_.store(max_connections);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClient::set_max_connections_per_host(const HostAddress&amp; host_address,\nusize max_connections) noexcept\n{\nSharedPtr&lt;HttpClientHostContext&gt; host_context = this-&gt;find_host_context(host_address);\nhost_context-&gt;set_max_connections(max_connections);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL i32 HttpClient::get_default_connection_timeout_ms() const noexcept\n{\nreturn this-&gt;default_connection_timeout_ms_.load();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpClient::set_default_connection_timeout_ms(i32 timeout_ms) noexcept\n{\nthis-&gt;default_connection_timeout_ms_.store(timeout_ms);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize HttpClient::count_active_connections_for_host(const HostAddress&amp; host_address) noexcept\n{\nSharedPtr&lt;HttpClientHostContext&gt; host_context =\nthis-&gt;find_host_context(host_address, CreateIfNotFound{false});\nif (host_context == nullptr) {\nreturn 0;\n}\nreturn host_context-&gt;count_active_connections();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize HttpClient::count_active_connections() const noexcept\n{\nusize total = 0;\nBATT_SCOPED_CONST_LOCK(locked_contexts, this-&gt;host_contexts_);\nfor (auto&amp; [host_addr, p_context] : *locked_contexts) {\nBATT_CHECK_NOT_NULLPTR(p_context) &lt;&lt; BATT_INSPECT(host_addr);\ntotal += p_context-&gt;count_active_connections();\n}\nreturn total;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SharedPtr&lt;HttpClientHostContext&gt; HttpClient::find_host_context(\nconst HostAddress&amp; host_address, CreateIfNotFound create)\n{\nBATT_SCOPED_LOCK(locked_contexts, this-&gt;host_contexts_);\nauto iter = locked_contexts-&gt;find(host_address);\nif (iter == locked_contexts-&gt;end()) {\nif (!create) {\nreturn nullptr;\n}\niter = locked_contexts\n-&gt;emplace(host_address, make_shared&lt;HttpClientHostContext&gt;(/*client=*/*this, host_address))\n.first;\n}\nreturn iter-&gt;second;\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_CLIENT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__data_8hpp/","title":"batteries/http/http_data.hpp","text":""},{"location":"_autogen/Files/http__data_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__data_8hpp/#classes","title":"Classes","text":"Name struct batt::HttpData"},{"location":"_autogen/Files/http__data_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_DATA_HPP"},{"location":"_autogen/Files/http__data_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__data_8hpp/#define-batteries_http_data_hpp","title":"define BATTERIES_HTTP_DATA_HPP","text":"<pre><code>#define BATTERIES_HTTP_DATA_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__data_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_DATA_HPP\n#define BATTERIES_HTTP_DATA_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\nnamespace batt {\nstruct HttpData {\nBufferSource source;\nbool empty() const\n{\nreturn !this-&gt;source;\n}\nusize size() const\n{\nif (!this-&gt;source) {\nreturn 0;\n}\nreturn this-&gt;source.size();\n}\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; fetch_at_least(i64 min_count)\n{\nif (!this-&gt;source) {\nreturn {StatusCode::kEndOfStream};\n}\nreturn this-&gt;source.fetch_at_least(min_count);\n}\nvoid consume(i64 count)\n{\nif (this-&gt;source) {\nthis-&gt;source.consume(count);\n}\n}\nvoid close_for_read()\n{\nif (this-&gt;source) {\nthis-&gt;source.close_for_read();\n}\n}\n};\nBATT_STRONG_TYPEDEF(bool, IncludeHttpTrailer);\n}  // namespace batt\n#endif  // BATTERIES_HTTP_DATA_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__header_8hpp/","title":"batteries/http/http_header.hpp","text":""},{"location":"_autogen/Files/http__header_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__header_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HEADER_HPP"},{"location":"_autogen/Files/http__header_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__header_8hpp/#define-batteries_http_header_hpp","title":"define BATTERIES_HTTP_HEADER_HPP","text":"<pre><code>#define BATTERIES_HTTP_HEADER_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__header_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HEADER_HPP\n#define BATTERIES_HTTP_HEADER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/pico_http/parser.hpp&gt;\nnamespace batt {\nusing HttpHeader = ::pico_http::MessageHeader;\ninline Optional&lt;std::string_view&gt; find_header(const SmallVecBase&lt;HttpHeader&gt;&amp; headers,\nconst std::string_view&amp; name)\n{\nconst auto iter = std::find_if(headers.begin(), headers.end(), [&amp;](const HttpHeader&amp; hdr) {\nreturn hdr.name == name;\n});\nif (iter == headers.end()) {\nreturn None;\n}\nreturn iter-&gt;value;\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HEADER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__message__base_8hpp/","title":"batteries/http/http_message_base.hpp","text":""},{"location":"_autogen/Files/http__message__base_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__message__base_8hpp/#classes","title":"Classes","text":"Name class batt::HttpMessageBase The common base type for HttpRequest and HttpResponse."},{"location":"_autogen/Files/http__message__base_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP"},{"location":"_autogen/Files/http__message__base_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__message__base_8hpp/#define-batteries_http_http_message_base_hpp","title":"define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__message__base_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP\n#define BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_header.hpp&gt;\n#include &lt;batteries/async/channel.hpp&gt;\n#include &lt;batteries/async/pin.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;string_view&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T&gt;\nclass HttpMessageBase : public Pinnable\n{\npublic:\nusing Message = T;\nenum State {\nkCreated = 0,\nkInitialized = 1,\nkConsumed = 2,\n};\nHttpMessageBase(const HttpMessageBase&amp;) = delete;\nHttpMessageBase&amp; operator=(const HttpMessageBase&amp;) = delete;\nHttpMessageBase()\n{\n}\n~HttpMessageBase() noexcept\n{\nthis-&gt;release_message();\nthis-&gt;release_data();\n}\nWatch&lt;i32&gt;&amp; state() noexcept\n{\nreturn this-&gt;state_;\n}\nvoid update_status(Status status) noexcept\n{\nthis-&gt;status_.Update(status);\n}\nStatus get_status() const noexcept\n{\nreturn this-&gt;status_;\n}\nvoid close(Status status = StatusCode::kClosed) noexcept\n{\nthis-&gt;update_status(status);\nthis-&gt;state().close();\nthis-&gt;message_.close_for_write();\nthis-&gt;data_.close_for_write();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid async_set_message(Message&amp; message)\n{\nthis-&gt;message_.async_write(message, [](Status status) {\nstatus.IgnoreError();\n});\n}\nStatus await_set_message(Message&amp; message)\n{\nreturn this-&gt;message_.write(message);\n}\nStatusOr&lt;Message&amp;&gt; await_message()\n{\nreturn this-&gt;message_.read();\n}\nMessage&amp; await_message_or_panic()\n{\nStatusOr&lt;Message&amp;&gt; msg = this-&gt;await_message();\nBATT_CHECK_OK(msg);\nreturn *msg;\n}\nvoid release_message()\n{\nif (this-&gt;message_.is_active()) {\nthis-&gt;message_.consume();\n}\n}\nvoid async_set_data(HttpData&amp; data)\n{\nthis-&gt;data_.async_write(data, [](Status status) {\nstatus.IgnoreError();\n});\n}\nStatus await_set_data(HttpData&amp; data)\n{\nreturn this-&gt;data_.write(data);\n}\ntemplate &lt;typename WriterFn /* = Status (AsyncWriteStream&amp; dst) */&gt;\nStatus invoke_stream_writer(usize buffer_size, WriterFn&amp;&amp; writer_fn)\n{\nBATT_CHECK_NOT_NULLPTR(std::addressof(Task::current()))\n&lt;&lt; \"batt::HttpMessageBase::invoke_stream_writer must be called from inside a batt::Task\";\nStreamBuffer buffer{buffer_size};\nStatus status;\n{\nStatus writer_status;\nTask writer_task{Task::current().get_executor(), [&amp;] {\nwriter_status = writer_fn(buffer);\nbuffer.close_for_write();\n}};\nHttpData http_data{\n.source = batt::BufferSource{std::ref(buffer)},\n};\nstatus = this-&gt;await_set_data(http_data);\nwriter_task.join();\nstatus.Update(writer_status);\n}\nreturn status;\n}\ntemplate &lt;typename WriterFn /* = Status (AsyncWriteStream&amp; dst) */&gt;\nStatus invoke_stream_writer(WriterFn&amp;&amp; writer_fn)\n{\nreturn this-&gt;invoke_stream_writer(/*buffer_size=*/4 * kKiB, BATT_FORWARD(writer_fn));\n}\nStatusOr&lt;HttpData&amp;&gt; await_data()\n{\nthis-&gt;release_message();\nreturn this-&gt;data_.read();\n}\nvoid release_data()\n{\nif (this-&gt;data_.is_active()) {\nthis-&gt;data_.consume();\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ni32 major_version()\n{\nreturn this-&gt;await_message_or_panic().major_version;\n}\ni32 minor_version()\n{\nreturn this-&gt;await_message_or_panic().minor_version;\n}\nconst SmallVecBase&lt;HttpHeader&gt;&amp; headers()\n{\nreturn this-&gt;await_message_or_panic().headers;\n}\nOptional&lt;std::string_view&gt; find_header(const std::string_view&amp; name)\n{\nreturn ::batt::find_header(this-&gt;headers(), name);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename AsyncWriteStream&gt;\nStatus serialize(AsyncWriteStream&amp; stream)\n{\nStatusOr&lt;Message&amp;&gt; message = this-&gt;await_message();\nBATT_REQUIRE_OK(message);\nconst std::string message_str = to_string(*message);\nthis-&gt;release_message();\nStatusOr&lt;HttpData&amp;&gt; data = this-&gt;await_data();\nBATT_REQUIRE_OK(data);\n//----- --- -- -  -  -   -\nauto on_scope_exit = finally([&amp;] {\nthis-&gt;release_data();\n});\n//----- --- -- -  -  -\nStatusOr&lt;usize&gt; bytes_written =               //\n*data                                     //\n| seq::prepend(make_buffer(message_str))  //\n| seq::write_to(stream);\nBATT_REQUIRE_OK(bytes_written);\nreturn OkStatus();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprotected:\nStatus status_{OkStatus()};\nWatch&lt;i32&gt; state_{kCreated};\nChannel&lt;Message&gt; message_;\nChannel&lt;HttpData&gt; data_;\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_MESSAGE_BASE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__message__info_8cpp/","title":"batteries/http/http_message_info.cpp","text":""},{"location":"_autogen/Files/http__message__info_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_message_info.hpp&gt;\n//\n#include &lt;batteries/http/http_message_info_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__message__info_8hpp/","title":"batteries/http/http_message_info.hpp","text":""},{"location":"_autogen/Files/http__message__info_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_message_info_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_message_info_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__message__info__decl_8hpp/","title":"batteries/http/http_message_info_decl.hpp","text":""},{"location":"_autogen/Files/http__message__info__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__message__info__decl_8hpp/#classes","title":"Classes","text":"Name struct batt::HttpMessageInfo A summary of information about a response message that is necessary for the connection to correctly handle it."},{"location":"_autogen/Files/http__message__info__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_MESSAGE_INFO_DECL_HPP"},{"location":"_autogen/Files/http__message__info__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__message__info__decl_8hpp/#define-batteries_http_http_message_info_decl_hpp","title":"define BATTERIES_HTTP_HTTP_MESSAGE_INFO_DECL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_MESSAGE_INFO_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__message__info__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_MESSAGE_INFO_DECL_HPP\n#define BATTERIES_HTTP_HTTP_MESSAGE_INFO_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/operators.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/pico_http/parser.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\nnamespace batt {\nstruct HttpMessageInfo {\nexplicit HttpMessageInfo(const pico_http::Response&amp; response) noexcept;\nexplicit HttpMessageInfo(const pico_http::Request&amp; request) noexcept;\nHttpMessageInfo(int major_version, int minor_version,\nconst batt::SmallVecBase&lt;pico_http::MessageHeader&gt;&amp; headers) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nbool is_valid() const\n{\nreturn this-&gt;content_length || this-&gt;chunked_encoding || !this-&gt;keep_alive;\n}\nHttpData get_data(StreamBuffer&amp; input_buffer);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nOptional&lt;usize&gt; content_length;\nbool keep_alive;\nbool chunked_encoding;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nBATT_OBJECT_PRINT_IMPL((inline), HttpMessageInfo, (content_length, keep_alive, chunked_encoding));\n}  //namespace batt\n#endif  // BATTERIES_HTTP_HTTP_MESSAGE_INFO_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__message__info__impl_8hpp/","title":"batteries/http/http_message_info_impl.hpp","text":""},{"location":"_autogen/Files/http__message__info__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__message__info__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_MESSAGE_INFO_IMPL_HPP"},{"location":"_autogen/Files/http__message__info__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__message__info__impl_8hpp/#define-batteries_http_http_message_info_impl_hpp","title":"define BATTERIES_HTTP_HTTP_MESSAGE_INFO_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_MESSAGE_INFO_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__message__info__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_MESSAGE_INFO_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_MESSAGE_INFO_IMPL_HPP\n#include &lt;batteries/http/http_message_info_decl.hpp&gt;\n#include &lt;batteries/http/http_chunk_decoder.hpp&gt;\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_header.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpMessageInfo::HttpMessageInfo(const pico_http::Response&amp; response) noexcept\n: HttpMessageInfo{response.major_version, response.minor_version, response.headers}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpMessageInfo::HttpMessageInfo(const pico_http::Request&amp; request) noexcept\n: HttpMessageInfo{request.major_version, request.minor_version, request.headers}\n{\nif (request.method != \"PUT\" &amp;&amp; request.method != \"POST\") {\nthis-&gt;content_length = 0;\nthis-&gt;chunked_encoding = false;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL\nHttpMessageInfo::HttpMessageInfo(int major_version, int minor_version,\nconst batt::SmallVecBase&lt;pico_http::MessageHeader&gt;&amp; headers) noexcept\n: content_length{find_header(headers, \"Content-Length\").flat_map([](std::string_view s) {\nreturn Optional{from_string&lt;usize&gt;(std::string(s))};\n})}\n, keep_alive{find_header(headers, \"Connection\")\n.map([](std::string_view s) {\nreturn s == \"keep-alive\";\n})\n.value_or(major_version == 1 &amp;&amp; minor_version &gt;= 1)}\n, chunked_encoding{find_header(headers, \"Transfer-Encoding\")\n.map([](std::string_view s) {\nreturn s == \"chunked\";\n})\n.value_or(false)}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpData HttpMessageInfo::get_data(StreamBuffer&amp; input_buffer)\n{\nreturn HttpData{[&amp;]() -&gt; BufferSource {\nconst auto consume_trailer = IncludeHttpTrailer{true};\nif (this-&gt;content_length == None) {\nif (this-&gt;chunked_encoding) {\nreturn HttpChunkDecoder&lt;StreamBuffer&amp;&gt;{input_buffer, consume_trailer};\n} else {\nif (this-&gt;keep_alive) {\nreturn BufferSource{};\n} else {\nreturn std::ref(input_buffer);\n}\n}\n} else {\nif (this-&gt;chunked_encoding) {\nreturn HttpChunkDecoder&lt;StreamBuffer&amp;&gt;{input_buffer, consume_trailer}  //\n| seq::take_n(*this-&gt;content_length);\n} else {\nreturn input_buffer | seq::take_n(*this-&gt;content_length);\n}\n}\n}()};\n}\n}  //namespace batt\n#endif  // BATTERIES_HTTP_HTTP_MESSAGE_INFO_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__request_8hpp/","title":"batteries/http/http_request.hpp","text":""},{"location":"_autogen/Files/http__request_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__request_8hpp/#classes","title":"Classes","text":"Name class batt::HttpRequest"},{"location":"_autogen/Files/http__request_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_REQUEST_HPP"},{"location":"_autogen/Files/http__request_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__request_8hpp/#define-batteries_http_request_hpp","title":"define BATTERIES_HTTP_REQUEST_HPP","text":"<pre><code>#define BATTERIES_HTTP_REQUEST_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__request_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_REQUEST_HPP\n#define BATTERIES_HTTP_REQUEST_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_header.hpp&gt;\n#include &lt;batteries/http/http_message_base.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;string_view&gt;\nnamespace batt {\nclass HttpRequest : public HttpMessageBase&lt;pico_http::Request&gt;\n{\npublic:\nusing HttpMessageBase&lt;pico_http::Request&gt;::HttpMessageBase;\nusing HttpMessageBase&lt;pico_http::Request&gt;::major_version;\nusing HttpMessageBase&lt;pico_http::Request&gt;::minor_version;\nusing HttpMessageBase&lt;pico_http::Request&gt;::headers;\nusing HttpMessageBase&lt;pico_http::Request&gt;::find_header;\nconst std::string_view&amp; method()\n{\nreturn this-&gt;await_message_or_panic().method;\n}\nconst std::string_view&amp; path()\n{\nreturn this-&gt;await_message_or_panic().path;\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_REQUEST_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__response_8hpp/","title":"batteries/http/http_response.hpp","text":""},{"location":"_autogen/Files/http__response_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__response_8hpp/#classes","title":"Classes","text":"Name class batt::HttpResponse"},{"location":"_autogen/Files/http__response_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_RESPONSE_HPP"},{"location":"_autogen/Files/http__response_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__response_8hpp/#define-batteries_http_response_hpp","title":"define BATTERIES_HTTP_RESPONSE_HPP","text":"<pre><code>#define BATTERIES_HTTP_RESPONSE_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__response_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_RESPONSE_HPP\n#define BATTERIES_HTTP_RESPONSE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_message_base.hpp&gt;\n#include &lt;batteries/pico_http/parser.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\nclass HttpResponse : public HttpMessageBase&lt;pico_http::Response&gt;\n{\npublic:\nusing HttpMessageBase&lt;pico_http::Response&gt;::HttpMessageBase;\nusing HttpMessageBase&lt;pico_http::Response&gt;::major_version;\nusing HttpMessageBase&lt;pico_http::Response&gt;::minor_version;\nusing HttpMessageBase&lt;pico_http::Response&gt;::headers;\nusing HttpMessageBase&lt;pico_http::Response&gt;::find_header;\ni32 code()\n{\nreturn this-&gt;await_message_or_panic().status;\n}\nstd::string_view message_text()\n{\nreturn this-&gt;await_message_or_panic().message;\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_RESPONSE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server_8cpp/","title":"batteries/http/http_server.cpp","text":""},{"location":"_autogen/Files/http__server_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_server.hpp&gt;\n//\n#include &lt;batteries/http/http_server_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server_8hpp/","title":"batteries/http/http_server.hpp","text":""},{"location":"_autogen/Files/http__server_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_server_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_server_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__connection_8cpp/","title":"batteries/http/http_server_connection.cpp","text":""},{"location":"_autogen/Files/http__server__connection_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_server_connection.hpp&gt;\n//\n#include &lt;batteries/http/http_server_connection_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__connection_8hpp/","title":"batteries/http/http_server_connection.hpp","text":""},{"location":"_autogen/Files/http__server__connection_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_server_connection_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_server_connection_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__connection__decl_8hpp/","title":"batteries/http/http_server_connection_decl.hpp","text":""},{"location":"_autogen/Files/http__server__connection__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__server__connection__decl_8hpp/#classes","title":"Classes","text":"Name class batt::HttpServerConnection"},{"location":"_autogen/Files/http__server__connection__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_CONNECTION_DECL_HPP"},{"location":"_autogen/Files/http__server__connection__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__server__connection__decl_8hpp/#define-batteries_http_http_server_connection_decl_hpp","title":"define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_DECL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__server__connection__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_CONNECTION_DECL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_data.hpp&gt;\n#include &lt;batteries/http/http_request.hpp&gt;\n#include &lt;batteries/http/http_response.hpp&gt;\n#include &lt;batteries/http/http_server_decl.hpp&gt;\n#include &lt;batteries/async/buffer_source.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/asio/deadline_timer.hpp&gt;\n#include &lt;batteries/asio/ip_tcp.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;tuple&gt;\nnamespace batt {\nclass HttpServerConnection\n{\npublic:\nstatic void spawn(boost::asio::ip::tcp::socket&amp;&amp; socket,\nHttpRequestDispatcherFactoryFn&amp;&amp; request_dispatcher_factory,\nconst HttpServerSettings&amp; settings) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nexplicit HttpServerConnection(boost::asio::ip::tcp::socket&amp;&amp; socket,\nHttpRequestDispatcherFactoryFn&amp;&amp; request_dispatcher_factory,\nconst HttpServerSettings&amp; settings) noexcept;\n~HttpServerConnection() noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n/* Data/Control flow diagram:\n      \u2554\u2550\u2550\u2550\u2550\u2557\n      \u2551Task\u2551\n      \u255a\u2550\u2550\u2550\u2550\u255d\n            \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u250c\u2500\u2500\u25b6\u2551 fill_input_buffer()  \u2551\u2500\u2500\u25b6\u2502 input_buffer_ \u2502\n        \u2502   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502                                      \u2502\n        \u2502                                      \u25bc\n        \u2502                          \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                       \u250c\u2500\u2500\u2551   read_requests()    \u2551\u25c0\u2500\u2500\u2500\u2500\u2502 request_queue_ \u2502\u25c0\u2500\u2510\n        \u2502                       \u2502  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u25bc              \u2502                                    \u2502\n  \u2502  socket_  \u2502        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502          \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557  \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2502response_queue_ \u2502      \u2502          \u2551  process_requests()  \u2560\u2557 \u2502\n        \u25b2              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502          \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\u2560\u2557\u2502\n        \u2502                       \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256c\u2500\u25b7\u2502  HttpRequest   \u2502\u2500\u2500\u256c\u256c\u256c\u2524\n        \u2502                       \u25bc                         \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\u2551\u2551\u2502\n        \u2502           \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557              \u2551  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2551\u2551\u2551\u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2551  write_responses()   \u2551\u25c1\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256c\u2500\u2500\u2502  HttpResponse  \u2502\u2500\u2500\u256c\u256c\u256c\u2518\n                    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d              \u2551  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2551\u2551\u2551\n                                                          \u255a\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u2551\u2551\n                                                           \u255a\u2566\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u2551\n                                                            \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n    */\nStatusOr&lt;boost::asio::ip::tcp::endpoint&gt; local_endpoint() const noexcept;\nStatusOr&lt;boost::asio::ip::tcp::endpoint&gt; remote_endpoint() const noexcept;\nvoid start();\nvoid halt();\nvoid join();\nStatus fill_input_buffer();\nStatus read_requests();\nvoid try_spawn_request_processor() noexcept;\nStatus process_requests(Grant token);\nStatus send_responses();\nStatus open_connection();\nStatusOr&lt;i32&gt; read_next_request(pico_http::Request&amp; request);\nvoid idle_connection_timeout_task_main();\nvoid halt_idle_timeout_task() noexcept;\nvoid idle_shutdown() noexcept;\nvoid shutdown_request_queue();\nvoid shutdown_response_queue();\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::asio::ip::tcp::socket socket_;\nHttpRequestDispatcherFactoryFn request_dispatcher_factory_;\nHttpServerSettings settings_;\nGrant::Issuer request_processor_tokens_;\nboost::asio::deadline_timer idle_timer_;\nStreamBuffer input_buffer_;\nQueue&lt;std::tuple&lt;Pin&lt;HttpRequest&gt;, Pin&lt;HttpResponse&gt;&gt;&gt; request_queue_;\nQueue&lt;Pin&lt;HttpResponse&gt;&gt; response_queue_;\nWatch&lt;bool&gt; halt_requested_{false};\nWatch&lt;usize&gt; request_count_{0};\nWatch&lt;u64&gt; activity_{0};\nOptional&lt;Task&gt; fill_input_buffer_task_;\nOptional&lt;Task&gt; read_requests_task_;\nOptional&lt;Task&gt; send_responses_task_;\nOptional&lt;Task&gt; idle_connection_timeout_task_;\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_SERVER_CONNECTION_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__connection__impl_8hpp/","title":"batteries/http/http_server_connection_impl.hpp","text":""},{"location":"_autogen/Files/http__server__connection__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__server__connection__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP"},{"location":"_autogen/Files/http__server__connection__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__server__connection__impl_8hpp/#define-batteries_http_http_server_connection_impl_hpp","title":"define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__server__connection__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP\n#include &lt;batteries/http/http_message_info.hpp&gt;\n#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ void HttpServerConnection::spawn(\nboost::asio::ip::tcp::socket&amp;&amp; socket, HttpRequestDispatcherFactoryFn&amp;&amp; request_dispatcher_factory,\nconst HttpServerSettings&amp; settings) noexcept\n{\nTask::spawn(Task::current().get_executor(), [socket = std::move(socket),\nrequest_dispatcher_factory =\nstd::move(request_dispatcher_factory),\nsettings]() mutable {\nHttpServerConnection connection{std::move(socket), std::move(request_dispatcher_factory), settings};\nconnection.start();\nconnection.join();\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpServerConnection::HttpServerConnection(\nboost::asio::ip::tcp::socket&amp;&amp; socket, HttpRequestDispatcherFactoryFn&amp;&amp; request_dispatcher_factory,\nconst HttpServerSettings&amp; settings) noexcept\n: socket_{std::move(socket)}\n, request_dispatcher_factory_{std::move(request_dispatcher_factory)}\n, settings_{settings}\n, request_processor_tokens_{this-&gt;settings_.max_requests_per_connection}\n, idle_timer_{this-&gt;socket_.get_executor()}\n, input_buffer_{this-&gt;settings_.connection_buffer_size}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpServerConnection::~HttpServerConnection() noexcept\n{\nthis-&gt;halt();\nthis-&gt;join();\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::~HttpServerConnection() Done\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;boost::asio::ip::tcp::endpoint&gt; HttpServerConnection::local_endpoint()\nconst noexcept\n{\nboost::system::error_code ec;\nauto ep = this-&gt;socket_.local_endpoint(ec);\nBATT_REQUIRE_OK(ec);\nreturn ep;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;boost::asio::ip::tcp::endpoint&gt; HttpServerConnection::remote_endpoint()\nconst noexcept\n{\nboost::system::error_code ec;\nauto ep = this-&gt;socket_.remote_endpoint(ec);\nBATT_REQUIRE_OK(ec);\nreturn ep;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::start()\n{\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::run() entered\";\nauto executor = Task::current().get_executor();\nBATT_CHECK(!this-&gt;fill_input_buffer_task_);\nthis-&gt;fill_input_buffer_task_.emplace(executor, [this] {\nthis-&gt;fill_input_buffer().IgnoreError();\n});\nBATT_CHECK(!this-&gt;read_requests_task_);\nthis-&gt;read_requests_task_.emplace(executor, [this] {\nthis-&gt;read_requests().IgnoreError();\n});\nBATT_CHECK(!this-&gt;send_responses_task_);\nthis-&gt;send_responses_task_.emplace(executor, [this] {\nthis-&gt;send_responses().IgnoreError();\n});\nBATT_CHECK(!this-&gt;idle_connection_timeout_task_);\nthis-&gt;idle_connection_timeout_task_.emplace(executor, [this] {\nthis-&gt;idle_connection_timeout_task_main();\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::halt()\n{\nthis-&gt;idle_shutdown();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::join()\n{\nconst auto join_subtask = [](Optional&lt;Task&gt;&amp; subtask) {\nif (subtask) {\nsubtask-&gt;join();\nsubtask = None;\n}\n};\njoin_subtask(this-&gt;fill_input_buffer_task_);\njoin_subtask(this-&gt;read_requests_task_);\njoin_subtask(this-&gt;send_responses_task_);\njoin_subtask(this-&gt;idle_connection_timeout_task_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::fill_input_buffer()\n{\nauto on_exit = finally([this] {\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::fill_input_buffer() exiting\"\n&lt;&lt; BATT_INSPECT(this-&gt;local_endpoint()) &lt;&lt; BATT_INSPECT(this-&gt;remote_endpoint());\nthis-&gt;input_buffer_.close_for_write();\n});\nfor (;;) {\nBATT_VLOG(1) &lt;&lt; \"Reading from socket\";\n// Allocate some space in the input buffer for incoming data.\n//\nStatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt;&gt; buffer = this-&gt;input_buffer_.prepare_at_least(1);\nBATT_REQUIRE_OK(buffer);\n// Read data from the socket into the buffer.\n//\nauto n_read = Task::await&lt;IOResult&lt;usize&gt;&gt;([&amp;](auto&amp;&amp; handler) {\nthis-&gt;socket_.async_read_some(*buffer, BATT_FORWARD(handler));\n});\nBATT_REQUIRE_OK(n_read) &lt;&lt; \"(HttpServerConnection::fill_input_buffer)\";\nBATT_VLOG(1) &lt;&lt; \"Read \" &lt;&lt; *n_read &lt;&lt; \" bytes; committing to buffer\";\nthis-&gt;activity_.fetch_add(1);\n// Assuming we were successful, commit the read data so it can be consumed by the parser task.\n//\nthis-&gt;input_buffer_.commit(*n_read);\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::read_requests()\n{\nauto on_exit = finally([this] {\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::read_requests() exiting\"\n&lt;&lt; BATT_INSPECT(this-&gt;local_endpoint()) &lt;&lt; BATT_INSPECT(this-&gt;remote_endpoint());\n// Unblock all other tasks by closing anything they might wait on.\n//\nthis-&gt;activity_.close();\nthis-&gt;halt_idle_timeout_task();\nthis-&gt;input_buffer_.close_for_read();\nthis-&gt;shutdown_request_queue();\nthis-&gt;response_queue_.close();\nboost::system::error_code ec;\nthis-&gt;socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_receive, ec);\n});\nfor (;;) {\nBATT_VLOG(1) &lt;&lt; \"Awaiting request\";\n//----- --- -- -  -  -   -\n// If there are no request processor subtasks asking for work to do, then try to start one.\n//\nthis-&gt;try_spawn_request_processor();\n//----- --- -- -  -  -   -\n// Wait for an available request processor to ask for work by queuing a request/response object pair.\n//\nusing RequestResponseTuple = std::tuple&lt;Pin&lt;HttpRequest&gt;, Pin&lt;HttpResponse&gt;&gt;;\nBATT_ASSIGN_OK_RESULT(RequestResponseTuple request_response, this-&gt;request_queue_.await_next());\nPin&lt;HttpRequest&gt; request;\nPin&lt;HttpResponse&gt; response;\nstd::tie(request, response) = std::move(request_response);\nBATT_CHECK_NOT_NULLPTR(request);\nBATT_CHECK_NOT_NULLPTR(response);\n// By default, we will mark the request and response as 'closed' so that the processor task who owns\n// them isn't indefinitely blocked.  These FinalAct objects will be cancelled once an alternate code\n// path for updating the state has been entered.\n//\nauto close_request = batt::finally([&amp;request] {\nrequest-&gt;close();\n});\nauto close_response = batt::finally([&amp;response] {\nresponse-&gt;close();\n});\n//----- --- -- -  -  -   -\n// We're only interested in the request; send the pinned response ref to the response writer task\n// (send_responses).  NOTE: The fact that there is only one task per connection inside read_requests\n// guarantees that the order of requests and responses will always match!\n//\nBATT_REQUIRE_OK(this-&gt;response_queue_.push(std::move(response)));\nclose_response.cancel();\nBATT_VLOG(1) &lt;&lt; \"Got request/response pair\";\n//----- --- -- -  -  -   -\n// Read a single HTTP request message from the input buffer.\n//\npico_http::Request request_message;\nStatusOr&lt;i32&gt; message_length = this-&gt;read_next_request(request_message);\nBATT_REQUIRE_OK(message_length)\n&lt;&lt; LogLevel::kError &lt;&lt; \"Failed to read/parse request (HttpServerConnection::read_requests)\";\nBATT_VLOG(1) &lt;&lt; \"Parsed response header\";\n// Extract connection-level information about the request.\n//\nHttpMessageInfo request_info(request_message);\nif (!request_info.is_valid()) {\nreturn StatusCode::kInvalidArgument;\n}\n//----- --- -- -  -  -   -\n// Request state is now kInitialized.\n//\nclose_request.cancel();\nrequest-&gt;state().set_value(HttpRequest::kInitialized);\n//----- --- -- -  -  -   -\n// Pass control over to the request processor task who owns `request` and wait for it to signal it is\n// done reading the message headers/url/etc.\n//\nStatus message_consumed = request-&gt;await_set_message(request_message);\nBATT_REQUIRE_OK(message_consumed) &lt;&lt; LogLevel::kError;\nBATT_VLOG(1) &lt;&lt; \"Done reading request header\";\nthis-&gt;activity_.fetch_add(1);\n// The consume is done with the message; consume it and move on to the body.\n//\nthis-&gt;input_buffer_.consume(*message_length);\n//----- --- -- -  -  -   -\n// Create an HttpData object to read the body of the request.  Hand control over to the request\n// processor task and wait for it to signal it is done.\n//\nHttpData request_data{request_info.get_data(this-&gt;input_buffer_)};\nrequest-&gt;await_set_data(request_data).IgnoreError();\n//\nBATT_VLOG(1) &lt;&lt; \"Done reading request body\";\n//\n// We must not touch `request` after `await_set_data` returns!\n// Whether or not we keep the connection alive, acknowledge the response when we exit the loop.\n//\nauto on_scope_exit = batt::finally([this] {\nthis-&gt;request_count_.fetch_add(1);\n});\nthis-&gt;activity_.fetch_add(1);\n//----- --- -- -  -  -   -\n// If we are going to keep the connection alive, we must consume any extra data that wasn't read\n// by the request processor.  Otherwise we just close the socket.\n//\nif (request_info.keep_alive) {\nBATT_VLOG(1) &lt;&lt; \"Request is Keep-Alive\";\nStatus data_consumed = std::move(request_data) | seq::consume();\nBATT_REQUIRE_OK(data_consumed) &lt;&lt; LogLevel::kError;\n} else {\nBATT_VLOG(1) &lt;&lt; \"Response is Close; closing socket\";\nbreak;\n}\n}\nreturn OkStatus();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::try_spawn_request_processor() noexcept\n{\nif (this-&gt;request_queue_.size() == 0) {\n// Each request processor task must hold a token; this limits the total number of tasks and the\n// pipelined request depth.  Try to acquire 1 token; if this succeeds, then spawn a request\n// processor task.\n//\nStatusOr&lt;Grant&gt; maybe_token = this-&gt;request_processor_tokens_.issue_grant(1, WaitForResource::kFalse);\nif (maybe_token.ok()) {\nTask::spawn(Task::current().get_executor(), [this, token = std::move(*maybe_token)]() mutable {\nthis-&gt;process_requests(std::move(token)).IgnoreError();\n});\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;i32&gt; HttpServerConnection::read_next_request(pico_http::Request&amp; request)\n{\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::read_next_request\";\ni32 result = 0;\nusize min_to_fetch = 1;\nfor (;;) {\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; fetched = this-&gt;input_buffer_.fetch_at_least(min_to_fetch);\nBATT_REQUIRE_OK(fetched) &lt;&lt; \"(HttpServerConnection::read_next_request)\";\nauto&amp; buffers = *fetched;\nconst usize n_bytes_fetched = boost::asio::buffer_size(buffers);\nBATT_CHECK(!buffers.empty());\nresult = request.parse(buffers.front());\nif (result == pico_http::kParseIncomplete) {\nmin_to_fetch = std::max(min_to_fetch + 1, n_bytes_fetched);\ncontinue;\n}\nif (result == pico_http::kParseFailed) {\nauto chunk = buffers.front();\nBATT_VLOG(1) &lt;&lt; \"Failed to parse http message: \"\n&lt;&lt; c_str_literal(std::string_view{(const char*)chunk.data(), chunk.size()});\nreturn {StatusCode::kInternal};\n}\nBATT_CHECK_GT(result, 0);\nreturn result;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::idle_connection_timeout_task_main()\n{\nfor (;;) {\nconst u64 activity_before = this-&gt;activity_.get_value();\n// IMPORTANT: we must set the timer and _then_ check the halt_requested_ flag (the reverse of the\n// order in which they are set when shutting down), so we will never miss a shutdown.\n//\nboost::system::error_code ec;\nthis-&gt;idle_timer_.expires_from_now(\nboost::posix_time::milliseconds(this-&gt;settings_.idle_connection_timeout_ms), ec);\nBATT_VLOG(1) &lt;&lt; BATT_INSPECT(activity_before) &lt;&lt; \"; Waiting for \"\n&lt;&lt; this-&gt;settings_.idle_connection_timeout_ms &lt;&lt; \"ms\"\n&lt;&lt; BATT_INSPECT(this-&gt;idle_timer_.expires_at());\nif (ec) {\nBATT_VLOG(1) &lt;&lt; \"Error setting idle timer: \" &lt;&lt; BATT_INSPECT(to_status(ec));\nbreak;\n}\nif (this-&gt;halt_requested_.get_value()) {\nbreak;\n}\nIOResult&lt;&gt; result = Task::await&lt;IOResult&lt;&gt;&gt;([this](auto&amp;&amp; handler) {\nthis-&gt;idle_timer_.async_wait(BATT_FORWARD(handler));\n});\nif (!result.ok() || this-&gt;halt_requested_.get_value()) {\nBATT_VLOG(1) &lt;&lt; \"Idle timer cancelled: \" &lt;&lt; BATT_INSPECT(result)\n&lt;&lt; BATT_INSPECT(this-&gt;halt_requested_);\nbreak;\n}\nif (this-&gt;activity_.get_value() == activity_before) {\nBATT_VLOG(1) &lt;&lt; \"Closing idle connection\" &lt;&lt; BATT_INSPECT(this-&gt;remote_endpoint())\n&lt;&lt; BATT_INSPECT(this-&gt;local_endpoint());\nthis-&gt;idle_shutdown();\nbreak;\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::halt_idle_timeout_task() noexcept\n{\n// IMPORTANT: halt_requested_ flag must be set before cancelling the timer.\n//\nthis-&gt;halt_requested_.set_value(true);\nboost::system::error_code ec;\nthis-&gt;idle_timer_.cancel(ec);\nthis-&gt;idle_timer_.expires_from_now(boost::posix_time::seconds(-1), ec);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::idle_shutdown() noexcept\n{\nboost::system::error_code ec;\nthis-&gt;socket_.close(ec);\n//----- --- -- -  -  -   -\n// Do NOT close the token pool, since we never do a blocking issue_grant during normal operation.\n//  this-&gt;request_processor_tokens_.close();\n//----- --- -- -  -  -   -\nthis-&gt;input_buffer_.close();\nthis-&gt;shutdown_request_queue();\nthis-&gt;shutdown_response_queue();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::process_requests(Grant token)\n{\nconst auto task_id = Task::current_id();\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::process_requests Entered\" &lt;&lt; BATT_INSPECT(task_id);\nauto on_scope_exit = batt::finally([&amp;] {\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::process_requests Exiting\" &lt;&lt; BATT_INSPECT(task_id);\n});\nBATT_CHECK_EQ(token.size(), 1u);\nBATT_CHECK_EQ(token.get_issuer(), std::addressof(this-&gt;request_processor_tokens_));\nBATT_ASSIGN_OK_RESULT(HttpRequestDispatcherFn request_dispatcher, this-&gt;request_dispatcher_factory_());\nfor (;;) {\nHttpRequest request;\nHttpResponse response;\nStatus push_status = this-&gt;request_queue_.push(make_pin(&amp;request), make_pin(&amp;response));\nBATT_REQUIRE_OK(push_status);\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::process_requests: Waiting for message\"\n&lt;&lt; BATT_INSPECT(task_id);\nStatusOr&lt;pico_http::Request&amp;&gt; request_message = request.await_message();\nBATT_REQUIRE_OK(request_message)\n&lt;&lt; \"HttpServerConnection::process_requests: Failed to receive HTTP request message\";\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::process_requests: Got request; dispatching\"\n&lt;&lt; BATT_INSPECT(task_id);\nStatus dispatch_status = request_dispatcher(request, response);\nBATT_REQUIRE_OK(dispatch_status);\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status HttpServerConnection::send_responses()\n{\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::send_responses Entered\";\nauto on_scope_exit = batt::finally([&amp;] {\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::send_responses Exiting\";\nthis-&gt;shutdown_request_queue();\nthis-&gt;shutdown_response_queue();\nboost::system::error_code ec;\nthis-&gt;socket_.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n});\nfor (;;) {\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::send_responses: Waiting for request processor\";\nBATT_ASSIGN_OK_RESULT(Pin&lt;HttpResponse&gt; response, this-&gt;response_queue_.await_next());\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::send_responses: Waiting for response\";\nStatusOr&lt;pico_http::Response&amp;&gt; response_message = response-&gt;await_message();\nBATT_REQUIRE_OK(response_message);\nHttpMessageInfo response_info{*response_message};\nif (!response_info.is_valid()) {\nresponse_info.keep_alive = false;\nif (!response_info.is_valid()) {\nBATT_LOG_WARNING() &lt;&lt; \"Invalid response message: \" &lt;&lt; response_info;\nbreak;\n}\n}\nthis-&gt;activity_.fetch_add(1);\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::send_responses: Got response; serializing\";\nStatus status = response-&gt;serialize(this-&gt;socket_);\nBATT_REQUIRE_OK(status);\nBATT_VLOG(1) &lt;&lt; \"HttpServerConnection::send_responses: Finished serializing response\";\nthis-&gt;activity_.fetch_add(1);\nif (!response_info.keep_alive) {\nbreak;\n}\n}\nreturn OkStatus();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::shutdown_request_queue()\n{\nBATT_VLOG(1) &lt;&lt; \"Shutting down request queue\";\nthis-&gt;request_queue_.close();\nthis-&gt;request_queue_.drain([](std::tuple&lt;Pin&lt;HttpRequest&gt;, Pin&lt;HttpResponse&gt;&gt;&amp; item) {\nPin&lt;HttpRequest&gt; request;\nPin&lt;HttpResponse&gt; response;\nstd::tie(request, response) = std::move(item);\nBATT_CHECK_NOT_NULLPTR(request);\nBATT_CHECK_NOT_NULLPTR(response);\nrequest-&gt;close();\nresponse-&gt;close();\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServerConnection::shutdown_response_queue()\n{\nBATT_VLOG(1) &lt;&lt; \"Shutting down response queue\";\nthis-&gt;response_queue_.close();\nthis-&gt;response_queue_.drain([](Pin&lt;HttpResponse&gt;&amp; response) {\nBATT_CHECK_NOT_NULLPTR(response);\nresponse-&gt;close();\n});\n}\n}  //namespace batt\n#endif  // BATTERIES_HTTP_HTTP_SERVER_CONNECTION_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__decl_8hpp/","title":"batteries/http/http_server_decl.hpp","text":""},{"location":"_autogen/Files/http__server__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__server__decl_8hpp/#classes","title":"Classes","text":"Name class batt::HttpServer An HTTP server."},{"location":"_autogen/Files/http__server__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_DECL_HPP"},{"location":"_autogen/Files/http__server__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__server__decl_8hpp/#define-batteries_http_http_server_decl_hpp","title":"define BATTERIES_HTTP_HTTP_SERVER_DECL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_SERVER_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__server__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_DECL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/host_address.hpp&gt;\n#include &lt;batteries/http/http_request.hpp&gt;\n#include &lt;batteries/http/http_response.hpp&gt;\n#include &lt;batteries/http/http_server_settings.hpp&gt;\n#include &lt;batteries/async/grant.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;memory&gt;\nnamespace batt {\nusing HttpRequestDispatcherFn = SmallFn&lt;Status(HttpRequest&amp; request, HttpResponse&amp; response)&gt;;\nusing HttpRequestDispatcherFactoryFn = SmallFn&lt;StatusOr&lt;HttpRequestDispatcherFn&gt;()&gt;;\nclass HttpServer\n{\npublic:\nexplicit HttpServer(boost::asio::io_context&amp; io, HostAddress&amp;&amp; host_address,\nHttpRequestDispatcherFactoryFn&amp;&amp; dispatcher_factory,\nconst Optional&lt;HttpServerSettings&gt;&amp; settings = None) noexcept;\n~HttpServer() noexcept;\nboost::asio::io_context&amp; get_io_context() const noexcept\n{\nreturn this-&gt;io_;\n}\nvoid halt();\nvoid join();\nStatus get_final_status() const;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nvoid acceptor_task_main();\nvoid connection_task_main(boost::asio::ip::tcp::socket&amp;&amp; socket);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::asio::io_context&amp; io_;\nHostAddress host_address_;\nHttpRequestDispatcherFactoryFn dispatcher_factory_;\nHttpServerSettings settings_;\nboost::asio::ip::tcp::acceptor acceptor_;\nWatch&lt;bool&gt; halt_requested_{false};\nStatus final_status_;\nGrant::Issuer connection_tokens_;\nTask acceptor_task_;\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_SERVER_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__impl_8hpp/","title":"batteries/http/http_server_impl.hpp","text":""},{"location":"_autogen/Files/http__server__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__server__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP"},{"location":"_autogen/Files/http__server__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__server__impl_8hpp/#define-batteries_http_http_server_impl_hpp","title":"define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__server__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/backoff.hpp&gt;\n#include &lt;batteries/http/http_server.hpp&gt;\n#include &lt;batteries/http/http_server_connection.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ HttpServer::HttpServer(boost::asio::io_context&amp; io, HostAddress&amp;&amp; host_address,\nHttpRequestDispatcherFactoryFn&amp;&amp; dispatcher_factory,\nconst Optional&lt;HttpServerSettings&gt;&amp; settings) noexcept\n: io_{io}\n, host_address_{std::move(host_address)}\n, dispatcher_factory_{std::move(dispatcher_factory)}\n, settings_{settings.or_else(&amp;HttpServerSettings::with_default_values)}\n, acceptor_{this-&gt;io_.get_executor()}\n, connection_tokens_{this-&gt;settings_.max_connections}\n, acceptor_task_{io.get_executor(),\n[this] {\nthis-&gt;acceptor_task_main();\n},\n\"HttpServer::acceptor_task\"}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpServer::~HttpServer() noexcept\n{\nthis-&gt;halt();\nthis-&gt;join();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServer::halt()\n{\nthis-&gt;halt_requested_.set_value(true);\nboost::system::error_code ec;\nthis-&gt;acceptor_.close(ec);\nif (ec) {\nBATT_LOG_ERROR() &lt;&lt; \"Error closing acceptor: \" &lt;&lt; ec;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServer::join()\n{\nthis-&gt;acceptor_task_.join();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void HttpServer::acceptor_task_main()\n{\nthis-&gt;final_status_ = [&amp;]() -&gt; Status {\nBATT_VLOG(1) &lt;&lt; \"HttpServer::acceptor_task entered\";\nBATT_CHECK_EQ(this-&gt;host_address_.scheme, \"http\") &lt;&lt; \"TODO [tastolfi 2022-05-06] implement https!\";\n// Resolve the server endpoint so we can bind our acceptor socket.\n//\nBATT_ASSIGN_OK_RESULT(SmallVec&lt;boost::asio::ip::tcp::endpoint&gt; endpoints,\nawait_resolve(this-&gt;io_, this-&gt;host_address_));\nif (endpoints.empty()) {\nreturn StatusCode::kInvalidArgument;\n}\nboost::asio::ip::tcp::endpoint endpoint = endpoints[0];\n{\nboost::system::error_code ec;\nthis-&gt;acceptor_.open(endpoint.protocol(), ec);\nBATT_REQUIRE_OK(ec);\nthis-&gt;acceptor_.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true), ec);\nBATT_REQUIRE_OK(ec);\nthis-&gt;acceptor_.bind(endpoint, ec);\nBATT_REQUIRE_OK(ec);\nthis-&gt;acceptor_.listen(boost::asio::ip::tcp::socket::max_listen_connections, ec);\nBATT_REQUIRE_OK(ec);\n}\nwhile (!this-&gt;halt_requested_.get_value()) {\nBATT_VLOG(1) &lt;&lt; \"Waiting for connection\";\nIOResult&lt;boost::asio::ip::tcp::socket&gt; socket = Task::await_accept(this-&gt;acceptor_);\nBATT_REQUIRE_OK(socket);\nBATT_VLOG(1) &lt;&lt; \"Client connected; spawning connection task\";\nHttpServerConnection::spawn(std::move(*socket), make_copy(this-&gt;dispatcher_factory_),\nthis-&gt;settings_);\n}\nreturn OkStatus();\n}();\n}\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_SERVER_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__settings_8cpp/","title":"batteries/http/http_server_settings.cpp","text":""},{"location":"_autogen/Files/http__server__settings_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/http_server_settings.hpp&gt;\n//\n#include &lt;batteries/http/http_server_settings_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__settings_8hpp/","title":"batteries/http/http_server_settings.hpp","text":""},{"location":"_autogen/Files/http__server__settings_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_server_settings_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/http_server_settings_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__settings__decl_8hpp/","title":"batteries/http/http_server_settings_decl.hpp","text":""},{"location":"_autogen/Files/http__server__settings__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__server__settings__decl_8hpp/#classes","title":"Classes","text":"Name struct batt::HttpServerSettings"},{"location":"_autogen/Files/http__server__settings__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_SETTINGS_DECL_HPP"},{"location":"_autogen/Files/http__server__settings__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__server__settings__decl_8hpp/#define-batteries_http_http_server_settings_decl_hpp","title":"define BATTERIES_HTTP_HTTP_SERVER_SETTINGS_DECL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_SERVER_SETTINGS_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__server__settings__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_SETTINGS_DECL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_SETTINGS_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/constants.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\nstruct HttpServerSettings {\nstatic constexpr usize kDefaultMaxConnections = 1024;\nstatic constexpr i32 kDefaultIdleConnectionTimeoutMs = 60 * 1000;\nstatic constexpr usize kDefaultConnectionBufferSize = 16 * kKiB;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic HttpServerSettings with_default_values() noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nusize max_connections;\nusize max_requests_per_connection;\ni32 idle_connection_timeout_ms;\nusize connection_buffer_size;\n};\n}  //namespace batt\n#endif  // BATTERIES_HTTP_HTTP_SERVER_SETTINGS_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__server__settings__impl_8hpp/","title":"batteries/http/http_server_settings_impl.hpp","text":""},{"location":"_autogen/Files/http__server__settings__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__server__settings__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_SERVER_SETTINGS_IMPL_HPP"},{"location":"_autogen/Files/http__server__settings__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__server__settings__impl_8hpp/#define-batteries_http_http_server_settings_impl_hpp","title":"define BATTERIES_HTTP_HTTP_SERVER_SETTINGS_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_SERVER_SETTINGS_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__server__settings__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_SERVER_SETTINGS_IMPL_HPP\n#define BATTERIES_HTTP_HTTP_SERVER_SETTINGS_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/http/http_server_settings.hpp&gt;\n#include &lt;thread&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL HttpServerSettings HttpServerSettings ::with_default_values() noexcept\n{\nreturn HttpServerSettings{\n.max_connections = HttpServerSettings::kDefaultMaxConnections,\n.max_requests_per_connection = std::thread::hardware_concurrency(),\n.idle_connection_timeout_ms = HttpServerSettings::kDefaultIdleConnectionTimeoutMs,\n.connection_buffer_size = HttpServerSettings::kDefaultConnectionBufferSize,\n};\n}\n}  //namespace batt\n#endif  // BATTERIES_HTTP_HTTP_SERVER_SETTINGS_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/http__version_8hpp/","title":"batteries/http/http_version.hpp","text":""},{"location":"_autogen/Files/http__version_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/http__version_8hpp/#classes","title":"Classes","text":"Name struct batt::HttpVersion"},{"location":"_autogen/Files/http__version_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_HTTP_VERSION_HPP"},{"location":"_autogen/Files/http__version_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/http__version_8hpp/#define-batteries_http_http_version_hpp","title":"define BATTERIES_HTTP_HTTP_VERSION_HPP","text":"<pre><code>#define BATTERIES_HTTP_HTTP_VERSION_HPP()\n</code></pre>"},{"location":"_autogen/Files/http__version_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_HTTP_VERSION_HPP\n#define BATTERIES_HTTP_HTTP_VERSION_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\nstruct HttpVersion {\ni32 major_version;\ni32 minor_version;\n};\n}  // namespace batt\n#endif  // BATTERIES_HTTP_HTTP_VERSION_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/inline__sub__task_8hpp/","title":"batteries/async/inline_sub_task.hpp","text":""},{"location":"_autogen/Files/inline__sub__task_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/inline__sub__task_8hpp/#classes","title":"Classes","text":"Name class batt::InlineSubTask A scoped asynchronous task with inline stack memory."},{"location":"_autogen/Files/inline__sub__task_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_INLINE_SUB_TASK_HPP"},{"location":"_autogen/Files/inline__sub__task_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/inline__sub__task_8hpp/#define-batteries_async_inline_sub_task_hpp","title":"define BATTERIES_ASYNC_INLINE_SUB_TASK_HPP","text":"<pre><code>#define BATTERIES_ASYNC_INLINE_SUB_TASK_HPP()\n</code></pre>"},{"location":"_autogen/Files/inline__sub__task_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_INLINE_SUB_TASK_HPP\n#define BATTERIES_ASYNC_INLINE_SUB_TASK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/async_run_task.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/constants.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;atomic&gt;\nnamespace batt {\ntemplate &lt;usize kStackBufferSize&gt;\nclass InlineSubTask\n{\npublic:\nstatic constexpr usize kTaskStackOverhead = 4 * kKiB;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename BodyFn, typename... TaskArgs&gt;\nexplicit InlineSubTask(const boost::asio::any_io_executor&amp; ex, BodyFn&amp;&amp; body_fn,\nTaskArgs&amp;&amp;... task_args) noexcept\n: task_{async_run_task(                                  //\nex,                                                //\nStackSize{kStackBufferSize - kTaskStackOverhead},  //\nBATT_FORWARD(body_fn),                             //\nTask::GetIsStarted{&amp;this-&gt;is_started_},            //\nBATT_FORWARD(task_args)...,                        //\n/*completion_handler=*/[this] {\nBATT_CHECK(!this-&gt;handler_memory_.in_use());\n{\nHandlerList&lt;&gt; local_handlers;\nstd::swap(local_handlers, this-&gt;completion_handlers_);\ninvoke_all_handlers(&amp;local_handlers);\n}\nthis-&gt;completed_.set_value_and_release(true);\n})}\n{\n// If the task was started in the ctor, then don't save `this-&gt;task_`, since it may dangle at any\n// moment!\n//\nif (this-&gt;is_started_) {\nthis-&gt;task_ = nullptr;\n} else {\nBATT_CHECK(!this-&gt;completed_.get_value());\n}\n}\n//----- --- -- -  -  -   -\nInlineSubTask(const InlineSubTask&amp;) = delete;\nInlineSubTask&amp; operator=(const InlineSubTask&amp;) = delete;\n//----- --- -- -  -  -   -\n~InlineSubTask() noexcept\n{\nthis-&gt;join();\n}\ntemplate &lt;typename F = void()&gt;\nvoid call_when_done(F&amp;&amp; handler)\n{\nBATT_CHECK(!this-&gt;is_started())\n&lt;&lt; \"InlineSubTask::call_when_done must be called _before_ the task is started!\";\npush_handler(&amp;this-&gt;completion_handlers_, BATT_FORWARD(handler));\n}\nvoid start() noexcept\n{\nif (this-&gt;task_) {\nTask* local_task = nullptr;\nstd::swap(local_task, this-&gt;task_);\nlocal_task-&gt;start();\n}\n}\nbool is_started() const noexcept\n{\nreturn this-&gt;task_ == nullptr;\n}\nvoid join() noexcept\n{\nBATT_CHECK_OK(this-&gt;completed_.await_equal(true));\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nWatch&lt;bool&gt; completed_{false};\nbool is_started_ = false;\nTask* task_ = nullptr;\nHandlerList&lt;&gt; completion_handlers_;\nHandlerMemory&lt;kStackBufferSize&gt; handler_memory_;\n};\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_INLINE_SUB_TASK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/inner__reduce_8hpp/","title":"batteries/seq/inner_reduce.hpp","text":""},{"location":"_autogen/Files/inner__reduce_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/inner__reduce_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::InnerReduceBinder"},{"location":"_autogen/Files/inner__reduce_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_INNER_REDUCE_HPP"},{"location":"_autogen/Files/inner__reduce_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/inner__reduce_8hpp/#define-batteries_seq_inner_reduce_hpp","title":"define BATTERIES_SEQ_INNER_REDUCE_HPP","text":"<pre><code>#define BATTERIES_SEQ_INNER_REDUCE_HPP()\n</code></pre>"},{"location":"_autogen/Files/inner__reduce_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_INNER_REDUCE_HPP\n#define BATTERIES_SEQ_INNER_REDUCE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/reduce.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// inner_reduce\n//\ntemplate &lt;typename ReduceFn&gt;\nstruct InnerReduceBinder {\nReduceFn reduce_fn;\n};\ntemplate &lt;typename ReduceFn&gt;\nInnerReduceBinder&lt;ReduceFn&gt; inner_reduce(ReduceFn&amp;&amp; reduce_fn)\n{\nreturn {BATT_FORWARD(reduce_fn)};\n}\ntemplate &lt;typename Seq, typename ReduceFn&gt;\n[[nodiscard]] Optional&lt;std::decay_t&lt;SeqItem&lt;Seq&gt;&gt;&gt; operator|(Seq&amp;&amp; seq, InnerReduceBinder&lt;ReduceFn&gt; binder)\n{\nOptional&lt;std::decay_t&lt;SeqItem&lt;Seq&gt;&gt;&gt; state = seq.next();\nif (!state) {\nreturn state;\n}\nreturn BATT_FORWARD(seq) | reduce(std::move(*state), BATT_FORWARD(binder.reduce_fn));\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_INNER_REDUCE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/inspect_8hpp/","title":"batteries/seq/inspect.hpp","text":""},{"location":"_autogen/Files/inspect_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/inspect_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_INSPECT_HPP"},{"location":"_autogen/Files/inspect_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/inspect_8hpp/#define-batteries_seq_inspect_hpp","title":"define BATTERIES_SEQ_INSPECT_HPP","text":"<pre><code>#define BATTERIES_SEQ_INSPECT_HPP()\n</code></pre>"},{"location":"_autogen/Files/inspect_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_INSPECT_HPP\n#define BATTERIES_SEQ_INSPECT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/map.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// inspect\ntemplate &lt;typename Fn&gt;\nauto inspect(Fn&amp;&amp; fn)\n{\nreturn map([fn = BATT_FORWARD(fn)](auto&amp;&amp; item) -&gt; decltype(auto) {\nfn(item);\nreturn BATT_FORWARD(item);\n});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_INSPECT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/inspect__adjacent_8hpp/","title":"batteries/seq/inspect_adjacent.hpp","text":""},{"location":"_autogen/Files/inspect__adjacent_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/inspect__adjacent_8hpp/#classes","title":"Classes","text":"Name class batt::seq::InspectAdjacent struct batt::seq::InspectAdjacentBinder"},{"location":"_autogen/Files/inspect__adjacent_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_INSPECT_ADJACENT_HPP"},{"location":"_autogen/Files/inspect__adjacent_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/inspect__adjacent_8hpp/#define-batteries_seq_inspect_adjacent_hpp","title":"define BATTERIES_SEQ_INSPECT_ADJACENT_HPP","text":"<pre><code>#define BATTERIES_SEQ_INSPECT_ADJACENT_HPP()\n</code></pre>"},{"location":"_autogen/Files/inspect__adjacent_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_INSPECT_ADJACENT_HPP\n#define BATTERIES_SEQ_INSPECT_ADJACENT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// inspect_adjacent(binary_fn)\n//\ntemplate &lt;typename Seq, typename Fn&gt;\nclass InspectAdjacent\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit InspectAdjacent(Seq&amp;&amp; seq, Fn&amp;&amp; fn) noexcept : seq_(BATT_FORWARD(seq)), fn_(BATT_FORWARD(fn))\n{\n}\nInspectAdjacent(InspectAdjacent&amp;&amp; that) noexcept\n: seq_(BATT_FORWARD(that.seq_))\n, fn_(BATT_FORWARD(*that.fn_))\n, next_(BATT_FORWARD(that.next_))\n{\n}\nInspectAdjacent&amp; operator=(InspectAdjacent&amp;&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;seq_ = BATT_FORWARD(that.seq_);\nthis-&gt;fn_.emplace(BATT_FORWARD(*that.fn_));\nthis-&gt;next_ = BATT_FORWARD(that.next_);\n}\nreturn *this;\n}\nInspectAdjacent(const InspectAdjacent&amp; that) : seq_(that.seq_), fn_(*that.fn_), next_(that.next_)\n{\n}\nInspectAdjacent&amp; operator=(const InspectAdjacent&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;seq_ = that.seq_;\nthis-&gt;fn_.emplace(*that.fn_);\nthis-&gt;next_ = that.next_;\n}\nreturn *this;\n}\nOptional&lt;Item&gt; peek()\n{\nreturn next_;\n}\nOptional&lt;Item&gt; next()\n{\nauto item = std::move(next_);\nnext_ = seq_.next();\nif (item &amp;&amp; next_) {\n(*fn_)(*item, *next_);\n}\nreturn item;\n}\nprivate:\nSeq seq_;\nOptional&lt;Fn&gt; fn_;\nOptional&lt;SeqItem&lt;Seq&gt;&gt; next_{seq_.next()};\n};\ntemplate &lt;typename Fn&gt;\nstruct InspectAdjacentBinder {\nFn fn;\n};\ntemplate &lt;typename Fn&gt;\nInspectAdjacentBinder&lt;Fn&gt; inspect_adjacent(Fn&amp;&amp; fn)\n{\nreturn {BATT_FORWARD(fn)};\n}\ntemplate &lt;typename Seq, typename Fn&gt;\nInspectAdjacent&lt;Seq, Fn&gt; operator|(Seq&amp;&amp; seq, InspectAdjacentBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nreturn InspectAdjacent&lt;Seq, Fn&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.fn)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_INSPECT_ADJACENT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/instance__counter_8hpp/","title":"batteries/instance_counter.hpp","text":""},{"location":"_autogen/Files/instance__counter_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/instance__counter_8hpp/#classes","title":"Classes","text":"Name class batt::InstanceCounter A quick and easy way to track the number of instances of a given type in existence; just add batt::InstanceCounter as a field or base class of T."},{"location":"_autogen/Files/instance__counter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_INSTANCE_COUNTER_HPP"},{"location":"_autogen/Files/instance__counter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/instance__counter_8hpp/#define-batteries_instance_counter_hpp","title":"define BATTERIES_INSTANCE_COUNTER_HPP","text":"<pre><code>#define BATTERIES_INSTANCE_COUNTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/instance__counter_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_INSTANCE_COUNTER_HPP\n#define BATTERIES_INSTANCE_COUNTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;atomic&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass InstanceCounter\n{\npublic:\nusing Self = InstanceCounter;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic isize get() noexcept\n{\nreturn Self::instance().load();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nInstanceCounter() noexcept\n{\nSelf::instance().fetch_add(1);\n}\n~InstanceCounter() noexcept\n{\nSelf::instance().fetch_sub(1);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nstatic std::atomic&lt;isize&gt;&amp; instance() noexcept\n{\nstatic std::atomic&lt;isize&gt; instance_{0};\nreturn instance_;\n}\n};\n}  //namespace batt\n#endif  // BATTERIES_INSTANCE_COUNTER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/int__types_8hpp/","title":"batteries/int_types.hpp","text":""},{"location":"_autogen/Files/int__types_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::int_types"},{"location":"_autogen/Files/int__types_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\nnamespace batt {\nnamespace int_types {\n// =============================================================================\n// Integral type definitions - adopt Rust style, to make code more concise.\n//\nusing u8 = std::uint8_t;\nusing i8 = std::int8_t;\nusing u16 = std::uint16_t;\nusing i16 = std::int16_t;\nusing u32 = std::uint32_t;\nusing i32 = std::int32_t;\nusing u64 = std::uint64_t;\nusing i64 = std::int64_t;\nusing usize = std::size_t;\nusing isize = std::ptrdiff_t;\n}  // namespace int_types\nusing namespace int_types;\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/interval_8hpp/","title":"batteries/interval.hpp","text":""},{"location":"_autogen/Files/interval_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/interval_8hpp/#classes","title":"Classes","text":"Name struct batt::IClosedOpen struct batt::IClosed struct batt::BasicInterval A set of totally ordered values, defined by a lower and upper bound. struct batt::BasicInterval::LinearOrder Partial order on Interval values that corresponds to a strict ordering on a one dimensional number line. struct batt::BasicInterval::LexicographicalOrder Total order that sorts intervals first by lower bound, then by upper bound (i.e., by \"dictionary order\")."},{"location":"_autogen/Files/interval_8hpp/#defines","title":"Defines","text":"Name BATTERIES_INTERVAL_HPP"},{"location":"_autogen/Files/interval_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/interval_8hpp/#define-batteries_interval_hpp","title":"define BATTERIES_INTERVAL_HPP","text":"<pre><code>#define BATTERIES_INTERVAL_HPP()\n</code></pre>"},{"location":"_autogen/Files/interval_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_INTERVAL_HPP\n#define BATTERIES_INTERVAL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/interval_traits.hpp&gt;\n#include &lt;batteries/seq/reverse.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;cstddef&gt;\n#include &lt;ostream&gt;\nnamespace batt {\ntemplate &lt;typename T, typename U = T&gt;\nstruct IClosedOpen\n: IntervalTraits&lt;T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, seq::NaturalOrder,\nseq::NaturalEquals&gt; {\n};\ntemplate &lt;typename T, typename U = T&gt;\nstruct IClosed\n: IntervalTraits&lt;T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, seq::NaturalOrder,\nseq::NaturalEquals&gt; {\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename Traits&gt;\nstruct BasicInterval;\ntemplate &lt;typename T&gt;\nusing Interval = BasicInterval&lt;IClosedOpen&lt;T&gt;&gt;;\ntemplate &lt;typename T&gt;\nusing CInterval = BasicInterval&lt;IClosed&lt;T&gt;&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename Traits&gt;\nstruct BasicInterval {\nusing traits_type = Traits;\ntypename Traits::lower_bound_type lower_bound;\ntypename Traits::upper_bound_type upper_bound;\nauto size() const\n{\nreturn Traits::size(this-&gt;lower_bound, this-&gt;upper_bound);\n}\nbool empty() const\n{\nreturn Traits::empty(this-&gt;lower_bound, this-&gt;upper_bound);\n}\ntemplate &lt;typename V&gt;\nbool contains(const V&amp; item) const\n{\nreturn Traits::lower_includes_x(this-&gt;lower_bound, item) &amp;&amp;\nTraits::x_included_by_upper(item, this-&gt;upper_bound);\n}\ntemplate &lt;typename ThatTraits&gt;\nbool adjacent_to(const BasicInterval&lt;ThatTraits&gt;&amp; that) const\n{\nstatic_assert(interval_traits_compatible&lt;Traits, ThatTraits&gt;(), \"\");\n// The intervals are adjacent if no non-empty interval can be constructed between them.\n//\nreturn Traits::adjacent(this-&gt;lower_bound, this-&gt;upper_bound, that.lower_bound, that.upper_bound);\n}\ntemplate &lt;typename ThatTraits&gt;\nBasicInterval union_with(const BasicInterval&lt;ThatTraits&gt;&amp; that) const\n{\nstatic_assert(interval_traits_compatible&lt;Traits, ThatTraits&gt;(), \"\");\nreturn BasicInterval{std::min(this-&gt;lower_bound, that.lower_bound),\nstd::max(this-&gt;upper_bound, that.upper_bound)};\n}\ntemplate &lt;typename ThatTraits&gt;\nbool overlaps(const BasicInterval&lt;ThatTraits&gt;&amp; that) const\n{\nstatic_assert(interval_traits_compatible&lt;Traits, ThatTraits&gt;(), \"\");\nreturn !Traits::empty(that.lower_bound, this-&gt;upper_bound) &amp;&amp;\n!ThatTraits::empty(this-&gt;lower_bound, that.upper_bound);\n}\ntemplate &lt;typename ThatTraits&gt;\nBasicInterval intersection_with(const BasicInterval&lt;ThatTraits&gt;&amp; that) const\n{\nstatic_assert(interval_traits_compatible&lt;Traits, ThatTraits&gt;(), \"\");\nBasicInterval i{\n.lower_bound = Traits::max(this-&gt;lower_bound, that.lower_bound),\n.upper_bound = Traits::min(this-&gt;upper_bound, that.upper_bound),\n};\nif (i.empty()) {\nreturn BasicInterval{this-&gt;lower_bound, this-&gt;lower_bound};\n}\nreturn i;\n}\nSmallVec&lt;BasicInterval, 2&gt; without(const BasicInterval&amp; that) const\n{\nif (this-&gt;empty()) {\nreturn {};\n}\nBasicInterval first{this-&gt;lower_bound, Traits::min(this-&gt;upper_bound, that.lower_bound)};\nBasicInterval second{Traits::max(this-&gt;lower_bound, that.upper_bound), this-&gt;upper_bound};\nif (first.adjacent_to(second)) {\nreturn {*this};\n}\nSmallVec&lt;BasicInterval, 2&gt; diff;\nif (!first.empty()) {\ndiff.emplace_back(first);\n}\nif (!second.empty()) {\ndiff.emplace_back(second);\n}\nreturn diff;\n}\ntemplate &lt;typename DiffT&gt;\nBasicInterval shift_up(const DiffT&amp; d) const\n{\nreturn BasicInterval{\n.lower_bound = this-&gt;lower_bound + d,\n.upper_bound = this-&gt;upper_bound + d,\n};\n}\ntemplate &lt;typename DiffT&gt;\nBasicInterval shift_down(const DiffT&amp; d) const\n{\nreturn BasicInterval{\n.lower_bound = this-&gt;lower_bound - d,\n.upper_bound = this-&gt;upper_bound - d,\n};\n}\ntemplate &lt;typename TraitsL, typename TraitsR&gt;\nfriend bool operator==(const BasicInterval&lt;TraitsL&gt;&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r);\ntemplate &lt;typename TraitsL, typename TraitsR&gt;\nfriend bool operator!=(const BasicInterval&lt;TraitsL&gt;&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r);\ntemplate &lt;typename TraitsT&gt;\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const BasicInterval&lt;TraitsT&gt;&amp; t);\nstruct LinearOrder {\ntemplate &lt;typename TraitsL, typename TraitsR&gt;\nbool operator()(const BasicInterval&lt;TraitsL&gt;&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r) const\n{\nstatic_assert(interval_traits_compatible&lt;TraitsL, TraitsR&gt;(), \"\");\nreturn TraitsL::empty(r.lower_bound, l.upper_bound);\n}\ntemplate &lt;typename L, typename TraitsR,\ntypename = std::enable_if_t&lt;!std::is_base_of_v&lt;BasicInterval&lt;TraitsR&gt;, L&gt;&gt;&gt;\nbool operator()(const L&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r) const\n{\nreturn TraitsR::x_excluded_by_lower(l, r.lower_bound);\n}\ntemplate &lt;typename TraitsL, typename R,\ntypename = std::enable_if_t&lt;!std::is_base_of_v&lt;BasicInterval&lt;TraitsL&gt;, R&gt;&gt;&gt;\nbool operator()(const BasicInterval&lt;TraitsL&gt;&amp; l, const R&amp; r) const\n{\nreturn TraitsL::upper_excludes_x(l.upper_bound, r);\n}\n};\nusing ReverseLinearOrder = seq::Reverse&lt;LinearOrder&gt;;\nstruct LexicographicalOrder {\ntemplate &lt;typename TraitsL, typename TraitsR&gt;\nbool operator()(const BasicInterval&lt;TraitsL&gt;&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r) const\n{\nstatic_assert(interval_traits_compatible&lt;TraitsL, TraitsR&gt;(), \"\");\nreturn TraitsL::less_than(l.lower_bound, r.lower_bound) ||\n(TraitsL::equal(l.lower_bound, r.lower_bound) &amp;&amp;\nTraitsL::less_than(l.upper_bound, r.upper_bound));\n}\n};\nusing ReverseLexicographicalOrder = seq::Reverse&lt;LexicographicalOrder&gt;;\n};\ntemplate &lt;typename TraitsT, typename DeltaT&gt;\nBasicInterval&lt;TraitsT&gt; push_back(const BasicInterval&lt;TraitsT&gt;&amp; i, DeltaT delta)\n{\nreturn {i.lower_bound, i.upper_bound + delta};\n}\ntemplate &lt;typename TraitsT, typename DeltaT&gt;\nBasicInterval&lt;TraitsT&gt; push_front(const BasicInterval&lt;TraitsT&gt;&amp; i, DeltaT delta)\n{\nreturn {i.lower_bound - delta, i.upper_bound};\n}\ntemplate &lt;typename TraitsT, typename DeltaT&gt;\nBasicInterval&lt;TraitsT&gt; pop_back(const BasicInterval&lt;TraitsT&gt;&amp; i, DeltaT delta)\n{\nreturn {i.lower_bound, i.upper_bound - delta};\n}\ntemplate &lt;typename TraitsT, typename DeltaT&gt;\nBasicInterval&lt;TraitsT&gt; pop_front(const BasicInterval&lt;TraitsT&gt;&amp; i, DeltaT delta)\n{\nreturn {i.lower_bound + delta, i.upper_bound};\n}\ntemplate &lt;typename T, typename U&gt;\nBasicInterval&lt;IClosedOpen&lt;std::decay_t&lt;T&gt;, std::decay_t&lt;U&gt;&gt;&gt; make_interval(T&amp;&amp; lower, U&amp;&amp; upper)\n{\nreturn {BATT_FORWARD(lower), BATT_FORWARD(upper)};\n}\ntemplate &lt;typename TraitsL, typename TraitsR&gt;\ninline bool operator==(const BasicInterval&lt;TraitsL&gt;&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r)\n{\nreturn interval_traits_compatible&lt;TraitsL, TraitsR&gt;() &amp;&amp; TraitsL::equal(l.lower_bound, r.lower_bound) &amp;&amp;\nTraitsL::equal(l.upper_bound, r.upper_bound);\n}\ntemplate &lt;typename TraitsL, typename TraitsR&gt;\ninline bool operator!=(const BasicInterval&lt;TraitsL&gt;&amp; l, const BasicInterval&lt;TraitsR&gt;&amp; r)\n{\nreturn !(l == r);\n}\ntemplate &lt;typename Traits&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const BasicInterval&lt;Traits&gt;&amp; t)\n{\nreturn out &lt;&lt; Traits::left_bracket() &lt;&lt; t.lower_bound &lt;&lt; \",\" &lt;&lt; t.upper_bound &lt;&lt; Traits::right_bracket();\n}\n}  // namespace batt\n#endif  // BATTERIES_INTERVAL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/interval__traits_8hpp/","title":"batteries/interval_traits.hpp","text":""},{"location":"_autogen/Files/interval__traits_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/interval__traits_8hpp/#classes","title":"Classes","text":"Name struct batt::IntervalTraitsBase struct batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt; struct batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt;"},{"location":"_autogen/Files/interval__traits_8hpp/#defines","title":"Defines","text":"Name BATTERIES_INTERVAL_TRAITS_HPP"},{"location":"_autogen/Files/interval__traits_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/interval__traits_8hpp/#define-batteries_interval_traits_hpp","title":"define BATTERIES_INTERVAL_TRAITS_HPP","text":"<pre><code>#define BATTERIES_INTERVAL_TRAITS_HPP()\n</code></pre>"},{"location":"_autogen/Files/interval__traits_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_INTERVAL_TRAITS_HPP\n#define BATTERIES_INTERVAL_TRAITS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/bounds.hpp&gt;\n#include &lt;batteries/seq/natural_equals.hpp&gt;\n#include &lt;batteries/seq/natural_order.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T, typename U, InclusiveLowerBound kLowerInclusive, InclusiveUpperBound kUpperInclusive,\ntypename OrderFn, typename EqualFn&gt;\nstruct IntervalTraits;\ntemplate &lt;typename Derived, typename OrderFn, typename EqualFn&gt;\nstruct IntervalTraitsBase {\nusing Base = IntervalTraitsBase;\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool less_than(const T0&amp; left, const T1&amp; right)\n{\nreturn OrderFn{}(left, right);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic std::common_type_t&lt;T0, T1&gt; min(const T0&amp; left, const T1&amp; right)\n{\nif (Base::less_than(right, left)) {\nreturn right;\n} else {\nreturn left;\n}\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic std::common_type_t&lt;T0, T1&gt; max(const T0&amp; left, const T1&amp; right)\n{\nif (Base::less_than(left, right)) {\nreturn right;\n} else {\nreturn left;\n}\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool equal(const T0&amp; left, const T1&amp; right)\n{\nreturn EqualFn{}(left, right);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool not_equal(const T0&amp; left, const T1&amp; right)\n{\nreturn !Base::equal(left, right);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool greater_than(const T0&amp; left, const T1&amp; right)\n{\nreturn Base::less_than(right, left);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool less_or_equal(const T0&amp; left, const T1&amp; right)\n{\nreturn !Base::greater_than(left, right);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool greater_or_equal(const T0&amp; left, const T1&amp; right)\n{\nreturn !Base::less_than(left, right);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool x_included_by_lower(const T0&amp; x, const T1&amp; lower)\n{\nreturn Derived::lower_includes_x(lower, x);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool upper_includes_x(const T0&amp; upper, const T1&amp; x)\n{\nreturn Derived::x_included_by_upper(x, upper);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool lower_excludes_x(const T0&amp; lower, const T0&amp; x)\n{\nreturn !Derived::lower_includes_x(lower, x);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool x_excluded_by_upper(const T0&amp; x, const T1&amp; upper)\n{\nreturn !Derived::x_included_by_upper(x, upper);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool x_excluded_by_lower(const T0&amp; x, const T1&amp; lower)\n{\nreturn !Derived::x_included_by_lower(x, lower);\n}\ntemplate &lt;typename T0, typename T1&gt;\nstatic bool upper_excludes_x(const T0&amp; upper, const T1&amp; x)\n{\nreturn !Derived::upper_includes_x(upper, x);\n}\n};\ntemplate &lt;typename T, typename U, typename OrderFn, typename EqualFn&gt;\nstruct IntervalTraits&lt;T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn&gt;\n: IntervalTraitsBase&lt;\nIntervalTraits&lt;T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn&gt;,\nOrderFn, EqualFn&gt; {\n//\nstatic constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound::kTrue;\nstatic constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound::kFalse;\nusing lower_bound_type = T;\nusing upper_bound_type = U;\nusing Self = IntervalTraits;\nstatic std::ptrdiff_t size(const T&amp; lower, const U&amp; upper)\n{\nreturn upper - lower;\n}\nstatic bool empty(const T&amp; lower, const U&amp; upper)\n{\nreturn Self::less_or_equal(upper, lower);\n}\ntemplate &lt;typename V&gt;\nstatic bool lower_includes_x(const T&amp; lower, const V&amp; x)\n{\nreturn Self::less_or_equal(lower, x);\n}\ntemplate &lt;typename V&gt;\nstatic bool x_included_by_upper(const V&amp; x, const U&amp; upper)\n{\nreturn Self::less_than(x, upper);\n}\ntemplate &lt;typename T1, typename U1&gt;\nstatic bool adjacent(const T&amp; a_lower, const U&amp; a_upper, const T1&amp; b_lower, const U1&amp; b_upper)\n{\nreturn !Self::less_than(a_upper, b_lower) &amp;&amp; !Self::less_than(b_upper, a_lower);\n}\nstatic char left_bracket()\n{\nreturn '[';\n}\nstatic char right_bracket()\n{\nreturn ')';\n}\n};\ntemplate &lt;typename T, typename U, typename OrderFn, typename EqualFn&gt;\nstruct IntervalTraits&lt;T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn&gt;\n: IntervalTraitsBase&lt;\nIntervalTraits&lt;T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn&gt;,\nOrderFn, EqualFn&gt; {\n//\nstatic constexpr InclusiveLowerBound inclusive_lower_bound = InclusiveLowerBound::kTrue;\nstatic constexpr InclusiveUpperBound inclusive_upper_bound = InclusiveUpperBound::kTrue;\nusing lower_bound_type = T;\nusing upper_bound_type = U;\nusing Self = IntervalTraits;\nstatic std::ptrdiff_t size(const T&amp; lower, const U&amp; upper)\n{\nreturn upper - lower + 1;\n}\nstatic bool empty(const T&amp; lower, const U&amp; upper)\n{\nreturn Self::less_than(upper, lower);\n}\ntemplate &lt;typename V&gt;\nstatic bool lower_includes_x(const T&amp; lower, const V&amp; x)\n{\nreturn Self::less_or_equal(lower, x);\n}\ntemplate &lt;typename V&gt;\nstatic bool x_included_by_upper(const V&amp; x, const U&amp; upper)\n{\nreturn Self::less_or_equal(x, upper);\n}\ntemplate &lt;typename T1, typename U1&gt;\nstatic bool adjacent(const T&amp; a_lower, const U&amp; a_upper, const T1&amp; b_lower, const U1&amp; b_upper)\n{\nreturn Self::lower_includes_x(a_lower, least_upper_bound(b_upper)) &amp;&amp;\nSelf::x_included_by_upper(b_lower, least_upper_bound(a_upper));\n}\nstatic char left_bracket()\n{\nreturn '[';\n}\nstatic char right_bracket()\n{\nreturn ']';\n}\n};\ntemplate &lt;typename Traits0, typename Traits1&gt;\ninline constexpr bool interval_traits_compatible()\n{\nreturn Traits0::inclusive_lower_bound == Traits1::inclusive_lower_bound &amp;&amp;\nTraits0::inclusive_upper_bound == Traits1::inclusive_upper_bound;\n}\n}  // namespace batt\n#endif  // BATTERIES_INTERVAL_TRAITS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/io__context_8hpp/","title":"batteries/asio/io_context.hpp","text":""},{"location":"_autogen/Files/io__context_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_IO_CONTEXT_HPP"},{"location":"_autogen/Files/io__context_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/io__context_8hpp/#define-batteries_asio_io_context_hpp","title":"define BATTERIES_ASIO_IO_CONTEXT_HPP","text":"<pre><code>#define BATTERIES_ASIO_IO_CONTEXT_HPP()\n</code></pre>"},{"location":"_autogen/Files/io__context_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASIO_IO_CONTEXT_HPP\n#define BATTERIES_ASIO_IO_CONTEXT_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/io_context.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_IO_CONTEXT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/io__result_8hpp/","title":"batteries/async/io_result.hpp","text":""},{"location":"_autogen/Files/io__result_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/io__result_8hpp/#classes","title":"Classes","text":"Name class batt::IOResult"},{"location":"_autogen/Files/io__result_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_IO_RESULT_HPP"},{"location":"_autogen/Files/io__result_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/io__result_8hpp/#define-batteries_async_io_result_hpp","title":"define BATTERIES_ASYNC_IO_RESULT_HPP","text":"<pre><code>#define BATTERIES_ASYNC_IO_RESULT_HPP()\n</code></pre>"},{"location":"_autogen/Files/io__result_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_IO_RESULT_HPP\n#define BATTERIES_ASYNC_IO_RESULT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/system/error_code.hpp&gt;\n#include &lt;ostream&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nusing ErrorCode = boost::system::error_code;\ntemplate &lt;typename... Ts&gt;\nclass IOResult\n{\npublic:\nusing value_type = std::tuple_element_t&lt;\n0, std::conditional_t&lt;(sizeof...(Ts) == 1), std::tuple&lt;Ts...&gt;, std::tuple&lt;std::tuple&lt;Ts...&gt;&gt;&gt;&gt;;\ntemplate &lt;typename... Args, typename = std::enable_if_t&lt;std::is_constructible_v&lt;value_type, Args&amp;&amp;...&gt;&gt;&gt;\nexplicit IOResult(const ErrorCode&amp; ec, Args&amp;&amp;... args) noexcept : ec_{ec}\n, value_{BATT_FORWARD(args)...}\n{\n}\nbool ok() const\n{\nreturn !bool{this-&gt;ec_};\n}\nconst ErrorCode&amp; error() const\n{\nreturn this-&gt;ec_;\n}\nvalue_type&amp; operator*()\n{\nreturn value_;\n}\nconst value_type&amp; operator*() const\n{\nreturn value_;\n}\nvalue_type&amp; value()\n{\nreturn this-&gt;value_;\n}\nconst value_type&amp; value() const\n{\nreturn this-&gt;value_;\n}\nvalue_type* operator-&gt;()\n{\nreturn &amp;this-&gt;value_;\n}\nconst value_type* operator-&gt;() const\n{\nreturn &amp;this-&gt;value_;\n}\nprivate:\nErrorCode ec_;\nvalue_type value_;\n};\ntemplate &lt;typename... Ts&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const IOResult&lt;Ts...&gt;&amp; t)\n{\nreturn out &lt;&lt; \"IOResult{.error=\" &lt;&lt; t.error() &lt;&lt; \"(\" &lt;&lt; t.error().message()\n&lt;&lt; \"), .value=\" &lt;&lt; make_printable(t.value()) &lt;&lt; \",}\";\n}\ntemplate &lt;typename... Ts&gt;\nbool is_ok_status(const IOResult&lt;Ts...&gt;&amp; io_result)\n{\nreturn !io_result.error();\n}\ninline bool is_ok_status(const ErrorCode&amp; ec)\n{\nreturn !ec;\n}\ntemplate &lt;typename... Ts&gt;\nStatus to_status(const IOResult&lt;Ts...&gt;&amp; io_result)\n{\nreturn to_status(io_result.error());\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_IO_RESULT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/ip__tcp_8hpp/","title":"batteries/asio/ip_tcp.hpp","text":""},{"location":"_autogen/Files/ip__tcp_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_IP_TCP_HPP"},{"location":"_autogen/Files/ip__tcp_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/ip__tcp_8hpp/#define-batteries_asio_ip_tcp_hpp","title":"define BATTERIES_ASIO_IP_TCP_HPP","text":"<pre><code>#define BATTERIES_ASIO_IP_TCP_HPP()\n</code></pre>"},{"location":"_autogen/Files/ip__tcp_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_ASIO_IP_TCP_HPP\n#define BATTERIES_ASIO_IP_TCP_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/ip/tcp.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_IP_TCP_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/is__sorted_8hpp/","title":"batteries/seq/is_sorted.hpp","text":""},{"location":"_autogen/Files/is__sorted_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/is__sorted_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::IsSortedBinder"},{"location":"_autogen/Files/is__sorted_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_IS_SORTED_HPP"},{"location":"_autogen/Files/is__sorted_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/is__sorted_8hpp/#define-batteries_seq_is_sorted_hpp","title":"define BATTERIES_SEQ_IS_SORTED_HPP","text":"<pre><code>#define BATTERIES_SEQ_IS_SORTED_HPP()\n</code></pre>"},{"location":"_autogen/Files/is__sorted_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_IS_SORTED_HPP\n#define BATTERIES_SEQ_IS_SORTED_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/all_true.hpp&gt;\n#include &lt;batteries/seq/map_adjacent.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// is_sorted\n//\ntemplate &lt;typename Compare&gt;\nstruct IsSortedBinder {\nCompare compare;\n};\ntemplate &lt;typename Compare&gt;\nIsSortedBinder&lt;Compare&gt; is_sorted_by(Compare&amp;&amp; compare)\n{\nreturn {BATT_FORWARD(compare)};\n}\ninline auto is_sorted()\n{\nreturn is_sorted_by([](const auto&amp; left, const auto&amp; right) {\nreturn (left &lt; right) || !(right &lt; left);\n});\n}\ntemplate &lt;typename Seq, typename Compare&gt;\n[[nodiscard]] inline bool operator|(Seq&amp;&amp; seq, IsSortedBinder&lt;Compare&gt;&amp;&amp; binder)\n{\nreturn BATT_FORWARD(seq) | map_adjacent(BATT_FORWARD(binder.compare)) | all_true();\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_IS_SORTED_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/kmerge_8hpp/","title":"batteries/seq/kmerge.hpp","text":""},{"location":"_autogen/Files/kmerge_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq batt::seq::detail"},{"location":"_autogen/Files/kmerge_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::detail::HeapOrderBase struct batt::seq::detail::HeapOrderEmptyBase struct batt::seq::detail::HeapOrder class batt::seq::KMergeBy struct batt::seq::KMergeByBinder"},{"location":"_autogen/Files/kmerge_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_KMERGE_HPP"},{"location":"_autogen/Files/kmerge_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/kmerge_8hpp/#define-batteries_seq_kmerge_hpp","title":"define BATTERIES_SEQ_KMERGE_HPP","text":"<pre><code>#define BATTERIES_SEQ_KMERGE_HPP()\n</code></pre>"},{"location":"_autogen/Files/kmerge_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_KMERGE_HPP\n#define BATTERIES_SEQ_KMERGE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/cache_next.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\nnamespace detail {\ntemplate &lt;typename Compare&gt;\nstruct HeapOrderBase {\nCompare&amp; compare() noexcept\n{\nreturn this-&gt;compare_;\n}\nconst Compare&amp; compare() const noexcept\n{\nreturn this-&gt;compare_;\n}\nCompare compare_;\n};\ntemplate &lt;typename Compare&gt;\nstruct HeapOrderEmptyBase : Compare {\nCompare&amp; compare() noexcept\n{\nreturn *this;\n}\nconst Compare&amp; compare() const noexcept\n{\nreturn *this;\n}\n};\ntemplate &lt;typename Compare&gt;\nstruct HeapOrder\n: std::conditional_t&lt;                //\ncan_be_empty_base&lt;Compare&gt;(),  //\nHeapOrderEmptyBase&lt;Compare&gt;,   //\nHeapOrderBase&lt;Compare&gt;         //\n&gt; {\ntemplate &lt;typename L, typename R&gt;\nbool operator()(L* l, R* r) const\n{\n// Reversed because it's a max-heap.\nreturn this-&gt;compare()(*r-&gt;peek(), *l-&gt;peek());\n}\nHeapOrder&amp; order() noexcept\n{\nreturn *this;\n}\nconst HeapOrder&amp; order() const noexcept\n{\nreturn *this;\n}\n};\n}  //namespace detail\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// kmerge, kmerge_by\n//\ntemplate &lt;typename Seq, typename Compare&gt;\nclass KMergeBy : private detail::HeapOrder&lt;Compare&gt;\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\ntemplate &lt;typename KSeqs&gt;\nexplicit KMergeBy(KSeqs&amp;&amp; k_seqs, Compare&amp;&amp; compare) noexcept\n: detail::HeapOrder&lt;Compare&gt;{BATT_FORWARD(compare)}\n, k_seqs_(BATT_FORWARD(k_seqs) | decayed() | map([](auto&amp;&amp; seq) {\nreturn BATT_FORWARD(seq) | cache_next();\n}) |\ncollect_vec())\n{\nstatic_assert(std::is_same_v&lt;Seq, SeqItem&lt;KSeqs&gt;&gt;, \"\");\nas_seq(k_seqs_) | for_each([this](CacheNext&lt;std::decay_t&lt;Seq&gt;&gt;&amp; seq) {\nif (!seq.peek()) {\nreturn;\n}\nthis-&gt;heap_.emplace_back(&amp;seq);\nstd::push_heap(this-&gt;heap_.begin(), this-&gt;heap_.end(), this-&gt;order());\n});\nBATT_ASSERT_LE(this-&gt;heap_.size(), this-&gt;k_seqs_.size());\n}\nKMergeBy(const KMergeBy&amp; that) noexcept\n: detail::HeapOrder&lt;Compare&gt;(that.order())\n, k_seqs_(that.k_seqs_)\n, heap_(that.heap_)\n{\nfix_heap_pointers(that);\n}\nKMergeBy&amp; operator=(const KMergeBy&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;order() = that.order();\nthis-&gt;k_seqs_ = that.k_seqs_;\nthis-&gt;heap_ = that.heap_;\nfix_heap_pointers(that);\n}\nreturn *this;\n}\nOptional&lt;Item&gt; next()\n{\nif (this-&gt;heap_.empty()) {\nreturn None;\n}\n// The lowest key is at the front of the level heap.  Pop it off the heap\n// first, then remove it from that level's sequence and replace the level\n// in the heap if it isn't empty.\n//\nstd::pop_heap(this-&gt;heap_.begin(), this-&gt;heap_.end(), this-&gt;order());\nCacheNext&lt;std::decay_t&lt;Seq&gt;&gt;* next_seq = this-&gt;heap_.back();\nBATT_ASSERT_NOT_NULLPTR(next_seq);\nauto next_item = next_seq-&gt;next();\nBATT_ASSERT_NE(next_item, None);\nif (!next_seq-&gt;peek()) {\nthis-&gt;heap_.pop_back();\n} else {\nstd::push_heap(this-&gt;heap_.begin(), this-&gt;heap_.end(), this-&gt;order());\n}\nreturn next_item;\n}\nOptional&lt;Item&gt; peek()\n{\nif (this-&gt;heap_.empty()) {\nreturn None;\n}\nreturn this-&gt;heap_.front()-&gt;peek();\n}\nprivate:\nvoid fix_heap_pointers(const KMergeBy&amp; that)\n{\nfor (std::size_t i = 0; i &lt; this-&gt;heap_.size(); ++i) {\nBATT_ASSERT_GE(this-&gt;heap_[i], that.k_seqs_.data());\nBATT_ASSERT_LT(this-&gt;heap_[i], that.k_seqs_.data() + that.k_seqs_.size());\n}\nfor (auto&amp; ptr : this-&gt;heap_) {\nptr = this-&gt;k_seqs_.data() + (ptr - that.k_seqs_.data());\n}\nfor (std::size_t i = 0; i &lt; this-&gt;heap_.size(); ++i) {\nBATT_ASSERT_GE(this-&gt;heap_[i], this-&gt;k_seqs_.data());\nBATT_ASSERT_LT(this-&gt;heap_[i], this-&gt;k_seqs_.data() + this-&gt;k_seqs_.size());\nBATT_ASSERT_EQ(this-&gt;heap_[i] - this-&gt;k_seqs_.data(), that.heap_[i] - that.k_seqs_.data());\n}\n}\n// The stack of sequences we are merging.\n//\nstd::vector&lt;CacheNext&lt;std::decay_t&lt;Seq&gt;&gt;&gt; k_seqs_;\n// A min-heap (by key) of per-level edit sequences, so we can quickly know\n// where the next lowest key is.\n//\nSmallVec&lt;CacheNext&lt;std::decay_t&lt;Seq&gt;&gt;*, 6&gt; heap_;\n};\ntemplate &lt;typename Compare&gt;\nstruct KMergeByBinder {\nCompare compare;\n};\ntemplate &lt;typename Compare&gt;\nKMergeByBinder&lt;Compare&gt; kmerge_by(Compare&amp;&amp; compare)\n{\nreturn {BATT_FORWARD(compare)};\n}\ninline auto kmerge()\n{\nreturn kmerge_by(NaturalOrder{});\n}\ntemplate &lt;typename KSeqs, typename Compare&gt;\n[[nodiscard]] KMergeBy&lt;SeqItem&lt;KSeqs&gt;, Compare&gt; operator|(KSeqs&amp;&amp; k_seqs, KMergeByBinder&lt;Compare&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;KSeqs, std::decay_t&lt;KSeqs&gt;&gt;,\n\"Merged sequences may not be captured implicitly by reference.\");\nreturn KMergeBy&lt;SeqItem&lt;KSeqs&gt;, Compare&gt;{BATT_FORWARD(k_seqs), BATT_FORWARD(binder.compare)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_KMERGE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/last_8hpp/","title":"batteries/seq/last.hpp","text":""},{"location":"_autogen/Files/last_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/last_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::LastBinder"},{"location":"_autogen/Files/last_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_LAST_HPP"},{"location":"_autogen/Files/last_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/last_8hpp/#define-batteries_seq_last_hpp","title":"define BATTERIES_SEQ_LAST_HPP","text":"<pre><code>#define BATTERIES_SEQ_LAST_HPP()\n</code></pre>"},{"location":"_autogen/Files/last_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_LAST_HPP\n#define BATTERIES_SEQ_LAST_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/seq_item.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// last\n//\nstruct LastBinder {\n};\ninline LastBinder last()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, LastBinder)\n{\nusing Item = SeqItem&lt;Seq&gt;;\nOptional&lt;Item&gt; prev, next = seq.next();\nwhile (next) {\nprev = std::move(next);\nnext = seq.next();\n}\nreturn prev;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_LAST_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/latch_8cpp/","title":"batteries/async/latch.cpp","text":""},{"location":"_autogen/Files/latch_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/latch_decl.hpp&gt;\n//\n#include &lt;batteries/async/latch_impl.ipp&gt;\n//\n#include &lt;batteries/async/latch_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/latch_8hpp/","title":"batteries/async/latch.hpp","text":""},{"location":"_autogen/Files/latch_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/async/latch_decl.hpp&gt;\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/watch.ipp&gt;\n#include &lt;batteries/async/latch_impl.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/latch_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/latch__decl_8hpp/","title":"batteries/async/latch_decl.hpp","text":""},{"location":"_autogen/Files/latch__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/latch__decl_8hpp/#classes","title":"Classes","text":"Name class batt::Latch A write-once, single-value synchronized container. class batt::Latch::AsyncGetHandler"},{"location":"_autogen/Files/latch__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_LATCH_DECL_HPP"},{"location":"_autogen/Files/latch__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/latch__decl_8hpp/#define-batteries_async_latch_decl_hpp","title":"define BATTERIES_ASYNC_LATCH_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_LATCH_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/latch__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_LATCH_DECL_HPP\n#define BATTERIES_ASYNC_LATCH_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/watch_decl.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass Latch : public RefCounted&lt;Latch&lt;T&gt;&gt;\n{\npublic:\nenum State : u32 {\nkInitial = 0,\nkSetting = 1,\n// 2 intentionally skipped; these states are treated as a bitmap of orthogonal conditions.\nkReady = 3,\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nLatch() = default;\nLatch(const Latch&amp;) = delete;\nLatch&amp; operator=(const Latch&amp;) = delete;\nbool set_error(const batt::Status&amp; status);\ntemplate &lt;typename... Args&gt;\nbool set_value(Args&amp;&amp;... args);\nbool is_ready() const;\nStatusOr&lt;T&gt; await() &amp; noexcept;\nStatusOr&lt;T&gt; await() &amp;&amp; noexcept;\nStatusOr&lt;T&gt; poll();\nStatusOr&lt;T&gt; get_ready_value_or_panic() &amp; noexcept;\nStatusOr&lt;T&gt; get_ready_value_or_panic() &amp;&amp; noexcept;\ntemplate &lt;typename Handler&gt;\nvoid async_get(Handler&amp;&amp; handler);\nvoid invalidate();\nprivate:\nclass AsyncGetHandler;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nWatch&lt;u32&gt; state_{kInitial};\nOptional&lt;StatusOr&lt;T&gt;&gt; value_;\n};\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\ntemplate &lt;typename T&gt;\nclass Latch&lt;T&gt;::AsyncGetHandler\n{\npublic:\nexplicit AsyncGetHandler(Latch* latch) noexcept : latch_{latch}\n{\n}\ntemplate &lt;typename Handler&gt;\nvoid operator()(Handler&amp;&amp; handler, const StatusOr&lt;u32&gt;&amp; result) const\n{\nif (!result.ok()) {\nBATT_FORWARD(handler)(result.status());\nreturn;\n}\nif (*result == kReady) {\nBATT_CHECK(this-&gt;latch_-&gt;value_);\nBATT_FORWARD(handler)(*this-&gt;latch_-&gt;value_);\nreturn;\n}\nthis-&gt;latch_-&gt;state_.async_wait(/*last_seen=*/*result, bind_handler(BATT_FORWARD(handler), *this));\n}\nprivate:\nLatch* latch_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_LATCH_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/latch__impl_8hpp/","title":"batteries/async/latch_impl.hpp","text":""},{"location":"_autogen/Files/latch__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/latch__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_LATCH_IMPL_HPP"},{"location":"_autogen/Files/latch__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/latch__impl_8hpp/#define-batteries_async_latch_impl_hpp","title":"define BATTERIES_ASYNC_LATCH_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_LATCH_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/latch__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_LATCH_IMPL_HPP\n#define BATTERIES_ASYNC_LATCH_IMPL_HPP\nnamespace batt {\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_LATCH_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/lazy_8hpp/","title":"batteries/seq/lazy.hpp","text":""},{"location":"_autogen/Files/lazy_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/lazy_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Lazy"},{"location":"_autogen/Files/lazy_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_LAZY_HPP"},{"location":"_autogen/Files/lazy_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/lazy_8hpp/#define-batteries_seq_lazy_hpp","title":"define BATTERIES_SEQ_LAZY_HPP","text":"<pre><code>#define BATTERIES_SEQ_LAZY_HPP()\n</code></pre>"},{"location":"_autogen/Files/lazy_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_LAZY_HPP\n#define BATTERIES_SEQ_LAZY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/case_of.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;variant&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// lazy - sequence created from a factory function when `peek()/next()` is first\n// invoked.\n//\ntemplate &lt;typename Fn&gt;\nclass Lazy\n{\npublic:\nusing Seq = decltype(std::declval&lt;Fn&gt;()());\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit Lazy(Fn&amp;&amp; fn) noexcept : state_{BATT_FORWARD(fn)}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn this-&gt;seq().peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn this-&gt;seq().next();\n}\nprivate:\nSeq&amp; seq()\n{\ncase_of(\nstate_,\n[&amp;](Fn&amp; fn) -&gt; Seq&amp; {\nFn fn_copy = BATT_FORWARD(fn);\nreturn state_.template emplace&lt;Seq&gt;(fn_copy());\n},\n[](Seq&amp; seq) -&gt; Seq&amp; {\nreturn seq;\n});\n}\nstd::variant&lt;Fn, Seq&gt; state_;\n};\ntemplate &lt;typename Fn&gt;\n[[nodiscard]] auto lazy(Fn&amp;&amp; fn)\n{\nreturn Lazy&lt;Fn&gt;{BATT_FORWARD(fn)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_LAZY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/lazy__latch_8cpp/","title":"batteries/async/lazy_latch.cpp","text":""},{"location":"_autogen/Files/lazy__latch_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/lazy_latch_decl.hpp&gt;\n//\n#include &lt;batteries/async/lazy_latch_impl.ipp&gt;\n//\n#include &lt;batteries/async/lazy_latch_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/lazy__latch_8hpp/","title":"batteries/async/lazy_latch.hpp","text":""},{"location":"_autogen/Files/lazy__latch_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/async/lazy_latch_decl.hpp&gt;\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/watch.ipp&gt;\n#include &lt;batteries/async/lazy_latch_impl.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/lazy_latch_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/lazy__latch__decl_8hpp/","title":"batteries/async/lazy_latch_decl.hpp","text":""},{"location":"_autogen/Files/lazy__latch__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/lazy__latch__decl_8hpp/#classes","title":"Classes","text":"Name class batt::LazyLatch A write-once, single-value synchronized container that is populated lazily by an init_fn when the value is requested. class batt::LazyLatch::AsyncGetHandler"},{"location":"_autogen/Files/lazy__latch__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_LAZY_LATCH_DECL_HPP"},{"location":"_autogen/Files/lazy__latch__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/lazy__latch__decl_8hpp/#define-batteries_async_lazy_latch_decl_hpp","title":"define BATTERIES_ASYNC_LAZY_LATCH_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_LAZY_LATCH_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/lazy__latch__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_LAZY_LATCH_DECL_HPP\n#define BATTERIES_ASYNC_LAZY_LATCH_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/watch_decl.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/shared_ptr.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\ntemplate &lt;typename T,\ntypename InitFn = SmallFn&lt;void(AbstractHandler&lt;StatusOr&lt;T&gt;&amp;&amp;&gt;*),\n/*size=*/kCpuCacheLineSize - (sizeof(void*) + sizeof(Watch&lt;u32&gt;)),\n/*move-only=*/true,\n/*allow-alloc=*/true&gt;&gt;\nclass LazyLatch\n: public RefCounted&lt;LazyLatch&lt;T&gt;&gt;\n, private AbstractHandler&lt;StatusOr&lt;T&gt;&amp;&amp;&gt;\n{\npublic:\nenum State : u32 {\nkInitial = 0,\nkTriggered = 1,\n// 2 intentionally skipped; these states are treated as a bitmap of orthogonal conditions.\nkReady = 3,\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit LazyLatch(InitFn&amp;&amp; init_fn) noexcept;\nLazyLatch(const LazyLatch&amp;) = delete;\n~LazyLatch() noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nLazyLatch&amp; operator=(const LazyLatch&amp;) = delete;\nvoid trigger();\nbool is_ready() const;\nStatusOr&lt;T&gt; await() &amp; noexcept;\nStatusOr&lt;T&gt; await() &amp;&amp; noexcept;\nStatusOr&lt;T&gt; poll();\nStatusOr&lt;T&gt; get_ready_value_or_panic() &amp; noexcept;\nStatusOr&lt;T&gt; get_ready_value_or_panic() &amp;&amp; noexcept;\ntemplate &lt;typename Handler&gt;\nvoid async_get(Handler&amp;&amp; handler);\nvoid poke()\n{\nthis-&gt;state_.poke();\n}\nprivate:\nclass AsyncGetHandler;\nusing Storage = std::aligned_storage_t&lt;std::max(sizeof(InitFn), sizeof(StatusOr&lt;T&gt;)),\nstd::max(alignof(InitFn), alignof(StatusOr&lt;T&gt;))&gt;;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// AbstractHandler impl\n//\nvoid notify(StatusOr&lt;T&gt;&amp;&amp;) override;\nvoid destroy() override;\nvoid dump(std::ostream&amp; out) override;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nInitFn&amp; stored_init_fn() noexcept;\nStatusOr&lt;T&gt;&amp; stored_result() noexcept;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nWatch&lt;u32&gt; state_{kInitial};\nStorage storage_;\n};\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\ntemplate &lt;typename T, typename InitFn&gt;\nclass LazyLatch&lt;T, InitFn&gt;::AsyncGetHandler\n{\npublic:\nexplicit AsyncGetHandler(LazyLatch* latch) noexcept : latch_{latch}\n{\n}\ntemplate &lt;typename Handler&gt;\nvoid operator()(Handler&amp;&amp; handler, const StatusOr&lt;u32&gt;&amp; result) const\n{\nif (result.status() != StatusCode::kPoke) {\nif (!result.ok()) {\nBATT_FORWARD(handler)(result.status());\nreturn;\n}\nif (*result == kReady) {\nBATT_FORWARD(handler)(this-&gt;latch_-&gt;get_ready_value_or_panic());\nreturn;\n}\n}\nthis-&gt;latch_-&gt;state_.async_wait(/*last_seen=*/*result, bind_handler(BATT_FORWARD(handler), *this));\n}\nprivate:\nLazyLatch* latch_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_LAZY_LATCH_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/lazy__latch__impl_8hpp/","title":"batteries/async/lazy_latch_impl.hpp","text":""},{"location":"_autogen/Files/lazy__latch__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/lazy__latch__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_LAZY_LATCH_IMPL_HPP"},{"location":"_autogen/Files/lazy__latch__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/lazy__latch__impl_8hpp/#define-batteries_async_lazy_latch_impl_hpp","title":"define BATTERIES_ASYNC_LAZY_LATCH_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_LAZY_LATCH_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/lazy__latch__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_LAZY_LATCH_IMPL_HPP\n#define BATTERIES_ASYNC_LAZY_LATCH_IMPL_HPP\nnamespace batt {\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_LAZY_LATCH_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/logging_8hpp/","title":"batteries/logging.hpp","text":""},{"location":"_autogen/Files/logging_8hpp/#defines","title":"Defines","text":"Name BATTERIES_LOGGING_HPP BATT_LOG_DISABLED(...) BATT_LOG_FATAL BATT_LOG_ERROR BATT_LOG_WARNING BATT_LOG_INFO BATT_VLOG BATT_DLOG BATT_DVLOG BATT_VLOG_IS_ON(level)"},{"location":"_autogen/Files/logging_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/logging_8hpp/#define-batteries_logging_hpp","title":"define BATTERIES_LOGGING_HPP","text":"<pre><code>#define BATTERIES_LOGGING_HPP()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_log_disabled","title":"define BATT_LOG_DISABLED","text":"<pre><code>#define BATT_LOG_DISABLED(...)\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_log_fatal","title":"define BATT_LOG_FATAL","text":"<pre><code>#define BATT_LOG_FATAL()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_log_error","title":"define BATT_LOG_ERROR","text":"<pre><code>#define BATT_LOG_ERROR()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_log_warning","title":"define BATT_LOG_WARNING","text":"<pre><code>#define BATT_LOG_WARNING()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_log_info","title":"define BATT_LOG_INFO","text":"<pre><code>#define BATT_LOG_INFO()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_vlog","title":"define BATT_VLOG","text":"<pre><code>#define BATT_VLOG()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_dlog","title":"define BATT_DLOG","text":"<pre><code>#define BATT_DLOG()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_dvlog","title":"define BATT_DVLOG","text":"<pre><code>#define BATT_DVLOG()\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#define-batt_vlog_is_on","title":"define BATT_VLOG_IS_ON","text":"<pre><code>#define BATT_VLOG_IS_ON(level)\n</code></pre>"},{"location":"_autogen/Files/logging_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_LOGGING_HPP\n#define BATTERIES_LOGGING_HPP\n#include &lt;batteries/config.hpp&gt;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\n#if BATT_WITH_GLOG\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_GCC(\"-Woverloaded-virtual\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Woverloaded-virtual\")\n//\n#include &lt;glog/logging.h&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\nBATT_UNSUPPRESS_IF_GCC()\n#define BATT_LOG_FATAL() LOG(FATAL)\n#define BATT_LOG_ERROR() LOG(ERROR)\n#define BATT_LOG_WARNING() LOG(WARNING)\n#define BATT_LOG_INFO() LOG(INFO)\n#define BATT_VLOG VLOG\n#define BATT_DLOG DLOG\n#define BATT_DVLOG DLOG\n#define BATT_VLOG_IS_ON(level) VLOG_IS_ON(level)\n#else  // ==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n#include &lt;iostream&gt;\n#define BATT_LOG_DISABLED(...)                                                                               \\\n    if (false)                                                                                               \\\n    std::cerr\n#define BATT_LOG_FATAL BATT_LOG_DISABLED\n#define BATT_LOG_ERROR BATT_LOG_DISABLED\n#define BATT_LOG_WARNING BATT_LOG_DISABLED\n#define BATT_LOG_INFO BATT_LOG_DISABLED\n#define BATT_VLOG BATT_LOG_DISABLED\n#define BATT_DLOG BATT_LOG_DISABLED\n#define BATT_DVLOG BATT_LOG_DISABLED\n#define BATT_VLOG_IS_ON(level) false\n#endif  // BATT_WITH_GLOG\n#endif  // BATTERIES_LOGGING_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/loop__control_8hpp/","title":"batteries/seq/loop_control.hpp","text":""},{"location":"_autogen/Files/loop__control_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/loop__control_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_LOOP_CONTROL_HPP"},{"location":"_autogen/Files/loop__control_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/loop__control_8hpp/#define-batteries_seq_loop_control_hpp","title":"define BATTERIES_SEQ_LOOP_CONTROL_HPP","text":"<pre><code>#define BATTERIES_SEQ_LOOP_CONTROL_HPP()\n</code></pre>"},{"location":"_autogen/Files/loop__control_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_LOOP_CONTROL_HPP\n#define BATTERIES_SEQ_LOOP_CONTROL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\nenum LoopControl {\nkContinue = 0,\nkBreak = 1,\n};\ntemplate &lt;\ntypename Fn, typename... Args,\ntypename = std::enable_if_t&lt;std::is_convertible_v&lt;std::invoke_result_t&lt;Fn&amp;&amp;, Args&amp;&amp;...&gt;, LoopControl&gt;&gt;&gt;\nLoopControl run_loop_fn(Fn&amp;&amp; fn, Args&amp;&amp;... args)\n{\nreturn std::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...);\n}\ntemplate &lt;\ntypename Fn, typename... Args,\ntypename = std::enable_if_t&lt;!std::is_convertible_v&lt;std::invoke_result_t&lt;Fn&amp;&amp;, Args&amp;&amp;...&gt;, LoopControl&gt;&gt;,\ntypename = void&gt;\nLoopControl run_loop_fn(Fn&amp;&amp; fn, Args&amp;&amp;... args)\n{\nstd::forward&lt;Fn&gt;(fn)(std::forward&lt;Args&gt;(args)...);\nreturn kContinue;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_LOOP_CONTROL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/make__printable_8hpp/","title":"batteries/make_printable.hpp","text":""},{"location":"_autogen/Files/make__printable_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/make__printable_8hpp/#defines","title":"Defines","text":"Name BATTERIES_MAKE_PRINTABLE_HPP"},{"location":"_autogen/Files/make__printable_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/make__printable_8hpp/#define-batteries_make_printable_hpp","title":"define BATTERIES_MAKE_PRINTABLE_HPP","text":"<pre><code>#define BATTERIES_MAKE_PRINTABLE_HPP()\n</code></pre>"},{"location":"_autogen/Files/make__printable_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_MAKE_PRINTABLE_HPP\n#define BATTERIES_MAKE_PRINTABLE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;iomanip&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\nnamespace batt {\ntemplate &lt;typename T, typename = std::enable_if_t&lt;IsPrintable&lt;T&gt;{}&gt;&gt;\ndecltype(auto) make_printable(T&amp;&amp; obj)\n{\nreturn BATT_FORWARD(obj);\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;!IsPrintable&lt;T&gt;{}&gt;, typename = void&gt;\nstd::string make_printable(T&amp;&amp; obj)\n{\nstd::ostringstream oss;\noss &lt;&lt; \"(\" &lt;&lt; name_of&lt;T&gt;() &lt;&lt; \") \" &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0');\nfor (const u8* bytes = (const u8*)&amp;obj; bytes != (const u8*)((&amp;obj) + 1); ++bytes) {\noss &lt;&lt; (int)*bytes;\n}\nreturn oss.str();\n}\n}  //namespace batt\n#endif  // BATTERIES_MAKE_PRINTABLE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/map_8hpp/","title":"batteries/seq/map.hpp","text":""},{"location":"_autogen/Files/map_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/map_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Map struct batt::seq::MapBinder"},{"location":"_autogen/Files/map_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_MAP_HPP"},{"location":"_autogen/Files/map_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/map_8hpp/#define-batteries_seq_map_hpp","title":"define BATTERIES_SEQ_MAP_HPP","text":"<pre><code>#define BATTERIES_SEQ_MAP_HPP()\n</code></pre>"},{"location":"_autogen/Files/map_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_MAP_HPP\n#define BATTERIES_SEQ_MAP_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map\n//\ntemplate &lt;typename Seq, typename MapFn&gt;\nclass Map\n{\npublic:\nusing Item = batt::DecayRValueRef&lt;std::invoke_result_t&lt;MapFn, SeqItem&lt;Seq&gt;&gt;&gt;;\nexplicit Map(Seq&amp;&amp; seq, MapFn&amp;&amp; map_fn) noexcept : seq_(BATT_FORWARD(seq)), map_fn_(BATT_FORWARD(map_fn))\n{\nstatic_assert(!std::is_same_v&lt;Item, void&gt;,\n\"Map function must not return void! (Did you mean batt::seq::for_each?)\");\n}\nMap(Map&amp;&amp; that) noexcept : seq_(BATT_FORWARD(that.seq_)), map_fn_(BATT_FORWARD(*that.map_fn_))\n{\n}\nMap(const Map&amp; that) noexcept : seq_(that.seq_), map_fn_(*that.map_fn_)\n{\n}\nMap&amp; operator=(Map&amp;&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;seq_ = BATT_FORWARD(that.seq_);\nthis-&gt;map_fn_.emplace(BATT_FORWARD(*that.map_fn_));\n}\nreturn *this;\n}\nMap&amp; operator=(const Map&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;seq_ = that.seq_;\nthis-&gt;map_fn_.emplace(*that.map_fn_);\n}\nreturn *this;\n}\nOptional&lt;Item&gt; peek()\n{\nauto item = seq_.peek();\nif (!item) {\nreturn None;\n}\nreturn (*map_fn_)(std::forward&lt;SeqItem&lt;Seq&gt;&gt;(*item));\n}\nOptional&lt;Item&gt; next()\n{\nauto item = seq_.next();\nif (!item) {\nreturn None;\n}\nreturn (*map_fn_)(std::forward&lt;SeqItem&lt;Seq&gt;&gt;(*item));\n}\n//----------------------\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename Seq_, typename MapFn_, typename EachFn&gt;\nfriend LoopControl operator|(Map&lt;Seq_, MapFn_&gt;&amp;&amp; map_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nSeq seq_;\nOptional&lt;batt::DecayRValueRef&lt;MapFn&gt;&gt; map_fn_;\n};\ntemplate &lt;typename MapFn&gt;\nstruct MapBinder {\nMapFn map_fn;\n};\ntemplate &lt;typename MapFn&gt;\nMapBinder&lt;MapFn&gt; map(MapFn&amp;&amp; map_fn)\n{\nreturn {BATT_FORWARD(map_fn)};\n}\ntemplate &lt;typename Seq, typename MapFn&gt;\n[[nodiscard]] Map&lt;Seq, MapFn&gt; operator|(Seq&amp;&amp; seq, MapBinder&lt;MapFn&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"Mapped sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;MapFn, std::decay_t&lt;MapFn&gt;&gt;,\n\"Mapped functions may not be captured implicitly by reference.\");\nreturn Map&lt;Seq, MapFn&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.map_fn)};\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Seq, typename MapFn, typename EachFn&gt;\nLoopControl operator|(Map&lt;Seq, MapFn&gt;&amp;&amp; map_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder)\n{\nauto&amp; map_fn = *map_seq.map_fn_;\nauto loop_body = [&amp;](auto&amp;&amp; item) {\nreturn binder.fn(map_fn(std::forward&lt;SeqItem&lt;Seq&gt;&gt;(item)));\n};\nreturn std::forward&lt;Seq&gt;(map_seq.seq_) | for_each(loop_body);\n}\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_MAP_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/map__adjacent_8hpp/","title":"batteries/seq/map_adjacent.hpp","text":""},{"location":"_autogen/Files/map__adjacent_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/map__adjacent_8hpp/#classes","title":"Classes","text":"Name class batt::seq::MapAdjacent struct batt::seq::MapAdjacentBinder"},{"location":"_autogen/Files/map__adjacent_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_MAP_ADJACENT_HPP"},{"location":"_autogen/Files/map__adjacent_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/map__adjacent_8hpp/#define-batteries_seq_map_adjacent_hpp","title":"define BATTERIES_SEQ_MAP_ADJACENT_HPP","text":"<pre><code>#define BATTERIES_SEQ_MAP_ADJACENT_HPP()\n</code></pre>"},{"location":"_autogen/Files/map__adjacent_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_MAP_ADJACENT_HPP\n#define BATTERIES_SEQ_MAP_ADJACENT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map_adjacent(binary_map_fn) -\n//  Transform [i0, i1, i2, i3, i4, ...]\n//       into [f(i0, i1), f(i1, i2), f(i2, i3), ...]\n//\ntemplate &lt;typename Seq, typename Fn&gt;\nclass MapAdjacent\n{\npublic:\nusing Item = decltype(std::declval&lt;Fn&amp;&gt;()(std::declval&lt;const SeqItem&lt;Seq&gt;&amp;&gt;(),\nstd::declval&lt;const SeqItem&lt;Seq&gt;&amp;&gt;()));\nexplicit MapAdjacent(Seq&amp;&amp; seq, Fn&amp;&amp; fn) noexcept : seq_(BATT_FORWARD(seq)), fn_(BATT_FORWARD(fn))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn item_.map([&amp;](const auto&amp; first) {\nreturn seq_.peek().map([&amp;](const auto&amp; second) {\nreturn fn_(first, second);\n});\n});\n}\nOptional&lt;Item&gt; next()\n{\nif (!item_) {\nreturn None;\n}\nauto first = std::move(*item_);\nitem_ = seq_.next();\nreturn item_.map([&amp;](const auto&amp; second) {\nreturn fn_(first, second);\n});\n}\nprivate:\nSeq seq_;\nFn fn_;\nOptional&lt;SeqItem&lt;Seq&gt;&gt; item_{seq_.next()};\n};\ntemplate &lt;typename Fn&gt;\nstruct MapAdjacentBinder {\nFn fn;\n};\ntemplate &lt;typename Fn&gt;\nMapAdjacentBinder&lt;Fn&gt; map_adjacent(Fn&amp;&amp; fn)\n{\nreturn {BATT_FORWARD(fn)};\n}\ntemplate &lt;typename Seq, typename Fn&gt;\n[[nodiscard]] MapAdjacent&lt;Seq, Fn&gt; operator|(Seq&amp;&amp; seq, MapAdjacentBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nreturn MapAdjacent&lt;Seq, Fn&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.fn)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_MAP_ADJACENT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/map__fold_8hpp/","title":"batteries/seq/map_fold.hpp","text":""},{"location":"_autogen/Files/map__fold_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/map__fold_8hpp/#classes","title":"Classes","text":"Name class batt::seq::MapFold struct batt::seq::MapFoldBinder"},{"location":"_autogen/Files/map__fold_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_MAP_FOLD_HPP"},{"location":"_autogen/Files/map__fold_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/map__fold_8hpp/#define-batteries_seq_map_fold_hpp","title":"define BATTERIES_SEQ_MAP_FOLD_HPP","text":"<pre><code>#define BATTERIES_SEQ_MAP_FOLD_HPP()\n</code></pre>"},{"location":"_autogen/Files/map__fold_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_MAP_FOLD_HPP\n#define BATTERIES_SEQ_MAP_FOLD_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map_fold(state, map_fn)\n//\n//  map_fn: (state, item) -&gt; tuple&lt;state, mapped_item&gt;\n//\n// seq | map_fold(...): Seq&lt;mapped_item&gt;\n//\n// Threads a state variable through a map operation, so that each invocation\n// of the map function sees the folded state from previous items.\n//\ntemplate &lt;typename Seq, typename State, typename MapFn&gt;\nclass MapFold\n{\npublic:\nusing Item = std::tuple_element_t&lt;1, std::invoke_result_t&lt;MapFn, State, SeqItem&lt;Seq&gt;&gt;&gt;;\nexplicit MapFold(Seq&amp;&amp; seq, State&amp;&amp; state, MapFn&amp;&amp; map_fn) noexcept\n: seq_(BATT_FORWARD(seq))\n, state_(BATT_FORWARD(state))\n, map_fn_(BATT_FORWARD(map_fn))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nauto tr = seq_.peek().map([&amp;](auto&amp;&amp; item) {\nreturn map_fn_(state_, BATT_FORWARD(item));\n});\nif (!tr) {\nreturn None;\n}\n// Don't update state if we are just peeking.\nreturn {std::get&lt;1&gt;(std::move(*tr))};\n}\nOptional&lt;Item&gt; next()\n{\nauto tr = seq_.next().map([&amp;](auto&amp;&amp; item) {\nreturn map_fn_(state_, BATT_FORWARD(item));\n});\nif (!tr) {\nreturn None;\n}\n// Update state.\nstate_ = std::get&lt;0&gt;(std::move(*tr));\nreturn {std::get&lt;1&gt;(std::move(*tr))};\n}\nprivate:\nSeq seq_;\nState state_;\nMapFn map_fn_;\n};\ntemplate &lt;typename State, typename MapFn&gt;\nstruct MapFoldBinder {\nState state;\nMapFn map_fn;\n};\ntemplate &lt;typename State, typename MapFn&gt;\nMapFoldBinder&lt;State, MapFn&gt; map_fold(State&amp;&amp; state, MapFn&amp;&amp; map_fn)\n{\nreturn {BATT_FORWARD(state), BATT_FORWARD(map_fn)};\n}\ntemplate &lt;typename Seq, typename State, typename MapFn&gt;\n[[nodiscard]] MapFold&lt;Seq, State, MapFn&gt; operator|(Seq&amp;&amp; seq, MapFoldBinder&lt;State, MapFn&gt;&amp;&amp; binder)\n{\nreturn MapFold&lt;Seq, State, MapFn&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.state),\nBATT_FORWARD(binder.map_fn)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_MAP_FOLD_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/map__pairwise_8hpp/","title":"batteries/seq/map_pairwise.hpp","text":""},{"location":"_autogen/Files/map__pairwise_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/map__pairwise_8hpp/#classes","title":"Classes","text":"Name class batt::seq::MapPairwise struct batt::seq::MapPairwiseBinder"},{"location":"_autogen/Files/map__pairwise_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_MAP_PAIRWISE_HPP"},{"location":"_autogen/Files/map__pairwise_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/map__pairwise_8hpp/#define-batteries_seq_map_pairwise_hpp","title":"define BATTERIES_SEQ_MAP_PAIRWISE_HPP","text":"<pre><code>#define BATTERIES_SEQ_MAP_PAIRWISE_HPP()\n</code></pre>"},{"location":"_autogen/Files/map__pairwise_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_MAP_PAIRWISE_HPP\n#define BATTERIES_SEQ_MAP_PAIRWISE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// map_pairwise\n//  Given: seqA = {a0, a1, a2, ...}, seqB = {b0, b1, b2, ...}, fn = (A, B) -&gt; T\n//  Produce: {fn(a0, b0), fn(a1, b1), fn(a2, b2), ...}\n//\ntemplate &lt;typename LeftSeq, typename RightSeq, typename MapFn&gt;\nclass MapPairwise\n{\npublic:\nusing Item = std::invoke_result_t&lt;MapFn, SeqItem&lt;LeftSeq&gt;, SeqItem&lt;RightSeq&gt;&gt;;\nexplicit MapPairwise(LeftSeq&amp;&amp; left, RightSeq&amp;&amp; right, MapFn&amp;&amp; map_fn) noexcept\n: left_(BATT_FORWARD(left))\n, right_(BATT_FORWARD(right))\n, map_fn_(BATT_FORWARD(map_fn))\n{\n}\nMapPairwise(MapPairwise&amp;&amp; that) noexcept\n: left_(BATT_FORWARD(that.left_))\n, right_(BATT_FORWARD(that.right_))\n, map_fn_(BATT_FORWARD(*that.map_fn_))\n{\n}\nMapPairwise(const MapPairwise&amp; that) : left_(that.left_), right_(that.right_), map_fn_(*that.map_fn_)\n{\n}\nMapPairwise&amp; operator=(MapPairwise&amp;&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;left_ = BATT_FORWARD(that.left_);\nthis-&gt;right_ = BATT_FORWARD(that.right_);\nthis-&gt;map_fn_.emplace(BATT_FORWARD(*that.map_fn_));\n}\nreturn *this;\n}\nMapPairwise&amp; operator=(const MapPairwise&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;left_ = that.left_;\nthis-&gt;right_ = that.right_;\nthis-&gt;map_fn_.emplace(*that.map_fn_);\n}\nreturn *this;\n}\nOptional&lt;Item&gt; peek()\n{\nreturn left_.peek().flat_map([this](auto&amp;&amp; left_item) {\nreturn right_.peek().map([this, &amp;left_item](auto&amp;&amp; right_item) {\nreturn (*map_fn_)(BATT_FORWARD(left_item), BATT_FORWARD(right_item));\n});\n});\n}\nOptional&lt;Item&gt; next()\n{\nreturn left_.next().flat_map([this](auto&amp;&amp; left_item) {\nreturn right_.next().map([this, &amp;left_item](auto&amp;&amp; right_item) {\nreturn (*map_fn_)(BATT_FORWARD(left_item), BATT_FORWARD(right_item));\n});\n});\n}\nprivate:\nLeftSeq left_;\nRightSeq right_;\nOptional&lt;MapFn&gt; map_fn_;\n};\ntemplate &lt;typename RightSeq, typename MapFn&gt;\nstruct MapPairwiseBinder {\nRightSeq right;\nMapFn map_fn;\n};\ntemplate &lt;typename RightSeq, typename MapFn&gt;\nMapPairwiseBinder&lt;RightSeq, MapFn&gt; map_pairwise(RightSeq&amp;&amp; right, MapFn&amp;&amp; map_fn)\n{\nreturn {BATT_FORWARD(right), BATT_FORWARD(map_fn)};\n}\ntemplate &lt;typename LeftSeq, typename RightSeq, typename MapFn&gt;\n[[nodiscard]] MapPairwise&lt;LeftSeq, RightSeq, MapFn&gt; operator|(LeftSeq&amp;&amp; left,\nMapPairwiseBinder&lt;RightSeq, MapFn&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;LeftSeq, std::decay_t&lt;LeftSeq&gt;&gt;,\n\"Mapped sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;RightSeq, std::decay_t&lt;RightSeq&gt;&gt;,\n\"Mapped sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;MapFn, std::decay_t&lt;MapFn&gt;&gt;,\n\"Mapping functions may not be captured implicitly by reference.\");\nreturn MapPairwise&lt;LeftSeq, RightSeq, MapFn&gt;{BATT_FORWARD(left), BATT_FORWARD(binder.right),\nBATT_FORWARD(binder.map_fn)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_MAP_PAIRWISE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/math_8hpp/","title":"batteries/math.hpp","text":""},{"location":"_autogen/Files/math_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/math_8hpp/#defines","title":"Defines","text":"Name BATTERIES_MATH_HPP"},{"location":"_autogen/Files/math_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/math_8hpp/#define-batteries_math_hpp","title":"define BATTERIES_MATH_HPP","text":"<pre><code>#define BATTERIES_MATH_HPP()\n</code></pre>"},{"location":"_autogen/Files/math_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_MATH_HPP\n#define BATTERIES_MATH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;type_traits&gt;\n#ifdef _MSC_VER\n#include &lt;intrin.h&gt;\n#define __builtin_clzll _lzcnt_u64\n#define __builtin_ctzll _tzcnt_u64\n#define __builtin_popcountll __popcnt64\n#endif\nnamespace batt {\ninline constexpr i32 log2_ceil(u64 i)\n{\nreturn (i &lt;= 1) ? 0 : (64 - (i32)__builtin_clzll(i - 1));\n}\ninline constexpr i32 log2_floor(u64 i)\n{\nreturn (i == 0) ? 0 : (63 - (i32)__builtin_clzll(i));\n}\ntemplate &lt;typename IntT&gt;\ninline constexpr IntT lsb_mask(i32 bits)\n{\nreturn ((IntT{1} &lt;&lt; bits) - 1);\n}\ntemplate &lt;typename IntT&gt;\ninline constexpr IntT round_down_bits(i32 bits, IntT n)\n{\nreturn n &amp; ~lsb_mask&lt;IntT&gt;(bits);\n}\ntemplate &lt;typename IntT&gt;\ninline constexpr IntT round_up_bits(i32 bits, IntT n)\n{\nreturn round_down_bits(bits, n + lsb_mask&lt;IntT&gt;(bits));\n}\ntemplate &lt;typename IntT&gt;\ninline constexpr IntT round_down_to(IntT unit, IntT n)\n{\nreturn n - (n % unit);\n}\ntemplate &lt;typename IntT&gt;\ninline constexpr IntT round_up_to(IntT unit, IntT n)\n{\nreturn round_down_to(unit, n + (unit - 1));\n}\ntemplate &lt;typename IntT&gt;\ninline constexpr IntT ipow(IntT base, IntT exponent, IntT accumulator = static_cast&lt;IntT&gt;(1))\n{\nstatic_assert(std::is_integral_v&lt;IntT&gt;, \"batt::ipow may only be used with integral types.\");\nreturn (exponent &gt; 0) ? ipow(base, exponent - 1, accumulator * base) : accumulator;\n}\ninline i32 bit_count(u64 n)\n{\nreturn __builtin_popcountll(n);\n}\n}  // namespace batt\n#endif  // BATTERIES_MATH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/mcs__lock_8hpp/","title":"batteries/async/mcs_lock.hpp","text":""},{"location":"_autogen/Files/mcs__lock_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/mcs__lock_8hpp/#classes","title":"Classes","text":"Name class batt::BasicMCSMutex A fair mutual exclusion lock based on the MCS lock algorithm. struct batt::BasicMCSMutex::Metrics Metric counters for measuring behavior of MCSMutex locks. class batt::BasicMCSMutex::Lock"},{"location":"_autogen/Files/mcs__lock_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_MCS_LOCK_HPP"},{"location":"_autogen/Files/mcs__lock_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/mcs__lock_8hpp/#define-batteries_async_mcs_lock_hpp","title":"define BATTERIES_ASYNC_MCS_LOCK_HPP","text":"<pre><code>#define BATTERIES_ASYNC_MCS_LOCK_HPP()\n</code></pre>"},{"location":"_autogen/Files/mcs__lock_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_MCS_LOCK_HPP\n#define BATTERIES_ASYNC_MCS_LOCK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/futex.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;functional&gt;\nnamespace batt {\ntemplate &lt;bool kMetricsEnabled&gt;\nclass BasicMCSMutex;\nusing MCSMutex = BasicMCSMutex&lt;false&gt;;\ntemplate &lt;bool kMetricsEnabled = true&gt;\nclass BasicMCSMutex\n{\npublic:\nstruct Metrics {\nusize acquire_count = 0;\nusize fast_acquire_count = 0;\nusize spin_acquire_count = 0;\nusize wait_acquire_count = 0;\nusize init_acquire_spin_count = 0;\nusize wait_acquire_spin_count = 0;\nusize wait_acquire_futex_count = 0;\nusize release_count = 0;\nusize fast_release_count = 0;\nusize direct_release_count = 0;\nusize spin_release_count = 0;\nusize wait_next_spin_count = 0;\nvoid reset() noexcept\n{\nstd::memset(this, 0, sizeof(Metrics));\n}\nMetrics&amp; operator+=(const Metrics&amp; other) noexcept\n{\nthis-&gt;acquire_count += other.acquire_count;\nthis-&gt;fast_acquire_count += other.fast_acquire_count;\nthis-&gt;spin_acquire_count += other.spin_acquire_count;\nthis-&gt;wait_acquire_count += other.wait_acquire_count;\nthis-&gt;init_acquire_spin_count += other.init_acquire_spin_count;\nthis-&gt;wait_acquire_futex_count += other.wait_acquire_futex_count;\nthis-&gt;release_count += other.release_count;\nthis-&gt;fast_release_count += other.fast_release_count;\nthis-&gt;direct_release_count += other.direct_release_count;\nthis-&gt;spin_release_count += other.spin_release_count;\nthis-&gt;wait_next_spin_count += other.wait_next_spin_count;\nreturn *this;\n}\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic Metrics&amp; metrics()\n{\nthread_local Metrics m;\nreturn m;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nclass Lock\n{\npublic:\nstatic constexpr usize kAcquireSpinCyclesInit = 2048;\nstatic constexpr usize kAcquireSpinCyclesSteady = 8;\nexplicit Lock(BasicMCSMutex&amp; mutex) noexcept : mutex_{mutex}\n{\nthis-&gt;lock_impl();\n}\nexplicit Lock(BasicMCSMutex&amp; mutex, std::defer_lock_t) noexcept : mutex_{mutex}\n{\n}\n~Lock() noexcept\n{\nif (this-&gt;owns_lock()) {\nthis-&gt;unlock_impl();\n}\n}\n//----- --- -- -  -  -   -\nLock(const Lock&amp;) = delete;\nLock&amp; operator=(const Lock&amp;) = delete;\n//----- --- -- -  -  -   -\nbool owns_lock() const noexcept\n{\nreturn this-&gt;waiting_to_acquire_-&gt;load() == 0;\n}\nvoid lock() noexcept\n{\nBATT_CHECK_EQ(this-&gt;waiting_to_acquire_-&gt;load(), 1u)\n&lt;&lt; \"attempt to lock() while already holding the mutex or after having unlocked it (Locks can \"\n\"only be re-acquired after calling reset())\";\nthis-&gt;lock_impl();\n}\nvoid unlock() noexcept\n{\nBATT_CHECK_EQ(this-&gt;waiting_to_acquire_-&gt;load(), 0u)\n&lt;&lt; \"unlock() called without owning a lock on the mutex!\";\nthis-&gt;waiting_to_acquire_-&gt;store(2);\nthis-&gt;unlock_impl();\n}\nbool needs_reset() const noexcept\n{\nreturn this-&gt;waiting_to_acquire_-&gt;load() == 2;\n}\nvoid reset() noexcept\n{\nBATT_CHECK_EQ(this-&gt;waiting_to_acquire_-&gt;load(), 2u)\n&lt;&lt; \"reset() called while needs_reset() is false\";\nthis-&gt;next_-&gt;store(nullptr);\nthis-&gt;waiting_to_acquire_-&gt;store(1);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\n// See https://dl.acm.org/doi/pdf/10.1145/106973.106999\n//\n// \"Synchronization without Contention\" 1991, ACM\n//  by John M. Mellor-Crummey &amp; Michael L. Scott\n//\nvoid lock_impl() noexcept\n{\nif (kMetricsEnabled) {\n++metrics().acquire_count;\n}\n{\nLock* const prev = this-&gt;mutex_.lock_-&gt;exchange(this);\nif (prev == nullptr) {\n// Fast path; we acquired the lock with no contention; return!\n//\nif (kMetricsEnabled) {\n++metrics().fast_acquire_count;\n}\nthis-&gt;waiting_to_acquire_-&gt;store(0);\nreturn;\n}\nBATT_CHECK_NE(prev, this) &lt;&lt; \"recursive call to lock()!\";\n// Let the current end-of-queue know about us.\n//\nprev-&gt;next_-&gt;store(this);\n}\n// The lock is held by some other task; we must spin to acquire.\n//\nfor (usize i = 0; i &lt; kAcquireSpinCyclesInit; ++i) {\nif (kMetricsEnabled) {\n++metrics().init_acquire_spin_count;\n}\nif (this-&gt;waiting_to_acquire_-&gt;load() == 0) {\nif (kMetricsEnabled) {\n++metrics().spin_acquire_count;\n}\ngoto have_lock;\n}\n//----- --- -- -  -  -   -\nspin_yield();\n//----- --- -- -  -  -   -\n}\n// We have exceeded the maximum allowed spin cycles; enter the Futex-wait loop.\n//\nfor (;;) {\nif (kMetricsEnabled) {\n++metrics().wait_acquire_futex_count;\n}\n// Wait on the Futex.\n//\nconst int retval = futex_wait(this-&gt;waiting_to_acquire_.get(), /*last_seen=*/1);\nif (retval != 0 &amp;&amp; errno != EAGAIN) {\nBATT_PANIC() &lt;&lt; BATT_INSPECT(retval) &lt;&lt; BATT_INSPECT(errno)\n&lt;&lt; \" The MAN page says this should not happen!\";\n}\n// Now that the futex has been signaled, we spin for the configured limit before doing\n// another Futex wait.\n//\nfor (usize i = 0; i &lt; kAcquireSpinCyclesSteady; ++i) {\nif (kMetricsEnabled) {\n++metrics().wait_acquire_spin_count;\n}\nif (this-&gt;waiting_to_acquire_-&gt;load() == 0) {\nif (kMetricsEnabled) {\n++metrics().wait_acquire_count;\n}\ngoto have_lock;\n}\n//----- --- -- -  -  -   -\nspin_yield();\n//----- --- -- -  -  -   -\n}\n}\n// Lock acquired!  We are done.\n//\nhave_lock:;\n}\nvoid unlock_impl() noexcept\n{\nif (kMetricsEnabled) {\n++metrics().release_count;\n}\nLock* observed_next = this-&gt;next_-&gt;load();\n//  If our next pointer is null, then assume we are the last in the queue, which means\n//  mutex_.lock_ should still point to us.  CAS to release the lock under this assumption.\n//\nif (observed_next == nullptr) {\n{\nLock* presumed_holder = this;\ndo {\nif (this-&gt;mutex_.lock_-&gt;compare_exchange_weak(presumed_holder, nullptr)) {\nif (kMetricsEnabled) {\n++metrics().fast_release_count;\n}\nreturn;\n}\n} while (presumed_holder == this);\n}\n// We failed to replace ourselves with nullptr at the end of the queue, which means there must\n// be another lock who came afterwards; since we observed our `next_` to be nullptr above, we\n// must spin-wait until our successor runs the `prev-&gt;next_.store(this)` statement in the\n// ctor.\n//\nfor (;;) {\nif (kMetricsEnabled) {\n++metrics().wait_next_spin_count;\n}\nobserved_next = this-&gt;next_-&gt;load();\nif (observed_next != nullptr) {\nif (kMetricsEnabled) {\n++metrics().spin_release_count;\n}\nbreak;\n}\n//----- --- -- -  -  -   -\nspin_yield();\n//----- --- -- -  -  -   -\n}\n} else {\nif (kMetricsEnabled) {\n++metrics().direct_release_count;\n}\n}\n// Signal to the next-in-queue that the lock is now free!\n//\n//  IMPORTANT: we must not touch `this` from this point on!\n//\nobserved_next-&gt;waiting_to_acquire_-&gt;store(0);\nfutex_notify(observed_next-&gt;waiting_to_acquire_.get());\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nBasicMCSMutex&amp; mutex_;\nbatt::CpuCacheLineIsolated&lt;std::atomic&lt;Lock*&gt;&gt; next_{nullptr};\nbatt::CpuCacheLineIsolated&lt;std::atomic&lt;u32&gt;&gt; waiting_to_acquire_{1};\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nBasicMCSMutex() = default;\nBasicMCSMutex(const BasicMCSMutex&amp;) = delete;\nBasicMCSMutex&amp; operator=(const BasicMCSMutex&amp;) = delete;\nbool is_locked() const noexcept\n{\nreturn *this-&gt;lock_ != nullptr;\n}\nprivate:\nbatt::CpuCacheLineIsolated&lt;std::atomic&lt;Lock*&gt;&gt; lock_{nullptr};\n};\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_MCS_LOCK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/merge__by_8hpp/","title":"batteries/seq/merge_by.hpp","text":""},{"location":"_autogen/Files/merge__by_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/merge__by_8hpp/#classes","title":"Classes","text":"Name class batt::seq::MergeBy struct batt::seq::MergeByBinder"},{"location":"_autogen/Files/merge__by_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_MERGE_BY_HPP"},{"location":"_autogen/Files/merge__by_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/merge__by_8hpp/#define-batteries_seq_merge_by_hpp","title":"define BATTERIES_SEQ_MERGE_BY_HPP","text":"<pre><code>#define BATTERIES_SEQ_MERGE_BY_HPP()\n</code></pre>"},{"location":"_autogen/Files/merge__by_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_MERGE_BY_HPP\n#define BATTERIES_SEQ_MERGE_BY_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/seq/emplace_back.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/natural_order.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// merge/merge_by\n//\ntemplate &lt;typename LeftSeq, typename RightSeq, typename Compare&gt;\nclass MergeBy\n{\npublic:\n// If merging two sequences of the same type, just use that; otherwise\n// produce a variant of the two types.\n//\nusing Item = std::conditional_t&lt;\n/* if */ std::is_same_v&lt;SeqItem&lt;LeftSeq&gt;, SeqItem&lt;RightSeq&gt;&gt;,\n/* then */ SeqItem&lt;LeftSeq&gt;,\n/* else */\nstd::conditional_t&lt;\n/* if */ std::is_same_v&lt;std::decay_t&lt;SeqItem&lt;LeftSeq&gt;&gt;, std::decay_t&lt;SeqItem&lt;RightSeq&gt;&gt;&gt;,\n/* then */ std::decay_t&lt;SeqItem&lt;LeftSeq&gt;&gt;,\n// TODO [tastolfi 2020-09-28] fix it so we can have refs\n/* else */ std::variant&lt;std::decay_t&lt;SeqItem&lt;LeftSeq&gt;&gt;, std::decay_t&lt;SeqItem&lt;RightSeq&gt;&gt;&gt;&gt;&gt;;\nexplicit MergeBy(LeftSeq&amp;&amp; left, RightSeq&amp;&amp; right, Compare&amp;&amp; compare) noexcept\n: left_(BATT_FORWARD(left))\n, right_(BATT_FORWARD(right))\n, compare_(BATT_FORWARD(compare))\n{\n}\nMergeBy(MergeBy&amp;&amp; that) noexcept\n: left_(BATT_FORWARD(that.left_))\n, right_(BATT_FORWARD(that.right_))\n, compare_(BATT_FORWARD(*that.compare_))\n{\n}\nMergeBy&amp; operator=(MergeBy&amp;&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nleft_ = BATT_FORWARD(that.left_);\nright_ = BATT_FORWARD(that.right_);\ncompare_.emplace(BATT_FORWARD(*that.compare_));\n}\nreturn *this;\n}\nMergeBy(const MergeBy&amp; that) : left_(that.left_), right_(that.right_), compare_(*that.compare_)\n{\n}\nMergeBy&amp; operator=(const MergeBy&amp; that)\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nleft_ = that.left_;\nright_ = that.right_;\ncompare_.emplace(*that.compare_);\n}\nreturn *this;\n}\nOptional&lt;Item&gt; peek()\n{\nreturn impl(/*consume=*/false);\n}\nOptional&lt;Item&gt; next()\n{\nreturn impl(/*consume=*/true);\n}\n//--------------------------\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename LeftSeq_, typename RightSeq_, typename Compare_, typename EachFn&gt;\nfriend LoopControl operator|(MergeBy&lt;LeftSeq_, RightSeq_, Compare_&gt;&amp;&amp; merge_seq,\nForEachBinder&lt;EachFn&gt;&amp;&amp; binder);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nstruct ToItem {\ntemplate &lt;typename T, typename = std::enable_if_t&lt;!std::is_same_v&lt;Item, T&amp;&amp;&gt;&gt;&gt;\nItem operator()(T&amp;&amp; item) const\n{\nreturn Item{BATT_FORWARD(item)};\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;Item, T&amp;&amp;&gt;&gt;, typename = void&gt;\nItem operator()(T&amp;&amp; item) const\n{\nreturn item;\n}\n};\nOptional&lt;Item&gt; impl(bool consume)\n{\nauto l = left_.peek();\nauto r = right_.peek();\nif (l) {\nif (r) {\nif ((*compare_)(*r, *l)) {\nif (consume) {\nreturn right_.next().map(ToItem{});\n}\nreturn r.map(ToItem{});\n} else {\nif (consume) {\nreturn left_.next().map(ToItem{});\n}\nreturn l.map(ToItem{});\n}\n} else {\nif (consume) {\nreturn left_.next().map(ToItem{});\n}\nreturn l.map(ToItem{});\n}\n} else {\nif (r) {\nif (consume) {\nreturn right_.next().map(ToItem{});\n}\nreturn r.map(ToItem{});\n} else {\nreturn None;\n}\n}\n}\nLeftSeq left_;\nRightSeq right_;\nOptional&lt;Compare&gt; compare_;\n};\ntemplate &lt;typename RightSeq, typename Compare&gt;\nstruct MergeByBinder {\nRightSeq right;\nCompare compare;\n};\ntemplate &lt;typename Compare, typename RightSeq&gt;\nMergeByBinder&lt;RightSeq, Compare&gt; merge_by(Compare&amp;&amp; compare, RightSeq&amp;&amp; right)\n{\nreturn {BATT_FORWARD(right), BATT_FORWARD(compare)};\n}\ntemplate &lt;typename RightSeq&gt;\nauto merge(RightSeq&amp;&amp; right)\n{\nreturn merge_by(NaturalOrder{}, BATT_FORWARD(right));\n}\ntemplate &lt;typename LeftSeq, typename RightSeq, typename Compare&gt;\n[[nodiscard]] MergeBy&lt;LeftSeq, RightSeq, Compare&gt; operator|(LeftSeq&amp;&amp; left,\nMergeByBinder&lt;RightSeq, Compare&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;LeftSeq, std::decay_t&lt;LeftSeq&gt;&gt;,\n\"Merged sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;RightSeq, std::decay_t&lt;RightSeq&gt;&gt;,\n\"Merged sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;Compare, std::decay_t&lt;Compare&gt;&gt;,\n\"Comparison functions may not be captured implicitly by reference.\");\nreturn MergeBy&lt;LeftSeq, RightSeq, Compare&gt;{BATT_FORWARD(left), BATT_FORWARD(binder.right),\nBATT_FORWARD(binder.compare)};\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename LeftSeq, typename RightSeq, typename Compare, typename EachFn&gt;\nLoopControl operator|(MergeBy&lt;LeftSeq, RightSeq, Compare&gt;&amp;&amp; merge_seq, ForEachBinder&lt;EachFn&gt;&amp;&amp; binder)\n{\nusing LeftItem = std::decay_t&lt;SeqItem&lt;LeftSeq&gt;&gt;;\nSmallVec&lt;LeftItem, 4096 / sizeof(LeftItem)&gt; left_items_cached;\nstd::forward&lt;LeftSeq&gt;(merge_seq.left_) | emplace_back(&amp;left_items_cached);\nauto* left_next = left_items_cached.data();\nauto* left_end = left_items_cached.data() + left_items_cached.size();\nauto&amp; compare = *merge_seq.compare_;\nauto loop_body = [&amp;](auto&amp;&amp; right_item) -&gt; LoopControl {\nwhile (left_next != left_end &amp;&amp; !compare(right_item, *left_next)) {\nif (BATT_HINT_FALSE(run_loop_fn(binder.fn, *left_next) == kBreak)) {\nreturn kBreak;\n}\n++left_next;\n}\nreturn run_loop_fn(binder.fn, right_item);\n};\nLoopControl control = std::forward&lt;RightSeq&gt;(merge_seq.right_) | for_each(loop_body);\nif (BATT_HINT_FALSE(control == kBreak)) {\nreturn kBreak;\n}\nwhile (left_next != left_end) {\nif (BATT_HINT_FALSE(run_loop_fn(binder.fn, *left_next) == kBreak)) {\nreturn kBreak;\n}\n++left_next;\n}\nreturn kContinue;\n}\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_MERGE_BY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__collectors_8hpp/","title":"batteries/metrics/metric_collectors.hpp","text":""},{"location":"_autogen/Files/metric__collectors_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__collectors_8hpp/#classes","title":"Classes","text":"Name class batt::CountMetric class batt::LatencyMetric class batt::LatencyTimer class batt::RateMetric class batt::GaugeMetric A Metric collector that stores and reports a single instantaneous value. class batt::StatsMetric Collect count, total, max and min values for multiple samples. class batt::HistogramMetric Collect histogram values for multiple samples. struct batt::HistogramMetric::Bucket Represents a single histogram bucket for reporting."},{"location":"_autogen/Files/metric__collectors_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_COLLECTORS_HPP BATT_COLLECT_LATENCY(metric, expr) BATT_COLLECT_LATENCY_N(metric, expr, count_delta)"},{"location":"_autogen/Files/metric__collectors_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__collectors_8hpp/#define-batteries_metrics_metric_collectors_hpp","title":"define BATTERIES_METRICS_METRIC_COLLECTORS_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_COLLECTORS_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__collectors_8hpp/#define-batt_collect_latency","title":"define BATT_COLLECT_LATENCY","text":"<pre><code>#define BATT_COLLECT_LATENCY(metric, expr)\n</code></pre>"},{"location":"_autogen/Files/metric__collectors_8hpp/#define-batt_collect_latency_n","title":"define BATT_COLLECT_LATENCY_N","text":"<pre><code>#define BATT_COLLECT_LATENCY_N(metric, expr, count_delta)\n</code></pre>"},{"location":"_autogen/Files/metric__collectors_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi, Eitan Steiner\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_COLLECTORS_HPP\n#define BATTERIES_METRICS_METRIC_COLLECTORS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;ostream&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass CountMetric\n{\npublic:\nCountMetric() = default;\n/*implicit*/ CountMetric(T init_val) noexcept : value_{init_val}\n{\n}\nvoid set(T value)\n{\nthis-&gt;value_.store(value, std::memory_order_relaxed);\n}\ntemplate &lt;typename D&gt;\nvoid add(D delta)\n{\nthis-&gt;value_.fetch_add(delta, std::memory_order_relaxed);\n}\ntemplate &lt;typename D&gt;\ndecltype(auto) fetch_add(D delta)\n{\nreturn this-&gt;value_.fetch_add(delta, std::memory_order_relaxed);\n}\noperator T() const\n{\nreturn this-&gt;value_;\n}\ndecltype(auto) operator++(int)\n{\nreturn this-&gt;value_++;\n}\ndecltype(auto) operator++()\n{\nreturn ++this-&gt;value_;\n}\ntemplate &lt;typename D&gt;\ndecltype(auto) operator+=(D delta)\n{\nreturn this-&gt;value_ += delta;\n}\nT load() const\n{\nreturn value_.load(std::memory_order_relaxed);\n}\nvoid reset()\n{\nthis-&gt;value_.store(0, std::memory_order_relaxed);\n}\nvoid clamp_min(T lower_bound)\n{\nT observed = this-&gt;value_.load();\nwhile (observed &lt; lower_bound) {\nif (value_.compare_exchange_weak(observed, lower_bound)) {\nbreak;\n}\n}\n}\nvoid clamp_max(T upper_bound)\n{\nT observed = this-&gt;value_.load();\nwhile (observed &gt; upper_bound) {\nif (value_.compare_exchange_weak(observed, upper_bound)) {\nbreak;\n}\n}\n}\nprivate:\nstd::atomic&lt;T&gt; value_{0};\n};\nclass LatencyMetric\n{\npublic:\nvoid update(std::chrono::steady_clock::time_point start, u64 count_delta = 1)\n{\nreturn this-&gt;update(std::chrono::steady_clock::now() - start, count_delta);\n}\nvoid update(std::chrono::steady_clock::duration elapsed_duration, u64 count_delta = 1)\n{\nconst i64 elapsed_usec =\nstd::max&lt;i64&gt;(0, std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed_duration).count());\nthis-&gt;total_usec.add(elapsed_usec);\nthis-&gt;count.add(count_delta);\n}\n// Count per second.\n//\ndouble rate_per_second() const\n{\nreturn double(count) / double(total_usec) * 1000.0 * 1000.0;\n}\nvoid reset()\n{\nthis-&gt;total_usec.reset();\nthis-&gt;count.reset();\n}\nCountMetric&lt;u64&gt; total_usec{0};\nCountMetric&lt;u64&gt; count{0};\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const LatencyMetric&amp; t)\n{\n//  return out &lt;&lt; t.total_usec &lt;&lt; \"/\" &lt;&lt; t.count &lt;&lt; \"(avg=\" &lt;&lt; ((double)t.total_usec /\n//  (double)(t.count + 1))\n//         &lt;&lt; \"usec)\";\nreturn out &lt;&lt; ((double)t.total_usec / (double)(t.count + 1)) &lt;&lt; \"us(n=\" &lt;&lt; t.count &lt;&lt; \")\";\n}\nclass LatencyTimer\n{\npublic:\nLatencyTimer(const LatencyTimer&amp;) = delete;\nLatencyTimer&amp; operator=(const LatencyTimer&amp;) = delete;\nexplicit LatencyTimer(LatencyMetric&amp; counter, u64 delta = 1) noexcept : metric_{&amp;counter}, delta_{delta}\n{\n}\n~LatencyTimer() noexcept\n{\nthis-&gt;stop();\n}\ni64 read_usec() const\n{\nreturn std::max&lt;i64&gt;(0, std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(\nstd::chrono::steady_clock::now() - this-&gt;start_)\n.count());\n}\nvoid stop() noexcept\n{\nif (this-&gt;metric_) {\nthis-&gt;metric_-&gt;update(this-&gt;start_, this-&gt;delta_);\nthis-&gt;metric_ = nullptr;\n}\n}\nprivate:\nLatencyMetric* metric_;\nconst u64 delta_;\nconst std::chrono::steady_clock::time_point start_ = std::chrono::steady_clock::now();\n};\n#define BATT_COLLECT_LATENCY(metric, expr)                                                                   \\\n    [&amp;] {                                                                                                    \\\n        ::batt::LatencyTimer ANONYMOUS_latency_timer_{(metric)};                                             \\\n        return expr;                                                                                         \\\n    }()\n#define BATT_COLLECT_LATENCY_N(metric, expr, count_delta)                                                    \\\n    [&amp;] {                                                                                                    \\\n        ::batt::LatencyTimer ANONYMOUS_latency_timer_{(metric), (count_delta)};                              \\\n        return expr;                                                                                         \\\n    }()\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T&gt;\nusing DerivedMetric = std::function&lt;T()&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T, i64 kDefaultIntervalSec = 2&gt;\nclass RateMetric\n{\npublic:\nusing Self = RateMetric;\nstatic constexpr i64 kDefaultIntervalUsec = kDefaultIntervalSec * 1000 * 1000;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic const auto&amp; base_time() noexcept\n{\nstatic const auto base_time_ = std::chrono::steady_clock::now();\nreturn base_time_;\n}\nstatic i64 now_usec() noexcept\n{\nreturn std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::steady_clock::now() -\nSelf::base_time())\n.count();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit RateMetric() noexcept : interval_usec_{Self::kDefaultIntervalUsec}\n{\n}\nexplicit RateMetric(double default_interval_sec) noexcept\n: interval_usec_{static_cast&lt;i64&gt;(default_interval_sec * 1000.0 * 1000.0)}\n{\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ni64 elapsed_usec() const noexcept\n{\nreturn Self::now_usec() - this-&gt;start_time_;\n}\ndouble elapsed_sec() const noexcept\n{\nreturn static_cast&lt;double&gt;(this-&gt;elapsed_usec) / (1000.0 * 1000.0);\n}\nvoid update(T value) noexcept\n{\nthis-&gt;current_value_.store(value);\nconst i64 local_elapsed_usec = this-&gt;elapsed_usec();\nif (local_elapsed_usec &gt;= this-&gt;interval_usec_) {\nthis-&gt;start_time_.fetch_add(local_elapsed_usec / 2);\nthis-&gt;start_value_.store((value + this-&gt;start_value_.load()) / 2);\n}\n}\ndouble get() const noexcept\n{\nreturn static_cast&lt;double&gt;(this-&gt;current_value_ - this-&gt;start_value_) * 1000000.0 /\nstatic_cast&lt;double&gt;(this-&gt;elapsed_usec());\n}\nprivate:\nconst i64 interval_usec_;\nstd::atomic&lt;i64&gt; start_time_{Self::now_usec()};\nstd::atomic&lt;T&gt; start_value_{0};\nstd::atomic&lt;T&gt; current_value_;\n};\ntemplate &lt;typename T&gt;\nclass GaugeMetric\n{\npublic:\nGaugeMetric() = default;\ntemplate &lt;typename D&gt;\nvoid set(D sample) noexcept\n{\nthis-&gt;value_.store(sample, std::memory_order_relaxed);\n}\nT load() const noexcept\n{\nreturn this-&gt;value_.load(std::memory_order_relaxed);\n}\nprivate:\nstd::atomic&lt;T&gt; value_{0};\n};\ntemplate &lt;typename T&gt;\nclass StatsMetric\n{\npublic:\nStatsMetric() = default;\nexplicit StatsMetric(T init_val) noexcept : count_{1}, total_{init_val}, max_{init_val}, min_{init_val}\n{\n}\nvoid reset()\n{\nthis-&gt;count_.reset();\nthis-&gt;total_.reset();\nthis-&gt;max_.set(std::numeric_limits&lt;T&gt;::min());\nthis-&gt;min_.set(std::numeric_limits&lt;T&gt;::max());\n}\ntemplate &lt;typename D&gt;\nvoid update(D sample)\n{\nthis-&gt;count_.fetch_add(1);\nthis-&gt;total_.fetch_add(sample);\nthis-&gt;max_.clamp_min(sample);\nthis-&gt;min_.clamp_max(sample);\n}\nT count() const\n{\nreturn this-&gt;count_.load();\n}\nT total() const\n{\nreturn this-&gt;total_.load();\n}\nT max() const\n{\nreturn this-&gt;max_.load();\n}\nT min() const\n{\nreturn this-&gt;min_.load();\n}\nprivate:\nCountMetric&lt;T&gt; count_{0};\nCountMetric&lt;T&gt; total_{0};\nCountMetric&lt;T&gt; max_{std::numeric_limits&lt;T&gt;::min()};\nCountMetric&lt;T&gt; min_{std::numeric_limits&lt;T&gt;::max()};\nfriend class MetricRegistry;\n};\ntemplate &lt;typename T&gt;\nclass HistogramMetric\n{\npublic:\nstatic constexpr batt::int_types::i64 kMaxNumberOfIntervals = /*-inf...*/ 1 + 16 + /*...+inf*/ 1;\nstruct Bucket {\nBucket() = delete;\nexplicit Bucket(T upper, T count, T total) noexcept : upper{upper}, count{count}, total{total}\n{\n}\nconst T upper;\nconst T count;\nconst T total;\n};\nHistogramMetric() = default;\nHistogramMetric(const HistogramMetric&amp;) = delete;\nHistogramMetric&amp; operator=(const HistogramMetric&amp;) = delete;\nHistogramMetric(const batt::int_types::usize intervals, const T min_val, const T max_val)\n{\nBATT_CHECK(initialize(intervals, min_val, max_val)) &lt;&lt; \"Histogram initialization failed\";\n}\n[[nodiscard]] bool initialize(const batt::int_types::usize intervals, const T min_val, const T max_val)\n{\nstatic_assert(std::is_integral&lt;T&gt;::value);\nthis-&gt;reset();\nif (intervals &lt; 1 || intervals &gt; (kMaxNumberOfIntervals - 2) || min_val &gt;= max_val) {\nreturn false;\n}\nthis-&gt;num_intervals_ = static_cast&lt;T&gt;(intervals);\nthis-&gt;min_val_ = min_val;\nthis-&gt;max_val_ = max_val;\n// Add (divisor - 1) to emulate ceiling function.\nthis-&gt;per_bucket_range_ = (this-&gt;overall_range() + this-&gt;num_intervals_ - 1) / this-&gt;num_intervals_;\nif (this-&gt;num_intervals_ &gt; this-&gt;overall_range()) {\nthis-&gt;reset();\nreturn false;\n}\nreturn true;\n}\nvoid reset()\n{\nthis-&gt;clear();\nthis-&gt;num_intervals_ = 0u;\nthis-&gt;min_val_ = 0;\nthis-&gt;max_val_ = 0;\nthis-&gt;per_bucket_range_ = 0;\n}\nvoid clear()\n{\nfor (auto&amp; bucket : this-&gt;buckets_) {\nbucket.reset();\n}\n}\ninline batt::int_types::usize bucket_index(T sample) const noexcept\n{\nBATT_CHECK_NE(this-&gt;num_intervals_, 0u) &lt;&lt; \"Histogram was not initialized\";\nBATT_CHECK_NE(this-&gt;overall_range(), 0) &lt;&lt; \"Histogram was not initialized\";\nreturn [&amp;] {\nif (BATT_HINT_FALSE(sample &gt; this-&gt;max_val_)) {  // Exceeds max\nreturn this-&gt;num_intervals_ + 1;\n} else if (BATT_HINT_FALSE(sample &lt;= this-&gt;min_val_)) {  // Subceeds min\nreturn 0;\n} else {  // Find index of interval in range. Add (divisor - 1) to emulate ceiling function.\nauto found = (this-&gt;num_intervals_ * (sample - this-&gt;min_val_) + this-&gt;overall_range() - 1) /\nthis-&gt;overall_range();\nif (sample &lt;= this-&gt;upper_bound(found - 1)) {  // Adjust when interval rounded up\n--found;\n}\nreturn found;\n}\n}();\n}\nvoid update(T sample)\n{\nconst auto index = this-&gt;bucket_index(sample);\nif (index &gt;= 0 &amp;&amp; index &lt; this-&gt;num_intervals_ + 2u) {\nthis-&gt;buckets_[index].update(sample);\n}\n}\nstd::vector&lt;HistogramMetric&lt;T&gt;::Bucket&gt; get() const\n{\nstd::vector&lt;HistogramMetric&lt;T&gt;::Bucket&gt; buckets;\nif (this-&gt;num_intervals_ &gt; 0) {\nfor (usize i = 0; i &lt; this-&gt;num_intervals_ + 2u; ++i) {\nbuckets.emplace_back(this-&gt;upper_bound(i), this-&gt;buckets_[i].count(),\nthis-&gt;buckets_[i].total());\n}\n}\nreturn buckets;\n}\nprivate:\nT upper_bound(batt::int_types::usize interval) const noexcept\n{\nBATT_CHECK_NE(this-&gt;num_intervals_, 0u) &lt;&lt; \"Histogram was not initialized\";\nBATT_CHECK_GE(this-&gt;num_intervals_ + 1u, interval) &lt;&lt; \"Histogram interval out of bounds\";\nif (interval == 0) {\nreturn this-&gt;min_val_;\n} else if (interval == this-&gt;num_intervals_ + 1u) {\nreturn std::numeric_limits&lt;T&gt;::max();\n} else {\nconst T upper_bound = this-&gt;min_val_ + this-&gt;per_bucket_range_ * static_cast&lt;T&gt;(interval);\nreturn std::min(upper_bound, this-&gt;max_val_);\n}\n}\ninline T overall_range() const noexcept\n{\nreturn (this-&gt;max_val_ - this-&gt;min_val_);\n}\nT num_intervals_{0};  // T instead of usize to minimize conversion during update-path arithmetic.\nT min_val_{0};\nT max_val_{0};\nT per_bucket_range_{0};  // Cache division result to mitigate repetition during update-path arithmetic.\nstd::array&lt;StatsMetric&lt;T&gt;, kMaxNumberOfIntervals&gt; buckets_{};\nfriend class MetricRegistry;\n};\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_COLLECTORS_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_collectors_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__collectors__impl_8hpp/","title":"batteries/metrics/metric_collectors_impl.hpp","text":""},{"location":"_autogen/Files/metric__collectors__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__csv__formatter_8cpp/","title":"batteries/metrics/metric_csv_formatter.cpp","text":""},{"location":"_autogen/Files/metric__csv__formatter_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_csv_formatter.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_csv_formatter_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/","title":"batteries/metrics/metric_csv_formatter.hpp","text":""},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#classes","title":"Classes","text":"Name class batt::MetricCsvFormatter"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRIC_CSV_FORMATTER_HPP"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#define-batteries_metric_csv_formatter_hpp","title":"define BATTERIES_METRIC_CSV_FORMATTER_HPP","text":"<pre><code>#define BATTERIES_METRIC_CSV_FORMATTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__csv__formatter_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRIC_CSV_FORMATTER_HPP\n#define BATTERIES_METRIC_CSV_FORMATTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;chrono&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nnamespace batt {\nclass MetricCsvFormatter : public MetricFormatter\n{\npublic:\nvoid initialize(MetricRegistry&amp; src, std::ostream&amp; dst) override;\nvoid format_values(MetricRegistry&amp; src, std::ostream&amp; dst) override;\nvoid finished(MetricRegistry&amp; src, std::ostream&amp; dst) override;\nprivate:\n// Additional columns added by this formatter: the metric id and starting time.\n//\nusize id_ = 0;\nstd::chrono::steady_clock::time_point start_time_;\n// Saved column names and positions.\n//\nstd::unordered_map&lt;std::string, usize&gt; index_of_;\n// So we don't have to keep reallocating.\n//\nstd::vector&lt;double&gt; values_;\n};\n}  // namespace batt\n#endif  // BATTERIES_METRIC_CSV_FORMATTER_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_csv_formatter_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/","title":"batteries/metrics/metric_csv_formatter_impl.hpp","text":""},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#define-batteries_metrics_metric_csv_formatter_hpp","title":"define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__csv__formatter__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP\n#define BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_csv_formatter.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wdeprecated-declarations\")\n#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#include &lt;algorithm&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void MetricCsvFormatter::initialize(MetricRegistry&amp; src, std::ostream&amp; dst)\n{\n// Build the schema for dumping metric rows.\n//\nstd::vector&lt;std::string&gt; all_names;\nsrc.read_all([&amp;](std::string_view name, double, const MetricLabelSet&amp; labels) {\nall_names.emplace_back(this-&gt;fully_qualified_name(name, labels));\n});\nstd::sort(all_names.begin(), all_names.end());\ndst &lt;&lt; \"id,time_usec,date_time\";\nfor (usize i = 0; i &lt; all_names.size(); ++i) {\nthis-&gt;index_of_[all_names[i]] = i;\ndst &lt;&lt; \",\" &lt;&lt; all_names[i];\n}\ndst &lt;&lt; \"\\n\";\nthis-&gt;values_.resize(all_names.size());\nthis-&gt;id_ = 0;\nthis-&gt;start_time_ = std::chrono::steady_clock::now();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void MetricCsvFormatter::format_values(MetricRegistry&amp; src, std::ostream&amp; dst)\n{\nthis-&gt;id_ += 1;\nconst double time_usec = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(\nstd::chrono::steady_clock::now() - this-&gt;start_time_)\n.count();\n// Read the registry, reordering the columns according to the schema we built above.\n//\nsrc.read_all([&amp;](std::string_view name, double value, const MetricLabelSet&amp; labels) {\nauto iter = this-&gt;index_of_.find(this-&gt;fully_qualified_name(name, labels));\nif (iter == this-&gt;index_of_.end()) {\nreturn;\n}\nthis-&gt;values_[iter-&gt;second] = value;\n});\n// First dump id and time_usec.\n//\nboost::posix_time::ptime t = boost::posix_time::microsec_clock::universal_time();\ndst &lt;&lt; this-&gt;id_ &lt;&lt; \",\" &lt;&lt; time_usec &lt;&lt; \",\" &lt;&lt; boost::posix_time::to_iso_extended_string(t);\n// Dump metric value columns in order.\n//\nfor (double v : this-&gt;values_) {\ndst &lt;&lt; \",\" &lt;&lt; std::setprecision(10) &lt;&lt; v;\n}\ndst &lt;&lt; \"\\n\";  // NOTE: don't flush (let the caller decide when to)\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void MetricCsvFormatter::finished(MetricRegistry&amp; /*src*/, std::ostream&amp; /*dst*/)\n{\n// Nothing to do for CSV format.\n}\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_CSV_FORMATTER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__dumper_8cpp/","title":"batteries/metrics/metric_dumper.cpp","text":""},{"location":"_autogen/Files/metric__dumper_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_dumper.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_dumper_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__dumper_8hpp/","title":"batteries/metrics/metric_dumper.hpp","text":""},{"location":"_autogen/Files/metric__dumper_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__dumper_8hpp/#classes","title":"Classes","text":"Name class batt::MetricDumper"},{"location":"_autogen/Files/metric__dumper_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_DUMPER_HPP"},{"location":"_autogen/Files/metric__dumper_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__dumper_8hpp/#define-batteries_metrics_metric_dumper_hpp","title":"define BATTERIES_METRICS_METRIC_DUMPER_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_DUMPER_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__dumper_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_DUMPER_HPP\n#define BATTERIES_METRICS_METRIC_DUMPER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;thread&gt;\nnamespace batt {\nclass MetricDumper\n{\npublic:\nexplicit MetricDumper(MetricRegistry&amp; registry, double rows_per_sec, std::ostream&amp; out,\nstd::unique_ptr&lt;MetricFormatter&gt; formatter) noexcept;\n~MetricDumper() noexcept;\nvoid halt();\nvoid join();\nvoid stop()\n{\nthis-&gt;halt();\nthis-&gt;join();\n}\nprivate:\nMetricRegistry&amp; registry_;\nconst double rows_per_sec_;\nstd::ostream&amp; out_;\nstd::unique_ptr&lt;MetricFormatter&gt; formatter_;\nstd::promise&lt;bool&gt; done_;\nOptional&lt;std::thread&gt; thread_;\n};\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_DUMPER_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_dumper_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/","title":"batteries/metrics/metric_dumper_impl.hpp","text":""},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#define-batteries_metrics_metric_dumper_impl_hpp","title":"define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__dumper__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP\n#define BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_dumper.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;chrono&gt;\n#include &lt;future&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;unordered_map&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL MetricDumper::MetricDumper(MetricRegistry&amp; registry, double rows_per_sec, std::ostream&amp; out,\nstd::unique_ptr&lt;MetricFormatter&gt; formatter) noexcept\n: registry_{registry}\n, rows_per_sec_{rows_per_sec}\n, out_{out}\n, formatter_{std::move(formatter)}\n, done_{}\n, thread_{[this] {\nstd::future&lt;bool&gt; done = this-&gt;done_.get_future();\nthis-&gt;formatter_-&gt;initialize(this-&gt;registry_, this-&gt;out_);\nfor (;;) {\nconst bool stop_requested =\ndone.wait_for(std::chrono::microseconds(i64(1000000.0 / this-&gt;rows_per_sec_))) !=\nstd::future_status::timeout;\nthis-&gt;formatter_-&gt;format_values(this-&gt;registry_, this-&gt;out_);\nif (stop_requested) {\nbreak;\n}\n}\nthis-&gt;formatter_-&gt;finished(this-&gt;registry_, this-&gt;out_);\n}}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL MetricDumper::~MetricDumper() noexcept\n{\nthis-&gt;stop();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void MetricDumper::halt()\n{\nthis-&gt;done_.set_value(true);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void MetricDumper::join()\n{\nif (this-&gt;thread_) {\nthis-&gt;thread_-&gt;join();\nthis-&gt;thread_ = None;\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_DUMPER_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__formatter_8hpp/","title":"batteries/metrics/metric_formatter.hpp","text":""},{"location":"_autogen/Files/metric__formatter_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__formatter_8hpp/#classes","title":"Classes","text":"Name class batt::MetricFormatter"},{"location":"_autogen/Files/metric__formatter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_FORMATTER_HPP"},{"location":"_autogen/Files/metric__formatter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__formatter_8hpp/#define-batteries_metrics_metric_formatter_hpp","title":"define BATTERIES_METRICS_METRIC_FORMATTER_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_FORMATTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__formatter_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi, Eitan Steiner\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_FORMATTER_HPP\n#define BATTERIES_METRICS_METRIC_FORMATTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\n#include &lt;boost/algorithm/string/replace.hpp&gt;\n#include &lt;ostream&gt;\nnamespace batt {\nclass MetricFormatter\n{\npublic:\nMetricFormatter(const MetricFormatter&amp;) = delete;\nMetricFormatter&amp; operator=(const MetricFormatter&amp;) = delete;\nvirtual ~MetricFormatter() = default;\n// Called once per ostream before any calls to `format_values` for that ostream.\n//\nvirtual void initialize(MetricRegistry&amp; src, std::ostream&amp; dst) = 0;\n// Called any number of times to format the current metric values in `src` to `dst`.\n//\nvirtual void format_values(MetricRegistry&amp; src, std::ostream&amp; dst) = 0;\n// Called once per ostream after all calls to `format_values` for that ostream.\n//\nvirtual void finished(MetricRegistry&amp; src, std::ostream&amp; dst) = 0;\nprotected:\nMetricFormatter() = default;\n// Fully qualified metric name with label keys and values, i.e.: name_key1_value1_key2_value2\n// Sanitize the key/value tokens to not contain ',' chars.\n//\nstd::string fully_qualified_name(std::string_view name, const MetricLabelSet&amp; labels)\n{\nstd::ostringstream fqn;\nfqn &lt;&lt; name;\nif (labels.size() &gt; 0) {\nfor (const auto&amp; l : labels) {\nstd::string key(l.key);\nstd::string value(l.value);\nboost::algorithm::replace_all(key, \",\", \"_\");\nboost::algorithm::replace_all(value, \",\", \"_\");\nfqn &lt;&lt; \"_\" &lt;&lt; key &lt;&lt; \"_\" &lt;&lt; value;\n}\n}\nreturn fqn.str();\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_FORMATTER_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_formatter_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__formatter__impl_8hpp/","title":"batteries/metrics/metric_formatter_impl.hpp","text":""},{"location":"_autogen/Files/metric__formatter__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__otel__formatter_8cpp/","title":"batteries/metrics/metric_otel_formatter.cpp","text":""},{"location":"_autogen/Files/metric__otel__formatter_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_otel_formatter.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_otel_formatter_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__otel__formatter_8hpp/","title":"batteries/metrics/metric_otel_formatter.hpp","text":""},{"location":"_autogen/Files/metric__otel__formatter_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__otel__formatter_8hpp/#classes","title":"Classes","text":"Name class batt::MetricOpenTelemetryFormatter Format metrics into OpenTelemetry data format: {=, ...}"},{"location":"_autogen/Files/metric__otel__formatter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRIC_OTEL_FORMATTER_HPP"},{"location":"_autogen/Files/metric__otel__formatter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__otel__formatter_8hpp/#define-batteries_metric_otel_formatter_hpp","title":"define BATTERIES_METRIC_OTEL_FORMATTER_HPP","text":"<pre><code>#define BATTERIES_METRIC_OTEL_FORMATTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__otel__formatter_8hpp/#source-code","title":"Source code","text":"<pre><code>//#############################################################################\n// Copyright 2023 Eitan Steiner\n//\n#pragma once\n#ifndef BATTERIES_METRIC_OTEL_FORMATTER_HPP\n#define BATTERIES_METRIC_OTEL_FORMATTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\nnamespace batt {\nclass MetricOpenTelemetryFormatter : public MetricFormatter\n{\npublic:\nstatic constexpr int kMetricValuePrecision = 10 /* digits */;\nvoid initialize(MetricRegistry&amp; src, std::ostream&amp; dst) override;\nvoid format_values(MetricRegistry&amp; src, std::ostream&amp; dst) override;\nvoid finished(MetricRegistry&amp; src, std::ostream&amp; dst) override;\n};\n}  // namespace batt\n#endif  // BATTERIES_METRIC_OTEL_FORMATTER_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_otel_formatter_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__otel__formatter__impl_8hpp/","title":"batteries/metrics/metric_otel_formatter_impl.hpp","text":""},{"location":"_autogen/Files/metric__otel__formatter__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/metric__otel__formatter__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_OTEL_FORMATTER_HPP"},{"location":"_autogen/Files/metric__otel__formatter__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__otel__formatter__impl_8hpp/#define-batteries_metrics_metric_otel_formatter_hpp","title":"define BATTERIES_METRICS_METRIC_OTEL_FORMATTER_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_OTEL_FORMATTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__otel__formatter__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//#############################################################################\n// Copyright 2023 Eitan Steiner, Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_OTEL_FORMATTER_HPP\n#define BATTERIES_METRICS_METRIC_OTEL_FORMATTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_otel_formatter.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nnamespace batt {\nnamespace detail {\nBATT_INLINE_IMPL std::string escape_otel_metric_name(const std::string_view name)\n{\nstd::ostringstream oss;\nfor (char ch : name) {\nif ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch == ':')) {\noss &lt;&lt; ch;\n} else {\noss &lt;&lt; '_';\n}\n}\nreturn std::move(oss).str();\n}\n}  // namespace detail\nBATT_INLINE_IMPL void MetricOpenTelemetryFormatter::initialize(MetricRegistry&amp; /*src*/, std::ostream&amp; /*dst*/)\n{\n// Nothing to do for OpenTelemtry format (stateless implementation).\n}\nBATT_INLINE_IMPL void MetricOpenTelemetryFormatter::format_values(MetricRegistry&amp; src, std::ostream&amp; dst)\n{\nstd::ostringstream buffer;\nstd::vector&lt;std::string&gt; ordered_metrics;\n// Read current metrics in the registry.\n//\nsrc.read_all([&amp;](std::string_view name, double value, const MetricLabelSet&amp; labels) {\nbuffer &lt;&lt; detail::escape_otel_metric_name(name) &lt;&lt; \" \";\n// Format optional labels.\nif (labels.size() &gt; 0) {\nbuffer &lt;&lt; \"{\";\nfor (const auto&amp; label : labels) {\nbuffer &lt;&lt; label.key &lt;&lt; \"=\\\"\" &lt;&lt; label.value &lt;&lt; \"\\\",\";\n}\nbuffer.seekp(-1 /*overwrite last ,*/, std::ios_base::end);\nbuffer &lt;&lt; \"}\";\n}\nbuffer &lt;&lt; \" \" &lt;&lt; std::setprecision(kMetricValuePrecision) &lt;&lt; value &lt;&lt; \"\\n\";\nordered_metrics.emplace_back(buffer.str());\nbuffer.str(\"\");\n});\nstd::sort(ordered_metrics.begin(), ordered_metrics.end());\nfor (const auto&amp; om : ordered_metrics) {\ndst &lt;&lt; om;\n}\n}\nBATT_INLINE_IMPL void MetricOpenTelemetryFormatter::finished(MetricRegistry&amp; /*src*/, std::ostream&amp; /*dst*/)\n{\n// Nothing to do for OpenTelemtry format.\n}\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_OTEL_FORMATTER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__registry_8cpp/","title":"batteries/metrics/metric_registry.cpp","text":""},{"location":"_autogen/Files/metric__registry_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_registry_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__registry_8hpp/","title":"batteries/metrics/metric_registry.hpp","text":""},{"location":"_autogen/Files/metric__registry_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__registry_8hpp/#classes","title":"Classes","text":"Name struct batt::MetricLabel class batt::MetricExporter class batt::ScalarMetricExporter Exports a single value metric. class batt::DerivedMetricExporter class batt::VariableExporter class batt::WatchExporter class batt::QueueDepthExporter class batt::MetricRegistry"},{"location":"_autogen/Files/metric__registry_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_REGISTRY_HPP"},{"location":"_autogen/Files/metric__registry_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__registry_8hpp/#define-batteries_metrics_metric_registry_hpp","title":"define BATTERIES_METRICS_METRIC_REGISTRY_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_REGISTRY_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__registry_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi, Eitan Steiner\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_REGISTRY_HPP\n#define BATTERIES_METRICS_METRIC_REGISTRY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_collectors.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/token.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n#include &lt;string_view&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nnamespace batt {\n// A key/value pair applied to a multi-dimensional metric.\n//\nstruct MetricLabel {\nToken key;\nToken value;\n};\n// A collection of MetricLabel values applied to a metric.\n//\nusing MetricLabelSet = std::vector&lt;MetricLabel&gt;;\n// Sorts the given metric set and eliminates duplicates.\n//\nMetricLabelSet normalize_labels(MetricLabelSet&amp;&amp; labels);\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// This interface must be implemented to export a metric.\n//\nclass MetricExporter\n{\npublic:\nMetricExporter(const MetricExporter&amp;) = delete;\nMetricExporter&amp; operator=(const MetricExporter&amp;) = delete;\nvirtual ~MetricExporter() = default;\nvirtual Token get_name() const = 0;\nvirtual std::string_view get_description() const\n{\nreturn \"A metric.\";\n}\nvirtual std::string_view get_type() const\n{\nreturn \"counter\";\n}\nvirtual const MetricLabelSet&amp; get_labels() const\n{\nreturn this-&gt;labels_;\n}\nvirtual void set_labels(MetricLabelSet&amp;&amp; labels)\n{\nthis-&gt;labels_ = normalize_labels(std::move(labels));\n}\nvirtual double get_value() const = 0;\nprotected:\nMetricExporter() = default;\nprivate:\nMetricLabelSet labels_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;class T&gt;\nclass ScalarMetricExporter : public MetricExporter\n{\npublic:\nexplicit ScalarMetricExporter(const std::string&amp; name, T&amp; metric) noexcept : name_{name}, metric_{metric}\n{\n}\nToken get_name() const override\n{\nreturn this-&gt;name_;\n}\ndouble get_value() const override\n{\nreturn static_cast&lt;double&gt;(this-&gt;metric_.load());\n}\nprivate:\nToken name_;\nT&amp; metric_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\nusing CountMetricExporter = ScalarMetricExporter&lt;CountMetric&lt;T&gt;&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\nusing GaugeMetricExporter = ScalarMetricExporter&lt;GaugeMetric&lt;T&gt;&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Exports a DerivedMetric&lt;T&gt;.\n//\ntemplate &lt;typename T&gt;\nclass DerivedMetricExporter : public MetricExporter\n{\npublic:\nexplicit DerivedMetricExporter(const std::string&amp; name, DerivedMetric&lt;T&gt;&amp; metric) noexcept\n: name_{name}\n, metric_{metric}\n{\n}\nToken get_name() const override\n{\nreturn this-&gt;name_;\n}\ndouble get_value() const override\n{\nreturn static_cast&lt;double&gt;(this-&gt;metric_());\n}\nprivate:\nToken name_;\nDerivedMetric&lt;T&gt;&amp; metric_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Exports a variable as a metric.\n//\ntemplate &lt;typename T&gt;\nclass VariableExporter : public MetricExporter\n{\npublic:\nexplicit VariableExporter(const std::string&amp; name, const T&amp; var) noexcept : name_{name}, var_{var}\n{\n}\nToken get_name() const override\n{\nreturn this-&gt;name_;\n}\ndouble get_value() const override\n{\nreturn static_cast&lt;double&gt;(this-&gt;var_);\n}\nprivate:\nToken name_;\nconst T&amp; var_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Exports a Watch&lt;T&gt; as a metric.\n//\ntemplate &lt;typename T&gt;\nclass WatchExporter : public MetricExporter\n{\npublic:\nexplicit WatchExporter(const std::string&amp; name, Watch&lt;T&gt;&amp; watch) noexcept : name_{name}, watch_{watch}\n{\n}\nToken get_name() const override\n{\nreturn this-&gt;name_;\n}\ndouble get_value() const override\n{\nreturn static_cast&lt;double&gt;(this-&gt;watch_.get_value());\n}\nprivate:\nToken name_;\nWatch&lt;T&gt;&amp; watch_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Exports Queue depth as a metric.\n//\nclass QueueDepthExporter : public MetricExporter\n{\npublic:\nexplicit QueueDepthExporter(const std::string&amp; name, QueueBase&amp; queue) noexcept\n: name_{name}\n, queue_{queue}\n{\n}\nToken get_name() const override\n{\nreturn this-&gt;name_;\n}\ndouble get_value() const override\n{\nreturn static_cast&lt;double&gt;(this-&gt;queue_.size());\n}\nprivate:\nToken name_;\nQueueBase&amp; queue_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// A set of metric exporters.\n//\nclass MetricRegistry\n{\npublic:\nMetricRegistry&amp; add_exporter(const void* obj, std::unique_ptr&lt;MetricExporter&gt; exporter,\nMetricLabelSet&amp;&amp; labels)\n{\nexporter-&gt;set_labels(std::move(labels));\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;metrics_.emplace(obj, std::move(exporter));\nreturn *this;\n}\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; add(std::string_view name, CountMetric&lt;T&gt;&amp; counter,\nMetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nBATT_VLOG(1) &lt;&lt; \"adding CountMetric:\" &lt;&lt; name;\nreturn this-&gt;add_exporter(&amp;counter,\nstd::make_unique&lt;CountMetricExporter&lt;T&gt;&gt;(std::string(name), counter),\nstd::move(labels));\n}\nMetricRegistry&amp; add(std::string_view name, LatencyMetric&amp; latency,\nMetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nBATT_VLOG(1) &lt;&lt; \"adding LatencyMetric:\" &lt;&lt; name;\nthis-&gt;add_exporter(\n&amp;latency,\nstd::make_unique&lt;CountMetricExporter&lt;u64&gt;&gt;(to_string(name, \"_total_usec\"), latency.total_usec),\nbatt::make_copy(labels));\nthis-&gt;add_exporter(\n&amp;latency, std::make_unique&lt;CountMetricExporter&lt;u64&gt;&gt;(to_string(name, \"_count\"), latency.count),\nbatt::make_copy(labels));\nreturn *this;\n}\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; add(std::string_view name, GaugeMetric&lt;T&gt;&amp; gauge,\nMetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nBATT_VLOG(1) &lt;&lt; \"adding GaugeMetric:\" &lt;&lt; name;\nthis-&gt;add_exporter(&amp;gauge, std::make_unique&lt;GaugeMetricExporter&lt;T&gt;&gt;(to_string(name, \"_gauge\"), gauge),\nstd::move(labels));\nreturn *this;\n}\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; add(std::string_view name, StatsMetric&lt;T&gt;&amp; stats,\nMetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nBATT_VLOG(1) &lt;&lt; \"adding StatsMetric:\" &lt;&lt; name;\n// Create 'fanout' copies of 'labels' argument.\nthis-&gt;add_exporter(&amp;stats,\nstd::make_unique&lt;CountMetricExporter&lt;T&gt;&gt;(to_string(name, \"_count\"), stats.count_),\nbatt::make_copy(labels));\nthis-&gt;add_exporter(&amp;stats,\nstd::make_unique&lt;CountMetricExporter&lt;T&gt;&gt;(to_string(name, \"_total\"), stats.total_),\nbatt::make_copy(labels));\nthis-&gt;add_exporter(&amp;stats,\nstd::make_unique&lt;CountMetricExporter&lt;T&gt;&gt;(to_string(name, \"_max\"), stats.max_),\nbatt::make_copy(labels));\nthis-&gt;add_exporter(&amp;stats,\nstd::make_unique&lt;CountMetricExporter&lt;T&gt;&gt;(to_string(name, \"_min\"), stats.min_),\nbatt::make_copy(labels));\nreturn *this;\n}\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; add(std::string_view name, HistogramMetric&lt;T&gt;&amp; histogram,\nMetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nBATT_VLOG(1) &lt;&lt; \"adding HistogramMetric:\" &lt;&lt; name;\nconst std::string bucket_prefix{to_string(name, \"_histogram_bucket\")};\nfor (usize i = 0; i &lt;= histogram.num_intervals_ + 1u; ++i) {\n// Create bucket label with upper-bound info.\nstd::string upper_bound{to_string(histogram.upper_bound(i))};\n// Display last upper_bound: numeric_limits&lt;T&gt;::max() as infinity.\nif (BATT_HINT_FALSE(i == histogram.num_intervals_ + 1u)) {\nupper_bound = \"Inf\";\n}\nconst batt::MetricLabel bucket_label{batt::Token(\"le\"), batt::Token(upper_bound)};\n// Append bucket label to preexisting labels.\nbatt::MetricLabelSet augmented_labels{labels};\naugmented_labels.push_back(bucket_label);\n// Add histogram bucket as a StatsMetric.\nStatsMetric&lt;T&gt;&amp; bucket_metric = histogram.buckets_[i];\nthis-&gt;add(bucket_prefix, bucket_metric, std::move(augmented_labels));\n}\nreturn *this;\n}\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; add(std::string_view name, Watch&lt;T&gt;&amp; watch, MetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nreturn this-&gt;add_exporter(&amp;watch, std::make_unique&lt;WatchExporter&lt;T&gt;&gt;(std::string(name), watch),\nstd::move(labels));\n}\nMetricRegistry&amp; add(std::string_view name, QueueBase&amp; queue, MetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nreturn this-&gt;add_exporter(\n&amp;queue, std::make_unique&lt;QueueDepthExporter&gt;(to_string(name, \"_queue_depth\"), queue),\nstd::move(labels));\n}\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; add(std::string_view name, DerivedMetric&lt;T&gt;&amp; metric,\nMetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nreturn this-&gt;add_exporter(&amp;metric, std::make_unique&lt;DerivedMetricExporter&lt;T&gt;&gt;(name, metric),\nstd::move(labels));\n}\nMetricRegistry&amp; add(std::string_view name, const double&amp; var, MetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nreturn this-&gt;add_exporter(&amp;var, std::make_unique&lt;VariableExporter&lt;double&gt;&gt;(std::string(name), var),\nstd::move(labels));\n}\nMetricRegistry&amp; add(std::string_view name, const usize&amp; var, MetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nreturn this-&gt;add_exporter(&amp;var, std::make_unique&lt;VariableExporter&lt;usize&gt;&gt;(std::string(name), var),\nstd::move(labels));\n}\nMetricRegistry&amp; add(std::string_view name, const isize&amp; var, MetricLabelSet&amp;&amp; labels = MetricLabelSet{})\n{\nreturn this-&gt;add_exporter(&amp;var, std::make_unique&lt;VariableExporter&lt;isize&gt;&gt;(std::string(name), var),\nstd::move(labels));\n}\n// Invokes the passed function for all registered metrics.\n//\nvoid read_all(\nstd::function&lt;void(std::string_view name, double value, const MetricLabelSet&amp; labels)&gt;&amp;&amp; fn) const\n{\nstruct MetricSnapshot {\nstd::string_view name;\ndouble value;\nMetricLabelSet labels;\n};\nstd::vector&lt;MetricSnapshot&gt; local_snapshot;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nfor (const auto&amp; p : this-&gt;metrics_) {\nlocal_snapshot.emplace_back(MetricSnapshot{\nstatic_cast&lt;const std::string&amp;&gt;(p.second-&gt;get_name()),\np.second-&gt;get_value(),\np.second-&gt;get_labels(),\n});\n}\n}\nfor (const auto&amp; m : local_snapshot) {\nfn(m.name, m.value, m.labels);\n}\n}\n// Removes the passed scalar metric from this registry.\n//\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; remove(T&amp; obj)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;metrics_.erase(&amp;obj);\nreturn *this;\n}\n// Removes the passed histogram metric from this registry.\n//\ntemplate &lt;typename T&gt;\nMetricRegistry&amp; remove(HistogramMetric&lt;T&gt;&amp; histogram)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nfor (auto&amp; obj : histogram.buckets_) {\nthis-&gt;metrics_.erase(&amp;obj);\n}\nreturn *this;\n}\n// Adds the passed metric exporter (`obj`) to the registry under the given `name`; the metric will\n// automatically be removed from the registry when the last (moved) copy of the returned guard object goes\n// out of scope.\n//\ntemplate &lt;typename T&gt;\nauto scoped_add(std::string_view name, T&amp; obj)\n{\nthis-&gt;add(name, obj);\nreturn finally([&amp;obj, this] {\nthis-&gt;remove(obj);\n});\n}\nprivate:\nmutable std::mutex mutex_;\nstd::unordered_multimap&lt;const void*, std::unique_ptr&lt;MetricExporter&gt;&gt; metrics_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// A process-wide instance of MetricRegistry used by various components by default.\n//\nMetricRegistry&amp; global_metric_registry();\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#if 0\n  const auto metric_name = [this](std::string_view property) {\n      return ::batt::to_string(\"Scope_\", this-&gt;name_, \"_\", property);\n  };\n#define ADD_METRIC_(n) ::batt::global_metric_registry().add(metric_name(#n), this-&gt;metrics_.n)\n  ADD_METRIC_(field_name);\n#undef ADD_METRIC_\n::batt::global_metric_registry()\n    .add(metric_name(\"other_name\"), this-&gt;other_thing_);\n#endif\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_REGISTRY_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/metrics/metric_registry_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/metric__registry__impl_8hpp/","title":"batteries/metrics/metric_registry_impl.hpp","text":""},{"location":"_autogen/Files/metric__registry__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/metric__registry__impl_8hpp/#define-batteries_metrics_metric_registry_impl_hpp","title":"define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP","text":"<pre><code>#define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/metric__registry__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP\n#define BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL MetricRegistry&amp; global_metric_registry()\n{\nstatic MetricRegistry instance_;\nreturn instance_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL MetricLabelSet normalize_labels(MetricLabelSet&amp;&amp; labels)\n{\nstd::sort(labels.begin(), labels.end(), [](const MetricLabel&amp; left, const MetricLabel&amp; right) {\nreturn left.key &lt; right.key;\n});\nlabels.erase(std::unique(labels.begin(), labels.end(),\n[](const MetricLabel&amp; left, const MetricLabel&amp; right) {\nreturn left.key == right.key;\n}),\nlabels.end());\nreturn std::move(labels);\n}\n}  // namespace batt\n#endif  // BATTERIES_METRICS_METRIC_REGISTRY_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/mutex_8cpp/","title":"batteries/async/mutex.cpp","text":""},{"location":"_autogen/Files/mutex_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/mutex.hpp&gt;\n//\n#include &lt;batteries/async/mutex_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/mutex_8hpp/","title":"batteries/async/mutex.hpp","text":""},{"location":"_autogen/Files/mutex_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/mutex_8hpp/#classes","title":"Classes","text":"Name class batt::MutexBase Base class of typed Mutex; implements core logic without any type dependencies. class batt::LockBase class batt::Mutex Provides mutually-exclusive access to an instance of type <code>T</code>. class batt::Mutex::LockImpl Represents a lock aquisition. struct batt::Mutex::ThreadSafeBaseIsNotSupportedByType Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is. class batt::ScopedLock"},{"location":"_autogen/Files/mutex_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_MUTEX_HPP BATT_SCOPED_LOCK(LOCK_VAR, MUTEX_EXPR) BATT_SCOPED_CONST_LOCK(LOCK_VAR, MUTEX_EXPR)"},{"location":"_autogen/Files/mutex_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/mutex_8hpp/#define-batteries_async_mutex_hpp","title":"define BATTERIES_ASYNC_MUTEX_HPP","text":"<pre><code>#define BATTERIES_ASYNC_MUTEX_HPP()\n</code></pre>"},{"location":"_autogen/Files/mutex_8hpp/#define-batt_scoped_lock","title":"define BATT_SCOPED_LOCK","text":"<pre><code>#define BATT_SCOPED_LOCK(LOCK_VAR, MUTEX_EXPR)\n</code></pre>"},{"location":"_autogen/Files/mutex_8hpp/#define-batt_scoped_const_lock","title":"define BATT_SCOPED_CONST_LOCK","text":"<pre><code>#define BATT_SCOPED_CONST_LOCK(LOCK_VAR, MUTEX_EXPR)\n</code></pre>"},{"location":"_autogen/Files/mutex_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_MUTEX_HPP\n#define BATTERIES_ASYNC_MUTEX_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/pointers.hpp&gt;\n#include &lt;atomic&gt;\nnamespace batt {\nclass LockBase;\nclass MutexBase\n{\npublic:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nfriend class LockBase;\nprotected:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nmutable std::atomic&lt;void*&gt; queue_back_{nullptr};\n};\nclass LockBase\n{\npublic:\nstatic constexpr usize kMaxLockDepth = 8;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstruct PerThreadState;\nstatic PerThreadState&amp; per_thread();\nstatic LockBase* acquire(const MutexBase&amp; mutex);\nstatic void release(LockBase* lock);\nenum struct State {\nkUnlocked = 0,\nkLocked = 1,\nkLockedHaveNext = 2,\nkInvalid = 3,\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nLockBase() noexcept\n: mutex_{nullptr}\n, state_{State::kUnlocked}\n, next_{nullptr}\n, waiting_to_acquire_{false}\n{\n}\nexplicit LockBase(const MutexBase&amp; mutex) noexcept\n: mutex_{std::addressof(mutex)}\n, state_{State::kUnlocked}\n, next_{nullptr}\n, waiting_to_acquire_{false}\n{\n// IMPORTANT: this should be the only call to acquire_impl!  Please do not add a public `lock()`\n// member function (or equivalent) without completely reviewing the design of this entire class and\n// the algorithms it uses.\n//\nthis-&gt;acquire_impl();\n}\nLockBase(LockBase&amp;&amp; src) noexcept\n: mutex_{nullptr}\n, state_{State::kUnlocked}\n, next_{nullptr}\n, waiting_to_acquire_{false}\n{\nthis-&gt;move_impl(std::move(src));\n}\nLockBase(const LockBase&amp;) = delete;\nLockBase&amp; operator=(const LockBase&amp;) = delete;\n~LockBase() noexcept\n{\nthis-&gt;release_impl();\n}\nLockBase&amp; operator=(LockBase&amp;&amp; src) noexcept\n{\nthis-&gt;release_impl();\nthis-&gt;move_impl(std::move(src));\nreturn *this;\n}\nvoid release() noexcept\n{\nthis-&gt;release_impl();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nvoid acquire_impl() noexcept\n{\n{\nvoid* prior_value = this-&gt;mutex_-&gt;queue_back_.exchange(this);\nif (prior_value == nullptr) {\nthis-&gt;state_ = State::kLocked;\nreturn;\n}\n//----- --- -- -  -  -   -\n// This is the only section of code where waiting_to_acquire_ is true.\n//\nthis-&gt;waiting_to_acquire_-&gt;set_value(true);\n//\nLockBase* prev_lock = static_cast&lt;LockBase*&gt;(prior_value);\nprev_lock-&gt;next_-&gt;set_value_and_release(this);\n//\n// NOTE: this call to `set_value_and_release` MUST be the final usage of the pointer value read\n// into `prior_value` above.\n}\n//\nBATT_CHECK_OK(this-&gt;waiting_to_acquire_-&gt;await_equal(false));\n//\n//----- --- -- -  -  -   -\nthis-&gt;state_ = State::kLocked;\n}\nvoid move_impl(LockBase&amp;&amp; src) noexcept\n{\nthis-&gt;mutex_ = src.mutex_;\nthis-&gt;state_ = src.state_;\n// We will transfer the value of src.next_ below, if necessary.\n//\nthis-&gt;next_-&gt;set_value(nullptr);\n// `src.waiting_to_acquire_` should *always* be false, since being true would imply that src is being\n// moved while inside a call to acquire, meaning it is partially constructed, so how exactly is it\n// being moved??\n//\nBATT_ASSERT(!src.waiting_to_acquire_-&gt;get_value());\nthis-&gt;waiting_to_acquire_-&gt;set_value(false);\n// If src wasn't locked, then we're done!\n//\nif (this-&gt;state_ == State::kUnlocked) {\nreturn;\n}\n// Let src know it no longer holds the mutex.\n//\nsrc.state_ = State::kUnlocked;\nif (this-&gt;state_ == State::kLocked) {\nvoid* expected_value = std::addressof(src);\nfor (;;) {\n// Try to atomically swap `this` into the mutex `queue_back_` where `&amp;src` was; if we succeed,\n// then no one will ever know the move took place, and we are done!\n//\n// NOTE: we know that if there is a LockBase object whose address is held by\n// MutexBase::queue_back_, it MUST be `src`, since we have an rvalue reference to `src`,\n// therefore `src` can't have been destroyed and its memory reclaimed (yet).\n//\nif (this-&gt;mutex_-&gt;queue_back_.compare_exchange_weak(expected_value, this)) {\nBATT_ASSERT_EQ(src.next_-&gt;get_value(), nullptr);\nreturn;\n}\n// If this was a spurious failure, just retry.\n//\nif (expected_value == std::addressof(src)) {\ncontinue;\n}\nbreak;\n}\n// If we get here, there is some lock who came _after_ `src` to acquire the mutex;  that lock\n// is obligated to set `src.next_` to itself so it can be unblocked when the lock is released.\n// Since `this` is the new owner of the lock, it is now responsible for signaling `src.next_`,\n// so wait for `src.next_` to be set and copy the pointer to `this-&gt;next_`.\n//\nStatusOr&lt;LockBase*&gt; status_or_next = src.next_-&gt;await_not_equal(nullptr);\nBATT_CHECK_OK(status_or_next);\nLockBase* const src_next = *status_or_next;\nBATT_ASSERT_NOT_NULLPTR(src_next);\nthis-&gt;next_-&gt;set_value(src_next);\nthis-&gt;state_ = State::kLockedHaveNext;\n} else {\n// Not kUnlocked, not kLocked; kLockedHaveNext is the only remaining possibility.\n//\nBATT_ASSERT_EQ(this-&gt;state_, State::kLockedHaveNext);\nLockBase* const src_next = src.next_-&gt;get_value();\n// kLockedHaveNext implies that src.next_ is non-null.\n//\nBATT_CHECK_NOT_NULLPTR(src_next) &lt;&lt; BATT_INSPECT((void*)this) &lt;&lt; BATT_INSPECT((void*)src_next);\nthis-&gt;next_-&gt;set_value(src_next);\n}\n}\nvoid release_impl() noexcept\n{\nif (this-&gt;state_ == State::kUnlocked) {\nreturn;\n}\nconst State prior_state = this-&gt;state_;\nthis-&gt;state_ = State::kUnlocked;\nLockBase* next_lock;  // MUST be set in both branches below.\nif (prior_state == State::kLocked) {\nvoid* expected_value = this;\nfor (;;) {\nif (this-&gt;mutex_-&gt;queue_back_.compare_exchange_weak(expected_value, nullptr)) {\nreturn;\n}\n// If this was a spurious failure, just retry.\n//\nif (expected_value == this) {\ncontinue;\n}\nbreak;\n}\nStatusOr&lt;LockBase*&gt; status_or_next = this-&gt;next_-&gt;await_not_equal(nullptr);\nBATT_CHECK_OK(status_or_next);\nnext_lock = *status_or_next;\n} else {\nBATT_ASSERT_EQ(prior_state, State::kLockedHaveNext);\nnext_lock = this-&gt;next_-&gt;get_value();\n}\nBATT_ASSERT_NOT_NULLPTR(next_lock) &lt;&lt; BATT_INSPECT(prior_state);\nnext_lock-&gt;waiting_to_acquire_-&gt;set_value_and_release(false);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nconst MutexBase* mutex_;\nState state_;\nCpuCacheLineIsolated&lt;Watch&lt;LockBase*&gt;&gt; next_;\nCpuCacheLineIsolated&lt;Watch&lt;bool&gt;&gt; waiting_to_acquire_;\n};\ntemplate &lt;typename T&gt;\nclass ScopedLock;\ntemplate &lt;typename T&gt;\nclass Mutex : public MutexBase\n{\npublic:\ntemplate &lt;typename&gt;\nfriend class ScopedLock;\n#if BATT_MUTEX_NO_LEGACY_API\nusing Lock = ScopedLock&lt;T&gt;;\nusing ConstLock = ScopedLock&lt;const T&gt;;\n#else  // BATT_MUTEX_NO_LEGACY_API\ntemplate &lt;typename U, typename MutexT&gt;\nclass LockImpl\n{\npublic:\nexplicit LockImpl(MutexT&amp; m) noexcept : lock_base_{m}, val_{std::addressof(m.value_)}\n{\n}\nLockImpl(const LockImpl&amp;) = delete;\nLockImpl&amp; operator=(const LockImpl&amp;) = delete;\nLockImpl(LockImpl&amp;&amp;) = default;\nLockImpl&amp; operator=(LockImpl&amp;&amp;) = default;\n~LockImpl() noexcept\n{\nthis-&gt;release();\n}\nbool is_held() const noexcept\n{\nreturn this-&gt;val_ != nullptr;\n}\nexplicit operator bool() const noexcept\n{\nreturn this-&gt;is_held();\n}\nU&amp; operator*() noexcept\n{\nreturn *this-&gt;val_;\n}\nU* get() noexcept\n{\nreturn this-&gt;val_.get();\n}\nU&amp; value() noexcept\n{\nreturn *this-&gt;val_;\n}\nU* operator-&gt;() noexcept\n{\nreturn this-&gt;val_.get();\n}\nbool release() noexcept\n{\nif (this-&gt;val_ != nullptr) {\nthis-&gt;val_.release();\nthis-&gt;lock_base_.release();\nreturn true;\n}\nreturn false;\n}\nprivate:\nLockBase lock_base_;\n// Direct pointer to the locked object; if nullptr, this indicates that the lock has been\n// released.\n//\nUniqueNonOwningPtr&lt;U&gt; val_;\n};\nusing Lock = LockImpl&lt;T, Mutex&gt;;\nusing ConstLock = LockImpl&lt;const T, const Mutex&gt;;\n#endif  // BATT_MUTEX_NO_LEGACY_API\ntemplate &lt;typename&gt;\nstruct ThreadSafeBaseIsNotSupportedByType {\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Self, typename Base = typename Self::ThreadSafeBase&gt;\nstatic Base* thread_safe_base(Self* ptr)\n{\nreturn ptr;\n}\ntemplate &lt;typename Self, typename Base = typename Self::ThreadSafeBase&gt;\nstatic const Base* thread_safe_base(const Self* ptr)\n{\nreturn ptr;\n}\ntemplate &lt;typename Self, typename Base = typename Self::ThreadSafeBase, typename = void&gt;\nstatic Base* thread_safe_base(const std::unique_ptr&lt;Self&gt;* ptr)\n{\nreturn ptr-&gt;get();\n}\nstatic ThreadSafeBaseIsNotSupportedByType&lt;T&gt;* thread_safe_base(...)\n{\nreturn nullptr;\n}\nMutex(const Mutex&amp;) = delete;\nMutex&amp; operator=(const Mutex&amp;) = delete;\nMutex() = default;\ntemplate &lt;typename... Args, typename = EnableIfNoShadow&lt;Mutex, Args...&gt;&gt;\nexplicit Mutex(Args&amp;&amp;... args) noexcept : value_(BATT_FORWARD(args)...)\n{\n}\n#if !BATT_MUTEX_NO_LEGACY_API\nLock lock()\n{\nreturn Lock{*this};\n}\nConstLock lock() const\n{\nreturn ConstLock{*this};\n}\n#endif  // BATT_MUTEX_NO_LEGACY_API\ntemplate &lt;typename Action&gt;\ndecltype(auto) with_lock(Action&amp;&amp; action);\nauto operator-&gt;()\n{\nreturn thread_safe_base(&amp;this-&gt;value_);\n}\ndecltype(auto) no_lock()\n{\nreturn *thread_safe_base(&amp;this-&gt;value_);\n}\ndecltype(auto) no_lock() const\n{\nreturn *thread_safe_base(&amp;this-&gt;value_);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nT value_;\n};\ntemplate &lt;typename T&gt;\nclass ScopedLock\n{\npublic:\nexplicit ScopedLock(Mutex&lt;T&gt;&amp; m) noexcept : lock_base_{m}, val_{std::addressof(m.value_)}\n{\n}\nexplicit ScopedLock(const Mutex&lt;std::remove_const_t&lt;T&gt;&gt;&amp; m) noexcept\n: lock_base_{m}\n, val_{const_cast&lt;std::add_const_t&lt;T&gt;*&gt;(std::addressof(m.value_))}\n{\n}\nScopedLock(const ScopedLock&amp;) = delete;\nScopedLock&amp; operator=(const ScopedLock&amp;) = delete;\n~ScopedLock() noexcept\n{\n}\nexplicit operator bool() const noexcept\n{\nreturn this-&gt;is_held();\n}\nT&amp; operator*() noexcept\n{\nreturn *this-&gt;val_;\n}\nT* get() noexcept\n{\nreturn this-&gt;val_.get();\n}\nT&amp; value() noexcept\n{\nreturn *this-&gt;val_;\n}\nT* operator-&gt;() noexcept\n{\nreturn this-&gt;val_.get();\n}\nprivate:\nLockBase lock_base_;\n// Direct pointer to the locked object; if nullptr, this indicates that the lock has been\n// released.\n//\nUniqueNonOwningPtr&lt;T&gt; val_;\n};\n#define BATT_SCOPED_LOCK(LOCK_VAR, MUTEX_EXPR)                                                               \\\n    decltype(MUTEX_EXPR)::Lock LOCK_VAR                                                                      \\\n    {                                                                                                        \\\n        MUTEX_EXPR                                                                                           \\\n    }\n#define BATT_SCOPED_CONST_LOCK(LOCK_VAR, MUTEX_EXPR)                                                         \\\n    decltype(MUTEX_EXPR)::ConstLock LOCK_VAR                                                                 \\\n    {                                                                                                        \\\n        MUTEX_EXPR                                                                                           \\\n    }\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ntemplate &lt;typename Action&gt;\ninline decltype(auto) Mutex&lt;T&gt;::with_lock(Action&amp;&amp; action)\n{\nScopedLock&lt;T&gt; lock{*this};\nreturn BATT_FORWARD(action)(this-&gt;value_);\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_MUTEX_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/mutex_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/mutex__impl_8hpp/","title":"batteries/async/mutex_impl.hpp","text":""},{"location":"_autogen/Files/mutex__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/mutex__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_MUTEX_IMPL_HPP"},{"location":"_autogen/Files/mutex__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/mutex__impl_8hpp/#define-batteries_async_mutex_impl_hpp","title":"define BATTERIES_ASYNC_MUTEX_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_MUTEX_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/mutex__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_MUTEX_IMPL_HPP\n#define BATTERIES_ASYNC_MUTEX_IMPL_HPP\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ LockBase* LockBase::acquire(const MutexBase&amp; mutex)\n{\nreturn new LockBase{mutex};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ void LockBase::release(LockBase* lock)\n{\ndelete lock;\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_MUTEX_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/natural__equals_8hpp/","title":"batteries/seq/natural_equals.hpp","text":""},{"location":"_autogen/Files/natural__equals_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/natural__equals_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::NaturalEquals"},{"location":"_autogen/Files/natural__equals_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_NATURAL_EQUALS_HPP"},{"location":"_autogen/Files/natural__equals_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/natural__equals_8hpp/#define-batteries_seq_natural_equals_hpp","title":"define BATTERIES_SEQ_NATURAL_EQUALS_HPP","text":"<pre><code>#define BATTERIES_SEQ_NATURAL_EQUALS_HPP()\n</code></pre>"},{"location":"_autogen/Files/natural__equals_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_NATURAL_EQUALS_HPP\n#define BATTERIES_SEQ_NATURAL_EQUALS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\nnamespace seq {\nstruct NaturalEquals {\ntemplate &lt;typename L, typename R&gt;\nbool operator()(L&amp;&amp; l, R&amp;&amp; r) const\n{\nreturn l == r;\n}\n};\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_NATURAL_EQUALS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/natural__order_8hpp/","title":"batteries/seq/natural_order.hpp","text":""},{"location":"_autogen/Files/natural__order_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/natural__order_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::NaturalOrder"},{"location":"_autogen/Files/natural__order_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_NATURAL_ORDER_HPP"},{"location":"_autogen/Files/natural__order_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/natural__order_8hpp/#define-batteries_seq_natural_order_hpp","title":"define BATTERIES_SEQ_NATURAL_ORDER_HPP","text":"<pre><code>#define BATTERIES_SEQ_NATURAL_ORDER_HPP()\n</code></pre>"},{"location":"_autogen/Files/natural__order_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_NATURAL_ORDER_HPP\n#define BATTERIES_SEQ_NATURAL_ORDER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\nnamespace seq {\nstruct NaturalOrder {\ntemplate &lt;typename L, typename R&gt;\nbool operator()(L&amp;&amp; l, R&amp;&amp; r) const\n{\nreturn l &lt; r;\n}\n};\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_NATURAL_ORDER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/no__destruct_8hpp/","title":"batteries/no_destruct.hpp","text":""},{"location":"_autogen/Files/no__destruct_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/no__destruct_8hpp/#classes","title":"Classes","text":"Name class batt::NoDestruct"},{"location":"_autogen/Files/no__destruct_8hpp/#defines","title":"Defines","text":"Name BATTERIES_NO_DESTRUCT_HPP"},{"location":"_autogen/Files/no__destruct_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/no__destruct_8hpp/#define-batteries_no_destruct_hpp","title":"define BATTERIES_NO_DESTRUCT_HPP","text":"<pre><code>#define BATTERIES_NO_DESTRUCT_HPP()\n</code></pre>"},{"location":"_autogen/Files/no__destruct_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_NO_DESTRUCT_HPP\n#define BATTERIES_NO_DESTRUCT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/type_traits.hpp&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass NoDestruct\n{\npublic:\nexplicit NoDestruct() noexcept\n{\nnew (&amp;this-&gt;storage_) T{};\n}\ntemplate &lt;typename... Args, typename = EnableIfNoShadow&lt;NoDestruct, Args...&gt;&gt;\nexplicit NoDestruct(Args&amp;&amp;... args) noexcept\n{\nnew (&amp;this-&gt;storage_) T(BATT_FORWARD(args)...);\n}\nNoDestruct(const NoDestruct&amp;) = delete;\nNoDestruct&amp; operator=(const NoDestruct&amp;) = delete;\n~NoDestruct() noexcept\n{\n// Do nothing!\n}\n//----- --- -- -  -  -   -\nT* pointer() noexcept\n{\nreturn reinterpret_cast&lt;T*&gt;(&amp;this-&gt;storage_);\n}\nconst T* pointer() const noexcept\n{\nreturn reinterpret_cast&lt;const T*&gt;(&amp;this-&gt;storage_);\n}\n//----- --- -- -  -  -   -\nT&amp; get() noexcept\n{\nreturn *this-&gt;pointer();\n}\nconst T&amp; get() const noexcept\n{\nreturn *this-&gt;pointer();\n}\n//----- --- -- -  -  -   -\nT* operator-&gt;() noexcept\n{\nreturn this-&gt;pointer();\n}\nconst T* operator-&gt;() const noexcept\n{\nreturn this-&gt;pointer();\n}\n//----- --- -- -  -  -   -\nT&amp; operator*() noexcept\n{\nreturn this-&gt;get();\n}\nconst T&amp; operator*() const noexcept\n{\nreturn this-&gt;get();\n}\nprivate:\nstd::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; storage_;\n};\n}  // namespace batt\n#endif  // BATTERIES_NO_DESTRUCT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/nullable_8hpp/","title":"batteries/nullable.hpp","text":""},{"location":"_autogen/Files/nullable_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/nullable_8hpp/#classes","title":"Classes","text":"Name struct batt::detail::NullableImpl struct batt::detail::NullableImpl&lt; std::optional&lt; T &gt; &gt; struct batt::detail::NullableImpl&lt; std::unique_ptr&lt; T &gt; &gt; struct batt::detail::NullableImpl&lt; std::shared_ptr&lt; T &gt; &gt; struct batt::detail::NullableImpl&lt; T * &gt;"},{"location":"_autogen/Files/nullable_8hpp/#defines","title":"Defines","text":"Name BATTERIES_NULLABLE_HPP"},{"location":"_autogen/Files/nullable_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/nullable_8hpp/#define-batteries_nullable_hpp","title":"define BATTERIES_NULLABLE_HPP","text":"<pre><code>#define BATTERIES_NULLABLE_HPP()\n</code></pre>"},{"location":"_autogen/Files/nullable_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_NULLABLE_HPP\n#define BATTERIES_NULLABLE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\nnamespace batt {\nnamespace detail {\ntemplate &lt;typename T&gt;\nstruct NullableImpl {\nusing type = std::optional&lt;T&gt;;\n};\ntemplate &lt;typename T&gt;\nstruct NullableImpl&lt;std::optional&lt;T&gt;&gt; {\nusing type = std::optional&lt;T&gt;;\n};\ntemplate &lt;typename T&gt;\nstruct NullableImpl&lt;std::unique_ptr&lt;T&gt;&gt; {\nusing type = std::unique_ptr&lt;T&gt;;\n};\ntemplate &lt;typename T&gt;\nstruct NullableImpl&lt;std::shared_ptr&lt;T&gt;&gt; {\nusing type = std::shared_ptr&lt;T&gt;;\n};\ntemplate &lt;typename T&gt;\nstruct NullableImpl&lt;T*&gt; {\nusing type = T*;\n};\n}  // namespace detail\ntemplate &lt;typename T&gt;\nusing Nullable = typename detail::NullableImpl&lt;T&gt;::type;\ntemplate &lt;typename T&gt;\nauto make_nullable(T&amp;&amp; obj) -&gt; Nullable&lt;std::decay_t&lt;T&gt;&gt;\n{\nreturn Nullable&lt;std::decay_t&lt;T&gt;&gt;(BATT_FORWARD(obj));\n}\n}  // namespace batt\n#endif  // BATTERIES_NULLABLE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/operators_8hpp/","title":"batteries/operators.hpp","text":""},{"location":"_autogen/Files/operators_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/operators_8hpp/#defines","title":"Defines","text":"Name BATTERIES_OPERATORS_HPP BATT_UNWRAP(...) BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type) BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type) BATT_OBJECT_FIELD_EXPR(r, obj, fieldname) BATT_OBJECT_FIELD_PARAM(r, obj, fieldname) BATT_PRINT_OBJECT_FIELD(r, obj, fieldname) BATT_PRINT_OBJECT_IMPL(type, fields_seq) BATT_OBJECT_PRINT_IMPL(inline_decl, type, fields_tuple) BATT_EQUALS_OBJECT_IMPL(inline_decl, type, fields_seq) BATT_OBJECT_EQUALS_IMPL(inline_decl, type, fields_tuple) BATT_LESS_THAN_OBJECT_IMPL(inline_decl, type, fields_seq) BATT_OBJECT_LESS_THAN_IMPL(inline_decl, type, fields_tuple)"},{"location":"_autogen/Files/operators_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/operators_8hpp/#define-batteries_operators_hpp","title":"define BATTERIES_OPERATORS_HPP","text":"<pre><code>#define BATTERIES_OPERATORS_HPP()\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_unwrap","title":"define BATT_UNWRAP","text":"<pre><code>#define BATT_UNWRAP(...)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_totally_ordered","title":"define BATT_TOTALLY_ORDERED","text":"<pre><code>#define BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_equality_comparable","title":"define BATT_EQUALITY_COMPARABLE","text":"<pre><code>#define BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_object_field_expr","title":"define BATT_OBJECT_FIELD_EXPR","text":"<pre><code>#define BATT_OBJECT_FIELD_EXPR(r, obj, fieldname)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_object_field_param","title":"define BATT_OBJECT_FIELD_PARAM","text":"<pre><code>#define BATT_OBJECT_FIELD_PARAM(r, obj, fieldname)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_print_object_field","title":"define BATT_PRINT_OBJECT_FIELD","text":"<pre><code>#define BATT_PRINT_OBJECT_FIELD(r, obj, fieldname)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_print_object_impl","title":"define BATT_PRINT_OBJECT_IMPL","text":"<pre><code>#define BATT_PRINT_OBJECT_IMPL(type, fields_seq)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_object_print_impl","title":"define BATT_OBJECT_PRINT_IMPL","text":"<pre><code>#define BATT_OBJECT_PRINT_IMPL(inline_decl, type, fields_tuple)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_equals_object_impl","title":"define BATT_EQUALS_OBJECT_IMPL","text":"<pre><code>#define BATT_EQUALS_OBJECT_IMPL(inline_decl, type, fields_seq)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_object_equals_impl","title":"define BATT_OBJECT_EQUALS_IMPL","text":"<pre><code>#define BATT_OBJECT_EQUALS_IMPL(inline_decl, type, fields_tuple)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_less_than_object_impl","title":"define BATT_LESS_THAN_OBJECT_IMPL","text":"<pre><code>#define BATT_LESS_THAN_OBJECT_IMPL(inline_decl, type, fields_seq)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#define-batt_object_less_than_impl","title":"define BATT_OBJECT_LESS_THAN_IMPL","text":"<pre><code>#define BATT_OBJECT_LESS_THAN_IMPL(inline_decl, type, fields_tuple)\n</code></pre>"},{"location":"_autogen/Files/operators_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_OPERATORS_HPP\n#define BATTERIES_OPERATORS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;boost/preprocessor/seq/for_each.hpp&gt;\n#include &lt;boost/preprocessor/stringize.hpp&gt;\n#include &lt;boost/preprocessor/tuple/to_seq.hpp&gt;\n#include &lt;tuple&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_UNWRAP(...) __VA_ARGS__\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_TOTALLY_ORDERED(inline_decl, left_type, right_type)                                             \\\n    BATT_UNWRAP inline_decl bool operator&gt;(const left_type&amp; l, const right_type&amp; r)                          \\\n    {                                                                                                        \\\n        return r &lt; l;                                                                                        \\\n    }                                                                                                        \\\n    BATT_UNWRAP inline_decl bool operator&lt;=(const left_type&amp; l, const right_type&amp; r)                         \\\n    {                                                                                                        \\\n        return !(l &gt; r);                                                                                     \\\n    }                                                                                                        \\\n    BATT_UNWRAP inline_decl bool operator&gt;=(const left_type&amp; l, const right_type&amp; r)                         \\\n    {                                                                                                        \\\n        return !(l &lt; r);                                                                                     \\\n    }\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_EQUALITY_COMPARABLE(inline_decl, left_type, right_type)                                         \\\n    BATT_UNWRAP inline_decl bool operator!=(const left_type&amp; l, const right_type&amp; r)                         \\\n    {                                                                                                        \\\n        return !(l == r);                                                                                    \\\n    }\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_OBJECT_FIELD_EXPR(r, obj, fieldname) (obj).fieldname\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_OBJECT_FIELD_PARAM(r, obj, fieldname) BATT_OBJECT_FIELD_EXPR(r, obj, fieldname),\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_PRINT_OBJECT_FIELD(r, obj, fieldname)                                                           \\\n    &lt;&lt; \" .\"                                                                                                  \\\n    &lt;&lt; BOOST_PP_STRINGIZE(fieldname) &lt;&lt; \"=\"                                                                  \\\n                                     &lt;&lt; ::batt::make_printable(BATT_OBJECT_FIELD_EXPR(r, obj, fieldname))    \\\n                                     &lt;&lt; \",\"\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_PRINT_OBJECT_IMPL(type, fields_seq)                                                             \\\n    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const type&amp; t)                                               \\\n    {                                                                                                        \\\n        return out &lt;&lt; ::batt::unqualified_name_of&lt;type&gt;()                                                    \\\n                   &lt;&lt; \"{\" BOOST_PP_SEQ_FOR_EACH(BATT_PRINT_OBJECT_FIELD, (t), fields_seq) &lt;&lt; \" }\";           \\\n    }\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_OBJECT_PRINT_IMPL(inline_decl, type, fields_tuple)                                              \\\n    BATT_UNWRAP inline_decl BATT_PRINT_OBJECT_IMPL(type, BOOST_PP_TUPLE_TO_SEQ(fields_tuple))\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_EQUALS_OBJECT_IMPL(inline_decl, type, fields_seq)                                               \\\n    BATT_UNWRAP inline_decl bool operator==(const type&amp; l, const type&amp; r)                                    \\\n    {                                                                                                        \\\n        return std::forward_as_tuple(                                                                        \\\n                   BOOST_PP_SEQ_FOR_EACH(BATT_OBJECT_FIELD_PARAM, (l), fields_seq) true) ==                  \\\n               std::forward_as_tuple(BOOST_PP_SEQ_FOR_EACH(BATT_OBJECT_FIELD_PARAM, (r), fields_seq) true);  \\\n    }\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_OBJECT_EQUALS_IMPL(inline_decl, type, fields_tuple)                                             \\\n    BATT_EQUALS_OBJECT_IMPL(inline_decl, type, BOOST_PP_TUPLE_TO_SEQ(fields_tuple))\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_LESS_THAN_OBJECT_IMPL(inline_decl, type, fields_seq)                                            \\\n    BATT_UNWRAP inline_decl bool operator&lt;(const type&amp; l, const type&amp; r)                                     \\\n    {                                                                                                        \\\n        return std::forward_as_tuple(BOOST_PP_SEQ_FOR_EACH(BATT_OBJECT_FIELD_PARAM, (l), fields_seq) true) &lt; \\\n               std::forward_as_tuple(BOOST_PP_SEQ_FOR_EACH(BATT_OBJECT_FIELD_PARAM, (r), fields_seq) true);  \\\n    }\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n#define BATT_OBJECT_LESS_THAN_IMPL(inline_decl, type, fields_tuple)                                          \\\n    BATT_LESS_THAN_OBJECT_IMPL(inline_decl, type, BOOST_PP_TUPLE_TO_SEQ(fields_tuple))\n}  //namespace batt\n#endif  // BATTERIES_OPERATORS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/optional_8hpp/","title":"batteries/optional.hpp","text":""},{"location":"_autogen/Files/optional_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/optional_8hpp/#classes","title":"Classes","text":"Name struct batt::NoneType struct batt::InPlaceInitType class batt::detail::OptionalBase class batt::detail::OptionalEmptyBase class batt::Optional class batt::Optional&lt; T &amp; &gt;"},{"location":"_autogen/Files/optional_8hpp/#defines","title":"Defines","text":"Name BATTERIES_OPTIONAL_HPP"},{"location":"_autogen/Files/optional_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/optional_8hpp/#define-batteries_optional_hpp","title":"define BATTERIES_OPTIONAL_HPP","text":"<pre><code>#define BATTERIES_OPTIONAL_HPP()\n</code></pre>"},{"location":"_autogen/Files/optional_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_OPTIONAL_HPP\n#define BATTERIES_OPTIONAL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;optional&gt;\n#ifdef BATT_USE_BOOST_OPTIONAL\n#include &lt;boost/optional.hpp&gt;\n#include &lt;boost/optional/optional_io.hpp&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nusing Optional = boost::optional&lt;T&gt;;\nnamespace {\ndecltype(auto) None = boost::none;\ndecltype(auto) InPlaceInit = boost::in_place_init;\n}  // namespace\nusing NoneType = std::decay_t&lt;decltype(boost::none)&gt;;\ntemplate &lt;typename... Args&gt;\nauto make_optional(Args&amp;&amp;... args)\n{\nreturn boost::make_optional(std::forward&lt;Args&gt;(args)...);\n}\ntemplate &lt;typename T, typename U, typename = decltype(std::declval&lt;const T&amp;&gt;() == std::declval&lt;const U&amp;&gt;())&gt;\ninline bool operator==(const Optional&lt;T&gt;&amp; l, const Optional&lt;U&gt;&amp; r)\n{\nreturn (l &amp;&amp; r &amp;&amp; *l == *r) || (!l &amp;&amp; !r);\n}\n}  // namespace batt\n#else\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Custom optional implementation.\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nstruct NoneType {\n};\ninline bool operator==(const NoneType&amp;, const NoneType&amp;)\n{\nreturn true;\n}\ninline bool operator!=(const NoneType&amp;, const NoneType&amp;)\n{\nreturn false;\n}\nstruct InPlaceInitType {\n};\nBATT_SUPPRESS_IF_GCC(\"-Wunused-variable\")\nnamespace {\nNoneType None;\nInPlaceInitType InPlaceInit;\n}  // namespace\nBATT_UNSUPPRESS_IF_GCC()\nnamespace detail {\ntemplate &lt;typename T&gt;\nclass OptionalBase\n{\nprotected:\nvoid* storage_address() noexcept\n{\nreturn &amp;this-&gt;storage_;\n}\nconst void* storage_address() const noexcept\n{\nreturn &amp;this-&gt;storage_;\n}\nprivate:\nstd::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; storage_;\n};\ntemplate &lt;typename T&gt;\nclass OptionalEmptyBase\n{\nprotected:\nvoid* storage_address() noexcept\n{\nreturn this;\n}\nconst void* storage_address() const noexcept\n{\nreturn this;\n}\n};\n}  //namespace detail\ntemplate &lt;typename T&gt;\nclass Optional\n: private std::conditional_t&lt;        //\ncan_be_empty_base&lt;T&gt;(),        //\ndetail::OptionalEmptyBase&lt;T&gt;,  //\ndetail::OptionalBase&lt;T&gt;        //\n&gt;\n{\npublic:\nstatic_assert(std::is_same_v&lt;T, std::decay_t&lt;T&gt;&gt;,\n\"Optional&lt;T&amp;&gt; is (partially) explicitly specialized below\");\nOptional() noexcept : valid_{false}\n{\n}\nOptional(NoneType) noexcept : valid_{false}\n{\n}\ntemplate &lt;typename... Args, typename = std::enable_if_t&lt;std::is_constructible_v&lt;T, Args&amp;&amp;...&gt;&gt;&gt;\nOptional(InPlaceInitType, Args&amp;&amp;... args) noexcept : valid_{false}\n{\nnew (this-&gt;storage_address()) T(BATT_FORWARD(args)...);\nthis-&gt;valid_ = true;\n}\nOptional(std::optional&lt;T&gt;&amp;&amp; init) noexcept : valid_{!!init}\n{\nif (this-&gt;valid_) {\nnew (this-&gt;storage_address()) T(std::move(*init));\n}\n}\ntemplate &lt;typename U,\ntypename = std::enable_if_t&lt;std::is_convertible_v&lt;U, T&gt; &amp;&amp; !std::is_same_v&lt;T, Optional&lt;U&gt;&gt;&gt;,\ntypename = batt::EnableIfNoShadow&lt;Optional, U&gt;&gt;\nOptional(Optional&lt;U&gt;&amp;&amp; u) noexcept : valid_{false}\n{\nif (u) {\nnew (this-&gt;storage_address()) T(std::move(*u));\nthis-&gt;valid_ = true;\n}\n}\ntemplate &lt;typename U,\ntypename = std::enable_if_t&lt;std::is_convertible_v&lt;U, T&gt; &amp;&amp; !std::is_same_v&lt;T, Optional&lt;U&gt;&gt;&gt;,\ntypename = batt::EnableIfNoShadow&lt;Optional, U&gt;&gt;\nOptional(const Optional&lt;U&gt;&amp; u) noexcept : valid_{false}\n{\nif (u) {\nnew (this-&gt;storage_address()) T(*u);\nthis-&gt;valid_ = true;\n}\n}\ntemplate &lt;typename... Args, typename = std::enable_if_t&lt;std::is_constructible_v&lt;T, Args&amp;&amp;...&gt;&gt;,\ntypename = batt::EnableIfNoShadow&lt;Optional, Args...&gt;&gt;\nOptional(Args&amp;&amp;... args) noexcept : valid_{false}\n{\nnew (this-&gt;storage_address()) T(BATT_FORWARD(args)...);\nthis-&gt;valid_ = true;\n}\nOptional(const T&amp; val) noexcept : valid_{false}\n{\nnew (this-&gt;storage_address()) T(val);\nthis-&gt;valid_ = true;\n}\n~Optional() noexcept\n{\nif (this-&gt;valid_) {\nthis-&gt;obj().~T();\n}\n}\nOptional(Optional&amp;&amp; that) noexcept : valid_{false}\n{\nif (that.valid_) {\nnew (this-&gt;storage_address()) T(std::move(that.obj()));\nvalid_ = true;\n}\n}\nOptional(const Optional&amp; that) noexcept : valid_{false}\n{\nif (that.valid_) {\nnew (this-&gt;storage_address()) T(that.obj());\nvalid_ = true;\n}\n}\nvoid reset() noexcept\n{\nif (this-&gt;valid_) {\nT&amp; obj_ref = this-&gt;obj();\nthis-&gt;valid_ = false;\nobj_ref.~T();\n}\n}\nOptional&amp; operator=(Optional&amp;&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;reset();\nif (that.valid_) {\nnew (this-&gt;storage_address()) T(std::move(that.obj()));\nthis-&gt;valid_ = true;\n}\n}\nreturn *this;\n}\nOptional&amp; operator=(const Optional&amp; that) noexcept\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nthis-&gt;reset();\nif (that.valid_) {\nnew (this-&gt;storage_address()) T(that.obj());\nthis-&gt;valid_ = true;\n}\n}\nreturn *this;\n}\ntemplate &lt;typename... Args&gt;\nT&amp; emplace(Args&amp;&amp;... args) noexcept\n{\nthis-&gt;reset();\nnew (this-&gt;storage_address()) T(BATT_FORWARD(args)...);\nthis-&gt;valid_ = true;\nreturn this-&gt;obj();\n}\ntemplate &lt;typename U&gt;\nT value_or(U&amp;&amp; else_val) const noexcept\n{\nif (this-&gt;valid_) {\nreturn this-&gt;obj();\n}\nreturn T(BATT_FORWARD(else_val));\n}\ntemplate &lt;typename Fn&gt;\nT or_else(Fn&amp;&amp; fn) const noexcept(noexcept(std::declval&lt;Fn&gt;()()))\n{\nif (this-&gt;valid_) {\nreturn this-&gt;obj();\n}\nreturn BATT_FORWARD(fn)();\n}\ntemplate &lt;typename Fn, typename U = std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\nOptional&lt;U&gt; map(Fn&amp;&amp; fn) const noexcept\n{\nif (this-&gt;valid_) {\nreturn BATT_FORWARD(fn)(this-&gt;obj());\n}\nreturn None;\n}\ntemplate &lt;typename Fn, typename OptionalU = std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\nOptionalU flat_map(Fn&amp;&amp; fn) const noexcept\n{\nif (this-&gt;valid_) {\nreturn BATT_FORWARD(fn)(this-&gt;obj());\n}\nreturn None;\n}\nexplicit operator bool() const noexcept\n{\nreturn this-&gt;valid_;\n}\nbool has_value() const noexcept\n{\nreturn this-&gt;valid_;\n}\nOptional&amp; operator=(NoneType) noexcept\n{\nthis-&gt;reset();\nreturn *this;\n}\nT&amp; operator*() &amp; noexcept\n{\nreturn this-&gt;obj();\n}\nconst T&amp; operator*() const&amp; noexcept\n{\nreturn this-&gt;obj();\n}\nT operator*() &amp;&amp; noexcept\n{\nreturn std::move(this-&gt;obj());\n}\nT operator*() const&amp;&amp; noexcept = delete;\nT* operator-&gt;() noexcept\n{\nreturn &amp;this-&gt;obj();\n}\nconst T* operator-&gt;() const noexcept\n{\nreturn &amp;this-&gt;obj();\n}\nT* get_ptr() noexcept\n{\nreturn &amp;this-&gt;obj();\n}\nconst T* get_ptr() const noexcept\n{\nreturn &amp;this-&gt;obj();\n}\nprivate:\nT&amp; obj() noexcept\n{\nBATT_ASSERT(this-&gt;valid_);\nreturn *(T*)this-&gt;storage_address();\n}\nconst T&amp; obj() const noexcept\n{\nBATT_ASSERT(this-&gt;valid_);\nreturn *(const T*)this-&gt;storage_address();\n}\nbool valid_ = false;\n};\ntemplate &lt;typename T&gt;\nclass Optional&lt;T&amp;&gt;\n{\npublic:\nOptional() noexcept : Optional{None}\n{\n}\nOptional(NoneType) noexcept : ptr_{nullptr}\n{\n}\ntemplate &lt;typename... Args, typename = std::enable_if_t&lt;std::is_constructible_v&lt;T&amp;, Args&amp;&amp;...&gt;&gt;&gt;\nOptional(InPlaceInitType, Args&amp;&amp;... args) noexcept\n: Optional{[](T&amp; ref) -&gt; T&amp; {\nreturn ref;\n}(BATT_FORWARD(args)...)}\n{\n}\ntemplate &lt;\ntypename U,\ntypename = std::enable_if_t&lt;std::is_convertible_v&lt;U*, T*&gt; &amp;&amp; !std::is_same_v&lt;T, const Optional&lt;U&gt;&gt;&gt;,\ntypename = batt::EnableIfNoShadow&lt;Optional, U&gt;&gt;\nOptional(const Optional&lt;U&amp;&gt;&amp; u) noexcept : ptr_{u.ptr_}\n{\n}\n/*implicit*/ Optional(T&amp; ref) noexcept : ptr_{&amp;ref}\n{\n}\nOptional(const Optional&amp;) = default;\nOptional&amp; operator=(const Optional&amp;) = default;\n~Optional() noexcept\n{\n// nothing to do.\n}\ntemplate &lt;typename Fn, typename U = std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\nOptional&lt;U&gt; map(Fn&amp;&amp; fn) const noexcept\n{\nif (this-&gt;ptr_) {\nreturn BATT_FORWARD(fn)(*this-&gt;ptr_);\n}\nreturn None;\n}\ntemplate &lt;typename Fn, typename OptionalU = std::invoke_result_t&lt;Fn, const T&amp;&gt;&gt;\nOptionalU flat_map(Fn&amp;&amp; fn) const noexcept\n{\nif (this-&gt;ptr_) {\nreturn BATT_FORWARD(fn)(*this-&gt;ptr_);\n}\nreturn None;\n}\nT&amp; operator*() const noexcept\n{\nreturn *this-&gt;ptr_;\n}\nT* operator-&gt;() noexcept\n{\nreturn this-&gt;ptr_;\n}\nconst T* operator-&gt;() const noexcept\n{\nreturn this-&gt;ptr_;\n}\nbool has_value() const noexcept\n{\nreturn this-&gt;ptr_ != nullptr;\n}\nexplicit operator bool() const noexcept\n{\nreturn this-&gt;has_value();\n}\nbool operator!() const noexcept\n{\nreturn this-&gt;ptr_ == nullptr;\n}\nT&amp; emplace(T&amp; ref) noexcept\n{\nthis-&gt;ptr_ = &amp;ref;\nreturn *this-&gt;ptr_;\n}\nOptional&amp; operator=(NoneType) noexcept\n{\nthis-&gt;ptr_ = nullptr;\nreturn *this;\n}\nT&amp; value_or(T&amp; other) noexcept\n{\nif (this-&gt;ptr_) {\nreturn *this-&gt;ptr_;\n}\nreturn other;\n}\ntemplate &lt;typename Fn&gt;\nT&amp; or_else(Fn&amp;&amp; fn) const noexcept(noexcept(std::declval&lt;Fn&gt;()()))\n{\nif (this-&gt;ptr_) {\nreturn *this-&gt;ptr_;\n}\nreturn BATT_FORWARD(fn)();\n}\nprivate:\nT* ptr_ = nullptr;\n};\ntemplate &lt;typename T0, typename T1&gt;\ninline bool operator==(const Optional&lt;T0&gt;&amp; v0, const Optional&lt;T1&gt;&amp; v1)\n{\nreturn (v0 &amp;&amp; v1 &amp;&amp; (*v0 == *v1)) || (!v0 &amp;&amp; !v1);\n}\ntemplate &lt;typename T0, typename T1&gt;\ninline bool operator!=(const Optional&lt;T0&gt;&amp; v0, const Optional&lt;T1&gt;&amp; v1)\n{\nreturn !(v0 == v1);\n}\ntemplate &lt;typename T0, typename T1&gt;\ninline bool operator==(const Optional&lt;T0&gt;&amp; v0, const T1&amp; v1)\n{\nreturn v0 &amp;&amp; (*v0 == v1);\n}\ntemplate &lt;typename T0, typename T1&gt;\ninline bool operator!=(const Optional&lt;T0&gt;&amp; v0, const T1&amp; v1)\n{\nreturn !(v0 == v1);\n}\ntemplate &lt;typename T0, typename T1&gt;\ninline bool operator==(const T0&amp; v0, const Optional&lt;T1&gt;&amp; v1)\n{\nreturn v1 &amp;&amp; (v0 == *v1);\n}\ntemplate &lt;typename T0, typename T1&gt;\ninline bool operator!=(const T0&amp; v0, const Optional&lt;T1&gt;&amp; v1)\n{\nreturn !(v0 == v1);\n}\ntemplate &lt;typename T&gt;\ninline bool operator==(NoneType, const Optional&lt;T&gt;&amp; v)\n{\nreturn !v;\n}\ntemplate &lt;typename T&gt;\ninline bool operator!=(NoneType, const Optional&lt;T&gt;&amp; v)\n{\nreturn !(None == v);\n}\ntemplate &lt;typename T&gt;\ninline bool operator==(const Optional&lt;T&gt;&amp; v, NoneType)\n{\nreturn !v;\n}\ntemplate &lt;typename T&gt;\ninline bool operator!=(const Optional&lt;T&gt;&amp; v, NoneType)\n{\nreturn !(v == None);\n}\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Optional&lt;T&gt;&amp; t)\n{\nif (!t) {\nreturn out &lt;&lt; \"--\";\n}\nreturn out &lt;&lt; make_printable(*t);\n}\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const NoneType&amp;)\n{\nreturn out &lt;&lt; \"--\";\n}\ntemplate &lt;typename T&gt;\nOptional&lt;std::decay_t&lt;T&gt;&gt; make_optional(T&amp;&amp; val) noexcept\n{\nreturn {BATT_FORWARD(val)};\n}\n}  // namespace batt\n#endif\nnamespace batt {\ntemplate &lt;typename T&gt;\ndecltype(auto) get_or_panic(Optional&lt;T&gt;&amp; opt)\n{\nBATT_CHECK(opt);\nreturn *opt;\n}\ntemplate &lt;typename T&gt;\ndecltype(auto) get_or_panic(const Optional&lt;T&gt;&amp; opt)\n{\nBATT_CHECK(opt);\nreturn *opt;\n}\ntemplate &lt;typename T&gt;\ndecltype(auto) get_or_panic(Optional&lt;T&gt;&amp;&amp; opt)\n{\nBATT_CHECK(opt);\nreturn std::move(*opt);\n}\n}  // namespace batt\n#endif  // BATTERIES_OPTIONAL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/parallel__accumulate_8hpp/","title":"batteries/algo/parallel_accumulate.hpp","text":""},{"location":"_autogen/Files/parallel__accumulate_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parallel__accumulate_8hpp/#define-batteries_algo_parallel_accumulate_hpp","title":"define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP","text":"<pre><code>#define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP()\n</code></pre>"},{"location":"_autogen/Files/parallel__accumulate_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP\n#define BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/slice.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n#include &lt;numeric&gt;\n#include &lt;thread&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Iter, typename T, typename BinaryOp&gt;\nSlice&lt;T&gt; parallel_accumulate_partial(WorkContext&amp; context,                   //\nIter first, Iter last, T init,          //\nconst BinaryOp&amp; binary_op, T identity,  //\nconst Slice&lt;T&gt;&amp; task_result_buffer,     //\nconst WorkSliceParams&amp; params)\n{\nif (first == last) {\nreturn as_slice(task_result_buffer.begin(), 0);\n}\nif (params.max_tasks == 1) {\nBATT_CHECK_GE(task_result_buffer.size(), 1u);\ntask_result_buffer.front() = std::accumulate(first, last, init, binary_op);\nreturn as_slice(task_result_buffer.begin(), 1);\n}\nconst WorkSlicePlan plan{params, first, last};\nSlice&lt;T&gt; task_results = as_slice(task_result_buffer.begin(), plan.n_tasks);\nstd::fill(task_results.begin(), task_results.end(), identity);\nif (!task_results.empty()) {\ntask_results.front() = init;\n}\nBATT_CHECK_OK(slice_work(context, plan,\n/*gen_work_fn=*/\n[&amp;](TaskIndex task_index, TaskOffset task_offset, TaskSize task_size) {\nreturn\n[task_index, task_offset, task_size, first, &amp;binary_op, task_results] {\nauto task_begin = std::next(first, task_offset);\nauto task_end = std::next(task_begin, task_size);\ntask_results[task_index] = std::accumulate(\ntask_begin, task_end, task_results[task_index], binary_op);\n};\n}))\n&lt;&lt; \"context must not be closed!\";\nreturn task_results;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename Iter, typename T, typename BinaryOp&gt;\nT parallel_accumulate(WorkerPool&amp; worker_pool,                  //\nIter first, Iter last, T init,            //\nconst BinaryOp&amp; binary_op, T identity,    //\nTaskSize min_task_size = TaskSize{4096},  //\nTaskCount max_tasks = TaskCount{std::thread::hardware_concurrency()})\n{\nif (first == last) {\nreturn init;\n}\nBATT_CHECK_GT(min_task_size, 0);\nBATT_CHECK_GT(max_tasks, 0);\nconst InputSize input_size{BATT_CHECKED_CAST(usize, std::distance(first, last))};\nif (max_tasks == 1 || input_size &lt;= std::max&lt;usize&gt;(min_task_size, max_tasks)) {\nreturn std::accumulate(first, last, init, binary_op);\n}\nSmallVec&lt;T, 64&gt; task_result_buffer(max_tasks);\nSlice&lt;T&gt; task_results;\n{\nScopedWorkContext context{worker_pool};\ntask_results = parallel_accumulate_partial(context,                       //\nfirst, last, init,             //\nbinary_op, identity,           //\nas_slice(task_result_buffer),  //\nWorkSliceParams{min_task_size, max_tasks});\n}\nBATT_CHECK(!task_results.empty());\nreturn parallel_accumulate(worker_pool,  //\nstd::next(task_results.begin()), task_results.end(),\ntask_results.front(),  //\nbinary_op, identity,   //\nmin_task_size,         //\nmax_tasks);\n}\n}  // namespace batt\n#endif  // BATTERIES_ALGO_PARALLEL_ACCUMULATE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/parallel__copy_8hpp/","title":"batteries/algo/parallel_copy.hpp","text":""},{"location":"_autogen/Files/parallel__copy_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/parallel__copy_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_PARALLEL_COPY_HPP"},{"location":"_autogen/Files/parallel__copy_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parallel__copy_8hpp/#define-batteries_algo_parallel_copy_hpp","title":"define BATTERIES_ALGO_PARALLEL_COPY_HPP","text":"<pre><code>#define BATTERIES_ALGO_PARALLEL_COPY_HPP()\n</code></pre>"},{"location":"_autogen/Files/parallel__copy_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_PARALLEL_COPY_HPP\n#define BATTERIES_ALGO_PARALLEL_COPY_HPP\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename Src, typename Dst&gt;\nvoid parallel_copy(WorkContext&amp; work_context,   //\nSrc src_begin, Src src_end,  //\nDst dst_begin,               //\nTaskSize min_task_size,      //\nTaskCount max_tasks)\n{\nif (max_tasks == 1) {\nstd::copy(src_begin, src_end, dst_begin);\nreturn;\n}\nconst WorkSlicePlan plan{WorkSliceParams{min_task_size, max_tasks}, src_begin, src_end};\nBATT_CHECK_OK(slice_work(work_context, plan,\n/*gen_work_fn=*/\n[&amp;](usize /*task_index*/, isize task_offset, isize task_size) {\nreturn [src_begin, dst_begin, task_offset, task_size] {\nauto task_src_begin = std::next(src_begin, task_offset);\nauto task_src_end = std::next(task_src_begin, task_size);\nauto task_dst_begin = std::next(dst_begin, task_offset);\nstd::copy(task_src_begin, task_src_end, task_dst_begin);\n};\n}))\n&lt;&lt; \"work_context must not be closed!\";\n}\n}  // namespace batt\n#endif  // BATTERIES_ALGO_PARALLEL_COPY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/parallel__merge_8hpp/","title":"batteries/algo/parallel_merge.hpp","text":""},{"location":"_autogen/Files/parallel__merge_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/parallel__merge_8hpp/#classes","title":"Classes","text":"Name struct batt::detail::FirstPhase struct batt::detail::SecondPhase struct batt::detail::ThirdPhase"},{"location":"_autogen/Files/parallel__merge_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_PARALLEL_MERGE_HPP"},{"location":"_autogen/Files/parallel__merge_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parallel__merge_8hpp/#define-batteries_algo_parallel_merge_hpp","title":"define BATTERIES_ALGO_PARALLEL_MERGE_HPP","text":"<pre><code>#define BATTERIES_ALGO_PARALLEL_MERGE_HPP()\n</code></pre>"},{"location":"_autogen/Files/parallel__merge_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_PARALLEL_MERGE_HPP\n#define BATTERIES_ALGO_PARALLEL_MERGE_HPP\n#include &lt;batteries/algo/parallel_copy.hpp&gt;\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nnamespace detail {\nstruct FirstPhase;\nstruct SecondPhase;\nstruct ThirdPhase;\nstruct FirstPhase {\nstatic const char* name()\n{\nreturn \"FirstPhase\";\n}\nusing NextPhase = SecondPhase;\ntemplate &lt;typename Src0, typename Src1&gt;\nstatic const Src0&amp; fixed_iter(const Src0&amp; src_0, const Src1&amp; /*src_1*/)\n{\nreturn src_0;\n}\ntemplate &lt;typename Src0, typename Src1&gt;\nstatic const Src1&amp; search_iter(const Src0&amp; /*src_0*/, const Src1&amp; src_1)\n{\nreturn src_1;\n}\ntemplate &lt;typename Fixed, typename Search&gt;\nstatic const Fixed&amp; src_0_iter(const Fixed&amp; fixed, const Search&amp; /*search*/)\n{\nreturn fixed;\n}\ntemplate &lt;typename Fixed, typename Search&gt;\nstatic const Search&amp; src_1_iter(const Fixed&amp; /*fixed*/, const Search&amp; search)\n{\nreturn search;\n}\n};\nstruct SecondPhase {\nstatic const char* name()\n{\nreturn \"SecondPhase\";\n}\nusing NextPhase = ThirdPhase;\ntemplate &lt;typename Src0, typename Src1&gt;\nstatic const Src1&amp; fixed_iter(const Src0&amp; /*src_0*/, const Src1&amp; src_1)\n{\nreturn src_1;\n}\ntemplate &lt;typename Src0, typename Src1&gt;\nstatic const Src0&amp; search_iter(const Src0&amp; src_0, const Src1&amp; /*src_1*/)\n{\nreturn src_0;\n}\ntemplate &lt;typename Fixed, typename Search&gt;\nstatic const Search&amp; src_0_iter(const Fixed&amp; /*fixed*/, const Search&amp; search)\n{\nreturn search;\n}\ntemplate &lt;typename Fixed, typename Search&gt;\nstatic const Fixed&amp; src_1_iter(const Fixed&amp; fixed, const Search&amp; /*search*/)\n{\nreturn fixed;\n}\n};\nstruct ThirdPhase : SecondPhase {\nstatic const char* name()\n{\nreturn \"ThirdPhase\";\n}\n};\nstatic constexpr isize kThreshold = 1400;\nstatic constexpr isize kMaxShards = 8;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Fixed, typename Search, typename Dst, typename Compare, typename Phase&gt;\nvoid parallel_merge_fanout(WorkContext&amp; context,                    //\nFixed fixed_begin, Fixed fixed_end,      //\nSearch search_begin, Search search_end,  //\nDst dst_begin,                           //\nCompare&amp;&amp; compare,                       //\nusize min_task_size,                     //\nusize max_tasks,                         //\nbatt::StaticType&lt;Phase&gt;);\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Src0, typename Src1, typename Dst, typename Compare, typename Phase&gt;\nvoid parallel_merge_impl(WorkContext&amp; context,              //\nSrc0 src_0_begin, Src0 src_0_end,  //\nSrc1 src_1_begin, Src1 src_1_end,  //\nDst dst_begin,                     //\nCompare&amp;&amp; compare,                 //\nusize min_task_size,               //\nusize max_tasks,                   //\nbatt::StaticType&lt;Phase&gt; phase)\n{\nconst isize src_0_size = std::distance(src_0_begin, src_0_end);\nconst isize src_1_size = std::distance(src_1_begin, src_1_end);\n// Trivial merge edge cases.\n//\nif (src_0_begin == src_0_end) {\nreturn parallel_copy(context, src_1_begin, src_1_end, dst_begin,  //\n/*min_task_size=*/TaskSize{0},\n/*max_tasks=*/TaskCount{1});\n}\nBATT_CHECK_LT(src_0_begin, src_0_end);\nif (src_1_begin == src_1_end) {\nreturn parallel_copy(context, src_0_begin, src_0_end, dst_begin,  //\n/*min_task_size=*/TaskSize{0},\n/*max_tasks=*/TaskCount{1});\n}\nBATT_CHECK_LT(src_1_begin, src_1_end);\n// Sequential merge base case.\n//\nif (std::is_same_v&lt;Phase, ThirdPhase&gt; || src_0_size + src_1_size &lt;= (isize)min_task_size) {\nstd::merge(src_0_begin, src_0_end, src_1_begin, src_1_end, dst_begin, compare);\nreturn;\n}\n// General case: break up the work and do it in parallel.\n//\nauto fixed_begin = Phase::fixed_iter(src_0_begin, src_1_begin);\nauto fixed_end = Phase::fixed_iter(src_0_end, src_1_end);\nauto search_begin = Phase::search_iter(src_0_begin, src_1_begin);\nauto search_end = Phase::search_iter(src_0_end, src_1_end);\nparallel_merge_fanout(context,                   //\nfixed_begin, fixed_end,    //\nfixed_begin, fixed_end,    //\nsearch_begin, search_end,  //\ndst_begin,                 //\ncompare,                   //\nmin_task_size,             //\nmax_tasks,                 //\nphase);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Fixed, typename Search, typename Dst, typename Compare, typename Phase&gt;\nvoid parallel_merge_fanout(WorkContext&amp; context,                          //\nFixed fixed_begin, Fixed fixed_end,            //\nFixed fixed_part_begin, Fixed fixed_part_end,  //\nSearch search_begin, Search search_end,        //\nDst dst_begin,                                 //\nCompare&amp;&amp; compare,                             //\nusize min_task_size,                           //\nusize max_tasks,                               //\nbatt::StaticType&lt;Phase&gt;)\n{\nconst usize max_tasks_per_phase = (max_tasks + 1) / 2;\nisize fixed_part_size = std::distance(fixed_part_begin, fixed_part_end);\nconst isize target_size =\nstd::max((fixed_part_size + max_tasks_per_phase - 1) / max_tasks_per_phase, (min_task_size + 1) / 2);\nwhile (fixed_part_begin != fixed_part_end) {\nisize shard_size = std::min(target_size, fixed_part_size);\nBATT_CHECK_GT(shard_size, 0);\n// Set up the extents of the next task's shard.  `shard_size` may need to be increased if the\n// initial shard end estimate cuts into the middle of an equivalence group.\n//\nconst Fixed fixed_shard_begin = fixed_part_begin;\nFixed fixed_shard_back = std::next(fixed_shard_begin, shard_size - 1);\nFixed fixed_shard_end = std::next(fixed_shard_back);\n// Advance `fixed_shard_end` to include the entire equivalence group at the end of the fixed\n// shard.\n//  TODO [tastolfi 2021-09-02] use std::upper_bound here?\n//\nwhile (fixed_shard_end != fixed_part_end &amp;&amp; !compare(*fixed_shard_back, *fixed_shard_end)) {\nBATT_CHECK_LT(shard_size, fixed_part_size);\nfixed_shard_back = fixed_shard_end;\n++fixed_shard_end;\n++shard_size;\n}\n// MUST be after we advance `fixed_shard_end` above.\n//\nconst bool is_first = (fixed_shard_begin == fixed_begin);\nconst bool is_last = (fixed_shard_end == fixed_end);\n// Capture the shard variables.\n//\nauto work_fn = [&amp;context,                               //\nfixed_shard_begin, fixed_shard_end,     //\nsearch_begin, search_end,               //\ndst_begin, compare, is_first, is_last,  //\nmin_task_size, max_tasks] {\nauto search_shard_begin = [&amp;] {\nif (is_first) {\nreturn search_begin;\n}\nreturn std::lower_bound(search_begin, search_end, *fixed_shard_begin, compare);\n}();\nauto search_shard_end = [&amp;] {\nif (is_last) {\nreturn search_end;\n}\nBATT_CHECK_LE(search_shard_begin, search_end);\nreturn std::lower_bound(search_shard_begin, search_end, *fixed_shard_end, compare);\n}();\nauto src_0_shard_begin = Phase::src_0_iter(fixed_shard_begin, search_shard_begin);\nauto src_0_shard_end = Phase::src_0_iter(fixed_shard_end, search_shard_end);\nBATT_CHECK_LE(src_0_shard_begin, src_0_shard_end);\nauto src_1_shard_begin = Phase::src_1_iter(fixed_shard_begin, search_shard_begin);\nauto src_1_shard_end = Phase::src_1_iter(fixed_shard_end, search_shard_end);\nBATT_CHECK_LE(src_1_shard_begin, src_1_shard_end);\nauto dst_shard_begin = std::next(dst_begin, std::distance(search_begin, search_shard_begin));\nparallel_merge_impl(context,                             //\nsrc_0_shard_begin, src_0_shard_end,  //\nsrc_1_shard_begin, src_1_shard_end,  //\ndst_shard_begin,                     //\ncompare,                             //\nmin_task_size,                       //\nmax_tasks,                           //\nbatt::StaticType&lt;typename Phase::NextPhase&gt;{});\n};\nif (fixed_shard_end != fixed_part_end) {\nBATT_CHECK_OK(context.async_run(work_fn)) &lt;&lt; \"context must not be closed!\";\n} else {\nwork_fn();\n}\nfixed_part_begin = fixed_shard_end;\nstd::advance(dst_begin, shard_size);\nfixed_part_size -= shard_size;\n}\n}\n}  // namespace detail\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename Src0, typename Src1, typename Dst, typename Compare&gt;\nvoid parallel_merge(WorkerPool&amp; worker_pool,                                   //\nSrc0 src_0_begin, Src0 src_0_end,                          //\nSrc1 src_1_begin, Src1 src_1_end,                          //\nDst dst_begin,                                             //\nCompare&amp;&amp; compare,                                         //\nusize min_task_size = 1400,                                //\nusize max_tasks = std::thread::hardware_concurrency() / 2  //\n)\n{\nScopedWorkContext context{worker_pool};\ndetail::parallel_merge_impl(context,                 //\nsrc_0_begin, src_0_end,  //\nsrc_1_begin, src_1_end,  //\ndst_begin,               //\nBATT_FORWARD(compare),   //\nmin_task_size,           //\nmax_tasks,               //\nbatt::StaticType&lt;detail::FirstPhase&gt;{});\n}\ntemplate &lt;typename Src0, typename Src1, typename Dst, typename Compare&gt;\nvoid parallel_merge(WorkContext&amp; context,                                      //\nSrc0 src_0_begin, Src0 src_0_end,                          //\nSrc1 src_1_begin, Src1 src_1_end,                          //\nDst dst_begin,                                             //\nCompare&amp;&amp; compare,                                         //\nusize min_task_size = 1400,                                //\nusize max_tasks = std::thread::hardware_concurrency() / 2  //\n)\n{\ndetail::parallel_merge_impl(context,                 //\nsrc_0_begin, src_0_end,  //\nsrc_1_begin, src_1_end,  //\ndst_begin,               //\nBATT_FORWARD(compare),   //\nmin_task_size,           //\nmax_tasks,               //\nbatt::StaticType&lt;detail::FirstPhase&gt;{});\n}\n}  // namespace batt\n#endif  // BATTERIES_ALGO_PARALLEL_MERGE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/","title":"batteries/state_machine_model/parallel_model_check_state.hpp","text":""},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#classes","title":"Classes","text":"Name struct batt::detail::ModelCheckShardMetrics class batt::detail::ParallelModelCheckState"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#define-batteries_state_machine_model_parallel_model_check_state_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP()\n</code></pre>"},{"location":"_autogen/Files/parallel__model__check__state_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\n#include &lt;vector&gt;\nnamespace batt {\nnamespace detail {\nstruct ModelCheckShardMetrics {\ni64 stall_count = 0;\ni64 flush_count = 0;\ni64 send_count = 0;\ni64 recv_count = 0;\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const ModelCheckShardMetrics&amp; t)\n{\nreturn out &lt;&lt; \"ShardMetrics{\"                                                           //\n&lt;&lt; \".stall=\" &lt;&lt; t.stall_count                                                //\n&lt;&lt; \", .flush=\" &lt;&lt; t.flush_count                                              //\n&lt;&lt; \", .send=\" &lt;&lt; t.send_count                                                //\n&lt;&lt; \", .recv=\" &lt;&lt; t.recv_count                                                //\n&lt;&lt; \", .stall_rate=\" &lt;&lt; double(t.stall_count + 1) / double(t.recv_count + 1)  //\n&lt;&lt; \",}\";\n}\ntemplate &lt;typename Branch&gt;\nclass ParallelModelCheckState\n{\npublic:\nstatic constexpr u64 kStallEpochUnit = u64{1} &lt;&lt; 32;\nstatic constexpr u64 kStallCountMask = kStallEpochUnit - 1;\nstatic constexpr u64 kStallEpochMask = ~kStallCountMask;\nusing ShardMetrics = ModelCheckShardMetrics;\nexplicit ParallelModelCheckState(usize n_shards)\n: shard_count{n_shards}\n, stalled(this-&gt;shard_count)\n, recv_queues(this-&gt;shard_count)\n, send_queues(this-&gt;shard_count)\n, shard_metrics(this-&gt;shard_count)\n, local_consume_count(this-&gt;shard_count)\n{\nBATT_CHECK_EQ(this-&gt;stalled.size(), this-&gt;shard_count);\nBATT_CHECK_EQ(this-&gt;local_consume_count.size(), this-&gt;shard_count);\nBATT_CHECK_EQ(this-&gt;recv_queues.size(), this-&gt;shard_count);\nBATT_CHECK_EQ(this-&gt;send_queues.size(), this-&gt;shard_count);\nBATT_CHECK_EQ(this-&gt;shard_metrics.size(), this-&gt;shard_count);\nfor (std::unique_ptr&lt;std::atomic&lt;bool&gt;[]&gt;&amp; stalled_per_other : this-&gt;stalled) {\nstalled_per_other.reset(new std::atomic&lt;bool&gt;[this-&gt;shard_count]);\nfor (usize i = 0; i &lt; this-&gt;shard_count; ++i) {\nstalled_per_other[i].store(false);\n}\n}\nfor (auto&amp; recv_queues_per_dst : this-&gt;recv_queues) {\nrecv_queues_per_dst = std::make_unique&lt;Queue&lt;std::vector&lt;Branch&gt;&gt;&gt;();\n}\nfor (CpuCacheLineIsolated&lt;std::vector&lt;std::vector&lt;Branch&gt;&gt;&gt;&amp;  //\nsend_queues_per_src : this-&gt;send_queues) {\nsend_queues_per_src-&gt;resize(this-&gt;shard_count);\n}\nfor (auto&amp; count : this-&gt;local_consume_count) {\n*count = 0;\n}\n}\nusize find_shard(const Branch&amp; branch) const\n{\nconst usize branch_hash = hash(branch);\nconst usize branch_shard = branch_hash / this-&gt;hash_space_per_shard;\nreturn branch_shard;\n}\nvoid send(usize src_i, usize dst_i, Branch&amp;&amp; branch)\n{\nstd::vector&lt;std::vector&lt;Branch&gt;&gt;&amp; src_send_queues = *this-&gt;send_queues[src_i];\nstd::vector&lt;Branch&gt;&amp; src_dst_send_queue = src_send_queues[dst_i];\nsrc_dst_send_queue.emplace_back(std::move(branch));\nthis-&gt;metrics(src_i).send_count += 1;\nif (this-&gt;stalled[src_i][dst_i].load()) {\nthis-&gt;queue_push(dst_i, &amp;src_dst_send_queue);\n}\n}\nvoid flush_all(usize src_i)\n{\nstd::vector&lt;std::vector&lt;Branch&gt;&gt;&amp; src_send_queues = *this-&gt;send_queues[src_i];\nusize dst_i = 0;\nfor (std::vector&lt;Branch&gt;&amp; src_dst_send_queue : src_send_queues) {\nconst auto advance_dst_i = finally([&amp;dst_i] {\ndst_i += 1;\n});\nif (src_dst_send_queue.empty()) {\ncontinue;\n}\nthis-&gt;metrics(src_i).flush_count += 1;\nthis-&gt;queue_push(dst_i, &amp;src_dst_send_queue);\n}\n}\nvoid queue_push(usize dst_i, std::vector&lt;Branch&gt;* branch)\n{\nstd::vector&lt;Branch&gt; to_send;\nstd::swap(to_send, *branch);\nthis-&gt;total_pending_count-&gt;fetch_add(1);\nconst Status success = this-&gt;recv_queues[dst_i]-&gt;push(std::move(to_send));\nBATT_CHECK_OK(success) &lt;&lt; BATT_INSPECT(dst_i) &lt;&lt; BATT_INSPECT(this-&gt;shard_count);\nthis-&gt;queue_push_count.fetch_add(1);\n}\nStatusOr&lt;usize&gt; recv(usize shard_i, std::deque&lt;Branch&gt;&amp; local_queue)\n{\nQueue&lt;std::vector&lt;Branch&gt;&gt;&amp; src_queue = *this-&gt;recv_queues[shard_i];\nthis-&gt;metrics(shard_i).recv_count += 1;\nconst auto transfer_batch = [this, &amp;local_queue, shard_i](auto&amp; maybe_next_batch) {\nstd::vector&lt;Branch&gt;&amp; next_batch = *maybe_next_batch;\nthis-&gt;queue_pop_count.fetch_add(1);\nusize count = next_batch.size();\nlocal_queue.insert(local_queue.end(),                            //\nstd::make_move_iterator(next_batch.begin()),  //\nstd::make_move_iterator(next_batch.end()));\n*this-&gt;local_consume_count[shard_i] += 1;\nreturn count;\n};\n// Try to pop branches without stalling.\n//\n{\nOptional&lt;std::vector&lt;Branch&gt;&gt; next_batch = src_queue.try_pop_next();\nif (next_batch) {\nreturn transfer_batch(next_batch);\n}\n}\nthis-&gt;metrics(shard_i).stall_count += 1;\n// Set \"stalled\" flags for this shard so that other shards know to send queued batches ASAP.\n//\nfor (usize other_i = 0; other_i &lt; shard_count; ++other_i) {\nthis-&gt;stalled[other_i][shard_i].store(true);\n}\nconst auto reset_stall_flags = finally([&amp;] {\n// Clear \"stalled\" flags, now that we have a some branches to process, or the entire job is\n// done.\n//\nfor (usize other_i = 0; other_i &lt; shard_count; ++other_i) {\nthis-&gt;stalled[other_i][shard_i].store(false);\n}\n});\n// Because we are about to go to put the current task to sleep awaiting the next batch, flush all\n// outgoing batches so no other shards are blocked on `shard_i`.\n//\nthis-&gt;flush_all(shard_i);\n// Now that we've flushed all outgoing branches, it is safe to ack the read message timestamp\n// upper bound for this shard.\n//\ni64 n_to_consume = 0;\nstd::swap(n_to_consume, *this-&gt;local_consume_count[shard_i]);\nconst i64 old_value = this-&gt;total_pending_count-&gt;fetch_sub(n_to_consume);\n// Check for deadlock; if all shards are stalled, then the branch-state-space has been fully explored\n// and we are done!\n//\nif (old_value - n_to_consume == 0) {\nthis-&gt;close_all(shard_i);\n//\n// More than one shard task may call close_all; this is fine!\n}\nStatusOr&lt;std::vector&lt;Branch&gt;&gt; next_batch = src_queue.await_next();\nBATT_REQUIRE_OK(next_batch);\nreturn transfer_batch(next_batch);\n}\nvoid close_all(usize shard_i, bool allow_pending = false)\n{\nfor (usize dst_i = 0; dst_i &lt; this-&gt;recv_queues.size(); ++dst_i) {\nconst auto&amp; p_queue = this-&gt;recv_queues[dst_i];\nbool queue_is_empty = p_queue-&gt;empty();\nif (!queue_is_empty) {\nTask::sleep(boost::posix_time::milliseconds(1200));\nqueue_is_empty = p_queue-&gt;empty();\n}\nBATT_CHECK(allow_pending || queue_is_empty)\n&lt;&lt; BATT_INSPECT(shard_i) &lt;&lt; BATT_INSPECT(dst_i) &lt;&lt; BATT_INSPECT(queue_is_empty)\n&lt;&lt; BATT_INSPECT(p_queue-&gt;empty()) &lt;&lt; BATT_INSPECT(allow_pending)\n&lt;&lt; BATT_INSPECT(p_queue-&gt;size()) &lt;&lt; BATT_INSPECT(this-&gt;shard_count);\np_queue-&gt;close();\n}\n}\nvoid finished(usize shard_i)\n{\nthis-&gt;flush_all(shard_i);\nthis-&gt;recv_queues[shard_i]-&gt;close();\nthis-&gt;queue_pop_count.fetch_add(this-&gt;recv_queues[shard_i]-&gt;drain());\n}\nShardMetrics&amp; metrics(usize shard_i)\n{\nreturn *this-&gt;shard_metrics[shard_i];\n}\nStatus wait_for_other_shards()\n{\nthis-&gt;barrier_.fetch_sub(1);\nreturn this-&gt;barrier_.await_equal(0);\n}\nconst usize shard_count;\nconst usize hash_space_per_shard = std::numeric_limits&lt;usize&gt;::max() / this-&gt;shard_count;\nWatch&lt;usize&gt; barrier_{this-&gt;shard_count};\nstd::atomic&lt;i64&gt; queue_push_count{0};\nstd::atomic&lt;i64&gt; queue_pop_count{0};\nstd::vector&lt;std::unique_ptr&lt;std::atomic&lt;bool&gt;[]&gt;&gt; stalled;\nstd::vector&lt;std::unique_ptr&lt;Queue&lt;std::vector&lt;Branch&gt;&gt;&gt;&gt; recv_queues;\nstd::vector&lt;CpuCacheLineIsolated&lt;std::vector&lt;std::vector&lt;Branch&gt;&gt;&gt;&gt; send_queues;\nstd::vector&lt;CpuCacheLineIsolated&lt;ShardMetrics&gt;&gt; shard_metrics;\nCpuCacheLineIsolated&lt;std::atomic&lt;i64&gt;&gt; total_pending_count{0};\nstd::vector&lt;CpuCacheLineIsolated&lt;i64&gt;&gt; local_consume_count;\n};\n}  // namespace detail\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_PARALLEL_MODEL_CHECK_STATE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/parallel__running__total_8hpp/","title":"batteries/algo/parallel_running_total.hpp","text":""},{"location":"_autogen/Files/parallel__running__total_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/parallel__running__total_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP"},{"location":"_autogen/Files/parallel__running__total_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parallel__running__total_8hpp/#define-batteries_algo_parallel_running_total_hpp","title":"define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP","text":"<pre><code>#define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP()\n</code></pre>"},{"location":"_autogen/Files/parallel__running__total_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP\n#define BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP\n#include &lt;batteries/algo/running_total.hpp&gt;\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;iterator&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;\ntypename Iter, typename Fn,\ntypename ValueT = std::decay_t&lt;std::invoke_result_t&lt;Fn, typename std::iterator_traits&lt;Iter&gt;::reference&gt;&gt;&gt;\nBasicRunningTotal&lt;ValueT&gt; parallel_running_total(WorkerPool&amp; worker_pool, Iter first, Iter last, const Fn&amp; fn,\nconst WorkSliceParams&amp; params);\ntemplate &lt;typename Iter, typename ValueT = typename std::iterator_traits&lt;Iter&gt;::value_type&gt;\nBasicRunningTotal&lt;ValueT&gt; parallel_running_total(WorkerPool&amp; worker_pool, Iter first, Iter last,\nconst WorkSliceParams&amp; params);\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Iter, typename Fn, typename ValueT&gt;\nBasicRunningTotal&lt;ValueT&gt; parallel_running_total(WorkerPool&amp; worker_pool, Iter first, Iter last, const Fn&amp; fn,\nconst WorkSliceParams&amp; params)\n{\nstatic const ValueT zero_value = make_default&lt;ValueT&gt;();\nconst WorkSlicePlan plan{params, first, last};\nif (plan.input_size == 0) {\nreturn BasicRunningTotal&lt;ValueT&gt;{};\n}\nBasicRunningTotal&lt;ValueT&gt; running_total{PartsCount{plan.n_tasks}, PartSize{plan.task_size}};\nrunning_total.set_size(plan.input_size + 1u);\n{\nScopedWorkContext context{worker_pool};\nBATT_CHECK_OK(slice_work(\ncontext, plan,\n[&amp;running_total, &amp;first, &amp;fn, &amp;plan](TaskIndex task_index, TaskOffset task_offset,\nTaskSize task_size) {\nreturn [&amp;running_total, &amp;fn, task_index, src_begin = std::next(first, task_offset), task_size,\n&amp;plan] {\nauto src_end = std::next(src_begin, task_size);\nauto dst = running_total.mutable_part(task_index);\nauto dst_iter = dst.begin();\nValueT part_total = zero_value;\nif (task_index + 1 &lt; plan.n_tasks) {\nBATT_CHECK_EQ(dst.size(), static_cast&lt;usize&gt;(std::distance(src_begin, src_end)) + 1u)\n&lt;&lt; BATT_INSPECT(task_index) &lt;&lt; BATT_INSPECT(plan);\n}\nBATT_CHECK_EQ(*dst_iter, zero_value);\n++dst_iter;\nstd::for_each(src_begin, src_end, [&amp;](const auto&amp; item) {\npart_total += fn(item);\n*dst_iter = part_total;\n++dst_iter;\n});\n// Fill to the end with the last value.\n//\nstd::fill(dst_iter, dst.end(), part_total);\n};\n}))\n&lt;&lt; \"worker_pool must not be closed!\";\n}\n// Finally, calculate the running total of part totals.\n//\nrunning_total.update_summary();\nreturn running_total;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Iter, typename ValueT&gt;\nBasicRunningTotal&lt;ValueT&gt; parallel_running_total(WorkerPool&amp; worker_pool, Iter first, Iter last,\nconst WorkSliceParams&amp; params)\n{\nreturn parallel_running_total(\nworker_pool, first, last, /*fn=*/\n[](auto&amp;&amp; value) -&gt; decltype(auto) {\nreturn BATT_FORWARD(value);\n},\nparams);\n}\n}  // namespace batt\n#endif  // BATTERIES_ALGO_PARALLEL_RUNNING_TOTAL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/parallel__transform_8hpp/","title":"batteries/algo/parallel_transform.hpp","text":""},{"location":"_autogen/Files/parallel__transform_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/parallel__transform_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP"},{"location":"_autogen/Files/parallel__transform_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parallel__transform_8hpp/#define-batteries_algo_parallel_transform_hpp","title":"define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP","text":"<pre><code>#define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP()\n</code></pre>"},{"location":"_autogen/Files/parallel__transform_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP\n#define BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename Src, typename Dst, typename TransformFn&gt;\nvoid parallel_transform(WorkContext&amp; work_context,        //\nSrc src_begin, Src src_end,       //\nDst dst_begin,                    //\nconst TransformFn&amp; transform_fn,  //\nTaskSize min_task_size,           //\nTaskCount max_tasks)\n{\nif (max_tasks == 1) {\nstd::transform(src_begin, src_end, dst_begin, transform_fn);\nreturn;\n}\nconst WorkSlicePlan plan{WorkSliceParams{min_task_size, max_tasks}, src_begin, src_end};\nBATT_CHECK_OK(slice_work(work_context, plan,\n/*gen_work_fn=*/\n[&amp;](usize /*task_index*/, isize task_offset, isize task_size) {\nreturn [src_begin, dst_begin, task_offset, task_size, transform_fn] {\nauto task_src_begin = std::next(src_begin, task_offset);\nauto task_src_end = std::next(task_src_begin, task_size);\nauto task_dst_begin = std::next(dst_begin, task_offset);\nstd::transform(task_src_begin, task_src_end, task_dst_begin,\ntransform_fn);\n};\n}))\n&lt;&lt; \"work_context must not be closed!\";\n}\n}  // namespace batt\n#endif  // BATTERIES_ALGO_PARALLEL_TRANSFORM_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/parser_8cpp/","title":"batteries/pico_http/parser.cpp","text":""},{"location":"_autogen/Files/parser_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/pico_http/parser.hpp&gt;\n//\n#include &lt;batteries/pico_http/parser_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/parser_8hpp/","title":"batteries/pico_http/parser.hpp","text":""},{"location":"_autogen/Files/parser_8hpp/#defines","title":"Defines","text":"Name BATTERIES_PICO_HTTP_PARSER_HPP"},{"location":"_autogen/Files/parser_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parser_8hpp/#define-batteries_pico_http_parser_hpp","title":"define BATTERIES_PICO_HTTP_PARSER_HPP","text":"<pre><code>#define BATTERIES_PICO_HTTP_PARSER_HPP()\n</code></pre>"},{"location":"_autogen/Files/parser_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_PICO_HTTP_PARSER_HPP\n#define BATTERIES_PICO_HTTP_PARSER_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/pico_http/parser_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/pico_http/parser_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n#endif  // BATTERIES_PICO_HTTP_PARSER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/parser__decl_8hpp/","title":"batteries/pico_http/parser_decl.hpp","text":""},{"location":"_autogen/Files/parser__decl_8hpp/#namespaces","title":"Namespaces","text":"Name pico_http"},{"location":"_autogen/Files/parser__decl_8hpp/#classes","title":"Classes","text":"Name struct pico_http::MessageHeader struct pico_http::Request struct pico_http::Response struct pico_http::ChunkedDecoder struct pico_http::DecodeResult"},{"location":"_autogen/Files/parser__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#ifndef BATTERIES_PICO_HTTP_PARSER_DECL_HPP\n#define BATTERIES_PICO_HTTP_PARSER_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;string_view&gt;\n#include &lt;sys/types.h&gt;\n#ifdef _MSC_VER\n#define ssize_t intptr_t\n#endif\nnamespace pico_http {\nusing namespace batt::int_types;\n/* contains name and value of a header (name == NULL if is a continuing line\n * of a multiline header */\nstruct MessageHeader {\nstd::string_view name;\nstd::string_view value;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nMessageHeader() = default;\nMessageHeader(std::string_view name, std::string_view value) noexcept : name{name}, value{value}\n{\n}\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MessageHeader&amp; t);\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const batt::SmallVecBase&lt;MessageHeader&gt;&amp; t);\nconstexpr usize kDefaultNumHeaders = 16;\nconstexpr int kParseOk = 0;\nconstexpr int kParseFailed = -1;\nconstexpr int kParseIncomplete = -2;\nstruct Request {\nstd::string_view method;\nstd::string_view path;\nint major_version;\nint minor_version;\nbatt::SmallVec&lt;MessageHeader, kDefaultNumHeaders&gt; headers;\n/* returns number of bytes consumed if successful, kParseIncomplete if request is partial,\n     * kParseFailed if failed\n     */\nint parse(const char* buf, usize len, usize last_len = 0);\n// Convenience.\n//\nint parse(const batt::ConstBuffer&amp; buf)\n{\nreturn this-&gt;parse(static_cast&lt;const char*&gt;(buf.data()), buf.size());\n}\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Request&amp; t);\nstruct Response {\nint major_version;\nint minor_version;\nint status;\nstd::string_view message;\nbatt::SmallVec&lt;MessageHeader, kDefaultNumHeaders&gt; headers;\n/* returns number of bytes consumed if successful, kParseIncomplete if request is partial,\n     * kParseFailed if failed\n     */\nint parse(const char* buf, usize len, usize last_len = 0);\n// Convenience.\n//\nint parse(const batt::ConstBuffer&amp; buf)\n{\nreturn this-&gt;parse(static_cast&lt;const char*&gt;(buf.data()), buf.size());\n}\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Response&amp; t);\n/* returns number of bytes consumed if successful, kParseIncomplete if request is partial,\n * kParseFailed if failed\n */\nint parse_headers(const char* buf, usize len, batt::SmallVecBase&lt;MessageHeader&gt;* headers, usize last_len = 0);\n/* should be zero-filled before start */\nstruct ChunkedDecoder {\nusize bytes_left_in_chunk; /* number of bytes left in current chunk */\nbool consume_trailer;      /* if trailing headers should be consumed */\ni8 hex_count_;\ni8 state_;\n};\nstruct DecodeResult {\nbool done;\nusize bytes_consumed;\n};\n/* the function rewrites the buffer given as (buf, bufsz) removing the chunked-\n * encoding headers.  When the function returns without an error, bufsz is\n * updated to the length of the decoded data available.  Applications should\n * repeatedly call the function while it returns kParseIncomplete (incomplete) every time\n * supplying newly arrived data.  If the end of the chunked-encoded data is\n * found, the function returns a non-negative number indicating the number of\n * octets left undecoded, that starts from the offset returned by `*bufsz`.\n * Returns kParseFailed on error.\n */\nbatt::StatusOr&lt;DecodeResult&gt; decode_chunked(ChunkedDecoder* decoder, const batt::ConstBuffer&amp; input,\nbatt::SmallVecBase&lt;batt::ConstBuffer&gt;* output);\n/* returns if the chunked decoder is in middle of chunked data */\nint decode_chunked_is_in_data(ChunkedDecoder* decoder);\n}  // namespace pico_http\n#endif  // BATTERIES_PICO_HTTP_PARSER_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/parser__impl_8hpp/","title":"batteries/pico_http/parser_impl.hpp","text":""},{"location":"_autogen/Files/parser__impl_8hpp/#namespaces","title":"Namespaces","text":"Name pico_http pico_http::detail"},{"location":"_autogen/Files/parser__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_PICO_HTTP_PARSER_IMPL_HPP BATT_PICO_HTTP_ALIGNED(n) BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c) BATT_PICO_HTTP_CHECK_EOF() BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch) BATT_PICO_HTTP_EXPECT_CHAR(ch) BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen) BATT_PICO_HTTP_DOIT() BATT_PICO_HTTP_PARSE_INT(valp_, mul_) BATT_PICO_HTTP_PARSE_INT_3(valp_) BATT_PICO_HTTP_PARSER_DUMP_CHUNKS"},{"location":"_autogen/Files/parser__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/parser__impl_8hpp/#define-batteries_pico_http_parser_impl_hpp","title":"define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP","text":"<pre><code>#define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_aligned","title":"define BATT_PICO_HTTP_ALIGNED","text":"<pre><code>#define BATT_PICO_HTTP_ALIGNED(n)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_is_printable_ascii","title":"define BATT_PICO_HTTP_IS_PRINTABLE_ASCII","text":"<pre><code>#define BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_check_eof","title":"define BATT_PICO_HTTP_CHECK_EOF","text":"<pre><code>#define BATT_PICO_HTTP_CHECK_EOF()\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_expect_char_no_check","title":"define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK","text":"<pre><code>#define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_expect_char","title":"define BATT_PICO_HTTP_EXPECT_CHAR","text":"<pre><code>#define BATT_PICO_HTTP_EXPECT_CHAR(ch)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_advance_token","title":"define BATT_PICO_HTTP_ADVANCE_TOKEN","text":"<pre><code>#define BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_doit","title":"define BATT_PICO_HTTP_DOIT","text":"<pre><code>#define BATT_PICO_HTTP_DOIT()\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_parse_int","title":"define BATT_PICO_HTTP_PARSE_INT","text":"<pre><code>#define BATT_PICO_HTTP_PARSE_INT(valp_, mul_)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_parse_int_3","title":"define BATT_PICO_HTTP_PARSE_INT_3","text":"<pre><code>#define BATT_PICO_HTTP_PARSE_INT_3(valp_)\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#define-batt_pico_http_parser_dump_chunks","title":"define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS","text":"<pre><code>#define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS()\n</code></pre>"},{"location":"_autogen/Files/parser__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n#pragma once\n#ifndef BATTERIES_PICO_HTTP_PARSER_IMPL_HPP\n#define BATTERIES_PICO_HTTP_PARSER_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;assert.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;string.h&gt;\n#ifdef __SSE4_2__\n#ifdef _MSC_VER\n#include &lt;nmmintrin.h&gt;\n#else\n#include &lt;x86intrin.h&gt;\n#endif\n#endif\n#include &lt;batteries/pico_http/parser_decl.hpp&gt;\nnamespace pico_http {\nusing namespace batt::int_types;\n}\n#ifdef _MSC_VER\n#define BATT_PICO_HTTP_ALIGNED(n) _declspec(align(n))\n#else\n#define BATT_PICO_HTTP_ALIGNED(n) __attribute__((aligned(n)))\n#endif\n#define BATT_PICO_HTTP_IS_PRINTABLE_ASCII(c) ((unsigned char)(c)-040u &lt; 0137u)\n#define BATT_PICO_HTTP_CHECK_EOF()                                                                           \\\n    if (buf == buf_end) {                                                                                    \\\n        *ret = -2;                                                                                           \\\n        return nullptr;                                                                                      \\\n    }\n#define BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch)                                                              \\\n    if (*buf++ != ch) {                                                                                      \\\n        *ret = -1;                                                                                           \\\n        return nullptr;                                                                                      \\\n    }\n#define BATT_PICO_HTTP_EXPECT_CHAR(ch)                                                                       \\\n    BATT_PICO_HTTP_CHECK_EOF();                                                                              \\\n    BATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK(ch);\n#define BATT_PICO_HTTP_ADVANCE_TOKEN(tok, toklen)                                                            \\\n    do {                                                                                                     \\\n        const char* tok_start = buf;                                                                         \\\n        static const char BATT_PICO_HTTP_ALIGNED(16) ranges2[16] = \"\\000\\040\\177\\177\";                       \\\n        int found2;                                                                                          \\\n        buf = findchar_fast(buf, buf_end, ranges2, 4, &amp;found2);                                              \\\n        if (!found2) {                                                                                       \\\n            BATT_PICO_HTTP_CHECK_EOF();                                                                      \\\n        }                                                                                                    \\\n        while (1) {                                                                                          \\\n            if (*buf == ' ') {                                                                               \\\n                break;                                                                                       \\\n            } else if (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) {                          \\\n                if ((unsigned char)*buf &lt; '\\040' || *buf == '\\177') {                                        \\\n                    *ret = -1;                                                                               \\\n                    return nullptr;                                                                          \\\n                }                                                                                            \\\n            }                                                                                                \\\n            ++buf;                                                                                           \\\n            BATT_PICO_HTTP_CHECK_EOF();                                                                      \\\n        }                                                                                                    \\\n        tok = tok_start;                                                                                     \\\n        toklen = buf - tok_start;                                                                            \\\n    } while (0)\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace pico_http {\nnamespace detail {\nnamespace {\nconst char* token_char_map =\n\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\"\\0\\1\\0\\1\\1\\1\\1\\1\\0\\0\\1\\1\\0\\1\\1\\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\0\\0\\0\"\n\"\\0\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\0\\0\\1\\1\"\n\"\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\0\\1\\0\\1\\0\"\n\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\nBATT_INLINE_IMPL const char* findchar_fast(const char* buf, const char* buf_end, const char* ranges,\nusize ranges_size, int* found)\n{\n*found = 0;\n#if __SSE4_2__\nif (BATT_HINT_TRUE(buf_end - buf &gt;= 16)) {\n__m128i ranges16 = _mm_loadu_si128((const __m128i*)ranges);\nusize left = (buf_end - buf) &amp; ~15;\ndo {\n__m128i b16 = _mm_loadu_si128((const __m128i*)buf);\nint r = _mm_cmpestri(ranges16, ranges_size, b16, 16,\n_SIDD_LEAST_SIGNIFICANT | _SIDD_CMP_RANGES | _SIDD_UBYTE_OPS);\nif (BATT_HINT_FALSE(r != 16)) {\nbuf += r;\n*found = 1;\nbreak;\n}\nbuf += 16;\nleft -= 16;\n} while (BATT_HINT_TRUE(left != 0));\n}\n#else\n/* suppress unused parameter warning */\n(void)buf_end;\n(void)ranges;\n(void)ranges_size;\n#endif\nreturn buf;\n}\nBATT_INLINE_IMPL const char* get_token_to_eol(const char* buf, const char* buf_end, std::string_view* token,\nint* ret)\n{\nconst char* token_start = buf;\nint token_len = 0;\n#ifdef __SSE4_2__\nstatic const char BATT_PICO_HTTP_ALIGNED(16) ranges1[16] =\n\"\\0\\010\"    /* allow HT */\n\"\\012\\037\"  /* allow SP and up to but not including DEL */\n\"\\177\\177\"; /* allow chars w. MSB set */\nint found;\nbuf = findchar_fast(buf, buf_end, ranges1, 6, &amp;found);\nif (found) {\ngoto FOUND_CTL;\n}\n#else\n/* find non-printable char within the next 8 bytes, this is the hottest code; manually inlined */\nwhile (BATT_HINT_TRUE(buf_end - buf &gt;= 8)) {\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n#define BATT_PICO_HTTP_DOIT()                                                                                \\\n    do {                                                                                                     \\\n        if (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) {                                     \\\n            goto NonPrintable;                                                                               \\\n        }                                                                                                    \\\n        ++buf;                                                                                               \\\n    } while (0)\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\nBATT_PICO_HTTP_DOIT();\n#undef BATT_PICO_HTTP_DOIT\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ncontinue;\nNonPrintable:\nif ((BATT_HINT_TRUE((unsigned char)*buf &lt; '\\040') &amp;&amp; BATT_HINT_TRUE(*buf != '\\011')) ||\nBATT_HINT_FALSE(*buf == '\\177')) {\ngoto FOUND_CTL;\n}\n++buf;\n}\n#endif\nfor (;; ++buf) {\nBATT_PICO_HTTP_CHECK_EOF();\nif (BATT_HINT_FALSE(!BATT_PICO_HTTP_IS_PRINTABLE_ASCII(*buf))) {\nif ((BATT_HINT_TRUE((unsigned char)*buf &lt; '\\040') &amp;&amp; BATT_HINT_TRUE(*buf != '\\011')) ||\nBATT_HINT_FALSE(*buf == '\\177')) {\ngoto FOUND_CTL;\n}\n}\n}\nFOUND_CTL:\nif (BATT_HINT_TRUE(*buf == '\\015')) {\n++buf;\nBATT_PICO_HTTP_EXPECT_CHAR('\\012');\ntoken_len = buf - 2 - token_start;\n} else if (*buf == '\\012') {\ntoken_len = buf - token_start;\n++buf;\n} else {\n*ret = -1;\nreturn nullptr;\n}\n*token = std::string_view{token_start, static_cast&lt;usize&gt;(token_len)};\nreturn buf;\n}\nBATT_INLINE_IMPL const char* is_complete(const char* buf, const char* buf_end, usize last_len, int* ret)\n{\nint ret_cnt = 0;\nbuf = last_len &lt; 3 ? buf : buf + last_len - 3;\nwhile (1) {\nBATT_PICO_HTTP_CHECK_EOF();\nif (*buf == '\\015') {\n++buf;\nBATT_PICO_HTTP_CHECK_EOF();\nBATT_PICO_HTTP_EXPECT_CHAR('\\012');\n++ret_cnt;\n} else if (*buf == '\\012') {\n++buf;\n++ret_cnt;\n} else {\n++buf;\nret_cnt = 0;\n}\nif (ret_cnt == 2) {\nreturn buf;\n}\n}\n*ret = -2;\nreturn nullptr;\n}\n#define BATT_PICO_HTTP_PARSE_INT(valp_, mul_)                                                                \\\n    if (*buf &lt; '0' || '9' &lt; *buf) {                                                                          \\\n        buf++;                                                                                               \\\n        *ret = -1;                                                                                           \\\n        return nullptr;                                                                                      \\\n    }                                                                                                        \\\n    *(valp_) = (mul_) * (*buf++ - '0');\n#define BATT_PICO_HTTP_PARSE_INT_3(valp_)                                                                    \\\n    do {                                                                                                     \\\n        int res_ = 0;                                                                                        \\\n        BATT_PICO_HTTP_PARSE_INT(&amp;res_, 100)                                                                 \\\n        *valp_ = res_;                                                                                       \\\n        BATT_PICO_HTTP_PARSE_INT(&amp;res_, 10)                                                                  \\\n        *valp_ += res_;                                                                                      \\\n        BATT_PICO_HTTP_PARSE_INT(&amp;res_, 1)                                                                   \\\n        *valp_ += res_;                                                                                      \\\n    } while (0)\n/* returned pointer is always within [buf, buf_end), or null */\nBATT_INLINE_IMPL const char* parse_token(const char* buf, const char* buf_end, std::string_view* token,\nchar next_char, int* ret)\n{\n/* We use pcmpestri to detect non-token characters. This instruction can take no more than eight character\n     * ranges (8*2*8=128\n     * bits that is the size of a SSE register). Due to this restriction, characters `|` and `~` are handled\n     * in the slow loop. */\nstatic const char BATT_PICO_HTTP_ALIGNED(16) ranges[] =\n\"\\x00 \"  /* control chars and up to SP */\n\"\\\"\\\"\"   /* 0x22 */\n\"()\"     /* 0x28,0x29 */\n\",,\"     /* 0x2c */\n\"//\"     /* 0x2f */\n\":@\"     /* 0x3a-0x40 */\n\"[]\"     /* 0x5b-0x5d */\n\"{\\xff\"; /* 0x7b-0xff */\nconst char* buf_start = buf;\nint found;\nbuf = findchar_fast(buf, buf_end, ranges, sizeof(ranges) - 1, &amp;found);\nif (!found) {\nBATT_PICO_HTTP_CHECK_EOF();\n}\nwhile (1) {\nif (*buf == next_char) {\nbreak;\n} else if (!token_char_map[(unsigned char)*buf]) {\n*ret = -1;\nreturn nullptr;\n}\n++buf;\nBATT_PICO_HTTP_CHECK_EOF();\n}\n*token = std::string_view{buf_start, static_cast&lt;usize&gt;(buf - buf_start)};\nreturn buf;\n}\n/* returned pointer is always within [buf, buf_end), or null */\nBATT_INLINE_IMPL const char* parse_http_version(const char* buf, const char* buf_end, int* minor_version,\nint* ret)\n{\n/* we want at least [HTTP/1.&lt;two chars&gt;] to try to parse */\nif (buf_end - buf &lt; 9) {\n*ret = -2;\nreturn nullptr;\n}\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('H');\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('T');\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('T');\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('P');\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('/');\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('1');\nBATT_PICO_HTTP_EXPECT_CHAR_NO_CHECK('.');\nBATT_PICO_HTTP_PARSE_INT(minor_version, 1);\nreturn buf;\n}\nBATT_INLINE_IMPL const char* parse_headers_impl(const char* buf, const char* buf_end,\nbatt::SmallVecBase&lt;pico_http::MessageHeader&gt;* headers,\nint* ret)\n{\nusize num_headers = 0;\nstd::string_view header_name;\nstd::string_view header_value;\nconst auto commit_header = [&amp;] {\nheaders-&gt;emplace_back(pico_http::MessageHeader{header_name, header_value});\n++num_headers;\n};\nfor (;; commit_header()) {\nBATT_PICO_HTTP_CHECK_EOF();\nif (*buf == '\\015') {\n++buf;\nBATT_PICO_HTTP_EXPECT_CHAR('\\012');\nbreak;\n} else if (*buf == '\\012') {\n++buf;\nbreak;\n}\nif (!(num_headers != 0 &amp;&amp; (*buf == ' ' || *buf == '\\t'))) {\n/* parsing name, but do not discard SP before colon, see\n             * http://www.mozilla.org/security/announce/2006/mfsa2006-33.html */\nif ((buf = parse_token(buf, buf_end, &amp;header_name, ':', ret)) == nullptr) {\nreturn nullptr;\n}\nif (header_name.size() == 0) {\n*ret = -1;\nreturn nullptr;\n}\n++buf;\nfor (;; ++buf) {\nBATT_PICO_HTTP_CHECK_EOF();\nif (!(*buf == ' ' || *buf == '\\t')) {\nbreak;\n}\n}\n} else {\nheader_name = std::string_view{};\n}\nstd::string_view value;\nif ((buf = get_token_to_eol(buf, buf_end, &amp;value, ret)) == nullptr) {\nreturn nullptr;\n}\n/* remove trailing SPs and HTABs */\nconst char* const value_begin = value.data();\nconst char* value_end = value_begin + value.size();\nfor (; value_end != value_begin; --value_end) {\nconst char c = *(value_end - 1);\nif (!(c == ' ' || c == '\\t')) {\nbreak;\n}\n}\nheader_value = std::string_view{value_begin, static_cast&lt;usize&gt;(value_end - value_begin)};\n}\nreturn buf;\n}\nBATT_INLINE_IMPL const char* parse_request_impl(const char* buf, const char* buf_end,\nstd::string_view* method, std::string_view* path,\nint* minor_version,\nbatt::SmallVecBase&lt;pico_http::MessageHeader&gt;* headers,\nint* ret)\n{\n/* skip first empty line (some clients add CRLF after POST content) */\nBATT_PICO_HTTP_CHECK_EOF();\nif (*buf == '\\015') {\n++buf;\nBATT_PICO_HTTP_EXPECT_CHAR('\\012');\n} else if (*buf == '\\012') {\n++buf;\n}\n/* parse request line */\nif ((buf = parse_token(buf, buf_end, method, ' ', ret)) == nullptr) {\nreturn nullptr;\n}\ndo {\n++buf;\nBATT_PICO_HTTP_CHECK_EOF();\n} while (*buf == ' ');\n{\nconst char* path_begin;\nusize path_len;\nBATT_PICO_HTTP_ADVANCE_TOKEN(path_begin, path_len);\n*path = std::string_view{path_begin, path_len};\n}\ndo {\n++buf;\nBATT_PICO_HTTP_CHECK_EOF();\n} while (*buf == ' ');\nif (method-&gt;size() == 0 || path-&gt;size() == 0) {\n*ret = -1;\nreturn nullptr;\n}\nif ((buf = parse_http_version(buf, buf_end, minor_version, ret)) == nullptr) {\nreturn nullptr;\n}\nif (*buf == '\\015') {\n++buf;\nBATT_PICO_HTTP_EXPECT_CHAR('\\012');\n} else if (*buf == '\\012') {\n++buf;\n} else {\n*ret = -1;\nreturn nullptr;\n}\nreturn ::pico_http::detail::parse_headers_impl(buf, buf_end, headers, ret);\n}\n}  // namespace\n}  // namespace detail\n}  // namespace pico_http\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL int pico_http::Request::parse(const char* buf_start, usize len, usize last_len)\n{\nconst char *buf = buf_start, *buf_end = buf_start + len;\nint r;\nthis-&gt;method = std::string_view{};\nthis-&gt;path = std::string_view{};\nthis-&gt;major_version = -1;\nthis-&gt;minor_version = -1;\nthis-&gt;headers.clear();\n/* if last_len != 0, check if the request is complete (a fast countermeasure\n       againt slowloris */\nif (last_len != 0 &amp;&amp; ::pico_http::detail::is_complete(buf, buf_end, last_len, &amp;r) == nullptr) {\nthis-&gt;major_version = 1;\nreturn r;\n}\nbuf = ::pico_http::detail::parse_request_impl(buf, buf_end, &amp;this-&gt;method, &amp;this-&gt;path,\n&amp;this-&gt;minor_version, &amp;this-&gt;headers, &amp;r);\nif (buf == nullptr) {\nreturn r;\n}\nthis-&gt;major_version = 1;\nreturn (int)(buf - buf_start);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace pico_http {\nnamespace detail {\nnamespace {\nBATT_INLINE_IMPL const char* parse_response_impl(const char* buf, const char* buf_end, int* minor_version,\nint* status, std::string_view* msg,\nbatt::SmallVecBase&lt;pico_http::MessageHeader&gt;* headers,\nint* ret)\n{\n/* parse \"HTTP/1.x\" */\nif ((buf = parse_http_version(buf, buf_end, minor_version, ret)) == nullptr) {\nreturn nullptr;\n}\n/* skip space */\nif (*buf != ' ') {\n*ret = -1;\nreturn nullptr;\n}\ndo {\n++buf;\nBATT_PICO_HTTP_CHECK_EOF();\n} while (*buf == ' ');\n/* parse status code, we want at least [:digit:][:digit:][:digit:]&lt;other char&gt; to try to parse */\nif (buf_end - buf &lt; 4) {\n*ret = -2;\nreturn nullptr;\n}\nBATT_PICO_HTTP_PARSE_INT_3(status);\n/* get message including preceding space */\nif ((buf = get_token_to_eol(buf, buf_end, msg, ret)) == nullptr) {\nreturn nullptr;\n}\nif (msg-&gt;size() == 0) {\n/* ok */\n} else if ((*msg)[0] == ' ') {\n/* Remove preceding space. Successful return from `get_token_to_eol` guarantees that we would hit\n         * something other than SP before running past the end of the given buffer. */\nconst char* msg_begin = msg-&gt;data();\nusize msg_len = msg-&gt;size();\ndo {\n++msg_begin;\n--msg_len;\n} while (*msg_begin == ' ');\n*msg = std::string_view{msg_begin, msg_len};\n} else {\n/* garbage found after status code */\n*ret = -1;\nreturn nullptr;\n}\nreturn ::pico_http::detail::parse_headers_impl(buf, buf_end, headers, ret);\n}\n}  // namespace\n}  // namespace detail\n}  // namespace pico_http\n#undef BATT_PICO_HTTP_PARSE_INT\n#undef BATT_PICO_HTTP_PARSE_INT_3\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL int pico_http::Response::parse(const char* buf_start, usize len, usize last_len)\n{\nconst char *buf = buf_start, *buf_end = buf + len;\nint r;\nthis-&gt;major_version = -1;\nthis-&gt;minor_version = -1;\nthis-&gt;status = 0;\nthis-&gt;message = std::string_view{};\nthis-&gt;headers.clear();\n/* if last_len != 0, check if the response is complete (a fast countermeasure\n       against slowloris */\nif (last_len != 0 &amp;&amp; ::pico_http::detail::is_complete(buf, buf_end, last_len, &amp;r) == nullptr) {\nthis-&gt;major_version = 1;\nreturn r;\n}\nbuf = ::pico_http::detail::parse_response_impl(buf, buf_end, &amp;this-&gt;minor_version, &amp;this-&gt;status,\n&amp;this-&gt;message, &amp;this-&gt;headers, &amp;r);\nif (buf == nullptr) {\nreturn r;\n}\nthis-&gt;major_version = 1;\nreturn (int)(buf - buf_start);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL int pico_http::parse_headers(const char* buf_start, usize len,\nbatt::SmallVecBase&lt;pico_http::MessageHeader&gt;* headers,\nusize last_len)\n{\nconst char *buf = buf_start, *buf_end = buf + len;\nint r;\nheaders-&gt;clear();\n/* if last_len != 0, check if the response is complete (a fast countermeasure\n       against slowloris */\nif (last_len != 0 &amp;&amp; ::pico_http::detail::is_complete(buf, buf_end, last_len, &amp;r) == nullptr) {\nreturn r;\n}\nif ((buf = ::pico_http::detail::parse_headers_impl(buf, buf_end, headers, &amp;r)) == nullptr) {\nreturn r;\n}\nreturn (int)(buf - buf_start);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace pico_http {\nnamespace detail {\nnamespace {\nenum {\nCHUNKED_IN_CHUNK_SIZE,\nCHUNKED_IN_CHUNK_EXT,\nCHUNKED_IN_CHUNK_DATA,\nCHUNKED_IN_CHUNK_CRLF,\nCHUNKED_IN_TRAILERS_LINE_HEAD,\nCHUNKED_IN_TRAILERS_LINE_MIDDLE\n};\nBATT_INLINE_IMPL int decode_hex(int ch)\n{\nif ('0' &lt;= ch &amp;&amp; ch &lt;= '9') {\nreturn ch - '0';\n} else if ('A' &lt;= ch &amp;&amp; ch &lt;= 'F') {\nreturn ch - 'A' + 0xa;\n} else if ('a' &lt;= ch &amp;&amp; ch &lt;= 'f') {\nreturn ch - 'a' + 0xa;\n} else {\nreturn kParseFailed;\n}\n}\n}  // namespace\n}  // namespace detail\n}  // namespace pico_http\n#define BATT_PICO_HTTP_PARSER_DUMP_CHUNKS 0\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL batt::StatusOr&lt;pico_http::DecodeResult&gt; pico_http::decode_chunked(\npico_http::ChunkedDecoder* decoder, const batt::ConstBuffer&amp; input,\nbatt::SmallVecBase&lt;batt::ConstBuffer&gt;* output)\n{\nconst char* const buf = static_cast&lt;const char*&gt;(input.data());\nconst usize bufsz = input.size();\n#if BATT_PICO_HTTP_PARSER_DUMP_CHUNKS\nstd::cerr &lt;&lt; \"decode_chunks(\" &lt;&lt; batt::c_str_literal(std::string_view{buf, bufsz}) &lt;&lt; \")\" &lt;&lt; std::endl;\n#endif\nDecodeResult result;\nresult.done = false;\nresult.bytes_consumed = 0;\nusize&amp; src = result.bytes_consumed;\nfor (;;) {\nswitch (decoder-&gt;state_) {\ncase ::pico_http::detail::CHUNKED_IN_CHUNK_SIZE:\nfor (;; ++src) {\nint v;\nif (src == bufsz) {\nreturn result;\n}\nif ((v = ::pico_http::detail::decode_hex(buf[src])) == kParseFailed) {\nif (decoder-&gt;hex_count_ == 0) {\nreturn {batt::StatusCode::kInvalidArgument};\n}\nbreak;\n}\nif (decoder-&gt;hex_count_ == sizeof(usize) * 2) {\nreturn {batt::StatusCode::kInvalidArgument};\n}\ndecoder-&gt;bytes_left_in_chunk = decoder-&gt;bytes_left_in_chunk * 16 + v;\n++decoder-&gt;hex_count_;\n}\ndecoder-&gt;hex_count_ = 0;\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_CHUNK_EXT;\n/* fallthru */\ncase ::pico_http::detail::CHUNKED_IN_CHUNK_EXT:\n/* RFC 7230 A.2 \"Line folding in chunk extensions is disallowed\" */\nfor (;; ++src) {\nif (src == bufsz) {\nreturn result;\n}\nif (buf[src] == '\\012') {\nbreak;\n}\n}\n++src;\nif (decoder-&gt;bytes_left_in_chunk == 0) {\nif (decoder-&gt;consume_trailer) {\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_TRAILERS_LINE_HEAD;\nbreak;\n} else {\nresult.done = true;\nreturn result;\n}\n}\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_CHUNK_DATA;\n/* fallthru */\ncase ::pico_http::detail::CHUNKED_IN_CHUNK_DATA: {\nconst usize avail = bufsz - src;\nif (avail &lt; decoder-&gt;bytes_left_in_chunk) {\nif (avail &gt; 0) {\noutput-&gt;emplace_back(batt::ConstBuffer{buf + src, avail});\n}\nsrc += avail;\ndecoder-&gt;bytes_left_in_chunk -= avail;\nreturn result;\n}\noutput-&gt;emplace_back(batt::ConstBuffer{buf + src, decoder-&gt;bytes_left_in_chunk});\nsrc += decoder-&gt;bytes_left_in_chunk;\ndecoder-&gt;bytes_left_in_chunk = 0;\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_CHUNK_CRLF;\n}\n/* fallthru */\ncase ::pico_http::detail::CHUNKED_IN_CHUNK_CRLF:\nfor (;; ++src) {\nif (src == bufsz) {\nreturn result;\n}\nif (buf[src] != '\\015') {\nbreak;\n}\n}\nif (buf[src] != '\\012') {\nreturn {batt::StatusCode::kInvalidArgument};\n}\n++src;\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_CHUNK_SIZE;\nbreak;\ncase ::pico_http::detail::CHUNKED_IN_TRAILERS_LINE_HEAD:\nfor (;; ++src) {\nif (src == bufsz) {\nreturn result;\n}\nif (buf[src] != '\\015') {\nbreak;\n}\n}\nif (buf[src++] == '\\012') {\nresult.done = true;\nreturn result;\n}\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_TRAILERS_LINE_MIDDLE;\n/* fallthru */\ncase ::pico_http::detail::CHUNKED_IN_TRAILERS_LINE_MIDDLE:\nfor (;; ++src) {\nif (src == bufsz) {\nreturn result;\n}\nif (buf[src] == '\\012') {\nbreak;\n}\n}\n++src;\ndecoder-&gt;state_ = ::pico_http::detail::CHUNKED_IN_TRAILERS_LINE_HEAD;\nbreak;\ndefault:\nBATT_PANIC() &lt;&lt; \"decoder is corrupt\";\n}\n}\n}\nBATT_INLINE_IMPL int pico_http::decode_chunked_is_in_data(pico_http::ChunkedDecoder* decoder)\n{\nreturn decoder-&gt;state_ == ::pico_http::detail::CHUNKED_IN_CHUNK_DATA;\n}\n#undef BATT_PICO_HTTP_CHECK_EOF\n#undef BATT_PICO_HTTP_EXPECT_CHAR\n#undef BATT_PICO_HTTP_ADVANCE_TOKEN\n#undef BATT_PICO_HTTP_ALIGNED\nnamespace pico_http {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MessageHeader&amp; t)\n{\nreturn out &lt;&lt; t.name &lt;&lt; \": \" &lt;&lt; t.value &lt;&lt; \"\\r\\n\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const batt::SmallVecBase&lt;MessageHeader&gt;&amp; t)\n{\nfor (const MessageHeader&amp; hdr : t) {\nout &lt;&lt; hdr;\n}\nreturn out;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Request&amp; t)\n{\nreturn out &lt;&lt; t.method &lt;&lt; ' ' &lt;&lt; t.path &lt;&lt; \" HTTP/\" &lt;&lt; t.major_version &lt;&lt; '.' &lt;&lt; t.minor_version &lt;&lt; \"\\r\\n\"\n&lt;&lt; t.headers &lt;&lt; \"\\r\\n\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Response&amp; t)\n{\nreturn out &lt;&lt; \"HTTP/\" &lt;&lt; t.major_version &lt;&lt; '.' &lt;&lt; t.minor_version &lt;&lt; ' ' &lt;&lt; t.status &lt;&lt; ' ' &lt;&lt; t.message\n&lt;&lt; \"\\r\\n\"\n&lt;&lt; t.headers &lt;&lt; \"\\r\\n\";\n}\n}  // namespace pico_http\n#endif  // BATTERIES_PICO_HTTP_PARSER_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/pin_8hpp/","title":"batteries/async/pin.hpp","text":""},{"location":"_autogen/Files/pin_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/pin_8hpp/#classes","title":"Classes","text":"Name class batt::Pinnable class batt::Pin class batt::PinnablePtr A raw pointer augmented to support the batt::Pinnable interface, so that a batt::Pin&gt; can be created to block the destruction of the pointer."},{"location":"_autogen/Files/pin_8hpp/#functions","title":"Functions","text":"Name template &lt;typename T &gt; void batt_pin_object_helper(T * object) template &lt;typename T &gt; void batt_unpin_object_helper(T * object)"},{"location":"_autogen/Files/pin_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_PIN_HPP"},{"location":"_autogen/Files/pin_8hpp/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Files/pin_8hpp/#function-batt_pin_object_helper","title":"function batt_pin_object_helper","text":"<pre><code>template &lt;typename T &gt;\ninline void batt_pin_object_helper(\nT * object\n)\n</code></pre>"},{"location":"_autogen/Files/pin_8hpp/#function-batt_unpin_object_helper","title":"function batt_unpin_object_helper","text":"<pre><code>template &lt;typename T &gt;\ninline void batt_unpin_object_helper(\nT * object\n)\n</code></pre>"},{"location":"_autogen/Files/pin_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/pin_8hpp/#define-batteries_async_pin_hpp","title":"define BATTERIES_ASYNC_PIN_HPP","text":"<pre><code>#define BATTERIES_ASYNC_PIN_HPP()\n</code></pre>"},{"location":"_autogen/Files/pin_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_PIN_HPP\n#define BATTERIES_ASYNC_PIN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;atomic&gt;\n// Top-level functions to increase/decrease the pin count of an object; this must be outside of the `batt`\n// namespace so we can make an unqualified call to `pin_object` in order to utilize ADL (argument-dependent\n// lookup).\n//\ntemplate &lt;typename T&gt;\ninline void batt_pin_object_helper(T* object)\n{\npin_object(object);\n}\ntemplate &lt;typename T&gt;\ninline void batt_unpin_object_helper(T* object)\n{\nunpin_object(object);\n}\nnamespace batt {\n// Base class that implements the PinnableObject requirements.  See Pin&lt;T&gt; for details.\n//\nclass Pinnable\n{\npublic:\nPinnable() = default;\nPinnable(const Pinnable&amp;) = delete;\nPinnable&amp; operator=(const Pinnable&amp;) = delete;\n~Pinnable()\n{\n// Release the self-pin before waiting for other pins to be released.\n//\nthis-&gt;unpin();\n// Don't let the current Task continue until all other pins on this object have been released.\n//\nwhile (this-&gt;pin_count_.load(std::memory_order_acquire) &gt; 0) {\nTask::yield();\n}\n// We can safely assert this is the case because once the pin count goes to 0, it should never\n// increase again (because of the self-pin acquired at construction time and released at destruction\n// time).\n//\nBATT_CHECK_EQ(this-&gt;pin_count_.exchange(0, std::memory_order_release), 0);\n}\nvoid pin()\n{\nthis-&gt;pin_count_.fetch_add(1, std::memory_order_relaxed);\n}\nvoid unpin()\n{\nthis-&gt;pin_count_.fetch_sub(1, std::memory_order_release);\n}\nprivate:\n// The pin count starts out as 1; this way we avoid A/B/A issues where the pin count drops down to zero\n// then goes back up.\n//\nstd::atomic&lt;isize&gt; pin_count_{1};\n};\n// Default implementation of ADL-enabled pin_object, for `Pinnable`.\n//\ntemplate &lt;typename T&gt;\nvoid pin_object(T* object)\n{\nobject-&gt;pin();\n}\n// Default implementation of ADL-enabled unpin_object, for `Pinnable`.\n//\ntemplate &lt;typename T&gt;\nvoid unpin_object(T* object)\n{\nobject-&gt;unpin();\n}\n// A copyable/move-optimized smart pointer to PinnableObject `T` that prevents the pointee from being\n// destructed.  This is an alternative to shared_ptr/intrusive_ptr for the case where application code wishes\n// to avoid the overhead of heap allocation.  The use case is that a unique owner can be identified within the\n// code, but there may be race conditions on destruction of the object.  For example, if one Task creates an\n// object, hands it to another Task, waits for the other Task to be done with it, then the first Task deletes\n// the object. Normally you would need some external synchronization mechanism for this, but Pin&lt;T&gt; allows the\n// object itself to contain the required synchronization.\n//\ntemplate &lt;typename T&gt;\nclass Pin\n{\npublic:\nPin() noexcept : ptr_{nullptr}\n{\n}\nexplicit Pin(std::nullptr_t) noexcept : Pin{}\n{\n}\nexplicit Pin(T* object) noexcept : ptr_{object}\n{\nif (BATT_HINT_TRUE(object != nullptr)) {\n::batt_pin_object_helper(object);\n}\n}\nPin(const Pin&amp; other) noexcept : Pin{other.ptr_}\n{\n}\nPin(Pin&amp;&amp; other) noexcept : ptr_{other.ptr_}\n{\nother.ptr_ = nullptr;\n}\n~Pin() noexcept\n{\nthis-&gt;release();\n}\nPin&amp; operator=(const Pin&amp; other)\n{\nPin tmp{other};\nthis-&gt;swap(tmp);\nreturn *this;\n}\nPin&amp; operator=(Pin&amp;&amp; other)\n{\nPin tmp{std::move(other)};\nthis-&gt;swap(tmp);\nreturn *this;\n}\nexplicit operator bool() const\n{\nreturn this-&gt;ptr_ != nullptr;\n}\nvoid swap(Pin&amp; other)\n{\nstd::swap(this-&gt;ptr_, other.ptr_);\n}\nvoid release()\n{\nif (this-&gt;ptr_) {\n::batt_unpin_object_helper(this-&gt;ptr_);\nthis-&gt;ptr_ = nullptr;\n}\n}\nT* get() const\n{\nreturn this-&gt;ptr_;\n}\nT&amp; operator*() const\n{\nreturn *this-&gt;get();\n}\nT* operator-&gt;() const\n{\nreturn this-&gt;get();\n}\nprivate:\nT* ptr_;\n};\ntemplate &lt;typename T&gt;\ninline Pin&lt;T&gt; make_pin(T* object)\n{\nreturn Pin&lt;T&gt;{object};\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator==(const Pin&lt;T&gt;&amp; l, const Pin&lt;U&gt;&amp; r)\n{\nreturn l.get() == r.get();\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator!=(const Pin&lt;T&gt;&amp; l, const Pin&lt;U&gt;&amp; r)\n{\nreturn !(l == r);\n}\ntemplate &lt;typename T&gt;\ninline bool operator==(const Pin&lt;T&gt;&amp; l, std::nullptr_t)\n{\nreturn l.get() == nullptr;\n}\ntemplate &lt;typename T&gt;\ninline bool operator!=(const Pin&lt;T&gt;&amp; l, std::nullptr_t)\n{\nreturn !(l == nullptr);\n}\ntemplate &lt;typename U&gt;\ninline bool operator==(std::nullptr_t, const Pin&lt;U&gt;&amp; r)\n{\nreturn nullptr == r.get();\n}\ntemplate &lt;typename U&gt;\ninline bool operator!=(std::nullptr_t, const Pin&lt;U&gt;&amp; r)\n{\nreturn !(nullptr == r);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T&gt;\nclass PinnablePtr : public Pinnable\n{\npublic:\nexplicit PinnablePtr(T* ptr) noexcept : ptr_{ptr}\n{\n}\nPinnablePtr() = default;\nT* get() const noexcept\n{\nreturn this-&gt;ptr_;\n}\nexplicit operator bool() const noexcept\n{\nreturn this-&gt;get() != nullptr;\n}\nT&amp; operator*() const noexcept\n{\nreturn *this-&gt;get();\n}\nT* operator-&gt;() const noexcept\n{\nreturn this-&gt;get();\n}\nprivate:\nT* ptr_ = nullptr;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_PIN_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/pointers_8hpp/","title":"batteries/pointers.hpp","text":""},{"location":"_autogen/Files/pointers_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/pointers_8hpp/#classes","title":"Classes","text":"Name struct batt::NoopDeleter"},{"location":"_autogen/Files/pointers_8hpp/#defines","title":"Defines","text":"Name BATTERIES_POINTERS_HPP"},{"location":"_autogen/Files/pointers_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/pointers_8hpp/#define-batteries_pointers_hpp","title":"define BATTERIES_POINTERS_HPP","text":"<pre><code>#define BATTERIES_POINTERS_HPP()\n</code></pre>"},{"location":"_autogen/Files/pointers_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_POINTERS_HPP\n#define BATTERIES_POINTERS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;memory&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nstruct NoopDeleter {\ntemplate &lt;typename T&gt;\nvoid operator()(T*) const\n{  // do nothing\n}\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename T&gt;\nusing UniqueNonOwningPtr = std::unique_ptr&lt;T, NoopDeleter&gt;;\n}  // namespace batt\n#endif  // BATTERIES_POINTERS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/post_8hpp/","title":"batteries/asio/post.hpp","text":""},{"location":"_autogen/Files/post_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_POST_HPP"},{"location":"_autogen/Files/post_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/post_8hpp/#define-batteries_asio_post_hpp","title":"define BATTERIES_ASIO_POST_HPP","text":"<pre><code>#define BATTERIES_ASIO_POST_HPP()\n</code></pre>"},{"location":"_autogen/Files/post_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASIO_POST_HPP\n#define BATTERIES_ASIO_POST_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/post.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_POST_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/preallocated__task_8hpp/","title":"batteries/async/preallocated_task.hpp","text":""},{"location":"_autogen/Files/preallocated__task_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/preallocated__task_8hpp/#classes","title":"Classes","text":"Name class batt::PreallocatedTask class batt::PreallocatedTask::PreallocatedStackAllocator"},{"location":"_autogen/Files/preallocated__task_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_PREALLOCATED_TASK_HPP"},{"location":"_autogen/Files/preallocated__task_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/preallocated__task_8hpp/#define-batteries_async_preallocated_task_hpp","title":"define BATTERIES_ASYNC_PREALLOCATED_TASK_HPP","text":"<pre><code>#define BATTERIES_ASYNC_PREALLOCATED_TASK_HPP()\n</code></pre>"},{"location":"_autogen/Files/preallocated__task_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_PREALLOCATED_TASK_HPP\n#define BATTERIES_ASYNC_PREALLOCATED_TASK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;boost/asio/associated_allocator.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\ntemplate &lt;typename CompletionHandlerFn = void()&gt;\nclass PreallocatedTask\n{\npublic:\nusing byte_allocator_type = typename std::allocator_traits&lt;\nboost::asio::associated_allocator_t&lt;CompletionHandlerFn&gt;&gt;::template rebind_alloc&lt;char&gt;;\nclass PreallocatedStackAllocator\n{\npublic:\nPreallocatedStackAllocator() = default;\nexplicit PreallocatedStackAllocator(PreallocatedTask* prealloc) noexcept : prealloc_{prealloc}\n{\n}\nPreallocatedStackAllocator(const PreallocatedStackAllocator&amp;) = default;\nPreallocatedStackAllocator&amp; operator=(const PreallocatedStackAllocator&amp;) = default;\nboost::context::stack_context allocate() const\n{\nBATT_CHECK_NOT_NULLPTR(this-&gt;prealloc_);\nBATT_CHECK(!this-&gt;prealloc_-&gt;stack_in_use_);\nthis-&gt;prealloc_-&gt;stack_in_use_ = true;\nreturn this-&gt;prealloc_-&gt;get_stack_context();\n}\nvoid deallocate(boost::context::stack_context&amp; ctx) const\n{\nBATT_CHECK_NOT_NULLPTR(this-&gt;prealloc_);\nBATT_CHECK(this-&gt;prealloc_-&gt;stack_in_use_);\nthis-&gt;prealloc_-&gt;stack_in_use_ = false;\nboost::context::stack_context expected = this-&gt;prealloc_-&gt;get_stack_context();\nBATT_CHECK_EQ(expected.sp, ctx.sp);\nBATT_CHECK_EQ(expected.size, ctx.size);\n}\nprivate:\nPreallocatedTask* prealloc_ = nullptr;\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename BodyFn, typename... TaskArgs&gt;\nstatic PreallocatedTask* make_new(const boost::asio::any_io_executor&amp; ex,\nCompletionHandlerFn&amp;&amp; completion_handler, StackSize stack_byte_size,\nBodyFn&amp;&amp; body_fn, TaskArgs&amp;&amp;... task_args)\n{\nbyte_allocator_type byte_allocator =\nstd::move(boost::asio::get_associated_allocator(completion_handler));\nconst usize storage_byte_size = stack_byte_size + sizeof(PreallocatedTask);\nvoid* storage = byte_allocator.allocate(storage_byte_size);\nreturn new (storage) PreallocatedTask{ex, BATT_FORWARD(completion_handler), stack_byte_size,\nBATT_FORWARD(body_fn), BATT_FORWARD(task_args)...};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename BodyFn, typename... TaskArgs&gt;\nexplicit PreallocatedTask(const boost::asio::any_io_executor&amp; ex,\nCompletionHandlerFn&amp;&amp; completion_handler, StackSize stack_byte_size,\nBodyFn&amp;&amp; body_fn, TaskArgs&amp;&amp;... task_args) noexcept\n: completion_handler_{std::move(completion_handler)}\n, stack_in_use_{false}\n, stack_byte_size_{stack_byte_size}\n{\nauto task_options = Task::Options::from_args(BATT_FORWARD(task_args)...);\nTask::DeferStart defer_start = task_options.get_defer_start();\nOptional&lt;Task::GetIsStarted&gt; get_is_started = task_options.get_is_started;\ntask_options.get_is_started = None;\ntask_options.set_params(Task::DeferStart{true});\ntask_options.set_params(StackAllocator{PreallocatedStackAllocator{this}});\nTask* task = new (std::addressof(this-&gt;task_))\nTask{/*parent_task_list=*/Task::all_tasks(), ex, BATT_FORWARD(body_fn), std::move(task_options)};\ntask-&gt;call_when_done([this] {\nBATT_CHECK(!this-&gt;stack_in_use_);\nthis-&gt;task_pointer()-&gt;~Task();\nCompletionHandlerFn local_handler = std::move(*this-&gt;completion_handler_);\n{\nthis-&gt;completion_handler_ = None;\nbyte_allocator_type byte_allocator =\nstd::move(boost::asio::get_associated_allocator(local_handler));\nconst usize storage_byte_size = this-&gt;stack_byte_size_ + sizeof(PreallocatedTask);\nthis-&gt;~PreallocatedTask();\nbyte_allocator.deallocate((char*)this, storage_byte_size);\n}\nstd::move(local_handler)();\n});\nBATT_CHECK(!task-&gt;is_started());\nif (get_is_started &amp;&amp; *get_is_started) {\n**get_is_started = !defer_start;\n}\nif (!defer_start) {\ntask-&gt;start();\n}\n}\n~PreallocatedTask() noexcept\n{\nBATT_CHECK(!this-&gt;stack_in_use_);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::context::stack_context get_stack_context() const noexcept\n{\nu8* const stack_bottom = (u8*)(&amp;this-&gt;stack_top_[this-&gt;stack_byte_size_]);\nboost::context::stack_context ctx;\nctx.sp = stack_bottom;\nctx.size = this-&gt;stack_byte_size_;\nreturn ctx;\n}\nTask* task_pointer() noexcept\n{\nreturn reinterpret_cast&lt;Task*&gt;(std::addressof(this-&gt;task_));\n}\nTask&amp; task_ref() noexcept\n{\nreturn *this-&gt;task_pointer();\n}\nTask* operator-&gt;() noexcept\n{\nreturn this-&gt;task_pointer();\n}\nvoid start() noexcept\n{\nthis-&gt;task_pointer()-&gt;start();\n}\nprivate:\nOptional&lt;CompletionHandlerFn&gt; completion_handler_;\nbool stack_in_use_;\nusize stack_byte_size_;\nstd::aligned_storage_t&lt;sizeof(Task)&gt; task_;\nu8 stack_top_[0];\n};\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_PREALLOCATED_TASK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/prepend_8hpp/","title":"batteries/seq/prepend.hpp","text":""},{"location":"_autogen/Files/prepend_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/prepend_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::PrependBinder"},{"location":"_autogen/Files/prepend_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_PREPEND_HPP"},{"location":"_autogen/Files/prepend_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/prepend_8hpp/#define-batteries_seq_prepend_hpp","title":"define BATTERIES_SEQ_PREPEND_HPP","text":"<pre><code>#define BATTERIES_SEQ_PREPEND_HPP()\n</code></pre>"},{"location":"_autogen/Files/prepend_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_PREPEND_HPP\n#define BATTERIES_SEQ_PREPEND_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\ntemplate &lt;typename Item&gt;\nstruct PrependBinder {\nItem item;\n};\ntemplate &lt;typename Item&gt;\ninline auto prepend(Item&amp;&amp; item)\n{\nstatic_assert(std::is_same_v&lt;Item, std::decay_t&lt;Item&gt;&gt;,\n\"References may not be passed to batt::seq::prepend\");\nreturn PrependBinder&lt;Item&gt;{BATT_FORWARD(item)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_PREPEND_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/print__out_8hpp/","title":"batteries/seq/print_out.hpp","text":""},{"location":"_autogen/Files/print__out_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/print__out_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::PrintOut"},{"location":"_autogen/Files/print__out_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_PRINT_OUT_HPP"},{"location":"_autogen/Files/print__out_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/print__out_8hpp/#define-batteries_seq_print_out_hpp","title":"define BATTERIES_SEQ_PRINT_OUT_HPP","text":"<pre><code>#define BATTERIES_SEQ_PRINT_OUT_HPP()\n</code></pre>"},{"location":"_autogen/Files/print__out_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_PRINT_OUT_HPP\n#define BATTERIES_SEQ_PRINT_OUT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/map.hpp&gt;\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n// print_out\n//\nstruct PrintOut {\nstd::ostream&amp; out;\nstd::string_view sep;\n};\ninline auto print_out(std::ostream&amp; out, std::string_view sep = \" \")\n{\nreturn PrintOut{out, sep};\n}\ntemplate &lt;typename Seq, typename = EnableIfSeq&lt;Seq&gt;&gt;\ninline auto operator|(Seq&amp;&amp; seq, PrintOut p)\n{\nreturn BATT_FORWARD(seq) | for_each([&amp;](auto&amp;&amp; item) {\np.out &lt;&lt; item &lt;&lt; p.sep;\n});\n}\ninline auto debug_out(std::ostream&amp; out, std::string_view sep = \" \")\n{\nreturn map([&amp;out, sep ](auto&amp;&amp; item) -&gt; auto{\nout &lt;&lt; item &lt;&lt; sep;\nreturn BATT_FORWARD(item);\n});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_PRINT_OUT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/printable_8hpp/","title":"batteries/seq/printable.hpp","text":""},{"location":"_autogen/Files/printable_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/printable_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Printable struct batt::seq::PrintableBinder"},{"location":"_autogen/Files/printable_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_PRINTABLE_HPP"},{"location":"_autogen/Files/printable_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/printable_8hpp/#define-batteries_seq_printable_hpp","title":"define BATTERIES_SEQ_PRINTABLE_HPP","text":"<pre><code>#define BATTERIES_SEQ_PRINTABLE_HPP()\n</code></pre>"},{"location":"_autogen/Files/printable_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_PRINTABLE_HPP\n#define BATTERIES_SEQ_PRINTABLE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/print_out.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\ntemplate &lt;typename Seq&gt;\nclass Printable\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit Printable(Seq&amp;&amp; seq) noexcept : seq_(BATT_FORWARD(seq))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn this-&gt;seq_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn this-&gt;seq_.next();\n}\nvoid operator()(std::ostream&amp; out)\n{\nbatt::make_copy(*this)                              //\n| map(BATT_OVERLOADS_OF(batt::make_printable))  //\n| print_out(out);\n}\nprivate:\nSeq seq_;\n};\nstruct PrintableBinder {\n};\ninline PrintableBinder printable()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\ninline auto operator|(Seq&amp;&amp; seq, PrintableBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;, \"Sequences may not be captured by reference.\");\nreturn Printable&lt;Seq&gt;{BATT_FORWARD(seq)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_PRINTABLE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/priority__watch_8hpp/","title":"batteries/async/priority_watch.hpp","text":""},{"location":"_autogen/Files/priority__watch_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/priority__watch_8hpp/#classes","title":"Classes","text":"Name class batt::detail::PriorityHeapItem class batt::detail::PriorityHeapItemList class batt::detail::PriorityHeap class batt::PriorityWatch"},{"location":"_autogen/Files/priority__watch_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_PRIORITY_WATCH_HPP"},{"location":"_autogen/Files/priority__watch_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/priority__watch_8hpp/#define-batteries_async_priority_watch_hpp","title":"define BATTERIES_ASYNC_PRIORITY_WATCH_HPP","text":"<pre><code>#define BATTERIES_ASYNC_PRIORITY_WATCH_HPP()\n</code></pre>"},{"location":"_autogen/Files/priority__watch_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_PRIORITY_WATCH_HPP\n#define BATTERIES_ASYNC_PRIORITY_WATCH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/math.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/loop_control.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;boost/container/static_vector.hpp&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;thread&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// TODO [tastolfi 2023-04-16]\n//  - This code needs to be as fast as is reasonably possible\n//  - Optimizations to try:\n//    - Convert as much as possible to branch-free style:\n//      - left/right symmetric cases should become index + children array[2]\n//      - use branch prediction hints\n//      - statically alloc a small array for heaps smaller than some number; use this\n//        in place of the pointers to decrease cache misses\n//      - generalized left/right processing should reduce total code size which will also help with cache\n//        locality\n//      - cache and maintain a bottom item pointer, so we don't have to do a log(N) traversal down a path to\n//        find it each time\n//      - change CHECKs to ASSERTs, perhaps through a template-based policy injection (so we can verify during\n//        testing, but disable for production code, even in RelWithDebInfo builds.\n//      - for items with the same `order` value, group at a single heap location, repurposing the 'child'\n//        pointers as double-linked list pointers\n//\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace detail {\ntemplate &lt;typename IntT&gt;\nclass PriorityHeap;\ntemplate &lt;typename IntT&gt;\nclass PriorityHeapItem\n{\npublic:\nfriend class PriorityHeap&lt;IntT&gt;;\nusing order_type = IntT;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit PriorityHeapItem(IntT order) noexcept : order_{order}\n{\n}\nPriorityHeapItem() = default;\nPriorityHeapItem(const PriorityHeapItem&amp;) = delete;\nPriorityHeapItem&amp; operator=(const PriorityHeapItem&amp;) = delete;\nIntT order() const noexcept\n{\nreturn this-&gt;order_;\n}\nbool is_linked() const noexcept\n{\nreturn this-&gt;children_[0] || this-&gt;children_[1];\n}\nprivate:\nIntT order_ = IntT{};\nstd::array&lt;PriorityHeapItem*, 2&gt; children_ = {nullptr, nullptr};\n};\ntemplate &lt;typename IntT&gt;\nclass PriorityHeapItemList\n{\npublic:\nusing Item = PriorityHeapItem&lt;IntT&gt;;\nvoid insert(Item* item)\n{\n//this-&gt;head_.children_[0]-&gt;children_[1] = item;\n//this-&gt;head_.children_[1]-&gt;children_[0] = item;\n//item-&gt;children_ = this-&gt;head_-&gt;children_;\nitem-&gt;children_[0] = &amp;this-&gt;head_;\nthis-&gt;head_.children_[1] = item;\n}\nprivate:\nItem head_;\n};\ntemplate &lt;typename IntT&gt;\nclass PriorityHeap\n{\npublic:\nusing Self = PriorityHeap;\nusing Item = PriorityHeapItem&lt;IntT&gt;;\nstatic constexpr usize kStackSize = sizeof(usize) * (8 /*bits per byte*/);\nusing StackVec = boost::container::static_vector&lt;Item**, kStackSize&gt;;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nBATT_ALWAYS_INLINE static Item** swap_child(Item** parent, usize i,\nconst std::array&lt;Item*, 2&gt;&amp; children) noexcept\n{\nconst usize j = i ^ 0x1;\n(*parent)-&gt;children_ = children[i]-&gt;children_;\nchildren[i]-&gt;children_[i] = (*parent);\nchildren[i]-&gt;children_[j] = children[j];\n(*parent) = children[i];\nreturn &amp;children[i]-&gt;children_[i];\n}\nBATT_ALWAYS_INLINE static Item** swap_left(Item** parent,\nconst std::array&lt;Item*, 2&gt;&amp; children) noexcept\n{\nreturn swap_child(parent, 0, children);\n}\nBATT_ALWAYS_INLINE static Item** swap_right(Item** parent,\nconst std::array&lt;Item*, 2&gt;&amp; children) noexcept\n{\nreturn swap_child(parent, 1, children);\n}\nBATT_ALWAYS_INLINE static i32 depth_upper_bound(usize path) noexcept\n{\nconstexpr i32 bits = sizeof(usize) * 8;\nreturn bits - __builtin_clzll(path) - 1;\n}\nBATT_ALWAYS_INLINE static usize get_top_mask(usize path) noexcept\n{\nreturn usize{1} &lt;&lt; Self::depth_upper_bound(path);\n}\ntemplate &lt;typename Fn&gt;\nBATT_ALWAYS_INLINE static void path_to_bottom(usize size, Fn&amp;&amp; fn) noexcept\n{\nconst usize path = size + 1;\nconst usize top_mask = Self::get_top_mask(path);\nfor (usize mask = top_mask &gt;&gt; 1; mask != 0; mask &gt;&gt;= 1) {\nbool go_left = ((path &amp; mask) == 0);\nfn(go_left);\n}\n}\ntemplate &lt;typename Fn&gt;\nBATT_ALWAYS_INLINE static void path_from_bottom(usize size, Fn&amp;&amp; fn) noexcept\n{\nconst usize path = size + 1;\nconst usize top_mask = Self::get_top_mask(path);\nfor (usize mask = 1; mask != top_mask; mask &lt;&lt;= 1) {\nbool go_left = ((path &amp; mask) == 0);\nif (seq::run_loop_fn(fn, go_left) == seq::LoopControl::kBreak) {\nbreak;\n}\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nPriorityHeap() = default;\nPriorityHeap(const PriorityHeap&amp;) = delete;\nPriorityHeap&amp; operator=(const PriorityHeap&amp;) = delete;\n~PriorityHeap() = default;\nPriorityHeap(PriorityHeap&amp;&amp; other) noexcept\n: top_{other.top_}\n, size_{other.size_}\n, min_value_{other.min_value_}\n{\nother.top_ = nullptr;\nother.size_ = 0;\nother.min_value_ = None;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nbool empty() const noexcept\n{\nreturn !this-&gt;top_;\n}\nusize size() const noexcept\n{\nreturn this-&gt;size_;\n}\nconst Optional&lt;IntT&gt;&amp; min_value() const noexcept\n{\nreturn this-&gt;min_value_;\n}\nconst Item* top() const noexcept\n{\nreturn this-&gt;top_;\n}\nvoid insert(Item* item) noexcept\n{\nitem-&gt;children_.fill(nullptr);\nauto on_scope_exit = batt::finally([&amp;] {\nthis-&gt;min_value_ = this-&gt;top_-&gt;order_;\nthis-&gt;size_ += 1;\n});\nif (!this-&gt;top_) {\nthis-&gt;top_ = item;\nreturn;\n}\nStackVec stack{&amp;this-&gt;top_};\n// First insert at the bottom of the heap...\n//\nSelf::path_to_bottom(this-&gt;size_, [&amp;stack](bool go_left) {\nItem** parent = stack.back();\nBATT_CHECK_NOT_NULLPTR((*parent));\nif (go_left) {\nstack.push_back(&amp;(*parent)-&gt;children_[0]);\n} else {\nstack.push_back(&amp;(*parent)-&gt;children_[1]);\n}\n});\n*(stack.back()) = item;\n// ...then back-track, fixing the heap\n// property.\n//\nSelf::path_from_bottom(this-&gt;size_, [&amp;stack](bool go_left) {\nstack.pop_back();\nItem** parent = stack.back();\nconst std::array&lt;Item*, 2&gt; children = (*parent)-&gt;children_;\nif (go_left) {\nif (BATT_HINT_TRUE(children[0]-&gt;order_ &lt; (*parent)-&gt;order_)) {\nSelf::swap_left(parent, children);\n} else {\nreturn seq::LoopControl::kBreak;\n}\n} else {\nif (BATT_HINT_TRUE(children[1]-&gt;order_ &lt; (*parent)-&gt;order_)) {\nSelf::swap_right(parent, children);\n} else {\nreturn seq::LoopControl::kBreak;\n}\n}\nreturn seq::LoopControl::kContinue;\n});\n}\nItem* remove() noexcept\n{\n// Base case: already empty.\n//\nif (!this-&gt;top_) {\nreturn nullptr;\n}\nauto on_scope_exit = batt::finally([&amp;] {\nif (this-&gt;top_) {\nthis-&gt;min_value_ = this-&gt;top_-&gt;order_;\n} else {\nthis-&gt;min_value_ = None;\n}\n});\nthis-&gt;size_ -= 1;\nItem* const removed = this-&gt;top_;\n// Base case: 2-&gt;1, 1-&gt;0.\n//\nif (!this-&gt;top_-&gt;children_[1]) {\nthis-&gt;top_ = removed-&gt;children_[0];\nremoved-&gt;children_[0] = nullptr;\nreturn removed;\n}\n// Find the bottom item.\n//\nItem** parent = &amp;this-&gt;top_;\nItem* bottom = this-&gt;top_;\nSelf::path_to_bottom(this-&gt;size_, [&amp;parent, &amp;bottom](bool go_left) {\nif (go_left) {\nparent = &amp;bottom-&gt;children_[0];\nbottom = bottom-&gt;children_[0];\n} else {\nparent = &amp;bottom-&gt;children_[1];\nbottom = bottom-&gt;children_[1];\n}\n});\nBATT_CHECK_NOT_NULLPTR(bottom);\nBATT_CHECK_EQ(bottom-&gt;children_[0], nullptr);\nBATT_CHECK_EQ(bottom-&gt;children_[1], nullptr);\n*parent = nullptr;\nstd::swap(bottom-&gt;children_[0], this-&gt;top_-&gt;children_[0]);\nstd::swap(bottom-&gt;children_[1], this-&gt;top_-&gt;children_[1]);\nthis-&gt;top_ = bottom;\nparent = &amp;this-&gt;top_;\nfor (;;) {\nBATT_CHECK_NOT_NULLPTR(*parent);\nstd::array&lt;Item*, 2&gt; children = (*parent)-&gt;children_;\nif (!children[0]) {\nBATT_CHECK_EQ(children[1], nullptr);\nbreak;\n}\nif (!children[1]) {\nif (!(children[0]-&gt;order_ &lt; (*parent)-&gt;order_)) {\nbreak;\n}\nparent = Self::swap_left(parent, children);\ncontinue;\n}\nif (BATT_HINT_TRUE(children[0]-&gt;order_ &lt; (*parent)-&gt;order_ ||\nchildren[1]-&gt;order_ &lt; (*parent)-&gt;order_)) {\nif (children[0]-&gt;order_ &lt; children[1]-&gt;order_) {\nparent = Self::swap_left(parent, children);\n} else {\nparent = Self::swap_right(parent, children);\n}\ncontinue;\n}\nbreak;\n}\nreturn removed;\n}\n[[nodiscard]] bool check_invariants(StackVec* stack, usize* count = nullptr)\n{\nBATT_CHECK_NOT_NULLPTR(stack);\nusize count_ = 0;\nif (!count) {\ncount = &amp;count_;\n}\nbool at_top = false;\nif (stack-&gt;empty()) {\nstack-&gt;push_back(&amp;this-&gt;top_);\nat_top = true;\n}\nItem* const parent = *stack-&gt;back();\nif (!parent) {\nreturn true;\n}\n*count += 1;\nif (parent-&gt;children_[0]) {\nstack-&gt;push_back(&amp;parent-&gt;children_[0]);\nif (parent-&gt;order_ &gt; parent-&gt;children_[0]-&gt;order_) {\nreturn false;\n}\nif (!this-&gt;check_invariants(stack, count)) {\nreturn false;\n}\nstack-&gt;pop_back();\n}\nif (parent-&gt;children_[1]) {\nstack-&gt;push_back(&amp;parent-&gt;children_[1]);\nif (parent-&gt;order_ &gt; parent-&gt;children_[1]-&gt;order_) {\nreturn false;\n}\nif (!this-&gt;check_invariants(stack, count)) {\nreturn false;\n}\nstack-&gt;pop_back();\n}\n#if BATT_DEBUG_PRIORITY_HEAP\nif (at_top &amp;&amp; (*count != this-&gt;size_)) {\nstd::cerr &lt;&lt; \"bad count!\" &lt;&lt; BATT_INSPECT(*count) &lt;&lt; BATT_INSPECT(this-&gt;size_) &lt;&lt; std::endl;\nthis-&gt;dump(std::cerr);\n}\n#endif  // BATT_DEBUG_PRIORITY_HEAP\nreturn !at_top || (*count == this-&gt;size_);\n}\nvoid dump(std::ostream&amp; out, Item* parent = nullptr, int depth = 0)\n{\nif (!parent &amp;&amp; depth == 0 &amp;&amp; this-&gt;top_) {\nthis-&gt;dump(out, this-&gt;top_);\nreturn;\n}\nout &lt;&lt; std::string(depth * 2, ' ') &lt;&lt; \"- \";\nif (!parent) {\nout &lt;&lt; \"nullptr\" &lt;&lt; std::endl;\n} else {\nout &lt;&lt; parent-&gt;order_ &lt;&lt; std::endl;\nthis-&gt;dump(out, parent-&gt;children_[0], depth + 1);\nthis-&gt;dump(out, parent-&gt;children_[1], depth + 1);\n}\n}\nprivate:\nItem* top_ = nullptr;\nusize size_ = 0;\nOptional&lt;IntT&gt; min_value_;\n};\n}  //namespace detail\ntemplate &lt;typename T&gt;\nclass PriorityWatch\n{\npublic:\nusing PriorityHandler = BasicAbstractHandler&lt;detail::PriorityHeapItem&lt;T&gt;, StatusOr&lt;T&gt;&gt;;\nstatic constexpr u32 kLocked = 0x01;\nstatic constexpr u32 kOpen = 0x02;\nstatic constexpr u32 kWaiting = 0x04;\nstatic constexpr u32 kClosedAtEnd = 0x08;\nstatic constexpr u32 kClosedBeforeEnd = 0x10;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStatus await_at_least(T min_value);\nT clamp_min_value(T min_value);\nT fetch_add(T delta);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nStatus get_final_status() const\n{\nconstexpr u32 mask = PriorityWatch::kClosedAtEnd | PriorityWatch::kClosedBeforeEnd;\nswitch (this-&gt;spin_state_.load() &amp; mask) {\ncase PriorityWatch::kClosedBeforeEnd:\nreturn Status{StatusCode::kClosedBeforeEndOfStream};\ncase PriorityWatch::kClosedAtEnd:\nreturn Status{StatusCode::kEndOfStream};\ndefault:\nbreak;\n}\nreturn Status{StatusCode::kClosed};\n}\nu32 lock_observers() const\n{\nfor (;;) {\nconst u32 prior_state = this-&gt;spin_state_.fetch_or(kLocked);\nif ((prior_state &amp; kLocked) == 0) {\nreturn prior_state;\n}\nstd::this_thread::yield();\n}\n}\nvoid unlock_observers(u32 desired_state) const\n{\nthis-&gt;spin_state_.store(desired_state &amp; ~kLocked);\n}\nvoid notify(T new_value)\n{\nconst auto post_change_state = this-&gt;spin_state_.load();\nif ((post_change_state &amp; (kLocked | kWaiting)) == 0) {\n//\n// If there is a concurrent call to async_wait that results in a handler being added to the\n// `observers_` list, it must go through the following atomic events:\n//\n//  1. load value (phase 1), no change\n//  2. set kLocked\n//  3. load value (phase 2), no change\n//  4. set kWaiting\n//\n// The notifier thread (this call), when not waking observers, goes through the following atomic\n// events:\n//\n//  a. change value\n//  b. load spin state, observe not kLocked and not kWaiting\n//\n// (b) must occur before (1) [therefore (a) &lt; (1)] or between (1) and (2) [(a) &lt; (3)].  In either\n// case, the async_wait call will load the value *after* this thread changes it (a), so there will\n// be no spurious deadlocks.\n//\nreturn;\n}\n// Acquire the spinlock.\n//\nconst auto pre_lock_state = this-&gt;lock_observers();\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers = std::move(this-&gt;observers_);\nthis-&gt;unlock_observers(pre_lock_state &amp; ~(kWaiting));\ninvoke_all_handlers(&amp;local_observers, new_value);\n//\n// IMPORTANT: we must not touch *anything* in `this` after invoking handlers, since one of the\n// handlers may delete this Watch object.\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstd::atomic&lt;T&gt; value_{0};\nmutable std::atomic&lt;u32&gt; spin_state_{/*kOpen*/ 0};\nmutable detail::PriorityHeap&lt;T&gt; observers_;\n};\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename IntT&gt;\ninline Status PriorityWatch&lt;IntT&gt;::await_at_least(IntT min_value)\n{\n(void)min_value;\nreturn OkStatus();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename IntT&gt;\ninline IntT PriorityWatch&lt;IntT&gt;::clamp_min_value(IntT min_value)\n{\n(void)min_value;\nreturn 0;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename IntT&gt;\ninline IntT PriorityWatch&lt;IntT&gt;::fetch_add(IntT delta)\n{\n(void)delta;\nreturn 0;\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_PRIORITY_WATCH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/product_8hpp/","title":"batteries/seq/product.hpp","text":""},{"location":"_autogen/Files/product_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/product_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::ProductBinder"},{"location":"_autogen/Files/product_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_PRODUCT_HPP"},{"location":"_autogen/Files/product_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/product_8hpp/#define-batteries_seq_product_hpp","title":"define BATTERIES_SEQ_PRODUCT_HPP","text":"<pre><code>#define BATTERIES_SEQ_PRODUCT_HPP()\n</code></pre>"},{"location":"_autogen/Files/product_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_PRODUCT_HPP\n#define BATTERIES_SEQ_PRODUCT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/reduce.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// product\n//\nstruct ProductBinder {\n};\ninline ProductBinder product()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, ProductBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::product) Sequences may not be captured implicitly by reference.\");\nreturn BATT_FORWARD(seq) | reduce(SeqItem&lt;Seq&gt;{1}, [](auto&amp;&amp; a, auto&amp;&amp; b) {\nreturn a * b;\n});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_PRODUCT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/prometheus__exporter_8hpp/","title":"batteries/metrics/prometheus_exporter.hpp","text":""},{"location":"_autogen/Files/prometheus__exporter_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/prometheus__exporter_8hpp/#classes","title":"Classes","text":"Name class batt::PrometheusMetricExporter struct batt::PrometheusMetricExporter::Metrics"},{"location":"_autogen/Files/prometheus__exporter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_METRICS_PROMETHEUS_EXPORTER_HPP"},{"location":"_autogen/Files/prometheus__exporter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/prometheus__exporter_8hpp/#define-batteries_metrics_prometheus_exporter_hpp","title":"define BATTERIES_METRICS_PROMETHEUS_EXPORTER_HPP","text":"<pre><code>#define BATTERIES_METRICS_PROMETHEUS_EXPORTER_HPP()\n</code></pre>"},{"location":"_autogen/Files/prometheus__exporter_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_METRICS_PROMETHEUS_EXPORTER_HPP\n#define BATTERIES_METRICS_PROMETHEUS_EXPORTER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/metrics/metric_collectors.hpp&gt;\n#include &lt;batteries/metrics/metric_otel_formatter.hpp&gt;\n#include &lt;batteries/metrics/metric_registry.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/asio/io_context.hpp&gt;\n#include &lt;batteries/asio/ip_tcp.hpp&gt;\n#include &lt;cstring&gt;\n#include &lt;sstream&gt;\nnamespace batt {\nclass PrometheusMetricExporter\n{\npublic:\nusing Self = PrometheusMetricExporter;\nstruct Metrics {\nCountMetric&lt;u64&gt; export_count{0};\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic Metrics&amp; metrics()\n{\nstatic Metrics metrics_;\nstatic bool init_ [[maybe_unused]] = [&amp;] {\nglobal_metric_registry().add(\"export_count\", metrics_.export_count);\nreturn true;\n}();\nreturn metrics_;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nPrometheusMetricExporter(const PrometheusMetricExporter&amp;) = delete;\nPrometheusMetricExporter&amp; operator=(const PrometheusMetricExporter&amp;) = delete;\nexplicit PrometheusMetricExporter(boost::asio::io_context&amp; io, MetricRegistry&amp; registry,\nconst boost::asio::ip::tcp::endpoint&amp; endpoint) noexcept\n: acceptor_{io.get_executor(), endpoint}\n, registry_{registry}\n, endpoint_{endpoint}\n{\n}\nexplicit PrometheusMetricExporter(boost::asio::io_context&amp; io,\nconst boost::asio::ip::tcp::endpoint&amp; endpoint) noexcept\n: PrometheusMetricExporter{io, global_metric_registry(), endpoint}\n{\n}\nexplicit PrometheusMetricExporter(boost::asio::io_context&amp; io, u16 port) noexcept\n: PrometheusMetricExporter{\nio, global_metric_registry(),\nboost::asio::ip::tcp::endpoint{boost::asio::ip::address_v4::from_string(\"0.0.0.0\"), port}}\n{\n}\nvoid start()\n{\nif (!this-&gt;task_) {\nthis-&gt;task_.emplace(this-&gt;acceptor_.get_executor(), [this] {\nStatus status = this-&gt;run();\nBATT_VLOG(1) &lt;&lt; BATT_INSPECT(status);\n});\n}\n}\nvoid halt()\n{\nboost::system::error_code ec;\nthis-&gt;acceptor_.close(ec);\nBATT_VLOG(1) &lt;&lt; BATT_INSPECT(batt::to_status(ec));\n}\nvoid join()\n{\nif (this-&gt;task_) {\nthis-&gt;task_-&gt;join();\nthis-&gt;task_ = None;\n}\n}\nbatt::Status run()\n{\nboost::system::error_code ec;\nthis-&gt;acceptor_.listen(boost::asio::ip::tcp::socket::max_listen_connections, ec);\nBATT_REQUIRE_OK(ec);\nfor (;;) {\nauto socket =\nbatt::Task::await&lt;batt::IOResult&lt;boost::asio::ip::tcp::socket&gt;&gt;([this](auto&amp;&amp; handler) {\nthis-&gt;acceptor_.async_accept(BATT_FORWARD(handler));\n});\nBATT_REQUIRE_OK(socket);\nTask::spawn(\nTask::current().get_executor(),\n[this, socket = std::move(*socket)]() mutable {\nStatus status = this-&gt;run_connection(std::move(socket));\nBATT_VLOG(1) &lt;&lt; BATT_INSPECT(status);\n},\n\"metric exporter connection\");\n}\n}\nbatt::Status run_connection(boost::asio::ip::tcp::socket socket)\n{\nauto on_scope_exit = batt::finally([&amp;] {\nboost::system::error_code ec;\nsocket.close(ec);\nBATT_VLOG(1) &lt;&lt; \"PrometheusMetricExporter socket closed:\" &lt;&lt; BATT_INSPECT(ec);\n});\nSelf::metrics().export_count.add(1);\nstd::ostringstream body_out;\nthis-&gt;formatter_.format_values(this-&gt;registry_, body_out);\nstd::string body_str = std::move(body_out).str();\nstd::ostringstream header_out;\nheader_out &lt;&lt; \"HTTP/1.1 200 OK\\r\\n\"\n&lt;&lt; \"Content-Type: text/plain; version=0.0.4; charset=utf-8\\r\\n\"\n&lt;&lt; \"Content-Length: \" &lt;&lt; body_str.size() &lt;&lt; \"\\r\\n\"\n&lt;&lt; \"Connection: close\\r\\n\"\n&lt;&lt; \"\\r\\n\";\nstd::string header_str = std::move(header_out).str();\nIOResult&lt;usize&gt; result = Task::await_write(\nsocket, std::array&lt;ConstBuffer, 2&gt;{ConstBuffer{header_str.data(), header_str.size()},\nConstBuffer{body_str.data(), body_str.size()}});\nBATT_VLOG(1) &lt;&lt; \"Metrics written;\" &lt;&lt; BATT_INSPECT(result);\nstd::array&lt;char, 512&gt; buffer;\nauto mbuffer = MutableBuffer{buffer.data(), buffer.size()};\nusize extra = 0;\nfor (;;) {\nIOResult&lt;usize&gt; n_read = Task::await_read_some(socket, mbuffer);\nBATT_REQUIRE_OK(n_read);\nauto str = std::string_view{buffer.data(), *n_read + extra};\nconst auto CRLF_CRLF = std::string_view{\"\\r\\n\\r\\n\"};\nconst auto LF_LF = std::string_view{\"\\n\\n\"};\nif (str.find(CRLF_CRLF) != std::string_view::npos || str.find(LF_LF) != std::string_view::npos) {\nbreak;\n}\nextra = std::min&lt;usize&gt;(3, str.size());\nstd::memmove(buffer.data(), buffer.data() + (str.size() - extra), extra);\nmbuffer = MutableBuffer{buffer.data() + extra, buffer.size() - extra};\n}\nreturn OkStatus();\n}\nprivate:\nboost::asio::ip::tcp::acceptor acceptor_;\nMetricRegistry&amp; registry_;\nboost::asio::ip::tcp::endpoint endpoint_;\nMetricOpenTelemetryFormatter formatter_;\nbatt::Optional&lt;batt::Task&gt; task_;\n};\n}  //namespace batt\n#endif  // BATTERIES_METRICS_PROMETHEUS_EXPORTER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/queue_8hpp/","title":"batteries/async/queue.hpp","text":""},{"location":"_autogen/Files/queue_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/queue_8hpp/#classes","title":"Classes","text":"Name class batt::QueueBase Type-agnostic base class for all Queue types. class batt::Queue Unbounded multi-producer/multi-consumer (MPMC) FIFO queue."},{"location":"_autogen/Files/queue_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_QUEUE_HPP"},{"location":"_autogen/Files/queue_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/queue_8hpp/#define-batteries_async_queue_hpp","title":"define BATTERIES_ASYNC_QUEUE_HPP","text":"<pre><code>#define BATTERIES_ASYNC_QUEUE_HPP()\n</code></pre>"},{"location":"_autogen/Files/queue_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_QUEUE_HPP\n#define BATTERIES_ASYNC_QUEUE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/do_nothing.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;deque&gt;\nnamespace batt {\nclass QueueBase\n{\npublic:\nbool is_open() const\n{\nreturn !this-&gt;pending_count_.is_closed();\n}\nbool is_closed() const\n{\nreturn !this-&gt;is_open();\n}\ni64 size() const\n{\nreturn this-&gt;pending_count_.get_value();\n}\nbool empty() const\n{\nreturn this-&gt;size() == 0;\n}\ntemplate &lt;typename Predicate = bool(i64)&gt;\nStatusOr&lt;i64&gt; await_size_is_truly(Predicate&amp;&amp; predicate)\n{\nreturn this-&gt;pending_count_.await_true(BATT_FORWARD(predicate));\n}\nStatusOr&lt;i64&gt; await_empty()\n{\nreturn this-&gt;await_size_is_truly([](i64 count) {\nBATT_ASSERT_GE(count, 0);\nreturn count == 0;\n});\n}\nvoid poke()\n{\nthis-&gt;pending_count_.poke();\n}\nprotected:\nStatus await_one() noexcept\n{\nStatusOr&lt;i64&gt; prior_count = this-&gt;pending_count_.await_modify(&amp;decrement_if_positive);\nBATT_REQUIRE_OK(prior_count);\nBATT_CHECK_GT(*prior_count, 0);\nreturn OkStatus();\n}\nStatusOr&lt;i64&gt; await_count_range(i64 min_count, i64 max_count) noexcept\n{\ni64 modified_count = 0;\nStatusOr&lt;i64&gt; prior_count = this-&gt;pending_count_.await_modify([&amp;](i64 n) -&gt; Optional&lt;i64&gt; {\nif (n &lt; min_count) {\nreturn None;\n}\nif (n &gt; max_count) {\nmodified_count = n - max_count;\n} else {\nmodified_count = 0;\n}\nreturn modified_count;\n});\nBATT_REQUIRE_OK(prior_count);\nconst i64 claimed_count = *prior_count - modified_count;\nBATT_CHECK_GE(claimed_count, min_count) &lt;&lt; BATT_INSPECT(*prior_count) &lt;&lt; BATT_INSPECT(modified_count);\nBATT_CHECK_LE(claimed_count, max_count) &lt;&lt; BATT_INSPECT(*prior_count) &lt;&lt; BATT_INSPECT(modified_count);\nreturn claimed_count;\n}\nbool try_acquire() noexcept\n{\nOptional&lt;i64&gt; prior_count = this-&gt;pending_count_.modify_if(&amp;decrement_if_positive);\nif (!prior_count) {\nreturn false;\n}\nBATT_CHECK_GT(*prior_count, 0);\nreturn true;\n}\nvoid notify(i64 count)\n{\nthis-&gt;pending_count_.fetch_add(count);\n}\nvoid close_impl() noexcept\n{\nthis-&gt;pending_count_.close();\n}\nprivate:\nstatic Optional&lt;i64&gt; decrement_if_positive(i64 n) noexcept\n{\nif (n &gt; 0) {\nreturn n - 1;\n}\nreturn None;\n}\nWatch&lt;i64&gt; pending_count_{0};\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T&gt;\nclass Queue : public QueueBase\n{\npublic:\nvoid close()\n{\nScopedLock&lt;std::deque&lt;T&gt;&gt; locked{this-&gt;pending_items_};\nthis-&gt;close_impl();\n}\ntemplate &lt;typename... Args&gt;\nStatus push(Args&amp;&amp;... args)\n{\n{\nScopedLock&lt;std::deque&lt;T&gt;&gt; locked{this-&gt;pending_items_};\nif (!this-&gt;is_open()) {\nreturn {StatusCode::kClosed};\n}\nlocked-&gt;emplace_back(BATT_FORWARD(args)...);\n}\nthis-&gt;notify(1);\nreturn OkStatus();\n}\ntemplate &lt;typename FactoryFn&gt;\nStatus push_with_lock(FactoryFn&amp;&amp; factory_fn)\n{\n{\nScopedLock&lt;std::deque&lt;T&gt;&gt; locked{this-&gt;pending_items_};\nif (!this-&gt;is_open()) {\nreturn {StatusCode::kClosed};\n}\nlocked-&gt;emplace_back(BATT_FORWARD(factory_fn)());\n}\nthis-&gt;notify(1);\nreturn OkStatus();\n}\ntemplate &lt;typename Items&gt;\nStatus push_all(Items&amp;&amp; items)\n{\nauto first = std::begin(items);\nauto last = std::end(items);\nconst usize count = std::distance(first, last);\nbool closed = false;\nthis-&gt;pending_items_.with_lock([&amp;](auto&amp; pending) {\nif (!this-&gt;is_open()) {\nclosed = true;\n} else {\npending.insert(pending.end(), first, last);\n}\n});\nif (closed) {\nreturn {StatusCode::kClosed};\n}\nthis-&gt;notify(count);\nreturn OkStatus();\n}\ntemplate &lt;typename Items&gt;\nStatus consume_all(Items&amp;&amp; items)\n{\nauto first = std::begin(items);\nauto last = std::end(items);\nconst usize count = std::distance(first, last);\nbool closed = false;\nthis-&gt;pending_items_.with_lock([&amp;](auto&amp; pending) {\nif (!this-&gt;is_open()) {\nclosed = true;\n} else {\npending.insert(pending.end(),                   //\nstd::make_move_iterator(first),  //\nstd::make_move_iterator(last));\n}\n});\nif (closed) {\nreturn {StatusCode::kClosed};\n}\nthis-&gt;notify(count);\nreturn OkStatus();\n}\nStatusOr&lt;T&gt; await_next()\n{\nStatus acquired = this-&gt;await_one();\nBATT_REQUIRE_OK(acquired);\nreturn this-&gt;pop_next_or_panic();\n}\ntemplate &lt;typename Iter&gt;\nStatusOr&lt;Iter&gt; await_some(Iter&amp;&amp; first_out, Iter&amp;&amp; last_out)\n{\nconst i64 max_count = std::distance(first_out, last_out);\nStatusOr&lt;i64&gt; claimed_count = this-&gt;await_count_range(/*min_count=*/1, max_count);\nBATT_REQUIRE_OK(claimed_count);\nconst usize n_to_pop = BATT_CHECKED_CAST(usize, *claimed_count);\n{\nScopedLock&lt;std::deque&lt;T&gt;&gt; locked{this-&gt;pending_items_};\nBATT_CHECK_GE(locked-&gt;size(), n_to_pop);\nauto first = locked-&gt;begin();\nauto last = std::next(first, n_to_pop);\nstd::copy(std::make_move_iterator(first),  //\nstd::make_move_iterator(last), first_out);\nlocked-&gt;erase(first, last);\n}\nreturn std::next(first_out, n_to_pop);\n}\nOptional&lt;T&gt; try_pop_next()\n{\nif (!this-&gt;try_acquire()) {\nreturn None;\n}\nreturn this-&gt;pop_next_or_panic();\n}\nT pop_next_or_panic()\n{\nScopedLock&lt;std::deque&lt;T&gt;&gt; locked{this-&gt;pending_items_};\nBATT_CHECK(!locked-&gt;empty()) &lt;&lt; \"pop_next_or_panic FAILED because the queue is empty\";\nauto on_return = batt::finally([&amp;] {\nlocked-&gt;pop_front();\n});\nreturn std::forward&lt;T&gt;(locked-&gt;front());\n}\ntemplate &lt;typename CleanupFn = DoNothing&gt;\nusize drain(CleanupFn&amp;&amp; cleanup_fn = {})\n{\nusize count = 0;\nfor (;;) {\nOptional&lt;T&gt; next = this-&gt;try_pop_next();\nif (!next) {\nbreak;\n}\n++count;\ntry {\ncleanup_fn(*next);\n} catch (...) {\ncontinue;\n}\n}\nreturn count;\n}\nprivate:\nMutex&lt;std::deque&lt;T&gt;&gt; pending_items_;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_QUEUE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/radix__queue_8hpp/","title":"batteries/radix_queue.hpp","text":""},{"location":"_autogen/Files/radix__queue_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/radix__queue_8hpp/#classes","title":"Classes","text":"Name class batt::RadixQueue struct batt::RadixQueue::Segment struct batt::RadixQueue::Hash"},{"location":"_autogen/Files/radix__queue_8hpp/#defines","title":"Defines","text":"Name BATTERIES_RADIX_QUEUE_HPP"},{"location":"_autogen/Files/radix__queue_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/radix__queue_8hpp/#define-batteries_radix_queue_hpp","title":"define BATTERIES_RADIX_QUEUE_HPP","text":"<pre><code>#define BATTERIES_RADIX_QUEUE_HPP()\n</code></pre>"},{"location":"_autogen/Files/radix__queue_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_RADIX_QUEUE_HPP\n#define BATTERIES_RADIX_QUEUE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;boost/functional/hash.hpp&gt;\n#include &lt;boost/operators.hpp&gt;\n#include &lt;array&gt;\n#include &lt;limits&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;usize kCapacityInBits&gt;\nclass RadixQueue;\ntemplate &lt;usize N_&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const RadixQueue&lt;N_&gt;&amp; t);\n// A fixed-capacity FIFO queue of integers with variable radix per integer.  This is used to store sequences\n// of events.\n//\ntemplate &lt;usize kCapacityInBits&gt;\nclass RadixQueue : public boost::equality_comparable&lt;RadixQueue&lt;kCapacityInBits&gt;&gt;\n{\npublic:\nstatic constexpr usize kQueueSize = kCapacityInBits / 64;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nusing index_type = std::conditional_t&lt;\n(kCapacityInBits &lt;= std::numeric_limits&lt;u16&gt;::max()),\nstd::conditional_t&lt;(kCapacityInBits &lt;= std::numeric_limits&lt;u8&gt;::max()), u8, u16&gt;,\nstd::conditional_t&lt;(kCapacityInBits &lt;= std::numeric_limits&lt;u32&gt;::max()), u32, u64&gt;&gt;;\n// The queue is stored in segments of 64 bits each.\n//\nstruct Segment {\nu64 radix = 1;\nu64 value = 0;\nfriend inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Segment&amp; t)\n{\nreturn out &lt;&lt; \"{.value=\" &lt;&lt; t.value &lt;&lt; \", .radix=\" &lt;&lt; t.radix &lt;&lt; \"}\";\n}\n};\n// Default hash function.\n//\nstruct Hash {\nusing value_type = usize;\nusize operator()(const RadixQueue&amp; r) const\n{\nconst usize size = r.queue_size();\nusize seed = size;\nfor (usize i = 0; i &lt; size; ++i) {\nconst usize j = (r.front_ + i) % kQueueSize;\nboost::hash_combine(seed, r.queue_[j].radix);\nboost::hash_combine(seed, r.queue_[j].value);\n}\nreturn seed;\n}\n};\nbool operator==(const RadixQueue&amp; other) const\n{\nconst usize size = this-&gt;queue_size();\nif (size != other.queue_size()) {\nreturn false;\n}\nfor (usize i = 0; i &lt; size; ++i) {\nconst usize this_j = (this-&gt;front_ + i) % kQueueSize;\nconst usize other_j = (other.front_ + i) % kQueueSize;\nif (this-&gt;queue_[this_j].radix != other.queue_[other_j].radix ||\nthis-&gt;queue_[this_j].value != other.queue_[other_j].value) {\nreturn false;\n}\n}\nreturn true;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nRadixQueue() = default;\n// Returns true when there are no items in the queue.\n//\nbool empty() const\n{\nreturn this-&gt;queue_size() == 1 &amp;&amp; this-&gt;front().radix == 1;\n}\n// Returns true when the queue has reached its maximum capacity.\n//\nbool full() const\n{\nreturn this-&gt;front_ == (this-&gt;back_ + 1) % kQueueSize;\n}\n// Discards the contents of the queue, resetting it to default state.\n//\nvoid clear()\n{\nthis-&gt;front_ = 0;\nthis-&gt;back_ = 0;\nthis-&gt;queue_[0] = Segment{};\n}\n// Insert the given value with the given radix at the back of the queue.\n//\nvoid push(u64 radix, u64 value)\n{\nBATT_CHECK_GT(radix, value) &lt;&lt; \"value must not exceed the supplied radix\";\nconst bool would_overflow = std::numeric_limits&lt;u64&gt;::max() / this-&gt;back().radix &lt; radix;\nif (would_overflow) {\nthis-&gt;push_back();\n}\nSegment&amp; s = this-&gt;back();\ns.value += value * s.radix;\ns.radix *= radix;\n}\n// Extract the next value out of the queue.  The passed radix must match the radix used when inserting\n// the item originally; otherwise behavior is undefined.\n//\nu64 pop(u64 radix)\n{\nSegment&amp; s = this-&gt;front();\nBATT_CHECK_LE(radix, s.radix) &lt;&lt; \"the supplied radix is too large\";\nconst u64 value = s.value % radix;\ns.radix /= radix;\ns.value /= radix;\nBATT_CHECK_LT(s.value, s.radix);\nif (s.radix == 1 &amp;&amp; this-&gt;queue_size() &gt; 1) {\nthis-&gt;pop_front();\n}\nreturn value;\n}\ntemplate &lt;usize N_&gt;\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const RadixQueue&lt;N_&gt;&amp; t);\nprivate:\nstatic void advance_index(index_type* i)\n{\n*i = (*i + 1) % kQueueSize;\n}\nusize queue_size() const\n{\nconst usize upper_bound = [&amp;]() -&gt; usize {\nif (this-&gt;front_ &lt;= this-&gt;back_) {\nreturn this-&gt;back_ + 1;\n}\nreturn kQueueSize + this-&gt;back_ + 1;\n}();\nBATT_CHECK_LT(this-&gt;front_, upper_bound);\nreturn upper_bound - this-&gt;front_;\n}\nSegment&amp; front()\n{\nreturn this-&gt;queue_[this-&gt;front_];\n}\nconst Segment&amp; front() const\n{\nreturn this-&gt;queue_[this-&gt;front_];\n}\nSegment&amp; back()\n{\nreturn this-&gt;queue_[this-&gt;back_];\n}\nconst Segment&amp; back() const\n{\nreturn this-&gt;queue_[this-&gt;back_];\n}\nvoid pop_front()\n{\nBATT_CHECK_NE(this-&gt;front_, this-&gt;back_) &lt;&lt; \"pull failed; the RadixQueue is empty\";\nadvance_index(&amp;this-&gt;front_);\n}\nvoid push_back()\n{\nBATT_CHECK(!this-&gt;full()) &lt;&lt; \"push failed; the RadixQueue is full\";\nadvance_index(&amp;this-&gt;back_);\nthis-&gt;queue_[this-&gt;back_] = Segment{};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nindex_type front_ = 0;\nindex_type back_ = 0;\nstd::array&lt;Segment, kQueueSize&gt; queue_;\n};\ntemplate &lt;usize N_&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const RadixQueue&lt;N_&gt;&amp; t)\n{\nusize end = (t.front_ &lt;= t.back_) ? (t.back_ + 1) : (t.back_ + 1 + t.queue_.size());\nout &lt;&lt; \"{\";\nfor (usize i = t.front_; i &lt; end; ++i) {\nconst auto&amp; s = t.queue_[i % t.queue_.size()];\nout &lt;&lt; s.value &lt;&lt; \"/\" &lt;&lt; s.radix &lt;&lt; \",\";\n}\nreturn out &lt;&lt; \"}\";\n}\n}  // namespace batt\n#endif  // BATTERIES_RADIX_QUEUE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/rate__limiter_8hpp/","title":"batteries/async/rate_limiter.hpp","text":""},{"location":"_autogen/Files/rate__limiter_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/rate__limiter_8hpp/#classes","title":"Classes","text":"Name class batt::BasicRateLimiter"},{"location":"_autogen/Files/rate__limiter_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_RATE_LIMITER_HPP"},{"location":"_autogen/Files/rate__limiter_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/rate__limiter_8hpp/#define-batteries_async_rate_limiter_hpp","title":"define BATTERIES_ASYNC_RATE_LIMITER_HPP","text":"<pre><code>#define BATTERIES_ASYNC_RATE_LIMITER_HPP()\n</code></pre>"},{"location":"_autogen/Files/rate__limiter_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_RATE_LIMITER_HPP\n#define BATTERIES_ASYNC_RATE_LIMITER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;chrono&gt;\nnamespace batt {\ntemplate &lt;typename Clock&gt;\nclass BasicRateLimiter\n{\npublic:\n// `rate` - the limit rate in operations per second\n// `burst` - the number of \"unspent\" operations we allow to accumulate for immediate consumption;\n// 1 means there is no burst capability, &gt;1 means that a client can temporarily perform up to\n// `burst` operations immediately, assuming there is enough time in the past to cover those ops.\n//\nexplicit BasicRateLimiter(double rate, i64 burst = 1) noexcept : rate_{rate}, burst_{burst}\n{\n}\n// Performs a non-blocking check to see whether enough time has elapsed for us to consume one\n// count.  If so, consume the count and return true, else return false.\n//\nbool poll()\n{\nconst i64 current_upper_bound = this-&gt;get_current_upper_bound();\nif (current_upper_bound - this-&gt;count_ &gt; this-&gt;burst_) {\nthis-&gt;count_ = current_upper_bound - this-&gt;burst_;\n}\nif (this-&gt;count_ == current_upper_bound) {\nreturn false;\n}\nthis-&gt;count_ += 1;\nBATT_CHECK_LE(this-&gt;count_, current_upper_bound);\nreturn true;\n}\n// Returns the amount of accumulated count available for consumption.\n//\ni64 available() const\n{\nreturn std::clamp&lt;i64&gt;(this-&gt;get_current_upper_bound() - this-&gt;count_, 0, this-&gt;burst_);\n}\n// How many seconds until the next allowed operation.  May return a negative value if `poll()` will return\n// `true`.\n//\ndouble time_remaining_sec() const\n{\nreturn static_cast&lt;double&gt;(this-&gt;count_ + 1) / this-&gt;rate_ - this-&gt;elapsed_sec();\n}\n// The total elapsed time since this object was created, in microseconds.\n//\ndouble elapsed_usec() const\n{\nreturn static_cast&lt;double&gt;(std::max&lt;i64&gt;(\n0, std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(Clock::now() - this-&gt;start_).count()));\n}\n// The total elapsed time since this object was created, in seconds.\n//\ndouble elapsed_sec() const\n{\nreturn this-&gt;elapsed_usec() / double{1000.0 * 1000.0};\n}\n// The minimum allowed amortized time between operations.\n//\ndouble period_sec() const\n{\nreturn double{1.0} / this-&gt;rate_;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\ni64 get_current_upper_bound() const\n{\nreturn static_cast&lt;i64&gt;(this-&gt;elapsed_sec() * this-&gt;rate_);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// The creation time of this object.\n//\ntypename Clock::time_point start_ = Clock::now();\n// The number of operations performed (i.e., the number of times `poll()` returned 1).\n//\ni64 count_ = 0;\n// The number of allowed _amortized_ operations per second.\n//\ndouble rate_;\n// The maximum amortization factor -- how many operations can be performed immediately if we wait\n// for `burst_ * rate_` seconds.\n//\ni64 burst_;\n};\nusing RateLimiter = BasicRateLimiter&lt;std::chrono::steady_clock&gt;;\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_RATE_LIMITER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/read__write__lock_8hpp/","title":"batteries/async/read_write_lock.hpp","text":""},{"location":"_autogen/Files/read__write__lock_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/read__write__lock_8hpp/#classes","title":"Classes","text":"Name struct batt::DumpReadWriteLockState class batt::BasicReadWriteLock An MCS-style fair reader/writer lock. class batt::BasicReadWriteLock::QueueNode Base class for Reader and Writer scoped lock guards. class batt::BasicReadWriteLock::Reader class batt::BasicReadWriteLock::Writer class batt::ReadWriteMutex Mutex wrapper for a value of type T, providing exclusive read/write access and non-exclusive read-only access. struct batt::ReadWriteMutex::ThreadSafeBaseIsNotSupportedByType Returned by Mutex::thread_safe_base when no-lock access isn't enabled; the name of this type is designed to produce a compilation error that makes it obvious what the problem is. class batt::ScopedReadWriteLockImpl"},{"location":"_autogen/Files/read__write__lock_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_READ_WRITE_LOCK_HPP"},{"location":"_autogen/Files/read__write__lock_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/read__write__lock_8hpp/#define-batteries_async_read_write_lock_hpp","title":"define BATTERIES_ASYNC_READ_WRITE_LOCK_HPP","text":"<pre><code>#define BATTERIES_ASYNC_READ_WRITE_LOCK_HPP()\n</code></pre>"},{"location":"_autogen/Files/read__write__lock_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_READ_WRITE_LOCK_HPP\n#define BATTERIES_ASYNC_READ_WRITE_LOCK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/futex.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;bitset&gt;\n#include &lt;ostream&gt;\nnamespace batt {\nstruct DumpReadWriteLockState {\nu32 state_value;\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DumpReadWriteLockState&amp; dump);\nenum struct ReadWriteLockQueueNodeClass : int {\nkReading = 0,\nkWriting = 1,\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, ReadWriteLockQueueNodeClass t);\ntemplate &lt;template &lt;typename&gt; class WatchImplT, bool kPollForNext = false&gt;\nclass BasicReadWriteLock\n{\npublic:\nusing Self = BasicReadWriteLock;\nusing Lock = Self;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr u32 kBlockedMask = 0b1;\nstatic constexpr u32 kBlockedFalse = 0b0;\nstatic constexpr u32 kBlockedTrue = 0b1;\nstatic constexpr u32 kSuccessorMask = 0b110;\nstatic constexpr u32 kSuccessorNone = 0b000;\nstatic constexpr u32 kSuccessorReader = 0b010;\nstatic constexpr u32 kSuccessorWriter = 0b100;\nstatic constexpr u32 make_state(u32 is_blocked, u32 successor_class) noexcept\n{\nreturn (is_blocked &amp; kBlockedMask) | (successor_class &amp; kSuccessorMask);\n}\nstatic constexpr bool is_blocked_from_state(u32 state) noexcept\n{\nreturn (state &amp; kBlockedMask) != 0;\n}\nstatic constexpr u32 successor_class_from_state(u32 state) noexcept\n{\nreturn (state &amp; kSuccessorMask);\n}\nusing DumpState = DumpReadWriteLockState;\n//----- --- -- -  -  -   -\nstatic constexpr u32 kInitialState = Self::make_state(Self::kBlockedTrue, Self::kSuccessorNone);\nstatic_assert(kInitialState == 1);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nclass QueueNode\n{\npublic:\nusing NodeClass = ReadWriteLockQueueNodeClass;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit QueueNode(Lock* lock, NodeClass node_class) noexcept\n: lock_{lock}\n, class_{node_class}\n, next_{nullptr}\n, state_{Self::kInitialState}\n{\n}\n//----- --- -- -  -  -   -\nQueueNode* fast_lock_or_get_predecessor(u32&amp; observed_state) noexcept\n{\nobserved_state = Self::kInitialState;\nQueueNode* const pred = this-&gt;lock_-&gt;tail_-&gt;exchange(this);\nreturn pred;\n}\n//----- --- -- -  -  -   -\ntemplate &lt;typename Mode&gt;\nvoid set_unblocked(u32&amp; observed_state, Mode mode) noexcept\n{\nobserved_state = this-&gt;state_-&gt;fetch_and(~kBlockedTrue, mode) &amp; ~kBlockedTrue;\n}\n//----- --- -- -  -  -   -\nvoid await_unblocked(u32&amp; observed_state) noexcept\n{\nBATT_DEBUG_INFO(\"next=\" &lt;&lt; (void*)this-&gt;next_-&gt;get_value() &lt;&lt; BATT_INSPECT((void*)this)\n&lt;&lt; BATT_INSPECT(this-&gt;class_)\n&lt;&lt; \" state=\" &lt;&lt; DumpState{this-&gt;state_-&gt;get_value()}\n&lt;&lt; BATT_INSPECT((void*)this-&gt;lock_));\n// We have exceeded the maximum allowed initial spin cycles; use the more expensive `await_true`\n// method.\n//\nconst StatusOr&lt;u32&gt; new_observed_state =  //\nthis-&gt;state_-&gt;await_true([](u32 observed_state) {\nreturn !is_blocked_from_state(observed_state);\n});\nBATT_CHECK_OK(new_observed_state);\nobserved_state = *new_observed_state;\n}\n//----- --- -- -  -  -   -\nbool fast_unlock(QueueNode*&amp; observed_next) noexcept\n{\nobserved_next = this-&gt;next_-&gt;get_value();\nif (observed_next == nullptr) {\nQueueNode* presumed_tail = this;\ndo {\nif (this-&gt;lock_-&gt;tail_-&gt;compare_exchange_weak(presumed_tail, nullptr)) {\n// Fast-path release - this QueueNode is (still) the tail and we successfully set\n// tail to nullptr.  Return!\n//\nreturn true;\n}\n} while (this == presumed_tail);\n// Fast-path failed, so we know there is a successor to `this`; wait for them to set our\n// `next` pointer.\n//\nthis-&gt;await_next(observed_next);\n}\nreturn false;\n}\n//----- --- -- -  -  -   -\nvoid await_next(QueueNode*&amp; observed_next)\n{\nif (kPollForNext) {\nwhile (observed_next == nullptr) {\nobserved_next = this-&gt;next_-&gt;poll();\n}\n} else {\nconst StatusOr&lt;QueueNode*&gt; new_observed_next = this-&gt;next_-&gt;await_not_equal(nullptr);\nBATT_CHECK(new_observed_next.ok() &amp;&amp; *new_observed_next != nullptr)\n&lt;&lt; BATT_INSPECT(new_observed_next);\nobserved_next = *new_observed_next;\n}\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nLock* const lock_;\nNodeClass const class_;\nCpuCacheLineIsolated&lt;WatchImplT&lt;QueueNode*&gt;&gt; next_;\nCpuCacheLineIsolated&lt;WatchImplT&lt;u32&gt;&gt; state_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nclass Reader : private QueueNode\n{\npublic:\nexplicit Reader(Lock&amp; lock) noexcept : QueueNode{&amp;lock, QueueNode::NodeClass::kReading}\n{\nthis-&gt;lock_for_read_impl();\n}\n~Reader() noexcept\n{\nthis-&gt;unlock_for_read_impl();\n}\nLock* lock() const noexcept\n{\nreturn this-&gt;lock_;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nvoid lock_for_read_impl() noexcept\n{\nu32 observed_state = 0;\nQueueNode* const pred = this-&gt;fast_lock_or_get_predecessor(observed_state);\nif (pred == nullptr) {\nthis-&gt;lock_-&gt;reader_count_-&gt;fetch_add(1);\nthis-&gt;set_unblocked(observed_state, HoldOwnership{});\n} else {\n// If our predecessor is a writer or a blocked reader whose state we were able to update (via\n// CAS) to {successor_class = reader}, then we can count on `pred` to set our state to\n// unblocked, so set pred-&gt;next to us and await that state change.\n//\nu32 presumed_pred_state = Self::kInitialState;\nif (pred-&gt;class_ == QueueNode::NodeClass::kWriting ||\npred-&gt;state_-&gt;compare_exchange(presumed_pred_state,\nmake_state(kBlockedTrue, kSuccessorReader)))  //\n{\npred-&gt;next_-&gt;set_value(this, ReleaseOwnership{});\nthis-&gt;await_unblocked(observed_state);\n} else {\n// `pred` is a non-blocked reader; that means we are also unblocked!\n//\nthis-&gt;lock_-&gt;reader_count_-&gt;fetch_add(1);\npred-&gt;next_-&gt;set_value(this, ReleaseOwnership{});\nthis-&gt;set_unblocked(observed_state, HoldOwnership{});\n}\n}\n//\n// At this point, we are NOT blocked.\nif (successor_class_from_state(observed_state) == kSuccessorReader) {\nQueueNode* observed_next = this-&gt;next_-&gt;get_value();\n//----- --- -- -  -  -   -\nthis-&gt;await_next(observed_next);\n//----- --- -- -  -  -   -\nthis-&gt;lock_-&gt;reader_count_-&gt;fetch_add(1);\nu32 observed_next_state = 0;\nobserved_next-&gt;set_unblocked(observed_next_state, ReleaseOwnership{});\n}\n}\nvoid unlock_for_read_impl() noexcept\n{\nQueueNode* observed_next = nullptr;\nif (!this-&gt;fast_unlock(observed_next)) {\n//\n// At this point, observed_next is NOT nullptr.\nconst u32 observed_state = this-&gt;state_-&gt;get_value();\nif (successor_class_from_state(observed_state) == kSuccessorWriter) {\nthis-&gt;lock_-&gt;next_writer_-&gt;store(observed_next);\n}\n}\n// If this QueueNode is the last reader, then it's our job to wake the next writer in the queue.\n//\nif (this-&gt;lock_-&gt;reader_count_-&gt;fetch_sub(1) == 1) {\nQueueNode* const observed_next_writer = this-&gt;lock_-&gt;next_writer_-&gt;exchange(nullptr);\nif (observed_next_writer != nullptr) {\nu32 observed_next_writer_state = 0;\nobserved_next_writer-&gt;set_unblocked(observed_next_writer_state, ReleaseOwnership{});\n}\n}\n}\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nclass Writer : private QueueNode\n{\npublic:\nexplicit Writer(Lock&amp; lock) noexcept : QueueNode{&amp;lock, QueueNode::NodeClass::kWriting}\n{\nthis-&gt;lock_for_write_impl();\n}\n~Writer() noexcept\n{\nthis-&gt;unlock_for_write_impl();\n}\nLock* lock() const noexcept\n{\nreturn this-&gt;lock_;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nvoid lock_for_write_impl() noexcept\n{\nu32 observed_state = 0;\nQueueNode* const pred = this-&gt;fast_lock_or_get_predecessor(observed_state);\nif (pred == nullptr) {\nthis-&gt;lock_-&gt;next_writer_-&gt;store(this);\nif (this-&gt;lock_-&gt;reader_count_-&gt;load() == 0 &amp;&amp;\nthis-&gt;lock_-&gt;next_writer_-&gt;exchange(nullptr) == this) {\nthis-&gt;set_unblocked(observed_state, HoldOwnership{});\nreturn;\n}\n} else {\n// IMPORTANT: this assumes the bits 0b110 are zero!\n//\nconst u32 prior_pred_state = pred-&gt;state_-&gt;fetch_or(kSuccessorWriter);\nBATT_CHECK_EQ((prior_pred_state &amp; kSuccessorMask), kSuccessorNone);\n// IMPORTANT: updating pred-&gt;next_ must come after modifying pred-&gt;state_!\n//\npred-&gt;next_-&gt;set_value(this, ReleaseOwnership{});\n}\nthis-&gt;await_unblocked(observed_state);\n}\nvoid unlock_for_write_impl() noexcept\n{\nQueueNode* observed_next = nullptr;\nif (!this-&gt;fast_unlock(observed_next)) {\n//\n// At this point, observed_next is NOT nullptr.\nif (observed_next-&gt;class_ == QueueNode::NodeClass::kReading) {\nthis-&gt;lock_-&gt;reader_count_-&gt;fetch_add(1);\n}\n// Set next-&gt;blocked to false to allow the next thread to run.\n//\nu32 observed_next_state = 0;\nobserved_next-&gt;set_unblocked(observed_next_state, ReleaseOwnership{});\n}\n}\n};\ni64 reader_count() const noexcept\n{\nreturn this-&gt;reader_count_-&gt;load();\n}\nprivate:\nCpuCacheLineIsolated&lt;std::atomic&lt;QueueNode*&gt;&gt; tail_{nullptr};\nCpuCacheLineIsolated&lt;std::atomic&lt;i64&gt;&gt; reader_count_{0};\nCpuCacheLineIsolated&lt;std::atomic&lt;QueueNode*&gt;&gt; next_writer_{nullptr};\n};\nusing ReadWriteLock = BasicReadWriteLock&lt;/*WatchImplT=*/WatchAtomic&gt;;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DumpReadWriteLockState&amp; dump)\n{\nout &lt;&lt; std::bitset&lt;3&gt;{dump.state_value} &lt;&lt; \"(\";\nif ((dump.state_value &amp; ReadWriteLock::kBlockedMask) == ReadWriteLock::kBlockedTrue) {\nout &lt;&lt; \"blocked\";\n} else {\nout &lt;&lt; \"unblocked\";\n}\nout &lt;&lt; \",succ=\";\nswitch (dump.state_value &amp; ReadWriteLock::kSuccessorMask) {\ncase ReadWriteLock::kSuccessorNone:\nout &lt;&lt; \"none\";\nbreak;\ncase ReadWriteLock::kSuccessorReader:\nout &lt;&lt; \"reader\";\nbreak;\ncase ReadWriteLock::kSuccessorWriter:\nout &lt;&lt; \"writer\";\nbreak;\ndefault:\nout &lt;&lt; \"INVALID\";\nbreak;\n}\nreturn out &lt;&lt; \")\";\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Forward-declaration.\n//\ntemplate &lt;typename T, typename LockT&gt;\nclass ScopedReadWriteLockImpl;\ntemplate &lt;typename T&gt;\nclass ReadWriteMutex\n{\npublic:\ntemplate &lt;typename, typename&gt;\nfriend class ScopedReadWriteLockImpl;\nusing Self = ReadWriteMutex;\ntemplate &lt;typename&gt;\nstruct ThreadSafeBaseIsNotSupportedByType {\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Self, typename Base = typename Self::ThreadSafeBase&gt;\nstatic Base* thread_safe_base(Self* ptr)\n{\nreturn ptr;\n}\ntemplate &lt;typename Self, typename Base = typename Self::ThreadSafeBase&gt;\nstatic const Base* thread_safe_base(const Self* ptr)\n{\nreturn ptr;\n}\ntemplate &lt;typename Self, typename Base = typename Self::ThreadSafeBase, typename = void&gt;\nstatic Base* thread_safe_base(const std::unique_ptr&lt;Self&gt;* ptr)\n{\nreturn ptr-&gt;get();\n}\nstatic ThreadSafeBaseIsNotSupportedByType&lt;T&gt;* thread_safe_base(...)\n{\nreturn nullptr;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nReadWriteMutex(const ReadWriteMutex&amp;) = delete;\nReadWriteMutex&amp; operator=(const ReadWriteMutex&amp;) = delete;\nReadWriteMutex() = default;\ntemplate &lt;typename... Args, typename = EnableIfNoShadow&lt;Self, Args...&gt;&gt;\nexplicit ReadWriteMutex(Args&amp;&amp;... args) noexcept : value_(BATT_FORWARD(args)...)\n{\n}\ntemplate &lt;typename Action&gt;\ndecltype(auto) with_read_lock(Action&amp;&amp; action);\ntemplate &lt;typename Action&gt;\ndecltype(auto) with_write_lock(Action&amp;&amp; action);\nauto operator-&gt;()\n{\nreturn thread_safe_base(&amp;this-&gt;value_);\n}\ndecltype(auto) no_lock()\n{\nreturn *thread_safe_base(&amp;this-&gt;value_);\n}\ndecltype(auto) no_lock() const\n{\nreturn *thread_safe_base(&amp;this-&gt;value_);\n}\nprivate:\nReadWriteLock lock_;\nT value_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nusing ScopedReadLock = ScopedReadWriteLockImpl&lt;const T, ReadWriteLock::Reader&gt;;\ntemplate &lt;typename T&gt;\nusing ScopedWriteLock = ScopedReadWriteLockImpl&lt;T, ReadWriteLock::Writer&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T, typename LockT&gt;\nclass ScopedReadWriteLockImpl\n{\npublic:\nexplicit ScopedReadWriteLockImpl(ReadWriteMutex&lt;std::remove_const_t&lt;T&gt;&gt;&amp; mutex) noexcept\n: lock_{mutex.lock_}\n, value_{mutex.value_}\n{\n}\nScopedReadWriteLockImpl(const ScopedReadWriteLockImpl&amp;) = delete;\nScopedReadWriteLockImpl&amp; operator=(const ScopedReadWriteLockImpl&amp;) = delete;\n~ScopedReadWriteLockImpl() = default;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nT* get() noexcept\n{\nreturn std::addressof(this-&gt;value_);\n}\nT&amp; value() noexcept\n{\nreturn this-&gt;value_;\n}\nT* operator-&gt;() noexcept\n{\nreturn this-&gt;get();\n}\nT&amp; operator*() noexcept\n{\nreturn this-&gt;value();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nLockT lock_;\nT&amp; value_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ntemplate &lt;typename Action&gt;\ninline decltype(auto) ReadWriteMutex&lt;T&gt;::with_read_lock(Action&amp;&amp; action)\n{\nScopedReadLock&lt;T&gt; lock{*this};\nreturn BATT_FORWARD(action)(*lock);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ntemplate &lt;typename Action&gt;\ninline decltype(auto) ReadWriteMutex&lt;T&gt;::with_write_lock(Action&amp;&amp; action)\n{\nScopedWriteLock&lt;T&gt; lock{*this};\nreturn BATT_FORWARD(action)(*lock);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, ReadWriteLockQueueNodeClass t)\n{\nusing NodeClass = ReadWriteLockQueueNodeClass;\nswitch (t) {\ncase NodeClass::kReading:\nreturn out &lt;&lt; \"Reading\";\ncase NodeClass::kWriting:\nreturn out &lt;&lt; \"Writing\";\ndefault:\nbreak;\n}\nreturn out &lt;&lt; \"(invalid:\" &lt;&lt; (int)t &lt;&lt; \")\";\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_READ_WRITE_LOCK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/reduce_8hpp/","title":"batteries/seq/reduce.hpp","text":""},{"location":"_autogen/Files/reduce_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/reduce_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::ReduceBinder"},{"location":"_autogen/Files/reduce_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_REDUCE_HPP"},{"location":"_autogen/Files/reduce_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/reduce_8hpp/#define-batteries_seq_reduce_hpp","title":"define BATTERIES_SEQ_REDUCE_HPP","text":"<pre><code>#define BATTERIES_SEQ_REDUCE_HPP()\n</code></pre>"},{"location":"_autogen/Files/reduce_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_REDUCE_HPP\n#define BATTERIES_SEQ_REDUCE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// reduce\n//\ntemplate &lt;typename State, typename ReduceFn&gt;\nstruct ReduceBinder {\nState state;\nReduceFn reduce_fn;\n};\ntemplate &lt;typename State, typename ReduceFn&gt;\nReduceBinder&lt;State, ReduceFn&gt; reduce(State&amp;&amp; state, ReduceFn&amp;&amp; reduce_fn)\n{\nreturn {BATT_FORWARD(state), BATT_FORWARD(reduce_fn)};\n}\ntemplate &lt;typename Seq, typename State, typename ReduceFn&gt;\n[[nodiscard]] State operator|(Seq&amp;&amp; seq, ReduceBinder&lt;State, ReduceFn&gt; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::reduce) Sequences may not be captured implicitly by reference.\");\nBATT_FORWARD(seq) | for_each([&amp;binder](auto&amp;&amp; item) {\nbinder.state = binder.reduce_fn(binder.state, BATT_FORWARD(item));\n});\nreturn binder.state;\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_REDUCE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/ref_8hpp/","title":"batteries/ref.hpp","text":""},{"location":"_autogen/Files/ref_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/ref_8hpp/#classes","title":"Classes","text":"Name class batt::Ref"},{"location":"_autogen/Files/ref_8hpp/#defines","title":"Defines","text":"Name BATTERIES_REF_HPP BATT_REF_DELEGATE_MEMFUN(name, qualifiers) BATT_UNWRAP_REF_BATT_REF(qualifiers)"},{"location":"_autogen/Files/ref_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/ref_8hpp/#define-batteries_ref_hpp","title":"define BATTERIES_REF_HPP","text":"<pre><code>#define BATTERIES_REF_HPP()\n</code></pre>"},{"location":"_autogen/Files/ref_8hpp/#define-batt_ref_delegate_memfun","title":"define BATT_REF_DELEGATE_MEMFUN","text":"<pre><code>#define BATT_REF_DELEGATE_MEMFUN(name, qualifiers)\n</code></pre>"},{"location":"_autogen/Files/ref_8hpp/#define-batt_unwrap_ref_batt_ref","title":"define BATT_UNWRAP_REF_BATT_REF","text":"<pre><code>#define BATT_UNWRAP_REF_BATT_REF(qualifiers)\n</code></pre>"},{"location":"_autogen/Files/ref_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_REF_HPP\n#define BATTERIES_REF_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq.hpp&gt;\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;ostream&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass Ref\n{\npublic:\nusing Item = typename std::conditional_t&lt;batt::HasSeqRequirements&lt;T&gt;{},  //\n/*then*/ batt::SeqItem_Impl&lt;T&gt;,\n/*else*/ batt::StaticType&lt;void&gt;&gt;::type;\ntemplate &lt;typename U, typename = std::enable_if_t&lt;std::is_constructible_v&lt;T*, U*&gt;&gt;&gt;\n/*implicit*/ Ref(U&amp; obj_ref) noexcept : ptr_{&amp;obj_ref}\n{\n}\nRef() noexcept : ptr_{nullptr}\n{\n}\ntemplate &lt;typename U, typename = std::enable_if_t&lt;std::is_constructible_v&lt;T*, U*&gt;&gt;&gt;\nRef(const Ref&lt;U&gt;&amp; that) noexcept : ptr_{that.ptr_}\n{\n}\ntemplate &lt;typename U, typename = std::enable_if_t&lt;std::is_constructible_v&lt;T*, U*&gt;&gt;&gt;\nRef&amp; operator=(const Ref&lt;U&gt;&amp; that) noexcept\n{\nthis-&gt;ptr_ = that.ptr_;\nreturn *this;\n}\nbool is_valid() const\n{\nreturn this-&gt;ptr_ != nullptr;\n}\nT&amp; get() const\n{\nreturn *this-&gt;ptr_;\n}\nT* pointer() const\n{\nreturn this-&gt;ptr_;\n}\n/*implicit*/ operator T&amp;() const\n{\nreturn *this-&gt;ptr_;\n}\ntemplate &lt;typename... Args,\ntypename = std::enable_if_t&lt;!std::is_same_v&lt;std::tuple&lt;std::ostream&amp;&gt;, std::tuple&lt;Args...&gt;&gt;&gt;&gt;\ndecltype(auto) operator()(Args&amp;&amp;... args) const\nnoexcept(noexcept((*std::declval&lt;const Ref*&gt;()-&gt;ptr_)(BATT_FORWARD(args)...)))\n{\nreturn (*this-&gt;ptr_)(BATT_FORWARD(args)...);\n}\n#define BATT_REF_DELEGATE_MEMFUN(name, qualifiers)                                                           \\\n    template &lt;typename... Args&gt;                                                                              \\\n    decltype(auto) name(Args&amp;&amp;... args) qualifiers                                                           \\\n    {                                                                                                        \\\n        return this-&gt;ptr_-&gt;name(BATT_FORWARD(args)...);                                                      \\\n    }\nBATT_REF_DELEGATE_MEMFUN(poll, const)\nBATT_REF_DELEGATE_MEMFUN(poll, )\nBATT_REF_DELEGATE_MEMFUN(peek, const)\nBATT_REF_DELEGATE_MEMFUN(peek, )\nBATT_REF_DELEGATE_MEMFUN(next, const)\nBATT_REF_DELEGATE_MEMFUN(next, )\nBATT_REF_DELEGATE_MEMFUN(push_frame, const)\nBATT_REF_DELEGATE_MEMFUN(await_frame_consumed, const)\nBATT_REF_DELEGATE_MEMFUN(Update, const)\nBATT_REF_DELEGATE_MEMFUN(ok, const)\nBATT_REF_DELEGATE_MEMFUN(recycle_pages, const)\nBATT_REF_DELEGATE_MEMFUN(await_flush, const)\n#undef BATT_REF_DELEGATE_MEMFUN\nprivate:\nT* ptr_;\n};\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Ref&lt;T&gt;&amp; t)\n{\nreturn out &lt;&lt; t.get();\n}\ntemplate &lt;typename T&gt;\nRef&lt;T&gt; as_ref(T&amp; obj_ref)\n{\nreturn Ref&lt;T&gt;{obj_ref};\n}\ntemplate &lt;typename T&gt;\nRef&lt;const T&gt; as_cref(const T&amp; obj_ref)\n{\nreturn Ref&lt;const T&gt;{obj_ref};\n}\ntemplate &lt;typename T&gt;\nRef&lt;T&gt; into_ref(T* ptr)\n{\nreturn as_ref(*ptr);\n}\ntemplate &lt;typename T&gt;\nRef&lt;const T&gt; into_cref(const T* ptr)\n{\nreturn as_ref(*ptr);\n}\n#define BATT_UNWRAP_REF_BATT_REF(qualifiers)                                                                 \\\n    template &lt;typename T&gt;                                                                                    \\\n    decltype(auto) unwrap_ref(Ref&lt;T&gt; qualifiers wrapper)                                                     \\\n    {                                                                                                        \\\n        return BATT_FORWARD(wrapper).get();                                                                  \\\n    }\nBATT_UNWRAP_REF_BATT_REF(&amp;)\nBATT_UNWRAP_REF_BATT_REF(const&amp;)\nBATT_UNWRAP_REF_BATT_REF(&amp;&amp;)\nBATT_UNWRAP_REF_BATT_REF(const&amp;&amp;)\n#undef BATT_UNWRAP_REF_BATT_REF\n}  // namespace batt\n#endif  // BATTERIES_REF_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/require_8hpp/","title":"batteries/require.hpp","text":""},{"location":"_autogen/Files/require_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/require_8hpp/#defines","title":"Defines","text":"Name BATTERIES_REQUIRE_HPP BATT_REQUIRE_RELATION(left, op, right) BATT_REQUIRE_EQ(left, right) BATT_REQUIRE_NE(left, right) BATT_REQUIRE_LT(left, right) BATT_REQUIRE_GT(left, right) BATT_REQUIRE_LE(left, right) BATT_REQUIRE_GE(left, right) BATT_REQUIRE_TRUE(expr) BATT_REQUIRE_FALSE(expr)"},{"location":"_autogen/Files/require_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/require_8hpp/#define-batteries_require_hpp","title":"define BATTERIES_REQUIRE_HPP","text":"<pre><code>#define BATTERIES_REQUIRE_HPP()\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_relation","title":"define BATT_REQUIRE_RELATION","text":"<pre><code>#define BATT_REQUIRE_RELATION(left, op, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_eq","title":"define BATT_REQUIRE_EQ","text":"<pre><code>#define BATT_REQUIRE_EQ(left, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_ne","title":"define BATT_REQUIRE_NE","text":"<pre><code>#define BATT_REQUIRE_NE(left, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_lt","title":"define BATT_REQUIRE_LT","text":"<pre><code>#define BATT_REQUIRE_LT(left, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_gt","title":"define BATT_REQUIRE_GT","text":"<pre><code>#define BATT_REQUIRE_GT(left, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_le","title":"define BATT_REQUIRE_LE","text":"<pre><code>#define BATT_REQUIRE_LE(left, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_ge","title":"define BATT_REQUIRE_GE","text":"<pre><code>#define BATT_REQUIRE_GE(left, right)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_true","title":"define BATT_REQUIRE_TRUE","text":"<pre><code>#define BATT_REQUIRE_TRUE(expr)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#define-batt_require_false","title":"define BATT_REQUIRE_FALSE","text":"<pre><code>#define BATT_REQUIRE_FALSE(expr)\n</code></pre>"},{"location":"_autogen/Files/require_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_REQUIRE_HPP\n#define BATTERIES_REQUIRE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;boost/preprocessor/stringize.hpp&gt;\n#include &lt;tuple&gt;\nnamespace batt {\n#define BATT_REQUIRE_RELATION(left, op, right)                                                               \\\n    for (auto values = std::make_tuple((left), (right));                                                     \\\n         !BATT_HINT_TRUE(std::get&lt;0&gt;(values) op std::get&lt;1&gt;(values));)                                       \\\n    return ::batt::detail::NotOkStatusWrapper{sizeof(::batt::detail::NotOkStatusWrapper),                    \\\n                                              __FILE__,                                                      \\\n                                              __LINE__,                                                      \\\n                                              {::batt::StatusCode::kFailedPrecondition},                     \\\n                                              BATT_VLOG_IS_ON(1)}                                            \\\n           &lt;&lt; \"\\n\\n  Expected:\\n\\n    \"                                                                      \\\n           &lt;&lt; BOOST_PP_STRINGIZE(left) &lt;&lt; \" \"                                                                               \\\n                        &lt;&lt; BOOST_PP_STRINGIZE(op) &lt;&lt; \" \"                                                                    \\\n                                   &lt;&lt; BOOST_PP_STRINGIZE(right)                                              \\\n                                          &lt;&lt; \"\\n\\n  Actual:\\n\\n    \"                                         \\\n                                          &lt;&lt; BOOST_PP_STRINGIZE(left)                                        \\\n                                                 &lt;&lt; \" == \" &lt;&lt; ::batt::make_printable(std::get&lt;0&gt;(values))    \\\n                                                 &lt;&lt; \"\\n\\n    \"                                               \\\n                                                 &lt;&lt; BOOST_PP_STRINGIZE(right) &lt;&lt; \" == \"                      \\\n                                                                              &lt;&lt; ::batt::make_printable(     \\\n                                                                                     std::get&lt;1&gt;(values))    \\\n                                                                              &lt;&lt; \"\\n\\n\"\n#define BATT_REQUIRE_EQ(left, right) BATT_REQUIRE_RELATION(left, ==, right)\n#define BATT_REQUIRE_NE(left, right) BATT_REQUIRE_RELATION(left, !=, right)\n#define BATT_REQUIRE_LT(left, right) BATT_REQUIRE_RELATION(left, &lt;, right)\n#define BATT_REQUIRE_GT(left, right) BATT_REQUIRE_RELATION(left, &gt;, right)\n#define BATT_REQUIRE_LE(left, right) BATT_REQUIRE_RELATION(left, &lt;=, right)\n#define BATT_REQUIRE_GE(left, right) BATT_REQUIRE_RELATION(left, &gt;=, right)\n#define BATT_REQUIRE_TRUE(expr) BATT_REQUIRE_RELATION(bool{(expr)}, ==, true)\n#define BATT_REQUIRE_FALSE(expr) BATT_REQUIRE_RELATION(bool{(expr)}, ==, false)\n}  // namespace batt\n#endif  // BATTERIES_REQUIRE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/requirements_8hpp/","title":"batteries/seq/requirements.hpp","text":""},{"location":"_autogen/Files/requirements_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/requirements_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_REQUIREMENTS_HPP"},{"location":"_autogen/Files/requirements_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/requirements_8hpp/#define-batteries_seq_requirements_hpp","title":"define BATTERIES_SEQ_REQUIREMENTS_HPP","text":"<pre><code>#define BATTERIES_SEQ_REQUIREMENTS_HPP()\n</code></pre>"},{"location":"_autogen/Files/requirements_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_REQUIREMENTS_HPP\n#define BATTERIES_SEQ_REQUIREMENTS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\nnamespace batt {\nnamespace detail {\ntemplate &lt;typename T&gt;\ninline std::false_type has_seq_requirements_impl(...)\n{\nreturn {};\n}\ntemplate &lt;typename T, typename ItemT = typename std::decay_t&lt;T&gt;::Item,\ntypename = std::enable_if_t&lt;                                                       //\nstd::is_convertible_v&lt;decltype(std::declval&lt;T&gt;().next()), Optional&lt;ItemT&gt;&gt; &amp;&amp;  //\nstd::is_convertible_v&lt;decltype(std::declval&lt;T&gt;().peek()), Optional&lt;ItemT&gt;&gt;     //\n&gt;&gt;\ninline std::true_type has_seq_requirements_impl(std::decay_t&lt;T&gt;*)\n{\nreturn {};\n}\n}  // namespace detail\ntemplate &lt;typename T&gt;\nusing HasSeqRequirements = decltype(detail::has_seq_requirements_impl&lt;T&gt;(nullptr));\ntemplate &lt;typename T&gt;\ninline constexpr bool has_seq_requirements(StaticType&lt;T&gt; = {})\n{\nreturn HasSeqRequirements&lt;T&gt;{};\n}\ntemplate &lt;typename T&gt;\nusing EnableIfSeq = std::enable_if_t&lt;has_seq_requirements&lt;T&gt;()&gt;;\n}  // namespace batt\n#endif  // BATTERIES_SEQ_REQUIREMENTS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/reverse_8hpp/","title":"batteries/seq/reverse.hpp","text":""},{"location":"_autogen/Files/reverse_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/reverse_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::Reverse"},{"location":"_autogen/Files/reverse_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_REVERSE_HPP"},{"location":"_autogen/Files/reverse_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/reverse_8hpp/#define-batteries_seq_reverse_hpp","title":"define BATTERIES_SEQ_REVERSE_HPP","text":"<pre><code>#define BATTERIES_SEQ_REVERSE_HPP()\n</code></pre>"},{"location":"_autogen/Files/reverse_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_REVERSE_HPP\n#define BATTERIES_SEQ_REVERSE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\ntemplate &lt;typename Fn&gt;\nstruct Reverse : private Fn {\nusing Fn::Fn;\ntemplate &lt;typename Left, typename Right&gt;\ndecltype(auto) operator()(Left&amp;&amp; left, Right&amp;&amp; right) const\n{\nreturn Fn::operator()(BATT_FORWARD(right), BATT_FORWARD(left));\n}\n};\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_REVERSE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/rolling_8hpp/","title":"batteries/seq/rolling.hpp","text":""},{"location":"_autogen/Files/rolling_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/rolling_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::RollingBinder"},{"location":"_autogen/Files/rolling_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ROLLING_HPP"},{"location":"_autogen/Files/rolling_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/rolling_8hpp/#define-batteries_seq_rolling_hpp","title":"define BATTERIES_SEQ_ROLLING_HPP","text":"<pre><code>#define BATTERIES_SEQ_ROLLING_HPP()\n</code></pre>"},{"location":"_autogen/Files/rolling_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ROLLING_HPP\n#define BATTERIES_SEQ_ROLLING_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/map_fold.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// rolling(initial, binary_fn) -\n//\n//  a1, a2, a3, a4, ... =&gt; b1 = fn(initial, a1), b2 = fn(b1, a2), b3 = fn(b2, a3), etc.\n//\ntemplate &lt;typename T, typename BinaryFn&gt;\nstruct RollingBinder {\nBinaryFn binary_fn;\nT initial;\n};\ntemplate &lt;typename T, typename BinaryFn&gt;\ninline RollingBinder&lt;T, BinaryFn&gt; rolling(BinaryFn&amp;&amp; binary_fn, T&amp;&amp; initial = T{})\n{\nreturn {BATT_FORWARD(binary_fn), BATT_FORWARD(initial)};\n}\ntemplate &lt;typename Seq, typename T, typename BinaryFn&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, RollingBinder&lt;T, BinaryFn&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;, \"Sequences may not be captured by reference.\");\nreturn BATT_FORWARD(seq) | map_fold(BATT_FORWARD(binder.initial),\n[binary_fn = BATT_FORWARD(binder.binary_fn)](auto a, auto b) {\nauto c = binary_fn(a, b);\nreturn std::make_tuple(c, c);\n});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ROLLING_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/rolling__sum_8hpp/","title":"batteries/seq/rolling_sum.hpp","text":""},{"location":"_autogen/Files/rolling__sum_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/rolling__sum_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::RollingSumBinder"},{"location":"_autogen/Files/rolling__sum_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ROLLING_SUM_HPP"},{"location":"_autogen/Files/rolling__sum_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/rolling__sum_8hpp/#define-batteries_seq_rolling_sum_hpp","title":"define BATTERIES_SEQ_ROLLING_SUM_HPP","text":"<pre><code>#define BATTERIES_SEQ_ROLLING_SUM_HPP()\n</code></pre>"},{"location":"_autogen/Files/rolling__sum_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ROLLING_SUM_HPP\n#define BATTERIES_SEQ_ROLLING_SUM_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/addition.hpp&gt;\n#include &lt;batteries/seq/rolling.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// rolling_sum()\n//\nstruct RollingSumBinder {\n};\ninline RollingSumBinder rolling_sum()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, RollingSumBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;, \"Sequences may not be captured by reference.\");\nusing T = std::decay_t&lt;SeqItem&lt;Seq&gt;&gt;;\nreturn BATT_FORWARD(seq) | rolling&lt;T&gt;(Addition{});\n}\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n// DEPRECATED - for compatibility only; use rolling_sum().\n//\ninline auto running_total()\n{\nreturn rolling_sum();\n}\n//\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ROLLING_SUM_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/running__total_8cpp/","title":"batteries/algo/running_total.cpp","text":""},{"location":"_autogen/Files/running__total_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/algo/running_total.hpp&gt;\n//\n#include &lt;batteries/algo/running_total_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/running__total_8hpp/","title":"batteries/algo/running_total.hpp","text":""},{"location":"_autogen/Files/running__total_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/running__total_8hpp/#classes","title":"Classes","text":"Name class batt::BasicRunningTotal class batt::BasicRunningTotal::Iterator"},{"location":"_autogen/Files/running__total_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_RUNNING_TOTAL_HPP"},{"location":"_autogen/Files/running__total_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/running__total_8hpp/#define-batteries_algo_running_total_hpp","title":"define BATTERIES_ALGO_RUNNING_TOTAL_HPP","text":"<pre><code>#define BATTERIES_ALGO_RUNNING_TOTAL_HPP()\n</code></pre>"},{"location":"_autogen/Files/running__total_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_RUNNING_TOTAL_HPP\n#define BATTERIES_ALGO_RUNNING_TOTAL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/interval.hpp&gt;\n#include &lt;batteries/slice.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\n#include &lt;boost/iterator/iterator_facade.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;iterator&gt;\n#include &lt;memory&gt;\n#include &lt;ostream&gt;\nnamespace batt {\nBATT_STRONG_TYPEDEF(usize, PartsCount);\nBATT_STRONG_TYPEDEF(usize, PartSize);\ntemplate &lt;typename T&gt;\nclass BasicRunningTotal;\nusing RunningTotal = BasicRunningTotal&lt;usize&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// A parallel-friendly cummulative running total of `usize` values.\n//\n// This collection is structured as a series of adjacent 'parts' (or shards/partitions) plus a 'summary' that\n// records the running totals of the parts.  For example, if the input array (on which we wish to compute the\n// running total) is:\n//\n// `{2, 1, 3, 1, 1, 2, 1, 2, 3, 3, 1, 2}`\n//\n// We might divide this into three (logical) parts whose running totals can be computed independently in\n// parallel:\n//\n// input parts: `{{2, 1, 3, 1}, {1, 2, 1, 2}, {3, 3, 1, 2}}`\n// part totals: `{{2, 3, 6, 7}, {1, 3, 4, 6}, {3, 6, 7, 9}}`\n//\n// And then the summary is computed as the running total of the individual part totals plus leading zero:\n//\n// summary: `{0, 7, 13, 22}`\n//\n// So the overall set of values stored internally by `RunningTotal` for this input would be:\n//\n// &lt;part-0&gt; + &lt;part-1&gt; + &lt;part-2&gt; + &lt;summary&gt; =&gt; `{2, 3, 6, 7, 1, 3, 4, 6, 3, 6, 7, 9, 0, 7, 13, 22}`\n//\n// This allows a fast O(1) calculation of the overall running total at any point; just add the part-local\n// total to the summary for that part.\n//\ntemplate &lt;typename T&gt;\nclass BasicRunningTotal\n{\npublic:\nclass Iterator;\nusing iterator = Iterator;\nusing const_iterator = Iterator;\nusing value_type = T;\nusing slice_type = boost::iterator_range&lt;Iterator&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nBasicRunningTotal() = default;\nBasicRunningTotal(BasicRunningTotal&amp;&amp;) = default;\nexplicit BasicRunningTotal(PartsCount count, PartSize size);\n~BasicRunningTotal() = default;\nBasicRunningTotal&amp; operator=(BasicRunningTotal&amp;&amp;) = default;\nPartsCount parts_count() const\n{\nreturn PartsCount{this-&gt;parts_count_};\n}\nPartSize part_size() const\n{\nreturn PartSize{this-&gt;part_size_};\n}\nusize size() const\n{\nreturn this-&gt;size_;\n}\nbool empty() const\n{\nreturn this-&gt;size() == 0;\n}\nconst T&amp; front() const\n{\nBATT_ASSERT(!this-&gt;empty());\nreturn this-&gt;values_[0];\n}\nT back() const\n{\nBATT_ASSERT(!this-&gt;empty());\nreturn operator[](this-&gt;size() - 1);\n}\niterator begin() const;\niterator end() const;\nslice_type slice(usize begin_index, usize end_index) const;\nslice_type slice(Interval&lt;usize&gt; interval) const;\nvoid reset(PartsCount count, PartSize size);\nvoid set_size(usize new_size);\nSlice&lt;const T&gt; const_part(usize i) const;\nSlice&lt;T&gt; mutable_part(usize i);\nSlice&lt;const T&gt; const_summary() const;\nSlice&lt;T&gt; mutable_summary();\nT operator[](isize i) const;\nSlice&lt;const T&gt; raw_values() const;\nstd::function&lt;void(std::ostream&amp;)&gt; dump() const;\n// Recompute the summary, which is a running total of the parts.  Must be called after parts are\n// updated.\n//\nvoid update_summary();\nprivate:\nSlice&lt;const T&gt; const_part_impl(usize i) const;\nSlice&lt;const T&gt; raw_slice(usize offset, usize size) const;\nSlice&lt;T&gt; raw_slice(usize offset, usize size);\nusize raw_size() const;\nusize part_segment_offset(usize part_i) const;\nusize part_segment_size() const;\nusize summary_offset() const;\nusize summary_size() const;\nusize offset_of_part(usize part_i) const;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstd::unique_ptr&lt;T[]&gt; values_{new T[1]{make_default&lt;T&gt;()}};\nPartsCount parts_count_{0};\nPartSize part_size_{1};\nusize size_{1};\n};\n// #=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\ntemplate &lt;typename T&gt;\nclass BasicRunningTotal&lt;T&gt;::Iterator\n: public boost::iterator_facade&lt;        //\nIterator,                         // &lt;- Derived\nT,                                // &lt;- Value\nstd::random_access_iterator_tag,  // &lt;- CategoryOrTraversal\nT,                                // &lt;- Reference\nisize                             // &lt;- Difference\n&gt;\n{\npublic:\nusing Self = Iterator;\nusing iterator_category = std::random_access_iterator_tag;\nusing value_type = usize;\nusing reference = value_type;\nexplicit Iterator(const BasicRunningTotal&lt;T&gt;* container, usize position) noexcept\n: container_{container}\n, position_{static_cast&lt;isize&gt;(position)}\n{\nBATT_ASSERT_GE(this-&gt;position_, 0);\n}\nreference dereference() const\n{\nreturn (*this-&gt;container_)[this-&gt;position_];\n}\nbool equal(const Self&amp; other) const\n{\nreturn this-&gt;container_ == other.container_ &amp;&amp; this-&gt;position_ == other.position_;\n}\nvoid increment()\n{\nBATT_ASSERT_LT(static_cast&lt;usize&gt;(this-&gt;position_), this-&gt;container_-&gt;size());\n++this-&gt;position_;\n}\nvoid decrement()\n{\nBATT_ASSERT_GT(this-&gt;position_, 0);\n--this-&gt;position_;\n}\nvoid advance(isize delta)\n{\nthis-&gt;position_ += delta;\nBATT_ASSERT_IN_RANGE(0, this-&gt;position_, static_cast&lt;isize&gt;(this-&gt;container_-&gt;size() + 1));\n}\nisize distance_to(const Self&amp; other) const\n{\nreturn other.position_ - this-&gt;position_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nconst BasicRunningTotal&lt;T&gt;* container() const\n{\nreturn this-&gt;container_;\n}\nisize position() const\n{\nreturn this-&gt;position_;\n}\nprivate:\nconst BasicRunningTotal&lt;T&gt;* container_;\nisize position_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n}  // namespace batt\n#include &lt;batteries/algo/running_total.ipp&gt;\n#endif  // BATTERIES_ALGO_RUNNING_TOTAL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#if BATT_HEADER_ONLY\n#include &lt;batteries/algo/running_total_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/running__total__impl_8hpp/","title":"batteries/algo/running_total_impl.hpp","text":""},{"location":"_autogen/Files/running__total__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/running__total__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ALGO_RUNNING_TOTAL_IMPL_HPP"},{"location":"_autogen/Files/running__total__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/running__total__impl_8hpp/#define-batteries_algo_running_total_impl_hpp","title":"define BATTERIES_ALGO_RUNNING_TOTAL_IMPL_HPP","text":"<pre><code>#define BATTERIES_ALGO_RUNNING_TOTAL_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/running__total__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ALGO_RUNNING_TOTAL_IMPL_HPP\n#define BATTERIES_ALGO_RUNNING_TOTAL_IMPL_HPP\nnamespace batt {\n}  //namespace batt\n#endif  // BATTERIES_ALGO_RUNNING_TOTAL_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/runtime_8hpp/","title":"batteries/async/runtime.hpp","text":""},{"location":"_autogen/Files/runtime_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/runtime_8hpp/#classes","title":"Classes","text":"Name class batt::Runtime struct batt::Runtime::WeakNotifySlot class batt::Runtime::DefaultScheduler"},{"location":"_autogen/Files/runtime_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_RUNTIME_HPP"},{"location":"_autogen/Files/runtime_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/runtime_8hpp/#define-batteries_async_runtime_hpp","title":"define BATTERIES_ASYNC_RUNTIME_HPP","text":"<pre><code>#define BATTERIES_ASYNC_RUNTIME_HPP()\n</code></pre>"},{"location":"_autogen/Files/runtime_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_RUNTIME_HPP\n#define BATTERIES_ASYNC_RUNTIME_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/dump_tasks.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/task_scheduler.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/env.hpp&gt;\n#include &lt;batteries/hash.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;boost/asio/executor_work_guard.hpp&gt;\n#include &lt;boost/asio/io_context.hpp&gt;\n#include &lt;boost/asio/signal_set.hpp&gt;\n#include &lt;boost/exception/diagnostic_information.hpp&gt;\n#include &lt;boost/exception_ptr.hpp&gt;\n#include &lt;chrono&gt;\n#include &lt;cstddef&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n#if defined(BATT_PLATFORM_IS_LINUX) || defined(BATT_PLATFORM_IS_APPLE)\n#include &lt;sched.h&gt;\n#include &lt;signal.h&gt;\n#endif\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nclass Runtime\n{\npublic:\nclass DefaultScheduler;\nstruct WeakNotifySlot {\nWatch&lt;u64&gt; counter;\nMutex&lt;NoneType&gt; mutex;\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic Runtime&amp; instance()\n{\nreturn *Runtime::instance_ptr();\n}\nstatic void reset()\n{\nBATT_CHECK(Runtime::instance().is_halted());\ndelete Runtime::instance_ptr();\nRuntime::instance_ptr() = new Runtime;\nBATT_CHECK(!Runtime::instance().is_halted());\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit Runtime() noexcept;\nTaskScheduler&amp; default_scheduler()\n{\nreturn *this-&gt;default_scheduler_;\n}\n// DEPRECATED; use TaskScheduler explicitly instead for DI testing.\n//\nboost::asio::any_io_executor schedule_task()\n{\nreturn this-&gt;scheduler_.load()-&gt;schedule_task();\n}\nTaskScheduler* exchange_task_scheduler(TaskScheduler* new_scheduler)\n{\nreturn this-&gt;scheduler_.exchange(new_scheduler);\n}\nvoid halt()\n{\nconst bool halted_prior = this-&gt;halted_.exchange(true);\nif (halted_prior) {\nreturn;\n}\ndetail::SigInfoHandler::instance().halt();\nthis-&gt;default_scheduler_-&gt;halt();\nthis-&gt;scheduler_.load()-&gt;halt();\n}\nbool is_halted() const\n{\nreturn this-&gt;halted_.load();\n}\nvoid join()\n{\ndetail::SigInfoHandler::instance().join();\nthis-&gt;default_scheduler_-&gt;join();\nthis-&gt;scheduler_.load()-&gt;join();\n}\ntemplate &lt;typename... Ts&gt;\nusize get_weak_notify_slot_index(const Ts&amp;... objs) const\n{\nreturn batt::hash(objs...) % this-&gt;n_weak_notify_slots_;\n}\ntemplate &lt;typename... Ts&gt;\nWeakNotifySlot&amp; get_weak_notify_slot(const Ts&amp;... objs)\n{\nreturn this-&gt;weak_notify_slot_[this-&gt;get_weak_notify_slot_index(objs...)];\n}\ntemplate &lt;typename... Ts&gt;\nvoid notify(const Ts&amp;... objs)\n{\nWeakNotifySlot&amp; slot = this-&gt;get_weak_notify_slot(objs...);\nslot.counter.fetch_add(1);\n}\n#if !BATT_MUTEX_NO_LEGACY_API\ntemplate &lt;typename... Ts&gt;\nMutex&lt;NoneType&gt;::Lock lock(const Ts&amp;... objs)\n{\nreturn this-&gt;get_weak_notify_slot(objs...).mutex.lock();\n}\n#endif  // BATT_MUTEX_NO_LEGACY_API\ntemplate &lt;typename CheckCondition, typename... Ts&gt;\nauto await_condition(const CheckCondition&amp; check_condition, const Ts&amp;... objs)\n{\nWeakNotifySlot&amp; slot = this-&gt;get_weak_notify_slot(objs...);\nu64 observed_ts = slot.counter.get_value();\nOptional&lt;ScopedLock&lt;NoneType&gt;&gt; locked{slot.mutex};\nfor (;;) {\nauto last_result = check_condition(objs...);\nif (last_result) {\nreturn last_result;\n}\nlocked = None;\nStatusOr&lt;u64&gt; updated_ts = slot.counter.await_not_equal(observed_ts);\nif (!updated_ts.ok()) {\nreturn last_result;\n}\nobserved_ts = *updated_ts;\nlocked.emplace(slot.mutex);\n}\n}\nprivate:\nstatic Runtime*&amp; instance_ptr()\n{\n// Intentionally leaked to avoid any potential static deinit order issues.\n//\nstatic Runtime* instance_ = new Runtime;\nreturn instance_;\n}\n~Runtime() noexcept\n{\nthis-&gt;halt();\n}\nusing WorkGuard =\nbatt::Optional&lt;boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;&gt;;\nstd::atomic&lt;bool&gt; halted_{false};\nstd::unique_ptr&lt;TaskScheduler&gt; default_scheduler_;\nstd::atomic&lt;TaskScheduler*&gt; scheduler_;\nconst usize n_weak_notify_slots_ = std::thread::hardware_concurrency() * 1024;\nconst std::unique_ptr&lt;WeakNotifySlot[]&gt; weak_notify_slot_{[this] {\nauto* slots = new WeakNotifySlot[this-&gt;n_weak_notify_slots_];\nfor (usize i = 0; i &lt; this-&gt;n_weak_notify_slots_; ++i) {\nslots[i].counter.set_value(0);\n}\nreturn slots;\n}()};\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nclass Runtime::DefaultScheduler : public TaskScheduler\n{\npublic:\nexplicit DefaultScheduler() noexcept\n{\nBATT_VLOG(1) &lt;&lt; \"cpu_count == \" &lt;&lt; cpu_count_;\nconst auto push_new_io = [&amp;] {\nthis-&gt;io_.emplace_back(std::make_unique&lt;boost::asio::io_context&gt;());\nthis-&gt;work_guards_.emplace_back(std::make_unique&lt;WorkGuard&gt;(io_.back()-&gt;get_executor()));\n};\nif (this-&gt;shared_io_) {\npush_new_io();\n}\nstd::atomic&lt;usize&gt; init_countdown{this-&gt;cpu_count_};\nfor (usize i = 0; i &lt; cpu_count_; ++i) {\nif (!this-&gt;shared_io_) {\npush_new_io();\n}\nthis-&gt;thread_pool_.emplace_back([i, this, io = io_.back().get(), &amp;init_countdown] {\nif (i &lt; this-&gt;cpu_count_) {\nusize cpu_n = i % this-&gt;cpu_count_;\nbatt::this_thread_id() = cpu_n + 1;\nBATT_VLOG(1) &lt;&lt; \"thread \" &lt;&lt; batt::this_thread_id() &lt;&lt; \" started; cpu=\" &lt;&lt; (cpu_n + 1);\nif (this-&gt;pin_cpu_) {\n#ifdef __linux__\nBATT_CHECK_OK(pin_thread_to_cpu(cpu_n)) &lt;&lt; \"cpu=\" &lt;&lt; cpu_n;\n#endif  // __linux__\nBATT_VLOG(1) &lt;&lt; \"thread \" &lt;&lt; i &lt;&lt; \" set affinity mask; running io_context\";\n}\n}\ninit_countdown.fetch_sub(1);\nio-&gt;run();\n});\n}\nwhile (init_countdown.load() != 0) {\nstd::this_thread::yield();\n}\n}\n~DefaultScheduler() noexcept\n{\nthis-&gt;halt();\nthis-&gt;join();\n}\nboost::asio::any_io_executor schedule_task() override\n{\nif (BATT_HINT_FALSE(this-&gt;deprecated_)) {\nBATT_LOG_WARNING() &lt;&lt; \"DEPRECATED DefaultScheduler::schedule_task() from: \"\n&lt;&lt; boost::stacktrace::stacktrace{};\n}\nif (BATT_HINT_FALSE(this-&gt;disabled_)) {\nBATT_PANIC() &lt;&lt; \"DISABLED: DefaultScheduler::schedule_task() -- Please Remove!\";\n}\nconst usize i = this-&gt;round_robin_.fetch_add(1);\nBATT_VLOG(1) &lt;&lt; \"scheduling task on default thread \" &lt;&lt; (i + 1);\nBATT_VLOG(2) &lt;&lt; \" -- \" &lt;&lt; boost::stacktrace::stacktrace{};\nreturn this-&gt;io_[i % this-&gt;io_.size()]-&gt;get_executor();\n}\nvoid halt() override\n{\nconst bool halted_prior = this-&gt;halted_.exchange(true);\nif (halted_prior) {\nreturn;\n}\nBATT_VLOG(1) &lt;&lt; \"halting Runtime::DefaultScheduler...\";\nfor (auto&amp; work_ptr : this-&gt;work_guards_) {\nwork_ptr.reset();\n}\nBATT_VLOG(1) &lt;&lt; \"work guards released\";\nfor (auto&amp; io_ptr : this-&gt;io_) {\nio_ptr-&gt;stop();\n}\nBATT_VLOG(1) &lt;&lt; \"io contexts stopped\";\n}\nvoid join() override\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;join_mutex_};\nwhile (!this-&gt;thread_pool_.empty()) {\ntry {\nthis-&gt;thread_pool_.back().join();\n} catch (...) {\nstd::cerr &lt;&lt; \"unhandled exception: \"\n&lt;&lt; boost::diagnostic_information(boost::current_exception()) &lt;&lt; std::endl;\n}\nthis-&gt;thread_pool_.pop_back();\n}\nBATT_VLOG(1) &lt;&lt; \"threads joined\";\n}\nprivate:\nconst bool deprecated_ = getenv_as&lt;bool&gt;(\"BATT_DEFAULT_SCHEDULER_DEPRECATE\").value_or(false);\nconst bool disabled_ = getenv_as&lt;bool&gt;(\"BATT_DEFAULT_SCHEDULER_DISABLE\").value_or(false);\nconst bool shared_io_ = getenv_as&lt;bool&gt;(\"BATT_DEFAULT_SCHEDULER_SHARED_IO\").value_or(false);\nconst bool pin_cpu_ = getenv_as&lt;bool&gt;(\"BATT_DEFAULT_SCHEDULER_PIN_CPU\").value_or(true);\n// The number of physical execution units on the system; read at construction time.\n//\nconst unsigned cpu_count_ =\ngetenv_as&lt;unsigned&gt;(\"BATT_DEFAULT_SCHEDULER_CPU_COUNT\").value_or(std::thread::hardware_concurrency());\n// One io_context for each thread in the pool.\n//\nstd::vector&lt;std::unique_ptr&lt;boost::asio::io_context&gt;&gt; io_;\n// One WorkGuard for each io_context, to keep it alive even if there is no work available at the\n// moment.\n//\nstd::vector&lt;std::unique_ptr&lt;WorkGuard&gt;&gt; work_guards_;\n// One thread per io_context.\n//\nstd::vector&lt;std::thread&gt; thread_pool_;\n// Latching flag to make it safe to call this-&gt;halt() more than once.\n//\nstd::atomic&lt;bool&gt; halted_{false};\n// The scheduling algorithm is to increment this counter each time `schedule_task` is invoked.\n//\nstd::atomic&lt;usize&gt; round_robin_{0};\n// Used to prevent data races inside `join()`.\n//\nstd::mutex join_mutex_;\n};\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\ninline Runtime::Runtime() noexcept\n: default_scheduler_{new DefaultScheduler{}}\n, scheduler_{this-&gt;default_scheduler_.get()}\n{\n::batt::enable_dump_tasks();\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_RUNTIME_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/scalable__grant_8cpp/","title":"batteries/async/scalable_grant.cpp","text":""},{"location":"_autogen/Files/scalable__grant_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/scalable_grant.hpp&gt;\n//\n#include &lt;batteries/async/scalable_grant_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/scalable__grant_8hpp/","title":"batteries/async/scalable_grant.hpp","text":""},{"location":"_autogen/Files/scalable__grant_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/scalable__grant_8hpp/#classes","title":"Classes","text":"Name class batt::ScalableGrantIssuer A pool from which ScalableGrant instances are allocated. class batt::ScalableGrant A claim on some counted resource."},{"location":"_autogen/Files/scalable__grant_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SCALABLE_GRANT_HPP"},{"location":"_autogen/Files/scalable__grant_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/scalable__grant_8hpp/#define-batteries_async_scalable_grant_hpp","title":"define BATTERIES_ASYNC_SCALABLE_GRANT_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SCALABLE_GRANT_HPP()\n</code></pre>"},{"location":"_autogen/Files/scalable__grant_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SCALABLE_GRANT_HPP\n#define BATTERIES_ASYNC_SCALABLE_GRANT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/async/types.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;mutex&gt;\nnamespace batt {\nclass ScalableGrant;\nclass ScalableGrantIssuer\n{\nfriend class ScalableGrant;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\npublic:\nusing Issuer = ScalableGrantIssuer;\nusing Self = Issuer;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nScalableGrantIssuer() noexcept;\nexplicit ScalableGrantIssuer(u64 size) noexcept;\nScalableGrantIssuer(const Self&amp;) = delete;\nSelf&amp; operator=(const Self&amp;) = delete;\n~ScalableGrantIssuer() noexcept;\n//----- --- -- -  -  -   -\nStatusOr&lt;ScalableGrant&gt; issue_grant(u64 count, WaitForResource wait_for_resource) noexcept;\nvoid grow(u64 count) noexcept;\nvoid close() noexcept;\nu64 available() const noexcept\n{\nreturn this-&gt;state_.get_count();\n}\nu64 total_size() const noexcept\n{\nreturn this-&gt;total_size_.load();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nstruct ConsumerBase;\nusing Consumer = BasicAbstractHandler&lt;/*Base=*/ConsumerBase, /*Args...=*/StatusOr&lt;ScalableGrant&gt;&gt;;\ntemplate &lt;typename HandlerFn&gt;\nusing ConsumerImpl =\nBasicHandlerImpl&lt;HandlerFn, /*Base=*/ConsumerBase, /*Args...=*/StatusOr&lt;ScalableGrant&gt;&gt;;\nstruct ConsumerBase\n: boost::intrusive::slist_base_hook&lt;boost::intrusive::cache_last&lt;true&gt;,\nboost::intrusive::constant_time_size&lt;true&gt;&gt; {\nu64 needed = 0;\n};\nusing ConsumerList = boost::intrusive::slist&lt;Consumer, boost::intrusive::cache_last&lt;true&gt;,\nboost::intrusive::constant_time_size&lt;true&gt;&gt;;\nclass State\n{\npublic:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic void wake_all(Issuer* issuer, ConsumerList&amp; to_wake, Status status);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit State(u64 init_count) noexcept;\nState(State&amp;&amp; that) noexcept;\n//----- --- -- -  -  -   -\nStatusOr&lt;ScalableGrant&gt; acquire(Issuer* issuer, u64 n, WaitForResource wait_for_resource) noexcept;\nbool try_acquire(u64 n) noexcept;\ntemplate &lt;typename HandlerFn = void(StatusOr&lt;ScalableGrant&gt;)&gt;\nvoid async_acquire(Issuer* issuer, u64 n, HandlerFn&amp;&amp; handler) noexcept;\nu64 acquire_all() noexcept\n{\nconst u64 observed = this-&gt;count_.exchange(0);\nif (observed == 0) {\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn this-&gt;count_.exchange(0);\n}\nreturn observed;\n}\nBATT_WARN_UNUSED_RESULT ConsumerList release(u64 n) noexcept;\nBATT_WARN_UNUSED_RESULT ConsumerList close() noexcept;\nu64 get_count() const noexcept\n{\nconst u64 observed = this-&gt;count_.load();\nif (observed == 0) {\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn this-&gt;count_.load();\n}\nreturn observed;\n}\nbool is_closed() const noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn this-&gt;closed_;\n}\nvoid swap(State&amp; that) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nstd::atomic&lt;u64&gt; count_;\nmutable std::mutex mutex_;\nConsumerList waiters_;\nbool closed_;\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid recycle(u64 n) noexcept\n{\nConsumerList to_wake = this-&gt;state_.release(n);\nState::wake_all(this, to_wake, OkStatus());\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nState state_;\nstd::atomic&lt;u64&gt; total_size_;\n};\nclass ScalableGrant\n{\nfriend class ScalableGrantIssuer;\nfriend class ScalableGrantIssuer::State;\npublic:\nusing Issuer = ScalableGrantIssuer;\nusing State = Issuer::State;\nScalableGrant() noexcept;\nScalableGrant(const ScalableGrant&amp;) = delete;\nScalableGrant&amp; operator=(const ScalableGrant&amp;) = delete;\nScalableGrant(ScalableGrant&amp;&amp; that) noexcept;\nScalableGrant&amp; operator=(ScalableGrant&amp;&amp;) = delete;\n~ScalableGrant() noexcept;\n//----- --- -- -  -  -   -\nconst Issuer* get_issuer() const noexcept\n{\nreturn this-&gt;issuer_.get();\n}\nbool empty() const noexcept\n{\nreturn this-&gt;size() == 0;\n}\nexplicit operator bool() const noexcept\n{\nreturn this-&gt;is_valid();\n}\nbool is_valid() const noexcept\n{\nreturn this-&gt;size() != 0 &amp;&amp; this-&gt;issuer_;\n}\nbool is_revoked() const noexcept\n{\nreturn this-&gt;state_.is_closed();\n}\n//----- --- -- -  -  -   -\n// All of the following public methods are thread-safe with respect to each other; they MUST NOT be called\n// concurrent to:\n//  - `SpinGrant::~SpinGrant()`\n//  - `SpinGrant other = std::move(*this);`\n//----- --- -- -  -  -   -\nvoid revoke() noexcept;\nu64 size() const noexcept\n{\nreturn this-&gt;state_.get_count();\n}\nStatusOr&lt;ScalableGrant&gt; spend(u64 count,\nWaitForResource wait_for_resource = WaitForResource::kFalse) noexcept;\nu64 spend_all() noexcept;\nScalableGrant&amp; subsume(ScalableGrant&amp;&amp; that) noexcept;\nvoid swap(ScalableGrant&amp; that) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nScalableGrant(Issuer* issuer, u64 count) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// Tracks the currently held count, the closed/revoked state, and any waiters.\n//\nState state_;\n// This field *must not* change after it is initialized.\n//\nUniqueNonOwningPtr&lt;Issuer&gt; issuer_;\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const ScalableGrant&amp; t)\n{\nreturn out &lt;&lt; \"Grant{.size=\" &lt;&lt; t.size() &lt;&lt; \",}\";\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename HandlerFn /*= void(StatusOr&lt;ScalableGrant&gt;)*/&gt;\nvoid ScalableGrantIssuer::State::async_acquire(Issuer* issuer, u64 n, HandlerFn&amp;&amp; handler) noexcept\n{\nbool ready = false;\nbool closed = false;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nif (this-&gt;closed_) {\nready = true;\nclosed = true;\n} else {\nu64 local_count = this-&gt;count_.exchange(0);\nauto on_scope_exit = batt::finally([&amp;] {\nthis-&gt;count_.store(local_count);\n});\nif (local_count &gt;= n) {\nlocal_count -= n;\nready = true;\n} else {\nConsumer* client = ConsumerImpl&lt;std::decay_t&lt;HandlerFn&gt;&gt;::make_new(BATT_FORWARD(handler));\nclient-&gt;needed = n;\nthis-&gt;waiters_.push_back(*client);\n}\n}\n}\nif (ready) {\nif (!closed) {\nhandler(StatusOr&lt;ScalableGrant&gt;{ScalableGrant{issuer, n}});\n} else {\nhandler(StatusOr&lt;ScalableGrant&gt;{Status{StatusCode::kClosed}});\n}\n}\n}\n}  //namespace batt\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/scalable_grant_impl.hpp&gt;\n#endif\n#endif  // BATTERIES_ASYNC_SCALABLE_GRANT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/scalable__grant__impl_8hpp/","title":"batteries/async/scalable_grant_impl.hpp","text":""},{"location":"_autogen/Files/scalable__grant__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/scalable__grant__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SCALABLE_GRANT_IMPL_HPP"},{"location":"_autogen/Files/scalable__grant__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/scalable__grant__impl_8hpp/#define-batteries_async_scalable_grant_impl_hpp","title":"define BATTERIES_ASYNC_SCALABLE_GRANT_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SCALABLE_GRANT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/scalable__grant__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SCALABLE_GRANT_IMPL_HPP\n#define BATTERIES_ASYNC_SCALABLE_GRANT_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/debug_info.hpp&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// class ScalableGrantIssuer\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrantIssuer::~ScalableGrantIssuer() noexcept\n{\nBATT_CHECK_EQ(this-&gt;total_size_.load(), this-&gt;state_.get_count())\n&lt;&lt; \"This may indicate a Grant is still active!\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrantIssuer::ScalableGrantIssuer() noexcept : Self{0}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ ScalableGrantIssuer::ScalableGrantIssuer(u64 size) noexcept\n: state_{size}\n, total_size_{size}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;ScalableGrant&gt; ScalableGrantIssuer::issue_grant(\nu64 count, WaitForResource wait_for_resource) noexcept\n{\nreturn this-&gt;state_.acquire(this, count, wait_for_resource);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void ScalableGrantIssuer::grow(u64 count) noexcept\n{\nconst u64 old_size = this-&gt;total_size_.fetch_add(count);\nBATT_CHECK_GT(u64{old_size + count}, old_size) &lt;&lt; \"Integer overflow detected!\";\nthis-&gt;recycle(count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void ScalableGrantIssuer::close() noexcept\n{\nConsumerList to_wake = this-&gt;state_.close();\nState::wake_all(this, to_wake, StatusCode::kClosed);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// class ScalableGrantIssuer::State\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ ScalableGrantIssuer::State::State(u64 init_count) noexcept\n: count_{init_count}\n, mutex_{}\n, waiters_{}\n, closed_{false}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrantIssuer::State::State(State&amp;&amp; that) noexcept\n: count_{that.count_.exchange(0)}\n, mutex_{}\n, waiters_{std::move(that.waiters_)}\n, closed_{that.closed_}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ void ScalableGrantIssuer::State::wake_all(Issuer* issuer, ConsumerList&amp; to_wake,\nStatus status)\n{\nwhile (!to_wake.empty()) {\nConsumer&amp; next = to_wake.front();\nto_wake.pop_front();\nu64 size = next.needed;\nif (status.ok()) {\nnext.notify(ScalableGrant{issuer, size});\n} else {\nnext.notify(status);\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;ScalableGrant&gt; ScalableGrantIssuer::State::acquire(\nIssuer* issuer, u64 n, WaitForResource wait_for_resource) noexcept\n{\nif (issuer == nullptr) {\nreturn {StatusCode::kFailedPrecondition};\n}\nif (this-&gt;try_acquire(n)) {\nreturn ScalableGrant{issuer, n};\n}\nif (wait_for_resource == WaitForResource::kFalse) {\nreturn {StatusCode::kGrantUnavailable};\n}\nBATT_DEBUG_INFO(\"Grant::acquire(n=\" &lt;&lt; n &lt;&lt; \")\" &lt;&lt; BATT_INSPECT(this-&gt;count_)\n&lt;&lt; BATT_INSPECT(issuer-&gt;total_size_));\nreturn Task::await&lt;StatusOr&lt;ScalableGrant&gt;&gt;([&amp;](auto&amp;&amp; handler) {\nthis-&gt;async_acquire(issuer, n, BATT_FORWARD(handler));\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool ScalableGrantIssuer::State::try_acquire(u64 n) noexcept\n{\nOptional&lt;std::unique_lock&lt;std::mutex&gt;&gt; optional_lock;\nu64 observed = this-&gt;count_.load();\nfor (;;) {\n// If we observe the count to be zero, lock the mutex to rule out the possibility that there is\n// another thread inside release.\n//\nif (observed == 0 &amp;&amp; !optional_lock) {\noptional_lock.emplace(this-&gt;mutex_);\nobserved = this-&gt;count_.load();\n}\nif (observed &lt; n) {\nreturn false;\n}\nif (this-&gt;count_.compare_exchange_weak(observed, observed - n)) {\nreturn true;\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto ScalableGrantIssuer::State::release(u64 n_released) noexcept -&gt; ConsumerList\n{\nConsumerList to_wake;\nif (n_released != 0) {\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\n// If there are no waiters, we just increment the count and return.\n//\nif (this-&gt;waiters_.empty()) {\nthis-&gt;count_.fetch_add(n_released);\n} else {\n// Claim exclusive access to all count while release is running; because `release` must lock the\n// mutex (and all acquire methods only decrease count, never increase), we know that count will\n// stay 0 until we replace the local count below.\n//\nu64 local_count = this-&gt;count_.exchange(0) + n_released;\nauto on_scope_exit = batt::finally([&amp;] {\nthis-&gt;count_.store(local_count);\n});\ndo {\nConsumer&amp; next = this-&gt;waiters_.front();\nconst u64 n_needed = next.needed;\nif (local_count &lt; n_needed) {\nbreak;\n}\nlocal_count -= n_needed;\nthis-&gt;waiters_.pop_front();\nto_wake.push_back(next);\n} while (!this-&gt;waiters_.empty());\n}\n}\nreturn to_wake;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto ScalableGrantIssuer::State::close() noexcept -&gt; ConsumerList\n{\nConsumerList to_wake;\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;closed_ = true;\nstd::swap(to_wake, this-&gt;waiters_);\nreturn to_wake;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void ScalableGrantIssuer::State::swap(State&amp; that) noexcept\n{\nif (BATT_HINT_FALSE(this == &amp;that)) {\nreturn;\n}\nstd::array&lt;std::mutex*, 2&gt; to_lock{&amp;this-&gt;mutex_, &amp;that.mutex_};\nif (to_lock[0] &gt; to_lock[1]) {\nstd::swap(to_lock[0], to_lock[1]);\n}\nstd::unique_lock&lt;std::mutex&gt; lock0{*to_lock[0]};\nstd::unique_lock&lt;std::mutex&gt; lock1{*to_lock[1]};\nthis-&gt;count_.store(that.count_.exchange(this-&gt;count_.exchange(0)));\nstd::swap(this-&gt;closed_, that.closed_);\nstd::swap(this-&gt;waiters_, that.waiters_);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// class ScalableGrant\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrant::ScalableGrant() noexcept : state_{0}, issuer_{nullptr}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrant::ScalableGrant(ScalableGrant&amp;&amp; that) noexcept\n: state_{std::move(that.state_)}\n, issuer_{std::move(that.issuer_)}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrant::ScalableGrant(Issuer* issuer, u64 count) noexcept\n: state_{count}\n, issuer_{issuer}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrant::~ScalableGrant() noexcept\n{\nthis-&gt;revoke();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;ScalableGrant&gt; ScalableGrant::spend(u64 count,\nWaitForResource wait_for_resource) noexcept\n{\nreturn this-&gt;state_.acquire(this-&gt;issuer_.get(), count, wait_for_resource);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL u64 ScalableGrant::spend_all() noexcept\n{\nif (!this-&gt;issuer_) {\nreturn 0;\n}\nconst u64 n_to_recycle = this-&gt;state_.acquire_all();\nif (n_to_recycle != 0) {\nthis-&gt;issuer_-&gt;recycle(n_to_recycle);\n}\nreturn n_to_recycle;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ScalableGrant&amp; ScalableGrant::subsume(ScalableGrant&amp;&amp; that) noexcept\n{\nif (this == &amp;that || !that.issuer_) {\nreturn *this;\n}\nBATT_CHECK_NOT_NULLPTR(this-&gt;issuer_) &lt;&lt; \"It is NOT legal to subsume a Grant into an invalidated Grant.\";\nBATT_CHECK_EQ(this-&gt;issuer_, that.issuer_);\nconst u64 n_subsumed = that.state_.acquire_all();\nIssuer::ConsumerList to_wake = this-&gt;state_.release(n_subsumed);\nState::wake_all(this-&gt;issuer_.get(), to_wake, OkStatus());\nreturn *this;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void ScalableGrant::revoke() noexcept\n{\nthis-&gt;spend_all();\nIssuer::ConsumerList to_wake = this-&gt;state_.close();\nState::wake_all(this-&gt;issuer_.get(), to_wake, StatusCode::kGrantRevoked);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void ScalableGrant::swap(ScalableGrant&amp; that) noexcept\n{\nstd::swap(this-&gt;issuer_, that.issuer_);\nthis-&gt;state_.swap(that.state_);\n}\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_SCALABLE_GRANT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/segv_8hpp/","title":"batteries/segv.hpp","text":""},{"location":"_autogen/Files/segv_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/segv_8hpp/#defines","title":"Defines","text":"Name BATT_STACK_TRACE_AT_EXIT BATT_EXIT(code)"},{"location":"_autogen/Files/segv_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/segv_8hpp/#define-batt_stack_trace_at_exit","title":"define BATT_STACK_TRACE_AT_EXIT","text":"<pre><code>#define BATT_STACK_TRACE_AT_EXIT()\n</code></pre>"},{"location":"_autogen/Files/segv_8hpp/#define-batt_exit","title":"define BATT_EXIT","text":"<pre><code>#define BATT_EXIT(code)\n</code></pre>"},{"location":"_autogen/Files/segv_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/stacktrace.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n#include &lt;signal.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#ifndef BATT_PLATFORM_IS_WINDOWS\n#include &lt;execinfo.h&gt;\n#include &lt;unistd.h&gt;\n#endif\nnamespace batt {\nusing PrintToStreamFunctionPointer = void (*)(std::ostream&amp;);\nnamespace detail {\ninline void print_nothing(std::ostream&amp;)\n{\n}\n}  // namespace detail\ninline std::atomic&lt;PrintToStreamFunctionPointer&gt;&amp; extra_segv_debug_info_callback()\n{\nstatic std::atomic&lt;PrintToStreamFunctionPointer&gt; ptr_{&amp;detail::print_nothing};\nreturn ptr_;\n}\ninline void print_stack_trace()\n{\n#ifndef BATT_PLATFORM_IS_WINDOWS\nconstexpr usize kMaxStackFrames = 64;\nvoid* frames[kMaxStackFrames];\nconst usize size = backtrace(frames, kMaxStackFrames);\n// print out all the frames to stderr\nbacktrace_symbols_fd(frames, size, STDERR_FILENO);\nfflush(stderr);\n#endif  // !BATT_PLATFORM_IS_WINDOWS\nstd::cerr &lt;&lt; std::endl &lt;&lt; boost::stacktrace::stacktrace{} &lt;&lt; std::endl;\nextra_segv_debug_info_callback().load()(std::cerr);\n}\n#ifndef BATT_STACK_TRACE_AT_EXIT\n#define BATT_STACK_TRACE_AT_EXIT false\n#endif\ninline bool&amp; print_stack_trace_atexit_enabled()\n{\nstatic bool b_ = BATT_STACK_TRACE_AT_EXIT;\nreturn b_;\n}\ninline void print_stack_trace_atexit()\n{\nif (print_stack_trace_atexit_enabled()) {\nprint_stack_trace();\n}\n}\n// =============================================================================\n// SEGV backtrace handler\n//\nnamespace detail {\ninline void handle_segv(int sig)\n{\n#ifdef BATT_PLATFORM_IS_WINDOWS\nfprintf(stderr, \"FATAL: signal %d:\\n[[raw stack]]\\n\", sig);\n#else\nfprintf(stderr, \"FATAL: signal %d (%s):\\n[[raw stack]]\\n\", sig, strsignal(sig));\n#endif\nprint_stack_trace_atexit_enabled() = true;\nexit(sig);\n}\ninline void exit_impl(int code)\n{\nprint_stack_trace_atexit_enabled() = (code != 0);\n::exit(code);\n}\n}  // namespace detail\ninline const bool kSigSegvHandlerInstalled = [] {\nsignal(SIGSEGV, &amp;detail::handle_segv);\nsignal(SIGABRT, &amp;detail::handle_segv);\nstd::atexit(&amp;print_stack_trace_atexit);\nreturn true;\n}();\n#define BATT_EXIT(code) ::batt::detail::exit_impl(code)\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/seq_8hpp/","title":"batteries/seq.hpp","text":""},{"location":"_autogen/Files/seq_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/seq_8hpp/#classes","title":"Classes","text":"Name struct batt::VecSeqBase class batt::VecSeq class batt::SeqRef class batt::seq::SingleItem"},{"location":"_autogen/Files/seq_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_HPP"},{"location":"_autogen/Files/seq_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/seq_8hpp/#define-batteries_seq_hpp","title":"define BATTERIES_SEQ_HPP","text":"<pre><code>#define BATTERIES_SEQ_HPP()\n</code></pre>"},{"location":"_autogen/Files/seq_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n// Utilities for dealing with sequences.\n//\n#pragma once\n#ifndef BATTERIES_SEQ_HPP\n#define BATTERIES_SEQ_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/case_of.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/all_true.hpp&gt;\n#include &lt;batteries/seq/any_true.hpp&gt;\n#include &lt;batteries/seq/apply.hpp&gt;\n#include &lt;batteries/seq/attach.hpp&gt;\n#include &lt;batteries/seq/boxed.hpp&gt;\n#include &lt;batteries/seq/cache_next.hpp&gt;\n#include &lt;batteries/seq/chain.hpp&gt;\n#include &lt;batteries/seq/collect.hpp&gt;\n#include &lt;batteries/seq/collect_vec.hpp&gt;\n#include &lt;batteries/seq/consume.hpp&gt;\n#include &lt;batteries/seq/count.hpp&gt;\n#include &lt;batteries/seq/decay.hpp&gt;\n#include &lt;batteries/seq/deref.hpp&gt;\n#include &lt;batteries/seq/emplace_back.hpp&gt;\n#include &lt;batteries/seq/filter.hpp&gt;\n#include &lt;batteries/seq/filter_map.hpp&gt;\n#include &lt;batteries/seq/first.hpp&gt;\n#include &lt;batteries/seq/flatten.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/seq/fuse.hpp&gt;\n#include &lt;batteries/seq/group_by.hpp&gt;\n#include &lt;batteries/seq/inner_reduce.hpp&gt;\n#include &lt;batteries/seq/inspect.hpp&gt;\n#include &lt;batteries/seq/inspect_adjacent.hpp&gt;\n#include &lt;batteries/seq/is_sorted.hpp&gt;\n#include &lt;batteries/seq/kmerge.hpp&gt;\n#include &lt;batteries/seq/last.hpp&gt;\n#include &lt;batteries/seq/lazy.hpp&gt;\n#include &lt;batteries/seq/map.hpp&gt;\n#include &lt;batteries/seq/map_adjacent.hpp&gt;\n#include &lt;batteries/seq/map_fold.hpp&gt;\n#include &lt;batteries/seq/map_pairwise.hpp&gt;\n#include &lt;batteries/seq/merge_by.hpp&gt;\n#include &lt;batteries/seq/natural_order.hpp&gt;\n#include &lt;batteries/seq/print_out.hpp&gt;\n#include &lt;batteries/seq/printable.hpp&gt;\n#include &lt;batteries/seq/product.hpp&gt;\n#include &lt;batteries/seq/reduce.hpp&gt;\n#include &lt;batteries/seq/rolling.hpp&gt;\n#include &lt;batteries/seq/rolling_sum.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/seq/skip_n.hpp&gt;\n#include &lt;batteries/seq/splice.hpp&gt;\n#include &lt;batteries/seq/status_ok.hpp&gt;\n#include &lt;batteries/seq/sub_range_seq.hpp&gt;\n#include &lt;batteries/seq/sum.hpp&gt;\n#include &lt;batteries/seq/take_n.hpp&gt;\n#include &lt;batteries/seq/take_while.hpp&gt;\n#include &lt;batteries/seq/zip.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/range/iterator_range.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;ostream&gt;\n#include &lt;string_view&gt;\n#include &lt;type_traits&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\nnamespace batt {\ntemplate &lt;typename ForwardIter&gt;\nauto as_seq(ForwardIter&amp;&amp; begin, ForwardIter&amp;&amp; end)\n{\nreturn as_seq(boost::make_iterator_range(BATT_FORWARD(begin), BATT_FORWARD(end)));\n}\ntemplate &lt;typename VectorLike, typename = decltype(std::declval&lt;VectorLike&gt;().data()),\ntypename = decltype(std::declval&lt;VectorLike&gt;().size()),\ntypename = std::enable_if_t&lt;std::is_same_v&lt;decltype(std::declval&lt;VectorLike&gt;().data()),\ndecltype(std::declval&lt;VectorLike&gt;().data() +\nstd::declval&lt;VectorLike&gt;().size())&gt;&gt;&gt;\nauto as_seq(VectorLike&amp;&amp; v)\n{\nreturn as_seq(v.data(), v.data() + v.size());\n}\ntemplate &lt;typename T, typename Begin = decltype(std::declval&lt;const T&amp;&gt;().data()),\ntypename End = decltype(std::declval&lt;Begin&gt;() + std::declval&lt;const T&amp;&gt;().size()),\ntypename = std::enable_if_t&lt;std::is_same_v&lt;Begin, End&gt;&gt;&gt;\nauto vec_range(const T&amp; vec)\n{\nreturn boost::make_iterator_range(vec.data(), vec.data() + vec.size());\n}\ntemplate &lt;typename T&gt;\nstruct VecSeqBase {\nexplicit VecSeqBase(std::vector&lt;T&gt;&amp;&amp; v) noexcept : vec(std::move(v))\n{\n}\nstd::vector&lt;T&gt; vec;\n};\ntemplate &lt;typename T&gt;\nclass VecSeq\n: public VecSeqBase&lt;T&gt;\n, public SubRangeSeq&lt;boost::iterator_range&lt;const T*&gt;&gt;\n{\npublic:\nexplicit VecSeq(std::vector&lt;T&gt;&amp;&amp; v) noexcept\n: VecSeqBase&lt;T&gt;{std::move(v)}\n, SubRangeSeq&lt;boost::iterator_range&lt;const T*&gt;&gt;{\nboost::make_iterator_range(this-&gt;vec.data(), this-&gt;vec.data() + this-&gt;vec.size())}\n{\n}\n};\ntemplate &lt;typename T&gt;\nauto into_seq(std::vector&lt;T&gt;&amp;&amp; v)\n{\nreturn VecSeq&lt;T&gt;{std::move(v)};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename SeqT&gt;\nclass SeqRef\n{\npublic:\nusing Item = SeqItem&lt;SeqT&gt;;\nexplicit SeqRef(SeqT&amp; seq) noexcept : p_seq_{&amp;seq}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn this-&gt;p_seq_-&gt;peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn this-&gt;p_seq_-&gt;next();\n}\nprivate:\nSeqT* p_seq_;\n};\ntemplate &lt;typename SeqT&gt;\nSeqRef&lt;SeqT&gt; seq_ref(SeqT&amp; seq)\n{\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;SeqT&gt;, SeqT&gt;,\n\"batt::seq_ref must be used with non-const lvalue references\");\nreturn SeqRef&lt;SeqT&gt;{seq};\n}\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// single_item\n//\ntemplate &lt;typename T&gt;\nclass SingleItem\n{\npublic:\nusing Item = T;\nexplicit SingleItem(T&amp;&amp; item) noexcept : item_(BATT_FORWARD(item))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn item_;\n}\nOptional&lt;Item&gt; next()\n{\nauto n = std::move(item_);\nitem_ = None;\nreturn n;\n}\nprivate:\nOptional&lt;Item&gt; item_;\n};\ntemplate &lt;typename T&gt;\n[[nodiscard]] SingleItem&lt;T&gt; single_item(T&amp;&amp; item)\n{\nreturn SingleItem&lt;T&gt;{BATT_FORWARD(item)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/seq__item_8hpp/","title":"batteries/seq/seq_item.hpp","text":""},{"location":"_autogen/Files/seq__item_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/seq__item_8hpp/#classes","title":"Classes","text":"Name struct batt::SeqItem_Impl"},{"location":"_autogen/Files/seq__item_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_SEQ_ITEM_HPP"},{"location":"_autogen/Files/seq__item_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/seq__item_8hpp/#define-batteries_seq_seq_item_hpp","title":"define BATTERIES_SEQ_SEQ_ITEM_HPP","text":"<pre><code>#define BATTERIES_SEQ_SEQ_ITEM_HPP()\n</code></pre>"},{"location":"_autogen/Files/seq__item_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_SEQ_ITEM_HPP\n#define BATTERIES_SEQ_SEQ_ITEM_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nstruct SeqItem_Impl {\nusing type = typename std::decay_t&lt;T&gt;::Item;\nstatic_assert(!std::is_rvalue_reference_v&lt;type&gt;, \"\");\n};\ntemplate &lt;typename T&gt;\nusing SeqItem = typename SeqItem_Impl&lt;T&gt;::type;\n}  // namespace batt\n#endif  // BATTERIES_SEQ_SEQ_ITEM_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/shared__ptr_8hpp/","title":"batteries/shared_ptr.hpp","text":""},{"location":"_autogen/Files/shared__ptr_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/shared__ptr_8hpp/#classes","title":"Classes","text":"Name struct batt::SharedPtrImpl"},{"location":"_autogen/Files/shared__ptr_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SHARED_PTR_HPP"},{"location":"_autogen/Files/shared__ptr_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/shared__ptr_8hpp/#define-batteries_shared_ptr_hpp","title":"define BATTERIES_SHARED_PTR_HPP","text":"<pre><code>#define BATTERIES_SHARED_PTR_HPP()\n</code></pre>"},{"location":"_autogen/Files/shared__ptr_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SHARED_PTR_HPP\n#define BATTERIES_SHARED_PTR_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/smart_ptr/intrusive_ptr.hpp&gt;\n#include &lt;boost/smart_ptr/intrusive_ref_counter.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Alias to add atomic reference counting intrusively to a class via base class.\n//\ntemplate &lt;typename T&gt;\nusing RefCounted = boost::intrusive_ref_counter&lt;std::decay_t&lt;T&gt;&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nnamespace detail {\ntemplate &lt;typename T,                                               //\ntypename = decltype(intrusive_ptr_add_ref((T*)nullptr)),  //\ntypename = decltype(intrusive_ptr_release((T*)nullptr))&gt;\nstd::true_type is_ref_counted_impl(void*);\ntemplate &lt;typename T&gt;\nstd::false_type is_ref_counted_impl(...);\n}  // namespace detail\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Type trait that determines whether T, when decayed, is intrusively reference counted.\n//\ntemplate &lt;typename T&gt;\nusing IsRefCounted = decltype(detail::is_ref_counted_impl&lt;std::decay_t&lt;T&gt;&gt;(nullptr));\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\nstruct SharedPtrImpl\n: std::conditional&lt;\n// If T derives from RefCounted&lt;T&gt;\nIsRefCounted&lt;T&gt;{},\n// Then use intrusive_ptr\nboost::intrusive_ptr&lt;std::remove_reference_t&lt;T&gt;&gt;,\n// Else use shared_ptr\nstd::shared_ptr&lt;std::remove_reference_t&lt;T&gt;&gt;&gt; {\n};\ntemplate &lt;typename T&gt;\nusing SharedPtr = typename SharedPtrImpl&lt;T&gt;::type;\ntemplate &lt;typename T, typename... Args, typename = std::enable_if_t&lt;IsRefCounted&lt;T&gt;{}&gt;&gt;\nSharedPtr&lt;T&gt; make_shared(Args&amp;&amp;... args)\n{\nreturn SharedPtr&lt;T&gt;{new T(BATT_FORWARD(args)...)};\n}\ntemplate &lt;typename T, typename... Args, typename = std::enable_if_t&lt;!IsRefCounted&lt;T&gt;{}&gt;, typename = void&gt;\nSharedPtr&lt;T&gt; make_shared(Args&amp;&amp;... args)\n{\nreturn std::make_shared&lt;T&gt;(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename T&gt;\nSharedPtr&lt;T&gt; into_shared(std::unique_ptr&lt;T&gt;&amp;&amp; ptr)\n{\nreturn SharedPtr&lt;T&gt;{ptr.release()};\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;\nstd::is_same_v&lt;SharedPtr&lt;T&gt;, std::shared_ptr&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;&gt;&gt;\nSharedPtr&lt;T&gt; shared_ptr_from(T* that)\n{\nreturn that-&gt;shared_from_this();\n}\ntemplate &lt;typename T,\ntypename = std::enable_if_t&lt;\nstd::is_same_v&lt;SharedPtr&lt;T&gt;, boost::intrusive_ptr&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;&gt;,\ntypename = void&gt;\nSharedPtr&lt;T&gt; shared_ptr_from(T* that)\n{\nreturn SharedPtr&lt;T&gt;{that};\n}\n}  // namespace batt\n#endif  // BATTERIES_SHARED_PTR_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/simple__executor_8cpp/","title":"batteries/async/simple_executor.cpp","text":""},{"location":"_autogen/Files/simple__executor_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/simple_executor.hpp&gt;\n//\n#include &lt;batteries/async/simple_executor_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/simple__executor_8hpp/","title":"batteries/async/simple_executor.hpp","text":""},{"location":"_autogen/Files/simple__executor_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/simple__executor_8hpp/#classes","title":"Classes","text":"Name class batt::SimpleExecutionContext A minimal multi-threaded execution context implementation, suitable for parallel-compute thread pools."},{"location":"_autogen/Files/simple__executor_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SIMPLE_EXECUTOR_HPP"},{"location":"_autogen/Files/simple__executor_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/simple__executor_8hpp/#define-batteries_async_simple_executor_hpp","title":"define BATTERIES_ASYNC_SIMPLE_EXECUTOR_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SIMPLE_EXECUTOR_HPP()\n</code></pre>"},{"location":"_autogen/Files/simple__executor_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SIMPLE_EXECUTOR_HPP\n#define BATTERIES_ASYNC_SIMPLE_EXECUTOR_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/asio/execution_context.hpp&gt;\n#include &lt;batteries/asio/system_executor.hpp&gt;\n#include &lt;batteries/async/basic_executor.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/asio/query.hpp&gt;\n#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\nnamespace batt {\n// Forward-declaration.\n//\nclass SimpleExecutionContext;\n// The executor type used by SimpleExecutionContext.\n//\nusing SimpleExecutor = BasicExecutor&lt;SimpleExecutionContext,  //\nboost::asio::execution::outstanding_work_t::untracked_t,\nboost::asio::execution::blocking_t::never_t,\nboost::asio::execution::relationship_t::fork_t&gt;;\nclass SimpleExecutionContext : public boost::asio::execution_context\n{\npublic:\nusing Self = SimpleExecutionContext;\nusing executor_type = SimpleExecutor;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic auto inside_run_on_this_thread() noexcept -&gt; SimpleExecutionContext**;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nSimpleExecutionContext() = default;\n~SimpleExecutionContext() = default;\nauto get_executor() noexcept -&gt; executor_type;\nauto work_count() noexcept -&gt; Watch&lt;i64&gt;&amp;;  // TODO [tastolfi 2023-07-31] make const &amp;\nauto wake() -&gt; void;\nauto on_work_started() noexcept -&gt; void;\nauto on_work_finished() noexcept -&gt; void;\nauto stop() noexcept -&gt; void;\nauto is_stopped() const noexcept -&gt; bool;\nauto run() noexcept -&gt; usize;\nauto reset() noexcept -&gt; void;\nauto get_allocator() const -&gt; std::allocator&lt;void&gt;;\ntemplate &lt;typename Fn&gt;\nauto dispatch(Fn&amp;&amp; fn) noexcept -&gt; void;\ntemplate &lt;typename Fn&gt;\nauto post(Fn&amp;&amp; fn) noexcept -&gt; void;\ntemplate &lt;typename Fn&gt;\nauto defer(Fn&amp;&amp; fn) noexcept -&gt; void;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nWatch&lt;i64&gt; work_count_{0};\nstd::allocator&lt;void&gt; allocator_;\nstd::mutex mutex_;\nstd::condition_variable cond_;\nHandlerList&lt;&gt; queue_;\nstd::atomic&lt;bool&gt; stop_{false};\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n}  //namespace batt\n#include &lt;batteries/async/simple_executor.ipp&gt;\n#endif  // BATTERIES_ASYNC_SIMPLE_EXECUTOR_HPP\n#include &lt;batteries/config.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/simple_executor_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/simple__executor__impl_8hpp/","title":"batteries/async/simple_executor_impl.hpp","text":""},{"location":"_autogen/Files/simple__executor__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/simple__executor__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SIMPLE_EXECUTOR_IMPL_HPP"},{"location":"_autogen/Files/simple__executor__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/simple__executor__impl_8hpp/#define-batteries_async_simple_executor_impl_hpp","title":"define BATTERIES_ASYNC_SIMPLE_EXECUTOR_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SIMPLE_EXECUTOR_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/simple__executor__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SIMPLE_EXECUTOR_IMPL_HPP\n#define BATTERIES_ASYNC_SIMPLE_EXECUTOR_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ auto SimpleExecutionContext::inside_run_on_this_thread() noexcept\n-&gt; SimpleExecutionContext**\n{\nthread_local SimpleExecutionContext* context = nullptr;\nreturn &amp;context;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::get_executor() noexcept -&gt; executor_type\n{\nreturn executor_type{this};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::stop() noexcept -&gt; void\n{\nthis-&gt;stop_.store(true);\nthis-&gt;cond_.notify_all();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::is_stopped() const noexcept -&gt; bool\n{\nreturn this-&gt;stop_.load();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::run() noexcept -&gt; usize\n{\nusize handler_count = 0;\nSelf* prev_context = this;\nstd::swap(*Self::inside_run_on_this_thread(), prev_context);\nauto on_scope_exit = batt::finally([&amp;] {\nstd::swap(*Self::inside_run_on_this_thread(), prev_context);\n});\nwhile (!this-&gt;stop_.load() &amp;&amp; this-&gt;work_count_.get_value() &gt; 0) {\nbool have_more = false;\nauto next = [this, &amp;have_more]() -&gt; AbstractHandler&lt;&gt;* {\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nwhile (this-&gt;queue_.empty() &amp;&amp; !this-&gt;stop_.load() &amp;&amp; this-&gt;work_count_.get_value() &gt; 0) {\nthis-&gt;cond_.wait(lock);\n}\nif (this-&gt;queue_.empty()) {\nreturn nullptr;\n}\nauto* ptr = &amp;(this-&gt;queue_.front());\nthis-&gt;queue_.pop_front();\nhave_more = !this-&gt;queue_.empty();\nreturn ptr;\n}();\nif (have_more) {\nthis-&gt;cond_.notify_one();\n} else if (this-&gt;stop_.load() || this-&gt;work_count_.get_value() == 0) {\nthis-&gt;cond_.notify_all();\n}\nif (next) {\ntry {\nauto on_handler_return = batt::finally([this, &amp;handler_count] {\n++handler_count;\nthis-&gt;on_work_finished();\n});\nnext-&gt;notify();\n} catch (...) {\ncontinue;\n}\n}\n}\nreturn handler_count;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::reset() noexcept -&gt; void\n{\nthis-&gt;stop_.store(false);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::get_allocator() const -&gt; std::allocator&lt;void&gt;\n{\nreturn this-&gt;allocator_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::work_count() noexcept -&gt; Watch&lt;i64&gt;&amp;\n{\nreturn this-&gt;work_count_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::wake() -&gt; void\n{\nthis-&gt;cond_.notify_all();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::on_work_started() noexcept -&gt; void\n{\nconst i64 prior_count = this-&gt;work_count_.fetch_add(1);\nBATT_CHECK_NE(prior_count + 1u, 0u);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto SimpleExecutionContext::on_work_finished() noexcept -&gt; void\n{\nconst i64 prior_count = this-&gt;work_count_.fetch_sub(1);\nBATT_CHECK_GT(prior_count, 0u);\nif (prior_count == 1) {\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nif (this-&gt;work_count_.get_value() != 0) {\nreturn;\n}\n}\nthis-&gt;cond_.notify_all();\n}\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Explicit instantiations.\n//\n#if 0\n    template class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t,\n                             boost::asio::execution::blocking_t::never_t,\n                             boost::asio::execution::relationship_t::fork_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t,\n                             boost::asio::execution::blocking_t::never_t,\n                             boost::asio::execution::relationship_t::fork_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t,\n                             boost::asio::execution::blocking_t::possibly_t,\n                             boost::asio::execution::relationship_t::fork_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t,\n                             boost::asio::execution::blocking_t::possibly_t,\n                             boost::asio::execution::relationship_t::fork_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t,\n                             boost::asio::execution::blocking_t::never_t,\n                             boost::asio::execution::relationship_t::continuation_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t,\n                             boost::asio::execution::blocking_t::never_t,\n                             boost::asio::execution::relationship_t::continuation_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::tracked_t,\n                             boost::asio::execution::blocking_t::possibly_t,\n                             boost::asio::execution::relationship_t::continuation_t&gt;;\ntemplate class BasicExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t,\n                             boost::asio::execution::blocking_t::possibly_t,\n                             boost::asio::execution::relationship_t::continuation_t&gt;;\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n// Type requirement checks.\nstatic_assert(std::is_constructible&lt;boost::asio::any_io_executor, SimpleExecutor&gt;{},\n              \"If this check fails, hopefully one or more of the following more scoped checks will fail as \"\n              \"well, which will help with debugging!\");\nstatic_assert(\n    boost::asio::execution::can_execute&lt;SimpleExecutor, boost::asio::execution::invocable_archetype&gt;::value,\n    \"\");\nstatic_assert(std::is_same_v&lt;bool, decltype(std::declval&lt;const SimpleExecutor&gt;() ==\n                                            std::declval&lt;const SimpleExecutor&gt;())&gt;,\n              \"\");\nstatic_assert(std::is_same_v&lt;bool, decltype(std::declval&lt;const SimpleExecutor&gt;() !=\n                                            std::declval&lt;const SimpleExecutor&gt;())&gt;,\n              \"\");\nstatic_assert(std::is_nothrow_copy_constructible&lt;SimpleExecutor&gt;::value, \"\");\nstatic_assert(std::is_nothrow_destructible&lt;SimpleExecutor&gt;::value, \"\");\nstatic_assert(boost::asio::traits::equality_comparable&lt;SimpleExecutor&gt;::is_valid, \"\");\nstatic_assert(boost::asio::traits::equality_comparable&lt;SimpleExecutor&gt;::is_noexcept, \"\");\nstatic_assert(boost::asio::execution::is_executor_v&lt;SimpleExecutor&gt;, \"\");\nstatic_assert(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;::is_applicable_property_v&lt;\n                  SimpleExecutor&gt;,\n              \"\");\nstatic_assert(\n    boost::asio::can_query&lt;SimpleExecutor,\n                           boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;&gt;::value ||\n        true,\n    \"\");\nstatic_assert(boost::asio::is_applicable_property_v&lt;\n                  SimpleExecutor, boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;&gt;,\n              \"\");\nstatic_assert(boost::asio::execution::detail::supportable_properties&lt;\n                  0, void(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;)&gt;::\n                      template is_valid_target&lt;SimpleExecutor&gt;::value ||\n                  true,\n              \"\");\nstatic_assert(\n    boost::asio::execution::detail::is_valid_target_executor&lt;\n        SimpleExecutor, void(boost::asio::execution::context_as_t&lt;boost::asio::execution_context&amp;&gt;)&gt;::value,\n    \"\");\nstatic_assert(std::is_same_v&lt;decltype(boost::asio::query(\n                                 std::declval&lt;const SimpleExecutor&gt;(),\n                                 boost::asio::execution::context_as&lt;boost::asio::execution_context&amp;&gt;)),\n                             boost::asio::execution_context&amp;&gt;,\n              \"\");\nstatic_assert(boost::asio::is_executor&lt;SimpleExecutionContext::executor_type&gt;::value);\nstatic_assert(boost::asio::execution::detail::is_executor_of_impl&lt;\n              SimpleExecutionContext::executor_type, boost::asio::execution::invocable_archetype&gt;::value);\nstatic_assert(boost::asio::execution::is_executor&lt;SimpleExecutionContext::executor_type&gt;::value);\n#endif\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_SIMPLE_EXECUTOR_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/single__thread__executor_8hpp/","title":"batteries/async/single_thread_executor.hpp","text":""},{"location":"_autogen/Files/single__thread__executor_8hpp/#namespaces","title":"Namespaces","text":"Name batteries"},{"location":"_autogen/Files/single__thread__executor_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP"},{"location":"_autogen/Files/single__thread__executor_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/single__thread__executor_8hpp/#define-batteries_async_single_thread_executor_hpp","title":"define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP()\n</code></pre>"},{"location":"_autogen/Files/single__thread__executor_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP\n#define BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batteries {\n}  // namespace batteries\n#endif  // BATTERIES_ASYNC_SINGLE_THREAD_EXECUTOR_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/skip__list_8hpp/","title":"batteries/skip_list.hpp","text":""},{"location":"_autogen/Files/skip__list_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/skip__list_8hpp/#classes","title":"Classes","text":"Name class batt::SkipNodeBase class SkipNode class SkipList"},{"location":"_autogen/Files/skip__list_8hpp/#functions","title":"Functions","text":"Name void deallocate() SkipNodeBase ** get_next(i32 level)"},{"location":"_autogen/Files/skip__list_8hpp/#attributes","title":"Attributes","text":"Name Optional&lt; KeyT &gt; key_ Optional&lt; ValueT &gt; value_ i32 height_"},{"location":"_autogen/Files/skip__list_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SKIP_LIST_HPP BATT_FOR_SKIP_LEVEL_2(start, macro) BATT_FOR_SKIP_LEVEL_4(start, macro) BATT_FOR_SKIP_LEVEL_8(start, macro) BATT_FOR_SKIP_LEVEL_16(start, macro) BATT_FOR_SKIP_LEVEL_32(start, macro) BATT_FOR_SKIP_LEVEL_64(start, macro) BATT_FOR_ALL_SKIP_LEVELS(height_expr, macro) BATT_RETURN_NEW_SKIP_NODE(HEIGHT) BATT_DELETE_SKIP_NODE(HEIGHT)"},{"location":"_autogen/Files/skip__list_8hpp/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Files/skip__list_8hpp/#function-deallocate","title":"function deallocate","text":"<pre><code>void deallocate()\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#function-get_next","title":"function get_next","text":"<pre><code>SkipNodeBase ** get_next(\ni32 level\n)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"_autogen/Files/skip__list_8hpp/#variable-key_","title":"variable key_","text":"<pre><code>Optional&lt; KeyT &gt; key_;\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#variable-value_","title":"variable value_","text":"<pre><code>Optional&lt; ValueT &gt; value_;\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#variable-height_","title":"variable height_","text":"<pre><code>i32 height_;\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/skip__list_8hpp/#define-batteries_skip_list_hpp","title":"define BATTERIES_SKIP_LIST_HPP","text":"<pre><code>#define BATTERIES_SKIP_LIST_HPP()\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_skip_level_2","title":"define BATT_FOR_SKIP_LEVEL_2","text":"<pre><code>#define BATT_FOR_SKIP_LEVEL_2(start, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_skip_level_4","title":"define BATT_FOR_SKIP_LEVEL_4","text":"<pre><code>#define BATT_FOR_SKIP_LEVEL_4(start, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_skip_level_8","title":"define BATT_FOR_SKIP_LEVEL_8","text":"<pre><code>#define BATT_FOR_SKIP_LEVEL_8(start, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_skip_level_16","title":"define BATT_FOR_SKIP_LEVEL_16","text":"<pre><code>#define BATT_FOR_SKIP_LEVEL_16(start, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_skip_level_32","title":"define BATT_FOR_SKIP_LEVEL_32","text":"<pre><code>#define BATT_FOR_SKIP_LEVEL_32(start, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_skip_level_64","title":"define BATT_FOR_SKIP_LEVEL_64","text":"<pre><code>#define BATT_FOR_SKIP_LEVEL_64(start, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_for_all_skip_levels","title":"define BATT_FOR_ALL_SKIP_LEVELS","text":"<pre><code>#define BATT_FOR_ALL_SKIP_LEVELS(height_expr, macro)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_return_new_skip_node","title":"define BATT_RETURN_NEW_SKIP_NODE","text":"<pre><code>#define BATT_RETURN_NEW_SKIP_NODE(HEIGHT)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#define-batt_delete_skip_node","title":"define BATT_DELETE_SKIP_NODE","text":"<pre><code>#define BATT_DELETE_SKIP_NODE(HEIGHT)\n</code></pre>"},{"location":"_autogen/Files/skip__list_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_SKIP_LIST_HPP\n#define BATTERIES_SKIP_LIST_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/math.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;pcg_random.hpp&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;functional&gt;\nnamespace batt {\n#define BATT_FOR_SKIP_LEVEL_2(start, macro) macro((start)) macro(((start) + 1))\n#define BATT_FOR_SKIP_LEVEL_4(start, macro)                                                                  \\\n    BATT_FOR_SKIP_LEVEL_2(start, macro) BATT_FOR_SKIP_LEVEL_2((start) + 2, macro)\n#define BATT_FOR_SKIP_LEVEL_8(start, macro)                                                                  \\\n    BATT_FOR_SKIP_LEVEL_4((start), macro) BATT_FOR_SKIP_LEVEL_4((start) + 4, macro)\n#define BATT_FOR_SKIP_LEVEL_16(start, macro)                                                                 \\\n    BATT_FOR_SKIP_LEVEL_8((start), macro) BATT_FOR_SKIP_LEVEL_8((start) + 8, macro)\n#define BATT_FOR_SKIP_LEVEL_32(start, macro)                                                                 \\\n    BATT_FOR_SKIP_LEVEL_16((start), macro) BATT_FOR_SKIP_LEVEL_16((start) + 16, macro)\n#define BATT_FOR_SKIP_LEVEL_64(start, macro)                                                                 \\\n    BATT_FOR_SKIP_LEVEL_32((start), macro) BATT_FOR_SKIP_LEVEL_32((start) + 32, macro)\n#define BATT_FOR_ALL_SKIP_LEVELS(height_expr, macro)                                                         \\\n    switch (height_expr) {                                                                                   \\\n        BATT_FOR_SKIP_LEVEL_64(1, macro)                                                                     \\\n                                                                                                             \\\n    default:                                                                                                 \\\n        BATT_PANIC() &lt;&lt; \"Bad height value: \" &lt;&lt; (height_expr);                                               \\\n        BATT_UNREACHABLE();                                                                                  \\\n    }\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename KeyT, typename ValueT, typename OrderFn, i32 kHeight&gt;\nclass SkipNode;\ntemplate &lt;typename KeyT, typename ValueT, typename OrderFn&gt;\nclass SkipNodeBase\n{\npublic:\ntemplate &lt;i32 kHeight&gt;\nusing Derived = SkipNode&lt;KeyT, ValueT, OrderFn, kHeight&gt;;\nstatic SkipNodeBase* allocate(i32 new_node_height)\n{\n#define BATT_RETURN_NEW_SKIP_NODE(HEIGHT)                                                                    \\\n    case (HEIGHT):                                                                                           \\\n        return new Derived&lt;(HEIGHT)&gt;{};\n//----- --- -- -  -  -   -\nBATT_FOR_ALL_SKIP_LEVELS(new_node_height, BATT_RETURN_NEW_SKIP_NODE)\n}\nvoid deallocate()\n{\n#define BATT_DELETE_SKIP_NODE(HEIGHT)                                                                        \\\n    case (HEIGHT):                                                                                           \\\n        delete static_cast&lt;Derived&lt;(HEIGHT)&gt;*&gt;(this);                                                        \\\n        break;\n//----- --- -- -  -  -   -\nBATT_FOR_ALL_SKIP_LEVELS(this-&gt;height_, BATT_DELETE_SKIP_NODE)\n}\nSkipNodeBase** get_next(i32 level);\nconst SkipNodeBase* const* get_next(i32 level) const;\nOptional&lt;KeyT&gt; key_;\nOptional&lt;ValueT&gt; value_;\ni32 height_;\n};\ntemplate &lt;typename KeyT, typename ValueT, typename OrderFn, i32 kHeight&gt;\nclass SkipNode : public SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;\n{\npublic:\nusing Super = SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;;\nSkipNode()\n{\nthis-&gt;height_ = kHeight;\nthis-&gt;next_.fill(nullptr);\n}\nstd::array&lt;Super*, kHeight&gt; next_;\n};\ntemplate &lt;typename KeyT, typename ValueT, typename OrderFn = std::less&lt;KeyT&gt;, typename Rng = pcg64_unique&gt;\nclass SkipList\n{\npublic:\ntemplate &lt;i32 kHeight&gt;\nusing Node = SkipNode&lt;KeyT, ValueT, OrderFn, kHeight&gt;;\nusing NodeBase = SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nSkipList() noexcept : rng_{}, active_levels_{0}, head_{}, size_{0}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ni32 height() const noexcept\n{\nif (this-&gt;active_levels_ == 0) {\nreturn 0;\n}\nreturn 64 - __builtin_clzll(this-&gt;active_levels_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nusize size() const noexcept\n{\nreturn this-&gt;size_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nbool empty() const noexcept\n{\nreturn this-&gt;size_ == 0;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nconst NodeBase* find(const KeyT&amp; key) const noexcept\n{\ni32 height = this-&gt;height();\nif (height == 0) {\nreturn nullptr;\n}\ni32 level = height - 1;\nOrderFn key_less_than;\nconst NodeBase* prev = &amp;this-&gt;head_;\nconst NodeBase* next;\nconst NodeBase* const* p_next;\nfor (;;) {\np_next = prev-&gt;get_next(level);\nnext = *p_next;\nif (!next || (next-&gt;key_ &amp;&amp; key_less_than(key, *next-&gt;key_))) {\nif (level == 0) {\nreturn prev;\n}\n--level;\n} else {\nprev = next;\n}\n}\nBATT_UNREACHABLE();\n}\ntemplate &lt;typename KeyArg&gt;\nbool erase(const KeyArg&amp; key_arg)\n{\ni32 height = this-&gt;height();\nif (height == 0) {\nreturn false;\n}\ni32 level = height - 1;\nOrderFn key_less_than;\nNodeBase* prev = &amp;this-&gt;head_;\nNodeBase* next;\nNodeBase** p_next;\nNodeBase* found = nullptr;\nfor (;;) {\np_next = prev-&gt;get_next(level);\nnext = *p_next;\nif (next) {\nBATT_CHECK(next-&gt;key_);\nif (found || !key_less_than(key_arg, *next-&gt;key_)) {\nif (next == found || (!found &amp;&amp; !key_less_than(*next-&gt;key_, key_arg))) {\n//\n// Keys are equal!\nif (found) {\nBATT_CHECK_EQ(found, next) &lt;&lt; \"Same key found multiple times, different nodes!\";\n} else {\nfound = next;\n}\n// Remove the node from this level of the list.\n//\n*p_next = *next-&gt;get_next(level);\n} else {\nprev = next;\ncontinue;\n}\n}\n}\nif (level == 0) {\nbreak;\n}\n--level;\n}\nif (found) {\nfor (i32 i = 0; i &lt; height; ++i) {\nif (!this-&gt;head_.next_[i]) {\nthis-&gt;active_levels_ &amp;= ~(u64{1} &lt;&lt; i);\n}\n}\nfound-&gt;deallocate();\n}\nreturn found != nullptr;\n}\ntemplate &lt;typename KeyArg, typename ValueArg&gt;\nNodeBase* emplace(KeyArg&amp;&amp; key_arg, ValueArg&amp;&amp; value_arg)\n{\ni32 new_node_height = __builtin_clzll(this-&gt;rng_() | 1ull) + 1;\nNodeBase* node = nullptr;\ni32 this_height = this-&gt;height();\ni32 level = this_height - 1;\nOrderFn key_less_than;\nNodeBase* prev = &amp;this-&gt;head_;\nNodeBase* next;\nNodeBase** p_next;\nstd::array&lt;NodeBase**, 64&gt; p_next_stack;\nfor (i32 i = 0; i &lt; new_node_height; ++i) {\np_next_stack[i] = &amp;this-&gt;head_.next_[i];\n}\nwhile (level &gt;= 0) {\np_next = prev-&gt;get_next(level);\nnext = *p_next;\nif (next) {\nBATT_CHECK(next-&gt;key_);\nif (!key_less_than(key_arg, *next-&gt;key_)) {\nif (!key_less_than(*next-&gt;key_, key_arg)) {\n//\n// Keys are equal!\nnode = next;\nnode-&gt;value_.emplace(BATT_FORWARD(value_arg));\nbreak;\n} else {\nprev = next;\ncontinue;\n}\n}\n}\nif (level &lt; new_node_height) {\np_next_stack[level] = p_next;\n}\n--level;\n}\nif (!node) {\nnode = NodeBase::allocate(new_node_height);\nBATT_ASSERT_EQ(node-&gt;height_, new_node_height);\nnode-&gt;key_.emplace(BATT_FORWARD(key_arg));\nnode-&gt;value_.emplace(BATT_FORWARD(value_arg));\nfor (i32 i = 0; i &lt; new_node_height; ++i) {\nBATT_ASSERT_NOT_NULLPTR(p_next_stack[i]);\n*node-&gt;get_next(i) = *p_next_stack[i];\n*p_next_stack[i] = node;\n}\nthis-&gt;active_levels_ |= (u64{1} &lt;&lt; new_node_height) - 1;\nthis-&gt;size_ += 1;\n}\nreturn node;\n}\nvoid check_invariants() const\n{\nfor (i32 level = 0; level &lt; i32(this-&gt;head_.next_.size()); ++level) {\nu64 mask = u64{1} &lt;&lt; level;\nNodeBase* node = this-&gt;head_.next_[level];\nBATT_CHECK_EQ((node != nullptr), ((this-&gt;active_levels_ &amp; mask) != 0))\n&lt;&lt; BATT_INSPECT((void*)node) &lt;&lt; BATT_INSPECT(std::bitset&lt;16&gt;{this-&gt;active_levels_})\n&lt;&lt; BATT_INSPECT(std::bitset&lt;16&gt;{mask}) &lt;&lt; BATT_INSPECT(level);\nOptional&lt;KeyT&gt; prev_key = this-&gt;head_.key_;\nOrderFn key_less_than;\nwhile (node) {\nBATT_CHECK(node-&gt;key_);\nif (prev_key) {\nBATT_CHECK(key_less_than(*prev_key, *node-&gt;key_))\n&lt;&lt; BATT_INSPECT(prev_key) &lt;&lt; BATT_INSPECT(node-&gt;key_);\n}\nBATT_CHECK_GT(node-&gt;height_, level);\nprev_key = node-&gt;key_;\nnode = *node-&gt;get_next(level);\n}\n}\n}\nRng rng_;\nu64 active_levels_;\nNode&lt;64&gt; head_;\nusize size_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename KeyT, typename ValueT, typename OrderFn&gt;\nauto SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;::get_next(i32 level) -&gt; SkipNodeBase**\n{\nauto* node1 = static_cast&lt;SkipNode&lt;KeyT, ValueT, OrderFn, 1&gt;*&gt;(this);\nreturn &amp;node1-&gt;next_[level];\n}\ntemplate &lt;typename KeyT, typename ValueT, typename OrderFn&gt;\nauto SkipNodeBase&lt;KeyT, ValueT, OrderFn&gt;::get_next(i32 level) const -&gt; const SkipNodeBase* const*\n{\nauto* node1 = static_cast&lt;const SkipNode&lt;KeyT, ValueT, OrderFn, 1&gt;*&gt;(this);\nreturn &amp;node1-&gt;next_[level];\n}\n}  //namespace batt\n#endif  // BATTERIES_SKIP_LIST_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/skip__n_8hpp/","title":"batteries/seq/skip_n.hpp","text":""},{"location":"_autogen/Files/skip__n_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/skip__n_8hpp/#classes","title":"Classes","text":"Name struct batt::SkipNBinder class batt::SkipN"},{"location":"_autogen/Files/skip__n_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_SKIP_N_HPP"},{"location":"_autogen/Files/skip__n_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/skip__n_8hpp/#define-batteries_seq_skip_n_hpp","title":"define BATTERIES_SEQ_SKIP_N_HPP","text":"<pre><code>#define BATTERIES_SEQ_SKIP_N_HPP()\n</code></pre>"},{"location":"_autogen/Files/skip__n_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_SKIP_N_HPP\n#define BATTERIES_SEQ_SKIP_N_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// skip(n)\n//\nstruct SkipNBinder {\nusize n;\n};\ninline SkipNBinder skip_n(usize n)\n{\nreturn {n};\n}\ntemplate &lt;typename Seq&gt;\nclass SkipN\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit SkipN(Seq&amp;&amp; seq, usize n) noexcept : seq_(BATT_FORWARD(seq)), n_{n}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (n_ != 0) {\nreturn None;\n}\nreturn seq_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nif (n_ != 0) {\n--n_;\n(void)seq_.next();\nreturn None;\n}\nreturn seq_.next();\n}\nprivate:\nSeq seq_;\nusize n_;\n};\ntemplate &lt;typename Seq, typename = EnableIfSeq&lt;Seq&gt;&gt;\n[[nodiscard]] SkipN&lt;Seq&gt; operator|(Seq&amp;&amp; seq, const SkipNBinder&amp; binder)\n{\nreturn SkipN&lt;Seq&gt;{BATT_FORWARD(seq), binder.n};\n}\n}  // namespace batt\n#endif  // BATTERIES_SEQ_SKIP_N_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/slice_8hpp/","title":"batteries/slice.hpp","text":""},{"location":"_autogen/Files/slice_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/slice_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SLICE_HPP"},{"location":"_autogen/Files/slice_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/slice_8hpp/#define-batteries_slice_hpp","title":"define BATTERIES_SLICE_HPP","text":"<pre><code>#define BATTERIES_SLICE_HPP()\n</code></pre>"},{"location":"_autogen/Files/slice_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SLICE_HPP\n#define BATTERIES_SLICE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/interval.hpp&gt;\n#include &lt;batteries/seq.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/range/begin.hpp&gt;\n#include &lt;boost/range/iterator_range.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nusing Slice = boost::iterator_range&lt;T*&gt;;\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T, typename DataT = decltype(std::declval&lt;T&gt;().data()),\ntypename = std::enable_if_t&lt;std::is_pointer_v&lt;DataT&gt;&gt;,\ntypename ElementT = typename std::pointer_traits&lt;DataT&gt;::element_type&gt;\nSlice&lt;ElementT&gt; as_slice(T&amp;&amp; container)\n{\nreturn Slice&lt;ElementT&gt;{container.data(), container.data() + container.size()};\n}\ntemplate &lt;typename ElementT&gt;\nSlice&lt;ElementT&gt; as_slice(ElementT* begin, ElementT* end)\n{\nreturn Slice&lt;ElementT&gt;{begin, end};\n}\ntemplate &lt;typename ElementT&gt;\nSlice&lt;ElementT&gt; as_slice(ElementT* begin, usize size)\n{\nreturn Slice&lt;ElementT&gt;{begin, begin + size};\n}\ntemplate &lt;typename ElementT&gt;\nSlice&lt;ElementT&gt; as_slice(const Slice&lt;ElementT&gt;&amp; slice)\n{\nreturn slice;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename ElementT&gt;\nSlice&lt;const ElementT&gt; as_const_slice(const ElementT* begin, const ElementT* end)\n{\nreturn Slice&lt;const ElementT&gt;{begin, end};\n}\ntemplate &lt;typename ElementT&gt;\nSlice&lt;const ElementT&gt; as_const_slice(const ElementT* begin, usize size)\n{\nreturn as_const_slice(begin, size);\n}\ntemplate &lt;typename T, typename DataT = decltype(std::declval&lt;const T&amp;&gt;().data()),\ntypename = std::enable_if_t&lt;std::is_pointer_v&lt;DataT&gt;&gt;,\ntypename ElementT = typename std::pointer_traits&lt;DataT&gt;::element_type&gt;\nSlice&lt;const ElementT&gt; as_const_slice(const T&amp; container)\n{\nreturn as_const_slice(container.data(), container.data() + container.size());\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename ElementT&gt;\nSlice&lt;ElementT&gt; empty_slice(StaticType&lt;ElementT&gt; = {})\n{\nstatic std::aligned_storage_t&lt;sizeof(ElementT), alignof(ElementT)&gt; storage_;\nreturn as_slice(reinterpret_cast&lt;ElementT*&gt;(&amp;storage_), 0);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T&gt;\nSubRangeSeq&lt;Slice&lt;T&gt;&gt; as_seq(const Slice&lt;T&gt;&amp; s)\n{\nreturn SubRangeSeq&lt;Slice&lt;T&gt;&gt;{batt::make_copy(s)};\n}\ntemplate &lt;typename T&gt;\nauto as_seq(Slice&lt;T&gt;&amp; s)\n{\nreturn as_seq(const_cast&lt;const Slice&lt;T&gt;&amp;&gt;(s));\n}\ntemplate &lt;typename T&gt;\nauto as_seq(Slice&lt;T&gt;&amp;&amp; s)\n{\nreturn as_seq(const_cast&lt;const Slice&lt;T&gt;&amp;&gt;(s));\n}\ntemplate &lt;typename T&gt;\nauto as_seq(const Slice&lt;T&gt;&amp;&amp; s)\n{\nreturn as_seq(const_cast&lt;const Slice&lt;T&gt;&amp;&gt;(s));\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename Iter&gt;\nboost::iterator_range&lt;Iter&gt; as_range(const std::pair&lt;Iter, Iter&gt;&amp; p)\n{\nreturn boost::make_iterator_range(p.first, p.second);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename RangeT, typename Iter = std::decay_t&lt;decltype(boost::begin(std::declval&lt;RangeT&gt;()))&gt;,\ntypename OffsetT, typename = std::enable_if_t&lt;std::is_integral_v&lt;OffsetT&gt;&gt;&gt;\nboost::iterator_range&lt;Iter&gt; slice_range(RangeT&amp;&amp; range, const Interval&lt;OffsetT&gt;&amp; i)\n{\nreturn boost::make_iterator_range(std::next(boost::begin(range), i.lower_bound),\nstd::next(boost::begin(range), i.upper_bound));\n}\n}  // namespace batt\n#endif  // BATTERIES_SLICE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/slice__work_8cpp/","title":"batteries/async/slice_work.cpp","text":""},{"location":"_autogen/Files/slice__work_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;batteries/async/slice_work_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/slice__work_8hpp/","title":"batteries/async/slice_work.hpp","text":""},{"location":"_autogen/Files/slice__work_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/slice__work_8hpp/#classes","title":"Classes","text":"Name struct batt::WorkSliceParams struct batt::WorkSlicePlan"},{"location":"_autogen/Files/slice__work_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SLICE_WORK_HPP"},{"location":"_autogen/Files/slice__work_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/slice__work_8hpp/#define-batteries_async_slice_work_hpp","title":"define BATTERIES_ASYNC_SLICE_WORK_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SLICE_WORK_HPP()\n</code></pre>"},{"location":"_autogen/Files/slice__work_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SLICE_WORK_HPP\n#define BATTERIES_ASYNC_SLICE_WORK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\n#include &lt;algorithm&gt;\nnamespace batt {\nBATT_STRONG_TYPEDEF(usize, TaskCount);\nBATT_STRONG_TYPEDEF(usize, InputSize);\nBATT_STRONG_TYPEDEF(usize, TaskSize);\nBATT_STRONG_TYPEDEF(usize, TaskIndex);\nBATT_STRONG_TYPEDEF(isize, TaskOffset);\ntemplate &lt;typename Iter&gt;\ninline InputSize get_input_size(const Iter&amp; first, const Iter&amp; last)\n{\nBATT_CHECK_LE(first, last);\nreturn InputSize{static_cast&lt;usize&gt;(std::distance(first, last))};\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Parameters that control the formation of a work-slicing plan (WorkSlicePlan).\n//\nstruct WorkSliceParams {\n// This isn't too meaningful, as it is a unitless quantity, but supposing it is number of bytes to be\n// loaded from memory, we define this as a half kilobyte as a \"safe\" lower bound on how small an amount of\n// data can be transferred to a CPU for processing, without being so small as to not be worth it.\n//\nstatic constexpr TaskSize kDefaultMinTaskSize{512};\n// Returns reasonable defaults for slicing work to be performed by the given WorkerPool.\n//\nstatic WorkSliceParams from_worker_pool(WorkerPool&amp; worker_pool)\n{\nreturn WorkSliceParams{\n.min_task_size = WorkSliceParams::kDefaultMinTaskSize,\n.max_tasks = TaskCount{worker_pool.size() + 1},\n};\n}\n// The minimum size to assign to a task (slice).  This depends on the round-trip communication latency\n// within a WorkerPool and the cost of the computation to be performed on a given amount of input.  Too\n// small and we spend more time transferring data than doing useful work (it would have been cheaper just\n// to do it locally); too large and we may under-utilize compute resources.\n//\nTaskSize min_task_size;\n// The maximum number of slices (tasks) to create for parallel execution.  This is informed by the amount\n// of independent execution resources available and the expected variance in cost between work slices.\n//\nTaskCount max_tasks;\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const WorkSliceParams&amp; t);\n// Apply the given WorkSliceParams to the given InputSize to produce a target TaskSize.\n//\n// The returned value must not be smaller than `params.min_task_size` and large enough so that `input_size /\n// task_size &lt;= params.max_tasks`.\n//\ninline TaskSize get_task_size(const WorkSliceParams&amp; params, InputSize input_size)\n{\nBATT_CHECK_GT(params.max_tasks, 0u);\nBATT_CHECK_GT(params.min_task_size, 0u);\nreturn TaskSize{\nstd::max&lt;usize&gt;(params.min_task_size, (input_size + params.max_tasks - 1) / params.max_tasks)};\n}\ninline TaskCount get_task_count(InputSize input_size, TaskSize task_size)\n{\nBATT_CHECK_GT(task_size, 0u);\nreturn TaskCount{(input_size + task_size - 1) / task_size};\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// An abstract plan for slicing up some amount of work into smaller tasks of roughly equal size that can\n// be executed in parallel.\n//\nstruct WorkSlicePlan {\nexplicit WorkSlicePlan(const WorkSliceParams&amp; params, InputSize input_size) noexcept;\ntemplate &lt;typename Iter&gt;\nexplicit WorkSlicePlan(const WorkSliceParams&amp; params, const Iter&amp; first, const Iter&amp; last) noexcept;\n// A metric on the total amount of work to be done.\n//\nInputSize input_size;\n// The target amount of `input_size` to be apportioned to each task.\n//\nTaskSize task_size;\n// The target number of tasks (slices) into which to divide the overall work.\n//\nTaskCount n_tasks;\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const WorkSlicePlan&amp; t);\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Divide an input range into equal sized pieces and schedule work tasks for each by invoking the\n// WorkFnGenerator.  The final task is run on the calling thread.\n//\n// `WorkFnGenerator`: auto(usize task_index, isize task_offset, isize task_size) -&gt; void()\n//\ntemplate &lt;typename WorkFnGenerator&gt;\nStatus slice_work(WorkContext&amp; context, const WorkSlicePlan&amp; plan, WorkFnGenerator&amp;&amp; gen_work_fn)\n{\nif (plan.input_size == 0) {\nreturn OkStatus();\n}\nBATT_CHECK_GT(plan.n_tasks, 0);\nBATT_CHECK_GT(plan.task_size, 0);\nusize task_index = 0;\nisize task_offset = 0;\nusize input_remaining = plan.input_size;\nwhile (input_remaining &gt; 0) {\nconst usize this_task_size = std::min&lt;usize&gt;(input_remaining, plan.task_size);\nauto work_fn = gen_work_fn(TaskIndex{task_index}, TaskOffset{task_offset}, TaskSize{this_task_size});\ntask_index += 1;\ntask_offset += this_task_size;\ninput_remaining -= this_task_size;\nif (task_index == plan.n_tasks) {\nwork_fn();\n} else {\nBATT_REQUIRE_OK(context.async_run(BATT_FORWARD(work_fn)));\n}\n}\nBATT_CHECK_EQ(task_index, plan.n_tasks);\nreturn OkStatus();\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_SLICE_WORK_HPP\n#include &lt;batteries/async/slice_work.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/slice_work_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/slice__work__impl_8hpp/","title":"batteries/async/slice_work_impl.hpp","text":""},{"location":"_autogen/Files/slice__work__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/slice__work__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP"},{"location":"_autogen/Files/slice__work__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/slice__work__impl_8hpp/#define-batteries_async_slice_work_impl_hpp","title":"define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/slice__work__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP\n#define BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/slice_work.hpp&gt;\n#include &lt;ostream&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const WorkSliceParams&amp; t)\n{\nreturn out &lt;&lt; \"WorkSliceParams{.min_task_size=\" &lt;&lt; t.min_task_size &lt;&lt; \", .max_tasks=\" &lt;&lt; t.max_tasks\n&lt;&lt; \",}\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ WorkSlicePlan::WorkSlicePlan(const WorkSliceParams&amp; params,\nInputSize input_size) noexcept\n: input_size{input_size}\n, task_size{get_task_size(params, this-&gt;input_size)}\n, n_tasks{get_task_count(this-&gt;input_size, this-&gt;task_size)}\n{\nBATT_CHECK_GE(this-&gt;task_size, params.min_task_size) &lt;&lt; BATT_INSPECT(*this) &lt;&lt; BATT_INSPECT(params);\nBATT_CHECK_LE(this-&gt;n_tasks, params.max_tasks) &lt;&lt; BATT_INSPECT(*this) &lt;&lt; BATT_INSPECT(params);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const WorkSlicePlan&amp; t)\n{\nreturn out &lt;&lt; \"WorkSlicePlan{.input_size=\" &lt;&lt; t.input_size &lt;&lt; \", .task_size=\" &lt;&lt; t.task_size\n&lt;&lt; \", .n_tasks=\" &lt;&lt; t.n_tasks &lt;&lt; \",}\";\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_SLICE_WORK_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/small__fn_8hpp/","title":"batteries/small_fn.hpp","text":""},{"location":"_autogen/Files/small__fn_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/small__fn_8hpp/#classes","title":"Classes","text":"Name class batt::detail::AbstractMoveFn class batt::detail::AbstractCopyFn class batt::detail::MoveFnImpl class batt::detail::CopyFnImpl class batt::detail::AllocFnWrapper class batt::kAllowAlloc"},{"location":"_autogen/Files/small__fn_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SMALL_FUNCTION_HPP BATT_REQUIRE_COPYABLE BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual) BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual)"},{"location":"_autogen/Files/small__fn_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/small__fn_8hpp/#define-batteries_small_function_hpp","title":"define BATTERIES_SMALL_FUNCTION_HPP","text":"<pre><code>#define BATTERIES_SMALL_FUNCTION_HPP()\n</code></pre>"},{"location":"_autogen/Files/small__fn_8hpp/#define-batt_require_copyable","title":"define BATT_REQUIRE_COPYABLE","text":"<pre><code>#define BATT_REQUIRE_COPYABLE()\n</code></pre>"},{"location":"_autogen/Files/small__fn_8hpp/#define-batt_small_fn_construct_move_only_from_copy","title":"define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY","text":"<pre><code>#define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual)\n</code></pre>"},{"location":"_autogen/Files/small__fn_8hpp/#define-batt_small_fn_assign_move_only_from_copy","title":"define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY","text":"<pre><code>#define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual)\n</code></pre>"},{"location":"_autogen/Files/small__fn_8hpp/#source-code","title":"Source code","text":"<pre><code>//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SMALL_FUNCTION_HPP\n#define BATTERIES_SMALL_FUNCTION_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/static_assert.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename Signature,                                  //\nusize kMaxSize = kCpuCacheLineSize - sizeof(void*),  //\nbool kMoveOnly = false,                              //\nbool kAllowAlloc = false&gt;\nclass SmallFn;\ntemplate &lt;typename Signature, usize kMaxSize = kCpuCacheLineSize - sizeof(void*), bool kAllowAlloc = false&gt;\nusing UniqueSmallFn = SmallFn&lt;Signature, kMaxSize, /*kMoveOnly=*/true, kAllowAlloc&gt;;\nnamespace detail {\n// Forward declare the abstract base class templates for function type erasure.\n//\ntemplate &lt;bool kMoveOnly, typename Result, typename... Args&gt;\nclass AbstractMoveFn;\ntemplate &lt;typename Result, typename... Args&gt;\nclass AbstractCopyFn;\n// Templated alias for the type-erased function interface; kMoveOnly controls\n// whether copy semantics are enabled.\n//\ntemplate &lt;bool kMoveOnly, typename Result, typename... Args&gt;\nusing AbstractFn =\nstd::conditional_t&lt;kMoveOnly, AbstractMoveFn&lt;true, Result, Args...&gt;, AbstractCopyFn&lt;Result, Args...&gt;&gt;;\n// Forward declare the implementation class templates for function type erasure.\n//\ntemplate &lt;typename Fn, bool kMoveOnly, typename Result, typename... Args&gt;\nclass MoveFnImpl;\ntemplate &lt;typename Fn, typename Result, typename... Args&gt;\nclass CopyFnImpl;\ntemplate &lt;typename Fn, bool kMoveOnly, typename Result, typename... Args&gt;\nusing FnImpl = std::conditional_t&lt;kMoveOnly, MoveFnImpl&lt;Fn, kMoveOnly, Result, Args...&gt;,\nCopyFnImpl&lt;Fn, Result, Args...&gt;&gt;;\n// Base class for abstract function types.  Defines the common\n// interface/concept for move-only and copyable functions:\n// - Invocable (with the signature `auto(Args...)-&gt;Result`)\n// - Move-Constructible/Assignable\n// - Destructible\n//\ntemplate &lt;bool kMoveOnly, typename Result, typename... Args&gt;\nclass AbstractMoveFn\n{\nprotected:\nAbstractMoveFn() = default;\npublic:\nAbstractMoveFn(const AbstractMoveFn&amp;) = delete;\nAbstractMoveFn&amp; operator=(const AbstractMoveFn&amp;) = delete;\nvirtual ~AbstractMoveFn() = default;\nvirtual auto invoke(Args... args) noexcept -&gt; Result = 0;\n// Move construct from `this` into `storage`.  `size` MUST be big enough to\n// fit the stored function, otherwise this method will assert-crash.\n// Invalidates `this`; `invoke` must not be called after `move`.\n//\nvirtual auto move(void* storage, usize size) noexcept -&gt; AbstractFn&lt;kMoveOnly, Result, Args...&gt;* = 0;\n};\n// Adds copy semantics to the basic type-erased concept.\n//\ntemplate &lt;typename Result, typename... Args&gt;\nclass AbstractCopyFn : public AbstractMoveFn&lt;false, Result, Args...&gt;\n{\npublic:\nusing AbstractMoveFn&lt;false, Result, Args...&gt;::AbstractMoveFn;\n// Copy construct from `this` into `storage`.  `size` MUST be big enough to\n// fit the stored function, otherwise this method will assert-crash.\n//\nvirtual auto copy(void* memory, usize size) const noexcept -&gt; AbstractFn&lt;false, Result, Args...&gt;* = 0;\n// Same as `copy`, but the returned type-erased object drops the ability to\n// copy in favor of a move-only interface.\n//\nvirtual auto copy_to_move_only(void* memory,\nusize size) const noexcept -&gt; AbstractFn&lt;true, Result, Args...&gt;* = 0;\n};\n// Implements the basic concept; can be extended because `fn_` is protected,\n// not private.\n//\ntemplate &lt;typename Fn, bool kMoveOnly, typename Result, typename... Args&gt;\nclass MoveFnImpl : public AbstractFn&lt;kMoveOnly, Result, Args...&gt;\n{\npublic:\nusing self_type = MoveFnImpl;\ntemplate &lt;typename FnRef&gt;\nexplicit MoveFnImpl(FnRef&amp;&amp; ref) : fn_(BATT_FORWARD(ref))\n{\n}\nResult invoke(Args... args) noexcept override\n{\nreturn fn_(BATT_FORWARD(args)...);\n}\nAbstractFn&lt;kMoveOnly, Result, Args...&gt;* move(void* memory, usize size) noexcept override\n{\nBATT_CHECK_LE(sizeof(self_type), size);\nreturn new (memory) FnImpl&lt;Fn, kMoveOnly, Result, Args...&gt;(std::move(fn_));\n}\nprotected:\nFn fn_;\n};\n// Extends MoveFnImpl to implement copy semantics in terms of the concrete\n// type `Fn`.\n//\ntemplate &lt;typename Fn, typename Result, typename... Args&gt;\nclass CopyFnImpl : public MoveFnImpl&lt;Fn, /*kMoveOnly=*/false, Result, Args...&gt;\n{\npublic:\nusing self_type = CopyFnImpl;\nusing MoveFnImpl&lt;Fn, /*kMoveOnly=*/false, Result, Args...&gt;::MoveFnImpl;\nAbstractFn&lt;false, Result, Args...&gt;* copy(void* memory, usize size) const noexcept override\n{\nBATT_CHECK_LE(sizeof(self_type), size);\nreturn new (memory) FnImpl&lt;Fn, /*kMoveOnly=*/false, Result, Args...&gt;(this-&gt;fn_);\n}\nAbstractFn&lt;true, Result, Args...&gt;* copy_to_move_only(void* memory, usize size) const noexcept override\n{\nBATT_CHECK_LE(sizeof(self_type), size);\nreturn new (memory) FnImpl&lt;Fn, /*kMoveOnly=*/true, Result, Args...&gt;(this-&gt;fn_);\n}\n};\n// Wraps an arbitrary callable of type Fn, using dynamic allocation to maintain fixed, small size.\n//\ntemplate &lt;typename Fn, bool kMoveOnly, typename Result, typename... Args&gt;\nclass AllocFnWrapper\n{\npublic:\nusing Self = AllocFnWrapper;\nusing Pointer = std::conditional_t&lt;kMoveOnly, std::unique_ptr&lt;Fn&gt;, std::shared_ptr&lt;Fn&gt;&gt;;\nstatic constexpr std::integral_constant&lt;bool, kMoveOnly&gt; move_only = {};\n//----- --- -- -  -  -   -\ntemplate &lt;typename... FnInit&gt;\nstatic Pointer wrap_fn(std::true_type /*move_only*/, FnInit&amp;&amp;... init)\n{\nreturn std::make_unique&lt;Fn&gt;(BATT_FORWARD(init)...);\n}\ntemplate &lt;typename... FnInit&gt;\nstatic Pointer wrap_fn(std::false_type /*move_only*/, FnInit&amp;&amp;... init)\n{\nreturn std::make_shared&lt;Fn&gt;(BATT_FORWARD(init)...);\n}\n//----- --- -- -  -  -   -\ntemplate &lt;typename... FnInit&gt;\nexplicit AllocFnWrapper(FnInit&amp;&amp;... init) : p_fn_{Self::wrap_fn(move_only, BATT_FORWARD(init)...)}\n{\n}\nAllocFnWrapper(const AllocFnWrapper&amp;) = default;\nAllocFnWrapper&amp; operator=(const AllocFnWrapper&amp;) = default;\nAllocFnWrapper(AllocFnWrapper&amp;&amp;) = default;\nAllocFnWrapper&amp; operator=(AllocFnWrapper&amp;&amp;) = default;\nResult operator()(Args... args) const\n{\nreturn (*this-&gt;p_fn_)(BATT_FORWARD(args)...);\n}\n//----- --- -- -  -  -   -\nprivate:\nPointer p_fn_;\n};\n}  // namespace detail\ntemplate &lt;typename... Args, typename Result, usize kMaxSize, bool kMoveOnly, bool kAllowAlloc&gt;\nclass SmallFn&lt;auto(Args...)-&gt;Result, kMaxSize, kMoveOnly, kAllowAlloc&gt;\n{\ntemplate &lt;typename, usize, bool, bool&gt;\nfriend class SmallFn;\n// The type-erased interface to use, depending on the value of `kMoveOnly`.\n//\nusing AbstractFn = detail::AbstractFn&lt;kMoveOnly, Result, Args...&gt;;\n// The concrete type erasure, depending on the value of `kMoveOnly`.\n//\ntemplate &lt;typename Fn&gt;\nusing NoAllocFnImpl = detail::FnImpl&lt;Fn, kMoveOnly, Result, Args...&gt;;\n// The wrapped function type, if Fn is too large to avoid dynamic allocation.\n//\ntemplate &lt;typename Fn&gt;\nusing AllocFnImpl =\ndetail::FnImpl&lt;detail::AllocFnWrapper&lt;Fn, kMoveOnly, Result, Args...&gt;, kMoveOnly, Result, Args...&gt;;\ntemplate &lt;typename Fn&gt;\nusing FnImpl = std::conditional_t&lt;                                          //\n(!kAllowAlloc || sizeof(NoAllocFnImpl&lt;std::decay_t&lt;Fn&gt;&gt;) &lt;= kMaxSize),  //\nNoAllocFnImpl&lt;Fn&gt;, AllocFnImpl&lt;Fn&gt;&gt;;\n#define BATT_REQUIRE_COPYABLE static_assert(!kMoveOnly, \"This kind of SmallFn is move-only!\")\ntemplate &lt;typename Fn&gt;\nstatic auto check_fn_size(Fn&amp;&amp; fn) -&gt; Fn&amp;&amp;\n{\nBATT_STATIC_ASSERT_LE(sizeof(FnImpl&lt;std::decay_t&lt;Fn&gt;&gt;),\nkMaxSize);  // \"Passed function is not small!\"\nreturn BATT_FORWARD(fn);\n}\npublic:\nusing self_type = SmallFn&lt;auto(Args...)-&gt;Result, kMaxSize, kMoveOnly, kAllowAlloc&gt;;\nusing result_type = Result;\nSmallFn() = default;\ntemplate &lt;typename Fn, typename = EnableIfNoShadow&lt;self_type, Fn&gt;,\ntypename = std::enable_if_t&lt;IsCallable&lt;Fn, Args...&gt;{}&gt;&gt;\nSmallFn(Fn&amp;&amp; fn) noexcept\n: impl_{new(&amp;storage_) FnImpl&lt;std::decay_t&lt;Fn&gt;&gt;(check_fn_size(BATT_FORWARD(fn)))}\n{\n}\nSmallFn(self_type&amp;&amp; that) noexcept\n: impl_{[&amp;] {\nauto impl =\nBATT_HINT_TRUE(that.impl_ != nullptr) ? that.impl_-&gt;move(&amp;storage_, kMaxSize) : nullptr;\nthat.clear();\nreturn impl;\n}()}\n{\n}\nSmallFn(const self_type&amp; that) noexcept\n: impl_{[&amp;] {\nBATT_REQUIRE_COPYABLE;\nreturn BATT_HINT_TRUE(that.impl_ != nullptr) ? that.impl_-&gt;copy(&amp;storage_, kMaxSize) : nullptr;\n}()}\n{\n}\n#define BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(cv_qual)                                                 \\\n    template &lt;usize kThatSize, typename = std::enable_if_t&lt;kThatSize &lt;= kMaxSize &amp;&amp; kMoveOnly&gt;&gt;              \\\n    SmallFn(cv_qual SmallFn&lt;Result(Args...), kThatSize, /*kMoveOnly=*/false&gt;&amp; that) noexcept                 \\\n        : impl_{that.impl_-&gt;copy_to_move_only(&amp;storage_, kMaxSize)}                                          \\\n    {                                                                                                        \\\n    }\nBATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(BATT_EXPANDS_TO_NOTHING)\nBATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY(const)\n#undef BATT_SMALL_FN_CONSTRUCT_MOVE_ONLY_FROM_COPY\n~SmallFn() noexcept\n{\nclear();\n}\nauto clear() noexcept -&gt; void\n{\nif (BATT_HINT_TRUE(impl_ != nullptr)) {\nimpl_-&gt;~AbstractFn();\nimpl_ = nullptr;\n}\n}\nauto operator=(std::nullptr_t) noexcept -&gt; self_type&amp;\n{\nthis-&gt;clear();\nreturn *this;\n}\ntemplate &lt;typename Fn, typename = EnableIfNoShadow&lt;SmallFn, Fn&gt;&gt;\nauto operator=(Fn&amp;&amp; fn) noexcept -&gt; self_type&amp;\n{\nclear();\nFn&amp;&amp; checked_fn = check_fn_size(std::forward&lt;Fn&gt;(fn));\nimpl_ = new (&amp;storage_) FnImpl&lt;std::decay_t&lt;Fn&gt;&gt;(std::forward&lt;Fn&gt;(checked_fn));\nreturn *this;\n}\nauto operator=(self_type&amp;&amp; that) noexcept -&gt; self_type&amp;\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nclear();\nimpl_ = BATT_HINT_TRUE(that.impl_ != nullptr) ? that.impl_-&gt;move(&amp;storage_, kMaxSize) : nullptr;\nthat.clear();\n}\nreturn *this;\n}\nauto operator=(const self_type&amp; that) noexcept -&gt; self_type&amp;\n{\nBATT_REQUIRE_COPYABLE;\nif (BATT_HINT_TRUE(this != &amp;that)) {\nclear();\nimpl_ = BATT_HINT_TRUE(that.impl_ != nullptr) ? that.impl_-&gt;copy(&amp;storage_, kMaxSize) : nullptr;\n}\nreturn *this;\n}\n#define BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(cv_qual)                                                    \\\n    template &lt;usize kThatSize, typename = std::enable_if_t&lt;kThatSize &lt;= kMaxSize &amp;&amp; kMoveOnly&gt;&gt;              \\\n    auto operator=(cv_qual SmallFn&lt;Result(Args...), kThatSize, false&gt;&amp; that) noexcept -&gt; self_type&amp;          \\\n    {                                                                                                        \\\n        clear();                                                                                             \\\n        impl_ = that.impl_-&gt;copy_to_move_only(&amp;storage_, kMaxSize);                                          \\\n                                                                                                             \\\n        return *this;                                                                                        \\\n    }\nBATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(BATT_EXPANDS_TO_NOTHING)\nBATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY(const)\n#undef BATT_SMALL_FN_ASSIGN_MOVE_ONLY_FROM_COPY\nexplicit operator bool() const noexcept\n{\nreturn impl_ != nullptr;\n}\nauto operator()(Args... args) const -&gt; Result\n{\nBATT_ASSERT_NOT_NULLPTR(impl_);\nreturn impl_-&gt;invoke(BATT_FORWARD(args)...);\n}\nprivate:\nstd::aligned_storage_t&lt;kMaxSize&gt; storage_;  // must come before `impl_`\nAbstractFn* impl_ = nullptr;\n#undef BATT_REQUIRE_COPYABLE\n};  // class SmallFn\n}  // namespace batt\n#endif  // BATTERIES_SMALL_FUNCTION_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/small__vec_8hpp/","title":"batteries/small_vec.hpp","text":""},{"location":"_autogen/Files/small__vec_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/small__vec_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SMALL_VEC_HPP"},{"location":"_autogen/Files/small__vec_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/small__vec_8hpp/#define-batteries_small_vec_hpp","title":"define BATTERIES_SMALL_VEC_HPP","text":"<pre><code>#define BATTERIES_SMALL_VEC_HPP()\n</code></pre>"},{"location":"_autogen/Files/small__vec_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SMALL_VEC_HPP\n#define BATTERIES_SMALL_VEC_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nBATT_SUPPRESS_IF_GCC(\"-Wmaybe-uninitialized\")\n//\n#include &lt;boost/container/detail/advanced_insert_int.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_GCC()\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n#include &lt;boost/container/small_vector.hpp&gt;\n#include &lt;string_view&gt;\nnamespace batt {\nconstexpr usize kDefaultSmallVecSize = 4;\ntemplate &lt;typename T, usize kStaticSize = kDefaultSmallVecSize&gt;\nusing SmallVec = boost::container::small_vector&lt;T, kStaticSize&gt;;\ntemplate &lt;typename T&gt;\nusing SmallVecBase = boost::container::small_vector_base&lt;T&gt;;\ninline void copy_string(SmallVecBase&lt;char&gt;&amp; dst, const std::string_view&amp; src)\n{\ndst.assign(src.data(), src.data() + src.size());\n}\ninline std::string_view as_str(const SmallVecBase&lt;char&gt;&amp; v)\n{\nreturn std::string_view{v.data(), v.size()};\n}\n}  // namespace batt\n#endif  // BATTERIES_SMALL_VEC_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/spin__grant_8cpp/","title":"batteries/async/spin_grant.cpp","text":""},{"location":"_autogen/Files/spin__grant_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023-2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/spin_grant.hpp&gt;\n//\n#include &lt;batteries/async/spin_grant_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/spin__grant_8hpp/","title":"batteries/async/spin_grant.hpp","text":""},{"location":"_autogen/Files/spin__grant_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SPIN_GRANT_HPP"},{"location":"_autogen/Files/spin__grant_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/spin__grant_8hpp/#define-batteries_async_spin_grant_hpp","title":"define BATTERIES_ASYNC_SPIN_GRANT_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SPIN_GRANT_HPP()\n</code></pre>"},{"location":"_autogen/Files/spin__grant_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SPIN_GRANT_HPP\n#define BATTERIES_ASYNC_SPIN_GRANT_HPP\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/spin_grant_decl.hpp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/spin_grant_impl.hpp&gt;\n#endif\n#endif  // BATTERIES_ASYNC_SPIN_GRANT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/spin__grant__decl_8hpp/","title":"batteries/async/spin_grant_decl.hpp","text":""},{"location":"_autogen/Files/spin__grant__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/spin__grant__decl_8hpp/#classes","title":"Classes","text":"Name class batt::SpinGrant A claim on some counted resource. class batt::SpinGrant::Issuer A pool from which SpinGrant instances are allocated."},{"location":"_autogen/Files/spin__grant__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SPIN_GRANT_DECL_HPP"},{"location":"_autogen/Files/spin__grant__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/spin__grant__decl_8hpp/#define-batteries_async_spin_grant_decl_hpp","title":"define BATTERIES_ASYNC_SPIN_GRANT_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SPIN_GRANT_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/spin__grant__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SPIN_GRANT_DECL_HPP\n#define BATTERIES_ASYNC_SPIN_GRANT_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/types.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/pointers.hpp&gt;\n#include &lt;atomic&gt;\nnamespace batt {\nclass SpinGrant\n{\npublic:\nclass Issuer\n{\nfriend class SpinGrant;\npublic:\nIssuer() = default;\nexplicit Issuer(u64 initial_count) noexcept;\nIssuer(const Issuer&amp;) = delete;\nIssuer&amp; operator=(const Issuer&amp;) = delete;\n~Issuer() noexcept;\nStatusOr&lt;SpinGrant&gt; issue_grant(u64 count, WaitForResource wait_for_resource);\nvoid grow(u64 count);\nvoid close();\nu64 available() const noexcept\n{\nreturn this-&gt;available_.get_value();\n}\nu64 total_size() const noexcept\n{\nreturn this-&gt;total_size_.load();\n}\nprivate:\nvoid recycle(u64 count);\nWatch&lt;u64&gt; available_{0};\nstd::atomic&lt;u64&gt; total_size_{0};\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//----- --- -- -  -  -   -\n// (SpinGrant has no default constructor; you must create a new one by calling\n// SpinGrant::Issuer::issue_grant or by spending part of an existing SpinGrant.  This guarantees that a\n// SpinGrant is never detached from a SpinGrant::Issuer unless it has gone out of scope via move, which is\n// equivalent to destruction.)\n//----- --- -- -  -  -   -\nSpinGrant(const SpinGrant&amp;) = delete;\nSpinGrant&amp; operator=(const SpinGrant&amp;) = delete;\nSpinGrant(SpinGrant&amp;&amp; that) noexcept;\nSpinGrant&amp; operator=(SpinGrant&amp;&amp;) = delete;\n~SpinGrant() noexcept;\n//----- --- -- -  -  -   -\nconst Issuer* get_issuer() const\n{\nreturn this-&gt;issuer_.get();\n}\nbool empty() const\n{\nreturn this-&gt;size() == 0;\n}\nexplicit operator bool() const\n{\nreturn this-&gt;is_valid();\n}\nbool is_valid() const\n{\nreturn this-&gt;size() != 0 &amp;&amp; this-&gt;issuer_;\n}\nbool is_revoked() const\n{\nreturn this-&gt;size_.is_closed();\n}\n//----- --- -- -  -  -   -\n// All of the following public methods are thread-safe with respect to each other; they MUST NOT be called\n// concurrent to:\n//  - `SpinGrant::~SpinGrant()`\n//  - `SpinGrant other = std::move(*this);`\n//----- --- -- -  -  -   -\nvoid revoke();\nu64 size() const;\nStatusOr&lt;SpinGrant&gt; spend(u64 count, WaitForResource wait_for_resource = WaitForResource::kFalse);\nu64 spend_all();\nSpinGrant&amp; subsume(SpinGrant&amp;&amp; that);\nvoid swap(SpinGrant&amp; that);\nprivate:\nstatic StatusOr&lt;SpinGrant&gt; transfer_impl(SpinGrant::Issuer* issuer, Watch&lt;u64&gt;&amp; source, u64 count,\nWaitForResource wait_for_resource);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit SpinGrant(Issuer* issuer, u64 size) noexcept;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// This field *must not* change after it is initialized.\n//\nUniqueNonOwningPtr&lt;Issuer&gt; issuer_;\n// The size of this SpinGrant.\n//\nWatch&lt;u64&gt; size_{0};\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const SpinGrant&amp; t)\n{\nreturn out &lt;&lt; \"Grant{.size=\" &lt;&lt; t.size() &lt;&lt; \",}\";\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_GRANT_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/spin__grant__impl_8hpp/","title":"batteries/async/spin_grant_impl.hpp","text":""},{"location":"_autogen/Files/spin__grant__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/spin__grant__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_SPIN_GRANT_IMPL_HPP"},{"location":"_autogen/Files/spin__grant__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/spin__grant__impl_8hpp/#define-batteries_async_spin_grant_impl_hpp","title":"define BATTERIES_ASYNC_SPIN_GRANT_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_SPIN_GRANT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/spin__grant__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_SPIN_GRANT_IMPL_HPP\n#define BATTERIES_ASYNC_SPIN_GRANT_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SpinGrant::Issuer::Issuer(u64 initial_count) noexcept\n: available_{initial_count}\n, total_size_{initial_count}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SpinGrant::Issuer::~Issuer() noexcept\n{\nBATT_CHECK_EQ(this-&gt;total_size_.load(), this-&gt;available_.get_value())\n&lt;&lt; \"This may indicate a Grant is still active!\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;SpinGrant&gt; SpinGrant::Issuer::issue_grant(u64 count,\nWaitForResource wait_for_resource)\n{\nBATT_DEBUG_INFO(\"[SpinGrant::Issuer::issue_grant]\");\nreturn transfer_impl(/*issuer=*/this, /*source=*/this-&gt;available_, /*count=*/count,\n/*wait_for_resource=*/wait_for_resource);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SpinGrant::Issuer::grow(u64 count)\n{\n[[maybe_unused]] const u64 old_size = this-&gt;total_size_.fetch_add(count);\nBATT_ASSERT_GT(u64{old_size + count}, old_size) &lt;&lt; \"Integer overflow detected!\";\nthis-&gt;recycle(count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SpinGrant::Issuer::recycle(u64 count)\n{\nthis-&gt;available_.fetch_add(count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SpinGrant::Issuer::close()\n{\nthis-&gt;available_.close();\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SpinGrant::SpinGrant(Issuer* issuer, u64 size) noexcept : issuer_{issuer}, size_{size}\n{\nBATT_CHECK_NOT_NULLPTR(issuer);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SpinGrant::SpinGrant(SpinGrant&amp;&amp; that) noexcept\n: issuer_{std::move(that.issuer_)}\n, size_{that.size_.set_value(0)}\n{\nBATT_CHECK_EQ(that.issuer_, nullptr);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SpinGrant::~SpinGrant() noexcept\n{\nthis-&gt;revoke();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SpinGrant::revoke()\n{\nthis-&gt;spend_all();\nthis-&gt;size_.close();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SpinGrant::swap(SpinGrant&amp; that)\n{\nstd::swap(this-&gt;issuer_, that.issuer_);\nthat.size_.set_value(this-&gt;size_.set_value(that.size_.set_value(0)));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL u64 SpinGrant::size() const\n{\nreturn this-&gt;size_.get_value();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;SpinGrant&gt; SpinGrant::spend(u64 count, WaitForResource wait_for_resource)\n{\nreturn transfer_impl(/*issuer=*/this-&gt;issuer_.get(), /*source=*/this-&gt;size_, /*count=*/count,\n/*wait_for_resource=*/wait_for_resource);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL u64 SpinGrant::spend_all()\n{\nif (!this-&gt;issuer_) {\nreturn 0;\n}\nconst u64 previous_size = this-&gt;size_.set_value(0);\nthis-&gt;issuer_-&gt;recycle(previous_size);\nreturn previous_size;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL SpinGrant&amp; SpinGrant::subsume(SpinGrant&amp;&amp; that)\n{\nif (!that.issuer_) {\nreturn *this;\n}\nBATT_CHECK_NOT_NULLPTR(this-&gt;issuer_) &lt;&lt; \"It is NOT legal to subsume a Grant into an invalidated Grant.\";\nBATT_CHECK_EQ(this-&gt;issuer_, that.issuer_);\nconst u64 count = that.size_.set_value(0);\nthis-&gt;size_.fetch_add(count);\nreturn *this;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ StatusOr&lt;SpinGrant&gt; SpinGrant::transfer_impl(SpinGrant::Issuer* issuer,\nWatch&lt;u64&gt;&amp; source, u64 count,\nWaitForResource wait_for_resource)\n{\nif (issuer == nullptr) {\nreturn {StatusCode::kFailedPrecondition};\n}\nfor (;;) {\nBATT_DEBUG_INFO(\"[SpinGrant::transfer_impl] count=\"\n&lt;&lt; count &lt;&lt; \" wait_for_resource=\" &lt;&lt; (bool)wait_for_resource\n&lt;&lt; \" available=\" &lt;&lt; source.get_value() &lt;&lt; \" of total=\" &lt;&lt; issuer-&gt;total_size());\nconst Optional&lt;u64&gt; pre_transfer_count = source.modify_if([count](u64 observed) -&gt; Optional&lt;u64&gt; {\nif (observed &gt;= count) {\nreturn observed - count;\n}\nreturn None;\n});\n// If the spend succeeded, return a new SpinGrant representing the spent amount.\n//\nif (pre_transfer_count) {\nreturn SpinGrant{issuer, count};\n}\n// At this point, we must wait for the SpinGrant to be increased in size, so if we are in non-blocking\n// mode, fail now.\n//\nif (wait_for_resource == WaitForResource::kFalse) {\nif (source.is_closed()) {\nreturn {StatusCode::kGrantRevoked};\n}\nreturn {StatusCode::kGrantUnavailable};\n}\n// Await the increase of the grant size.\n//\nStatusOr&lt;u64&gt; available = source.await_true([count](u64 observed) {\nreturn observed &gt;= count;\n});\nBATT_REQUIRE_OK(available);\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_SPIN_GRANT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/splice_8hpp/","title":"batteries/seq/splice.hpp","text":""},{"location":"_autogen/Files/splice_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/splice_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Splice struct batt::seq::SpliceBinder"},{"location":"_autogen/Files/splice_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_SPLICE_HPP"},{"location":"_autogen/Files/splice_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/splice_8hpp/#define-batteries_seq_splice_hpp","title":"define BATTERIES_SEQ_SPLICE_HPP","text":"<pre><code>#define BATTERIES_SEQ_SPLICE_HPP()\n</code></pre>"},{"location":"_autogen/Files/splice_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_SPLICE_HPP\n#define BATTERIES_SEQ_SPLICE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/seq/chain.hpp&gt;\n#include &lt;batteries/seq/take_n.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// splice\n//\ntemplate &lt;typename OuterSeq, typename InnerSeq&gt;\nclass Splice\n{\npublic:\nusing OuterSeqRef = std::add_lvalue_reference_t&lt;OuterSeq&gt;;\nusing Impl = Chain&lt;TakeN&lt;OuterSeqRef&gt;, Chain&lt;InnerSeq, OuterSeqRef&gt;&gt;;\nusing Item = SeqItem&lt;Impl&gt;;\nexplicit Splice(OuterSeq&amp;&amp; outer_seq, usize n, InnerSeq&amp;&amp; inner_seq) noexcept\n: outer_seq_(BATT_FORWARD(outer_seq))\n, impl_{TakeN&lt;OuterSeqRef&gt;{outer_seq_, n},\nChain&lt;InnerSeq, OuterSeqRef&gt;{BATT_FORWARD(inner_seq), outer_seq_}}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nreturn impl_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nreturn impl_.next();\n}\nprivate:\nOuterSeq outer_seq_;\nImpl impl_;\n};\ntemplate &lt;typename InnerSeq&gt;\nstruct SpliceBinder {\nusize n;\nInnerSeq inner_seq;\n};\ntemplate &lt;typename InnerSeq&gt;\ninline SpliceBinder&lt;InnerSeq&gt; splice(usize n, InnerSeq&amp;&amp; inner_seq)\n{\nreturn {\nn,\nBATT_FORWARD(inner_seq),\n};\n}\ntemplate &lt;typename OuterSeq, typename InnerSeq&gt;\n[[nodiscard]] auto operator|(OuterSeq&amp;&amp; outer_seq, SpliceBinder&lt;InnerSeq&gt;&amp;&amp; binder)\n{\nreturn Splice&lt;OuterSeq, InnerSeq&gt;{BATT_FORWARD(outer_seq), binder.n, BATT_FORWARD(binder.inner_seq)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_SPLICE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/ssl__transport_8cpp/","title":"batteries/http/ssl_transport.cpp","text":""},{"location":"_autogen/Files/ssl__transport_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/http/ssl_transport.hpp&gt;\n//\n#include &lt;batteries/http/ssl_transport_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/ssl__transport_8hpp/","title":"batteries/http/ssl_transport.hpp","text":""},{"location":"_autogen/Files/ssl__transport_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/ssl__transport_8hpp/#classes","title":"Classes","text":"Name class batt::SslTransport An SSL/TLS based transport for HTTPS clients."},{"location":"_autogen/Files/ssl__transport_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_SSL_TRANSPORT_HPP"},{"location":"_autogen/Files/ssl__transport_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/ssl__transport_8hpp/#define-batteries_http_ssl_transport_hpp","title":"define BATTERIES_HTTP_SSL_TRANSPORT_HPP","text":"<pre><code>#define BATTERIES_HTTP_SSL_TRANSPORT_HPP()\n</code></pre>"},{"location":"_autogen/Files/ssl__transport_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n//\n#pragma once\n#ifndef BATTERIES_HTTP_SSL_TRANSPORT_HPP\n#define BATTERIES_HTTP_SSL_TRANSPORT_HPP\n#include &lt;batteries/http/http_client_host_context_decl.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/asio/io_context.hpp&gt;\n#include &lt;batteries/asio/ip_tcp.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;boost/asio/bind_executor.hpp&gt;\n#include &lt;boost/asio/dispatch.hpp&gt;\n#include &lt;boost/asio/ssl/stream.hpp&gt;\n#include &lt;boost/asio/strand.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;functional&gt;\nnamespace batt {\nclass SslTransport\n{\npublic:\nexplicit SslTransport(HttpClientHostContext&amp; host_context) noexcept;\nboost::asio::ip::tcp::endpoint local_endpoint(ErrorCode&amp; ec) const noexcept;\nboost::asio::ip::tcp::endpoint remote_endpoint(ErrorCode&amp; ec) const noexcept;\nbool is_open() const noexcept;\nvoid close(ErrorCode&amp; ec) noexcept;\nvoid shutdown(boost::asio::socket_base::shutdown_type mode, ErrorCode&amp; ec) noexcept;\ntemplate &lt;typename Handler&gt;\nvoid async_connect(const boost::asio::ip::tcp::endpoint&amp; ep, Handler&amp;&amp; handler);\ntemplate &lt;typename MutableBufferSequence, typename Handler&gt;\nvoid async_read_some(MutableBufferSequence&amp;&amp; buffers, Handler&amp;&amp; handler);\ntemplate &lt;typename ConstBufferSequence, typename Handler&gt;\nvoid async_write_some(ConstBufferSequence&amp;&amp; buffers, Handler&amp;&amp; handler);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nboost::asio::io_context&amp; io_;\nconst i64 stream_id_;\nstd::atomic&lt;bool&gt; close_initiated_;\nOptional&lt;boost::asio::ssl::context&gt; ssl_context_;\nboost::asio::ssl::stream&lt;boost::asio::ip::tcp::socket&gt; ssl_stream_;\nboost::asio::basic_socket&lt;boost::asio::ip::tcp&gt;&amp; socket_;\nboost::asio::strand&lt;boost::asio::any_io_executor&gt; strand_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Handler&gt;\ninline void SslTransport::async_connect(const boost::asio::ip::tcp::endpoint&amp; ep, Handler&amp;&amp; handler)\n{\nboost::asio::dispatch(\nthis-&gt;strand_,\nbind_handler(\nBATT_FORWARD(handler),  //\n[this, ep](auto&amp;&amp; handler) {\n//----- --- -- -  -  -   -\n// On strand.\n//\nthis-&gt;socket_.async_connect(\nep, bind_executor(\nthis-&gt;strand_,\nbind_handler(BATT_FORWARD(handler),  //\n[this](auto&amp;&amp; handler, const ErrorCode&amp; ec) {\n//----- --- -- -  -  -   -\n// On strand.\n//\nif (ec) {\n// Because this is a caller-supplied handler, we must\n// call it in the \"proper\" way by extracting its\n// associated executor and calling post, binding the\n// completion args.\n//\npost_handler(BATT_FORWARD(handler), ec);\n} else {\nthis-&gt;ssl_stream_.async_handshake(\nboost::asio::ssl::stream_base::client,\nbind_executor(\nthis-&gt;strand_,\nbind_handler(\nBATT_FORWARD(handler),\n[this](auto&amp;&amp; handler, const ErrorCode&amp; ec) {\n//----- --- -- -  -  -   -\n// On strand.\n// If the handshake failed, then close\n// the socket.\n//\nif (ec) {\nErrorCode close_ec;\nthis-&gt;socket_.close(close_ec);\n}\n// Reset the close flag.\n//\nthis-&gt;close_initiated_.store(false);\n// See comment above re: post_handler vs\n// directly calling `handler`.\n//\npost_handler(BATT_FORWARD(handler), ec);\n})));\n}\n})));\n}));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename MutableBufferSequence, typename Handler&gt;\ninline void SslTransport::async_read_some(MutableBufferSequence&amp;&amp; buffers, Handler&amp;&amp; handler)\n{\nboost::asio::dispatch(\nthis-&gt;strand_,\nbind_handler(BATT_FORWARD(handler), [this, buffers = BATT_FORWARD(buffers)](auto&amp;&amp; handler) mutable {\n//----- --- -- -  -  -   -\n// On strand.\n//\nthis-&gt;ssl_stream_.async_read_some(std::move(buffers),\nbind_executor(this-&gt;strand_, BATT_FORWARD(handler)));\n}));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename ConstBufferSequence, typename Handler&gt;\ninline void SslTransport::async_write_some(ConstBufferSequence&amp;&amp; buffers, Handler&amp;&amp; handler)\n{\nboost::asio::dispatch(\nthis-&gt;strand_,\nbind_handler(BATT_FORWARD(handler), [this, buffers = BATT_FORWARD(buffers)](auto&amp;&amp; handler) mutable {\n//----- --- -- -  -  -   -\n// On strand.\n//\nthis-&gt;ssl_stream_.async_write_some(std::move(buffers),\nbind_executor(this-&gt;strand_, BATT_FORWARD(handler)));\n}));\n}\n}  //namespace batt\n#endif  // BATTERIES_HTTP_SSL_TRANSPORT_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/http/ssl_transport_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/ssl__transport__impl_8hpp/","title":"batteries/http/ssl_transport_impl.hpp","text":""},{"location":"_autogen/Files/ssl__transport__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/ssl__transport__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_SSL_TRANSPORT_IMPL_HPP"},{"location":"_autogen/Files/ssl__transport__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/ssl__transport__impl_8hpp/#define-batteries_http_ssl_transport_impl_hpp","title":"define BATTERIES_HTTP_SSL_TRANSPORT_IMPL_HPP","text":"<pre><code>#define BATTERIES_HTTP_SSL_TRANSPORT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/ssl__transport__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_SSL_TRANSPORT_IMPL_HPP\n#define BATTERIES_HTTP_SSL_TRANSPORT_IMPL_HPP\n#include &lt;atomic&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ SslTransport::SslTransport(HttpClientHostContext&amp; host_context) noexcept\n: io_{host_context.get_io_context()}\n, stream_id_{[] {\nstatic std::atomic&lt;i64&gt; next_id{0};\nreturn next_id.fetch_add(1) + 1;\n}()}\n, close_initiated_{false}\n, ssl_context_{}\n, ssl_stream_{this-&gt;io_,\n[&amp;]() -&gt; boost::asio::ssl::context&amp; {\nhost_context.get_ssl_init_fn()(this-&gt;ssl_context_, host_context.host_address());\nBATT_CHECK(this-&gt;ssl_context_);\nreturn *this-&gt;ssl_context_;\n}()}\n, socket_{this-&gt;ssl_stream_.lowest_layer()}\n, strand_{this-&gt;io_.get_executor()}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL boost::asio::ip::tcp::endpoint SslTransport::local_endpoint(ErrorCode&amp; ec) const noexcept\n{\nreturn Task::await&lt;boost::asio::ip::tcp::endpoint&gt;([&amp;](auto&amp;&amp; handler) {\nboost::asio::dispatch(this-&gt;strand_,\nbind_handler(BATT_FORWARD(handler), [this, &amp;ec](auto&amp;&amp; handler) mutable {\n//----- --- -- -  -  -   -\n// On strand.\n//\n// It is ok to call the handler directly (instead of posting it using\n// its associated executor), since we know it comes directly from\n// Task::await.\n//\nBATT_FORWARD(handler)(this-&gt;socket_.local_endpoint(ec));\n}));\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL boost::asio::ip::tcp::endpoint SslTransport::remote_endpoint(ErrorCode&amp; ec) const noexcept\n{\nreturn Task::await&lt;boost::asio::ip::tcp::endpoint&gt;([&amp;](auto&amp;&amp; handler) {\nboost::asio::dispatch(this-&gt;strand_,\nbind_handler(BATT_FORWARD(handler), [this, &amp;ec](auto&amp;&amp; handler) mutable {\n//----- --- -- -  -  -   -\n// On strand.\n//\n// It is ok to call the handler directly (instead of posting it using\n// its associated executor), since we know it comes directly from\n// Task::await.\n//\nBATT_FORWARD(handler)(this-&gt;socket_.remote_endpoint(ec));\n}));\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool SslTransport::is_open() const noexcept\n{\nif (this-&gt;close_initiated_.load() == true) {\nBATT_LOG_INFO() &lt;&lt; \"is_open() -&gt; false;\" &lt;&lt; BATT_INSPECT(this-&gt;close_initiated_);\nreturn false;\n}\nreturn Task::await&lt;bool&gt;([&amp;](auto&amp;&amp; handler) {\nboost::asio::dispatch(\nthis-&gt;strand_, bind_handler(BATT_FORWARD(handler), [this](auto&amp;&amp; handler) mutable {\n//----- --- -- -  -  -   -\n// On strand.\n//\n// It is ok to call the handler directly (instead of posting it using\n// its associated executor), since we know it comes directly from\n// Task::await.\n//\nbool result = this-&gt;socket_.is_open();\nBATT_LOG_INFO() &lt;&lt; \"is_open()\" &lt;&lt; BATT_INSPECT(this-&gt;stream_id_) &lt;&lt; BATT_INSPECT(result);\nBATT_FORWARD(handler)(result);\n}));\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SslTransport::close(ErrorCode&amp; ec) noexcept\n{\nBATT_LOG_INFO() &lt;&lt; \"SslTransport::close()\" &lt;&lt; BATT_INSPECT(this-&gt;stream_id_) &lt;&lt; std::endl\n&lt;&lt; boost::stacktrace::stacktrace{};\nif (this-&gt;close_initiated_.exchange(true)) {\nBATT_LOG_INFO() &lt;&lt; \"close already initiated; returning success\";\nec = ErrorCode{};\nreturn;\n}\nec = Task::await&lt;ErrorCode&gt;([this](auto&amp;&amp; handler) {\nboost::asio::dispatch(\nthis-&gt;strand_, bind_handler(BATT_FORWARD(handler), [this](auto&amp;&amp; handler) mutable {\nBATT_LOG_INFO() &lt;&lt; \"async_shutdown()\" &lt;&lt; BATT_INSPECT(this-&gt;stream_id_);\n//----- --- -- -  -  -   -\n// On strand.\n//\nthis-&gt;ssl_stream_.async_shutdown(bind_executor(\nthis-&gt;strand_, bind_handler(handler, [this](auto&amp;&amp; handler, const ErrorCode&amp; ssl_ec) {\nBATT_LOG_INFO() &lt;&lt; BATT_INSPECT(ssl_ec);\n// On strand.\n//\n// Regardless how the SSL shutdown went, close the socket.\n//\nErrorCode tcp_ec;\nthis-&gt;socket_.close(tcp_ec);\nBATT_LOG_INFO() &lt;&lt; BATT_INSPECT(tcp_ec);\n// If multiple errors occurred, report the one at the SSL level.\n//\nconst ErrorCode ec = [&amp;] {\nif (ssl_ec &amp;&amp; ssl_ec != boost::asio::ssl::error::stream_truncated) {\nreturn ssl_ec;\n}\nreturn tcp_ec;\n}();\n// It is ok to call the handler directly (instead of posting it using\n// its associated executor), since we know it comes directly from\n// Task::await.\n//\nBATT_FORWARD(handler)(ec);\n})));\n}));\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void SslTransport::shutdown(boost::asio::socket_base::shutdown_type mode,\nErrorCode&amp; ec) noexcept\n{\nec = Task::await&lt;ErrorCode&gt;([this, mode](auto&amp;&amp; handler) {\nboost::asio::dispatch(this-&gt;strand_,\nbind_handler(BATT_FORWARD(handler), [this, mode](auto&amp;&amp; handler) mutable {\n//----- --- -- -  -  -   -\n// On strand.\n//\n// It is ok to call the handler directly (instead of posting it using\n// its associated executor), since we know it comes directly from\n// Task::await.\n//\nErrorCode ec;\nthis-&gt;socket_.shutdown(mode, ec);\nBATT_FORWARD(handler)(ec);\n}));\n});\n}\n}  //namespace batt\n#endif  // BATTERIES_HTTP_SSL_TRANSPORT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/stacktrace_8hpp/","title":"batteries/stacktrace.hpp","text":""},{"location":"_autogen/Files/stacktrace_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STACKTRACE_HPP"},{"location":"_autogen/Files/stacktrace_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stacktrace_8hpp/#define-batteries_stacktrace_hpp","title":"define BATTERIES_STACKTRACE_HPP","text":"<pre><code>#define BATTERIES_STACKTRACE_HPP()\n</code></pre>"},{"location":"_autogen/Files/stacktrace_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STACKTRACE_HPP\n#define BATTERIES_STACKTRACE_HPP\n#ifdef BOOST_STACKTRACE_USE_NOOP\n#undef BOOST_STACKTRACE_USE_NOOP\n#endif  // BOOST_STACKTRACE_USE_NOOP\n// IMPORTANT: This file must not include any batteries/*.hpp!\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wmaybe-uninitialized\"\n#endif\n#include &lt;boost/stacktrace.hpp&gt;\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n#pragma GCC diagnostic pop\n#endif\n#endif  // BATTERIES_STACKTRACE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/state__machine__model_8hpp/","title":"batteries/state_machine_model.hpp","text":""},{"location":"_autogen/Files/state__machine__model_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/state__machine__model_8hpp/#classes","title":"Classes","text":"Name class batt::StateMachineModel"},{"location":"_autogen/Files/state__machine__model_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_HPP"},{"location":"_autogen/Files/state__machine__model_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/state__machine__model_8hpp/#define-batteries_state_machine_model_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_HPP()\n</code></pre>"},{"location":"_autogen/Files/state__machine__model_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/state_machine_model/entropy_source.hpp&gt;\n#include &lt;batteries/state_machine_model/exhaustive_model_checker.hpp&gt;\n#include &lt;batteries/state_machine_model/parallel_model_check_state.hpp&gt;\n#include &lt;batteries/state_machine_model/state_machine_result.hpp&gt;\n#include &lt;batteries/state_machine_model/state_machine_traits.hpp&gt;\n#include &lt;batteries/state_machine_model/stochastic_model_checker.hpp&gt;\n#include &lt;batteries/state_machine_model/verbose.hpp&gt;\n#include &lt;batteries/async/debug_info.hpp&gt;\n#include &lt;batteries/async/latch.hpp&gt;\n#include &lt;batteries/async/mutex.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/hash.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/radix_queue.hpp&gt;\n#include &lt;batteries/static_dispatch.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\n#include &lt;array&gt;\n#include &lt;atomic&gt;\n#include &lt;bitset&gt;\n#include &lt;chrono&gt;\n#include &lt;deque&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename StateT, typename StateHash = std::hash&lt;StateT&gt;,\ntypename StateEqual = std::equal_to&lt;StateT&gt;&gt;\nclass StateMachineModel\n{\npublic:\nusing state_type = StateT;\nusing state_hash_type = StateHash;\nusing state_equal_type = StateEqual;\nusing Base = StateMachineModel;\nusing Branch = StateMachineBranch&lt;StateT, StateHash, StateEqual&gt;;\nusing Result = StateMachineResult;\nusing AdvancedOptions = StateMachineModelCheckAdvancedOptions;\nenum struct VisitResult {\nkFirstTime,\nkSeenBefore,\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStateMachineModel(const StateMachineModel&amp;) = delete;\nStateMachineModel&amp; operator=(const StateMachineModel&amp;) = delete;\nvirtual ~StateMachineModel() = default;\nStateMachineModel() = default;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename Checker = ExhaustiveModelChecker&lt;StateMachineModel&gt;&gt;\nResult check_model(StaticType&lt;Checker&gt; = {});\nbool state_visited(const state_type&amp; s) const\n{\nreturn this-&gt;visited_.count(s) != 0;\n}\nstd::shared_ptr&lt;std::ostringstream&gt; debug_out = std::make_shared&lt;std::ostringstream&gt;();\n// Attach the passed entropy source to the model.  This is used to return values from `pick_int`, etc.\n// during the model's `step()` function.\n//\nvoid set_entropy(StateMachineEntropySource&amp;&amp; entropy_source)\n{\nthis-&gt;entropy_ = std::move(entropy_source);\n}\n// Clears the set of states visited by the model.\n//\nvoid reset_visited_states()\n{\nthis-&gt;visited_.clear();\n}\n// Returns whether this is the first time visiting the passed state.\n//\nVisitResult visit(const StateT&amp; state, const Branch&amp; src_branch)\n{\n// We save a subgraph of the overall search so we can give somewhat meaningful information to help\n// users understand how a state machine got into a certain state, if things go wrong.\n//\nconst auto&amp; [iter, inserted] = this-&gt;visited_.emplace(state, src_branch);\n(void)iter;\nif (inserted) {\nreturn VisitResult::kFirstTime;\n}\nreturn VisitResult::kSeenBefore;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Derived classes must implemented these methods to define the state machine simulation.\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Returns the initial state value for the search.\n//\nvirtual state_type initialize() = 0;\n// Invoked whenever a state is entered, prior to checking invariants and generating branches.\n//\nvirtual void enter_state(const state_type&amp;) = 0;\n// Should non-deterministically update the state machine using one or more calls to `pick_int` and/or\n// `do_one_of`.  This defines the state transition space.  Eventually all values of non-deterministic\n// variables will be searched.\n//\nvirtual void step() = 0;\n// Invoked after step() to retrieve the serialized snapshot of the new state.\n//\nvirtual state_type leave_state() = 0;\n// Verifies the invariants of the state machine that should hold after initialization and between each\n// step.  Returns false if the check failed.\n//\nvirtual bool check_invariants() = 0;\n// (Optional) Verifies any invariants that should hold across subsequent states.  Returns false if the\n// check failed.\n//\nvirtual bool check_stepwise_invariants()\n{\nreturn true;\n}\n// (Optional) Maps symmetrical states onto a single normalized form; in many cases this can dramatically\n// reduce the overall state search space.\n//\nvirtual state_type normalize(const state_type&amp; s)\n{\nreturn s;\n}\n// (Optional) How often to report progress during a model check.\n//\nvirtual double progress_report_interval_seconds() const\n{\nreturn 5.0;\n}\n// (Optional) Report progress during a model check.\n//\nvirtual void report_progress(const Result&amp;)\n{\n}\n// (Optional) Should return &gt; 1 if this model supports parallel execution via object cloning.\n//\nvirtual usize max_concurrency() const\n{\nreturn 1;\n}\n// If the derived model implementation class returns `max_concurrency() &gt; 1`, this method must return\n// non-nullptr.\n//\nvirtual std::unique_ptr&lt;StateMachineModel&gt; clone() const\n{\nreturn nullptr;\n}\n// (Optional) Advanced tuning of model check algorithm.\n//\nvirtual AdvancedOptions advanced_options() const\n{\nreturn AdvancedOptions::with_default_values();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Returns an integer `i` non-deterministically, such that `i &gt;= min_value &amp;&amp; i &lt;= max_value`.\n//\nusize pick_int(usize min_value, usize max_value)\n{\nreturn this-&gt;entropy_.pick_int(min_value, max_value);\n}\n// Returns false or true.\n//\nbool pick_branch()\n{\nreturn this-&gt;entropy_.pick_branch();\n}\n// Returns one of the items in `values`, using `pick_int`.\n//\ntemplate &lt;typename T&gt;\nT pick_one_of(std::initializer_list&lt;T&gt; values)\n{\nreturn this-&gt;entropy_.pick_one_of(values);\n}\n// If there is at least one runnable completion handler in `context`, one such handler is selected (via\n// `pick_int`) and invoked, and this function returns true.  Else false is returned.\n//\nbool run_one(FakeExecutionContext&amp; context)\n{\nreturn this-&gt;entropy_.run_one(context);\n}\n// Performs one of the passed action functions.  Each `Fn` in `actions...` must be callable with no\n// arguments and its return type must be ignorable.\n//\ntemplate &lt;typename... Fn&gt;\nvoid do_one_of(Fn&amp;&amp;... actions)\n{\nthis-&gt;entropy_.do_one_of(BATT_FORWARD(actions)...);\n}\n// Returns a generic entropy source that can be passed around by state machine implementations to\n// implement modular simulations.  No copy of the returned object may outlive `this`, or behavior is\n// undefined!\n//\nStateMachineEntropySource entropy()\n{\nreturn this-&gt;entropy_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nusing VisitedBranchMap = std::unordered_map&lt;state_type, Branch, StateHash, StateEqual&gt;;\nVisitedBranchMap visited_;\nStateMachineEntropySource entropy_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename StateT, typename StateHash, typename StateEqual&gt;\ntemplate &lt;typename Checker&gt;\nauto StateMachineModel&lt;StateT, StateHash, StateEqual&gt;::check_model(StaticType&lt;Checker&gt;) -&gt; Result\n{\nconst usize n_shards = this-&gt;max_concurrency();\nBATT_CHECK_GT(n_shards, 0u);\nconst auto print_summary = finally([&amp;] {\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; \"Model check done; \" &lt;&lt; BATT_INSPECT(this-&gt;visited_.size());\n});\ndetail::ParallelModelCheckState&lt;Branch&gt; mesh{/*shard_count=*/n_shards};\nif (n_shards == 1) {\nChecker checker{*this, mesh, 0};\nreturn checker.run();\n}\n// Set up a thread pool and process a shard per thread.\n//\nstd::vector&lt;std::unique_ptr&lt;Latch&lt;Result&gt;&gt;&gt; shard_results(n_shards);\nstd::vector&lt;VisitedBranchMap&gt; shard_visited(n_shards);\nstd::vector&lt;std::unique_ptr&lt;StateMachineModel&gt;&gt; shard_models(n_shards);\nstd::vector&lt;std::thread&gt; threads;\nconst usize cpu_count = std::thread::hardware_concurrency();\n// IMPORTANT: all of the latches must be created before we launch any of the threads.\n//\nfor (usize shard_i = 0; shard_i &lt; n_shards; ++shard_i) {\nshard_results[shard_i] = std::make_unique&lt;Latch&lt;Result&gt;&gt;();\n// Each thread gets its own copy of the model object.\n//\nshard_models[shard_i] = this-&gt;clone();\nBATT_CHECK_NOT_NULLPTR(shard_models[shard_i])\n&lt;&lt; \"clone() MUST return non-nullptr if max_concurrency() is &gt; 1\";\n}\nconst bool pin_cpu = this-&gt;advanced_options().pin_shard_to_cpu;\n// Launch threads, one per shard.  Each thread will explore the model state space that hashes to its\n// portion of the hash space (i.e., its \"shard\") and then do O(log_2(N)) combine operations to collect the\n// results of other shards.  These two stages are like Map and Reduce.\n//\nfor (usize shard_i = 0; shard_i &lt; n_shards; ++shard_i) {\nthreads.emplace_back([shard_i, &amp;shard_results, &amp;shard_models, &amp;shard_visited, &amp;mesh, cpu_count,\npin_cpu] {\nboost::asio::io_context io;\nbatt::Task shard_task{\nio.get_executor(), [&amp;] {\n// Pin each thread to a different CPU to try to speed things up.\n//\nif (pin_cpu) {\nconst usize cpu_i = shard_i % cpu_count;\npin_thread_to_cpu(cpu_i).IgnoreError();\n}\n// First step is to compute the shard-local result.\n//\nChecker checker{*shard_models[shard_i], mesh, shard_i};\nResult tmp_result = checker.run();\ntmp_result.shards.set(shard_i, true);\nshard_visited[shard_i] = std::move(shard_models[shard_i]-&gt;visited_);\n// Combine sub-results until the merge mask collides with the least-significant 1 bit of\n// the shard index.\n//\n// Example:\n//\n// shard_i  | merge_i values\n// ---------|---------------------------------\n// 0b0000   | {0b0001, 0b0010, 0b0100, 0b1000}\n// 0b0001   | {}\n// 0b0010   | {0b0011}\n// 0b0011   | {}\n// 0b0100   | {0b0101, 0b0110}\n// 0b0101   | {}\n// 0b0110   | {0b0111}\n// 0b0111   | {}\n// 0b1000   | {0b1001, 0b1010, 0b1100}\n// 0b1001   | {}\n// 0b1010   | {0b1011}\n// 0b1011   | {}\n// 0b1100   | {0b1101, 0b1110}\n// 0b1101   | {}\n// 0b1110   | {0b1111}\n// 0b1111   | {}\n//\nfor (usize merge_mask = 1; (merge_mask &amp; shard_i) == 0; merge_mask &lt;&lt;= 1) {\nconst usize merge_i = (shard_i | merge_mask);\nif (merge_i &gt;= mesh.shard_count) {\n// `merge_i` is only going to get bigger, so stop as soon as this happens.\nbreak;\n}\nBATT_CHECK_LT(shard_i, merge_i);\nBATT_CHECK_LT(merge_i, shard_results.size());\nconst Result merge_result = BATT_OK_RESULT_OR_PANIC(shard_results[merge_i]-&gt;await());\ntmp_result = combine_results(tmp_result, merge_result);\nshard_visited[shard_i].insert(shard_visited[merge_i].begin(),\nshard_visited[merge_i].end());\n}\nBATT_CHECK(shard_results[shard_i]-&gt;set_value(std::move(tmp_result)));\nio.stop();\n}};\nio.run();\n});\n}\nfor (std::thread&amp; t : threads) {\nt.join();\n}\n{\nusize shard_i = 0;\nfor (auto&amp; r : shard_results) {\n*this-&gt;debug_out &lt;&lt; shard_i &lt;&lt; \": \" &lt;&lt; BATT_OK_RESULT_OR_PANIC(r-&gt;poll()) &lt;&lt; std::endl;\n++shard_i;\n}\n}\nthis-&gt;visited_ = std::move(shard_visited[0]);\nResult result = BATT_OK_RESULT_OR_PANIC(shard_results[0]-&gt;poll());\nresult.state_count = this-&gt;visited_.size();\nreturn result;\n}\n//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n/* TEMPLATE FOR NEW STATE MACHINE MODEL IMPLS:\n#include &lt;batteries/state_machine_model.hpp&gt;\n#include &lt;boost/functional/hash.hpp&gt;\n#include &lt;boost/operators.hpp&gt;\nstruct $ImplState : boost::equality_comparable&lt;$ImplState&gt; {\n  struct Hash {\n    usize operator()(const $ImplState&amp; s) const\n    {\n      return batt::hash();\n    }\n  };\n  friend bool operator==(const $ImplState&amp; l, const $ImplState&amp; r)\n  {\n    return false;\n  }\n  bool is_terminal() const\n  {\n    return true;\n  }\n};\nclass $ImplModel : public batt::StateMachineModel&lt;$ImplState, $ImplState::Hash&gt;\n{\n public:\n    $ImplState initialize() override\n    {\n        return $ImplState{};\n    }\n    void enter_state(const $ImplState&amp; s) override\n    {\n        this-&gt;state_ = s;\n    }\n    void step() override\n    {\n        if (this-&gt;state_.is_terminal()) {\n            return;\n        }\n        this-&gt;pick_int(min, max);\n        this-&gt;do_one_of([]{\n            action1();\n          },\n          []{\n            action2();\n          });\n    }\n    $ImplState leave_state() override\n    {\n        return this-&gt;state_;\n    }\n    bool check_invariants() override\n    {\n        return true;\n    }\n    $ImplState normalize(const $ImplState&amp; s) override\n    {\n        return s;\n    }\n   private:\n    $ImplState state_;\n};\nTEST($ImplTest, StateMachineSimulation)\n{\n    $ImplModel model;\n    $ImplModel::Result result = model.check_model();\n    EXPECT_TRUE(result.ok());\n}\n */\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/state__machine__result_8hpp/","title":"batteries/state_machine_model/state_machine_result.hpp","text":""},{"location":"_autogen/Files/state__machine__result_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/state__machine__result_8hpp/#classes","title":"Classes","text":"Name struct batt::StateMachineResult"},{"location":"_autogen/Files/state__machine__result_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP"},{"location":"_autogen/Files/state__machine__result_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/state__machine__result_8hpp/#define-batteries_state_machine_model_state_machine_result_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP()\n</code></pre>"},{"location":"_autogen/Files/state__machine__result_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;bitset&gt;\n#include &lt;chrono&gt;\n#include &lt;ostream&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nstruct StateMachineResult {\nbool ok = false;\nusize branch_push_count = 0;\nusize branch_pop_count = 0;\nusize branch_miss_count = 0;\nusize state_count = 0;\nusize self_branch_count = 0;\nstd::chrono::steady_clock::time_point start_time;\nusize elapsed_ms = 0;\ndouble states_per_second = 0.0;\ndouble branch_pop_per_second = 0.0;\ndouble branch_push_per_second = 0.0;\nstd::bitset&lt;64&gt; shards{0};\nOptional&lt;usize&gt; seed;\nvoid update_elapsed_time()\n{\nthis-&gt;elapsed_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\nstd::chrono::steady_clock::now() - this-&gt;start_time)\n.count();\nthis-&gt;update_rates();\n}\ndouble compute_rate(usize count) const\n{\nreturn double(count * 1000 + 1) / double(this-&gt;elapsed_ms + 1);\n}\nvoid update_rates()\n{\nthis-&gt;states_per_second = this-&gt;compute_rate(this-&gt;state_count);\nthis-&gt;branch_pop_per_second = this-&gt;compute_rate(this-&gt;branch_pop_count);\nthis-&gt;branch_push_per_second = this-&gt;compute_rate(this-&gt;branch_push_count);\n}\n};\ninline StateMachineResult combine_results(const StateMachineResult&amp; a, const StateMachineResult&amp; b)\n{\nStateMachineResult c;\nc.ok = a.ok &amp;&amp; b.ok;\nc.branch_push_count = a.branch_push_count + b.branch_push_count;\nc.branch_pop_count = a.branch_pop_count + b.branch_pop_count;\nc.branch_miss_count = a.branch_miss_count + b.branch_miss_count;\nc.state_count = a.state_count + b.state_count;\nc.self_branch_count = a.self_branch_count + b.self_branch_count;\nc.elapsed_ms = std::max(a.elapsed_ms, b.elapsed_ms);\nc.start_time = std::chrono::steady_clock::now() - std::chrono::milliseconds(c.elapsed_ms);\nc.shards = a.shards | b.shards;\nc.update_rates();\nif (a.seed) {\nc.seed = a.seed;\n} else {\nc.seed = b.seed;\n}\nreturn c;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const StateMachineResult&amp; r)\n{\nreturn out &lt;&lt; \"StateMachineResult{\"                                     //\n&lt;&lt; \".ok=\" &lt;&lt; r.ok                                            //\n&lt;&lt; \", .branch_push_count=\" &lt;&lt; r.branch_push_count            //\n&lt;&lt; \", .branch_pop_count=\" &lt;&lt; r.branch_pop_count              //\n&lt;&lt; \", .branch_miss_count=\" &lt;&lt; r.branch_miss_count            //\n&lt;&lt; \", .state_count=\" &lt;&lt; r.state_count                        //\n&lt;&lt; \", .self_branch_count=\" &lt;&lt; r.self_branch_count            //\n&lt;&lt; \", .states_per_second=\" &lt;&lt; r.states_per_second            //\n&lt;&lt; \", .branch_push_per_second=\" &lt;&lt; r.branch_push_per_second  //\n&lt;&lt; \", .branch_pop_per_second=\" &lt;&lt; r.branch_pop_per_second    //\n&lt;&lt; \", .elapsed_ms=\" &lt;&lt; r.elapsed_ms                          //\n&lt;&lt; \", .shards=\" &lt;&lt; r.shards                                  //\n&lt;&lt; \", .seed=\" &lt;&lt; r.seed                                      //\n&lt;&lt; \",}\";\n}\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_RESULT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/state__machine__traits_8hpp/","title":"batteries/state_machine_model/state_machine_traits.hpp","text":""},{"location":"_autogen/Files/state__machine__traits_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/state__machine__traits_8hpp/#classes","title":"Classes","text":"Name struct batt::StateMachineTraits"},{"location":"_autogen/Files/state__machine__traits_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP"},{"location":"_autogen/Files/state__machine__traits_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/state__machine__traits_8hpp/#define-batteries_state_machine_model_state_machine_traits_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP()\n</code></pre>"},{"location":"_autogen/Files/state__machine__traits_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\nnamespace batt {\ntemplate &lt;typename StateT&gt;\nstruct StateMachineTraits {\nstatic constexpr usize kRadixQueueSize = 256;\n};\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_STATE_MACHINE_TRAITS_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/static__assert_8hpp/","title":"batteries/static_assert.hpp","text":""},{"location":"_autogen/Files/static__assert_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/static__assert_8hpp/#classes","title":"Classes","text":"Name struct batt::StaticBinaryAssertion struct batt::StaticSameTypeAssertion"},{"location":"_autogen/Files/static__assert_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATIC_ASSERT_HPP BATT_STATIC_ASSERT_EQ(x, y) BATT_STATIC_ASSERT_NE(x, y) BATT_STATIC_ASSERT_LT(x, y) BATT_STATIC_ASSERT_LE(x, y) BATT_STATIC_ASSERT_GT(x, y) BATT_STATIC_ASSERT_GE(x, y) BATT_STATIC_ASSERT_TYPE_EQ(x, y) BATT_CHECK_TYPE(type, expr) Evaluates to <code>expr</code>, failing the compilation if the type of the expression doesn't match <code>type</code>."},{"location":"_autogen/Files/static__assert_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/static__assert_8hpp/#define-batteries_static_assert_hpp","title":"define BATTERIES_STATIC_ASSERT_HPP","text":"<pre><code>#define BATTERIES_STATIC_ASSERT_HPP()\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_eq","title":"define BATT_STATIC_ASSERT_EQ","text":"<pre><code>#define BATT_STATIC_ASSERT_EQ(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_ne","title":"define BATT_STATIC_ASSERT_NE","text":"<pre><code>#define BATT_STATIC_ASSERT_NE(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_lt","title":"define BATT_STATIC_ASSERT_LT","text":"<pre><code>#define BATT_STATIC_ASSERT_LT(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_le","title":"define BATT_STATIC_ASSERT_LE","text":"<pre><code>#define BATT_STATIC_ASSERT_LE(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_gt","title":"define BATT_STATIC_ASSERT_GT","text":"<pre><code>#define BATT_STATIC_ASSERT_GT(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_ge","title":"define BATT_STATIC_ASSERT_GE","text":"<pre><code>#define BATT_STATIC_ASSERT_GE(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_static_assert_type_eq","title":"define BATT_STATIC_ASSERT_TYPE_EQ","text":"<pre><code>#define BATT_STATIC_ASSERT_TYPE_EQ(x, y)\n</code></pre>"},{"location":"_autogen/Files/static__assert_8hpp/#define-batt_check_type","title":"define BATT_CHECK_TYPE","text":"<pre><code>#define BATT_CHECK_TYPE(type, expr)\n</code></pre> <p>Evaluates to <code>expr</code>, failing the compilation if the type of the expression doesn't match <code>type</code>. </p>"},{"location":"_autogen/Files/static__assert_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATIC_ASSERT_HPP\n#define BATTERIES_STATIC_ASSERT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/preprocessor/cat.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nstruct Eq;\nstruct Ne;\nstruct Lt;\nstruct Le;\nstruct Ge;\nstruct Gt;\ntemplate &lt;typename T, typename U, T left, typename Op, U right, bool kCondition&gt;\nstruct StaticBinaryAssertion : std::integral_constant&lt;bool, kCondition&gt; {\nstatic_assert(kCondition == true, \"\");\n};\n#define BATT_STATIC_ASSERT_EQ(x, y)                                                                          \\\n    BATT_MAYBE_UNUSED static ::batt::StaticBinaryAssertion&lt;decltype(x), decltype(y), (x), ::batt::Eq, \\\n                                                           (y), ((x) == (y))&gt;                                \\\n    BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n#define BATT_STATIC_ASSERT_NE(x, y)                                                                          \\\n    BATT_MAYBE_UNUSED static ::batt::StaticBinaryAssertion&lt;decltype(x), decltype(y), (x), ::batt::Ne, \\\n                                                           (y), ((x) != (y))&gt;                                \\\n    BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n#define BATT_STATIC_ASSERT_LT(x, y)                                                                          \\\n    BATT_MAYBE_UNUSED static ::batt::StaticBinaryAssertion&lt;decltype(x), decltype(y), (x), ::batt::Lt, \\\n                                                           (y), ((x) &lt; (y))&gt;                                 \\\n    BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n#define BATT_STATIC_ASSERT_LE(x, y)                                                                          \\\n    BATT_MAYBE_UNUSED static ::batt::StaticBinaryAssertion&lt;decltype(x), decltype(y), (x), ::batt::Le, \\\n                                                           (y), ((x) &lt;= (y))&gt;                                \\\n    BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n#define BATT_STATIC_ASSERT_GT(x, y)                                                                          \\\n    BATT_MAYBE_UNUSED static ::batt::StaticBinaryAssertion&lt;decltype(x), decltype(y), (x), ::batt::Gt, \\\n                                                           (y), ((x) &gt; (y))&gt;                                 \\\n    BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n#define BATT_STATIC_ASSERT_GE(x, y)                                                                          \\\n    BATT_MAYBE_UNUSED static ::batt::StaticBinaryAssertion&lt;decltype(x), decltype(y), (x), ::batt::Ge, \\\n                                                           (y), ((x) &gt;= (y))&gt;                                \\\n    BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename U&gt;\nstruct StaticSameTypeAssertion {\nstatic_assert(std::is_same_v&lt;T, U&gt;, \"\");\n};\n#if defined(_MSC_VER) &amp;&amp; 0\n#define BATT_STATIC_ASSERT_TYPE_EQ(x, y) static_assert(std::is_same_v&lt;x, y&gt;)\n#else\n#define BATT_STATIC_ASSERT_TYPE_EQ(x, y)                                                                     \\\n    BATT_MAYBE_UNUSED static ::batt::StaticSameTypeAssertion&lt;x, y&gt; BOOST_PP_CAT(                             \\\n        BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__), __COUNTER__)\n#endif\n#define BATT_CHECK_TYPE(type, expr)                                                                          \\\n    [&amp;]() noexcept(noexcept(expr)) -&gt; decltype(auto) {                                                       \\\n        BATT_STATIC_ASSERT_TYPE_EQ(decltype(expr), type);                                                    \\\n        return expr;                                                                                         \\\n    }()\n}  // namespace batt\n#endif  // BATTERIES_STATIC_ASSERT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/static__dispatch_8hpp/","title":"batteries/static_dispatch.hpp","text":""},{"location":"_autogen/Files/static__dispatch_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/static__dispatch_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATIC_DISPATCH_HPP BATT_CONST_T(i) BATT_CONST(i) Shortcut for: <code>std::integral_constant&lt;decltype(i), i&gt;{}</code>."},{"location":"_autogen/Files/static__dispatch_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/static__dispatch_8hpp/#define-batteries_static_dispatch_hpp","title":"define BATTERIES_STATIC_DISPATCH_HPP","text":"<pre><code>#define BATTERIES_STATIC_DISPATCH_HPP()\n</code></pre>"},{"location":"_autogen/Files/static__dispatch_8hpp/#define-batt_const_t","title":"define BATT_CONST_T","text":"<pre><code>#define BATT_CONST_T(i)\n</code></pre>"},{"location":"_autogen/Files/static__dispatch_8hpp/#define-batt_const","title":"define BATT_CONST","text":"<pre><code>#define BATT_CONST(i)\n</code></pre> <p>Shortcut for: <code>std::integral_constant&lt;decltype(i), i&gt;{}</code>. </p>"},{"location":"_autogen/Files/static__dispatch_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATIC_DISPATCH_HPP\n#define BATTERIES_STATIC_DISPATCH_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n//\n#include &lt;array&gt;\n#include &lt;cstddef&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace detail {\ntemplate &lt;typename Arg, typename Result&gt;\nusing AbstractCaseHandler = Result (*)(Arg);\ntemplate &lt;typename IntT, IntT I, typename Fn, typename R&gt;\nR CaseHandlerImpl(Fn&amp;&amp; fn)\n{\nreturn BATT_FORWARD(fn)(std::integral_constant&lt;IntT, I&gt;{});\n}\ntemplate &lt;typename IntT, IntT I, typename Fn, typename R&gt;\nvoid initialize_case_handlers(std::integral_constant&lt;IntT, I&gt;, std::integral_constant&lt;IntT, I&gt;,\nAbstractCaseHandler&lt;Fn, R&gt;* /*begin*/, AbstractCaseHandler&lt;Fn, R&gt;* /*end*/)\n{\n// Nothing to do; empty range.\n}\ntemplate &lt;typename IntT, IntT kBegin, IntT kEnd, typename Fn, typename R&gt;\nvoid initialize_case_handlers(std::integral_constant&lt;IntT, kBegin&gt;, std::integral_constant&lt;IntT, kEnd&gt;,\nAbstractCaseHandler&lt;Fn, R&gt;* begin, AbstractCaseHandler&lt;Fn, R&gt;* end)\n{\nstatic_assert(kEnd &gt;= kBegin, \"\");\nBATT_CHECK_LE(begin, end);\nBATT_CHECK_EQ(kEnd - kBegin, end - begin);\nif (begin == end - 1) {\n*begin = CaseHandlerImpl&lt;IntT, kBegin, Fn, R&gt;;\n} else {\nconstexpr IntT kMiddle = (kBegin + kEnd) / 2;\nAbstractCaseHandler&lt;Fn, R&gt;* middle = begin + (end - begin) / 2;\ninitialize_case_handlers(std::integral_constant&lt;IntT, kBegin&gt;{},\nstd::integral_constant&lt;IntT, kMiddle&gt;{}, begin, middle);\ninitialize_case_handlers(std::integral_constant&lt;IntT, kMiddle&gt;{},\nstd::integral_constant&lt;IntT, kEnd&gt;{}, middle, end);\n}\n}\n}  // namespace detail\ntemplate &lt;typename IntT, IntT kBegin, IntT kEnd, typename Fn,\ntypename R = decltype(std::declval&lt;Fn&gt;()(std::integral_constant&lt;IntT, kBegin&gt;{}))&gt;\nR static_dispatch(IntT i, Fn&amp;&amp; fn)\n{\nstatic const std::array&lt;detail::AbstractCaseHandler&lt;Fn&amp;&amp;, R&gt;, kEnd - kBegin&gt; case_handlers = [&amp;] {\nstd::array&lt;detail::AbstractCaseHandler&lt;Fn&amp;&amp;, R&gt;, kEnd - kBegin&gt; case_handlers;\ndetail::initialize_case_handlers(std::integral_constant&lt;IntT, kBegin&gt;{},\nstd::integral_constant&lt;IntT, kEnd&gt;{}, case_handlers.data(),\ncase_handlers.data() + case_handlers.size());\nreturn case_handlers;\n}();\nBATT_CHECK_GE(i, kBegin);\nBATT_CHECK_LT(i, kEnd);\nreturn case_handlers[i - kBegin](BATT_FORWARD(fn));\n}\ntemplate &lt;typename Fn&gt;\ndecltype(auto) static_dispatch(bool b, Fn&amp;&amp; fn)\n{\nif (b) {\nreturn BATT_FORWARD(fn)(std::true_type{});\n} else {\nreturn BATT_FORWARD(fn)(std::false_type{});\n}\n}\ntemplate &lt;typename Tuple, typename Fn&gt;\ndecltype(auto) static_dispatch(std::size_t i, Fn&amp;&amp; fn)\n{\nreturn static_dispatch&lt;std::size_t, 0, std::tuple_size&lt;Tuple&gt;::value&gt;(\ni, [&amp;fn](auto static_int) mutable -&gt; decltype(auto) {\nusing T = std::tuple_element_t&lt;decltype(static_int)::value, Tuple&gt;;\nreturn BATT_FORWARD(fn)(StaticType&lt;T&gt;{});\n});\n}\n#define BATT_CONST_T(i) std::integral_constant&lt;decltype(i), (i)&gt;\n// clang-format off\n#define BATT_CONST(i) BATT_CONST_T(I){}\n// clang-format on\n}  // namespace batt\n#endif  // BATTERIES_STATIC_DISPATCH_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/status_8cpp/","title":"batteries/status.cpp","text":""},{"location":"_autogen/Files/status_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/status.hpp&gt;\n//\n#include &lt;batteries/status_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/status_8hpp/","title":"batteries/status.hpp","text":""},{"location":"_autogen/Files/status_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/status_8hpp/#classes","title":"Classes","text":"Name class batt::detail::StatusBase class batt::Status struct batt::Status::ForceLookup Sentinel type passed to Status constructor to force the passed code enum value to be treated as a non-error_code type. struct batt::Status::CodeEntry struct batt::Status::CodeGroup class batt::detail::StatusOrValueContainer class batt::detail::StatusOrValueContainer&lt; T &amp; &gt; class batt::StatusOr class batt::StatusOr&lt; Status &gt; class batt::StatusOr&lt; StatusOr&lt; T &gt; &gt; struct batt::detail::IsStatusOrImpl struct batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &gt; &gt; struct batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &amp; &gt; &gt; struct batt::RemoveStatusOrImpl struct batt::RemoveStatusOrImpl&lt; StatusOr&lt; T &gt; &gt; class batt::detail::NotOkStatusWrapper"},{"location":"_autogen/Files/status_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATUS_HPP BATT_REQUIRE_OK(expr) BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr) BATT_OK_RESULT_OR_PANIC(expr) BATT_CHECK_OK(expr) BATT_RETURN_OK_RESULT(statusor_expr)"},{"location":"_autogen/Files/status_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/status_8hpp/#define-batteries_status_hpp","title":"define BATTERIES_STATUS_HPP","text":"<pre><code>#define BATTERIES_STATUS_HPP()\n</code></pre>"},{"location":"_autogen/Files/status_8hpp/#define-batt_require_ok","title":"define BATT_REQUIRE_OK","text":"<pre><code>#define BATT_REQUIRE_OK(expr)\n</code></pre>"},{"location":"_autogen/Files/status_8hpp/#define-batt_assign_ok_result","title":"define BATT_ASSIGN_OK_RESULT","text":"<pre><code>#define BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr)\n</code></pre>"},{"location":"_autogen/Files/status_8hpp/#define-batt_ok_result_or_panic","title":"define BATT_OK_RESULT_OR_PANIC","text":"<pre><code>#define BATT_OK_RESULT_OR_PANIC(expr)\n</code></pre>"},{"location":"_autogen/Files/status_8hpp/#define-batt_check_ok","title":"define BATT_CHECK_OK","text":"<pre><code>#define BATT_CHECK_OK(expr)\n</code></pre>"},{"location":"_autogen/Files/status_8hpp/#define-batt_return_ok_result","title":"define BATT_RETURN_OK_RESULT","text":"<pre><code>#define BATT_RETURN_OK_RESULT(statusor_expr)\n</code></pre>"},{"location":"_autogen/Files/status_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATUS_HPP\n#define BATTERIES_STATUS_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;batteries/strong_typedef.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_GCC(\"-Woverloaded-virtual\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Woverloaded-virtual\")\n//\n#include &lt;boost/asio/error.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\nBATT_UNSUPPRESS_IF_GCC()\n#include &lt;boost/preprocessor/cat.hpp&gt;\n#include &lt;boost/system/error_code.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;cstring&gt;\n#include &lt;limits&gt;\n#include &lt;mutex&gt;\n#include &lt;string&gt;\n#include &lt;typeindex&gt;\n#include &lt;typeinfo&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nnamespace batt {\n#ifdef BATT_STATUS_CUSTOM_MESSSAGES\n#error This feature is not ready yet!\n#endif\nnamespace detail {\nclass StatusBase\n{\npublic:\nStatusBase() noexcept;\n};\n}  // namespace detail\n// Intentionally value-compatible with Abseil's StatusCode.\n//\nenum class StatusCode : int {\nkOk = 0,\nkCancelled = 1,\nkUnknown = 2,\nkInvalidArgument = 3,\nkDeadlineExceeded = 4,\nkNotFound = 5,\nkAlreadyExists = 6,\nkPermissionDenied = 7,\nkResourceExhausted = 8,\nkFailedPrecondition = 9,\nkAborted = 10,\nkOutOfRange = 11,\nkUnimplemented = 12,\nkInternal = 13,\nkUnavailable = 14,\nkDataLoss = 15,\nkUnauthenticated = 16,\n// ...\n// This range reserved for future allocation of Abseil status codes.\n// ...\nkClosed = 100,\nkGrantUnavailable = 101,\nkLoopBreak = 102,\nkEndOfStream = 103,\nkClosedBeforeEndOfStream = 104,\nkGrantRevoked = 105,\nkPoke = 106,\n};\nenum ErrnoValue {};\nenum StdGenericErrorCode {};\nenum StdFutureErrorCode {};\nenum StdSystemErrorCode {};\nenum StdIostreamErrorCode {};\nclass BATT_WARN_UNUSED_RESULT Status;\ntemplate &lt;typename T&gt;\nclass BATT_WARN_UNUSED_RESULT StatusOr;\ntemplate &lt;typename T&gt;\nconstexpr bool IsStatusEnum = std::is_enum_v&lt;T&gt; &amp;&amp;                                  //\n!boost::system::is_error_code_enum&lt;T&gt;::value &amp;&amp;       //\n!boost::system::is_error_condition_enum&lt;T&gt;::value &amp;&amp;  //\n!std::is_error_code_enum_v&lt;T&gt; &amp;&amp;                      //\n!std::is_error_condition_enum_v&lt;T&gt;;\nclass Status : private detail::StatusBase\n{\npublic:\nusing value_type = i32;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr i32 kGroupSizeBits = 12 /*-&gt; 4096*/;\nstatic constexpr i32 kGroupSize = i32{1} &lt;&lt; kGroupSizeBits;\nstatic constexpr i32 kMaxGroups = 0x7fffff00l - kGroupSize;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstruct ForceLookup {\n};\nstruct CodeEntry {\nvalue_type code;\nint enum_value;\nstd::string message;\n};\nstruct CodeGroup {\nstd::type_index enum_type_index{typeid(int)};\nusize index;\nint min_enum_value;\nstd::vector&lt;usize&gt; enum_value_to_code;\nstd::vector&lt;CodeEntry&gt; entries;\nconst char* name() const noexcept;\n};\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename EnumT&gt;\nstatic const CodeGroup&amp; code_group_for_type()\n{\nreturn code_group_for_type_internal&lt;EnumT&gt;();\n}\nstatic const std::string&amp; unknown_enum_value_message();\ntemplate &lt;typename EnumT&gt;\nstatic bool register_codes(const std::vector&lt;std::pair&lt;EnumT, std::string&gt;&gt;&amp; codes);\nstatic const CodeEntry&amp; get_entry_from_code(value_type value);\nstatic std::string_view message_from_code(value_type value);\nstatic usize get_index_of_group(value_type value);\nstatic usize get_index_within_group(value_type value);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// Construct a no-error status object.\n//\nStatus();\n// This is a regular copyable value type.\n//\nStatus(const Status&amp;) = default;\nStatus&amp; operator=(const Status&amp;) = default;\n// Implicitly convert enumerated types to Status.  The given type `EnumT` must have been registered\n// via `Status::register_codes` prior to invoking this constructor.\n//\ntemplate &lt;typename EnumT&gt;\n/*implicit*/ Status(ForceLookup, EnumT enum_value) noexcept\n{\nconst CodeGroup&amp; group = code_group_for_type&lt;EnumT&gt;();\nBATT_ASSERT_GE(static_cast&lt;int&gt;(enum_value), group.min_enum_value);\nconst int index_within_enum = static_cast&lt;int&gt;(enum_value) - group.min_enum_value;\nBATT_ASSERT_LT(index_within_enum, static_cast&lt;int&gt;(group.enum_value_to_code.size()))\n&lt;&lt; BATT_INSPECT(group.index) &lt;&lt; BATT_INSPECT(group.enum_type_index.name());\nthis-&gt;value_ = group.enum_value_to_code[index_within_enum];\nBATT_ASSERT_NOT_NULLPTR(message_from_code(this-&gt;value_).data());\n#ifdef BATT_ASSERT_CUSTOM_MESSSAGES\nconst usize index_within_group = get_index_within_group(this-&gt;value_);\nthis-&gt;message_ = group.entries[index_within_group].message;\n#endif\n}\ntemplate &lt;typename EnumT, typename = std::enable_if_t&lt;IsStatusEnum&lt;EnumT&gt;&gt;&gt;\n/*implicit*/ Status(EnumT enum_value) noexcept : Status{ForceLookup{}, enum_value}\n{\n}\ntemplate &lt;typename EnumT, typename = std::enable_if_t&lt;boost::system::is_error_code_enum&lt;EnumT&gt;::value&gt;,\ntypename = void&gt;\n/*implicit*/ Status(EnumT enum_value) noexcept;\ntemplate &lt;typename EnumT, typename = std::enable_if_t&lt;std::is_error_code_enum&lt;EnumT&gt;::value&gt;,\ntypename = void, typename = void&gt;\n/*implicit*/ Status(EnumT enum_value) noexcept;\n#ifdef BATT_STATUS_CUSTOM_MESSSAGES\ntemplate &lt;typename EnumT, typename = std::enable_if_t&lt;IsStatusEnum&lt;EnumT&gt;&gt;&gt;\nexplicit Status(EnumT enum_value, const std::string_view&amp; custom_message) noexcept : Status{enum_value}\n{\nthis-&gt;message_ = custom_message;\n}\n#endif\nStatus(const StatusOr&lt;NoneType&gt;&amp;) noexcept;\nStatus&amp; operator=(const StatusOr&lt;NoneType&gt;&amp;) noexcept;\nbool ok() const noexcept BATT_WARN_UNUSED_RESULT;\nvalue_type code() const noexcept;\nvalue_type code_index_within_group() const noexcept;\nconst CodeEntry&amp; code_entry() const noexcept;\nstd::string_view message() const noexcept;\nconst CodeGroup&amp; group() const;\nvalue_type group_index() const noexcept;\nvoid IgnoreError() const noexcept;\nvoid Update(const Status&amp; new_status);\nprivate:\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nfriend class detail::StatusBase;\nstatic constexpr usize kMaxGroupCount = 256;\nstatic constexpr i32 kMaxCodeNumericRange = 0xffff;\nstatic constexpr i32 kLocalMask = (i32{1} &lt;&lt; kGroupSizeBits) - 1;\nstatic constexpr i32 kGroupMask = ~kLocalMask;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic usize next_group_index();\nstatic std::array&lt;CodeGroup*, kMaxGroupCount&gt;&amp; registered_groups();\ntemplate &lt;typename EnumT&gt;\nstatic CodeGroup&amp; code_group_for_type_internal()\n{\nstatic CodeGroup group;\nreturn group;\n}\ntemplate &lt;typename EnumT&gt;\nstatic bool register_codes_internal(const std::vector&lt;std::pair&lt;EnumT, std::string&gt;&gt;&amp; codes);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// Unique error code;\n//\nvalue_type value_;\n#ifdef BATT_STATUS_CUSTOM_MESSSAGES\nstd::string_view message_;\n#endif\n};\nstatic_assert(sizeof(Status) &lt;= sizeof(void*), \"\");\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Print human-friendly representation of a Status.\n//\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Status&amp; t);\n// Equality comparison of `Status` values.\n//\nbool operator==(const Status&amp; l, const Status&amp; r);\nbool operator!=(const Status&amp; l, const Status&amp; r);\n// Returns a Status value `s` for which `s.ok() == true`.\n//\nStatus OkStatus();\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace detail {\ntemplate &lt;typename T&gt;\nclass StatusOrValueContainer\n{\npublic:\nusing Self = StatusOrValueContainer;\ntemplate &lt;typename... Args&gt;\nvoid construct(Args&amp;&amp;... args)\n{\nnew (&amp;this-&gt;storage_) T(BATT_FORWARD(args)...);\n}\nvoid construct(const Self&amp; that)\n{\nthis-&gt;construct(that.reference());\n}\nvoid construct(Self&amp;&amp; that)\n{\nthis-&gt;construct(std::move(that.reference()));\n}\nT* pointer() noexcept\n{\nreturn reinterpret_cast&lt;T*&gt;(&amp;this-&gt;storage_);\n}\nconst T* pointer() const noexcept\n{\nreturn reinterpret_cast&lt;const T*&gt;(&amp;this-&gt;storage_);\n}\nT&amp; reference() noexcept\n{\nreturn *this-&gt;pointer();\n}\nconst T&amp; reference() const noexcept\n{\nreturn *this-&gt;pointer();\n}\nvoid destroy()\n{\nthis-&gt;reference().~T();\n}\nprivate:\nstd::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; storage_;\n};\ntemplate &lt;typename T&gt;\nvoid emplace_none(StatusOrValueContainer&lt;T&gt;&amp;)\n{\n}\ninline void emplace_none(StatusOrValueContainer&lt;NoneType&gt;&amp; s)\n{\ns.construct(None);\n}\ntemplate &lt;typename T&gt;\nclass StatusOrValueContainer&lt;T&amp;&gt;\n{\npublic:\nusing Self = StatusOrValueContainer&lt;T&amp;&gt;;\nvoid construct(T&amp; value)\n{\nthis-&gt;ptr_ = &amp;value;\n}\nvoid construct(const Self&amp; that)\n{\nthis-&gt;ptr_ = that.ptr_;\n}\nvoid construct(Self&amp;&amp; that)\n{\nthis-&gt;ptr_ = that.ptr_;\n}\nT* pointer() const noexcept\n{\nreturn this-&gt;ptr_;\n}\nT&amp; reference() const noexcept\n{\nreturn *this-&gt;pointer();\n}\nvoid destroy() noexcept\n{\nthis-&gt;ptr_ = nullptr;\n}\nprivate:\nT* ptr_ = nullptr;\n};\n}  // namespace detail\ntemplate &lt;typename T&gt;\nclass StatusOr\n{\ntemplate &lt;typename U&gt;\nfriend class StatusOr;\npublic:\nusing value_type = T;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Constructors\nexplicit StatusOr() noexcept : status_{StatusCode::kUnknown}\n{\nBATT_ASSERT(!this-&gt;ok());\n}\n/*implicit*/ StatusOr(const Status&amp; s) : status_{s}\n{\nif (!std::is_same_v&lt;T, NoneType&gt;) {\nBATT_CHECK(!this-&gt;ok()) &lt;&lt; \"StatusOr must not be constructed with an Ok Status value.\";\n} else {\nif (s.ok()) {\ndetail::emplace_none(this-&gt;value_);\n}\n}\n}\nStatusOr(StatusOr&amp;&amp; that) : status_{StatusCode::kUnknown}\n{\nif (that.ok()) {\nthis-&gt;value_.construct(std::move(that.value_));\nthis-&gt;status_ = OkStatus();\nthat.value_.destroy();\nthat.status_ = StatusCode::kUnknown;\n} else {\nthis-&gt;status_ = std::move(that.status_);\n}\n}\nStatusOr(const StatusOr&amp; that) : status_{that.status_}\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.construct(that.value_);\n}\n}\n/*implicit*/ StatusOr(const std::decay_t&lt;T&gt;&amp; obj) noexcept(\nnoexcept(T(std::declval&lt;const std::decay_t&lt;T&gt;&amp;&gt;())))\n: status_{OkStatus()}\n{\nthis-&gt;value_.construct(obj);\n}\n/*implicit*/ StatusOr(std::decay_t&lt;T&gt;&amp; obj) noexcept(noexcept(T(std::declval&lt;std::decay_t&lt;T&gt;&amp;&gt;())))\n: status_{OkStatus()}\n{\nthis-&gt;value_.construct(obj);\n}\n/*implicit*/ StatusOr(std::decay_t&lt;T&gt;&amp;&amp; obj) noexcept(noexcept(T(std::declval&lt;std::decay_t&lt;T&gt;&amp;&amp;&gt;())))\n: status_{OkStatus()}\n{\nthis-&gt;value_.construct(std::move(obj));\n}\ntemplate &lt;\ntypename U, typename = EnableIfNoShadow&lt;StatusOr, U&amp;&amp;&gt;,\ntypename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp; std::is_constructible_v&lt;T, U&amp;&amp;&gt;&gt;,\ntypename = void&gt;\n/*implicit*/ StatusOr(U&amp;&amp; obj) noexcept(noexcept(T(std::declval&lt;U&amp;&amp;&gt;()))) : status_{OkStatus()}\n{\nthis-&gt;value_.construct(BATT_FORWARD(obj));\n}\ntemplate &lt;typename U, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp;\nstd::is_constructible_v&lt;T, U&amp;&amp;&gt;&gt;&gt;\n/*implicit*/ StatusOr(StatusOr&lt;U&gt;&amp;&amp; that) noexcept(noexcept(T(std::declval&lt;U&amp;&amp;&gt;())))\n: status_{StatusCode::kUnknown}\n{\nif (that.status_.ok()) {\nthis-&gt;value_.construct(std::move(that.value()));\nthis-&gt;status_ = OkStatus();\nthat.value_.destroy();\nthat.status_ = StatusCode::kUnknown;\n} else {\nthis-&gt;status_ = std::move(that).status();\n}\n}\ntemplate &lt;typename U, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp;\nstd::is_constructible_v&lt;T, const U&amp;&gt;&gt;&gt;\n/*implicit*/ StatusOr(const StatusOr&lt;U&gt;&amp; that) noexcept(noexcept(T(std::declval&lt;const U&amp;&gt;())))\n: status_{StatusCode::kUnknown}\n{\nif (that.status_.ok()) {\nnew (&amp;this-&gt;storage_) T(that.value());\nthis-&gt;status_ = OkStatus();\n} else {\nthis-&gt;status_ = that.status_;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Destructor\n~StatusOr()\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Assignment operator overloads\nStatusOr&amp; operator=(std::decay_t&lt;T&gt;&amp;&amp; obj)\n{\nstatic_assert(std::is_same_v&lt;T, std::decay_t&lt;T&gt;&gt;, \"\");\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\n}\nthis-&gt;status_ = OkStatus();\nthis-&gt;value_.construct(std::move(obj));\nreturn *this;\n}\nStatusOr&amp; operator=(const T&amp; obj)\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\n}\nthis-&gt;status_ = OkStatus();\nthis-&gt;value_.construct(obj);\nreturn *this;\n}\ntemplate &lt;typename U, typename = std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;U&gt;, T&gt; &amp;&amp;\nstd::is_constructible_v&lt;T, U&amp;&amp;&gt;&gt;&gt;\nStatusOr&amp; operator=(U&amp;&amp; obj) noexcept(noexcept(T(std::declval&lt;U&amp;&amp;&gt;())))\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\n}\nthis-&gt;status_ = OkStatus();\nthis-&gt;value_.construct(BATT_FORWARD(obj));\nreturn *this;\n}\nStatusOr&amp; operator=(const StatusOr&amp; that) noexcept(\nnoexcept(T(std::declval&lt;const T&amp;&gt;())) &amp;&amp; noexcept(std::declval&lt;T&amp;&gt;() = std::declval&lt;const T&amp;&gt;()))\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nif (this-&gt;ok()) {\nif (that.ok()) {\nthis-&gt;value() = that.value();\n} else {\nthis-&gt;value_.destroy();\n}\n} else {\nif (that.ok()) {\nthis-&gt;value_.construct(that.value());\n}\n}\nthis-&gt;status_ = that.status_;\n}\nreturn *this;\n}\nStatusOr&amp; operator=(StatusOr&amp;&amp; that) noexcept(\nnoexcept(T(std::declval&lt;T&amp;&amp;&gt;())) &amp;&amp; noexcept(std::declval&lt;T&amp;&gt;() = std::move(std::declval&lt;T&amp;&gt;())))\n{\nif (BATT_HINT_TRUE(this != &amp;that)) {\nif (this-&gt;ok()) {\nif (that.ok()) {\nthis-&gt;value() = std::move(that.value());\n} else {\nthis-&gt;value_.destroy();\n}\n} else {\nif (that.ok()) {\nthis-&gt;value_.construct(std::move(that.value()));\n}\n}\nthis-&gt;status_ = that.status_;\n}\nreturn *this;\n}\nStatusOr&amp; operator=(const Status&amp; new_status) noexcept\n{\nif (BATT_HINT_FALSE(&amp;new_status == &amp;this-&gt;status_)) {\nreturn *this;\n}\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\n}\nif (std::is_same_v&lt;T, NoneType&gt;) {\nif (new_status.ok()) {\ndetail::emplace_none(this-&gt;value_);\n}\n} else {\nBATT_CHECK(!new_status.ok()) &lt;&lt; \"StatusOr must not be constructed with an Ok Status value.\";\n}\nthis-&gt;status_ = new_status;\nreturn *this;\n}\ntemplate &lt;typename... Args&gt;\nvoid emplace(Args&amp;&amp;... args)\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\n}\nthis-&gt;value_.construct(BATT_FORWARD(args)...);\nthis-&gt;status_ = OkStatus();\n}\ntemplate &lt;typename U&gt;\nvoid emplace(StatusOr&lt;U&gt;&amp;&amp; that)\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\nthis-&gt;status_ = StatusCode::kUnknown;\n}\nif (that.ok()) {\nthis-&gt;value_.construct(std::move(*that));\n}\nthis-&gt;status_ = that.status();\n}\ntemplate &lt;typename U&gt;\nvoid emplace(const StatusOr&lt;U&gt;&amp; that)\n{\nif (this-&gt;ok()) {\nthis-&gt;value_.destroy();\nthis-&gt;status_ = StatusCode::kUnknown;\n}\nif (that.ok()) {\nthis-&gt;value_.construct(*that);\n}\nthis-&gt;status_ = that.status();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid IgnoreError() const noexcept\n{\n// do nothing\n}\nbool ok() const noexcept\n{\nreturn this-&gt;status_.ok();\n}\nconst Status&amp; status() const&amp;\n{\nreturn this-&gt;status_;\n}\nT&amp; value() noexcept\n{\nBATT_ASSERT(this-&gt;status_.ok()) &lt;&lt; BATT_INSPECT(this-&gt;status_);\nreturn this-&gt;value_.reference();\n}\nconst T&amp; value() const noexcept\n{\nBATT_ASSERT(this-&gt;status_.ok()) &lt;&lt; BATT_INSPECT(this-&gt;status_);\nreturn this-&gt;value_.reference();\n}\nT&amp; operator*() &amp; noexcept\n{\nreturn this-&gt;value();\n}\nconst T&amp; operator*() const&amp; noexcept\n{\nreturn this-&gt;value();\n}\nT operator*() &amp;&amp; noexcept\n{\nreturn std::move(this-&gt;value());\n}\nstd::add_const_t&lt;std::remove_reference_t&lt;T&gt;&gt;* operator-&gt;() const noexcept\n{\nreturn &amp;(this-&gt;value());\n}\nstd::remove_reference_t&lt;T&gt;* operator-&gt;() noexcept\n{\nreturn &amp;(this-&gt;value());\n}\nprivate:\nStatus status_;\ndetail::StatusOrValueContainer&lt;T&gt; value_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// StatusOr&lt;Status&gt; == Status.\n//\ntemplate &lt;&gt;\nclass StatusOr&lt;Status&gt; : public Status\n{\npublic:\nusing Status::Status;\n/*implicit*/ StatusOr(const Status&amp; status) : Status{status}\n{\n}\n/*implicit*/ StatusOr(Status&amp;&amp; status) : Status{std::move(status)}\n{\n}\n};\nstatic_assert(sizeof(Status) == sizeof(StatusOr&lt;Status&gt;), \"\");\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// StatusOr&lt;StatusOr&lt;T&gt;&gt; == StatusOr&lt;T&gt;\n//\ntemplate &lt;typename T&gt;\nclass StatusOr&lt;StatusOr&lt;T&gt;&gt; : public StatusOr&lt;T&gt;\n{\npublic:\nusing StatusOr&lt;T&gt;::StatusOr;\n/*implicit*/ StatusOr(const StatusOr&lt;T&gt;&amp; status_or) : StatusOr&lt;T&gt;{status_or}\n{\n}\n/*implicit*/ StatusOr(StatusOr&lt;T&gt;&amp;&amp; status_or) : StatusOr&lt;T&gt;{std::move(status_or)}\n{\n}\n};\nstatic_assert(sizeof(StatusOr&lt;StatusOr&lt;int&gt;&gt;) == sizeof(StatusOr&lt;int&gt;), \"\");\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T, typename U, typename = std::enable_if_t&lt;CanBeEqCompared&lt;T, U&gt;{}&gt;&gt;\ninline bool operator==(const StatusOr&lt;T&gt;&amp; l, const StatusOr&lt;U&gt;&amp; r)\n{\nreturn (l.ok() &amp;&amp; r.ok() &amp;&amp; l.value() == r.value()) || (!l.ok() &amp;&amp; !r.ok() &amp;&amp; l.status() == r.status());\n}\n// If `T` (and `U`) can't be equality-compared, then we define StatusOr&lt;T&gt; to be equal iff the non-ok status\n// values are equal.\n//\ntemplate &lt;typename T, typename U, typename = std::enable_if_t&lt;!CanBeEqCompared&lt;T, U&gt;{}&gt;, typename = void&gt;\ninline bool operator==(const StatusOr&lt;T&gt;&amp; l, const StatusOr&lt;U&gt;&amp; r)\n{\nreturn (!l.ok() &amp;&amp; !r.ok() &amp;&amp; l.status() == r.status());\n}\ntemplate &lt;typename T, typename U&gt;\ninline bool operator!=(const StatusOr&lt;T&gt;&amp; l, const StatusOr&lt;U&gt;&amp; r)\n{\nreturn !(l == r);\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace detail {\ntemplate &lt;typename T&gt;\nstruct IsStatusOrImpl : std::false_type {\n};\ntemplate &lt;typename T&gt;\nstruct IsStatusOrImpl&lt;StatusOr&lt;T&gt;&gt; : std::true_type {\n};\ntemplate &lt;typename T&gt;\nstruct IsStatusOrImpl&lt;StatusOr&lt;T&amp;&gt;&gt; : std::true_type {\n};\n}  // namespace detail\ntemplate &lt;typename T&gt;\nusing IsStatusOr = detail::IsStatusOrImpl&lt;std::decay_t&lt;T&gt;&gt;;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nstruct RemoveStatusOrImpl : batt::StaticType&lt;T&gt; {\n};\ntemplate &lt;typename T&gt;\nstruct RemoveStatusOrImpl&lt;StatusOr&lt;T&gt;&gt; : batt::StaticType&lt;T&gt; {\n};\ntemplate &lt;typename T&gt;\nusing RemoveStatusOr = typename RemoveStatusOrImpl&lt;std::decay_t&lt;T&gt;&gt;::type;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nbool is_ok_status(const std::error_code&amp; ec);\ntemplate &lt;typename T&gt;\nbool is_ok_status(const T&amp; val)\n{\nreturn val.ok();\n}\nenum struct LogLevel {\nkFatal,\nkError,\nkWarning,\nkInfo,\nkDebug,\nkVerbose,\n};\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, LogLevel t);\nstd::atomic&lt;LogLevel&gt;&amp; require_fail_global_default_log_level();\nOptional&lt;LogLevel&gt;&amp; require_fail_thread_default_log_level();\nnamespace detail {\nclass NotOkStatusWrapper\n{\npublic:\nexplicit NotOkStatusWrapper(usize this_size, const char* file, int line, const Status&amp; status,\nbool vlog_is_on\n#if BATT_WITH_GLOG\n= false\n#endif  // BATT_WITH_GLOG\n) noexcept;\n~NotOkStatusWrapper() noexcept;\noperator Status() noexcept;\ntemplate &lt;typename T&gt;\noperator StatusOr&lt;T&gt;() noexcept\n{\nreturn StatusOr&lt;T&gt;{std::move(this-&gt;status_)};\n}\nNotOkStatusWrapper&amp; operator&lt;&lt;(LogLevel new_level);\ntemplate &lt;typename T&gt;\nNotOkStatusWrapper&amp; operator&lt;&lt;(T&amp;&amp; val)\n{\nthis-&gt;output_ &lt;&lt; BATT_FORWARD(val);\nreturn *this;\n}\nprivate:\n// The source file from which this object was created.\n//\nconst char* file_;\n// The source line from which tihs object was created.\n//\nint line_;\n// The error status code.\n//\nStatus status_;\n// Whether or not vlog is enabled.\n//\nbool vlog_is_on_;\n// The log level at which to report the error status.\n//\nLogLevel level_{require_fail_thread_default_log_level().or_else([] {\nreturn require_fail_global_default_log_level().load();\n})};\n// The error message for the log.\n//\nstd::ostringstream output_;\n};\n}  // namespace detail\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nStatus status_from_errno(int code);\ntemplate &lt;typename T,\ntypename = std::enable_if_t&lt;IsStatusOr&lt;T&gt;{} &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusOr&lt;Status&gt;&gt;&gt;&gt;\ninline decltype(auto) to_status(T&amp;&amp; v)\n{\nreturn BATT_FORWARD(v).status();\n}\ntemplate &lt;typename T,\ntypename = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, Status&gt; ||\nstd::is_same_v&lt;std::decay_t&lt;T&gt;, StatusOr&lt;Status&gt;&gt;&gt;,\ntypename = void&gt;\ninline decltype(auto) to_status(T&amp;&amp; s)\n{\nreturn BATT_FORWARD(s);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nnamespace detail {\nstd::unordered_map&lt;const boost::system::error_category*, const std::unordered_map&lt;int, Status&gt;&gt;&amp;\nthread_local_error_category_status_map();\nstd::mutex&amp; global_error_category_status_map_mutex();\nstd::unordered_map&lt;const boost::system::error_category*, const std::unordered_map&lt;int, Status&gt;&gt;&amp;\nglobal_error_category_status_map();\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n}  // namespace detail\ntemplate &lt;typename EnumT&gt;\n[[maybe_unused]] bool register_error_category(const boost::system::error_category&amp; category,\nconst std::vector&lt;EnumT&gt;&amp; codes, batt::StaticType&lt;EnumT&gt; = {})\n{\nstatic_assert(std::is_enum_v&lt;EnumT&gt;, \"The code value type must be an enum\");\nstatic bool result_ = [&amp;category, &amp;codes] {\n{\nstd::vector&lt;std::pair&lt;EnumT, std::string&gt;&gt; codes_with_message;\nfor (const EnumT&amp; code : codes) {\ncodes_with_message.emplace_back(code, category.message(static_cast&lt;int&gt;(code)));\n}\nStatus::register_codes(codes_with_message);\n}\nstd::unordered_map&lt;int, Status&gt; category_map;\nfor (const EnumT&amp; code : codes) {\ncategory_map.emplace(static_cast&lt;int&gt;(code), Status{Status::ForceLookup{}, code});\n}\n// Add the map of codes to Status values to the global cache.\n{\nstd::unique_lock&lt;std::mutex&gt; lock{detail::global_error_category_status_map_mutex()};\ndetail::global_error_category_status_map().emplace(&amp;category, std::move(category_map));\n}\nreturn true;\n}();\nreturn result_;\n}\nStatus status_from_error_category(const boost::system::error_category&amp; category, int code);\nStatus status_from_error_code(const boost::system::error_code&amp; ec);\nStatus error_code_to_status(const std::error_code&amp; ec);\nStatus error_code_to_status(const boost::system::error_code&amp; ec);\ntemplate &lt;typename T,\ntypename = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, std::error_code&gt; ||\nstd::is_same_v&lt;std::decay_t&lt;T&gt;, boost::system::error_code&gt;&gt;,\ntypename = void, typename = void&gt;\ninline Status to_status(const T&amp; ec)\n{\nreturn error_code_to_status(ec);\n}\ntemplate &lt;typename T,\ntypename = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::basic_errors&gt; ||\nstd::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::netdb_errors&gt; ||\nstd::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::addrinfo_errors&gt; ||\nstd::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::misc_errors&gt;&gt;,\ntypename = void, typename = void, typename = void&gt;\ninline Status to_status(T&amp;&amp; code_value)\n{\nreturn to_status(boost::system::error_code(code_value));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// clang-format off\n#define BATT_REQUIRE_OK(expr)                                                                                \\\n    for (auto&amp;&amp; BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__) = (expr);                              \\\n         !::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__));)                      \\\n        return ::batt::detail::NotOkStatusWrapper                                                            \\\n        {                                                                                                    \\\n            sizeof(::batt::detail::NotOkStatusWrapper), __FILE__, __LINE__,                                  \\\n                ::batt::to_status(BATT_FORWARD(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__))),      \\\n                BATT_VLOG_IS_ON(1)                                                                           \\\n        }\n// clang-format on\n#define BATT_ASSIGN_OK_RESULT(lvalue_expr, statusor_expr)                                                    \\\n    auto BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__) = statusor_expr;                            \\\n    BATT_REQUIRE_OK(BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__));                                \\\n    lvalue_expr = std::move(*BOOST_PP_CAT(BATTERIES_temp_StatusOr_result_, __LINE__))\n#define BATT_OK_RESULT_OR_PANIC(expr)                                                                        \\\n    [&amp;](auto&amp;&amp; expr_value) {                                                                                 \\\n        BATT_CHECK(::batt::is_ok_status(expr_value))                                                         \\\n            &lt;&lt; BOOST_PP_STRINGIZE(expr) &lt;&lt; \".status == \" &lt;&lt; ::batt::to_status(expr_value);                   \\\n        return std::move(*BATT_FORWARD(expr_value));                                                         \\\n    }((expr))\n// clang-format off\n#define BATT_CHECK_OK(expr)                                                                                  \\\n    if (bool BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__) = true)                                        \\\n        for (auto&amp;&amp; BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__) = (expr);                            \\\n             BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__);                                               \\\n             BOOST_PP_CAT(BATTERIES_check_ok_flag_, __LINE__) = false)                                       \\\n            for (; !BATT_HINT_TRUE(                                                                          \\\n                       ::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__))) &amp;&amp;         \\\n                   BATT_HINT_TRUE(::batt::lock_fail_check_mutex());                                          \\\n                 ::batt::fail_check_exit())                                                                  \\\n    BATT_FAIL_CHECK_MESSAGE(\"batt::to_status(\" BOOST_PP_STRINGIZE(expr) \")\",                                 \\\n                            ::batt::to_status(BOOST_PP_CAT(BATTERIES_check_expr_value_, __LINE__)),          \\\n                            \"==\", \"batt::OkStatus()\", ::batt::OkStatus(),                                    \\\n                            __FILE__, __LINE__, BATT_THIS_FUNCTION)\n#define BATT_RETURN_OK_RESULT(statusor_expr)                                                                 \\\n    for (auto&amp;&amp; BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__) = (statusor_expr);                              \\\n         ::batt::is_ok_status(BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__));)                       \\\n        return std::move(*BOOST_PP_CAT(BATTERIES_temp_status_result_, __LINE__))\n// clang-format on\ninline Status status_from_errno(int code)\n{\nif (BATT_HINT_FALSE(code &gt;= Status::kGroupSize || code &lt; 0)) {\nBATT_LOG_WARNING() &lt;&lt; \"Truncating invalid errno value: \" &lt;&lt; code &lt;&lt; \" (=&gt; \"\n&lt;&lt; (Status::kGroupSize - 1) &lt;&lt; \")\";\ncode = Status::kGroupSize - 1;\n}\nreturn static_cast&lt;ErrnoValue&gt;(code);\n}\ntemplate &lt;typename T&gt;\ninline Status status_from_retval(T retval)\n{\nif (retval &gt;= 0) {\nreturn OkStatus();\n}\nreturn status_from_errno(errno);\n}\ntemplate &lt;typename T&gt;\ninline T&amp;&amp; ok_result_or_panic(StatusOr&lt;T&gt;&amp;&amp; result)\n{\nBATT_CHECK(result.ok()) &lt;&lt; result.status();\nreturn std::move(*result);\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;IsStatusOr&lt;std::decay_t&lt;T&gt;&gt;{} &amp;&amp;\n!std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusOr&lt;Status&gt;&gt;&gt;&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, T&amp;&amp; status_or)\n{\nif (!status_or.ok()) {\nreturn out &lt;&lt; \"Status{\" &lt;&lt; status_or.status() &lt;&lt; \"}\";\n}\nreturn out &lt;&lt; \"Ok{\" &lt;&lt; make_printable(*status_or) &lt;&lt; \"}\";\n}\nbool status_is_retryable(const Status&amp; s);\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\ntemplate &lt;typename EnumT&gt;\ninline bool Status::register_codes(const std::vector&lt;std::pair&lt;EnumT, std::string&gt;&gt;&amp; codes)\n{\nstatic detail::StatusBase base;\nreturn register_codes_internal&lt;EnumT&gt;(codes);\n}\ntemplate &lt;typename EnumT&gt;\ninline bool Status::register_codes_internal(const std::vector&lt;std::pair&lt;EnumT, std::string&gt;&gt;&amp; codes)\n{\nstatic bool exactly_once = [&amp;]() -&gt; bool {\n[&amp;] {\nCodeGroup group;\ngroup.enum_type_index = std::type_index{typeid(EnumT)};\ngroup.index = next_group_index();\nBATT_CHECK_LT(group.index, kMaxGroups) &lt;&lt; \"Status::register_codes called too many times!\";\nif (codes.empty()) {\nreturn;\n}\nint min_enum_value = std::numeric_limits&lt;int&gt;::max();\nint max_enum_value = std::numeric_limits&lt;int&gt;::min();\nStatus::value_type next_code = group.index * kGroupSize;\nfor (auto&amp; [value, message] : codes) {\nconst int enum_value = static_cast&lt;int&gt;(value);\nmin_enum_value = std::min(min_enum_value, enum_value);\nmax_enum_value = std::max(max_enum_value, enum_value);\ngroup.entries.emplace_back(CodeEntry{\nnext_code,\nenum_value,\nstd::move(message),\n});\nnext_code += 1;\n}\nBATT_CHECK_LE(max_enum_value - min_enum_value, kMaxCodeNumericRange)\n&lt;&lt; \"The maximum numeric range of codes was exceeded.  min_enum_value=\" &lt;&lt; min_enum_value\n&lt;&lt; \" max_enum_value=\" &lt;&lt; max_enum_value;\ngroup.min_enum_value = min_enum_value;\ngroup.enum_value_to_code.resize(max_enum_value - min_enum_value + 1);\nstd::fill(group.enum_value_to_code.begin(), group.enum_value_to_code.end(), next_code);\nfor (const CodeEntry&amp; e : group.entries) {\ngroup.enum_value_to_code[e.enum_value - group.min_enum_value] = e.code;\n}\n// Insert an entry at the end of the group for all unknown values.\n//\ngroup.entries.emplace_back(\nCodeEntry{next_code, max_enum_value + 1, unknown_enum_value_message()});\n// Atomically insert the new code group.\n//\nCodeGroup&amp; global_group = Status::code_group_for_type_internal&lt;EnumT&gt;();\nBATT_CHECK(global_group.entries.empty()) &lt;&lt; \"A status code group may only be registered once!\";\nglobal_group = std::move(group);\n/*std::array&lt;CodeGroup*, ...&gt;*/ auto&amp; all_groups = Status::registered_groups();\nBATT_CHECK_LT(global_group.index, all_groups.size());\nall_groups[global_group.index] = &amp;global_group;\n// Done!\n}();\nreturn true;\n}();\nreturn exactly_once;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename EnumT, typename, typename&gt;\ninline /*implicit*/ Status::Status(EnumT enum_value) noexcept\n: Status{to_status(boost::system::error_code{enum_value})}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename EnumT, typename, typename, typename&gt;\ninline /*implicit*/ Status::Status(EnumT enum_value) noexcept : Status{to_status(std::error_code{enum_value})}\n{\n}\n}  // namespace batt\n#endif  // BATTERIES_STATUS_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/status_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/status__impl_8hpp/","title":"batteries/status_impl.hpp","text":""},{"location":"_autogen/Files/status__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/status__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATUS_IMPL_HPP"},{"location":"_autogen/Files/status__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/status__impl_8hpp/#define-batteries_status_impl_hpp","title":"define BATTERIES_STATUS_IMPL_HPP","text":"<pre><code>#define BATTERIES_STATUS_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/status__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATUS_IMPL_HPP\n#define BATTERIES_STATUS_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/hint.hpp&gt;\n#include &lt;batteries/no_destruct.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;future&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const char* Status::CodeGroup::name() const noexcept\n{\nreturn name_of(this-&gt;enum_type_index);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ const std::string&amp; Status::unknown_enum_value_message()\n{\nstatic const NoDestruct&lt;std::string&gt; s{\n\"(Unknown enum value; not registered via batt::Status::register_codes)\"};\nreturn *s;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ const Status::CodeEntry&amp; Status::get_entry_from_code(value_type value)\n{\nconst usize index_of_group = Status::get_index_of_group(value);\nconst usize index_within_group = Status::get_index_within_group(value);\nconst auto&amp; all_groups = Status::registered_groups();\nif (BATT_HINT_FALSE(!(index_of_group &lt; all_groups.size()) ||\n!(index_within_group &lt; all_groups[index_of_group]-&gt;entries.size()))) {\nif (!fail_check_exit_entered().exchange(true)) {\nBATT_PANIC() &lt;&lt; BATT_INSPECT(value)                      //\n&lt;&lt; BATT_INSPECT(index_of_group)             //\n&lt;&lt; BATT_INSPECT(all_groups.size())          //\n&lt;&lt; BATT_INSPECT((isize)index_of_group)      //\n&lt;&lt; BATT_INSPECT((isize)index_within_group)  //\n;\n}\nreturn all_groups[0]-&gt;entries[0];\n}\nreturn all_groups[index_of_group]-&gt;entries[index_within_group];\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ std::string_view Status::message_from_code(value_type value)\n{\nreturn Status::get_entry_from_code(value).message;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::Status() : Status(StatusCode::kOk)\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool Status::ok() const noexcept BATT_WARN_UNUSED_RESULT\n{\nreturn (this-&gt;value_ &amp; kLocalMask) == 0;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::value_type Status::code() const noexcept\n{\nreturn this-&gt;value_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::value_type Status::code_index_within_group() const noexcept\n{\nreturn Status::get_index_within_group(this-&gt;value_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const Status::CodeEntry&amp; Status::code_entry() const noexcept\n{\nreturn Status::get_entry_from_code(this-&gt;value_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::string_view Status::message() const noexcept\n{\n#ifdef BATT_STATUS_CUSTOM_MESSSAGES\nreturn this-&gt;message_;\n#else\nreturn message_from_code(this-&gt;value_);\n#endif\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::value_type Status::group_index() const noexcept\n{\nreturn get_index_of_group(this-&gt;value_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL const Status::CodeGroup&amp; Status::group() const\n{\nconst usize index_of_group = get_index_of_group(this-&gt;value_);\nconst auto&amp; all_groups = registered_groups();\nBATT_CHECK_LT(index_of_group, all_groups.size());\nBATT_ASSERT_NOT_NULLPTR(all_groups[index_of_group]);\nreturn *all_groups[index_of_group];\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Status::IgnoreError() const noexcept\n{\n// do nothing\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Status::Update(const Status&amp; new_status)\n{\nif (this-&gt;ok() || *this == Status{StatusCode::kUnknown}) {\n*this = new_status;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ usize Status::next_group_index()\n{\nstatic NoDestruct&lt;std::atomic&lt;i32&gt;&gt; next_index{0};\nconst usize i = next_index-&gt;fetch_add(1);\nBATT_CHECK_LT(i, kMaxGroupCount);\nreturn i;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ std::array&lt;Status::CodeGroup*, Status::kMaxGroupCount&gt;&amp;\nStatus::registered_groups()\n{\nstatic NoDestruct&lt;std::array&lt;CodeGroup*, kMaxGroupCount&gt;&gt; all_groups;\n[[maybe_unused]] static bool initialized = [] {\nall_groups-&gt;fill(nullptr);\nreturn true;\n}();\nreturn *all_groups;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ usize Status::get_index_of_group(value_type value)\n{\nreturn (value &amp; kGroupMask) &gt;&gt; kGroupSizeBits;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ usize Status::get_index_within_group(value_type value)\n{\nreturn value &amp; kLocalMask;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Status&amp; t)\n{\nreturn out &lt;&lt; t.group_index() &lt;&lt; \".\" &lt;&lt; t.code_index_within_group() &lt;&lt; \":\" &lt;&lt; t.message();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool operator==(const Status&amp; l, const Status&amp; r)\n{\nreturn l.code() == r.code() || (l.ok() &amp;&amp; r.ok());\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool operator!=(const Status&amp; l, const Status&amp; r)\n{\nreturn !(l == r);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status OkStatus()\n{\nreturn Status{};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL detail::StatusBase::StatusBase() noexcept\n{\n[[maybe_unused]] static bool initialized = [] {\nStatus::register_codes_internal&lt;StatusCode&gt;({\n{StatusCode::kOk, \"Ok\"},\n{StatusCode::kCancelled, \"Cancelled\"},\n{StatusCode::kUnknown, \"Unknown\"},\n{StatusCode::kInvalidArgument, \"Invalid Argument\"},\n{StatusCode::kDeadlineExceeded, \"Deadline Exceeded\"},\n{StatusCode::kNotFound, \"Not Found\"},\n{StatusCode::kAlreadyExists, \"Already Exists\"},\n{StatusCode::kPermissionDenied, \"Permission Denied\"},\n{StatusCode::kResourceExhausted, \"Resource Exhausted\"},\n{StatusCode::kFailedPrecondition, \"Failed Precondition\"},\n{StatusCode::kAborted, \"Aborted\"},\n{StatusCode::kOutOfRange, \"Out of Range\"},\n{StatusCode::kUnimplemented, \"Unimplemented\"},\n{StatusCode::kInternal, \"Internal\"},\n{StatusCode::kUnavailable, \"Unavailable\"},\n{StatusCode::kDataLoss, \"Data Loss\"},\n{StatusCode::kUnauthenticated, \"Unauthenticated\"},\n//\n{StatusCode::kClosed, \"Closed\"},\n{StatusCode::kGrantUnavailable, \"The requested grant count exceeds available count\"},\n{StatusCode::kLoopBreak, \"Loop break\"},\n{StatusCode::kEndOfStream, \"End of stream\"},\n{StatusCode::kClosedBeforeEndOfStream, \"The stream was closed before the end of data\"},\n{StatusCode::kGrantRevoked, \"The Grant was revoked\"},\n{StatusCode::kPoke, \"The observed object was poked\"},\n});\nstd::vector&lt;std::pair&lt;ErrnoValue, std::string&gt;&gt; errno_codes;\nfor (int code = 0; code &lt; Status::kGroupSize; ++code) {\nconst char* msg = std::strerror(code);\nif (msg) {\nerrno_codes.emplace_back(static_cast&lt;ErrnoValue&gt;(code), std::string(msg));\n} else {\nerrno_codes.emplace_back(static_cast&lt;ErrnoValue&gt;(code), std::string(\"(unknown)\"));\n}\n}\nreturn Status::register_codes_internal&lt;ErrnoValue&gt;(errno_codes);\n}();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool is_ok_status(const std::error_code&amp; ec)\n{\nreturn !ec;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, LogLevel t)\n{\nswitch (t) {\ncase LogLevel::kFatal:\nreturn out &lt;&lt; \"LogLevel::kFatal\";\ncase LogLevel::kError:\nreturn out &lt;&lt; \"LogLevel::kError\";\ncase LogLevel::kWarning:\nreturn out &lt;&lt; \"LogLevel::kWarning\";\ncase LogLevel::kInfo:\nreturn out &lt;&lt; \"LogLevel::kInfo\";\ncase LogLevel::kDebug:\nreturn out &lt;&lt; \"LogLevel::kDebug\";\ncase LogLevel::kVerbose:\nreturn out &lt;&lt; \"LogLevel::kVerbose\";\ndefault:\nbreak;\n}\nreturn out &lt;&lt; \"(Bad LogLevel value:\" &lt;&lt; (int)t &lt;&lt; \")\";\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::atomic&lt;LogLevel&gt;&amp; require_fail_global_default_log_level()\n{\nstatic std::atomic&lt;LogLevel&gt; global_default_{LogLevel::kVerbose};\nreturn global_default_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Optional&lt;LogLevel&gt;&amp; require_fail_thread_default_log_level()\n{\nthread_local Optional&lt;LogLevel&gt; per_thread_default_;\nreturn per_thread_default_;\n}\nnamespace detail {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ NotOkStatusWrapper::NotOkStatusWrapper(usize this_size, const char* file,\nint line, const Status&amp; status,\nbool vlog_is_on) noexcept\n: file_{file}\n, line_{line}\n, status_(status)\n, vlog_is_on_{vlog_is_on}\n{\nBATT_CHECK_EQ(sizeof(NotOkStatusWrapper), this_size);\n#if BATT_WITH_GLOG\nthis-&gt;output_ &lt;&lt; \"(\" &lt;&lt; this-&gt;file_ &lt;&lt; \":\" &lt;&lt; this-&gt;line_ &lt;&lt; \") \" &lt;&lt; this-&gt;status_ &lt;&lt; \"; \";\n#endif  // BATT_WITH_GLOG\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL NotOkStatusWrapper::~NotOkStatusWrapper() noexcept\n{\n#if BATT_WITH_GLOG\nswitch (this-&gt;level_) {\ncase LogLevel::kFatal:\n::google::LogMessage(this-&gt;file_, this-&gt;line_, google::GLOG_FATAL).stream() &lt;&lt; this-&gt;output_.str();\nbreak;\ncase LogLevel::kError:\n::google::LogMessage(this-&gt;file_, this-&gt;line_, google::GLOG_ERROR).stream() &lt;&lt; this-&gt;output_.str();\nbreak;\ncase LogLevel::kWarning:\n::google::LogMessage(this-&gt;file_, this-&gt;line_, google::GLOG_WARNING).stream() &lt;&lt; this-&gt;output_.str();\nbreak;\ncase LogLevel::kInfo:\n::google::LogMessage(this-&gt;file_, this-&gt;line_, google::GLOG_INFO).stream() &lt;&lt; this-&gt;output_.str();\nbreak;\ncase LogLevel::kDebug:\nDLOG(INFO) &lt;&lt; \" [\" &lt;&lt; this-&gt;file_ &lt;&lt; \":\" &lt;&lt; this-&gt;line_ &lt;&lt; \"] \" &lt;&lt; this-&gt;output_.str();\nbreak;\ncase LogLevel::kVerbose:\nif (this-&gt;vlog_is_on_) {\n::google::LogMessage(this-&gt;file_, this-&gt;line_, google::GLOG_INFO).stream() &lt;&lt; this-&gt;output_.str();\n}\nbreak;\n}\n#endif  // BATT_WITH_GLOG\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL NotOkStatusWrapper::operator Status() noexcept\n{\nreturn std::move(this-&gt;status_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL NotOkStatusWrapper&amp; NotOkStatusWrapper::operator&lt;&lt;(LogLevel new_level)\n{\nthis-&gt;level_ = new_level;\nreturn *this;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL\nstd::unordered_map&lt;const boost::system::error_category*, const std::unordered_map&lt;int, Status&gt;&gt;&amp;\nthread_local_error_category_status_map()\n{\nthread_local std::unordered_map&lt;const boost::system::error_category*,\nconst std::unordered_map&lt;int, Status&gt;&gt;\nthread_cache_;\nreturn thread_cache_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL std::mutex&amp; global_error_category_status_map_mutex()\n{\nstatic NoDestruct&lt;std::mutex&gt; mutex_;\nreturn *mutex_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL\nstd::unordered_map&lt;const boost::system::error_category*, const std::unordered_map&lt;int, Status&gt;&gt;&amp;\nglobal_error_category_status_map()\n{\nstatic NoDestruct&lt;\nstd::unordered_map&lt;const boost::system::error_category*, const std::unordered_map&lt;int, Status&gt;&gt;&gt;\nglobal_cache_;\nreturn *global_cache_;\n}\n}  //namespace detail\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status status_from_error_category(const boost::system::error_category&amp; category, int code)\n{\n// First check in the thread-local cache for the given category.\n//\nauto&amp; thread_cache = detail::thread_local_error_category_status_map();\nauto iter = thread_cache.find(&amp;category);\nif (iter != thread_cache.end()) {\n//  The category was found in the local cache; look up the code value.\n//\nauto iter2 = iter-&gt;second.find(code);\nif (iter2 != iter-&gt;second.end()) {\nreturn iter2-&gt;second;\n}\n}\n// Fall back on the global cache.  To access this, we need to grab the mutex.\n{\nstd::unique_lock&lt;std::mutex&gt; lock{detail::global_error_category_status_map_mutex()};\nauto&amp; global_cache = detail::global_error_category_status_map();\nauto iter2 = global_cache.find(&amp;category);\nif (iter2 != global_cache.end()) {\n//  We found the category in the global cache; add it to the thread cache and retry.\n//\nthread_cache.emplace(*iter2);\nreturn status_from_error_category(category, code);\n}\n}\n// This code wasn't registered for this category, or the category wasn't found.  Return `kUnknown`.\n//\nreturn StatusCode::kUnknown;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status status_from_error_code(const boost::system::error_code&amp; ec)\n{\nreturn status_from_error_category(ec.category(), ec.value());\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status error_code_to_status(const boost::system::error_code&amp; ec)\n{\nif (!ec) {\nreturn OkStatus();\n}\nif (&amp;(ec.category()) == &amp;(boost::asio::error::get_misc_category())) {\nswitch (ec.value()) {\ncase boost::asio::error::eof:\nreturn Status{StatusCode::kEndOfStream};\ncase boost::asio::error::not_found:\nreturn Status{StatusCode::kNotFound};\ndefault:\nbreak;\n}\n} else if (&amp;(ec.category()) == &amp;(boost::asio::error::get_system_category())) {\nswitch (ec.value()) {\ncase boost::asio::error::access_denied:\nreturn status_from_errno(EACCES);\ncase boost::asio::error::address_family_not_supported:\nreturn status_from_errno(EAFNOSUPPORT);\ncase boost::asio::error::address_in_use:\nreturn status_from_errno(EADDRINUSE);\ncase boost::asio::error::already_connected:\nreturn status_from_errno(EISCONN);\ncase boost::asio::error::already_started:\nreturn status_from_errno(EALREADY);\ncase boost::asio::error::broken_pipe:\n// TODO [tastolfi 2022-12-16] On Windows: ERROR_BROKEN_PIPE\nreturn status_from_errno(EPIPE);\ncase boost::asio::error::connection_aborted:\nreturn status_from_errno(ECONNABORTED);\ncase boost::asio::error::connection_refused:\nreturn status_from_errno(ECONNREFUSED);\ncase boost::asio::error::connection_reset:\nreturn status_from_errno(ECONNRESET);\ncase boost::asio::error::bad_descriptor:\nreturn status_from_errno(EBADF);\ncase boost::asio::error::fault:\nreturn status_from_errno(EFAULT);\ncase boost::asio::error::host_unreachable:\nreturn status_from_errno(EHOSTUNREACH);\ncase boost::asio::error::in_progress:\nreturn status_from_errno(EINPROGRESS);\ncase boost::asio::error::interrupted:\nreturn status_from_errno(EINTR);\ncase boost::asio::error::invalid_argument:\nreturn status_from_errno(EINVAL);\ncase boost::asio::error::message_size:\nreturn status_from_errno(EMSGSIZE);\ncase boost::asio::error::name_too_long:\nreturn status_from_errno(ENAMETOOLONG);\ncase boost::asio::error::network_down:\nreturn status_from_errno(ENETDOWN);\ncase boost::asio::error::network_reset:\nreturn status_from_errno(ENETRESET);\ncase boost::asio::error::network_unreachable:\nreturn status_from_errno(ENETUNREACH);\ncase boost::asio::error::no_descriptors:\nreturn status_from_errno(EMFILE);\ncase boost::asio::error::no_buffer_space:\nreturn status_from_errno(ENOBUFS);\ncase boost::asio::error::no_memory:\n// TODO [tastolfi 2022-12-16] Windows: ERROR_OUTOFMEMORY\nreturn status_from_errno(ENOMEM);\ncase boost::asio::error::no_permission:\n// TODO [tastolfi 2022-12-16] Windows: ERROR_ACCESS_DENIED\nreturn status_from_errno(EPERM);\ncase boost::asio::error::no_protocol_option:\nreturn status_from_errno(ENOPROTOOPT);\ncase boost::asio::error::no_such_device:\n// TODO [tastolfi 2022-12-16] Windows: ERROR_BAD_UNIT\nreturn status_from_errno(ENODEV);\ncase boost::asio::error::not_connected:\nreturn status_from_errno(ENOTCONN);\ncase boost::asio::error::not_socket:\nreturn status_from_errno(ENOTSOCK);\ncase boost::asio::error::operation_aborted:\n// TODO [tastolfi 2022-12-16] Windows: ERROR_OPERATION_ABORTED\nreturn status_from_errno(ECANCELED);\ncase boost::asio::error::operation_not_supported:\nreturn status_from_errno(EOPNOTSUPP);\n#ifndef BATT_PLATFORM_IS_WINDOWS\ncase boost::asio::error::shut_down:\nreturn status_from_errno(ESHUTDOWN);\n#endif  // BATT_PLATFORM_IS_WINDOWS\ncase boost::asio::error::timed_out:\nreturn status_from_errno(ETIMEDOUT);\ncase boost::asio::error::try_again:\n// TODO [tastolfi 2022-12-16] Windows: ERROR_RETRY\nreturn status_from_errno(EAGAIN);\n#if !defined(__linux__) &amp;&amp; !defined(__APPLE__)\n#if EAGAIN != EWOULDBLOCK\ncase boost::asio::error::would_block:\nreturn status_from_errno(EWOULDBLOCK);\n#endif\n#endif  // __linux__\ndefault:\nbreak;\n}\n}\nreturn status_from_error_code(ec);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status error_code_to_status(const std::error_code&amp; ec)\n{\nstatic const std::error_category* std_generic_category = std::addressof(std::generic_category());\nstatic const std::error_category* std_system_category = std::addressof(std::system_category());\nstatic const std::error_category* std_future_category = std::addressof(std::future_category());\nstatic const std::error_category* std_iostream_category = std::addressof(std::iostream_category());\n[[maybe_unused]] static const bool initialized = [] {\nconst auto register_std_error_category = [](auto code_enum_type,\nconst std::error_category* category) {\nusing CodeEnumT = typename decltype(code_enum_type)::type;\nstd::vector&lt;std::pair&lt;CodeEnumT, std::string&gt;&gt; code_table;\nfor (int i = 0; i &lt; Status::kGroupSize; ++i) {\nstd::error_code ec(i, *category);\ncode_table.emplace_back(static_cast&lt;CodeEnumT&gt;(i), ec.message());\n}\nreturn Status::register_codes&lt;CodeEnumT&gt;(code_table);\n};\nreturn register_std_error_category(StaticType&lt;StdGenericErrorCode&gt;{}, std_generic_category) &amp;&amp;    //\nregister_std_error_category(StaticType&lt;StdSystemErrorCode&gt;{}, std_system_category) &amp;&amp;      //\nregister_std_error_category(StaticType&lt;StdFutureErrorCode&gt;{}, std_future_category) &amp;&amp;      //\nregister_std_error_category(StaticType&lt;StdIostreamErrorCode&gt;{}, std_iostream_category) &amp;&amp;  //\ntrue;\n}();\nif (!ec) {\nreturn OkStatus();\n}\nconst std::error_category* category = std::addressof(ec.category());\nif (category == std_generic_category) {\nreturn Status{static_cast&lt;StdGenericErrorCode&gt;(ec.value())};\n} else if (category == std_system_category) {\nreturn Status{static_cast&lt;StdSystemErrorCode&gt;(ec.value())};\n} else if (category == std_future_category) {\nreturn Status{static_cast&lt;StdFutureErrorCode&gt;(ec.value())};\n} else if (category == std_iostream_category) {\nreturn Status{static_cast&lt;StdIostreamErrorCode&gt;(ec.value())};\n}\nreturn Status{StatusCode::kInternal};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool status_is_retryable(const Status&amp; s)\n{\nreturn s == StatusCode::kUnavailable            //\n|| s == static_cast&lt;ErrnoValue&gt;(EAGAIN)  //\n|| s == static_cast&lt;ErrnoValue&gt;(EINTR)   //\n|| s == StatusCode::kPoke                //\n;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status::Status(const StatusOr&lt;NoneType&gt;&amp; status_or) noexcept : Status{status_or.status()}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status&amp; Status::operator=(const StatusOr&lt;NoneType&gt;&amp; status_or) noexcept\n{\n*this = status_or.status();\nreturn *this;\n}\n}  // namespace batt\n#endif  // BATTERIES_STATUS_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/status__ok_8hpp/","title":"batteries/seq/status_ok.hpp","text":""},{"location":"_autogen/Files/status__ok_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/status__ok_8hpp/#classes","title":"Classes","text":"Name class batt::seq::StatusOk struct batt::seq::StatusOkBinder"},{"location":"_autogen/Files/status__ok_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_STATUS_OK_HPP"},{"location":"_autogen/Files/status__ok_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/status__ok_8hpp/#define-batteries_seq_status_ok_hpp","title":"define BATTERIES_SEQ_STATUS_OK_HPP","text":"<pre><code>#define BATTERIES_SEQ_STATUS_OK_HPP()\n</code></pre>"},{"location":"_autogen/Files/status__ok_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_STATUS_OK_HPP\n#define BATTERIES_SEQ_STATUS_OK_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\ntemplate &lt;typename SeqT&gt;\nclass StatusOk\n{\npublic:\nusing Item = std::decay_t&lt;RemoveStatusOr&lt;SeqItem&lt;SeqT&gt;&gt;&gt;;\ntemplate &lt;typename... Args, typename = batt::EnableIfNoShadow&lt;StatusOk, Args...&gt;&gt;\nexplicit StatusOk(Args&amp;&amp;... args) noexcept : seq_(BATT_FORWARD(args)...)\n{\n}\nbool ok() const\n{\nreturn this-&gt;status_.ok();\n}\nconst Status&amp; status() const&amp;\n{\nreturn this-&gt;status_;\n}\nStatus status() &amp;&amp;\n{\nreturn std::move(this-&gt;status_);\n}\nOptional&lt;Item&gt; peek()\n{\nreturn this-&gt;unwrap_item(this-&gt;seq_.peek());\n}\nOptional&lt;Item&gt; next()\n{\nreturn this-&gt;unwrap_item(this-&gt;seq_.next());\n}\nprivate:\nOptional&lt;Item&gt; unwrap_item(Optional&lt;SeqItem&lt;SeqT&gt;&gt;&amp;&amp; item)\n{\nif (!item) {\nreturn None;\n}\nif (!item-&gt;ok()) {\nthis-&gt;status_.Update(item-&gt;status());\nreturn None;\n}\nreturn **item;\n}\nSeqT seq_;\nStatus status_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstruct StatusOkBinder {\n};\ninline auto status_ok()\n{\nreturn StatusOkBinder{};\n}\ntemplate &lt;typename SeqT&gt;\ninline StatusOk&lt;SeqT&gt; operator|(SeqT&amp;&amp; seq, StatusOkBinder)\n{\nstatic_assert(std::is_same_v&lt;SeqT, std::decay_t&lt;SeqT&gt;&gt;,\n\"status_ok() must not be used with an lvalue reference\");\nreturn StatusOk&lt;SeqT&gt;{BATT_FORWARD(seq)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_STATUS_OK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/","title":"batteries/state_machine_model/stochastic_model_checker.hpp","text":""},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#classes","title":"Classes","text":"Name class batt::StochasticModelChecker"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#define-batteries_state_machine_model_stochastic_model_checker_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP()\n</code></pre>"},{"location":"_autogen/Files/stochastic__model__checker_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/state_machine_model/parallel_model_check_state.hpp&gt;\n#include &lt;batteries/state_machine_model/verbose.hpp&gt;\n#include &lt;chrono&gt;\n#include &lt;random&gt;\nnamespace batt {\ntemplate &lt;typename ModelT&gt;\nclass StochasticModelChecker\n{\npublic:\nusing Branch = typename ModelT::Branch;\nusing BranchDelta = typename Branch::delta_type;\nusing VisitResult = typename ModelT::VisitResult;\nexplicit StochasticModelChecker(typename ModelT::Base&amp; model,\ndetail::ParallelModelCheckState&lt;Branch&gt;&amp; mesh, usize shard_i) noexcept\n: model_{model}\n, n_shards_{mesh.shard_count}\n, shard_i_{shard_i}\n, starting_seed_{model.advanced_options().starting_seed.value_or(shard_i)}\n{\nthis-&gt;model_.set_entropy(StateMachineEntropySource{[this](usize min_value, usize max_value) -&gt; usize {\nif (min_value == max_value) {\nreturn min_value;\n}\nBATT_CHECK_LT(min_value, max_value);\nstd::uniform_int_distribution&lt;usize&gt; pick_random_value{min_value, max_value};\nconst usize value = pick_random_value(this-&gt;rng_);\nconst usize radix = max_value - min_value + 1;\nthis-&gt;branch_delta_.push(radix, value - min_value);\nreturn value;\n}});\n}\n~StochasticModelChecker() noexcept\n{\n}\nStateMachineResult run()\n{\nauto start_time = std::chrono::steady_clock::now();\nconst i64 min_running_time_ms = this-&gt;model_.advanced_options().min_running_time_ms;\nauto running_time_sufficient = [&amp;] {\nconst auto elapsed_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(\nstd::chrono::steady_clock::now() - start_time)\n.count();\nBATT_STATE_MACHINE_VERBOSE() &lt;&lt; BATT_INSPECT(elapsed_ms);\nreturn elapsed_ms &gt;= min_running_time_ms;\n};\nusize seed = this-&gt;starting_seed_;\nthis-&gt;rng_.seed(seed);\nStateMachineResult result;\nresult.start_time = start_time;\nresult.ok = true;\nconst auto initial_state = this-&gt;model_.normalize(this-&gt;model_.initialize());\nauto current_state = initial_state;\nthis-&gt;model_.visit(initial_state, /*src_branch=*/Branch{\n.snapshot = initial_state,\n.delta = BranchDelta{},\n});\nresult.state_count += 1;\n// We keep exploring random states until we reach the minimum time limit.\n//\nwhile (!running_time_sufficient()) {\n// Tell the model we are entering the current state.\n//\nthis-&gt;model_.enter_state(current_state);\nthis-&gt;branch_delta_ = BranchDelta{};\nBATT_CHECK(this-&gt;branch_delta_.empty());\n// Step the model.\n//\nthis-&gt;model_.step();\n// Make sure invariants are OK.\n//\nif (!this-&gt;model_.check_invariants()) {\nresult.seed = seed;\nresult.ok = false;\nbreak;\n}\n// Retrieve the next state.\n//\nconst auto next_state = this-&gt;model_.normalize(this-&gt;model_.leave_state());\n// If this state is novel, record that fact.\n//\nif (this-&gt;model_.visit(next_state, /*src_branch=*/Branch{\n.snapshot = current_state,\n.delta = this-&gt;branch_delta_,\n}) == VisitResult::kFirstTime) {\nBATT_STATE_MACHINE_VERBOSE()\n&lt;&lt; BATT_INSPECT(this-&gt;n_shards_) &lt;&lt; BATT_INSPECT(min_running_time_ms)\n&lt;&lt; BATT_INSPECT(seed) &lt;&lt; BATT_INSPECT(make_printable(next_state));\nresult.state_count += 1;\n}\n// If the current state is terminal (i.e., the branch delta is empty), then go back to the initial\n// state and continue with a new seed value.\n//\nconst bool terminal_state_reached =\n(this-&gt;branch_delta_ == BranchDelta{}) || (current_state == next_state);\nBATT_CHECK_EQ(this-&gt;branch_delta_ == BranchDelta{}, this-&gt;branch_delta_.empty());\nBATT_CHECK_IMPLIES(this-&gt;branch_delta_.empty(), current_state == next_state)\n&lt;&lt; BATT_INSPECT(make_printable(next_state)) &lt;&lt; BATT_INSPECT(make_printable(current_state));\nif (terminal_state_reached) {\ncurrent_state = initial_state;\nseed += this-&gt;n_shards_;\nthis-&gt;rng_.seed(seed);\n} else {\ncurrent_state = next_state;\nresult.branch_push_count += 1;\nresult.branch_pop_count += 1;\nresult.self_branch_count += 1;\n}\n}\nresult.update_elapsed_time();\nreturn result;\n}\nprivate:\ntypename ModelT::Base&amp; model_;\nusize n_shards_;\nusize shard_i_;\nusize starting_seed_;\nBranchDelta branch_delta_;\nstd::default_random_engine rng_{(u32)this-&gt;shard_i_};\n};\n}  // namespace batt\n#endif  // BATTERIES_STATE_MACHINE_MODEL_STOCHASTIC_MODEL_CHECKER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/stream__buffer_8cpp/","title":"batteries/async/stream_buffer.cpp","text":""},{"location":"_autogen/Files/stream__buffer_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n//\n#include &lt;batteries/async/stream_buffer_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/stream__buffer_8hpp/","title":"batteries/async/stream_buffer.hpp","text":""},{"location":"_autogen/Files/stream__buffer_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/stream__buffer_8hpp/#classes","title":"Classes","text":"Name class batt::StreamBuffer"},{"location":"_autogen/Files/stream__buffer_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_STREAM_BUFFER_HPP"},{"location":"_autogen/Files/stream__buffer_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stream__buffer_8hpp/#define-batteries_async_stream_buffer_hpp","title":"define BATTERIES_ASYNC_STREAM_BUFFER_HPP","text":"<pre><code>#define BATTERIES_ASYNC_STREAM_BUFFER_HPP()\n</code></pre>"},{"location":"_autogen/Files/stream__buffer_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_STREAM_BUFFER_HPP\n#define BATTERIES_ASYNC_STREAM_BUFFER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/types.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/asio/any_io_executor.hpp&gt;\n#include &lt;batteries/asio/system_executor.hpp&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nclass StreamBuffer\n{\npublic:\nstatic constexpr usize kTempBufferSize = 512;\nusing executor_type = boost::asio::any_io_executor;\n// Creates a new stream buffer large enough to hold `capacity` bytes of data.\n//\nexplicit StreamBuffer(usize capacity) noexcept;\n// Calls `this-&gt;close()`.\n//\n~StreamBuffer() noexcept;\n// The maximum number of bytes that this buffer can hold.\n//\nusize capacity() const;\n// The current number of bytes available as consumable data.\n//\nusize size() const;\n// The current number of bytes available as committable buffer space.\n//\nusize space() const;\n// The executor associated with this stream buffer.\n//\nexecutor_type get_executor() const\n{\nreturn this-&gt;executor_;\n}\n// Returns a MutableBufferSequence that is exactly `exact_count` bytes large.\n//\n// This method may block the current task if buffer space is not available to satisfy the request.  It\n// will unblock once enough data has been trimmed from the buffer via `consume()`, or if this object is\n// closed for reading.\n//\n// If an `exact_count` that exceeds `this-&gt;capacity()` is passed, then this method will immediately return\n// a StatusCode::kInvalidArgument result.\n//\nStatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt;&gt; prepare_exactly(i64 exact_count);\n// Like `prepare_exactly`, except that this method will return as soon as `this-&gt;space()` is at least\n// `min_count` bytes, and the returned MutableBufferSequence will be as large as possible.\n//\nStatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt;&gt; prepare_at_least(i64 min_count);\n// Invokes the passed handler with a MutableBufferSequence as soon as at least `min_count` free bytes can\n// be allocated within the buffer.\n//\ntemplate &lt;typename Handler = void(const ErrorCode&amp; ec, SmallVec&lt;MutableBuffer, 2&gt;)&gt;\nvoid async_prepare_at_least(i64 min_count, Handler&amp;&amp; handler);\n// Logically transfer `count` bytes of data from the \"prepared\" region of the buffer to the \"committed\"\n// region, by advancing the commit offset pointer.  This method does not literally copy data.  Behavior is\n// undefined if `count &gt; this-&gt;space()`.\n//\nvoid commit(i64 count);\n// Prepare enough space in the buffer to make a byte-for-byte copy of `value` in the buffer, copy the\n// value, and do the equivalent of `this-&gt;commit(sizeof(T))`.  `T` must be safe to copy via `memcpy`,\n// otherwise behavior is undefined.\n//\ntemplate &lt;typename T&gt;\nStatus write_type(StaticType&lt;T&gt;, const T&amp; value);\n// Copy at least 1 byte of the passed data to the buffer and then invoke the handler with the number of\n// bytes written.\n//\ntemplate &lt;typename ConstBuffers, typename Handler = void(const ErrorCode&amp; ec, usize n_bytes_written)&gt;\nvoid async_write_some(ConstBuffers&amp;&amp; buffers, Handler&amp;&amp; handler);\n// Convenience shortcut for `prepare_exactly`, copy the data, then `commit`.\n//\nStatus write_all(ConstBuffer buffer);\n// Unblocks any current and future calls to `fetch_at_least` (and all other fetch/read methods).  This\n// signals to the buffer (and all other clients of this object) that no more data will be\n// written/committed.\n//\nvoid close_for_write();\n// Returns a ConstBufferSequence containing at least `min_count` bytes of data.\n//\n// This method may block the current task if there isn't enough committed data in the buffer to satisfy\n// the request (i.e., if `this-&gt;size() &lt; min_count`).\n//\n// If `min_count` that exceeds `this-&gt;capacity()` is passed, then this method will immediately return\n// a StatusCode::kInvalidArgument result.\n//\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; fetch_at_least(i64 min_count);\n// Frees the specified number of bytes at the beginning of the \"committed\" region of the buffer, making\n// that buffer space available for current or future calls to `prepare_exactly` or `prepare_at_least`.\n//\nvoid consume(i64 count);\n// Returns the next sizeof(T) bytes of the stream as a reference to `const T`.  If the stream forces T to\n// be split over the end of the buffer, then a reference to a copy of the data is returned.  The\n// referenced data is valid until the next call to `fetch_type` or `consume`.\n//\ntemplate &lt;typename T&gt;\nStatusOr&lt;std::reference_wrapper&lt;const T&gt;&gt; fetch_type(StaticType&lt;T&gt; = {});\n// Consumes sizeof(T) bytes from the stream.\n//\ntemplate &lt;typename T&gt;\nvoid consume_type(StaticType&lt;T&gt; = {});\n// Reads and returns a single value of type T from the stream, copying byte-for-byte as if by memcpy.\n//\n// Behavior is undefined if it is unsafe to copy values of type T in this manner.\n//\ntemplate &lt;typename T&gt;\nStatusOr&lt;T&gt; read_type(StaticType&lt;T&gt; = {});\n// Unblocks any current and future calls to `prepare_at_least` (and all other fetch/read methods).  This\n// signals to the buffer (and all other clients of this object) that no more data will be read/consumed.\n//\nvoid close_for_read();\n// Shortcut for `this-&gt;close_for_read()` and `this-&gt;close_for_write()`.\n//\nvoid close();\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename BufferType&gt;\nSmallVec&lt;BufferType, 2&gt; get_buffers(i64 offset, i64 count, StaticType&lt;BufferType&gt; buffer_type = {});\ntemplate &lt;typename BufferType, typename GetMaxCount&gt;\nStatusOr&lt;SmallVec&lt;BufferType, 2&gt;&gt; pre_transfer(i64 min_count, Watch&lt;i64&gt;&amp; fixed_pos,\nWatch&lt;i64&gt;&amp; moving_pos, i64 min_delta,\nconst GetMaxCount&amp; get_max_count,\nWaitForResource wait_for_resource,\nStaticType&lt;BufferType&gt; buffer_type = {},\ni64* moving_pos_observed = nullptr);\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexecutor_type executor_ = boost::asio::system_executor();\n// The size in bytes of the array pointed to by `buffer_`.\n//\ni64 capacity_;\n// Points to the buffer for this object.\n//\nstd::unique_ptr&lt;u8[]&gt; buffer_;\n// A temporary buffer so that we can make sure the first buffer always holds at least the min_count.\n//\nSmallVec&lt;u8, kTempBufferSize&gt; tmp_buffer_;\n// The offset from the beginning of the stream that represents the upper bound of read data.  This value\n// increases monotonically beyond `this-&gt;capacity_`; the implementation must find the true consume\n// position within the buffer by taking this value modulo `this-&gt;capacity_`.\n//\nWatch&lt;i64&gt; consume_pos_;\n// The offset from the beginning of the stream that represents the upper bound of written data.  This\n// value increases monotonically beyond `this-&gt;capacity_`; the implementation must find the true commit\n// position within the buffer by taking this value modulo `this-&gt;capacity_`.\n//\nWatch&lt;i64&gt; commit_pos_;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\nStatusOr&lt;std::reference_wrapper&lt;StreamBuffer&gt;&gt; operator&lt;&lt;(\nStatusOr&lt;std::reference_wrapper&lt;StreamBuffer&gt;&gt; stream_buffer, T&amp;&amp; obj);\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_STREAM_BUFFER_HPP\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/stream_buffer_impl.hpp&gt;\n#endif\n#include &lt;batteries/async/stream_buffer.ipp&gt;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/","title":"batteries/async/stream_buffer_impl.hpp","text":""},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#define-batteries_async_stream_buffer_impl_hpp","title":"define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/stream__buffer__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP\n#define BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*explicit*/ StreamBuffer::StreamBuffer(usize capacity) noexcept\n: capacity_{BATT_CHECKED_CAST(i64, capacity)}\n, buffer_{new u8[capacity]}\n, consume_pos_{0}\n, commit_pos_{0}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StreamBuffer::~StreamBuffer() noexcept\n{\nthis-&gt;close();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize StreamBuffer::capacity() const\n{\nreturn static_cast&lt;usize&gt;(this-&gt;capacity_);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize StreamBuffer::size() const\n{\nreturn BATT_CHECKED_CAST(usize, this-&gt;commit_pos_.get_value() - this-&gt;consume_pos_.get_value());\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize StreamBuffer::space() const\n{\nreturn this-&gt;capacity() - this-&gt;size();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt;&gt; StreamBuffer::prepare_exactly(i64 exact_count)\n{\nreturn this-&gt;pre_transfer(\n/*min_count=*/exact_count,\n/*fixed_pos=*/this-&gt;commit_pos_,\n/*moving_pos=*/this-&gt;consume_pos_,\n/*min_delta=*/exact_count - this-&gt;capacity(), /*get_max_count=*/\n[exact_count] {\nreturn exact_count;\n},\nWaitForResource::kTrue,  //\nStaticType&lt;MutableBuffer&gt;{});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt;&gt; StreamBuffer::prepare_at_least(i64 min_count)\n{\nreturn this-&gt;pre_transfer(\n/*min_count=*/min_count,\n/*fixed_pos=*/this-&gt;commit_pos_,\n/*moving_pos=*/this-&gt;consume_pos_,\n/*min_delta=*/min_count - this-&gt;capacity(), /*get_max_count=*/\n[this] {\nreturn BATT_CHECKED_CAST(i64, this-&gt;space());\n},\nWaitForResource::kTrue,  //\nStaticType&lt;MutableBuffer&gt;{});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void StreamBuffer::commit(i64 count)\n{\nthis-&gt;commit_pos_.fetch_add(count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Status StreamBuffer::write_all(ConstBuffer buffer)\n{\nwhile (buffer.size() &gt; 0) {\nStatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt;&gt; prepared = this-&gt;prepare_at_least(1);\nBATT_REQUIRE_OK(prepared);\nconst usize n_copied = boost::asio::buffer_copy(*prepared, buffer);\nthis-&gt;commit(n_copied);\nbuffer += n_copied;\n}\nreturn OkStatus();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void StreamBuffer::close_for_write()\n{\nthis-&gt;commit_pos_.close(StatusCode::kEndOfStream);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL StatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; StreamBuffer::fetch_at_least(i64 min_count)\n{\nconst usize min_count_z = BATT_CHECKED_CAST(usize, min_count);\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt;&gt; buffers = this-&gt;pre_transfer(\n/*min_count=*/min_count,\n/*fixed_pos=*/this-&gt;consume_pos_,\n/*moving_pos=*/this-&gt;commit_pos_,\n/*min_delta=*/min_count, /*get_max_count=*/\n[this] {\nreturn BATT_CHECKED_CAST(i64, this-&gt;size());\n},\nWaitForResource::kTrue,  //\nStaticType&lt;ConstBuffer&gt;{});\nBATT_REQUIRE_OK(buffers);\n// Guarantee that the first buffer contains at least `min_count` bytes.  This is done so that retry-style\n// parsers don't have to implement this themselves.\n//\nif (buffers-&gt;size() &gt; 1 &amp;&amp; buffers-&gt;front().size() &lt; min_count_z) {\nthis-&gt;tmp_buffer_.reserve(min_count_z);\nconst usize n_copied =\nboost::asio::buffer_copy(MutableBuffer{this-&gt;tmp_buffer_.data(), min_count_z}, *buffers);\nBATT_CHECK_EQ(n_copied, min_count_z);\nBATT_CHECK_EQ(buffers-&gt;size(), 2u);\nbuffers-&gt;back() += min_count - buffers-&gt;front().size();\nif (buffers-&gt;back().size() == 0) {\nbuffers-&gt;pop_back();\n}\nbuffers-&gt;front() = ConstBuffer{this-&gt;tmp_buffer_.data(), n_copied};\n}\nreturn buffers;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void StreamBuffer::consume(i64 count)\n{\nthis-&gt;consume_pos_.fetch_add(count);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void StreamBuffer::close_for_read()\n{\nthis-&gt;consume_pos_.close();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void StreamBuffer::close()\n{\nthis-&gt;close_for_read();\nthis-&gt;close_for_write();\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_STREAM_BUFFER_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/","title":"batteries/protobuf/stream_buffer_input_stream.hpp","text":""},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#defines","title":"Defines","text":"Name BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#define-batteries_protobuf_stream_buffer_input_stream_hpp","title":"define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP","text":"<pre><code>#define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP()\n</code></pre>"},{"location":"_autogen/Files/stream__buffer__input__stream_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP\n#define BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_WITH_PROTOBUF\n#error This header may only be included if BATT_WITH_PROTOBUF == 1\n#else  // BATT_WITH_PROTOBUF\n#include &lt;google/protobuf/io/zero_copy_stream.h&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;algorithm&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nclass StreamBufferInputStream : public google::protobuf::io::ZeroCopyInputStream\n{\npublic:\nexplicit StreamBufferInputStream(StreamBuffer&amp; buffer) noexcept : buffer_{buffer}\n{\n}\n~StreamBufferInputStream() noexcept\n{\nthis-&gt;consume_data();\n}\n// Obtains a chunk of data from the stream.\n//\nbool Next(const void** data, int* size) override\n{\nBATT_ASSERT_NOT_NULLPTR(data);\nBATT_ASSERT_NOT_NULLPTR(size);\nOptional&lt;ConstBuffer&gt; next = this-&gt;fetch_next();\nif (!next) {\nreturn false;\n}\n*data = next-&gt;data();\n*size = BATT_CHECKED_CAST(int, next-&gt;size());\nreturn true;\n}\n// Backs up a number of bytes, so that the next call to Next() returns data again that was already\n// returned by the last call to Next().\n//\nvoid BackUp(int count) override\n{\nBATT_CHECK_LE(count, this-&gt;n_to_consume_);\nthis-&gt;n_to_consume_ -= count;\nthis-&gt;byte_count_ -= count;\n}\n// Skips a number of bytes.\n//\nbool Skip(int count) override\n{\nwhile (count &gt; 0) {\nconst void* data = nullptr;\nint size = 0;\nbool result = this-&gt;Next(&amp;data, &amp;size);\nif (!result || size == 0) {\nreturn false;\n}\nif (size &gt; count) {\nthis-&gt;BackUp(size - count);\ncount = 0;\n} else {\ncount -= size;\n}\n}\nreturn true;\n}\n// Returns the total number of bytes read since this object was created.\n//\ni64 ByteCount() const override\n{\nreturn this-&gt;byte_count_;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid consume_data()\n{\nif (this-&gt;n_to_consume_ &gt; 0) {\ni64 n = 0;\nstd::swap(n, this-&gt;n_to_consume_);\nthis-&gt;buffer_.consume(n);\n}\n}\nprivate:\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nOptional&lt;ConstBuffer&gt; fetch_next()\n{\nthis-&gt;consume_data();\nStatusOr&lt;SmallVec&lt;ConstBuffer, 2&gt; &gt; fetched = this-&gt;buffer_.fetch_at_least(1);\nif (!fetched.ok()) {\nreturn None;\n}\nConstBuffer&amp; next = fetched-&gt;front();\nthis-&gt;n_to_consume_ = next.size();\nthis-&gt;byte_count_ += next.size();\nreturn next;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStreamBuffer&amp; buffer_;\ni64 byte_count_ = 0;\ni64 n_to_consume_ = 0;\n};\n}  // namespace batt\n#endif  // BATT_WITH_PROTOBUF\n#endif  // BATTERIES_PROTOBUF_STREAM_BUFFER_INPUT_STREAM_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/","title":"batteries/protobuf/stream_buffer_output_stream.hpp","text":""},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#defines","title":"Defines","text":"Name BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#define-batteries_protobuf_stream_buffer_output_stream_hpp","title":"define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP","text":"<pre><code>#define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP()\n</code></pre>"},{"location":"_autogen/Files/stream__buffer__output__stream_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP\n#define BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_WITH_PROTOBUF\n#error This header may only be included if BATT_WITH_PROTOBUF == 1\n#else  // BATT_WITH_PROTOBUF\n#include &lt;google/protobuf/io/zero_copy_stream.h&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/stream_buffer.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/checked_cast.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/small_vec.hpp&gt;\n#include &lt;algorithm&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nclass StreamBufferOutputStream : public google::protobuf::io::ZeroCopyOutputStream\n{\npublic:\nexplicit StreamBufferOutputStream(StreamBuffer&amp; buffer) noexcept : buffer_{buffer}\n{\n}\n~StreamBufferOutputStream() noexcept\n{\nthis-&gt;commit_data();\n}\n// Obtains a buffer into which data can be written.\n//\nbool Next(void** data, int* size) override\n{\nBATT_ASSERT_NOT_NULLPTR(data);\nBATT_ASSERT_NOT_NULLPTR(size);\nOptional&lt;MutableBuffer&gt; next = this-&gt;prepare_next();\nif (!next) {\nreturn false;\n}\n*data = next-&gt;data();\n*size = BATT_CHECKED_CAST(int, next-&gt;size());\nreturn true;\n}\n// Backs up a number of bytes, so that the end of the last buffer returned by Next() is not actually\n// written.\n//\nvoid BackUp(int count) override\n{\nBATT_CHECK_LE(count, this-&gt;n_to_commit_);\nthis-&gt;n_to_commit_ -= count;\nthis-&gt;byte_count_ -= count;\n}\n// Returns the total number of bytes written since this object was created.\n//\ni64 ByteCount() const override\n{\nreturn this-&gt;byte_count_;\n}\n// Write a given chunk of data to the output.\n//\nbool WriteAliasedRaw(const void* /*data*/, int /*size*/) override\n{\nBATT_PANIC() &lt;&lt; \"Not supported\";\nreturn false;\n}\nbool AllowsAliasing() const override\n{\n// TODO [tastolfi 2022-02-24] support this.\nreturn false;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nvoid commit_data()\n{\nif (this-&gt;n_to_commit_ &gt; 0) {\ni64 n = 0;\nstd::swap(n, this-&gt;n_to_commit_);\nthis-&gt;buffer_.commit(n);\n}\n}\nprivate:\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nOptional&lt;MutableBuffer&gt; prepare_next()\n{\nthis-&gt;commit_data();\nStatusOr&lt;SmallVec&lt;MutableBuffer, 2&gt; &gt; prepared = this-&gt;buffer_.prepare_at_least(1);\nif (!prepared.ok()) {\nreturn None;\n}\nMutableBuffer&amp; next = prepared-&gt;front();\nthis-&gt;n_to_commit_ = next.size();\nthis-&gt;byte_count_ += next.size();\nreturn next;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStreamBuffer&amp; buffer_;\ni64 byte_count_ = 0;\ni64 n_to_commit_ = 0;\n};\n}  // namespace batt\n#endif  // BATT_WITH_PROTOBUF\n#endif  // BATTERIES_PROTOBUF_STREAM_BUFFER_OUTPUT_STREAM_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/stream__util_8hpp/","title":"batteries/stream_util.hpp","text":""},{"location":"_autogen/Files/stream__util_8hpp/#namespaces","title":"Namespaces","text":"Name std batt batt::detail"},{"location":"_autogen/Files/stream__util_8hpp/#classes","title":"Classes","text":"Name struct batt::EscapedStringLiteral struct batt::HexByteDumper struct batt::SizeDumper Wrapper around <code>usize</code> (<code>std::size_t</code>) that prints as human-readable sizes. class batt::RangeDumper"},{"location":"_autogen/Files/stream__util_8hpp/#defines","title":"Defines","text":"Name BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type) BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type) BATT_INSPECT_STR(expr) BATT_INSPECT_RANGE(expr) BATT_INSPECT_RANGE_PRETTY(expr)"},{"location":"_autogen/Files/stream__util_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/stream__util_8hpp/#define-batt_detail_overload_string_printable","title":"define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE","text":"<pre><code>#define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type)\n</code></pre>"},{"location":"_autogen/Files/stream__util_8hpp/#define-batt_detail_specialize_string_printable","title":"define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE","text":"<pre><code>#define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type)\n</code></pre>"},{"location":"_autogen/Files/stream__util_8hpp/#define-batt_inspect_str","title":"define BATT_INSPECT_STR","text":"<pre><code>#define BATT_INSPECT_STR(expr)\n</code></pre>"},{"location":"_autogen/Files/stream__util_8hpp/#define-batt_inspect_range","title":"define BATT_INSPECT_RANGE","text":"<pre><code>#define BATT_INSPECT_RANGE(expr)\n</code></pre>"},{"location":"_autogen/Files/stream__util_8hpp/#define-batt_inspect_range_pretty","title":"define BATT_INSPECT_RANGE_PRETTY","text":"<pre><code>#define BATT_INSPECT_RANGE_PRETTY(expr)\n</code></pre>"},{"location":"_autogen/Files/stream__util_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/constants.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/operators.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;boost/algorithm/string.hpp&gt;\n#include &lt;boost/io/ios_state.hpp&gt;\n#include &lt;array&gt;\n#include &lt;atomic&gt;\n#include &lt;charconv&gt;\n#include &lt;filesystem&gt;\n#include &lt;iomanip&gt;\n#include &lt;optional&gt;\n#include &lt;ostream&gt;\n#include &lt;sstream&gt;\nnamespace std {\n// =============================================================================\n// Support printing for std::optional&lt;T&gt;.\n//\ntemplate &lt;typename T&gt;\ninline ostream&amp; operator&lt;&lt;(ostream&amp; out, const optional&lt;T&gt;&amp; t)\n{\nif (t) {\nreturn out &lt;&lt; *t;\n}\nreturn out &lt;&lt; \"{}\";\n}\n// =============================================================================\n// Support insertion of lambdas and other callables that take a std::ostream&amp;.\n//\ntemplate &lt;typename Fn, typename = enable_if_t&lt;::batt::IsCallable&lt;Fn, ostream&amp;&gt;{}&gt;&gt;\ninline ostream&amp; operator&lt;&lt;(ostream&amp; out, Fn&amp;&amp; fn)\n{\nfn(out);\nreturn out;\n}\n}  // namespace std\nnamespace batt {\n// =============================================================================\n// print_all - insert all arguments to the stream.\n//\ninline std::ostream&amp; print_all(std::ostream&amp; out)\n{\nreturn out;\n}\ntemplate &lt;typename First, typename... Rest&gt;\nstd::ostream&amp; print_all(std::ostream&amp; out, First&amp;&amp; first, Rest&amp;&amp;... rest)\n{\nreturn print_all(out &lt;&lt; BATT_FORWARD(first), BATT_FORWARD(rest)...);\n}\n// =============================================================================\n// extract_all - extract all arguments to the stream.\n//\ninline std::istream&amp; extract_all(std::istream&amp; in)\n{\nreturn in;\n}\ntemplate &lt;typename First, typename... Rest&gt;\nstd::istream&amp; extract_all(std::istream&amp; in, First&amp;&amp; first, Rest&amp;&amp;... rest)\n{\nreturn extract_all(in &gt;&gt; BATT_FORWARD(first), BATT_FORWARD(rest)...);\n}\n// =============================================================================\n// to_string - use ostream insertion to convert any object to a string.\n//\ntemplate &lt;typename... Args&gt;\nstd::string to_string(Args&amp;&amp;... args)\n{\nstd::ostringstream oss;\nprint_all(oss, BATT_FORWARD(args)...);\nreturn std::move(oss).str();\n}\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\nBATT_SUPPRESS(\"-Wmaybe-uninitialized\")\n#endif\n// =============================================================================\n// from_string - use istream extraction to parse any object from a string.\n//\nnamespace detail {\n// General case.\n//\ntemplate &lt;typename T, typename... FormatArgs&gt;\nstd::optional&lt;T&gt; from_string_impl(StaticType&lt;T&gt;, const std::string&amp; str, FormatArgs&amp;&amp;... format_args)\n{\nT val;\nstd::istringstream iss{str};\nextract_all(iss, BATT_FORWARD(format_args)..., val);\nif (iss.good() || (iss.eof() &amp;&amp; !iss.fail())) {\nreturn val;\n}\nreturn std::nullopt;\n}\n// Special case for bool.\n//\ntemplate &lt;typename... FormatArgs&gt;\nstd::optional&lt;bool&gt; from_string_impl(StaticType&lt;bool&gt;, const std::string&amp; str,\nFormatArgs&amp;&amp;... /*format_args*/)\n{\nreturn boost::algorithm::to_lower_copy(str) == \"true\" || from_string_impl(StaticType&lt;int&gt;{}, str) != 0;\n}\n}  // namespace detail\ntemplate &lt;typename T, typename... FormatArgs&gt;\nstd::optional&lt;T&gt; from_string(const std::string&amp; str, FormatArgs&amp;&amp;... format_args)\n{\nreturn detail::from_string_impl(StaticType&lt;T&gt;{}, str, BATT_FORWARD(format_args)...);\n}\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\nBATT_UNSUPPRESS()\n#endif\n// =============================================================================\n// c_str_literal(str) - escape a C string.\n//\nstruct EscapedStringLiteral {\nstatic std::atomic&lt;usize&gt;&amp; max_show_length()\n{\nstatic std::atomic&lt;usize&gt; len{std::numeric_limits&lt;usize&gt;::max()};\nreturn len;\n}\nstd::string_view str;\n};\ninline EscapedStringLiteral c_str_literal(const std::string_view&amp; str)\n{\nreturn EscapedStringLiteral{str};\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_convertible_v&lt;T, std::string_view&gt;&gt;&gt;\ninline Optional&lt;EscapedStringLiteral&gt; c_str_literal(const Optional&lt;T&gt;&amp; maybe_str)\n{\nif (maybe_str) {\nreturn {c_str_literal(*maybe_str)};\n}\nreturn None;\n}\ninline Optional&lt;EscapedStringLiteral&gt; c_str_literal(const NoneType&amp;)\n{\nreturn None;\n}\n#define BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type)                                                          \\\n    inline decltype(auto) make_printable(type str)                                                           \\\n    {                                                                                                        \\\n        return c_str_literal(str);                                                                           \\\n    }\n#define BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(type)                                                        \\\n    BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type&amp;)                                                             \\\n    BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(type&amp;&amp;)                                                            \\\n    BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(const type&amp;)                                                       \\\n    BATT_DETAIL_OVERLOAD_STRING_PRINTABLE(const type&amp;&amp;)\nBATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(std::string)\nBATT_DETAIL_SPECIALIZE_STRING_PRINTABLE(std::string_view)\n#undef BATT_DETAIL_SPECIALIZE_STRING_PRINTABLE\n#undef BATT_DETAIL_OVERLOAD_STRING_PRINTABLE\n#define BATT_INSPECT_STR(expr) \" \" &lt;&lt; #expr &lt;&lt; \" == \" &lt;&lt; ::batt::c_str_literal((expr))\ninline const std::string_view&amp; StringUpperBound()\n{\nstatic const std::string_view s = [] {\nstatic std::array&lt;char, 4096&gt; s;\ns.fill(0xff);\nreturn std::string_view{s.data(), s.size()};\n}();\nreturn s;\n}\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const EscapedStringLiteral&amp; t)\n{\nif (t.str.data() == StringUpperBound().data()) {\nreturn out &lt;&lt; \"\\\"\\\\xff\\\"...\";\n}\nstatic const char xdigit[16] = {'0', '1', '2', '3', '4', '5', '6', '7',\n'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\nconst auto emit_hex_ascii = [&amp;](char ch) {\nout &lt;&lt; \"\\\\x\" &lt;&lt; xdigit[(ch &gt;&gt; 4) &amp; 0xf] &lt;&lt; xdigit[ch &amp; 0xf];\n};\nout &lt;&lt; '\"';\nusize i = 0;\nfor (char ch : t.str) {\nif (i &gt; EscapedStringLiteral::max_show_length()) {\nreturn out &lt;&lt; \"\\\"...(\" &lt;&lt; t.str.length() - i &lt;&lt; \" skipped chars)\";\n}\n++i;\nif (ch &amp; 0b10000000) {\nemit_hex_ascii(ch);\ncontinue;\n}\nswitch (ch &amp; 0b1110000) {\ncase 0b0000000:\nswitch (ch &amp; 0b1111) {\ncase 0b0000:\nout &lt;&lt; \"\\\\0\";\nbreak;\ncase 0b0111:\nout &lt;&lt; \"\\\\a\";\nbreak;\ncase 0b1000:\nout &lt;&lt; \"\\\\b\";\nbreak;\ncase 0b1001:\nout &lt;&lt; \"\\\\t\";\nbreak;\ncase 0b1010:\nout &lt;&lt; \"\\\\n\";\nbreak;\ncase 0b1011:\nout &lt;&lt; \"\\\\v\";\nbreak;\ncase 0b1100:\nout &lt;&lt; \"\\\\f\";\nbreak;\ncase 0b1101:\nout &lt;&lt; \"\\\\r\";\nbreak;\ndefault:\nemit_hex_ascii(ch);\nbreak;\n}\nbreak;\ncase 0b0010000:\nswitch (ch &amp; 0b1111) {\ncase 0b1011:\nout &lt;&lt; \"\\\\e\";\nbreak;\ndefault:\nemit_hex_ascii(ch);\nbreak;\n}\nbreak;\ncase 0b0100000:\nswitch (ch &amp; 0b1111) {\ncase 0b0010:\nout &lt;&lt; \"\\\\\\\"\";\nbreak;\ndefault:\nout &lt;&lt; ch;\nbreak;\n}\nbreak;\ncase 0b1010000:\nswitch (ch &amp; 0b1111) {\ncase 0b1100:\nout &lt;&lt; \"\\\\\\\\\";\nbreak;\ndefault:\nout &lt;&lt; ch;\nbreak;\n}\nbreak;\ncase 0b1110000:\nswitch (ch &amp; 0b1111) {\ncase 0b1111:\nout &lt;&lt; \"\\\\x7f\";\nbreak;\ndefault:\nout &lt;&lt; ch;\nbreak;\n}\nbreak;\ndefault:\nout &lt;&lt; ch;\nbreak;\n}\n}\nreturn out &lt;&lt; '\"';\n}\nstruct HexByteDumper {\nstd::string_view bytes;\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const HexByteDumper&amp; t)\n{\nout &lt;&lt; std::endl;\nboost::io::ios_flags_saver saver{out};\nconst char* const bytes = t.bytes.data();\nconst usize len = t.bytes.size();\nfor (usize i = 0; i &lt; len; ++i) {\nif (i % 16 == 0) {\nout &lt;&lt; std::hex &lt;&lt; std::setw(8) &lt;&lt; std::setfill('0') &lt;&lt; i &lt;&lt; \": \";\n}\nout &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; (((unsigned)bytes[i]) &amp; 0xfful);\nif (i % 16 == 15) {\nout &lt;&lt; std::endl;\n} else if (i % 2 == 1) {\nout &lt;&lt; \" \";\n}\n}\nreturn out;\n}\ninline HexByteDumper dump_hex(const void* ptr, usize size)\n{\nreturn HexByteDumper{std::string_view{static_cast&lt;const char*&gt;(ptr), size}};\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nstruct SizeDumper {\nenum struct UnitBase {\nkLog2 = 2,\nkLog10 = 10,\n};\nstd::string format(UnitBase base, i32&amp; parts, i32&amp; ord, usize&amp; error) const\n{\nstd::ostringstream oss;\nparts = 0;\nord = 0;\nerror = 0;\nbool first_part = true;\nusize n = this-&gt;value;\nusize unit_ord = 7;\nauto format_impl = [&amp;](const std::array&lt;std::pair&lt;u64, const char*&gt;, 7&gt;&amp; units) {\nfor (auto [div, unit_str] : units) {\nconst usize q = n / div;\nconst usize r = n % div;\nif (q != 0 || (div == 1 &amp;&amp; first_part)) {\nif (first_part) {\nord = unit_ord;\n}\nparts += 1;\noss &lt;&lt; (first_part ? \"\" : \"+\") &lt;&lt; q &lt;&lt; unit_str;\nif (!this-&gt;exact) {\nerror = r;\nbreak;\n}\nfirst_part = false;\n}\nn = r;\nunit_ord -= 1;\n}\n};\nswitch (base) {\ncase UnitBase::kLog2:\nformat_impl({\nstd::make_pair(kEiB, \"EiB\"),\nstd::make_pair(kPiB, \"PiB\"),\nstd::make_pair(kTiB, \"TiB\"),\nstd::make_pair(kGiB, \"GiB\"),\nstd::make_pair(kMiB, \"MiB\"),\nstd::make_pair(kKiB, \"KiB\"),\nstd::make_pair(u64{1}, \"B\"),\n});\nbreak;\ncase UnitBase::kLog10:\nformat_impl({\nstd::make_pair(kEB, \"EB\"),\nstd::make_pair(kPB, \"PB\"),\nstd::make_pair(kTB, \"TB\"),\nstd::make_pair(kGB, \"GB\"),\nstd::make_pair(kMB, \"MB\"),\nstd::make_pair(kKB, \"KB\"),\nstd::make_pair(u64{1}, \"B\"),\n});\nbreak;\ndefault:\nBATT_PANIC() &lt;&lt; \"Invalid value for `base`: \" &lt;&lt; int(base);\n}\nreturn std::move(oss).str();\n}\nusize value;\nbool exact;\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, SizeDumper t)\n{\ni32 base2_parts = 0, base10_parts = 0, base2_ord = 0, base10_ord = 0;\nusize base2_error = 0, base10_error = 0;\nconst std::string base2_str = t.format(SizeDumper::UnitBase::kLog2, base2_parts, base2_ord, base2_error);\nconst std::string base10_str =\nt.format(SizeDumper::UnitBase::kLog10, base10_parts, base10_ord, base10_error);\nif (base10_parts &lt; base2_parts           //\n|| (base10_parts == base2_parts      //\n&amp;&amp; (base2_ord &lt; base10_ord       //\n|| (base2_ord == base10_ord  //\n&amp;&amp; (base2_error != 0 &amp;&amp; base10_error == 0))))) {\nreturn out &lt;&lt; ((base10_error == 0) ? \"\" : \"~\") &lt;&lt; base10_str;\n} else {\nreturn out &lt;&lt; ((base2_error == 0) ? \"\" : \"~\") &lt;&lt; base2_str;\n}\n}\ninline SizeDumper dump_size(usize n)\n{\nreturn SizeDumper{\n.value = n,\n.exact = false,\n};\n}\ninline SizeDumper dump_size_exact(usize n)\n{\nreturn SizeDumper{\n.value = n,\n.exact = true,\n};\n}\ninline Optional&lt;usize&gt; parse_byte_size(std::string_view s)\n{\nif (s.empty()) {\nreturn None;\n}\nusize result_value = 0;\nbool have_result = false;\nwhile (!s.empty()) {\nif (s.front() == '+') {\ns.remove_prefix(1);\ncontinue;\n}\nif (s.front() == '-') {\nif (!have_result) {\nreturn None;\n}\ns.remove_prefix(1);\nOptional&lt;usize&gt; delta = parse_byte_size(s);\nif (!delta) {\nreturn None;\n}\nresult_value -= *delta;\nbreak;\n}\nstd::string_view num_chars = s;\nwhile (!s.empty() &amp;&amp; s.front() &gt;= '0' &amp;&amp; s.front() &lt;= '9') {\ns.remove_prefix(1);\n}\nnum_chars.remove_suffix(s.size());\nusize num_value = 0;\nstd::from_chars_result int_parse =\nstd::from_chars(num_chars.data(), num_chars.data() + num_chars.size(), num_value);\nif (int_parse.ec != std::errc{}) {\nreturn None;\n}\nconst usize unit_value = [&amp;]() -&gt; usize {\nif (s.empty()) {\nreturn 1ull;\n}\nswitch (std::tolower(s.front())) {\ncase 'b':\nreturn 1ull;\ncase 'k':\nreturn kKiB;\ncase 'm':\nreturn kMiB;\ncase 'g':\nreturn kGiB;\ncase 't':\nreturn kTiB;\ncase 'p':\nreturn kPiB;\ncase 'e':\nreturn kEiB;\ndefault:\nreturn 1ull;\n}\n}();\nwhile (!s.empty() &amp;&amp;\n((s.front() &gt;= 'a' &amp;&amp; s.front() &lt;= 'z') || (s.front() &gt;= 'A' &amp;&amp; s.front() &lt;= 'Z'))) {\ns.remove_prefix(1);\n}\nhave_result = true;\nresult_value += num_value * unit_value;\n// After the unit string, only '-' or '+' are allowed.\n//\nif (!s.empty() &amp;&amp; s.front() != '+' &amp;&amp; s.front() != '-') {\nreturn None;\n}\n}\nreturn result_value;\n}\n// =============================================================================\n// dump_range(x) - make range `x` printable to std::ostream.  Will also print any nested ranges\n// (e.g., `std::vector&lt;std::vector&lt;int&gt;&gt;`).\n//\n// Example:\n//\n// ```\n// std::vector&lt;int&gt; nums;\n//\n// std::cout &lt;&lt; batt::dump_range(nums);\n// ```\n//\n// Example (Pretty-printing):\n// ```\n// std::vector&lt;int&gt; nums;\n//\n// std::cout &lt;&lt; batt::dump_range(nums, batt::Pretty::True);\n// ```\n//\nenum struct Pretty { True, False, Default };\ntemplate &lt;typename T&gt;\nclass RangeDumper;\ntemplate &lt;typename T&gt;\nRangeDumper&lt;const T&amp;&gt; dump_range(const T&amp; value, Pretty pretty = Pretty::Default);\nnamespace detail {\ninline Pretty&amp; range_dump_pretty()\n{\nthread_local Pretty p = Pretty::False;\nreturn p;\n}\ninline int&amp; range_dump_depth()\n{\nthread_local int depth = 0;\nreturn depth;\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;T&gt;, u8&gt;{}&gt;,\ntypename = std::enable_if_t&lt;!IsRange&lt;T&gt;{}&gt;&gt;\ninline std::ostream&amp; dump_item(std::ostream&amp; out, T&amp;&amp; item)\n{\nreturn out &lt;&lt; BATT_FORWARD(item);\n}\ninline std::ostream&amp; dump_item(std::ostream&amp; out, const std::string&amp; s)\n{\nreturn out &lt;&lt; c_str_literal(s);\n}\ninline std::ostream&amp; dump_item(std::ostream&amp; out, const std::string_view&amp; s)\n{\nreturn out &lt;&lt; c_str_literal(s);\n}\ninline std::ostream&amp; dump_item(std::ostream&amp; out, const std::filesystem::path&amp; p)\n{\nreturn out &lt;&lt; p;\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;IsRange&lt;T&gt;{}&gt;&gt;\ninline std::ostream&amp; dump_item(std::ostream&amp; out, T&amp;&amp; item)\n{\nreturn out &lt;&lt; dump_range(item);\n}\ninline std::ostream&amp; dump_item(std::ostream&amp; out, u8 byte_val)\n{\nreturn out &lt;&lt; \"0x\" &lt;&lt; std::hex &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; unsigned(byte_val);\n}\ntemplate &lt;typename FirstT, typename SecondT&gt;\ninline std::ostream&amp; dump_item(std::ostream&amp; out, const std::pair&lt;FirstT, SecondT&gt;&amp; p)\n{\nout &lt;&lt; \"{\";\ndump_item(out, p.first);\nout &lt;&lt; \", \";\ndump_item(out, p.second);\nreturn out &lt;&lt; \"}\";\n}\n}  // namespace detail\ninline auto pretty_print_indent()\n{\nreturn std::string(detail::range_dump_depth() * 2, ' ');\n}\ntemplate &lt;typename T&gt;\nclass RangeDumper\n{\nprivate:\nT value_;\nPretty pretty_;\npublic:\ntemplate &lt;typename Arg&gt;\nexplicit RangeDumper(Arg&amp;&amp; arg, Pretty pretty) noexcept : value_{BATT_FORWARD(arg)}\n, pretty_{pretty}\n{\n}\nfriend inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const RangeDumper&amp; t) noexcept\n{\nboost::io::ios_flags_saver flags_saver(out);\nconst Pretty save_pretty = detail::range_dump_pretty();\nbool pretty = [&amp;] {\nif (t.pretty_ == Pretty::Default) {\nreturn save_pretty == Pretty::True;\n}\nreturn t.pretty_ == Pretty::True;\n}();\ndetail::range_dump_pretty() = pretty ? Pretty::True : Pretty::False;\nstd::string indent = pretty_print_indent();\n++detail::range_dump_depth();\nconst auto leave_indent_level = finally([&amp;] {\n--detail::range_dump_depth();\ndetail::range_dump_pretty() = save_pretty;\n});\nout &lt;&lt; \"{ \";\nif (pretty &amp;&amp; std::begin(t.value_) != std::end(t.value_)) {\nout &lt;&lt; std::endl &lt;&lt; indent;\n}\nfor (const auto&amp; item : t.value_) {\nif (pretty) {\nout &lt;&lt; \"  \";\n}\ndetail::dump_item(out, item) &lt;&lt; \", \";\nif (pretty) {\nout &lt;&lt; std::endl &lt;&lt; indent;\n}\n}\nreturn out &lt;&lt; \"}\";\n}\n};\ntemplate &lt;typename T&gt;\nRangeDumper&lt;const T&amp;&gt; dump_range(const T&amp; value, Pretty pretty)\n{\nreturn RangeDumper&lt;const T&amp;&gt;{value, pretty};\n}\n#define BATT_INSPECT_RANGE(expr) \" \" &lt;&lt; #expr &lt;&lt; \" == \" &lt;&lt; ::batt::dump_range((expr))\n#define BATT_INSPECT_RANGE_PRETTY(expr)                                                                      \\\n    \" \" &lt;&lt; #expr &lt;&lt; \" == \" &lt;&lt; ::batt::dump_range((expr), ::batt::Pretty::True)\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/strict_8hpp/","title":"batteries/strict.hpp","text":""},{"location":"_autogen/Files/strict_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#ifndef BATT_NO_STRICT\n#pragma GCC diagnostic error \"-Wall\"\n#pragma GCC diagnostic error \"-Wextra\"\n#endif  // BATT_NO_STRICT\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/strong__typedef_8hpp/","title":"batteries/strong_typedef.hpp","text":""},{"location":"_autogen/Files/strong__typedef_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/strong__typedef_8hpp/#classes","title":"Classes","text":"Name class batt::StrongType struct batt::StrongType::Hash struct batt::StrongType::Delta"},{"location":"_autogen/Files/strong__typedef_8hpp/#functions","title":"Functions","text":"Name constexpr std::false_type batt_strong_typedef_supports_numerics(... )"},{"location":"_autogen/Files/strong__typedef_8hpp/#defines","title":"Defines","text":"Name BATT_STRONG_TYPEDEF_PASTE_2_(a, b) BATT_STRONG_TYPEDEF_PASTE_(a, b) BATT_STRONG_TYPEDEF(TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE) BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME) BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short)"},{"location":"_autogen/Files/strong__typedef_8hpp/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Files/strong__typedef_8hpp/#function-batt_strong_typedef_supports_numerics","title":"function batt_strong_typedef_supports_numerics","text":"<pre><code>inline constexpr std::false_type batt_strong_typedef_supports_numerics(\n... )\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/strong__typedef_8hpp/#define-batt_strong_typedef_paste_2_","title":"define BATT_STRONG_TYPEDEF_PASTE_2_","text":"<pre><code>#define BATT_STRONG_TYPEDEF_PASTE_2_(a, b)\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#define-batt_strong_typedef_paste_","title":"define BATT_STRONG_TYPEDEF_PASTE_","text":"<pre><code>#define BATT_STRONG_TYPEDEF_PASTE_(a, b)\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#define-batt_strong_typedef","title":"define BATT_STRONG_TYPEDEF","text":"<pre><code>#define BATT_STRONG_TYPEDEF(TYPE, NAME)\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#define-batt_strong_typedef_with_default","title":"define BATT_STRONG_TYPEDEF_WITH_DEFAULT","text":"<pre><code>#define BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE)\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#define-batt_strong_typedef_supports_numerics","title":"define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS","text":"<pre><code>#define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME)\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#define-batt_strong_typedef_numeric_operator_defn","title":"define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN","text":"<pre><code>#define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short)\n</code></pre>"},{"location":"_autogen/Files/strong__typedef_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#ifndef BATT_STRONG_TYPEDEF_HPP\n#define BATT_STRONG_TYPEDEF_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;functional&gt;\n#include &lt;type_traits&gt;\n// Must be outside namespace batt so we can do ADL.\n//\ninline constexpr std::false_type batt_strong_typedef_supports_numerics(...)\n{\nreturn {};\n}\nnamespace batt {\ntemplate &lt;typename T, typename Tag&gt;\nclass StrongType;\ntemplate &lt;typename T, typename Tag&gt;\nclass StrongType\n{\nstatic_assert(std::is_standard_layout&lt;T&gt;{} &amp;&amp; std::is_trivial&lt;T&gt;{}, \"`T` must be a POD type.\");\npublic:\nusing value_type = T;\nusing tag_type = Tag;\nconstexpr StrongType() noexcept : value_{strong_typedef_default_value((Tag*)nullptr)}\n{\n}\nexplicit constexpr StrongType(T init_value) noexcept : value_{init_value}\n{\n}\nconstexpr T value() const\n{\nreturn value_;\n}\nconstexpr operator T() const\n{\nreturn value();\n}\nstruct Delta;\nStrongType&amp; operator+=(Delta d);\nStrongType&amp; operator-=(Delta d);\nstruct Hash {\nusing result_type = typename std::hash&lt;T&gt;::result_type;\nresult_type operator()(const StrongType&amp; obj) const\n{\nreturn impl_(obj.value());\n}\nprivate:\nstd::hash&lt;T&gt; impl_;\n};\nprivate:\nT value_;\n};\ntemplate &lt;typename T, typename Tag&gt;\nstruct StrongType&lt;T, Tag&gt;::Delta : StrongType&lt;T, Tag&gt; {\nusing StrongType::StrongType;\n/*implicit*/ Delta(StrongType value) noexcept : StrongType{value}\n{\n}\n};\n#define BATT_STRONG_TYPEDEF_PASTE_2_(a, b) a##b\n#define BATT_STRONG_TYPEDEF_PASTE_(a, b) BATT_STRONG_TYPEDEF_PASTE_2_(a, b)\n#define BATT_STRONG_TYPEDEF(TYPE, NAME) BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, TYPE{})\n#define BATT_STRONG_TYPEDEF_WITH_DEFAULT(TYPE, NAME, VALUE)                                                  \\\n    struct BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG);                                                           \\\n    [[maybe_unused]] inline constexpr TYPE strong_typedef_default_value(                                     \\\n        BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)*)                                                             \\\n    {                                                                                                        \\\n        return VALUE;                                                                                        \\\n    }                                                                                                        \\\n    using NAME = ::batt::StrongType&lt;TYPE, BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)&gt;\n#define BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS(NAME)                                                          \\\n    inline constexpr std::true_type batt_strong_typedef_supports_numerics(                                   \\\n        BATT_STRONG_TYPEDEF_PASTE_(NAME, _TAG)*)                                                             \\\n    {                                                                                                        \\\n        return {};                                                                                           \\\n    }\n#define BATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(op_long, op_short)                                         \\\n    template &lt;typename T, typename Tag,                                                                      \\\n              typename = std::enable_if_t&lt;batt_strong_typedef_supports_numerics((Tag*)nullptr)&gt;&gt;             \\\n    constexpr StrongType&lt;T, Tag&gt; op_long(StrongType&lt;T, Tag&gt; a, StrongType&lt;T, Tag&gt; b)                         \\\n    {                                                                                                        \\\n        return StrongType&lt;T, Tag&gt;{a.value() op_short b.value()};                                             \\\n    }\nBATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(operator+, +)\nBATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(operator-, -)\nBATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(operator*, *)\nBATT_STRONG_TYPEDEF_NUMERIC_OPERATOR_DEFN(operator/, /)\ntemplate &lt;typename T, typename Tag&gt;\ninline StrongType&lt;T, Tag&gt;&amp; StrongType&lt;T, Tag&gt;::operator+=(Delta d)\n{\nstatic_assert(batt_strong_typedef_supports_numerics((Tag*)nullptr),\n\"This StrongType does not support numeric operations; see \"\n\"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS\");\nvalue_ += d;\nreturn *this;\n}\ntemplate &lt;typename T, typename Tag&gt;\ninline StrongType&lt;T, Tag&gt;&amp; StrongType&lt;T, Tag&gt;::operator-=(Delta d)\n{\nstatic_assert(batt_strong_typedef_supports_numerics((Tag*)nullptr),\n\"This StrongType does not support numeric operations; see \"\n\"BATT_STRONG_TYPEDEF_SUPPORTS_NUMERICS\");\nvalue_ -= d;\nreturn *this;\n}\n}  // namespace batt\n#endif  // BATT_STRONG_TYPEDEF_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/sub__range__seq_8hpp/","title":"batteries/seq/sub_range_seq.hpp","text":""},{"location":"_autogen/Files/sub__range__seq_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/sub__range__seq_8hpp/#classes","title":"Classes","text":"Name class batt::SubRangeSeq"},{"location":"_autogen/Files/sub__range__seq_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_SUB_RANGE_SEQ_HPP"},{"location":"_autogen/Files/sub__range__seq_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/sub__range__seq_8hpp/#define-batteries_seq_sub_range_seq_hpp","title":"define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP","text":"<pre><code>#define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP()\n</code></pre>"},{"location":"_autogen/Files/sub__range__seq_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_SUB_RANGE_SEQ_HPP\n#define BATTERIES_SEQ_SUB_RANGE_SEQ_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/count.hpp&gt;\n#include &lt;batteries/seq/for_each.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass SubRangeSeq\n{\npublic:\nusing Item = decltype(std::declval&lt;T&gt;().front());\nexplicit SubRangeSeq(T&amp;&amp; sub_range) noexcept : sub_range_{BATT_FORWARD(sub_range)}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (sub_range_.empty()) {\nreturn None;\n}\nreturn {sub_range_.front()};\n}\nOptional&lt;Item&gt; next()\n{\nauto n = this-&gt;peek();\nif (n) {\nsub_range_.drop_front();\n}\nreturn n;\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\ntemplate &lt;typename T_&gt;\nfriend std::size_t operator|(const SubRangeSeq&lt;T_&gt;&amp;, seq::CountBinder);\ntemplate &lt;typename T_, typename Fn&gt;\nfriend seq::LoopControl operator|(const SubRangeSeq&lt;T_&gt;&amp;, seq::ForEachBinder&lt;Fn&gt;&amp;&amp;);\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\nprivate:\nT sub_range_;\n};\ntemplate &lt;typename T,  //\ntypename = decltype(std::declval&lt;T&gt;().front()), typename = decltype(std::declval&lt;T&gt;().drop_front())&gt;\nSubRangeSeq&lt;T&gt; as_seq(T&amp;&amp; sub_range)\n{\nreturn SubRangeSeq&lt;T&gt;{BATT_FORWARD(sub_range)};\n}\n#if BATT_SEQ_SPECIALIZE_ALGORITHMS\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T&gt;\n[[nodiscard]] std::size_t operator|(const SubRangeSeq&lt;T&gt;&amp; sub_range_seq, seq::CountBinder)\n{\nreturn sub_range_seq.sub_range_.size();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename Fn&gt;\nseq::LoopControl operator|(const SubRangeSeq&lt;T&gt;&amp; sub_range_seq, seq::ForEachBinder&lt;Fn&gt;&amp;&amp; binder)\n{\nfor (const auto&amp; item : sub_range_seq.sub_range_) {\nif (BATT_HINT_FALSE(seq::run_loop_fn(binder.fn, item) == seq::kBreak)) {\nreturn seq::kBreak;\n}\n}\nreturn seq::kContinue;\n}\n#endif  // BATT_SEQ_SPECIALIZE_ALGORITHMS\n}  // namespace batt\n#endif  // BATTERIES_SEQ_SUB_RANGE_SEQ_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/sum_8hpp/","title":"batteries/seq/sum.hpp","text":""},{"location":"_autogen/Files/sum_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/sum_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::SumBinder"},{"location":"_autogen/Files/sum_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_SUM_HPP"},{"location":"_autogen/Files/sum_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/sum_8hpp/#define-batteries_seq_sum_hpp","title":"define BATTERIES_SEQ_SUM_HPP","text":"<pre><code>#define BATTERIES_SEQ_SUM_HPP()\n</code></pre>"},{"location":"_autogen/Files/sum_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_SUM_HPP\n#define BATTERIES_SEQ_SUM_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/reduce.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// sum\n//\nstruct SumBinder {\n};\ninline SumBinder sum()\n{\nreturn {};\n}\ntemplate &lt;typename Seq&gt;\n[[nodiscard]] auto operator|(Seq&amp;&amp; seq, SumBinder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"(seq::sum) Sequences may not be captured implicitly by reference.\");\nreturn BATT_FORWARD(seq) | reduce(SeqItem&lt;Seq&gt;{}, [](auto&amp;&amp; a, auto&amp;&amp; b) {\nreturn a + b;\n});\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_SUM_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/suppress_8hpp/","title":"batteries/suppress.hpp","text":""},{"location":"_autogen/Files/suppress_8hpp/#defines","title":"Defines","text":"Name BATT_SUPPRESS(warn_id) Disables specific compiler warnings (by id). BATT_UNSUPPRESS() BATT_SUPPRESS_IF_GCC(warn_id) Disables optimization for a single function. BATT_UNSUPPRESS_IF_GCC() BATT_SUPPRESS_IF_CLANG(warn_id) BATT_UNSUPPRESS_IF_CLANG() BATT_SUPPRESS_IF_MSVC(warn_id) BATT_UNSUPPRESS_IF_MSVC()"},{"location":"_autogen/Files/suppress_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/suppress_8hpp/#define-batt_suppress","title":"define BATT_SUPPRESS","text":"<pre><code>#define BATT_SUPPRESS(warn_id)\n</code></pre> <p>Disables specific compiler warnings (by id). </p> <p>Nests with BATT_UNSUPPRESS().</p> <p>Example: </p> <pre><code>#include &lt;batteries/strict.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n// Ordinarily the function below would fail to compile because:\n//  - foo() is declared as returning int, but never returns anything\n//  - foo() is never used\n//\nBATT_SUPPRESS(\"-Wreturn-type\")\nBATT_SUPPRESS(\"-Wunused-function\")\nint foo()\n{}\nBATT_UNSUPPRESS()\nBATT_UNSUPPRESS()\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_unsuppress","title":"define BATT_UNSUPPRESS","text":"<pre><code>#define BATT_UNSUPPRESS()\n</code></pre> <p>See: BATT_SUPPRESS</p>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_suppress_if_gcc","title":"define BATT_SUPPRESS_IF_GCC","text":"<pre><code>#define BATT_SUPPRESS_IF_GCC(warn_id)\n</code></pre> <p>Disables optimization for a single function. </p> <p>Example: </p> <pre><code>void BATT_NO_OPTIMIZE empty_function() {}\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_unsuppress_if_gcc","title":"define BATT_UNSUPPRESS_IF_GCC","text":"<pre><code>#define BATT_UNSUPPRESS_IF_GCC()\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_suppress_if_clang","title":"define BATT_SUPPRESS_IF_CLANG","text":"<pre><code>#define BATT_SUPPRESS_IF_CLANG(warn_id)\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_unsuppress_if_clang","title":"define BATT_UNSUPPRESS_IF_CLANG","text":"<pre><code>#define BATT_UNSUPPRESS_IF_CLANG()\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_suppress_if_msvc","title":"define BATT_SUPPRESS_IF_MSVC","text":"<pre><code>#define BATT_SUPPRESS_IF_MSVC(warn_id)\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#define-batt_unsuppress_if_msvc","title":"define BATT_UNSUPPRESS_IF_MSVC","text":"<pre><code>#define BATT_UNSUPPRESS_IF_MSVC()\n</code></pre>"},{"location":"_autogen/Files/suppress_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n#ifdef BATT_GENERATING_DOCS\n// =============================================================================\n#define BATT_SUPPRESS(warn_id)\n#define BATT_UNSUPPRESS()\n#endif  // BATT_GENERATING_DOCS\n// =============================================================================\n#if BATT_COMPILER_IS_CLANG\n#define BATT_NO_OPTIMIZE __attribute__((optnone))\n#define BATT_GCC_BEGIN_OPTIMIZE(opt_level)\n#define BATT_GCC_END_OPTIMIZE()\n#define BATT_BEGIN_NO_OPTIMIZE()\n#define BATT_END_NO_OPTIMIZE()\n#elif BATT_COMPILER_IS_GCC\n#define BATT_NO_OPTIMIZE __attribute__((optimize(\"O0\")))\n#define BATT_GCC_BEGIN_OPTIMIZE(opt_level) _Pragma(\"GCC push_options\") BATT_DO_PRAGMA(GCC optimize(opt_level))\n#define BATT_GCC_END_OPTIMIZE() _Pragma(\"GCC pop_options\")\n#define BATT_BEGIN_NO_OPTIMIZE() BATT_GCC_BEGIN_OPTIMIZE(\"O0\")\n#define BATT_END_NO_OPTIMIZE() BATT_GCC_END_OPTIMIZE()\n#elif BATT_COMPILER_IS_MSVC\n#define BATT_NO_OPTIMIZE\n#define BATT_GCC_BEGIN_OPTIMIZE(opt_level)\n#define BATT_GCC_END_OPTIMIZE()\n#define BATT_BEGIN_NO_OPTIMIZE()\n#define BATT_END_NO_OPTIMIZE()\n#else\n#error Please define BATT_NO_OPTIMIZE, etc. for your compiler\n#endif\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#if BATT_COMPILER_IS_GCC\n#define BATT_DO_PRAGMA(x) _Pragma(#x)\n#define BATT_SUPPRESS_IF_GCC(warn_id)                                                                        \\\n    _Pragma(\"GCC diagnostic push\") BATT_DO_PRAGMA(GCC diagnostic ignored warn_id)\n#define BATT_UNSUPPRESS_IF_GCC() _Pragma(\"GCC diagnostic pop\")\n#else  // BATT_COMPILER_IS_GCC\n#define BATT_SUPPRESS_IF_GCC(warn_id)\n#define BATT_UNSUPPRESS_IF_GCC()\n#endif  // BATT_COMPILER_IS_GCC\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#if BATT_COMPILER_IS_CLANG\n#define BATT_DO_PRAGMA(x) _Pragma(#x)\n#define BATT_SUPPRESS_IF_CLANG(warn_id)                                                                      \\\n    _Pragma(\"GCC diagnostic push\") BATT_DO_PRAGMA(GCC diagnostic ignored warn_id)\n#define BATT_UNSUPPRESS_IF_CLANG() _Pragma(\"GCC diagnostic pop\")\n#else  // BATT_COMPILER_IS_CLANG\n#define BATT_SUPPRESS_IF_CLANG(warn_id)\n#define BATT_UNSUPPRESS_IF_CLANG()\n#endif  // BATT_COMPILER_IS_CLANG\n#if BATT_COMPILER_IS_MSVC\n#define BATT_SUPPRESS_IF_MSVC(warn_id) __pragma(warning(push)) __pragma(warning(disable : warn_id))\n#define BATT_UNSUPPRESS_IF_MSVC() __pragma(warning(pop))\n#else  // BATT_COMPILER_IS_MSVC\n#define BATT_SUPPRESS_IF_MSVC(warn_id)\n#define BATT_UNSUPPRESS_IF_MSVC()\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//----- --- -- -  -  -   -\n#if BATT_COMPILER_IS_GCC\n#define BATT_SUPPRESS BATT_SUPPRESS_IF_GCC\n#define BATT_UNSUPPRESS BATT_UNSUPPRESS_IF_GCC\n//----- --- -- -  -  -   -\n#elif BATT_COMPILER_IS_CLANG\n#define BATT_SUPPRESS BATT_SUPPRESS_IF_CLANG\n#define BATT_UNSUPPRESS BATT_UNSUPPRESS_IF_CLANG\n//----- --- -- -  -  -   -\n#elif BATT_COMPILER_IS_MSVC\n#define BATT_SUPPRESS BATT_SUPPRESS_IF_MSVC\n#define BATT_UNSUPPRESS BATT_UNSUPPRESS_IF_MSVC\n//----- --- -- -  -  -   -\n#else\n#error Please define BATT_SUPPRESS for your compiler!\n#endif\n#endif  // BATT_COMPILER_IS_MSVC\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/syscall__retry_8hpp/","title":"batteries/syscall_retry.hpp","text":""},{"location":"_autogen/Files/syscall__retry_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/syscall__retry_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SYSCALL_RETRY_HPP"},{"location":"_autogen/Files/syscall__retry_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/syscall__retry_8hpp/#define-batteries_syscall_retry_hpp","title":"define BATTERIES_SYSCALL_RETRY_HPP","text":"<pre><code>#define BATTERIES_SYSCALL_RETRY_HPP()\n</code></pre>"},{"location":"_autogen/Files/syscall__retry_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SYSCALL_RETRY_HPP\n#define BATTERIES_SYSCALL_RETRY_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#ifndef BATT_PLATFORM_IS_WINDOWS\n#include &lt;unistd.h&gt;\n#endif\nnamespace batt {\n// Executes the passed op repeatedly it doesn't fail with EINTR.\n//\ntemplate &lt;typename Op&gt;\nauto syscall_retry(Op&amp;&amp; op)\n{\nfor (;;) {\nconst auto result = op();\n#ifndef BATT_PLATFORM_IS_WINDOWS\nif (result != -1 || errno != EINTR)\n#endif  // BATT_PLATFORM_IS_WINDOWS\n{\nreturn result;\n}\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_SYSCALL_RETRY_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/system__executor_8hpp/","title":"batteries/asio/system_executor.hpp","text":""},{"location":"_autogen/Files/system__executor_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASIO_SYSTEM_EXECUTOR_HPP"},{"location":"_autogen/Files/system__executor_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/system__executor_8hpp/#define-batteries_asio_system_executor_hpp","title":"define BATTERIES_ASIO_SYSTEM_EXECUTOR_HPP","text":"<pre><code>#define BATTERIES_ASIO_SYSTEM_EXECUTOR_HPP()\n</code></pre>"},{"location":"_autogen/Files/system__executor_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASIO_SYSTEM_EXECUTOR_HPP\n#define BATTERIES_ASIO_SYSTEM_EXECUTOR_HPP\n#include &lt;batteries/suppress.hpp&gt;\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\n//\n#include &lt;boost/asio/system_executor.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n#endif  // BATTERIES_ASIO_SYSTEM_EXECUTOR_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/take__n_8hpp/","title":"batteries/seq/take_n.hpp","text":""},{"location":"_autogen/Files/take__n_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/take__n_8hpp/#classes","title":"Classes","text":"Name struct batt::seq::TakeNBinder class batt::seq::TakeN"},{"location":"_autogen/Files/take__n_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_TAKE_N_HPP"},{"location":"_autogen/Files/take__n_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/take__n_8hpp/#define-batteries_seq_take_n_hpp","title":"define BATTERIES_SEQ_TAKE_N_HPP","text":"<pre><code>#define BATTERIES_SEQ_TAKE_N_HPP()\n</code></pre>"},{"location":"_autogen/Files/take__n_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_TAKE_N_HPP\n#define BATTERIES_SEQ_TAKE_N_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/requirements.hpp&gt;\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// take(n)\n//\nstruct TakeNBinder {\nusize n;\n};\ninline TakeNBinder take_n(usize n)\n{\nreturn {n};\n}\ntemplate &lt;typename Seq&gt;\nclass TakeN\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit TakeN(Seq&amp;&amp; seq, usize n) noexcept : seq_(BATT_FORWARD(seq)), n_{n}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (n_ == 0) {\nreturn None;\n}\nreturn seq_.peek();\n}\nOptional&lt;Item&gt; next()\n{\nif (n_ == 0) {\nreturn None;\n}\n--n_;\nreturn seq_.next();\n}\nprivate:\nSeq seq_;\nusize n_;\n};\ntemplate &lt;typename Seq, typename = EnableIfSeq&lt;Seq&gt;&gt;\n[[nodiscard]] TakeN&lt;Seq&gt; operator|(Seq&amp;&amp; seq, const TakeNBinder&amp; binder)\n{\nreturn TakeN&lt;Seq&gt;{BATT_FORWARD(seq), binder.n};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_TAKE_N_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/take__while_8hpp/","title":"batteries/seq/take_while.hpp","text":""},{"location":"_autogen/Files/take__while_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq"},{"location":"_autogen/Files/take__while_8hpp/#classes","title":"Classes","text":"Name class batt::seq::TakeWhile struct batt::seq::TakeWhileBinder"},{"location":"_autogen/Files/take__while_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_TAKE_WHILE_HPP"},{"location":"_autogen/Files/take__while_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/take__while_8hpp/#define-batteries_seq_take_while_hpp","title":"define BATTERIES_SEQ_TAKE_WHILE_HPP","text":"<pre><code>#define BATTERIES_SEQ_TAKE_WHILE_HPP()\n</code></pre>"},{"location":"_autogen/Files/take__while_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_TAKE_WHILE_HPP\n#define BATTERIES_SEQ_TAKE_WHILE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// take_while\n//\ntemplate &lt;typename Seq, typename Predicate&gt;\nclass TakeWhile\n{\npublic:\nusing Item = SeqItem&lt;Seq&gt;;\nexplicit TakeWhile(Seq&amp;&amp; seq, Predicate&amp;&amp; predicate) noexcept\n: seq_(BATT_FORWARD(seq))\n, predicate_(BATT_FORWARD(predicate))\n{\n}\nOptional&lt;Item&gt; peek()\n{\nauto v = seq_.peek();\nif (v &amp;&amp; predicate_(*v)) {\nreturn v;\n}\nreturn None;\n}\nOptional&lt;Item&gt; next()\n{\nauto v = peek();\nif (v) {\n(void)seq_.next();\nreturn v;\n}\nreturn None;\n}\nprivate:\nSeq seq_;\nPredicate predicate_;\n};\ntemplate &lt;typename Predicate&gt;\nstruct TakeWhileBinder {\nPredicate predicate;\n};\ntemplate &lt;typename Predicate&gt;\nTakeWhileBinder&lt;Predicate&gt; take_while(Predicate&amp;&amp; predicate)\n{\nreturn {BATT_FORWARD(predicate)};\n}\ntemplate &lt;typename Seq, typename Predicate&gt;\n[[nodiscard]] TakeWhile&lt;Seq, Predicate&gt; operator|(Seq&amp;&amp; seq, TakeWhileBinder&lt;Predicate&gt;&amp;&amp; binder)\n{\nstatic_assert(std::is_same_v&lt;Seq, std::decay_t&lt;Seq&gt;&gt;,\n\"Mapped sequences may not be captured implicitly by reference.\");\nstatic_assert(std::is_same_v&lt;Predicate, std::decay_t&lt;Predicate&gt;&gt;,\n\"Predicate functions may not be captured implicitly by reference.\");\nreturn TakeWhile&lt;Seq, Predicate&gt;{BATT_FORWARD(seq), BATT_FORWARD(binder.predicate)};\n}\n}  // namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_TAKE_WHILE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/task_8cpp/","title":"batteries/async/task.cpp","text":""},{"location":"_autogen/Files/task_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/task.hpp&gt;\n//\n#include &lt;batteries/async/task_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/task_8hpp/","title":"batteries/async/task.hpp","text":""},{"location":"_autogen/Files/task_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/task_decl.hpp&gt;\n#include &lt;batteries/async/task.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/task_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/task__decl_8hpp/","title":"batteries/async/task_decl.hpp","text":""},{"location":"_autogen/Files/task__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/task__decl_8hpp/#classes","title":"Classes","text":"Name class batt::Task A user-space cooperatively scheduled thread of control. class batt::Task::ConcurrentTaskList Thread-safe list of tasks. struct batt::Task::Options Optional params for Task creation. struct batt::Task::DebugTrace Stack trace and debug information collected from a Task."},{"location":"_autogen/Files/task__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_TASK_DECL_HPP"},{"location":"_autogen/Files/task__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/task__decl_8hpp/#define-batteries_async_task_decl_hpp","title":"define BATTERIES_ASYNC_TASK_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_TASK_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/task__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_TASK_DECL_HPP\n#define BATTERIES_ASYNC_TASK_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/continuation.hpp&gt;\n#include &lt;batteries/async/future_decl.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/async/io_result.hpp&gt;\n#include &lt;batteries/async/mcs_lock.hpp&gt;\n#include &lt;batteries/async/watch_decl.hpp&gt;\n#include &lt;batteries/case_of.hpp&gt;\n#include &lt;batteries/constants.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/segv.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/suppress.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n// clang-format off\nBATT_SUPPRESS_IF_GCC(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_GCC(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wsuggest-override\")\nBATT_SUPPRESS_IF_CLANG(\"-Wunused-variable\")\n//\n#include &lt;boost/asio/deadline_timer.hpp&gt;\n#include &lt;boost/asio/defer.hpp&gt;\n#include &lt;boost/asio/dispatch.hpp&gt;\n#include &lt;boost/asio/executor.hpp&gt;\n#include &lt;boost/asio/executor_work_guard.hpp&gt;\n#include &lt;boost/asio/post.hpp&gt;\n#include &lt;boost/asio/read.hpp&gt;\n#include &lt;boost/asio/write.hpp&gt;\n#include &lt;boost/exception/diagnostic_information.hpp&gt;\n#include &lt;boost/preprocessor/cat.hpp&gt;\n//\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\nBATT_UNSUPPRESS_IF_GCC()\n// clang-format on\n#include &lt;boost/intrusive/list.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;bitset&gt;\n#include &lt;functional&gt;\n#include &lt;future&gt;\n#include &lt;thread&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\nnamespace batt {\ni32 next_thread_id();\ni32&amp; this_thread_id();\n// Forward-declaration.\n//\nclass DebugInfoFrame;\nclass Task\n: public boost::intrusive::list_base_hook&lt;boost::intrusive::link_mode&lt;boost::intrusive::auto_unlink&gt;&gt;\n{\nfriend class DebugInfoFrame;\nfriend void print_debug_info(DebugInfoFrame* p, std::ostream&amp; out);\npublic:\nBATT_STRONG_TYPEDEF(bool, DeferStart);\nusing PointerToBool = bool*;\nBATT_STRONG_TYPEDEF(PointerToBool, GetIsStarted);\nusing state_type = u32;\nBATT_STRONG_TYPEDEF_WITH_DEFAULT(i32, Priority, 0);\nBATT_STRONG_TYPEDEF(bool, IsDone);\nusing executor_type = boost::asio::any_io_executor;\nusing TaskList = boost::intrusive::list&lt;Task, boost::intrusive::constant_time_size&lt;false&gt;&gt;;\nclass ConcurrentTaskList\n{\npublic:\nConcurrentTaskList() = default;\nConcurrentTaskList(const ConcurrentTaskList&amp;) = delete;\nConcurrentTaskList&amp; operator=(const ConcurrentTaskList&amp;) = delete;\nvoid push_back(Task&amp; task);\nvoid unlink(Task&amp; task);\nvoid await_empty();\ntemplate &lt;typename Fn, typename R = std::invoke_result_t&lt;Fn&amp;&amp;, TaskList&amp;&gt;&gt;\nR with_lock(Fn&amp;&amp; fn);\nvoid dump_log_info(std::string_view label);\nbatt::SmallFn&lt;void(std::ostream&amp;)&gt; debug_info(std::string_view label) noexcept;\nprivate:\nvoid dump_log_info_locked(std::unique_lock&lt;std::mutex&gt;&amp;, std::string_view label);\nbatt::SmallFn&lt;void(std::ostream&amp;)&gt; debug_info_locked(std::unique_lock&lt;std::mutex&gt;&amp;,\nstd::string_view label) noexcept;\nstd::mutex mutex_;\nTaskList task_list_;\nstd::atomic&lt;i64&gt; link_count_{0};\nWatch&lt;i64&gt; unlink_count_{0};\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Task creation defaults\n//----- --- -- -  -  -   -\nstatic constexpr StackSize kDefaultStackSize = StackSize{8 * kMiB};\nstatic constexpr StackType kDefaultStackType = StackType::kFixedSize;\nstatic constexpr DeferStart kDefaultDeferStart = DeferStart{false};\nstatic std::string default_name()\n{\nreturn \"(anonymous)\";\n}\nstatic Priority default_priority()\n{\nreturn Priority{Task::current_priority() + 100};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstruct Options {\nOptional&lt;std::string&gt; name;\nOptional&lt;StackSize&gt; stack_size;\nOptional&lt;StackType&gt; stack_type;\nOptional&lt;Priority&gt; priority;\nOptional&lt;DeferStart&gt; defer_start;\nOptional&lt;GetIsStarted&gt; get_is_started;\nOptional&lt;StackAllocator&gt; stack_allocator;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename... Args&gt;\nstatic Options from_args(Args&amp;&amp;... args)\n{\nOptions options;\noptions.set_params(BATT_FORWARD(args)...);\nreturn options;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nOptions&amp; set_params()\n{\nreturn *this;\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(std::string&amp;&amp; name, Args&amp;&amp;... args)\n{\nthis-&gt;name.emplace(std::move(name));\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(const char* name, Args&amp;&amp;... args)\n{\nthis-&gt;name.emplace(std::string{name});\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(StackSize stack_size, Args&amp;&amp;... args)\n{\nthis-&gt;stack_size = stack_size;\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(StackType stack_type, Args&amp;&amp;... args)\n{\nthis-&gt;stack_type = stack_type;\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(Priority priority, Args&amp;&amp;... args)\n{\nthis-&gt;priority = priority;\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(DeferStart defer_start, Args&amp;&amp;... args)\n{\nthis-&gt;defer_start = defer_start;\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(GetIsStarted get_is_started, Args&amp;&amp;... args)\n{\nthis-&gt;get_is_started = get_is_started;\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(const StackAllocator&amp; stack_allocator, Args&amp;&amp;... args)\n{\nthis-&gt;stack_allocator = stack_allocator;\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\ntemplate &lt;typename... Args&gt;\nOptions&amp; set_params(StackAllocator&amp;&amp; stack_allocator, Args&amp;&amp;... args)\n{\nthis-&gt;stack_allocator = std::move(stack_allocator);\nreturn this-&gt;set_params(BATT_FORWARD(args)...);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstd::string get_name() &amp;&amp; noexcept\n{\nif (this-&gt;name) {\nreturn std::move(*this-&gt;name);\n}\nreturn Task::default_name();\n}\nstd::string get_name() const&amp;&amp; noexcept\n{\nif (this-&gt;name) {\nreturn *this-&gt;name;\n}\nreturn Task::default_name();\n}\nstd::string get_name() const&amp; noexcept\n{\nreturn std::move(*this).get_name();\n}\nStackAllocator get_task_stack_allocator() const noexcept\n{\nif (this-&gt;stack_allocator) {\nreturn *this-&gt;stack_allocator;\n}\nreturn ::batt::get_stack_allocator(this-&gt;get_stack_size(), this-&gt;get_stack_type());\n}\nStackSize get_stack_size() const noexcept\n{\nreturn this-&gt;stack_size.value_or(kDefaultStackSize);\n}\nStackType get_stack_type() const noexcept\n{\nreturn this-&gt;stack_type.value_or(kDefaultStackType);\n}\nPriority get_priority() const noexcept\n{\nif (this-&gt;priority) {\nreturn *this-&gt;priority;\n}\nreturn Task::default_priority();\n}\nDeferStart get_defer_start() const noexcept\n{\nreturn this-&gt;defer_start.value_or(kDefaultDeferStart);\n}\nvoid set_is_started(bool is_started) const noexcept\n{\nif (this-&gt;get_is_started &amp;&amp; *this-&gt;get_is_started) {\n**this-&gt;get_is_started = is_started;\n}\n}\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic usize&amp; nesting_depth();\nstatic constexpr usize kMaxNestingDepth = 8;\nstatic constexpr usize kHandlerMemoryBytes = 128;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr state_type kNeedSignal = state_type{1} &lt;&lt; 0;\nstatic constexpr state_type kHaveSignal = state_type{1} &lt;&lt; 1;\nstatic constexpr state_type kSuspended = state_type{1} &lt;&lt; 2;\nstatic constexpr state_type kTerminated = state_type{1} &lt;&lt; 3;\nstatic constexpr state_type kStackTrace = state_type{1} &lt;&lt; 4;\nstatic constexpr state_type kSleepTimerLock = state_type{1} &lt;&lt; 5;\nstatic constexpr state_type kCompletionHandlersLock = state_type{1} &lt;&lt; 6;\nstatic constexpr state_type kSleepTimerLockSuspend = state_type{1} &lt;&lt; 7;\nstatic constexpr state_type kCompletionHandlersClosed = state_type{1} &lt;&lt; 8;\nstatic constexpr state_type kInitialized = state_type{1} &lt;&lt; 9;\nstatic constexpr state_type kStarted = state_type{1} &lt;&lt; 10;\nstatic constexpr usize kNumStateFlags = 11;\n//----- --- -- -  -  -   -\n//\nstatic_assert((kNumStateFlags + 7) / 8 &lt;= sizeof(state_type),\n\"state_type does not have enough bits to store all the state flags!\");\n//\n//----- --- -- -  -  -   -\nusing StateBitset = std::bitset&lt;kNumStateFlags&gt;;\nstatic constexpr bool is_post_init_state(state_type state)\n{\nreturn (state &amp; kInitialized) == kInitialized;\n}\nstatic constexpr bool is_pre_start_state(state_type state)\n{\n// IMPORTANT: this must be an **exact** match.\n//\nreturn (state == (kInitialized | kNeedSignal));\n}\nstatic constexpr bool is_started_state(state_type state)\n{\nreturn (state &amp; (kInitialized | kStarted)) == (kInitialized | kStarted);\n}\nstatic constexpr bool is_running_state(state_type state)\n{\nreturn (state &amp; (kInitialized | kStarted | kSuspended)) == (kInitialized | kStarted);\n}\nstatic constexpr bool is_ready_state(state_type state)\n{\nreturn\n// The task must be suspended but not terminated.\n//\n((state &amp; (kInitialized | kStarted | kSuspended | kTerminated)) ==\n(kInitialized | kStarted | kSuspended))\n&amp;&amp; (  // *Either* task is not waiting for a signal...\n//\n(state &amp; (kNeedSignal | kHaveSignal)) == 0 ||\n// ...*Or* task was waiting for a signal, and it received one.\n//\n(state &amp; (kNeedSignal | kHaveSignal)) == (kNeedSignal | kHaveSignal)  //\n)\n// The stack trace flag is not set.\n//\n&amp;&amp; ((state &amp; kStackTrace) == 0);\n}\nstatic constexpr bool is_terminal_state(state_type state)\n{\nreturn (state &amp; (kInitialized | kStarted | kSuspended | kTerminated)) ==\n(kInitialized | kStarted | kSuspended | kTerminated);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstruct DebugTrace {\nboost::stacktrace::stacktrace stack_trace;\nstd::string debug_info;\nStateBitset state_bits;\nisize stack_growth_bytes;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic ConcurrentTaskList&amp; all_tasks();\nstatic Task&amp; current();\ntemplate &lt;typename... CtorArgs&gt;\nstatic void spawn(CtorArgs&amp;&amp;... args)\n{\nTask* parent = Task::current_ptr();\nif (parent == nullptr) {\nTask::spawn_impl(Task::all_tasks(), BATT_FORWARD(args)...);\n} else {\nTask::spawn_impl(parent-&gt;child_tasks_, BATT_FORWARD(args)...);\n}\n}\nstatic std::string_view current_name()\n{\nauto ptr = Task::current_ptr();\nif (ptr) {\nreturn ptr-&gt;name();\n}\nreturn \"\";\n}\nstatic i32 current_id()\n{\nauto ptr = Task::current_ptr();\nif (ptr) {\nreturn ptr-&gt;id();\n}\nthread_local const i32 id_ = Task::next_id();\nreturn id_;\n}\nstatic Optional&lt;usize&gt; current_stack_pos();\nstatic Optional&lt;usize&gt; current_stack_pos_of(const volatile void* ptr);\nstatic i32 backtrace_all(bool force, std::ostream&amp; out = std::cerr);\nstatic void yield();\ntemplate &lt;typename Duration = boost::posix_time::ptime&gt;\nstatic ErrorCode sleep(const Duration&amp; duration)\n{\nTask* current_task = Task::current_ptr();\nif (current_task) {\nreturn current_task-&gt;sleep_impl(duration);\n}\nstd::this_thread::sleep_for(std::chrono::nanoseconds(duration.total_nanoseconds()));\nreturn ErrorCode{};\n}\ntemplate &lt;typename R, typename Fn&gt;\nstatic R await(Fn&amp;&amp; fn)\n{\n// If there is a Task active on the current thread, use the Task impl of await.\n//\nTask* current_task = Task::current_ptr();\nif (current_task) {\nreturn current_task-&gt;template await_impl&lt;R&gt;(BATT_FORWARD(fn));\n}\n//---------------\n// This is the generic thread (non-Task) implementation:\n//\nHandlerMemory&lt;kHandlerMemoryBytes&gt; handler_memory;\n// Use MCSMutex instead of std::promise/future because it is no-alloc and very fast under light\n// contention.\n//\nMCSMutex mutex;\n// The result from the handler will go here.\n//\nOptional&lt;R&gt; result;\n// First `write_lock` acquires the mutex; it will release it when result is set.\n//\nMCSMutex::Lock write_lock{mutex};\nBATT_FORWARD(fn)\n(make_custom_alloc_handler(handler_memory, [&amp;write_lock, &amp;result /*, &amp;ok_to_exit*/](auto&amp;&amp;... args) {\nresult.emplace(BATT_FORWARD(args)...);\nwrite_lock.unlock();\n}));\n// Try to acquire the read lock.  When we succeed, it is because the write_lock has been released, so\n// the result should be initialized.\n//\nMCSMutex::Lock read_lock{mutex};\n//\n// TODO [tastolfi 2020-12-01] - detect deadlock here\nBATT_CHECK(result);\nreturn std::move(*result);\n}\n// TODO [tastolfi 2021-12-22] - Implement await_with_timeout\ntemplate &lt;typename R, typename Fn&gt;\nstatic R await(batt::StaticType&lt;R&gt;, Fn&amp;&amp; fn)\n{\nreturn Task::await&lt;R&gt;(BATT_FORWARD(fn));\n}\ntemplate &lt;typename T&gt;\nstatic StatusOr&lt;T&gt; await(const Future&lt;T&gt;&amp; future_result)\n{\nreturn Task::await&lt;StatusOr&lt;T&gt;&gt;([&amp;](auto&amp;&amp; handler) {\nfuture_result.async_wait(BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename AsyncStream, typename BufferSequence&gt;\nstatic IOResult&lt;usize&gt; await_read_some(AsyncStream&amp; s, BufferSequence&amp;&amp; buffers)\n{\nreturn Task::await&lt;IOResult&lt;usize&gt;&gt;([&amp;](auto&amp;&amp; handler) {\ns.async_read_some(BATT_FORWARD(buffers), BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename AsyncStream, typename BufferSequence&gt;\nstatic IOResult&lt;usize&gt; await_read(AsyncStream&amp; s, BufferSequence&amp;&amp; buffers)\n{\nreturn Task::await&lt;IOResult&lt;usize&gt;&gt;([&amp;](auto&amp;&amp; handler) {\nboost::asio::async_read(s, BATT_FORWARD(buffers), BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename AsyncStream, typename BufferSequence&gt;\nstatic IOResult&lt;usize&gt; await_write_some(AsyncStream&amp; s, BufferSequence&amp;&amp; buffers)\n{\nreturn Task::await&lt;IOResult&lt;usize&gt;&gt;([&amp;](auto&amp;&amp; handler) {\ns.async_write_some(BATT_FORWARD(buffers), BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename AsyncStream, typename BufferSequence&gt;\nstatic IOResult&lt;usize&gt; await_write(AsyncStream&amp; s, BufferSequence&amp;&amp; buffers)\n{\nreturn Task::await&lt;IOResult&lt;usize&gt;&gt;([&amp;](auto&amp;&amp; handler) {\nboost::asio::async_write(s, BATT_FORWARD(buffers), BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename AsyncStream, typename Endpoint&gt;\nstatic ErrorCode await_connect(AsyncStream&amp; s, const Endpoint&amp; endpoint)\n{\nreturn Task::await&lt;ErrorCode&gt;([&amp;](auto&amp;&amp; handler) {\ns.async_connect(BATT_FORWARD(endpoint), BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename AsyncAcceptor,                                      //\ntypename ProtocolT = typename AsyncAcceptor::protocol_type,  //\ntypename StreamT = typename ProtocolT::socket&gt;\nstatic IOResult&lt;StreamT&gt; await_accept(AsyncAcceptor&amp; a)\n{\nreturn Task::await&lt;IOResult&lt;StreamT&gt;&gt;([&amp;](auto&amp;&amp; handler) {\na.async_accept(BATT_FORWARD(handler));\n});\n}\ntemplate &lt;typename SignalSetT&gt;\nstatic IOResult&lt;int&gt; await_signal(SignalSetT&amp; signal_set)\n{\nreturn Task::await&lt;IOResult&lt;int&gt;&gt;([&amp;signal_set](auto&amp;&amp; handler) {\nsignal_set.async_wait(BATT_FORWARD(handler));\n});\n}\nstatic Priority current_priority()\n{\nTask* current_task = Task::current_ptr();\nif (current_task == nullptr) {\nreturn Priority{0};\n}\nreturn current_task-&gt;get_priority();\n}\nstatic bool&amp; inside_work_fn()\n{\nauto ptr = Task::current_ptr();\nif (ptr) {\nreturn ptr-&gt;is_inside_work_fn_;\n}\nthread_local bool b_ = false;\nreturn b_;\n}\nstatic std::atomic&lt;i64&gt;&amp; create_count()\n{\nstatic std::atomic&lt;i64&gt; count_{0};\nreturn count_;\n}\nstatic std::atomic&lt;i64&gt;&amp; destroy_count()\n{\nstatic std::atomic&lt;i64&gt; count_{0};\nreturn count_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nTask(const Task&amp;) = delete;\nTask&amp; operator=(const Task&amp;) = delete;\ntemplate &lt;typename BodyFn = void()&gt;\nexplicit Task(const boost::asio::any_io_executor&amp; ex, StackSize stack_size, BodyFn&amp;&amp; body_fn) noexcept\n: Task{ex, BATT_FORWARD(body_fn), /*name=*/default_name(), stack_size}\n{\n}\ntemplate &lt;typename BodyFn = void(), typename... Args, typename = EnableIfNoShadow&lt;Options, Args...&gt;&gt;\nexplicit Task(const boost::asio::any_io_executor&amp; ex, BodyFn&amp;&amp; body_fn, Args&amp;&amp;... args) noexcept\n: Task{Task::all_tasks(), ex, BATT_FORWARD(body_fn), BATT_FORWARD(args)...}\n{\n}\ntemplate &lt;typename BodyFn = void()&gt;\nexplicit Task(const boost::asio::any_io_executor&amp; ex, BodyFn&amp;&amp; body_fn) noexcept\n: Task{Task::all_tasks(), ex, BATT_FORWARD(body_fn), Options{}}\n{\n}\ntemplate &lt;typename BodyFn = void(), typename... Args, typename = EnableIfNoShadow&lt;Options, Args...&gt;&gt;\nexplicit Task(ConcurrentTaskList&amp; parent_task_list, const boost::asio::any_io_executor&amp; ex,\nBodyFn&amp;&amp; body_fn, Args&amp;&amp;... args) noexcept\n: Task{parent_task_list, ex, BATT_FORWARD(body_fn), Options::from_args(BATT_FORWARD(args)...)}\n{\n}\ntemplate &lt;typename BodyFn = void()&gt;\nexplicit Task(ConcurrentTaskList&amp; parent_task_list, const boost::asio::any_io_executor&amp; ex,\nBodyFn&amp;&amp; body_fn) noexcept\n: Task{parent_task_list, ex, BATT_FORWARD(body_fn), Options::from_args()}\n{\n}\ntemplate &lt;typename BodyFn = void(), typename OptionsT,\ntypename = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;OptionsT&gt;, Options&gt;&gt;&gt;\nexplicit Task(ConcurrentTaskList&amp; parent_task_list, const boost::asio::any_io_executor&amp; ex,\nBodyFn&amp;&amp; body_fn, OptionsT&amp;&amp; options) noexcept\n: name_(std::move(options).get_name())\n, ex_(ex)\n, priority_{options.get_priority()}\n, parent_task_list_{parent_task_list}\n{\n// Add this task to the parent list.  If this is a top-level task (no parent), then\n// `parent_task_list` will be Task::all_tasks().\n//\nthis-&gt;parent_task_list_.push_back(*this);\n// Initialize the task stack and run pre-body fn setup in the task context.  `pre_body_fn_entry` will\n// switch back to this context because kHaveSignal is set but kSignal is not.\n//\nthis-&gt;self_ = callcc(  //\noptions.get_task_stack_allocator(),\n[body_fn = ::batt::make_optional(BATT_FORWARD(body_fn)), this](Continuation&amp;&amp; parent) mutable {\nauto work_guard = boost::asio::make_work_guard(this-&gt;ex_);\nthis-&gt;pre_body_fn_entry(std::move(parent));\ntry {\n(*body_fn)();\n} catch (...) {\nBATT_LOG_WARNING() &lt;&lt; \"task fn exited via unhandled exception [task='\" &lt;&lt; this-&gt;name_\n&lt;&lt; \"']: \" &lt;&lt; boost::current_exception_diagnostic_information();\n}\nbody_fn = None;\nreturn this-&gt;post_body_fn_exit();\n});\n// Set the initalized state bit, for sanity checking.\n//\nthis-&gt;state_.fetch_or(kInitialized);\n// Unless defer start is true, start the task now (by setting the kStarted and kSignal bits to put the\n// task into a runnable state).\n//\nif (!options.get_defer_start()) {\noptions.set_is_started(true);\nthis-&gt;start();\n} else {\noptions.set_is_started(false);\n}\n// Track task creation/destruction (for diagnostics).\n//\nTask::create_count().fetch_add(1);\n}\n~Task() noexcept;\nbool is_started() const\n{\nreturn Task::is_started_state(this-&gt;state_.load());\n}\nvoid start()\n{\n// Even if kStarted is already set, this is harmless.\n//\nconst state_type prior_state = this-&gt;state_.fetch_or(kStarted);\n// If somehow we got here without having set the kInitialized bit, something has gone very wrong...\n//\nBATT_CHECK(Task::is_post_init_state(prior_state))\n&lt;&lt; \"Task started before being fully initialized!\" &lt;&lt; BATT_INSPECT(this-&gt;name())\n&lt;&lt; BATT_INSPECT(this-&gt;id());\n// This should only trigger once.\n//\nif (Task::is_pre_start_state(prior_state)) {\nthis-&gt;handle_event(kSuspended | kHaveSignal);\n}\n}\ni32 id() const\n{\nreturn this-&gt;id_;\n}\nstd::string_view name() const\n{\nreturn this-&gt;name_;\n}\nPriority get_priority() const\n{\nreturn Priority{this-&gt;priority_.load()};\n}\nvoid set_priority(Priority new_priority)\n{\nthis-&gt;priority_.store(new_priority);\n}\nusize stack_pos() const;\nusize stack_pos_of(const volatile void* ptr) const;\nvoid join();\nIsDone try_join();\nbool wake();\nexecutor_type get_executor() const\n{\nreturn this-&gt;ex_;\n}\nIsDone is_done() const;\ntemplate &lt;typename F = void()&gt;\nvoid call_when_done(F&amp;&amp; handler)\n{\nfor (;;) {\nif (this-&gt;is_done()) {\nthis-&gt;wait_for_run_completion_handlers();\nBATT_FORWARD(handler)();\nreturn;\n}\nSpinLockGuard lock{this, kCompletionHandlersLock};\nif (Task::is_terminal_state(lock.prior_state()) ||\n(lock.prior_state() &amp; kCompletionHandlersClosed) != 0) {\n// It's possible that the completion handlers list was cleared out after the call to\n// `is_done()` above, but before we grab the spin lock.  If so, keep retrying until we resolve\n// the race.\n//\ncontinue;\n}\npush_handler(&amp;this-&gt;completion_handlers_, BATT_FORWARD(handler));\nreturn;\n}\n}\n// =#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nDebugInfoFrame* debug_info = nullptr;\n// =#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nprivate:\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\nclass SpinLockGuard\n{\npublic:\nexplicit SpinLockGuard(Task* task, state_type mask) noexcept : task_{task}, mask_{mask}\n{\nthis-&gt;prior_state_ = task_-&gt;spin_lock(mask);\n}\nSpinLockGuard(const SpinLockGuard&amp;) = delete;\nSpinLockGuard&amp; operator=(const SpinLockGuard&amp;) = delete;\n~SpinLockGuard() noexcept\n{\ntask_-&gt;spin_unlock(mask_);\n}\nstate_type prior_state() const\n{\nreturn this-&gt;prior_state_;\n}\nprivate:\nTask* const task_;\nconst state_type mask_;\nstate_type prior_state_;\n};\nclass Trampoline\n{\npublic:\nstatic void activate_task(Task* t) noexcept;\nstatic Task* get_current_task() noexcept;\nprivate:\nstatic Trampoline&amp; per_thread_instance() noexcept;\nTask* next_to_run_ = nullptr;\nTask* current_task_ = nullptr;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic i32 next_id();\nstatic Task* current_ptr();\ntemplate &lt;typename... TaskCtorArgs&gt;\nstatic void spawn_impl(ConcurrentTaskList&amp; parent_task_list, TaskCtorArgs&amp;&amp;... task_ctor_args)\n{\nTask* const child = new Task{parent_task_list, BATT_FORWARD(task_ctor_args)...};\nchild-&gt;call_when_done([child] {\ndelete child;\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Invoked in the task's context prior to entering the task function; yields control back to the parent\n// context, ensuring that the task function is invoked via the executor.\n//\nvoid pre_body_fn_entry(Continuation&amp;&amp; parent) noexcept;\n// Invoked in the task's context after the task function returns.\n//\nContinuation post_body_fn_exit() noexcept;\n// Suspend the task, resuming the parent context.\n//\nvoid yield_impl();\n// Set the timer to expire after the given duration, suspending the task in a manner identical to\n// `await_impl`.\n//\nErrorCode sleep_impl(const boost::posix_time::time_duration&amp; duration);\n// Clears state flags kSuspended|kNeedSignal|kHaveSignal and resumes the task via its executor.  If\n// `force_post` is true, the resume is always scheduled via boost::asio::post.  Otherwise, if\n// Task::nesting_depth() is below the limit, boost::asio::dispatch is used instead.  `observed_state` is\n// the last observed value of `Task::state_`.\n//\nvoid schedule_to_run(state_type observed_state, bool force_post = false);\n// Resumes execution of the task on the current thread; this is the normal code path, when the task\n// receives a signal or is ready to run.  Stack traces collected on the task do not use this method;\n// rather they directly call resume_impl after atomically setting the kStackTrace bit (conditional on the\n// thread *not* being in a running, ready-to-run, or terminal state).\n//\nIsDone run();\n// Switch the current thread context to the task and resume execution.\n//\nvoid resume_impl();\n// `fn` is passed a callable acting as the continutation of the suspended Task.  This continuation may\n// receive any set of arguments from which the await operation's result type `R` can be constructed.\n//\ntemplate &lt;typename R, typename Fn&gt;\nR await_impl(Fn&amp;&amp; fn)\n{\nOptional&lt;R&gt; result;\nHandlerMemory&lt;kHandlerMemoryBytes&gt; handler_memory;\nconst state_type prior_state = this-&gt;state_.fetch_or(kNeedSignal);\nBATT_CHECK_NE((prior_state &amp; kHaveSignal), kHaveSignal) &lt;&lt; \"prior_state=\" &lt;&lt; StateBitset{prior_state};\nBATT_FORWARD(fn)\n(/*callback handler=*/make_custom_alloc_handler(\nhandler_memory,\n[this,\n&amp;result](auto&amp;&amp;... args) -&gt; std::enable_if_t&lt;std::is_constructible_v&lt;R, decltype(args)&amp;&amp;...&gt;&gt; {\nresult.emplace(BATT_FORWARD(args)...);\nthis-&gt;handle_event(kHaveSignal);\n}));\n// Fast path - if `fn` provided an immediate result, there is no need to run the scheduler.\n//\nif (result &amp;&amp; Task::is_ready_state(this-&gt;state_ | Task::kSuspended)) {\nconst state_type pre_yield_state = this-&gt;state_.fetch_and(~(kNeedSignal | kHaveSignal));\nBATT_CHECK_EQ((pre_yield_state &amp; (kNeedSignal | kHaveSignal)), (kNeedSignal | kHaveSignal));\n} else {\n// Suspend this Task.  It will not be in a ready state until the kHaveSignal event has been\n// handled.\n//\nthis-&gt;yield_impl();\n}\nreturn std::move(*result);\n}\n// Tells the task to handle events which may affect its running/suspended state.  This function is safe to\n// invoke inside the task or outside.  `event_mask` *must* be one of:\n//\n// - kHaveSignal\n// - kSuspended\n// - kTerminated\n//\nvoid handle_event(state_type event_mask);\n// Acquire a spin lock on the given state bit mask.  `lock_mask` must be one of:\n//\n// - kSleepTimerLock\n// - kCompletionHandlersLock\n//\n// Locks acquired via this function are not recursive.\n//\nstate_type spin_lock(state_type lock_mask);\n// Same as `spin_lock`, except only try once to acquire the lock.  Returns `true` iff the lock was\n// acquired. Sets `prior_state` equal to the last observed value of `state_`.\n//\nbool try_spin_lock(state_type lock_mask, state_type&amp; prior_state);\n// Release the given spin lock bit.  `lock_mask` must be a legal value passed to\n// `spin_lock`/`try_spin_lock`, and the calling thread must currently hold a lock on the given bit\n// (acquired via `spin_lock`/`try_spin_lock`).\n//\nvoid spin_unlock(state_type lock_mask);\n// Attempt to collect a stack trace from the task, dumping it to stderr if successful.  This will fail if\n// the task is running, ready-to-run, or terminated.  Returns true iff successful.\n//\nbool try_dump_stack_trace(bool force, std::ostream&amp; out = std::cerr);\n// Activate this task via boost::asio::post.\n//\nvoid activate_via_post();\n// Activate this task via boost::asio::dispatch.\n//\nvoid activate_via_dispatch();\n// Create an activation completion handler for use inside `activate_via_post`, `activate_via_dispatch`,\n// etc.\n//\nauto make_activation_handler(bool via_post);\n// Joins to all child tasks.\n//\nvoid join_child_tasks();\n// Unconditionally removes completion handlers from `this` and runs them on the current thread/task.\n//\nvoid run_completion_handlers();\n// Waits for run_completion_handlers to run; must only be called *after* this-&gt;is_done() returns true.\n//\nvoid wait_for_run_completion_handlers();\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Process-unique serial id number for this Task; automatically assigned at construction time.\n//\nconst i32 id_ = next_id();\n// Human-readable (non-unique) name for this Task; passed in at construction time.\n//\nconst std::string name_;\n// The (Boost.Async) Executor used to activate/schedule this task.\n//\nexecutor_type ex_;\n// The most recent context from which this Task was activated/scheduled.  If this is non-empty, then the\n// task is active/running.  At most one of `scheduler_` and `self_` are non-empty at any given time.\n//\nContinuation scheduler_;\n// The current (suspended) context of this Task.  If this is non-copy, then the task is suspended/waiting.\n// At most one of `scheduler_` and `self_` are non-empty at any given time.\n//\nContinuation self_;\n// Contains all spin lock bits and run-state information for this task.  Initially set to `kNeedSignal`\n// because the task must receive the \"go\" signal before it can enter normal operation.\n//\nstd::atomic&lt;state_type&gt; state_{kNeedSignal};\n// The current advisory priority for this task.  Higher numeric values signify more urgent priority.\n//\nstd::atomic&lt;Priority::value_type&gt; priority_;\n// Used to implement this-&gt;sleep().\n//\nOptional&lt;boost::asio::deadline_timer&gt; sleep_timer_;\n// When a stack trace is gathered from a task, we must temporarily swap its context in, then capture the\n// stack, then swap back; this member stores the stack trace.  TODO [tastolfi 2023-02-21] there could be a\n// race condition on this field if two threads attempt to capture a stack trace on the same task\n// concurrently!\n//\nOptional&lt;boost::stacktrace::stacktrace&gt; stack_trace_;\n// A linked list of handlers that are waiting for notification when this task finishes/joins.\n//\nHandlerList&lt;&gt; completion_handlers_;\n// A handler-attached memory buffer used whenever this task is scheduled via dispatch or post;\n// conceptually, this memory is used to store linked-list pointers for the task on some scheduler queue.\n//\nHandlerMemory&lt;kHandlerMemoryBytes&gt; activate_memory_;\n// Set to an address near the base of the stack when the task begins running; used to estimate the current\n// stack growth.\n//\nconst volatile u8* stack_base_ = nullptr;\n// Set to true when this task performs some action that causes a task with higher priority to move into a\n// ready state; this causes the current task to be rescheduled via `post()` so that the higher priority\n// task can be scheduled immediately, possibly on the same thread, via `dispatch()`.\n//\nbool is_preempted_ = false;\n// Used to prevent deadlock in WorkerPools.\n//\nbool is_inside_work_fn_ = false;\n// Monotonic counter, incremented whenever this task is suspended.\n//\nvolatile usize suspend_count_ = 0;\n// Monotonic counter, incremented whenever this task is resumed.\n//\nvolatile usize resume_count_ = 0;\n// A list of spawned tasks; will be joined when this terminates.\n//\nConcurrentTaskList child_tasks_;\n// The list to which this task was added at creation time.\n//\nConcurrentTaskList&amp; parent_task_list_;\n};\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Fn, typename R&gt;\nR Task::ConcurrentTaskList::with_lock(Fn&amp;&amp; fn)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn BATT_FORWARD(fn)(this-&gt;task_list_);\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_TASK_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/task__impl_8hpp/","title":"batteries/async/task_impl.hpp","text":""},{"location":"_autogen/Files/task__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/task__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_TASK_IMPL_HPP"},{"location":"_autogen/Files/task__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/task__impl_8hpp/#define-batteries_async_task_impl_hpp","title":"define BATTERIES_ASYNC_TASK_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_TASK_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/task__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_TASK_IMPL_HPP\n#define BATTERIES_ASYNC_TASK_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/debug_info.hpp&gt;\n#include &lt;batteries/async/fake_time_service.hpp&gt;\n#include &lt;batteries/async/future.hpp&gt;\n#include &lt;batteries/async/watch.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/no_destruct.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\nnamespace batt {\nBATT_INLINE_IMPL i32 next_thread_id()\n{\nstatic std::atomic&lt;i32&gt; id_{1000};\nreturn id_.fetch_add(1);\n}\nBATT_INLINE_IMPL i32&amp; this_thread_id()\n{\nthread_local i32 id_ = next_thread_id();\nreturn id_;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Task static methods.\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize&amp; Task::nesting_depth()\n{\nthread_local usize depth_ = 0;\nreturn depth_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL i32 Task::next_id()\n{\nstatic std::atomic&lt;i32&gt; id_{1};\nreturn id_.fetch_add(1);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Task* Task::current_ptr()\n{\nreturn Trampoline::get_current_task();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Task&amp; Task::current()\n{\nreturn *current_ptr();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto Task::all_tasks() -&gt; ConcurrentTaskList&amp;\n{\nstatic NoDestruct&lt;ConcurrentTaskList&gt; instance_;\nreturn *instance_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::yield()\n{\nTask* current_task = Task::current_ptr();\nif (current_task) {\ncurrent_task-&gt;yield_impl();\nreturn;\n}\nstd::this_thread::yield();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ Optional&lt;usize&gt; Task::current_stack_pos()\n{\nTask* current_task = Task::current_ptr();\nif (current_task) {\nreturn current_task-&gt;stack_pos();\n}\nreturn None;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ Optional&lt;usize&gt; Task::current_stack_pos_of(const volatile void* ptr)\n{\nTask* current_task = Task::current_ptr();\nif (current_task) {\nreturn current_task-&gt;stack_pos_of(ptr);\n}\nreturn None;\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Task instance methods.\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Task::~Task() noexcept\n{\nBATT_CHECK(!this-&gt;scheduler_);\nBATT_CHECK(!this-&gt;self_) &lt;&lt; BATT_INSPECT(this-&gt;id_) &lt;&lt; BATT_INSPECT_STR(this-&gt;name_)\n&lt;&lt; [this](std::ostream&amp; out) {\nprint_debug_info(this-&gt;debug_info, out);\n};\nBATT_CHECK(is_terminal_state(this-&gt;state_.load())) &lt;&lt; \"state=\" &lt;&lt; StateBitset{this-&gt;state_.load()};\nthis-&gt;parent_task_list_.unlink(*this);\nTask::destroy_count().fetch_add(1);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::pre_body_fn_entry(Continuation&amp;&amp; scheduler) noexcept\n{\nBATT_VLOG(1) &lt;&lt; \"Task{.name=\" &lt;&lt; this-&gt;name_ &lt;&lt; \",} created on thread \" &lt;&lt; this_thread_id();\n// Save the base address of the call stack.\n//\nvolatile u8 base = 0;\nthis-&gt;stack_base_ = &amp;base;\n// Transfer control back to the Task ctor.  This Task will be scheduled to run (activated) at the end of\n// the ctor.\n//\nthis-&gt;suspend_count_ = this-&gt;suspend_count_ + 1;\nthis-&gt;scheduler_ = scheduler.resume();\nthis-&gt;resume_count_ = this-&gt;resume_count_ + 1;\nBATT_VLOG(1) &lt;&lt; \"Task{.name=\" &lt;&lt; this-&gt;name_ &lt;&lt; \",} started on thread \" &lt;&lt; this_thread_id();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Continuation Task::post_body_fn_exit() noexcept\n{\n// Wait for all child tasks to terminate.  IMPORTANT: this needs to happen here, before we return the\n// `scheduler_`/`parent` Continuation, and before we set the kTerminated flag, because the join mechanism\n// relies on Watch::await_equal, which requires this Task to still be in \"normal operation\" mode.\n//\nthis-&gt;join_child_tasks();\nContinuation parent = std::move(this-&gt;scheduler_);\nBATT_CHECK(parent);\nthis-&gt;handle_event(kTerminated);\nreturn parent;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::join_child_tasks()\n{\nBATT_DEBUG_INFO(BATT_INSPECT_STR(this-&gt;name())\n&lt;&lt; \",\" &lt;&lt; BATT_INSPECT(this-&gt;id()) &lt;&lt; \": join_child_tasks()\"\n&lt;&lt; this-&gt;child_tasks_.debug_info(\"\"));\ntry {\nthis-&gt;child_tasks_.await_empty();\n} catch (...) {\nBATT_PANIC() &lt;&lt; \"this-&gt;child_tasks_.await_empty() exited via unhandled exception [task='\"\n&lt;&lt; this-&gt;name_ &lt;&lt; \"']: \" &lt;&lt; boost::current_exception_diagnostic_information();\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::run_completion_handlers()\n{\nBATT_CHECK(this-&gt;is_done());\nBATT_CHECK(!this-&gt;scheduler_);\nBATT_CHECK(!this-&gt;self_);\nHandlerList&lt;&gt; local_handlers;\n{\nSpinLockGuard lock{this, kCompletionHandlersLock};\nstd::swap(this-&gt;completion_handlers_, local_handlers);\n{\n// Set a state bit to make sure that there is no window of time where it is possible to add a\n// new handler after this lambda executes, but before `this-&gt;is_done()` returns true.\n//\n// IMPORTANT: This must be the only place we set the kCompletionHandlersClosed bit, AND it must be\n// _after_ we have swapped `this-&gt;completion_handlers_` with `local_handlers`!\n//\nconst state_type prior_state = this-&gt;state_.fetch_or(kCompletionHandlersClosed);\nBATT_CHECK_EQ(prior_state &amp; kCompletionHandlersClosed, state_type(0))\n&lt;&lt; BATT_INSPECT(Task::StateBitset{prior_state});\n}\n}\ninvoke_all_handlers(&amp;local_handlers);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::wait_for_run_completion_handlers()\n{\n// Fast path: since we know that kCompletionHandlersClosed is only set once, while holding the\n// kCompletionHandlersLock (see the BATT_CHECK on `prior_state` in `run_completion_handlers()`), if we see\n// the closed bit set without the lock bit set, then we know we are strictly _after_\n// `run_completion_handlers() releasing its spin lock.  Therefore it is safe to delete the task!\n{\nconst state_type observed_state = this-&gt;state_.load();\nif ((observed_state &amp; (kCompletionHandlersClosed | kCompletionHandlersLock)) ==\nkCompletionHandlersClosed) {\nreturn;\n}\n}\n// Acquire a lock on completion handlers to make sure that there isn't a concurrent\n// (racing) thread inside `Task::run_completion_handlers()`.  When `handler` is invoked,\n// we must be _absolutely sure_ that it is safe to delete this Task.\n//\nfor (;;) {\nSpinLockGuard lock{this, kCompletionHandlersLock};\nBATT_CHECK(this-&gt;is_done());\nBATT_CHECK(this-&gt;completion_handlers_.empty());\n// We have to be sure that Task::run_completion_handlers has been invoked and has gotten\n// past the point where it will read anything from `this`.  Because the\n// kCompletionHandlersClosed bit is only set at this point, but prior to releasing the\n// kCompletionHandlersLock spin lock (inside run_completion_handlers), if we observe\n// kCompletionHandlersClosed set while holding the spin lock, we know it is safe to invoke\n// `handler` (which may cause `this` to be deleted).\n//\nif ((lock.prior_state() &amp; kCompletionHandlersClosed) != 0) {\nbreak;\n}\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL ErrorCode Task::sleep_impl(const boost::posix_time::time_duration&amp; duration)\n{\nSpinLockGuard lock{this, kSleepTimerLock};\n// The deadline_timer is lazily constructed.\n//\nif (!this-&gt;sleep_timer_) {\n// First check to see if this Task's executor is configured to use the FakeTimeService.  If so, do\n// a fake wait instead of a real one.\n//\nboost::asio::execution_context&amp; context = this-&gt;ex_.context();\nif (boost::asio::has_service&lt;FakeTimeService&gt;(context)) {\nFakeTimeService&amp; fake_time = boost::asio::use_service&lt;FakeTimeService&gt;(context);\nconst FakeTimeService::TimePoint expires_at = fake_time.now() + duration;\nreturn this-&gt;await_impl&lt;ErrorCode&gt;([this, &amp;fake_time, expires_at](auto&amp;&amp; handler) {\nfake_time.async_wait(this-&gt;ex_, expires_at, BATT_FORWARD(handler));\n});\n}\nthis-&gt;sleep_timer_.emplace(this-&gt;ex_);\n}\nthis-&gt;sleep_timer_-&gt;expires_from_now(duration);\nreturn this-&gt;await_impl&lt;ErrorCode&gt;([&amp;](auto&amp;&amp; handler) {\nthis-&gt;sleep_timer_-&gt;async_wait(BATT_FORWARD(handler));\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize Task::stack_pos() const\n{\nvolatile u8 pos = 0;\nreturn this-&gt;stack_pos_of(&amp;pos);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL usize Task::stack_pos_of(const volatile void* ptr) const\n{\nconst u8* pos = (const u8*)ptr;\nif (pos &lt; this-&gt;stack_base_) {\nreturn this-&gt;stack_base_ - pos;\n} else {\nreturn pos - this-&gt;stack_base_;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::join()\n{\nBATT_DEBUG_INFO(BATT_INSPECT_STR(this-&gt;name()) &lt;&lt; \",\" &lt;&lt; BATT_INSPECT(this-&gt;id()));\nNoneType ignored = Task::await&lt;NoneType&gt;([this](auto&amp;&amp; handler) {\nthis-&gt;call_when_done(bind_handler(BATT_FORWARD(handler), [](auto&amp;&amp; handler) {\nBATT_FORWARD(handler)(None);\n}));\n});\n(void)ignored;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Task::IsDone Task::try_join()\n{\nreturn this-&gt;is_done();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Task::IsDone Task::is_done() const\n{\nreturn IsDone{Task::is_terminal_state(this-&gt;state_.load())};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool Task::wake()\n{\nSpinLockGuard lock{this, kSleepTimerLock};\nif (this-&gt;sleep_timer_) {\nErrorCode ec;\nthis-&gt;sleep_timer_-&gt;cancel(ec);\nif (!ec) {\nreturn true;\n}\n}\nreturn false;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::handle_event(u32 event_mask)\n{\nconst u32 new_state = this-&gt;state_.fetch_or(event_mask) | event_mask;\nif (is_ready_state(new_state)) {\nconst bool force_post = this-&gt;is_preempted_;\nthis-&gt;is_preempted_ = false;\nthis-&gt;schedule_to_run(new_state, force_post);\n//\n} else if (is_terminal_state(new_state)) {\n// NOTE: we only enter this code path once the context has been swapped back to the Trampoline\n// (thereby deactivating the task stack).  This is crucial to allowing the Task to be deleted from\n// inside a completion handler!\n//\nBATT_CHECK_EQ(Task::current_ptr(), nullptr);\nBATT_CHECK(!this-&gt;self_);\nBATT_CHECK(!this-&gt;scheduler_);\nBATT_VLOG(1) &lt;&lt; \"[Task] \" &lt;&lt; this-&gt;name_ &lt;&lt; \" exiting\";\nthis-&gt;run_completion_handlers();\n//\n// IMPORTANT: there must be no access of `this` after `run_completion_handlers()`, since one of\n// the completion handlers may have deleted the Task object.\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::schedule_to_run(u32 observed_state, bool force_post)\n{\nfor (;;) {\nif (!is_ready_state(observed_state)) {\nreturn;\n}\nconst u32 target_state = observed_state &amp; ~(kSuspended | kNeedSignal | kHaveSignal);\nif (this-&gt;state_.compare_exchange_weak(observed_state, target_state)) {\nbreak;\n}\n}\nBATT_CHECK(is_ready_state(observed_state));\nBATT_CHECK(this-&gt;self_);\nif (!force_post &amp;&amp; Task::nesting_depth() &lt; kMaxNestingDepth) {\n++Task::nesting_depth();\nauto on_scope_exit = batt::finally([] {\n--Task::nesting_depth();\n});\nthis-&gt;activate_via_dispatch();\n} else {\nthis-&gt;activate_via_post();\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL Task::IsDone Task::run()\n{\n// If the sleep timer lock was held *the last time* we yielded control, then re-acquire it now.\n//\nu32 observed_state = this-&gt;state_.load();\nif (observed_state &amp; kSleepTimerLockSuspend) {\nfor (;;) {\nif (observed_state &amp; kSleepTimerLock) {\nobserved_state = this-&gt;state_.load();\ncontinue;\n}\nconst u32 target_state = (observed_state &amp; ~kSleepTimerLockSuspend) | kSleepTimerLock;\nif (this-&gt;state_.compare_exchange_weak(observed_state, target_state)) {\nbreak;\n}\n}\n}\nthis-&gt;resume_impl();\n// If the sleep timer lock was held *this time* when we yielded, then atomically release it and set\n// the kSleepTimerLockSuspend bit so we re-acquire it next time.\n//\nobserved_state = this-&gt;state_.load();\nif (observed_state &amp; kSleepTimerLock) {\nfor (;;) {\nconst u32 target_state = (observed_state &amp; ~kSleepTimerLock) | kSleepTimerLockSuspend;\nif (this-&gt;state_.compare_exchange_weak(observed_state, target_state)) {\nbreak;\n}\n}\n}\nreturn IsDone{(observed_state &amp; kTerminated) == kTerminated};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::resume_impl()\n{\nBATT_CHECK(this-&gt;self_) &lt;&lt; StateBitset{this-&gt;state_.load()};\nthis-&gt;self_ = this-&gt;self_.resume();\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::yield_impl()\n{\nBATT_CHECK(this-&gt;scheduler_) &lt;&lt; StateBitset{this-&gt;state_.load()};\nfor (;;) {\nthis-&gt;suspend_count_ = this-&gt;suspend_count_ + 1;\nthis-&gt;scheduler_ = this-&gt;scheduler_.resume();\nthis-&gt;resume_count_ = this-&gt;resume_count_ + 1;\n// If a stack trace has been requested, print it and suspend.\n//\nif (this-&gt;state_ &amp; kStackTrace) {\nthis-&gt;stack_trace_.emplace();\ncontinue;\n}\nbreak;\n}\nBATT_CHECK_EQ(Task::current_ptr(), this);\nBATT_CHECK(this-&gt;scheduler_) &lt;&lt; StateBitset{this-&gt;state_.load()};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL u32 Task::spin_lock(u32 lock_mask)\n{\nu32 prior_state = 0;\nif (!this-&gt;try_spin_lock(lock_mask, prior_state)) {\nfor (;;) {\nstd::this_thread::yield();\nif (this-&gt;try_spin_lock(lock_mask, prior_state)) {\nbreak;\n}\n}\n}\nreturn prior_state;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool Task::try_spin_lock(u32 lock_mask, u32&amp; prior_state)\n{\nprior_state = this-&gt;state_.fetch_or(lock_mask);\nreturn (prior_state &amp; lock_mask) == 0;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::spin_unlock(u32 lock_mask)\n{\nthis-&gt;state_.fetch_and(~lock_mask);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL i32 Task::backtrace_all(bool force, std::ostream&amp; out)\n{\nstd::function&lt;i32(TaskList &amp; tasks)&gt; backtrace_all_task_list_fn;\nthread_local i32 nesting_depth = 0;\nbacktrace_all_task_list_fn = [&amp;](TaskList&amp; tasks) {\ni32 i = 0;\nfor (auto&amp; t : tasks) {\nout &lt;&lt; \"-- Task{id=\" &lt;&lt; t.id() &lt;&lt; \", name=\" &lt;&lt; t.name_ &lt;&lt; \", suspend=\" &lt;&lt; t.suspend_count_\n&lt;&lt; \", resume=\" &lt;&lt; t.resume_count_ &lt;&lt; \"} -------------\" &lt;&lt; std::endl;\nif (!t.try_dump_stack_trace(force, out)) {\nout &lt;&lt; \" &lt;no stack available&gt;\" &lt;&lt; std::endl;\n}\nout &lt;&lt; std::endl;\n++nesting_depth;\nauto on_scope_exit = batt::finally([&amp;] {\n--nesting_depth;\n});\nt.child_tasks_.with_lock(backtrace_all_task_list_fn);\n++i;\n}\nif (nesting_depth &gt; 1) {\nout &lt;&lt; i &lt;&lt; \" Subtasks are active\" &lt;&lt; std::endl;\n} else {\nout &lt;&lt; i &lt;&lt; \" Tasks are active\" &lt;&lt; std::endl;\n}\nprint_all_threads_debug_info(out);\nreturn i;\n};\nreturn Task::all_tasks().with_lock(backtrace_all_task_list_fn);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL bool Task::try_dump_stack_trace(bool force, std::ostream&amp; out)\n{\nconst auto dump_debug_info = [&amp;] {\nif (this-&gt;debug_info) {\nout &lt;&lt; \"DEBUG:\" &lt;&lt; std::endl;\nprint_debug_info(this-&gt;debug_info, out);\nout &lt;&lt; std::endl;\n}\n};\nu32 observed_state = this-&gt;state_.load();\nconst auto dump_state_bits = [&amp;](std::ostream&amp; out) {\nif (is_terminal_state(observed_state)) {\nout &lt;&lt; \"(terminated) \";\n} else if (is_running_state(observed_state)) {\nout &lt;&lt; \"(running) \";\n} else if (is_ready_state(observed_state)) {\nout &lt;&lt; \"(ready) \";\n} else if (observed_state &amp; kStackTrace) {\nout &lt;&lt; \"(busy) \";\n} else {\nout &lt;&lt; \"(suspended) \";\n}\nout &lt;&lt; \"state=\" &lt;&lt; StateBitset{this-&gt;state_}\n&lt;&lt; \" strt,init,chdc,tims,hdlr,timr,dump,term,susp,have,need\";\n};\nfor (;;) {\nif (is_running_state(observed_state) || is_ready_state(observed_state) ||\nis_terminal_state(observed_state) || (observed_state &amp; kStackTrace)) {\nout &lt;&lt; dump_state_bits &lt;&lt; std::endl;\nif (force) {\n// This is dangerous, but sometimes you just need a clue about what is happening!\n//\ndump_debug_info();\n}\nreturn false;\n}\nconst state_type target_state = observed_state | kStackTrace;\nif (this-&gt;state_.compare_exchange_weak(observed_state, target_state)) {\nbreak;\n}\n}\nout &lt;&lt; dump_state_bits &lt;&lt; std::endl;\ndump_debug_info();\nthis-&gt;resume_impl();\nBATT_CHECK(this-&gt;stack_trace_);\nout &lt;&lt; *this-&gt;stack_trace_ &lt;&lt; std::endl;\nthis-&gt;stack_trace_ = None;\nobserved_state = this-&gt;state_.load();\nfor (;;) {\nconst state_type target_state = (observed_state &amp; ~kStackTrace) | kSuspended;\nBATT_CHECK(!is_terminal_state(target_state))\n&lt;&lt; \"This should never happen because we check for terminal state above and calling \"\n\"Task::resume_impl with the StackTrace bit set should never terminate the task.\";\nif (this-&gt;state_.compare_exchange_weak(observed_state, target_state)) {\nobserved_state = target_state;\nbreak;\n}\n}\nif (is_ready_state(observed_state)) {\nthis-&gt;schedule_to_run(observed_state, /*force_post=*/true);\n}\nreturn true;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto Task::make_activation_handler(bool via_post)\n{\nreturn make_custom_alloc_handler(this-&gt;activate_memory_, [this, via_post] {\nif (via_post) {\nBATT_CHECK_EQ(Task::current_ptr(), nullptr);\n}\nTrampoline::activate_task(this);\n});\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::activate_via_post()\n{\nboost::asio::post(this-&gt;ex_, this-&gt;make_activation_handler(/*via_post=*/true));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::activate_via_dispatch()\n{\nboost::asio::dispatch(this-&gt;ex_, this-&gt;make_activation_handler(/*via_post=*/false));\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ void Task::Trampoline::activate_task(Task* task_to_activate) noexcept\n{\nauto&amp; self = per_thread_instance();\nwhile (task_to_activate != nullptr) {\n// If there is a task currently active on the current thread, then we will either soft-preempt it\n// and reschedule the current task, or queue a deferred activation of `task_to_activate` via post.\n//\nif (self.current_task_ != nullptr) {\nif (self.current_task_-&gt;get_priority() &gt;= task_to_activate-&gt;get_priority()) {\n// In this case, the current task gets to keep running on this thread because it has equal\n// or higher priority.\n//\ntask_to_activate-&gt;activate_via_post();\n} else {\n// In this case, we're going to force the current task to yield and re-activate it via\n// post. By setting the Trampoline's `next_to_run_` to the task that has preempted it, we\n// arrange for `task_to_activate` to be run after the current task yields.  Because there\n// is a current task and Task::run() may only be called from Trampoline::activate_task,\n// there must be a call to `activate_task` in the current task's scheduling context, so by\n// yielding, we allow that call to run `task_to_activate`.\n//\nBATT_CHECK_EQ(self.next_to_run_, nullptr);\nself.next_to_run_ = task_to_activate;\nself.current_task_-&gt;is_preempted_ = true;\nself.current_task_-&gt;yield_impl();\n}\nreturn;  // continue running `current_task`.\n}\n// else (self.current_task_ == nullptr)\n{\nBATT_CHECK_EQ(self.current_task_, nullptr);\nself.current_task_ = task_to_activate;\nauto on_scope_exit = finally([&amp;self, activated_task = task_to_activate] {\nBATT_CHECK_EQ(self.current_task_, activated_task);\nself.current_task_ = nullptr;\nactivated_task-&gt;handle_event(kSuspended);\n//\n// IMPORTANT: do not touch `activated_task` after handle_event, as the task object may have\n// been deleted!\n});\ntask_to_activate-&gt;run();\n}\n// Prepare to run the next task.\n//\ntask_to_activate = self.next_to_run_;\nself.next_to_run_ = nullptr;\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ Task* Task::Trampoline::get_current_task() noexcept\n{\nreturn Task::Trampoline::per_thread_instance().current_task_;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ auto Task::Trampoline::per_thread_instance() noexcept -&gt; Trampoline&amp;\n{\nthread_local Trampoline instance;\nreturn instance;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::ConcurrentTaskList::dump_log_info(std::string_view label)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nTask::ConcurrentTaskList::dump_log_info_locked(lock, label);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::ConcurrentTaskList::dump_log_info_locked(std::unique_lock&lt;std::mutex&gt;&amp; lock,\nstd::string_view label)\n{\nBATT_LOG_INFO() &lt;&lt; this-&gt;debug_info_locked(lock, label);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto Task::ConcurrentTaskList::debug_info(std::string_view label) noexcept\n-&gt; batt::SmallFn&lt;void(std::ostream&amp;)&gt;\n{\nreturn [this, label](std::ostream&amp; out) {\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nout &lt;&lt; this-&gt;debug_info_locked(lock, label);\n};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL auto Task::ConcurrentTaskList::debug_info_locked(\nstd::unique_lock&lt;std::mutex&gt;&amp;, std::string_view label) noexcept -&gt; batt::SmallFn&lt;void(std::ostream&amp;)&gt;\n{\nreturn [this, label](std::ostream&amp; out) {\nout &lt;&lt; label &lt;&lt; \": (begin)\\n\";\nfor (Task&amp; t : this-&gt;task_list_) {\nout &lt;&lt; label &lt;&lt; \": \" &lt;&lt; BATT_INSPECT(t.id()) &lt;&lt; BATT_INSPECT_STR(t.name()) &lt;&lt; \"\\n\";\n}\nout &lt;&lt; label &lt;&lt; \": (end)\";\n};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::ConcurrentTaskList::push_back(Task&amp; task)\n{\nBATT_CHECK(!task.is_linked());\nthis-&gt;link_count_.fetch_add(1);\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nBATT_ASSERT(!task.is_linked());\nthis-&gt;task_list_.push_back(task);\nBATT_ASSERT(task.is_linked());\n}\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::ConcurrentTaskList::unlink(Task&amp; task)\n{\nif (!task.is_linked()) {\nreturn;\n}\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nBATT_ASSERT(task.is_linked());\ntask.unlink();\nBATT_ASSERT(!task.is_linked());\n}\nthis-&gt;unlink_count_.fetch_add(1);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL void Task::ConcurrentTaskList::await_empty()\n{\nconst i64 observed_link_count = this-&gt;link_count_.load();\ni64 observed_unlink_count = this-&gt;unlink_count_.get_value();\nwhile (observed_unlink_count != this-&gt;link_count_.load()) {\nBATT_CHECK_EQ(observed_link_count, this-&gt;link_count_.load())\n&lt;&lt; \"link_count_ should not change once we enter `await_empty()!\";\nBATT_CHECK_LT(observed_unlink_count, observed_link_count)\n&lt;&lt; \"The link_count and unlink_count should never go backwards, and unlink_count should never get \"\n\"ahead of the link_count!\";\nStatusOr&lt;i64&gt; new_unlink_count = this-&gt;unlink_count_.await_not_equal(observed_unlink_count);\nif (!new_unlink_count.ok()) {\nbreak;\n}\nBATT_CHECK_GE(*new_unlink_count, observed_unlink_count)\n&lt;&lt; \"unlink_count should never go backwards!\" &lt;&lt; BATT_INSPECT(this-&gt;link_count_.load());\nobserved_unlink_count = *new_unlink_count;\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_TASK_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/task__scheduler_8hpp/","title":"batteries/async/task_scheduler.hpp","text":""},{"location":"_autogen/Files/task__scheduler_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/task__scheduler_8hpp/#classes","title":"Classes","text":"Name class batt::TaskScheduler class batt::NullTaskScheduler"},{"location":"_autogen/Files/task__scheduler_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_TASK_SCHEDULER_HPP"},{"location":"_autogen/Files/task__scheduler_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/task__scheduler_8hpp/#define-batteries_async_task_scheduler_hpp","title":"define BATTERIES_ASYNC_TASK_SCHEDULER_HPP","text":"<pre><code>#define BATTERIES_ASYNC_TASK_SCHEDULER_HPP()\n</code></pre>"},{"location":"_autogen/Files/task__scheduler_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_TASK_SCHEDULER_HPP\n#define BATTERIES_ASYNC_TASK_SCHEDULER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/asio/any_io_executor.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\nnamespace batt {\nclass TaskScheduler\n{\npublic:\nTaskScheduler(const TaskScheduler&amp;) = delete;\nTaskScheduler&amp; operator=(const TaskScheduler&amp;) = delete;\nvirtual ~TaskScheduler() = default;\n// Select an executor to run a new task.\n//\nvirtual boost::asio::any_io_executor schedule_task() = 0;\n// Request shutdown of all threads/executors owned by this scheduler.  Does not wait for shutdown\n// to complete; see TaskScheduler::join().\n//\nvirtual void halt() = 0;\n// Wait for shutdown of all threads/executors owned by this scheduler.  Does not initiate shutdown\n// per se, just waits for shutdown to complete.  See TaskScheduler::halt().\n//\nvirtual void join() = 0;\nprotected:\nTaskScheduler() = default;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// TaskScheduler implementation that does not schedule anything (`schedule_task` panics).\n//\nclass NullTaskScheduler : public TaskScheduler\n{\npublic:\nstatic NullTaskScheduler&amp; instance()\n{\nstatic NullTaskScheduler instance_;\nreturn instance_;\n}\nNullTaskScheduler()\n{\n}\nboost::asio::any_io_executor schedule_task() override\n{\nBATT_PANIC() &lt;&lt; \"The NullTaskScheduler can not schedule anything!  Use a different implementation.\";\nBATT_UNREACHABLE();\n}\nvoid halt() override\n{\n}\nvoid join() override\n{\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_TASK_SCHEDULER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/tcp__transport_8hpp/","title":"batteries/http/tcp_transport.hpp","text":""},{"location":"_autogen/Files/tcp__transport_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/tcp__transport_8hpp/#classes","title":"Classes","text":"Name class batt::TcpTransport A thread-safe socket based TCP connection for HTTP clients."},{"location":"_autogen/Files/tcp__transport_8hpp/#defines","title":"Defines","text":"Name BATTERIES_HTTP_TCP_TRANSPORT_HPP"},{"location":"_autogen/Files/tcp__transport_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/tcp__transport_8hpp/#define-batteries_http_tcp_transport_hpp","title":"define BATTERIES_HTTP_TCP_TRANSPORT_HPP","text":"<pre><code>#define BATTERIES_HTTP_TCP_TRANSPORT_HPP()\n</code></pre>"},{"location":"_autogen/Files/tcp__transport_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_HTTP_TCP_TRANSPORT_HPP\n#define BATTERIES_HTTP_TCP_TRANSPORT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/http/http_client_host_context_decl.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/asio/ip_tcp.hpp&gt;\n#include &lt;mutex&gt;\nnamespace batt {\nclass TcpTransport\n{\npublic:\nexplicit TcpTransport(HttpClientHostContext&amp; host_context) noexcept\n: socket_{host_context.get_io_context()}\n{\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nboost::asio::ip::tcp::endpoint local_endpoint(ErrorCode&amp; ec) const noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn this-&gt;socket_.local_endpoint(ec);\n}\nboost::asio::ip::tcp::endpoint remote_endpoint(ErrorCode&amp; ec) const noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn this-&gt;socket_.remote_endpoint(ec);\n}\nbool is_open() const noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nreturn this-&gt;socket_.is_open();\n}\nvoid close(ErrorCode&amp; ec) noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;socket_.close(ec);\n}\nvoid shutdown(boost::asio::socket_base::shutdown_type mode, ErrorCode&amp; ec) noexcept\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;socket_.shutdown(mode, ec);\n}\ntemplate &lt;typename Handler = void(const ErrorCode&amp;)&gt;\nvoid async_connect(const boost::asio::ip::tcp::endpoint&amp; ep, Handler&amp;&amp; handler)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;socket_.async_connect(ep, BATT_FORWARD(handler));\n}\ntemplate &lt;typename MutableBufferSequence, typename Handler = void(const ErrorCode&amp;, usize)&gt;\nvoid async_read_some(MutableBufferSequence&amp;&amp; buffers, Handler&amp;&amp; handler)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;socket_.async_read_some(BATT_FORWARD(buffers), BATT_FORWARD(handler));\n}\ntemplate &lt;typename ConstBufferSequence, typename Handler = void(const ErrorCode&amp;, usize)&gt;\nvoid async_write_some(ConstBufferSequence&amp;&amp; buffers, Handler&amp;&amp; handler)\n{\nstd::unique_lock&lt;std::mutex&gt; lock{this-&gt;mutex_};\nthis-&gt;socket_.async_write_some(BATT_FORWARD(buffers), BATT_FORWARD(handler));\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\nmutable std::mutex mutex_;\nboost::asio::ip::tcp::socket socket_;\n};\n}  //namespace batt\n#endif  // BATTERIES_HTTP_TCP_TRANSPORT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/token_8hpp/","title":"batteries/token.hpp","text":""},{"location":"_autogen/Files/token_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/token_8hpp/#defines","title":"Defines","text":"Name BATTERIES_TOKEN_HPP"},{"location":"_autogen/Files/token_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/token_8hpp/#define-batteries_token_hpp","title":"define BATTERIES_TOKEN_HPP","text":"<pre><code>#define BATTERIES_TOKEN_HPP()\n</code></pre>"},{"location":"_autogen/Files/token_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_TOKEN_HPP\n#define BATTERIES_TOKEN_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;boost/flyweight.hpp&gt;\n#include &lt;boost/flyweight/no_tracking.hpp&gt;\nnamespace batt {\nusing Token = boost::flyweights::flyweight&lt;std::string, boost::flyweights::no_tracking&gt;;\n}  // namespace batt\n#endif  // BATTERIES_TOKEN_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/tuples_8hpp/","title":"batteries/tuples.hpp","text":""},{"location":"_autogen/Files/tuples_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/tuples_8hpp/#classes","title":"Classes","text":"Name struct batt::MorphTuple&lt; TemplateT, std::tuple&lt; Ts... &gt; &gt; struct batt::TupleIndexOf&lt; std::tuple&lt;&gt;, T &gt; struct batt::TupleIndexOf&lt; std::tuple&lt; T, Rest... &gt;, T &gt; struct batt::TupleIndexOf&lt; std::tuple&lt; First, Rest... &gt;, T &gt; struct batt::MapTuple&lt; PerTypeT, std::tuple&lt; Ts... &gt; &gt; class batt::StaticTypeMap Stores a fixed-size set of Value objects, indexed by a set of bounded types (keys)."},{"location":"_autogen/Files/tuples_8hpp/#defines","title":"Defines","text":"Name BATTERIES_TUPLES_HPP"},{"location":"_autogen/Files/tuples_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/tuples_8hpp/#define-batteries_tuples_hpp","title":"define BATTERIES_TUPLES_HPP","text":"<pre><code>#define BATTERIES_TUPLES_HPP()\n</code></pre>"},{"location":"_autogen/Files/tuples_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_TUPLES_HPP\n#define BATTERIES_TUPLES_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;array&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n// Take the element types of a tuple and apply them as the args to some other\n// template to produce a new type.\n//\n// Example:\n// ```c++\n// using MyTypes = std::tuple&lt;int, char, std::string&gt;;\n// using Morphed = batt::MorphTuple_t&lt;std::variant, MyTypes&gt;;\n//\n// static_assert(std::is_same_v&lt;Morphed, std::variant&lt;int, char, std::string&gt;&gt;, \"\");\n// ```\n//\ntemplate &lt;template &lt;typename...&gt; class TemplateT, typename TupleT&gt;\nstruct MorphTuple;\ntemplate &lt;template &lt;typename...&gt; class TemplateT, typename... Ts&gt;\nstruct MorphTuple&lt;TemplateT, std::tuple&lt;Ts...&gt;&gt; : StaticType&lt;TemplateT&lt;Ts...&gt;&gt; {\n};\ntemplate &lt;template &lt;typename...&gt; class TemplateT, typename TupleT&gt;\nusing MorphTuple_t = typename MorphTuple&lt;TemplateT, std::decay_t&lt;TupleT&gt;&gt;::type;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename TupleT, typename T&gt;\nstruct TupleIndexOf;\ntemplate &lt;typename T&gt;\nstruct TupleIndexOf&lt;std::tuple&lt;&gt;, T&gt; : BATT_STATIC_VALUE(0u) {\n};\ntemplate &lt;typename T, typename... Rest&gt;\nstruct TupleIndexOf&lt;std::tuple&lt;T, Rest...&gt;, T&gt; : BATT_STATIC_VALUE(0u) {\n};\ntemplate &lt;typename T, typename First, typename... Rest&gt;\nstruct TupleIndexOf&lt;std::tuple&lt;First, Rest...&gt;, T&gt;\n: BATT_STATIC_VALUE((1u + TupleIndexOf&lt;std::tuple&lt;Rest...&gt;, T&gt;::value)) {\n};\ntemplate &lt;typename TupleT, typename T&gt;\nconstexpr auto TupleIndexOf_v = TupleIndexOf&lt;std::decay_t&lt;TupleT&gt;, T&gt;::value;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;template &lt;typename&gt; class PerTypeT, typename TupleT&gt;\nstruct MapTuple;\ntemplate &lt;template &lt;typename&gt; class PerTypeT, typename... Ts&gt;\nstruct MapTuple&lt;PerTypeT, std::tuple&lt;Ts...&gt;&gt; : StaticType&lt;std::tuple&lt;PerTypeT&lt;Ts&gt;...&gt;&gt; {\n};\ntemplate &lt;template &lt;typename&gt; class PerTypeT, typename TupleT&gt;\nusing MapTuple_t = typename MapTuple&lt;PerTypeT, std::decay_t&lt;TupleT&gt;&gt;::type;\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename KeyTupleT, typename Value&gt;\nclass StaticTypeMap\n{\npublic:\nusing Self = StaticTypeMap;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr usize size()\n{\nreturn std::tuple_size&lt;KeyTupleT&gt;::value;\n}\nusing ValueArray = std::array&lt;Value, Self::size()&gt;;\nusing iterator = typename ValueArray::iterator;\nusing const_iterator = typename ValueArray::const_iterator;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nStaticTypeMap() noexcept\n{\n}\nStaticTypeMap(const StaticTypeMap&amp;) = default;\nStaticTypeMap&amp; operator=(const StaticTypeMap&amp;) = default;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename KeyT&gt;\nValue&amp; get([[maybe_unused]] StaticType&lt;KeyT&gt; key = {}) noexcept\n{\nconstexpr usize kIndex = TupleIndexOf_v&lt;KeyTupleT, KeyT&gt;;\nstatic_assert(kIndex &lt; Self::size());\nreturn this-&gt;values_[kIndex];\n}\ntemplate &lt;typename KeyT&gt;\nconst Value&amp; get([[maybe_unused]] StaticType&lt;KeyT&gt; key = {}) const noexcept\n{\nconstexpr usize kIndex = TupleIndexOf_v&lt;KeyTupleT, KeyT&gt;;\nstatic_assert(kIndex &lt; Self::size());\nreturn this-&gt;values_[kIndex];\n}\ntemplate &lt;typename KeyT&gt;\nValue&amp; operator[](StaticType&lt;KeyT&gt; key) noexcept\n{\nreturn this-&gt;get(key);\n}\ntemplate &lt;typename KeyT&gt;\nconst Value&amp; operator[](StaticType&lt;KeyT&gt; key) const noexcept\n{\nreturn this-&gt;get(key);\n}\niterator begin() noexcept\n{\nreturn this-&gt;values_.begin();\n}\niterator end() noexcept\n{\nreturn this-&gt;values_.end();\n}\nconst_iterator begin() const noexcept\n{\nreturn this-&gt;values_.begin();\n}\nconst_iterator end() const noexcept\n{\nreturn this-&gt;values_.end();\n}\nprivate:\n// Stores all values in the map.\n//\nstd::array&lt;Value, Self::size()&gt; values_{};\n};\n}  // namespace batt\n#endif  // BATTERIES_TUPLES_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/type__erasure_8hpp/","title":"batteries/type_erasure.hpp","text":""},{"location":"_autogen/Files/type__erasure_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/type__erasure_8hpp/#classes","title":"Classes","text":"Name class batt::AbstractValue class batt::AbstractValuePointer class batt::TypeErasedStorageBase class batt::TypeErasedStorage class batt::AbstractValueImpl"},{"location":"_autogen/Files/type__erasure_8hpp/#defines","title":"Defines","text":"Name BATTERIES_TYPE_ERASURE_HPP"},{"location":"_autogen/Files/type__erasure_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/type__erasure_8hpp/#define-batteries_type_erasure_hpp","title":"define BATTERIES_TYPE_ERASURE_HPP","text":"<pre><code>#define BATTERIES_TYPE_ERASURE_HPP()\n</code></pre>"},{"location":"_autogen/Files/type__erasure_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_TYPE_ERASURE_HPP\n#define BATTERIES_TYPE_ERASURE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/buffer.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\nnamespace batt {\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename T&gt;\nclass AbstractValue\n{\npublic:\nAbstractValue(const AbstractValue&amp;) = delete;\nAbstractValue&amp; operator=(const AbstractValue&amp;) = delete;\nvirtual ~AbstractValue() = default;\nvirtual T* copy_to(MutableBuffer memory) const = 0;\nvirtual T* move_to(MutableBuffer memory) = 0;\nprotected:\nAbstractValue() = default;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename T&gt;\nclass AbstractValuePointer : public AbstractValue&lt;T&gt;\n{\npublic:\nexplicit AbstractValuePointer(std::unique_ptr&lt;T&gt; ptr) noexcept : ptr_{std::move(ptr)}\n{\n}\nT* copy_to(MutableBuffer memory) const override\n{\nBATT_CHECK_GE(memory.size(), sizeof(AbstractValuePointer));\nreturn this-&gt;ptr_-&gt;copy_to(memory);\n}\nT* move_to(MutableBuffer memory) override\n{\nBATT_CHECK_GE(memory.size(), sizeof(AbstractValuePointer));\nauto* copy_of_this = new (memory.data()) AbstractValuePointer{std::move(this-&gt;ptr_)};\nreturn copy_of_this-&gt;ptr_.get();\n}\nprivate:\nstd::unique_ptr&lt;T&gt; ptr_;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename AbstractType, template &lt;typename&gt; class TypedImpl&gt;\nclass TypeErasedStorageBase\n{\npublic:\ntemplate &lt;typename T, typename... Args&gt;\nstatic AbstractType* construct_impl(StaticType&lt;T&gt;, MutableBuffer buf, Args&amp;&amp;... args)\n{\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;T&gt;, T&gt;,\n\"Use std::reference_wrapper (std::ref) to wrap a reference.\");\n// If the impl will fit in the inline buffer, then just use placement new.\n//\nif (sizeof(TypedImpl&lt;T&gt;) &lt;= buf.size()) {\nreturn new (buf.data()) TypedImpl&lt;T&gt;{BATT_FORWARD(args)...};\n}\nauto p_impl = std::make_unique&lt;TypedImpl&lt;T&gt;&gt;(BATT_FORWARD(args)...);\nAbstractType* retval = p_impl.get();\nnew (buf.data()) AbstractValuePointer&lt;AbstractType&gt;{std::move(p_impl)};\nreturn retval;\n}\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename AbstractType, template &lt;typename&gt; class TypedImpl,\nusize kReservedSize = kCpuCacheLineSize - sizeof(void*), usize kAlignment = kCpuCacheLineSize&gt;\nclass TypeErasedStorage : public TypeErasedStorageBase&lt;AbstractType, TypedImpl&gt;\n{\npublic:\nstatic_assert(kReservedSize &gt;= sizeof(AbstractValuePointer&lt;AbstractType&gt;),\n\"kReservedSize must be large enough to fit a pointer\");\nstatic constexpr usize reserved_size = kReservedSize;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nTypeErasedStorage() noexcept : impl_{nullptr}\n{\n}\ntemplate &lt;typename T, typename... Args&gt;\n/*implicit*/ TypeErasedStorage(StaticType&lt;T&gt; static_type, Args&amp;&amp;... args) noexcept : impl_{nullptr}\n{\nthis-&gt;emplace(static_type, BATT_FORWARD(args)...);\n}\nTypeErasedStorage(const TypeErasedStorage&amp; other)\n: impl_{other.impl_ ? other.get_abstract()-&gt;copy_to(this-&gt;memory()) : nullptr}\n{\n}\nTypeErasedStorage(TypeErasedStorage&amp;&amp; other)\n: impl_{other.impl_ ? other.get_abstract()-&gt;move_to(this-&gt;memory()) : nullptr}\n{\nother.clear();\n}\n~TypeErasedStorage() noexcept\n{\nthis-&gt;clear();\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nTypeErasedStorage&amp; operator=(TypeErasedStorage&amp;&amp; other)\n{\nif (BATT_HINT_TRUE(this != &amp;other)) {\nthis-&gt;clear();\nif (other.impl_) {\nthis-&gt;impl_ = other.get_abstract()-&gt;move_to(this-&gt;memory());\nother.clear();\n}\n}\nreturn *this;\n}\nTypeErasedStorage&amp; operator=(const TypeErasedStorage&amp; other)\n{\nif (BATT_HINT_TRUE(this != &amp;other)) {\nthis-&gt;clear();\nif (other.impl_) {\nthis-&gt;impl_ = other.get_abstract()-&gt;copy_to(this-&gt;memory());\n}\n}\nreturn *this;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\ntemplate &lt;typename T, typename... Args&gt;\nAbstractType* emplace(StaticType&lt;T&gt; static_type, Args&amp;&amp;... args)\n{\nthis-&gt;clear();\nreturn this-&gt;construct(static_type, BATT_FORWARD(args)...);\n}\ntemplate &lt;typename T, typename U,\ntypename = std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;U&gt;, std::reference_wrapper&lt;T&gt;&gt;&gt;&gt;\nAbstractType* emplace(StaticType&lt;U&gt;, const std::reference_wrapper&lt;T&gt;&amp; ref)\n{\nthis-&gt;clear();\nreturn this-&gt;construct(StaticType&lt;std::reference_wrapper&lt;T&gt;&gt;{}, make_copy(ref));\n}\nvoid clear()\n{\nif (this-&gt;impl_) {\nthis-&gt;get_abstract()-&gt;~AbstractValue&lt;AbstractType&gt;();\nthis-&gt;impl_ = nullptr;\n}\n}\nMutableBuffer memory()\n{\nreturn MutableBuffer{&amp;this-&gt;storage_, sizeof(this-&gt;storage_)};\n}\nAbstractType* get() const\n{\nreturn this-&gt;impl_;\n}\nAbstractValue&lt;AbstractType&gt;* get_abstract() noexcept\n{\nreturn reinterpret_cast&lt;AbstractValue&lt;AbstractType&gt;*&gt;(&amp;this-&gt;storage_);\n}\nconst AbstractValue&lt;AbstractType&gt;* get_abstract() const noexcept\n{\nreturn reinterpret_cast&lt;const AbstractValue&lt;AbstractType&gt;*&gt;(&amp;this-&gt;storage_);\n}\nbool is_valid() const\n{\nreturn this-&gt;impl_ != nullptr;\n}\nexplicit operator bool() const\n{\nreturn this-&gt;is_valid();\n}\nAbstractType* operator-&gt;() const\n{\nreturn this-&gt;get();\n}\nAbstractType&amp; operator*() const\n{\nBATT_ASSERT_NOT_NULLTPR(this-&gt;get());\nreturn *this-&gt;get();\n}\nprivate:\ntemplate &lt;typename T, typename... Args&gt;\nAbstractType* construct(StaticType&lt;T&gt; static_type, Args&amp;&amp;... args)\n{\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;T&gt;, T&gt;,\n\"Use std::reference_wrapper (std::ref) to wrap a reference.\");\nthis-&gt;impl_ = TypeErasedStorage::construct_impl(static_type, this-&gt;memory(), BATT_FORWARD(args)...);\nreturn this-&gt;impl_;\n}\nstd::aligned_storage_t&lt;kReservedSize, kAlignment&gt; storage_;\nAbstractType* impl_ = nullptr;\n};\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n//\ntemplate &lt;typename AbstractType, template &lt;typename&gt; class TypedImpl, typename T&gt;\nclass AbstractValueImpl : public AbstractType\n{\npublic:\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nexplicit AbstractValueImpl(T&amp;&amp; obj) : obj_{BATT_FORWARD(obj)}\n{\nstatic_assert(std::is_same_v&lt;std::decay_t&lt;T&gt;, T&gt;,\n\"Use std::reference_wrapper (std::ref) to wrap a reference.\");\nstatic_assert(std::is_base_of_v&lt;AbstractValue&lt;AbstractType&gt;, AbstractType&gt;,\n\"AbstractType must be derived from AbstractValue&lt;AbstractType&gt;.\");\nstatic_assert(std::is_base_of_v&lt;AbstractValueImpl, TypedImpl&lt;T&gt;&gt;,\n\"TypedImpl&lt;T&gt; must be derived from AbstractValueImpl.\");\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n// AbstractValue interface\nAbstractType* copy_to(MutableBuffer memory) const override\n{\nreturn TypeErasedStorageBase&lt;AbstractType, TypedImpl&gt;::construct_impl(StaticType&lt;T&gt;{}, memory,\nbatt::make_copy(this-&gt;obj_));\n}\nAbstractType* move_to(MutableBuffer memory) override\n{\nreturn TypeErasedStorageBase&lt;AbstractType, TypedImpl&gt;::construct_impl(StaticType&lt;T&gt;{}, memory,\nstd::move(this-&gt;obj_));\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprotected:\nT obj_;\n};\n}  // namespace batt\n#endif  // BATTERIES_TYPE_ERASURE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/type__traits_8hpp/","title":"batteries/type_traits.hpp","text":""},{"location":"_autogen/Files/type__traits_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/type__traits_8hpp/#classes","title":"Classes","text":"Name struct batt::IsVariant struct batt::IsVariant&lt; std::variant&lt; Ts... &gt; &gt; struct batt::IsTuple struct batt::IsTuple&lt; std::tuple&lt; Ts... &gt; &gt; struct batt::StaticType struct batt::StaticValue struct batt::DecayRValueRefImpl struct batt::detail::EmptyBaseHelper struct batt::detail::EmptyBaseTestCase struct batt::detail::EmptyBaseTestCase2 struct batt::Difference Type trait that maps subtractable type <code>T</code> to the difference type. struct batt::Difference&lt; unsigned char &gt; struct batt::Difference&lt; unsigned short &gt; struct batt::Difference&lt; unsigned long &gt; struct batt::Difference&lt; unsigned long long &gt; struct batt::Difference&lt; std::pair&lt; A, B &gt; &gt; struct batt::Difference&lt; std::tuple&lt; Ts... &gt; &gt;"},{"location":"_autogen/Files/type__traits_8hpp/#defines","title":"Defines","text":"Name BATT_STATIC_VALUE(expr)"},{"location":"_autogen/Files/type__traits_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/type__traits_8hpp/#define-batt_static_value","title":"define BATT_STATIC_VALUE","text":"<pre><code>#define BATT_STATIC_VALUE(expr)\n</code></pre>"},{"location":"_autogen/Files/type__traits_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2022 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#ifndef BATT_PLATFORM_IS_WINDOWS\n#include &lt;cxxabi.h&gt;\n#endif\n#include &lt;iterator&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n#include &lt;typeindex&gt;\n#include &lt;utility&gt;\n#include &lt;variant&gt;\nnamespace batt {\n// =============================================================================\n// IsCallable&lt;Fn, Args...&gt;\n//\n//  Type alias for std::true_type if `Fn` is callable with `Args...`.\n//  Type alias for std::false_type otherwise.\n//\nnamespace detail {\ntemplate &lt;typename Fn, typename... Args, typename Result = std::invoke_result_t&lt;Fn, Args...&gt;&gt;\nstd::true_type is_callable_impl(void*);\ntemplate &lt;typename Fn, typename... Args&gt;\nstd::false_type is_callable_impl(...);\n}  // namespace detail\ntemplate &lt;typename Fn, typename... Args&gt;\nusing IsCallable = decltype(detail::is_callable_impl&lt;Fn, Args...&gt;(nullptr));\n// =============================================================================\n// IsPrintable&lt;T&gt;\n//\nnamespace detail {\ntemplate &lt;typename T, typename Result = decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())&gt;\nstd::true_type is_printable_impl(void*);\ntemplate &lt;typename Fn, typename... Args&gt;\nstd::false_type is_printable_impl(...);\n}  // namespace detail\ntemplate &lt;typename T&gt;\nusing IsPrintable = decltype(detail::is_printable_impl&lt;T&gt;(nullptr));\n// =============================================================================\n// IsRange&lt;T&gt;\n//\n//  Type alias for std::true_type if `T` is a range type.\n//  Type alias for std::false_type otherwise.\n//\nnamespace detail {\ntemplate &lt;typename T, typename BeginIter = decltype(std::begin(std::declval&lt;T&gt;())),\ntypename EndIter = decltype(std::end(std::declval&lt;T&gt;())),\ntypename = std::enable_if_t&lt;std::is_same&lt;BeginIter, EndIter&gt;{}&gt;&gt;\nstd::true_type is_range_impl(void*);\ntemplate &lt;typename T&gt;\nstd::false_type is_range_impl(...);\n}  // namespace detail\ntemplate &lt;typename T&gt;\nusing IsRange = decltype(detail::is_range_impl&lt;T&gt;(nullptr));\n// =============================================================================\n// IsVariant&lt;T&gt;\n//\n//  Derives std::true_type if `T` is a std::variant type.\n//  Derives std::false_type otherwise.\n//\ntemplate &lt;typename T&gt;\nstruct IsVariant : std::false_type {\n};\ntemplate &lt;typename... Ts&gt;\nstruct IsVariant&lt;std::variant&lt;Ts...&gt;&gt; : std::true_type {\n};\n// =============================================================================\n// IsTuple&lt;T&gt;\n//\n//  Derives std::true_type if `T` is a std::tuple type.\n//  Derives std::false_type otherwise.\n//\ntemplate &lt;typename T&gt;\nstruct IsTuple : std::false_type {\n};\ntemplate &lt;typename... Ts&gt;\nstruct IsTuple&lt;std::tuple&lt;Ts...&gt;&gt; : std::true_type {\n};\n// =============================================================================\n// StaticType&lt;T&gt;\n//\ntemplate &lt;typename T&gt;\nstruct StaticType {\nusing type = T;\n};\ntemplate &lt;typename L, typename R&gt;\ninline constexpr bool operator==(StaticType&lt;L&gt;, StaticType&lt;R&gt;)\n{\nreturn std::is_same_v&lt;L, R&gt;;\n}\ntemplate &lt;typename L, typename R&gt;\ninline constexpr bool operator!=(StaticType&lt;L&gt;, StaticType&lt;R&gt;)\n{\nreturn !std::is_same_v&lt;L, R&gt;;\n}\nstatic_assert(StaticType&lt;int&gt;{} == StaticType&lt;int&gt;{}, \"\");\nstatic_assert(StaticType&lt;int&gt;{} != StaticType&lt;unsigned&gt;{}, \"\");\n// =============================================================================\n//\ntemplate &lt;typename T, T kValue&gt;\nstruct StaticValue {\nstatic constexpr T value = kValue;\nconstexpr StaticValue() = default;\nconstexpr operator T() const\n{\nreturn value;\n}\n};\n#define BATT_STATIC_VALUE(expr) ::batt::StaticValue&lt;decltype(expr), (expr)&gt;\n// =============================================================================\n// Enables/disables a constructor template when the argments do not cause it to\n// shadow a built-in method.\n//\n// Usage:\n//\n// ```\n// class MyType {\n// public:\n//   template &lt;typename... Args, typename = batt::EnableIfNoShadow&lt;MyType, Args...&gt;&gt;\n//   MyType(Args&amp;&amp;... args) { /* something other than copy/move/default */ }\n// };\n// ```\n//\ntemplate &lt;typename T, typename... Args&gt;\nusing EnableIfNoShadow =\nstd::enable_if_t&lt;!std::is_same&lt;std::tuple&lt;std::decay_t&lt;T&gt;*&gt;, std::tuple&lt;std::decay_t&lt;Args&gt;*...&gt;&gt;{}\n// Copy or move ctor\n&amp;&amp; !std::is_same&lt;std::tuple&lt;&gt;, std::tuple&lt;std::decay_t&lt;Args&gt;*...&gt;&gt;{}  // Default ctor\n&gt;;\n// =============================================================================\ninline constexpr bool is_any_true() noexcept\n{\nreturn false;\n}\ntemplate &lt;typename... Rest&gt;\ninline constexpr bool is_any_true(bool first, Rest&amp;&amp;... rest) noexcept\n{\nreturn first || is_any_true(std::forward&lt;Rest&gt;(rest)...);\n}\n// =============================================================================\ninline constexpr bool are_all_true() noexcept\n{\nreturn true;\n}\ntemplate &lt;typename... Rest&gt;\ninline constexpr bool are_all_true(bool first, Rest&amp;&amp;... rest) noexcept\n{\nreturn first &amp;&amp; are_all_true(std::forward&lt;Rest&gt;(rest)...);\n}\n// =============================================================================\ntemplate &lt;typename T, typename... MatchTs&gt;\ninline constexpr bool IsOneOf = is_any_true(std::is_same_v&lt;T, MatchTs&gt;...);\ntemplate &lt;typename T, typename... MatchTs&gt;\ninline constexpr bool DecaysToOneOf = IsOneOf&lt;std::decay_t&lt;T&gt;, MatchTs...&gt;;\n// =============================================================================\n// Decays T iff it is an rvalue reference type.\n//\ntemplate &lt;typename T&gt;\nstruct DecayRValueRefImpl\n: std::conditional_t&lt;  //\n/*if */ std::is_rvalue_reference_v&lt;T&gt;,\n/* then */ std::decay&lt;T&gt;,\n/* else */ batt::StaticType&lt;T&gt;&gt; {\n};\ntemplate &lt;typename T&gt;\nusing DecayRValueRef = typename DecayRValueRefImpl&lt;T&gt;::type;\n// =============================================================================\n// CanBeEqCompared&lt;T, U&gt; - std::true_type or std::false_type depending on whether types `T` and `U` can be\n// equality-compared.\n//\nnamespace detail {\ntemplate &lt;typename T, typename U, typename = decltype(std::declval&lt;const T&amp;&gt;() == std::declval&lt;const U&amp;&gt;())&gt;\nstd::true_type can_be_eq_compared_helper(const T*, const U*)\n{\nreturn {};\n}\ntemplate &lt;typename T, typename U&gt;\nstd::false_type can_be_eq_compared_helper(...)\n{\nreturn {};\n}\n}  // namespace detail\ntemplate &lt;typename T, typename U = T&gt;\nusing CanBeEqCompared = decltype(detail::can_be_eq_compared_helper&lt;T, U&gt;(nullptr, nullptr));\n// =============================================================================\ninline const char* name_of(const std::type_index&amp; index)\n{\nint status = -1;\n#ifdef BATT_PLATFORM_IS_WINDOWS\nreturn index.name();\n#else\nreturn abi::__cxa_demangle(index.name(), NULL, NULL, &amp;status);\n#endif\n}\ninline const char* name_of(const std::type_info&amp; info)\n{\nreturn name_of(std::type_index{info});\n}\ntemplate &lt;typename T&gt;\nconst char* name_of(batt::StaticType&lt;T&gt; = {})\n{\nreturn name_of(typeid(T));\n}\ntemplate &lt;typename T&gt;\nconst char* unqualified_name_of(batt::StaticType&lt;T&gt; = {})\n{\nstatic const char* cached_ = [] {\nconst char* name_str = name_of(batt::StaticType&lt;T&gt;{});\nconst char* result = name_str;\nbool prev_colon = false;\nwhile (name_str &amp;&amp; *name_str) {\nif (*name_str == ':') {\nif (prev_colon) {\nresult = name_str + 1;\n}\nprev_colon = true;\n} else {\nprev_colon = false;\n}\n++name_str;\n}\nreturn result;\n}();\nreturn cached_;\n}\n// =============================================================================\nnamespace detail {\ntemplate &lt;typename T&gt;\nstruct EmptyBaseHelper : T {\nchar bytes[16];\n};\nstruct EmptyBaseTestCase {\n};\nstruct EmptyBaseTestCase2 {\nchar ch;\n};\ntemplate &lt;typename T,  //\ntypename = std::enable_if_t&lt;sizeof(detail::EmptyBaseHelper&lt;T&gt;) == 16&gt;&gt;\ninline constexpr std::true_type class_can_be_empty_base(StaticType&lt;T&gt; = {})\n{\nreturn {};\n}\ntemplate &lt;typename T,                                                             //\ntypename = std::enable_if_t&lt;sizeof(detail::EmptyBaseHelper&lt;T&gt;) != 16&gt;,  //\ntypename = void&gt;\ninline constexpr std::false_type class_can_be_empty_base(StaticType&lt;T&gt; = {})\n{\nreturn {};\n}\n}  //namespace detail\ntemplate &lt;typename T,  //\ntypename = std::enable_if_t&lt;std::is_class_v&lt;T&gt;&gt;&gt;\ninline constexpr auto can_be_empty_base(StaticType&lt;T&gt; = {})\n{\nreturn detail::class_can_be_empty_base&lt;T&gt;();\n}\ntemplate &lt;typename T,                                        //\ntypename = std::enable_if_t&lt;!std::is_class_v&lt;T&gt;&gt;,  //\ntypename = void&gt;\ninline constexpr std::false_type can_be_empty_base(StaticType&lt;T&gt; = {})\n{\nreturn {};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic_assert(can_be_empty_base&lt;detail::EmptyBaseTestCase&gt;());\nstatic_assert(!can_be_empty_base&lt;detail::EmptyBaseTestCase2&gt;());\nstatic_assert(!can_be_empty_base&lt;char&gt;());\nstatic_assert(!can_be_empty_base&lt;int&gt;());\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\ntemplate &lt;typename T&gt;\nstruct Difference : StaticType&lt;decltype(std::declval&lt;T&gt;() - std::declval&lt;T&gt;())&gt; {\n};\ntemplate &lt;&gt;\nstruct Difference&lt;unsigned char&gt; : StaticType&lt;char&gt; {\n};\ntemplate &lt;&gt;\nstruct Difference&lt;unsigned short&gt; : StaticType&lt;short&gt; {\n};\ntemplate &lt;&gt;\nstruct Difference&lt;unsigned long&gt; : StaticType&lt;long&gt; {\n};\ntemplate &lt;&gt;\nstruct Difference&lt;unsigned long long&gt; : StaticType&lt;long long&gt; {\n};\ntemplate &lt;typename A, typename B&gt;\nstruct Difference&lt;std::pair&lt;A, B&gt;&gt;\n: StaticType&lt;std::pair&lt;typename Difference&lt;A&gt;::type, typename Difference&lt;B&gt;::type&gt;&gt; {\n};\ntemplate &lt;typename... Ts&gt;\nstruct Difference&lt;std::tuple&lt;Ts...&gt;&gt; : StaticType&lt;std::tuple&lt;typename Difference&lt;Ts&gt;::type...&gt;&gt; {\n};\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/types_8hpp/","title":"batteries/async/types.hpp","text":""},{"location":"_autogen/Files/types_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/types_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_TYPES_HPP"},{"location":"_autogen/Files/types_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/types_8hpp/#define-batteries_async_types_hpp","title":"define BATTERIES_ASYNC_TYPES_HPP","text":"<pre><code>#define BATTERIES_ASYNC_TYPES_HPP()\n</code></pre>"},{"location":"_autogen/Files/types_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_TYPES_HPP\n#define BATTERIES_ASYNC_TYPES_HPP\n#include &lt;ostream&gt;\nnamespace batt {\nenum struct WaitForResource : bool {\nkFalse = false,\nkTrue = true,\n};\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, WaitForResource t)\n{\nswitch (t) {\ncase WaitForResource::kFalse:\nreturn out &lt;&lt; \"WaitForResource::kFalse\";\ncase WaitForResource::kTrue:  // fall-through\ndefault:\nreturn out &lt;&lt; \"WaitForResource::kTrue\";\n}\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_TYPES_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/url__parse_8hpp/","title":"batteries/url_parse.hpp","text":""},{"location":"_autogen/Files/url__parse_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/url__parse_8hpp/#classes","title":"Classes","text":"Name struct batt::UrlParse"},{"location":"_autogen/Files/url__parse_8hpp/#defines","title":"Defines","text":"Name BATTERIES_URL_PARSE_HPP"},{"location":"_autogen/Files/url__parse_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/url__parse_8hpp/#define-batteries_url_parse_hpp","title":"define BATTERIES_URL_PARSE_HPP","text":"<pre><code>#define BATTERIES_URL_PARSE_HPP()\n</code></pre>"},{"location":"_autogen/Files/url__parse_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_URL_PARSE_HPP\n#define BATTERIES_URL_PARSE_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/stream_util.hpp&gt;\n#include &lt;string_view&gt;\nnamespace batt {\nstruct UrlParse {\nstd::string_view scheme;\nstd::string_view user;\nstd::string_view host;\nOptional&lt;i64&gt; port;\nstd::string_view path;\nstd::string_view query;\nstd::string_view fragment;\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline bool operator==(const UrlParse&amp; left, const UrlParse&amp; right)\n{\nreturn left.scheme == right.scheme   //\n&amp;&amp; left.user == right.user    //\n&amp;&amp; left.host == right.host    //\n&amp;&amp; left.port == right.port    //\n&amp;&amp; left.path == right.path    //\n&amp;&amp; left.query == right.query  //\n&amp;&amp; left.fragment == right.fragment;\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline bool operator!=(const UrlParse&amp; left, const UrlParse&amp; right)\n{\nreturn !(left == right);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const UrlParse&amp; t)\n{\nreturn out &lt;&lt; \"UrlParse{.scheme=\" &lt;&lt; t.scheme  //\n&lt;&lt; \", .user=\" &lt;&lt; t.user             //\n&lt;&lt; \", .host=\" &lt;&lt; t.host             //\n&lt;&lt; \", .port=\" &lt;&lt; t.port             //\n&lt;&lt; \", .path=\" &lt;&lt; t.path             //\n&lt;&lt; \", .query=\" &lt;&lt; t.query           //\n&lt;&lt; \", .fragment=\" &lt;&lt; t.fragment     //\n&lt;&lt; \",}\";\n}\nnamespace detail {\nStatusOr&lt;UrlParse&gt; parse_url_auth(std::string_view url, UrlParse&amp;&amp; parse);\nStatusOr&lt;UrlParse&gt; parse_url_host(std::string_view url, UrlParse&amp;&amp; parse);\nStatusOr&lt;UrlParse&gt; parse_url_port(std::string_view url, UrlParse&amp;&amp; parse);\nStatusOr&lt;UrlParse&gt; parse_url_path(std::string_view url, UrlParse&amp;&amp; parse);\nStatusOr&lt;UrlParse&gt; parse_url_query(std::string_view url, UrlParse&amp;&amp; parse);\nStatusOr&lt;UrlParse&gt; parse_url_fragment(std::string_view url, UrlParse&amp;&amp; parse);\n}  // namespace detail\ninline StatusOr&lt;UrlParse&gt; parse_url(std::string_view url)\n{\nUrlParse parse;\nif (BATT_HINT_FALSE(url.empty())) {\nreturn parse;\n}\nif (url.front() == '/') {\nreturn detail::parse_url_path(url, std::move(parse));\n}\nconst usize scheme_delim = url.find(':');\nif (scheme_delim == std::string_view::npos) {\nparse.scheme = url;\nreturn parse;\n}\nparse.scheme = url.substr(0, scheme_delim);\nurl.remove_prefix(scheme_delim + 1);\nif (url.size() &gt; 1 &amp;&amp; url[0] == '/' &amp;&amp; url[1] == '/') {\nurl.remove_prefix(2);\nreturn detail::parse_url_auth(url, std::move(parse));\n}\nreturn detail::parse_url_path(url, std::move(parse));\n}\n//#=##=##=#==#=#==#===#+==#+==========+==+=+=+=+=+=++=+++=+++++=-++++=-+++++++++++\nnamespace detail {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;UrlParse&gt; parse_url_auth(std::string_view url, UrlParse&amp;&amp; parse)\n{\nif (!url.empty() &amp;&amp; url.front() == '[') {\nreturn parse_url_host(url, std::move(parse));\n}\nconst usize auth_first_delim = url.find_first_of(\"@:/\");\nif (auth_first_delim == std::string_view::npos) {\nparse.host = url;\nreturn std::move(parse);\n}\nswitch (url[auth_first_delim]) {\ncase '@':\nparse.user = url.substr(0, auth_first_delim);\nurl.remove_prefix(parse.user.size() + /*strlen(\"@\")=*/1);\nreturn parse_url_host(url, std::move(parse));\ncase ':':\nparse.user = {};\nparse.host = url.substr(0, auth_first_delim);\nurl.remove_prefix(parse.host.size() + /*strlen(\":\")=*/1);\nreturn parse_url_port(url, std::move(parse));\ncase '/':\nparse.user = {};\nparse.host = url.substr(0, auth_first_delim);\nparse.port = None;\nurl.remove_prefix(parse.host.size());\nreturn parse_url_path(url, std::move(parse));\ndefault:\nBATT_PANIC() &lt;&lt; \"This should not be possible!\";\n}\nreturn {StatusCode::kInternal};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;UrlParse&gt; parse_url_host(std::string_view url, UrlParse&amp;&amp; parse)\n{\nif (url.empty()) {\nreturn std::move(parse);\n}\nif (url.front() == '[') {\nurl.remove_prefix(/*strlen(\"[\")=*/1);\nconst usize host_delim = url.find_first_of(\"]\");\nif (host_delim == std::string_view::npos) {\nreturn {StatusCode::kInvalidArgument};\n}\nparse.host = url.substr(0, host_delim);\nurl.remove_prefix(host_delim + /*strlen(\"]\")=*/1);\n} else {\nconst usize host_delim = url.find_first_of(\":/\");\nif (host_delim == std::string_view::npos) {\nparse.host = url;\nreturn std::move(parse);\n}\nparse.host = url.substr(0, host_delim);\nurl.remove_prefix(host_delim);\n}\nif (url.empty()) {\nreturn std::move(parse);\n}\nswitch (url.front()) {\ncase ':':\nurl.remove_prefix(1);\nreturn parse_url_port(url, std::move(parse));\ncase '/':\nreturn parse_url_path(url, std::move(parse));\ndefault:\nBATT_PANIC() &lt;&lt; \"This should not be possible!\";\n}\nreturn {StatusCode::kInternal};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;UrlParse&gt; parse_url_port(std::string_view url, UrlParse&amp;&amp; parse)\n{\nconst std::string_view port_str = url.substr(0, url.find('/'));\nparse.port = from_string&lt;i64&gt;(std::string{port_str});\nif (!parse.port) {\nreturn {StatusCode::kInvalidArgument};\n}\nurl.remove_prefix(port_str.size());\nreturn parse_url_path(url, std::move(parse));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;UrlParse&gt; parse_url_path(std::string_view url, UrlParse&amp;&amp; parse)\n{\nconst usize path_delim = url.find_first_of(\"?#\");\nif (path_delim == std::string_view::npos) {\nparse.path = url;\nreturn std::move(parse);\n}\nparse.path = std::string_view{url.data(), path_delim};\nurl.remove_prefix(path_delim);\nswitch (url.front()) {\ncase '?':\nurl.remove_prefix(1);\nreturn parse_url_query(url, std::move(parse));\ncase '#':\nurl.remove_prefix(1);\nparse.fragment = url;\nreturn std::move(parse);\ndefault:\nBATT_PANIC() &lt;&lt; \"This should not be possible!\";\n}\nreturn {StatusCode::kInternal};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ninline StatusOr&lt;UrlParse&gt; parse_url_query(std::string_view url, UrlParse&amp;&amp; parse)\n{\nconst usize query_delim = url.find('#');\nif (query_delim == std::string_view::npos) {\nparse.query = url;\n} else {\nparse.query = url.substr(0, query_delim);\nparse.fragment = url.substr(query_delim + 1);\n}\nreturn std::move(parse);\n}\n}  // namespace detail\n}  // namespace batt\n#endif  // BATTERIES_URL_PARSE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/utility_8hpp/","title":"batteries/utility.hpp","text":""},{"location":"_autogen/Files/utility_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::detail"},{"location":"_autogen/Files/utility_8hpp/#classes","title":"Classes","text":"Name struct batt::DefaultInitialized A single type that implicitly converts to any default-constructible type (via batt::make_default())."},{"location":"_autogen/Files/utility_8hpp/#defines","title":"Defines","text":"Name BATT_FORWARD(x) Perfectly forward <code>x</code>. BATT_SINK(expr) BATT_WARN_UNUSED_RESULT Warn/error if a function's return value is ignored: BATT_OVERLOADS_OF(name) Roughly approximates the ability to treat a named overload set as though it were an actual callable function. BATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(qualifiers) BATT_EXPANDS_TO_NOTHING"},{"location":"_autogen/Files/utility_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/utility_8hpp/#define-batt_forward","title":"define BATT_FORWARD","text":"<pre><code>#define BATT_FORWARD(x)\n</code></pre> <p>Perfectly forward <code>x</code>. </p> <p>Avoids having to include redundant information in a <code>std::forward</code> expression. </p>"},{"location":"_autogen/Files/utility_8hpp/#define-batt_sink","title":"define BATT_SINK","text":"<pre><code>#define BATT_SINK(expr)\n</code></pre>"},{"location":"_autogen/Files/utility_8hpp/#define-batt_warn_unused_result","title":"define BATT_WARN_UNUSED_RESULT","text":"<pre><code>#define BATT_WARN_UNUSED_RESULT()\n</code></pre> <p>Warn/error if a function's return value is ignored: </p> <pre><code>int fn_returning_status_code() BATT_WARN_UNUSED_RESULT;\n</code></pre>"},{"location":"_autogen/Files/utility_8hpp/#define-batt_overloads_of","title":"define BATT_OVERLOADS_OF","text":"<pre><code>#define BATT_OVERLOADS_OF(name)\n</code></pre> <p>Roughly approximates the ability to treat a named overload set as though it were an actual callable function. </p>"},{"location":"_autogen/Files/utility_8hpp/#define-batt_unwrap_ref_std_reference_wrapper","title":"define BATT_UNWRAP_REF_STD_REFERENCE_WRAPPER","text":"<pre><code>#define BATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(qualifiers)\n</code></pre>"},{"location":"_autogen/Files/utility_8hpp/#define-batt_expands_to_nothing","title":"define BATT_EXPANDS_TO_NOTHING","text":"<pre><code>#define BATT_EXPANDS_TO_NOTHING()\n</code></pre>"},{"location":"_autogen/Files/utility_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\nnamespace batt {\n// =============================================================================\n#define BATT_FORWARD(x) std::forward&lt;decltype(x)&gt;(x)\ntemplate &lt;typename T&gt;\nT make_copy(const T&amp; value)\n{\nreturn value;\n}\n// BATT_SINK(val) - turns into BATT_FORWARD(val) if val is an rvalue-expression; otherwise, turns into\n// batt::make_copy(val).\n//\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, std::decay_t&lt;T&gt;&gt;&gt;&gt;\nT&amp;&amp; sink(T&amp;&amp; value)\n{\nreturn std::forward&lt;T&gt;(value);\n}\ntemplate &lt;typename T&gt;\nT sink(const T&amp; value)\n{\nreturn make_copy(value);\n}\n#define BATT_SINK(expr) ::batt::sink(BATT_FORWARD(expr))\n#if defined(__has_attribute)\n#if __has_attribute(nodiscard)\n#define BATT_WARN_UNUSED_RESULT [[nodiscard]]\n#elif __has_attribute(nodiscard)\n#define BATT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))\n#else\n#define BATT_WARN_UNUSED_RESULT \n#endif\n#else\n#define BATT_WARN_UNUSED_RESULT\n#endif\n#define BATT_OVERLOADS_OF(name)                                                                              \\\n    [](auto&amp;&amp;... args) noexcept(noexcept(name(BATT_FORWARD(args)...))) -&gt; decltype(auto) {                   \\\n        return name(BATT_FORWARD(args)...);                                                                  \\\n    }\n#ifdef __clang__\n#define BATT_MAYBE_UNUSED __attribute__((unused))\n//#define BATT_MAYBE_UNUSED [[maybe_unused]]\n#elif defined(__GNUC__)\n#define BATT_MAYBE_UNUSED __attribute__((unused))\n#pragma GCC diagnostic ignored \"-Wattributes\"\n#elif defined(_MSC_VER)\n#define BATT_MAYBE_UNUSED [[maybe_unused]]\n#endif\ntemplate &lt;typename T, typename = std::enable_if_t&lt;!std::is_same_v&lt;T, void&gt;&gt;&gt;\nT make_default()\n{\nreturn T{};\n}\ntemplate &lt;typename T, typename = std::enable_if_t&lt;std::is_same_v&lt;T, void&gt;&gt;, typename = void&gt;\nvoid make_default()\n{\n}\nstruct DefaultInitialized {\ntemplate &lt;typename T&gt;\n/*implicit*/ operator T() const noexcept(noexcept(make_default&lt;T&gt;()))\n{\nreturn make_default&lt;T&gt;();\n}\n};\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename T&gt;\ndecltype(auto) unwrap_ref(T&amp;&amp; obj)\n{\nreturn BATT_FORWARD(obj);\n}\n#define BATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(qualifiers)                                                    \\\n    template &lt;typename T&gt;                                                                                    \\\n    decltype(auto) unwrap_ref(std::reference_wrapper&lt;T&gt; qualifiers wrapper)                                  \\\n    {                                                                                                        \\\n        return BATT_FORWARD(wrapper).get();                                                                  \\\n    }\nBATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(&amp;)\nBATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(const&amp;)\nBATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(&amp;&amp;)\nBATT_UNWRAP_REF_STD_REFERENCE_WRAPPER(const&amp;&amp;)\n#undef BATT_UNWRAP_REF_STD_REFERENCE_WRAPPER\ntemplate &lt;typename T&gt;\nusing UnwrapRefType = decltype(unwrap_ref(std::declval&lt;T&gt;()));\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\nnamespace detail {\ntemplate &lt;typename Fn, typename ArgsTuple, usize... kIndex&gt;\ndecltype(auto) rotate_args_right_impl(Fn&amp;&amp; fn, ArgsTuple&amp;&amp; args_tuple, std::index_sequence&lt;kIndex...&gt;)\n{\nconstexpr usize kLastIndex = sizeof...(kIndex);\nreturn BATT_FORWARD(fn)(std::get&lt;kLastIndex&gt;(BATT_FORWARD(args_tuple)),\nstd::get&lt;kIndex&gt;(BATT_FORWARD(args_tuple))...);\n}\n}  // namespace detail\ntemplate &lt;typename Fn, typename... Args&gt;\ndecltype(auto) rotate_args_right(Fn&amp;&amp; fn, Args&amp;&amp;... args)\n{\nreturn detail::rotate_args_right_impl(BATT_FORWARD(fn), std::forward_as_tuple(BATT_FORWARD(args)...),\nstd::make_index_sequence&lt;sizeof...(args) - 1&gt;{});\n}\nnamespace detail {\ntemplate &lt;typename Fn, typename ArgsTuple, usize... kIndex&gt;\ndecltype(auto) rotate_args_left_impl(Fn&amp;&amp; fn, ArgsTuple&amp;&amp; args_tuple, std::index_sequence&lt;kIndex...&gt;)\n{\nreturn BATT_FORWARD(fn)(std::get&lt;kIndex + 1&gt;(BATT_FORWARD(args_tuple))...,\nstd::get&lt;0&gt;(BATT_FORWARD(args_tuple)));\n}\n}  // namespace detail\ntemplate &lt;typename Fn, typename... Args&gt;\ndecltype(auto) rotate_args_left(Fn&amp;&amp; fn, Args&amp;&amp;... args)\n{\nreturn detail::rotate_args_left_impl(BATT_FORWARD(fn), std::forward_as_tuple(BATT_FORWARD(args)...),\nstd::make_index_sequence&lt;sizeof...(args) - 1&gt;{});\n}\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#if BATT_COMPILER_IS_MSVC\n#define BATT_ALWAYS_INLINE __forceinline\n#elif BATT_COMPILER_IS_GCC || BATT_COMPILER_IS_CLANG\n#define BATT_ALWAYS_INLINE __attribute__((always_inline))\n#else\n#error Compiler not known; BATT_ALWAYS_INLINE not defined\n#endif\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n#define BATT_EXPANDS_TO_NOTHING\n}  // namespace batt\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/verbose_8hpp/","title":"batteries/state_machine_model/verbose.hpp","text":""},{"location":"_autogen/Files/verbose_8hpp/#defines","title":"Defines","text":"Name BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP BATT_STATE_MACHINE_VERBOSE()"},{"location":"_autogen/Files/verbose_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/verbose_8hpp/#define-batteries_state_machine_model_verbose_hpp","title":"define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP","text":"<pre><code>#define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP()\n</code></pre>"},{"location":"_autogen/Files/verbose_8hpp/#define-batt_state_machine_verbose","title":"define BATT_STATE_MACHINE_VERBOSE","text":"<pre><code>#define BATT_STATE_MACHINE_VERBOSE()\n</code></pre>"},{"location":"_autogen/Files/verbose_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP\n#define BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP\n#include &lt;iostream&gt;\n#if 0\n#define BATT_STATE_MACHINE_VERBOSE() \nfor (bool b_VerBOSe_vAR = true; b_VerBOSe_vAR; std::cout &lt;&lt; std::endl, b_VerBOSe_vAR = false)                \\\n    std::cout\n#else\n#define BATT_STATE_MACHINE_VERBOSE()                                                                         \\\n    for (; false;)                                                                                           \\\n    std::cout\n#endif\n#endif  // BATTERIES_STATE_MACHINE_MODEL_VERBOSE_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Files/watch_8cpp/","title":"batteries/async/watch.cpp","text":""},{"location":"_autogen/Files/watch_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/watch.hpp&gt;\n//\n#include &lt;batteries/async/watch_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/watch_8hpp/","title":"batteries/async/watch.hpp","text":""},{"location":"_autogen/Files/watch_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#include &lt;batteries/async/watch_decl.hpp&gt;\n#include &lt;batteries/async/watch.ipp&gt;\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/watch_impl.hpp&gt;\n#endif\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/watch__decl_8hpp/","title":"batteries/async/watch_decl.hpp","text":""},{"location":"_autogen/Files/watch__decl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/watch__decl_8hpp/#classes","title":"Classes","text":"Name class batt::Watch A batt::Watch is like a <code>std::atomic</code> that you can block on, synchronously and asynchronously; see also batt::WatchAtomic. struct batt::HoldOwnership struct batt::ReleaseOwnership class batt::WatchAtomic Watch for atomic primitive type. class batt::Watch&lt; bool &gt; class batt::Watch&lt; i8 &gt; class batt::Watch&lt; i16 &gt; class batt::Watch&lt; i32 &gt; class batt::Watch&lt; i64 &gt; class batt::Watch&lt; u8 &gt; class batt::Watch&lt; u16 &gt; class batt::Watch&lt; u32 &gt; class batt::Watch&lt; u64 &gt; class batt::Watch&lt; void * &gt; class batt::Watch&lt; T * &gt;"},{"location":"_autogen/Files/watch__decl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WATCH_DECL_HPP BATT_WATCH_HOLD_IMPL(old_value_expr, new_value_expr) BATT_WATCH_RELEASE_IMPL(old_value_expr, new_value_expr) BATT_SPECIALIZE_WATCH_ATOMIC(type)"},{"location":"_autogen/Files/watch__decl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/watch__decl_8hpp/#define-batteries_async_watch_decl_hpp","title":"define BATTERIES_ASYNC_WATCH_DECL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WATCH_DECL_HPP()\n</code></pre>"},{"location":"_autogen/Files/watch__decl_8hpp/#define-batt_watch_hold_impl","title":"define BATT_WATCH_HOLD_IMPL","text":"<pre><code>#define BATT_WATCH_HOLD_IMPL(old_value_expr, new_value_expr)\n</code></pre>"},{"location":"_autogen/Files/watch__decl_8hpp/#define-batt_watch_release_impl","title":"define BATT_WATCH_RELEASE_IMPL","text":"<pre><code>#define BATT_WATCH_RELEASE_IMPL(old_value_expr, new_value_expr)\n</code></pre>"},{"location":"_autogen/Files/watch__decl_8hpp/#define-batt_specialize_watch_atomic","title":"define BATT_SPECIALIZE_WATCH_ATOMIC","text":"<pre><code>#define BATT_SPECIALIZE_WATCH_ATOMIC(type)\n</code></pre>"},{"location":"_autogen/Files/watch__decl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2024 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_WATCH_DECL_HPP\n#define BATTERIES_ASYNC_WATCH_DECL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/handler.hpp&gt;\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;batteries/math.hpp&gt;\n#include &lt;batteries/optional.hpp&gt;\n#include &lt;batteries/seq/natural_order.hpp&gt;\n#include &lt;batteries/status.hpp&gt;\n#include &lt;batteries/type_traits.hpp&gt;\n#include &lt;bitset&gt;\n#include &lt;mutex&gt;\n#include &lt;ostream&gt;\n#include &lt;thread&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\ntemplate &lt;typename T&gt;\nclass Watch\n{\npublic:\nWatch(const Watch&amp;) = delete;\nWatch&amp; operator=(const Watch&amp;) = delete;\nWatch() = default;\ntemplate &lt;typename Init, typename = EnableIfNoShadow&lt;Watch, Init&gt;&gt;\nexplicit Watch(Init&amp;&amp; init_value) noexcept : value_(BATT_FORWARD(init_value))\n{\n}\n~Watch()\n{\nthis-&gt;close();\n}\nvoid close()\n{\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{mutex_};\nthis-&gt;closed_ = true;\nstd::swap(local_observers, this-&gt;observers_);\n}\ninvoke_all_handlers(&amp;local_observers, Status{StatusCode::kClosed});\n}\nbool is_closed() const\n{\nstd::unique_lock&lt;std::mutex&gt; lock{mutex_};\nreturn this-&gt;closed_;\n}\nvoid set_value(const T&amp; new_value)\n{\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{mutex_};\nif (new_value != this-&gt;value_) {\nvalue_ = new_value;\nstd::swap(local_observers, this-&gt;observers_);\n}\n}\ninvoke_all_handlers(&amp;local_observers, new_value);\n}\nT get_value() const\n{\nstd::unique_lock&lt;std::mutex&gt; lock{mutex_};\nreturn value_;\n}\ntemplate &lt;typename Fn&gt;\nT modify(Fn&amp;&amp; fn)\n{\nOptional&lt;T&gt; new_value;\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{mutex_};\nnew_value.emplace(BATT_FORWARD(fn)(value_));\nif (*new_value != value_) {\nvalue_ = *new_value;\nstd::swap(local_observers, this-&gt;observers_);\n}\n}\ninvoke_all_handlers(&amp;local_observers, *new_value);\nreturn std::move(*new_value);\n}\ntemplate &lt;typename Handler&gt;\nvoid async_wait(const T&amp; last_seen, Handler&amp;&amp; fn)\n{\nbool local_closed = false;\nbool changed = false;\nT new_value;\n{\nstd::unique_lock&lt;std::mutex&gt; lock{mutex_};\nif (this-&gt;closed_) {\nlocal_closed = true;\n} else if (value_ == last_seen &amp;&amp; !this-&gt;closed_) {\npush_handler(&amp;this-&gt;observers_, BATT_FORWARD(fn));\n} else {\nchanged = true;\nnew_value = value_;\n}\n}\nif (local_closed) {\nBATT_FORWARD(fn)(Status{StatusCode::kClosed});\n} else if (changed) {\nBATT_FORWARD(fn)(new_value);\n}\n}\nStatusOr&lt;T&gt; await_not_equal(const T&amp; last_seen);\ntemplate &lt;typename Pred&gt;\nStatusOr&lt;T&gt; await_true(Pred&amp;&amp; pred)\n{\nStatusOr&lt;T&gt; last_seen = this-&gt;get_value();\nwhile (last_seen.ok() &amp;&amp; !pred(*last_seen)) {\nlast_seen = this-&gt;await_not_equal(*last_seen);\n}\nreturn last_seen;\n}\ntemplate &lt;typename OrderFn = bool(const T&amp;, const T&amp;)&gt;\nvoid clamp_min_value(const T&amp; lower_bound, OrderFn&amp;&amp; order_fn)\n{\nthis-&gt;modify([&amp;](const T&amp; observed) -&gt; const T&amp; {\nif (order_fn(observed, lower_bound)) {\nreturn lower_bound;\n}\nreturn observed;\n});\n}\ntemplate &lt;typename OrderFn = bool(const T&amp;, const T&amp;)&gt;\nvoid clamp_max_value(const T&amp; upper_bound, OrderFn&amp;&amp; order_fn)\n{\nthis-&gt;modify([&amp;](const T&amp; observed) -&gt; const T&amp; {\nif (order_fn(upper_bound, observed)) {\nreturn upper_bound;\n}\nreturn observed;\n});\n}\nvoid clamp_min_value(const T&amp; lower_bound)\n{\nthis-&gt;clamp_min_value(lower_bound, seq::NaturalOrder{});\n}\nvoid clamp_max_value(const T&amp; upper_bound)\n{\nthis-&gt;clamp_max_value(upper_bound, seq::NaturalOrder{});\n}\nprivate:\nmutable std::mutex mutex_;\nbool closed_ = false;\nT value_;\nHandlerList&lt;StatusOr&lt;T&gt;&gt; observers_;\n};\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Watch&lt;T&gt;&amp; w)\n{\nreturn out &lt;&lt; make_printable(w.get_value());\n}\nstruct HoldOwnership {\n};\nstruct ReleaseOwnership {\n};\ntemplate &lt;typename T&gt;\nclass WatchAtomic\n{\npublic:\nusing value_type = T;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nstatic constexpr u32 kLocked = 0x01;\nstatic constexpr u32 kOpen = 0x02;\nstatic constexpr u32 kWaiting = 0x04;\nstatic constexpr u32 kClosedAtEnd = 0x08;\nstatic constexpr u32 kClosedBeforeEnd = 0x10;\nstatic constexpr u32 kPoked = 0x20;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nWatchAtomic(const WatchAtomic&amp;) = delete;\nWatchAtomic&amp; operator=(const WatchAtomic&amp;) = delete;\nWatchAtomic() = default;\ntemplate &lt;typename Init, typename = EnableIfNoShadow&lt;WatchAtomic, Init&gt;&gt;\nexplicit WatchAtomic(Init&amp;&amp; init_value) noexcept : value_(BATT_FORWARD(init_value))\n{\nstatic_assert(kLocked != (kLocked | kOpen));\nstatic_assert((kLocked | kOpen) != (kLocked | kOpen | kWaiting));\nstatic_assert((kLocked | kOpen | kWaiting) != (kLocked | kOpen | kWaiting | kClosedAtEnd));\nstatic_assert((kLocked | kOpen | kWaiting | kClosedAtEnd) !=\n(kLocked | kOpen | kWaiting | kClosedAtEnd | kClosedBeforeEnd));\nstatic_assert((kLocked | kOpen | kWaiting | kClosedAtEnd | kClosedBeforeEnd) !=\n(kLocked | kOpen | kWaiting | kClosedAtEnd | kClosedBeforeEnd | kPoked));\n}\n~WatchAtomic() noexcept\n{\nthis-&gt;close();\n}\nvoid close(StatusCode final_status_code = StatusCode::kClosed)\n{\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;\n{\nconst u32 prior_state = this-&gt;lock_observers();\nstd::swap(local_observers, this-&gt;observers_);\nconst u32 desired_state = (prior_state &amp; ~(kOpen | kWaiting)) | ([&amp;]() -&gt; u32 {\n// If already closed, don't change the closed status.\n//\nif ((prior_state &amp; kOpen) != kOpen) {\nreturn 0;\n}\nBATT_SUPPRESS_IF_GCC(\"-Wswitch-enum\")\nBATT_SUPPRESS_IF_CLANG(\"-Wswitch-enum\")\n{\nswitch (final_status_code) {\ncase StatusCode::kEndOfStream:\nreturn WatchAtomic::kClosedAtEnd;\ncase StatusCode::kClosedBeforeEndOfStream:\nreturn WatchAtomic::kClosedBeforeEnd;\ncase StatusCode::kClosed:  // fall-through\ndefault:\n// All other StatusCode values are ignored; set status\n// StatusCode::kClosed.\n//\nreturn 0;\n}\n}\nBATT_UNSUPPRESS_IF_CLANG()\nBATT_UNSUPPRESS_IF_GCC()\n}());\nthis-&gt;unlock_observers(desired_state);\n}\ninvoke_all_handlers(&amp;local_observers, this-&gt;get_final_status());\n//\n// IMPORTANT: Nothing can come after invoking observers, since we must allow one observer to delete\n// the WatchAtomic object (`this`).\n}\nvoid poke() noexcept\n{\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;\n{\nconst u32 prior_state = this-&gt;lock_observers();\nstd::swap(local_observers, this-&gt;observers_);\n// If we have an observer to invoke, then clear the waiting bit when we unlock; otherwise, set the\n// poked bit so that the next observer will be poked instead of waiting.  This resolves the race\n// condition:\n//\n// 1. (task A) check STATE\n// 2. (task B) update STATE\n// 3. (task B) poke (to force A to recheck STATE before awaiting on watch to change)\n// 4. (task A) watch.await_true(...)\n//\nconst u32 desired_state = [&amp;] {\nif ((prior_state &amp; kWaiting) == kWaiting) {\nreturn prior_state &amp; ~kWaiting;\n}\nreturn prior_state | kPoked;\n}();\nthis-&gt;unlock_observers(desired_state);\n}\ninvoke_all_handlers(&amp;local_observers, Status{StatusCode::kPoke});\n}\nbool is_poked() const noexcept\n{\nreturn (this-&gt;spin_state_.load() &amp; kPoked) == kPoked;\n}\nvoid reset()\n{\nconst u32 prior_state = this-&gt;lock_observers();\n// Set the open bit again.\n//\nconst u32 desired_state = prior_state | kOpen;\nthis-&gt;unlock_observers(desired_state);\n}\nbool is_closed() const\n{\nreturn !(this-&gt;spin_state_.load() &amp; kOpen);\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\n#define BATT_WATCH_HOLD_IMPL(old_value_expr, new_value_expr)                                                 \\\n    T old_value = old_value_expr;                                                                            \\\n    T new_value = new_value_expr;                                                                            \\\n    if (new_value != old_value) {                                                                            \\\n        this-&gt;notify(new_value);                                                                             \\\n    }                                                                                                        \\\n    return old_value\n#define BATT_WATCH_RELEASE_IMPL(old_value_expr, new_value_expr)                                              \\\n    HandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;                                                                \\\n    T old_value;                                                                                             \\\n    T new_value;                                                                                             \\\n    {                                                                                                        \\\n        const auto pre_lock_state = this-&gt;lock_observers();                                                  \\\n        old_value = old_value_expr;                                                                          \\\n        new_value = new_value_expr;                                                                          \\\n        if (new_value != old_value) {                                                                        \\\n            std::swap(local_observers, this-&gt;observers_);                                                    \\\n        }                                                                                                    \\\n        this-&gt;unlock_observers(pre_lock_state &amp; ~(kWaiting));                                                \\\n    }                                                                                                        \\\n    invoke_all_handlers(&amp;local_observers, new_value);                                                        \\\n    return old_value\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nT set_value(T arg, HoldOwnership = {}) noexcept\n{\nBATT_WATCH_HOLD_IMPL(this-&gt;value().exchange(arg), arg);\n}\nT set_value(T arg, ReleaseOwnership) noexcept\n{\nBATT_WATCH_RELEASE_IMPL(this-&gt;value().exchange(arg), arg);\n}\nT set_value_and_release(T new_value) noexcept\n{\nreturn this-&gt;set_value(new_value, ReleaseOwnership{});\n}\nT get_value() const noexcept\n{\nreturn this-&gt;value().load();\n}\nT fetch_add(T arg, HoldOwnership = {}) noexcept\n{\nBATT_WATCH_HOLD_IMPL(this-&gt;value().fetch_add(arg), old_value + arg);\n}\nT fetch_add(T arg, ReleaseOwnership) noexcept\n{\nBATT_WATCH_RELEASE_IMPL(this-&gt;value().fetch_add(arg), old_value + arg);\n}\nT fetch_or(T arg, HoldOwnership = {}) noexcept\n{\nBATT_WATCH_HOLD_IMPL(this-&gt;value().fetch_or(arg), old_value | arg);\n}\nT fetch_or(T arg, ReleaseOwnership) noexcept\n{\nBATT_WATCH_RELEASE_IMPL(this-&gt;value().fetch_or(arg), old_value | arg);\n}\nT fetch_sub(T arg, HoldOwnership = {}) noexcept\n{\nBATT_WATCH_HOLD_IMPL(this-&gt;value().fetch_sub(arg), old_value - arg);\n}\nT fetch_sub(T arg, ReleaseOwnership) noexcept\n{\nBATT_WATCH_RELEASE_IMPL(this-&gt;value().fetch_sub(arg), old_value - arg);\n}\nT fetch_and(T arg, HoldOwnership = {})\n{\nBATT_WATCH_HOLD_IMPL(this-&gt;value().fetch_and(arg), old_value &amp; arg);\n}\nT fetch_and(T arg, ReleaseOwnership)\n{\nBATT_WATCH_RELEASE_IMPL(this-&gt;value().fetch_and(arg), old_value &amp; arg);\n}\ntemplate &lt;typename Fn = T(T)&gt;\nT modify(Fn&amp;&amp; fn)\n{\nT old_value = this-&gt;value().load();\nbool changed = false;\nconst T new_value = [&amp;] {\nfor (;;) {\nconst T modified_value = fn(old_value);\nchanged = changed || (modified_value != old_value);\nif (this-&gt;value().compare_exchange_weak(old_value, modified_value)) {\nreturn modified_value;\n}\n}\n}();\nif (changed) {\nthis-&gt;notify(new_value);\n//\n// IMPORTANT: we must not touch *anything* in this after `notify`, since a handler may have\n// deleted this Watch object.\n}\n// TODO [tastolfi 2021-10-14] make the non-atomic version of modify consistent with this behavior!\nreturn old_value;\n}\nbool compare_exchange(T&amp; old_value, T new_value)\n{\nconst T init_old_value = old_value;\nfor (;;) {\nif (this-&gt;value().compare_exchange_weak(old_value, new_value)) {\nbreak;\n}\nif (old_value != init_old_value) {\nreturn false;\n}\n}\nif (init_old_value != new_value) {\nthis-&gt;notify(new_value);\n}\nreturn true;\n}\ntemplate &lt;typename Fn = Optional&lt;T&gt;(T)&gt;\nStatusOr&lt;T&gt; await_modify(Fn&amp;&amp; fn);\ntemplate &lt;typename Fn = Optional&lt;T&gt;(T)&gt;\nOptional&lt;T&gt; modify_if(Fn&amp;&amp; fn)\n{\nT old_value = this-&gt;value().load();\nbool changed = false;\nconst Optional&lt;T&gt; new_value = [&amp;] {\nfor (;;) {\nconst Optional&lt;T&gt; modified_value = fn(old_value);\nchanged = changed || (modified_value &amp;&amp; *modified_value != old_value);\nif (!modified_value || this-&gt;value().compare_exchange_weak(old_value, *modified_value)) {\nreturn modified_value;\n}\n}\n}();\nif (!new_value) {\nreturn None;\n}\nif (changed) {\nthis-&gt;notify(*new_value);\n//\n// IMPORTANT: we must not touch *anything* in this after `notify`, since a handler may have\n// deleted this Watch object.\n}\nreturn old_value;\n}\ntemplate &lt;typename Handler&gt;\nvoid async_wait(T last_seen, Handler&amp;&amp; fn) const\n{\nT now_seen = this-&gt;value().load();\nbool changed = (now_seen != last_seen);\nif (!changed) {\nu32 prior_state = this-&gt;lock_observers();\nif (!(prior_state &amp; kOpen)) {\nthis-&gt;unlock_observers(prior_state);\nBATT_FORWARD(fn)(this-&gt;get_final_status());\nreturn;\n}\nif ((prior_state &amp; kPoked) == kPoked) {\nthis-&gt;unlock_observers(prior_state &amp; ~kPoked);\nBATT_FORWARD(fn)(Status{StatusCode::kPoke});\nreturn;\n}\nauto unlock_guard = finally([&amp;] {\nthis-&gt;unlock_observers(prior_state);\n});\nnow_seen = this-&gt;value().load();\nchanged = (now_seen != last_seen);\nif (!changed) {\npush_handler(&amp;this-&gt;observers_, BATT_FORWARD(fn));\nprior_state |= kWaiting;\nreturn;\n//\n// The dtor of `unlock_guard` will atomically clear the `kLocked` flag and set `kWaiting`.\n}\n}\n//\n// If we get here, either the initial `changed` check was true, we are closed, or the second `changed`\n// check (with the spin lock held) must have succeeded; in any case, invoke the handler immediately.\nBATT_FORWARD(fn)(now_seen);\n}\nStatusOr&lt;T&gt; await_not_equal(const T&amp; last_seen) const;\ntemplate &lt;typename Pred&gt;\nStatusOr&lt;T&gt; await_true(Pred&amp;&amp; pred) const\n{\nStatusOr&lt;T&gt; last_seen = this-&gt;get_value();\nwhile (last_seen.ok() &amp;&amp; !pred(*last_seen)) {\nlast_seen = this-&gt;await_not_equal(*last_seen);\n}\nreturn last_seen;\n}\nStatus await_equal(T val) const\n{\nreturn this\n-&gt;await_true([val](T observed) {\nreturn observed == val;\n})\n.status();\n}\ntemplate &lt;typename OrderFn = bool(T, T)&gt;\nvoid clamp_min_value(T lower_bound, OrderFn&amp;&amp; order_fn)\n{\nthis-&gt;modify([&amp;](T observed) -&gt; T {\nif (order_fn(observed, lower_bound)) {\nreturn lower_bound;\n}\nreturn observed;\n});\n}\ntemplate &lt;typename OrderFn = bool(T, T)&gt;\nvoid clamp_max_value(T upper_bound, OrderFn&amp;&amp; order_fn)\n{\nthis-&gt;modify([&amp;](T observed) -&gt; T {\nif (order_fn(upper_bound, observed)) {\nreturn upper_bound;\n}\nreturn observed;\n});\n}\nvoid clamp_min_value(T lower_bound)\n{\nthis-&gt;clamp_min_value(lower_bound, seq::NaturalOrder{});\n}\nvoid clamp_max_value(T upper_bound)\n{\nthis-&gt;clamp_max_value(upper_bound, seq::NaturalOrder{});\n}\nT poll() noexcept;\nprivate:\nBATT_ALWAYS_INLINE std::atomic&lt;T&gt;&amp; value() noexcept\n{\nreturn this-&gt;value_;\n}\nBATT_ALWAYS_INLINE const std::atomic&lt;T&gt;&amp; value() const noexcept\n{\nreturn this-&gt;value_;\n}\nStatus get_final_status() const\n{\nconstexpr u32 mask = WatchAtomic::kClosedAtEnd | WatchAtomic::kClosedBeforeEnd;\nswitch (this-&gt;spin_state_.load() &amp; mask) {\ncase WatchAtomic::kClosedBeforeEnd:\nreturn Status{StatusCode::kClosedBeforeEndOfStream};\ncase WatchAtomic::kClosedAtEnd:\nreturn Status{StatusCode::kEndOfStream};\ndefault:\nbreak;\n}\nreturn Status{StatusCode::kClosed};\n}\nu32 lock_observers() const\n{\nfor (;;) {\nconst u32 prior_state = this-&gt;spin_state_.fetch_or(kLocked);\nif ((prior_state &amp; kLocked) == 0) {\nreturn prior_state;\n}\nstd::this_thread::yield();\n}\n}\nvoid unlock_observers(u32 desired_state) const\n{\nthis-&gt;spin_state_.store(desired_state &amp; ~kLocked);\n}\nvoid notify(T new_value)\n{\nconst auto post_change_state = this-&gt;spin_state_.load();\nif ((post_change_state &amp; (kLocked | kWaiting)) == 0) {\n//\n// If there is a concurrent call to async_wait that results in a handler being added to the\n// `observers_` list, it must go through the following atomic events:\n//\n//  1. load value (phase 1), no change\n//  2. set kLocked\n//  3. load value (phase 2), no change\n//  4. set kWaiting\n//\n// The notifier thread (this call), when not waking observers, goes through the following atomic\n// events:\n//\n//  a. change value\n//  b. load spin state, observe not kLocked and not kWaiting\n//\n// (b) must occur before (1) [therefore (a) &lt; (1)] or between (1) and (2) [(a) &lt; (3)].  In either\n// case, the async_wait call will load the value *after* this thread changes it (a), so there will\n// be no spurious deadlocks.\n//\nreturn;\n}\n// Acquire the spinlock.\n//\nconst auto pre_lock_state = this-&gt;lock_observers();\nHandlerList&lt;StatusOr&lt;T&gt;&gt; local_observers;\nstd::swap(local_observers, this-&gt;observers_);\nthis-&gt;unlock_observers(pre_lock_state &amp; ~(kWaiting));\ninvoke_all_handlers(&amp;local_observers, new_value);\n//\n// IMPORTANT: we must not touch *anything* in `this` after invoking handlers, since one of the\n// handlers may delete this Watch object.\n}\nstd::atomic&lt;T&gt; value_{0};\nmutable std::atomic&lt;u32&gt; spin_state_{kOpen};\nmutable HandlerList&lt;StatusOr&lt;T&gt;&gt; observers_;\n};\ntemplate &lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const WatchAtomic&lt;T&gt;&amp; w)\n{\nreturn out &lt;&lt; w.get_value();\n}\n#define BATT_SPECIALIZE_WATCH_ATOMIC(type)                                                                   \\\n    template &lt;&gt;                                                                                              \\\n    class Watch&lt;type&gt; : public WatchAtomic&lt;type&gt;                                                             \\\n    {                                                                                                        \\\n       public:                                                                                               \\\n        using WatchAtomic&lt;type&gt;::WatchAtomic;                                                                \\\n    }\nBATT_SPECIALIZE_WATCH_ATOMIC(bool);\nBATT_SPECIALIZE_WATCH_ATOMIC(i8);\nBATT_SPECIALIZE_WATCH_ATOMIC(i16);\nBATT_SPECIALIZE_WATCH_ATOMIC(i32);\nBATT_SPECIALIZE_WATCH_ATOMIC(i64);\nBATT_SPECIALIZE_WATCH_ATOMIC(u8);\nBATT_SPECIALIZE_WATCH_ATOMIC(u16);\nBATT_SPECIALIZE_WATCH_ATOMIC(u32);\nBATT_SPECIALIZE_WATCH_ATOMIC(u64);\n#if BATT_COMPILER_IS_CLANG\nBATT_SPECIALIZE_WATCH_ATOMIC(signed long);\nBATT_SPECIALIZE_WATCH_ATOMIC(unsigned long);\n#endif  // BATT_COMPILER_IS_CLANG\nBATT_SPECIALIZE_WATCH_ATOMIC(void*);\n#undef BATT_SPECIALIZE_WATCH_ATOMIC\n//=#=#==#==#===============+=+=+=+=++=++++++++++++++-++-+--+-+----+---------------\n// Specialize Watch for all raw pointer types, based on void*.\n//\ntemplate &lt;typename T&gt;\nclass Watch&lt;T*&gt; : public WatchAtomic&lt;void*&gt;\n{\npublic:\nusing Super = WatchAtomic&lt;void*&gt;;\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nWatch() = default;\nexplicit Watch(T* init_value) noexcept : Super{init_value}\n{\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nT* set_value(T* new_value) noexcept\n{\nreturn static_cast&lt;T*&gt;(this-&gt;Super::set_value(new_value));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nT* set_value_and_release(T* new_value) noexcept\n{\nreturn static_cast&lt;T*&gt;(this-&gt;Super::set_value_and_release(new_value));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nT* get_value() const noexcept\n{\nreturn static_cast&lt;T*&gt;(this-&gt;Super::get_value());\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Fn = T*(T*)&gt;\nT* modify(Fn&amp;&amp; fn)\n{\nreturn static_cast&lt;T*&gt;(this-&gt;Super::modify([&amp;fn](void* observed_value) -&gt; void* {\nreturn fn(static_cast&lt;T*&gt;(observed_value));\n}));\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Fn = Optional&lt;T*&gt;(T*)&gt;\nStatusOr&lt;T*&gt; await_modify(Fn&amp;&amp; fn)\n{\nBATT_ASSIGN_OK_RESULT(void* old_value,\nthis-&gt;Super::await_modify([&amp;fn](void* observed_value) -&gt; Optional&lt;void*&gt; {\nreturn fn(static_cast&lt;T*&gt;(observed_value));\n}));\nreturn {static_cast&lt;T*&gt;(old_value)};\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\ntemplate &lt;typename Fn = Optional&lt;T*&gt;(T*)&gt;\nOptional&lt;T*&gt; modify_if(Fn&amp;&amp; fn)\n{\nOptional&lt;void*&gt; old_value = this-&gt;Super::modify_if([&amp;fn](void* observed_value) -&gt; Optional&lt;void*&gt; {\nreturn fn(static_cast&lt;T*&gt;(observed_value));\n});\nif (!old_value) {\nreturn None;\n}\nreturn static_cast&lt;T*&gt;(*old_value);\n}\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nStatusOr&lt;T*&gt; await_not_equal(T* old_value)\n{\nBATT_ASSIGN_OK_RESULT(void* new_value, this-&gt;Super::await_not_equal(old_value));\nreturn static_cast&lt;T*&gt;(new_value);\n}\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_WATCH_DECL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/watch__impl_8hpp/","title":"batteries/async/watch_impl.hpp","text":""},{"location":"_autogen/Files/watch__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/watch__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WATCH_IMPL_HPP"},{"location":"_autogen/Files/watch__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/watch__impl_8hpp/#define-batteries_async_watch_impl_hpp","title":"define BATTERIES_ASYNC_WATCH_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WATCH_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/watch__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2021-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_WATCH_IMPL_HPP\n#define BATTERIES_ASYNC_WATCH_IMPL_HPP\nnamespace batt {\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_WATCH_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/work__context_8cpp/","title":"batteries/async/work_context.cpp","text":""},{"location":"_autogen/Files/work__context_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/work_context.hpp&gt;\n#include &lt;batteries/async/work_context_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/work__context_8hpp/","title":"batteries/async/work_context.hpp","text":""},{"location":"_autogen/Files/work__context_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/work__context_8hpp/#classes","title":"Classes","text":"Name class batt::WorkContext class batt::ScopedWorkContext"},{"location":"_autogen/Files/work__context_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WORK_CONTEXT_HPP"},{"location":"_autogen/Files/work__context_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/work__context_8hpp/#define-batteries_async_work_context_hpp","title":"define BATTERIES_ASYNC_WORK_CONTEXT_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WORK_CONTEXT_HPP()\n</code></pre>"},{"location":"_autogen/Files/work__context_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_WORK_CONTEXT_HPP\n#define BATTERIES_ASYNC_WORK_CONTEXT_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/utility.hpp&gt;\n#include &lt;thread&gt;\nnamespace batt {\n// Tracks a set of work items submitted to a WorkerPool so that application code can wait on the\n// completion of the entire set.\n//\nclass WorkContext\n{\npublic:\nWorkContext(const WorkContext&amp;) = delete;\nWorkContext&amp; operator=(const WorkContext&amp;) = delete;\nexplicit WorkContext(WorkerPool&amp; worker_pool) noexcept : worker_pool_{worker_pool}\n{\n}\ntemplate &lt;typename Fn&gt;\ndecltype(auto) async_run(Fn&amp;&amp; work_fn)\n{\nthis-&gt;on_work_started();\nreturn this-&gt;worker_pool_.async_run([this, work_fn = BATT_FORWARD(work_fn)]() mutable {\nconst auto on_exit = batt::finally([&amp;] {\nthis-&gt;on_work_finished();\n});\nwork_fn();\n});\n}\nvoid on_work_started()\n{\nthis-&gt;ref_count_.fetch_add(1);\nthis-&gt;work_count_.fetch_add(1);\n}\nvoid on_work_finished()\n{\nthis-&gt;work_count_.fetch_sub(1);\nthis-&gt;ref_count_.fetch_sub(1);\n}\nvoid await_done()\n{\nBATT_CHECK(!batt::Task::inside_work_fn());\nBATT_DEBUG_INFO(\"work_count=\" &lt;&lt; this-&gt;work_count_.get_value());\nthis-&gt;work_count_\n.await_true([](i64 count) {\nBATT_CHECK_GE(count, 0);\nreturn count &lt;= 0;\n})\n.IgnoreError();\nwhile (this-&gt;ref_count_.load() &gt; 0) {\nbatt::Task::yield();\n}\n}\nprivate:\nWorkerPool&amp; worker_pool_;\nbatt::Watch&lt;i64&gt; work_count_{0};\nstd::atomic&lt;i64&gt; ref_count_{0};\n};\n// Guard class that automatically waits on the completion of work in a WorkContext.\n//\nclass ScopedWorkContext : public WorkContext\n{\npublic:\nusing WorkContext::WorkContext;\nvoid cancel()\n{\nthis-&gt;cancelled_.store(true);\n}\n~ScopedWorkContext() noexcept\n{\nif (!this-&gt;cancelled_.load()) {\nthis-&gt;await_done();\n}\n}\nprivate:\nstd::atomic&lt;bool&gt; cancelled_{false};\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_WORK_CONTEXT_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/work__context__impl_8hpp/","title":"batteries/async/work_context_impl.hpp","text":""},{"location":"_autogen/Files/work__context__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/work__context__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WORK_CONTEXT_IMPL_HPP"},{"location":"_autogen/Files/work__context__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/work__context__impl_8hpp/#define-batteries_async_work_context_impl_hpp","title":"define BATTERIES_ASYNC_WORK_CONTEXT_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WORK_CONTEXT_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/work__context__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>#pragma once\n#ifndef BATTERIES_ASYNC_WORK_CONTEXT_IMPL_HPP\n#define BATTERIES_ASYNC_WORK_CONTEXT_IMPL_HPP\nnamespace batt {\n}  //namespace batt\n#endif  // BATTERIES_ASYNC_WORK_CONTEXT_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/worker_8hpp/","title":"batteries/async/worker.hpp","text":""},{"location":"_autogen/Files/worker_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/worker_8hpp/#classes","title":"Classes","text":"Name class batt::Worker"},{"location":"_autogen/Files/worker_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WORKER_HPP"},{"location":"_autogen/Files/worker_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/worker_8hpp/#define-batteries_async_worker_hpp","title":"define BATTERIES_ASYNC_WORKER_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WORKER_HPP()\n</code></pre>"},{"location":"_autogen/Files/worker_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_WORKER_HPP\n#define BATTERIES_ASYNC_WORKER_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/debug_info.hpp&gt;\n#include &lt;batteries/async/queue.hpp&gt;\n#include &lt;batteries/async/task.hpp&gt;\n#include &lt;batteries/constants.hpp&gt;\n#include &lt;batteries/finally.hpp&gt;\n#include &lt;batteries/small_fn.hpp&gt;\n#include &lt;string&gt;\nnamespace batt {\nclass Worker\n{\npublic:\nusing WorkFn = #ifdef NDEBUG\nbatt::UniqueSmallFn&lt;void(), 128 - 16&gt;\n#else\nbatt::UniqueSmallFn&lt;void(), 256 - 16&gt;\n#endif\n;\nexplicit Worker(boost::asio::any_io_executor ex, std::string&amp;&amp; name = \"Worker::task\") noexcept\n: task{ex,\n[this] {\nint job_count = 0;\nfor (;;) {\nBATT_DEBUG_INFO(\"[Worker::task] waiting for next job (completed=\" &lt;&lt; job_count &lt;&lt; \")\");\nbatt::StatusOr&lt;WorkFn&gt; next_work = this-&gt;work_queue.await_next();\nif (!next_work.ok()) {\nreturn;\n}\n{\nbatt::Task::inside_work_fn() = true;\nauto on_work_done = batt::finally([] {\nbatt::Task::inside_work_fn() = false;\n});\n(*next_work)();\n}\n++job_count;\n}\n},\nstd::move(name), batt::StackSize{2 * kMiB}}\n{\n}\nbatt::Queue&lt;WorkFn&gt; work_queue;\nbatt::Task task;\n};\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_WORKER_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/worker__pool_8cpp/","title":"batteries/async/worker_pool.cpp","text":""},{"location":"_autogen/Files/worker__pool_8cpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#include &lt;batteries/config.hpp&gt;\n#if !BATT_HEADER_ONLY\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;batteries/async/worker_pool_impl.hpp&gt;\n#endif  // !BATT_HEADER_ONLY\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/worker__pool_8hpp/","title":"batteries/async/worker_pool.hpp","text":""},{"location":"_autogen/Files/worker__pool_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/worker__pool_8hpp/#classes","title":"Classes","text":"Name class batt::WorkerPool class batt::ScopedWorkerThreadPool"},{"location":"_autogen/Files/worker__pool_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WORKER_POOL_HPP"},{"location":"_autogen/Files/worker__pool_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/worker__pool_8hpp/#define-batteries_async_worker_pool_hpp","title":"define BATTERIES_ASYNC_WORKER_POOL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WORKER_POOL_HPP()\n</code></pre>"},{"location":"_autogen/Files/worker__pool_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_WORKER_POOL_HPP\n#define BATTERIES_ASYNC_WORKER_POOL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/async/task_scheduler.hpp&gt;\n#include &lt;batteries/async/worker.hpp&gt;\n#include &lt;batteries/do_nothing.hpp&gt;\n#include &lt;batteries/int_types.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\nnamespace batt {\nclass WorkerPool\n{\npublic:\nstatic WorkerPool&amp; default_pool();\n// A pool containing no workers; `async_run` will always execute the passed function immediately on the\n// caller's thread.\n//\nstatic WorkerPool&amp; null_pool()\n{\nstatic WorkerPool* pool_ = new WorkerPool{0, NullTaskScheduler::instance()};\nreturn *pool_;\n}\nexplicit WorkerPool(usize size, TaskScheduler&amp; scheduler) noexcept\n{\nfor (usize i = 0; i &lt; size; ++i) {\nthis-&gt;workers_.emplace_back(std::make_unique&lt;Worker&gt;(scheduler.schedule_task()));\n}\n}\nexplicit WorkerPool(std::vector&lt;std::unique_ptr&lt;Worker&gt;&gt;&amp;&amp; workers) noexcept\n: workers_{std::move(workers)}\n{\n}\ntemplate &lt;typename Fn&gt;\nStatus async_run(Fn&amp;&amp; fn)\n{\nif (this-&gt;workers_.size() == 0) {\nfn();\nreturn OkStatus();\n} else {\nconst usize next = this-&gt;round_robin_.fetch_add(1) % this-&gt;workers_.size();\nreturn this-&gt;workers_[next]-&gt;work_queue.push(BATT_FORWARD(fn));\n}\n}\nvoid reset(usize phase_shift = 0)\n{\nthis-&gt;round_robin_ = phase_shift;\n}\nusize size() const\n{\nreturn workers_.size();\n}\nvoid halt()\n{\nfor (const auto&amp; w : this-&gt;workers_) {\nw-&gt;work_queue.close();\n}\n}\nvoid join()\n{\nfor (const auto&amp; w : this-&gt;workers_) {\nw-&gt;task.join();\n}\n}\n~WorkerPool() noexcept\n{\nthis-&gt;halt();\nthis-&gt;join();\n}\nprivate:\nWorkerPool() = default;\nstd::vector&lt;std::unique_ptr&lt;Worker&gt;&gt; workers_;\nstd::atomic&lt;usize&gt; round_robin_{0};\n};\nclass ScopedWorkerThreadPool\n{\npublic:\nusing WorkGuard =\nbatt::Optional&lt;boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt;&gt;;\nexplicit ScopedWorkerThreadPool(usize size,                                                           //\nstd::function&lt;void(usize thread_i)&gt;&amp;&amp; thread_enter_fn = DoNothing{},  //\nstd::function&lt;void(usize thread_i)&gt;&amp;&amp; thread_exit_fn = DoNothing{}    //\n) noexcept\n: thread_enter_fn_{std::move(thread_enter_fn)}\n, thread_exit_fn_{std::move(thread_exit_fn)}\n, worker_pool_{[&amp;] {\nstd::vector&lt;std::unique_ptr&lt;Worker&gt;&gt; workers;\nfor (usize thread_i = 0; thread_i &lt; size; ++thread_i) {\nthis-&gt;io_.emplace_back(std::make_unique&lt;boost::asio::io_context&gt;());\nthis-&gt;work_guards_.emplace_back(\nstd::make_unique&lt;WorkGuard&gt;(this-&gt;io_.back()-&gt;get_executor()));\nthis-&gt;threads_.emplace_back([thread_i, this, io = this-&gt;io_.back().get()] {\nthis-&gt;thread_enter_fn_(thread_i);\nauto on_scope_exit = batt::finally([&amp;] {\nthis-&gt;thread_exit_fn_(thread_i);\n});\nio-&gt;run();\n});\nworkers.emplace_back(std::make_unique&lt;Worker&gt;(this-&gt;io_.back()-&gt;get_executor()));\n}\nreturn WorkerPool(std::move(workers));\n}()}\n{\n}\nWorkerPool&amp; worker_pool() noexcept\n{\nreturn this-&gt;worker_pool_;\n}\nvoid halt() noexcept\n{\nthis-&gt;worker_pool_.halt();\nthis-&gt;work_guards_.clear();\n}\nvoid join()\n{\nthis-&gt;worker_pool_.halt();\nfor (std::thread&amp; t : this-&gt;threads_) {\nt.join();\n}\n}\nprivate:\nstd::function&lt;void(usize thread_i)&gt; thread_enter_fn_;\nstd::function&lt;void(usize thread_i)&gt; thread_exit_fn_;\n// One io_context for each thread in the pool.\n//\nstd::vector&lt;std::unique_ptr&lt;boost::asio::io_context&gt;&gt; io_;\n// One WorkGuard for each io_context, to keep it alive even if there is no work available at the\n// moment.\n//\nstd::vector&lt;std::unique_ptr&lt;WorkGuard&gt;&gt; work_guards_;\n// One thread per io_context.\n//\nstd::vector&lt;std::thread&gt; threads_;\nWorkerPool worker_pool_;\n};\n}  // namespace batt\n#if BATT_HEADER_ONLY\n#include &lt;batteries/async/worker_pool_impl.hpp&gt;\n#endif  // BATT_HEADER_ONLY\n#endif  // BATTERIES_ASYNC_WORKER_POOL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/worker__pool__impl_8hpp/","title":"batteries/async/worker_pool_impl.hpp","text":""},{"location":"_autogen/Files/worker__pool__impl_8hpp/#namespaces","title":"Namespaces","text":"Name batt"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#defines","title":"Defines","text":"Name BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/worker__pool__impl_8hpp/#define-batteries_async_worker_pool_impl_hpp","title":"define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP","text":"<pre><code>#define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP()\n</code></pre>"},{"location":"_autogen/Files/worker__pool__impl_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2022-2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP\n#define BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/cpu_align.hpp&gt;\n#include &lt;batteries/env.hpp&gt;\n#include &lt;batteries/logging.hpp&gt;\n#include &lt;batteries/async/simple_executor.hpp&gt;\n#include &lt;batteries/async/worker_pool.hpp&gt;\n#include &lt;vector&gt;\nnamespace batt {\n//==#==========+==+=+=++=+++++++++++-+-+--+----- --- -- -  -  -   -\n//\nBATT_INLINE_IMPL /*static*/ WorkerPool&amp; WorkerPool::default_pool()\n{\nstatic WorkerPool* pool_ = [] {\nstatic const usize cpu_count = std::thread::hardware_concurrency();\n#ifdef __linux__\nstatic const bool is_linux = true;\n#else\nstatic const bool is_linux = false;\n#endif\nstatic const ThreadPoolConfig config = {\n.thread_count = getenv_as&lt;usize&gt;(\"BATT_WORKER_POOL_DEFAULT_SIZE\").value_or(cpu_count),\n.cpu_group_size = getenv_as&lt;usize&gt;(\"BATT_WORKER_POOL_CPU_GROUP_SIZE\").value_or(2),\n.first_cpu = getenv_as&lt;usize&gt;(\"BATT_WORKER_POOL_FIRST_CPU\").value_or(0),\n.pin = getenv_as&lt;bool&gt;(\"BATT_WORKER_POOL_PIN_CPU\").value_or(is_linux),\n};\n// These are intentionally leaked to prevent shutdown issues.\n//\nauto* threads = new std::vector&lt;std::thread&gt;;\nauto* io = new std::vector&lt;std::unique_ptr&lt;SimpleExecutionContext&gt;&gt;;\nauto* pool = new WorkerPool;\nfor (usize i = 0; i &lt; config.thread_count; ++i) {\nio-&gt;emplace_back(std::make_unique&lt;SimpleExecutionContext&gt;());\nio-&gt;back()-&gt;get_executor().on_work_started();\nthreads-&gt;emplace_back([p_io = io-&gt;back().get(), i] {\nBATT_CHECK_OK(pin_thread_i_of_config(i, config, \"WorkerPool::default_pool().worker\"));\np_io-&gt;run();\n});\nboost::asio::any_io_executor ex{io-&gt;back()-&gt;get_executor()};\npool-&gt;workers_.emplace_back(std::make_unique&lt;Worker&gt;(std::move(ex)));\n}\nreturn pool;\n}();\nreturn *pool_;\n}\n}  // namespace batt\n#endif  // BATTERIES_ASYNC_WORKER_POOL_IMPL_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Files/zip_8hpp/","title":"batteries/seq/zip.hpp","text":""},{"location":"_autogen/Files/zip_8hpp/#namespaces","title":"Namespaces","text":"Name batt batt::seq batt::seq::detail"},{"location":"_autogen/Files/zip_8hpp/#classes","title":"Classes","text":"Name class batt::seq::Zip struct batt::seq::ZipBinder"},{"location":"_autogen/Files/zip_8hpp/#defines","title":"Defines","text":"Name BATTERIES_SEQ_ZIP_HPP"},{"location":"_autogen/Files/zip_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"_autogen/Files/zip_8hpp/#define-batteries_seq_zip_hpp","title":"define BATTERIES_SEQ_ZIP_HPP","text":"<pre><code>#define BATTERIES_SEQ_ZIP_HPP()\n</code></pre>"},{"location":"_autogen/Files/zip_8hpp/#source-code","title":"Source code","text":"<pre><code>//######=###=##=#=#=#=#=#==#==#====#+==#+==============+==+==+==+=+==+=+=+=+=+=+=+\n// Copyright 2023 Anthony Paul Astolfi\n//\n#pragma once\n#ifndef BATTERIES_SEQ_ZIP_HPP\n#define BATTERIES_SEQ_ZIP_HPP\n#include &lt;batteries/config.hpp&gt;\n//\n#include &lt;batteries/seq/seq_item.hpp&gt;\n#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\nnamespace batt {\nnamespace seq {\ntemplate &lt;typename... Seqs&gt;\nclass Zip\n{\npublic:\nusing Item = std::tuple&lt;SeqItem&lt;Seqs&gt;...&gt;;\nexplicit Zip(Seqs&amp;&amp;... seqs) noexcept : seqs_{BATT_FORWARD(seqs)...}\n{\n}\nOptional&lt;Item&gt; peek()\n{\nif (this-&gt;done_) {\nreturn None;\n}\nOptional&lt;Item&gt; item = this-&gt;peek_impl(std::integral_constant&lt;usize, 0&gt;{});\nif (!item) {\nthis-&gt;done_ = true;\n}\nreturn item;\n}\nOptional&lt;Item&gt; next()\n{\nif (this-&gt;done_) {\nreturn None;\n}\nOptional&lt;Item&gt; item = this-&gt;next_impl(std::integral_constant&lt;usize, 0&gt;{});\nif (!item) {\nthis-&gt;done_ = true;\n}\nreturn item;\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nprivate:\ntemplate &lt;usize kIndex, typename... PrevItems&gt;\nOptional&lt;Item&gt; peek_impl(std::integral_constant&lt;usize, kIndex&gt;, PrevItems&amp;&amp;... prev_items)\n{\ndecltype(auto) next_item = std::get&lt;kIndex&gt;(this-&gt;seqs_).peek();\nif (!next_item) {\nreturn None;\n}\nreturn this-&gt;peek_impl(std::integral_constant&lt;usize, kIndex + 1&gt;{}, BATT_FORWARD(prev_items)...,\n*BATT_FORWARD(next_item));\n}\ntemplate &lt;typename... AllItems&gt;\nOptional&lt;Item&gt; peek_impl(std::integral_constant&lt;usize, sizeof...(Seqs)&gt;, AllItems&amp;&amp;... all_items)\n{\nreturn Item{BATT_FORWARD(all_items)...};\n}\n//----- --- -- -  -  -   -\ntemplate &lt;usize kIndex, typename... PrevItems&gt;\nOptional&lt;Item&gt; next_impl(std::integral_constant&lt;usize, kIndex&gt;, PrevItems&amp;&amp;... prev_items)\n{\ndecltype(auto) next_item = std::get&lt;kIndex&gt;(this-&gt;seqs_).next();\nif (!next_item) {\nreturn None;\n}\nreturn this-&gt;next_impl(std::integral_constant&lt;usize, kIndex + 1&gt;{}, BATT_FORWARD(prev_items)...,\n*BATT_FORWARD(next_item));\n}\ntemplate &lt;typename... AllItems&gt;\nOptional&lt;Item&gt; next_impl(std::integral_constant&lt;usize, sizeof...(Seqs)&gt;, AllItems&amp;&amp;... all_items)\n{\nreturn Item{BATT_FORWARD(all_items)...};\n}\n//+++++++++++-+-+--+----- --- -- -  -  -   -\nbool done_ = false;\nstd::tuple&lt;Seqs...&gt; seqs_;\n};\ntemplate &lt;typename... OtherSeqs&gt;\nstruct ZipBinder {\nstd::tuple&lt;OtherSeqs...&gt; other_seqs;\n};\ntemplate &lt;typename... OtherSeqs&gt;\nZipBinder&lt;OtherSeqs&amp;&amp;...&gt; zip(OtherSeqs&amp;&amp;... other_seqs)\n{\nreturn {{BATT_FORWARD(other_seqs)...}};\n}\nnamespace detail {\ninline void zip_seqs_static_asserts()\n{\n}\ntemplate &lt;typename First, typename... Rest&gt;\ninline void zip_seqs_static_asserts(StaticType&lt;First&gt;, StaticType&lt;Rest&gt;... rest)\n{\nstatic_assert(std::is_same_v&lt;First, std::decay_t&lt;First&gt;&gt;,\n\"Zipped sequences may not be captured implicitly by reference.\");\nzip_seqs_static_asserts(rest...);\n}\n}  //namespace detail\ntemplate &lt;typename Seq, typename... OtherSeqs&gt;\n[[nodiscard]] Zip&lt;Seq, OtherSeqs...&gt; operator|(Seq&amp;&amp; seq, ZipBinder&lt;OtherSeqs&amp;&amp;...&gt;&amp;&amp; binder)\n{\ndetail::zip_seqs_static_asserts(StaticType&lt;Seq&gt;{}, StaticType&lt;OtherSeqs&gt;{}...);\nreturn std::apply(\n[&amp;](auto&amp;&amp;... other_seqs) {\nreturn Zip&lt;Seq, OtherSeqs...&gt;{BATT_FORWARD(seq), BATT_FORWARD(other_seqs)...};\n},\nstd::move(binder.other_seqs));\n}\n}  //namespace seq\n}  // namespace batt\n#endif  // BATTERIES_SEQ_ZIP_HPP\n</code></pre> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Modules/","title":"Modules","text":"<p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Namespaces/","title":"Namespaces","text":"<ul> <li>namespace batt <ul> <li>namespace constants </li> <li>namespace detail </li> <li>namespace features </li> <li>namespace int_types </li> <li>namespace seq <ul> <li>namespace detail </li> </ul> </li> </ul> </li> <li>namespace batt::@121 </li> <li>namespace batt::@197 </li> <li>namespace batteries </li> <li>namespace boost </li> <li>namespace pico_http <ul> <li>namespace detail </li> </ul> </li> <li>namespace pico_http::detail::@201 </li> <li>namespace std </li> </ul> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt/","title":"batt","text":""},{"location":"_autogen/Namespaces/namespacebatt/#namespaces","title":"Namespaces","text":"Name batt::constants batt::detail batt::features batt::int_types batt::seq"},{"location":"_autogen/Namespaces/namespacebatt/#classes","title":"Classes","text":"Name class batt::BasicRunningTotal struct batt::RetryState struct batt::ExponentialBackoff struct batt::TaskSleepImpl struct batt::DefaultStatusIsRetryableImpl class batt::BasicExecutor class batt::SingleBufferSource Adapts a single ConstBuffer to be a BufferSource. class batt::BufferSource class batt::SeqBufferSource class batt::TakeNSource class batt::FilterBufferSource class batt::MapBufferSource class batt::PrependBufferSource class batt::BufferedChannel class batt::CancelToken Enables effective cancellation of arbitrary async operations. class batt::Channel A Channel is a one-way, unbuffered, SPSC (single-producer, single consumer) communication/synchronization primitive. class batt::AbstractStackAllocator class batt::StackAllocatorImpl class batt::StackAllocator class batt::DebugInfoFrame class batt::BasicFakeExecutor class batt::FakeExecutionContext class batt::FakeTaskScheduler class batt::FakeTimeService class batt::BasicScopedChunk A fetched chunk of data that is automatically consumed (partially or entirely) when it goes out of scope. class batt::Promise An obligation to provide a value of type T to a Future. class batt::Future A value of type T that will be provided at some point in the future. class batt::BasicAbstractHandler A type-erased async completion handler with linked list pointers. class batt::BasicHandlerImpl class batt::UniqueHandler class batt::HandlerBinder class batt::HandlerMemoryBase Abstract base for HandlerMemory. class batt::HandlerMemory A chunk of memory that can be attached to an async completion handler. class batt::HandlerAllocator An allocator associated with a completion handler. class batt::CustomAllocHandler Wrapper for an async completion handler type <code>Handler</code>. class batt::InlineSubTask A scoped asynchronous task with inline stack memory. class batt::IOResult class batt::Latch A write-once, single-value synchronized container. class batt::LazyLatch A write-once, single-value synchronized container that is populated lazily by an init_fn when the value is requested. class batt::BasicMCSMutex A fair mutual exclusion lock based on the MCS lock algorithm. class batt::MutexBase Base class of typed Mutex; implements core logic without any type dependencies. class batt::LockBase class batt::ScopedLock class batt::Mutex Provides mutually-exclusive access to an instance of type <code>T</code>. class batt::Pinnable class batt::Pin class batt::PinnablePtr A raw pointer augmented to support the batt::Pinnable interface, so that a batt::Pin&gt; can be created to block the destruction of the pointer. class batt::PreallocatedTask class batt::PriorityWatch class batt::QueueBase Type-agnostic base class for all Queue types. class batt::Queue Unbounded multi-producer/multi-consumer (MPMC) FIFO queue. class batt::BasicRateLimiter struct batt::DumpReadWriteLockState class batt::BasicReadWriteLock An MCS-style fair reader/writer lock. class batt::ScopedReadWriteLockImpl class batt::ReadWriteMutex Mutex wrapper for a value of type T, providing exclusive read/write access and non-exclusive read-only access. class batt::Runtime class batt::ScalableGrantIssuer A pool from which ScalableGrant instances are allocated. class batt::ScalableGrant A claim on some counted resource. class batt::SimpleExecutionContext A minimal multi-threaded execution context implementation, suitable for parallel-compute thread pools. struct batt::WorkSliceParams struct batt::WorkSlicePlan class batt::SpinGrant A claim on some counted resource. class batt::StreamBuffer class batt::Task A user-space cooperatively scheduled thread of control. class batt::TaskScheduler class batt::NullTaskScheduler class batt::Watch A batt::Watch is like a <code>std::atomic</code> that you can block on, synchronously and asynchronously; see also batt::WatchAtomic. struct batt::HoldOwnership struct batt::ReleaseOwnership class batt::WatchAtomic Watch for atomic primitive type. class batt::Watch&lt; bool &gt; class batt::Watch&lt; i8 &gt; class batt::Watch&lt; i16 &gt; class batt::Watch&lt; i32 &gt; class batt::Watch&lt; i64 &gt; class batt::Watch&lt; u8 &gt; class batt::Watch&lt; u16 &gt; class batt::Watch&lt; u32 &gt; class batt::Watch&lt; u64 &gt; class batt::Watch&lt; void * &gt; class batt::Watch&lt; T * &gt; class batt::WorkContext class batt::ScopedWorkContext class batt::Worker class batt::WorkerPool class batt::ScopedWorkerThreadPool class batt::AtomicCounterGauge An atomic variable that maintains a gauge-like value, which can rise and fall over time, by means of two monotonic counters: one for increases, one for decreases. struct batt::LeastUpperBound struct batt::GreatestLowerBound class batt::ManagedBuffer class batt::BufferViewImpl class batt::ConstBufferView class batt::MutableBufferView class batt::CaseOfVisitor class batt::CpuCacheLineIsolated struct batt::ThreadPoolConfig struct batt::DoNothing struct batt::ByteSwap class batt::FinalAct struct batt::HostAddress class batt::HttpChunkDecoder BufferSource transformer that decodes HTTP chunked content fetched from <code>Src</code>. class batt::HttpClient An HTTP/1.1 client implementation. class batt::DefaultHttpClient A singleton instance of HttpClient; contains an io_context and thread pool (size == 1). class batt::BasicHttpClientConnection class batt::HttpClientHostContext struct batt::HttpData class batt::HttpMessageBase The common base type for HttpRequest and HttpResponse. struct batt::HttpMessageInfo A summary of information about a response message that is necessary for the connection to correctly handle it. class batt::HttpRequest class batt::HttpResponse class batt::HttpServerConnection class batt::HttpServer An HTTP server. struct batt::HttpServerSettings struct batt::HttpVersion class batt::SslTransport An SSL/TLS based transport for HTTPS clients. class batt::TcpTransport A thread-safe socket based TCP connection for HTTP clients. class batt::InstanceCounter A quick and easy way to track the number of instances of a given type in existence; just add batt::InstanceCounter as a field or base class of T. struct batt::IClosedOpen struct batt::IClosed struct batt::BasicInterval A set of totally ordered values, defined by a lower and upper bound. struct batt::IntervalTraits struct batt::IntervalTraitsBase struct batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kFalse, OrderFn, EqualFn &gt; struct batt::IntervalTraits&lt; T, U, InclusiveLowerBound::kTrue, InclusiveUpperBound::kTrue, OrderFn, EqualFn &gt; class batt::CountMetric class batt::LatencyMetric class batt::LatencyTimer class batt::RateMetric class batt::GaugeMetric A Metric collector that stores and reports a single instantaneous value. class batt::StatsMetric Collect count, total, max and min values for multiple samples. class batt::HistogramMetric Collect histogram values for multiple samples. class batt::MetricCsvFormatter class batt::MetricDumper class batt::MetricFormatter class batt::MetricOpenTelemetryFormatter Format metrics into OpenTelemetry data format: {=, ...}  struct batt::MetricLabel class batt::MetricExporter class batt::ScalarMetricExporter Exports a single value metric. class batt::DerivedMetricExporter class batt::VariableExporter class batt::WatchExporter class batt::QueueDepthExporter class batt::MetricRegistry class batt::PrometheusMetricExporter class batt::NoDestruct struct batt::NoneType struct batt::InPlaceInitType class batt::Optional class batt::Optional&lt; T &amp; &gt; struct batt::NoopDeleter class batt::RadixQueue class batt::Ref class batt::BoxedSeq struct batt::IsBoxedSeq struct batt::IsBoxedSeq&lt; BoxedSeq&lt; T &gt; &gt; struct batt::SeqItem_Impl struct batt::SkipNBinder class batt::SkipN class batt::SubRangeSeq struct batt::VecSeqBase class batt::VecSeq class batt::SeqRef struct batt::SharedPtrImpl class batt::SkipNode class batt::SkipNodeBase class batt::SmallFn A type-erased container for a callable function-like object with a statically bounded maximum size. class batt::kAllowAlloc struct batt::StateMachineModelCheckAdvancedOptions class batt::BasicStateMachineEntropySource struct batt::StateMachineBranch class batt::ExhaustiveModelChecker struct batt::StateMachineResult struct batt::StateMachineTraits class batt::StochasticModelChecker class batt::StateMachineModel struct batt::StaticBinaryAssertion struct batt::StaticSameTypeAssertion class batt::StatusOr class batt::Status class batt::StatusOr&lt; Status &gt; class batt::StatusOr&lt; StatusOr&lt; T &gt; &gt; struct batt::RemoveStatusOrImpl struct batt::RemoveStatusOrImpl&lt; StatusOr&lt; T &gt; &gt; struct batt::EscapedStringLiteral struct batt::HexByteDumper struct batt::SizeDumper Wrapper around <code>usize</code> (<code>std::size_t</code>) that prints as human-readable sizes. class batt::RangeDumper class batt::StrongType struct batt::MorphTuple struct batt::MorphTuple&lt; TemplateT, std::tuple&lt; Ts... &gt; &gt; struct batt::TupleIndexOf struct batt::TupleIndexOf&lt; std::tuple&lt;&gt;, T &gt; struct batt::TupleIndexOf&lt; std::tuple&lt; T, Rest... &gt;, T &gt; struct batt::TupleIndexOf&lt; std::tuple&lt; First, Rest... &gt;, T &gt; struct batt::MapTuple struct batt::MapTuple&lt; PerTypeT, std::tuple&lt; Ts... &gt; &gt; class batt::StaticTypeMap Stores a fixed-size set of Value objects, indexed by a set of bounded types (keys). class batt::AbstractValue class batt::AbstractValuePointer class batt::TypeErasedStorageBase class batt::TypeErasedStorage class batt::AbstractValueImpl struct batt::IsVariant struct batt::IsVariant&lt; std::variant&lt; Ts... &gt; &gt; struct batt::IsTuple struct batt::IsTuple&lt; std::tuple&lt; Ts... &gt; &gt; struct batt::StaticType struct batt::StaticValue struct batt::DecayRValueRefImpl struct batt::Difference Type trait that maps subtractable type <code>T</code> to the difference type. struct batt::Difference&lt; unsigned char &gt; struct batt::Difference&lt; unsigned short &gt; struct batt::Difference&lt; unsigned long &gt; struct batt::Difference&lt; unsigned long long &gt; struct batt::Difference&lt; std::pair&lt; A, B &gt; &gt; struct batt::Difference&lt; std::tuple&lt; Ts... &gt; &gt; struct batt::UrlParse struct batt::DefaultInitialized A single type that implicitly converts to any default-constructible type (via batt::make_default())."},{"location":"_autogen/Namespaces/namespacebatt/#types","title":"Types","text":"Name enum StackType { kFixedSize = 0, kProtectedFixedSize = 1, kPooledFixedSize = 2, kMaxValue} enum TransferStep { kNone, kFetch, kWrite} enum int ReadWriteLockQueueNodeClass { kReading = 0, kWriting = 1} enum bool WaitForResource { kFalse = false, kTrue = true} enum i8 BoolStatus { kUnknown = -1, kFalse = 0, kTrue = 1}An enumeration that models boolean (true/false) values plus unknown. enum bool InclusiveLowerBound { kFalse = false, kTrue = true} enum bool InclusiveUpperBound { kFalse = false, kTrue = true} enum i8 Order { Less = -1, Equal = 0, Greater = 1} enum int StatusCode { kOk = 0, kCancelled = 1, kUnknown = 2, kInvalidArgument = 3, kDeadlineExceeded = 4, kNotFound = 5, kAlreadyExists = 6, kPermissionDenied = 7, kResourceExhausted = 8, kFailedPrecondition = 9, kAborted = 10, kOutOfRange = 11, kUnimplemented = 12, kInternal = 13, kUnavailable = 14, kDataLoss = 15, kUnauthenticated = 16, kClosed = 100, kGrantUnavailable = 101, kLoopBreak = 102, kEndOfStream = 103, kClosedBeforeEndOfStream = 104, kGrantRevoked = 105, kPoke = 106} enum ErrnoValue { } enum StdGenericErrorCode { } enum StdFutureErrorCode { } enum StdSystemErrorCode { } enum StdIostreamErrorCode { } enum LogLevel { kFatal, kError, kWarning, kInfo, kDebug, kVerbose} enum Pretty { True, False, Default} using ::batt::StrongType&lt; usize, PartsCount_TAG &gt; PartsCount using ::batt::StrongType&lt; usize, PartSize_TAG &gt; PartSize using BasicRunningTotal&lt; usize &gt; RunningTotal template &lt;typename T &gt; using decltype(detail::has_const_buffer_sequence_requirements_impl&lt; T &gt;(nullptr)) HasConstBufferSequenceRequirements template &lt;typename T &gt; using std::enable_if_t&lt; has_const_buffer_sequence_requirements&lt; T &gt;()&gt; EnableIfConstBufferSequence template &lt;typename T &gt; using decltype(detail::has_buffer_source_requirements_impl&lt; T &gt;(nullptr)) HasBufferSourceRequirements template &lt;typename T &gt; using std::enable_if_t&lt; has_buffer_source_requirements&lt; T &gt;()&gt; EnableIfBufferSource using boost::context::continuation Continuation using ::batt::StrongType&lt; usize, StackSize_TAG &gt; StackSize using BasicFakeExecutor&lt; boost::asio::execution::outstanding_work_t::untracked_t &gt; FakeExecutor using ScalableGrant Grant using boost::intrusive::slist_base_hook&lt; boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt; &gt; DefaultHandlerBase template &lt;typename... Args&gt; using BasicAbstractHandler&lt; DefaultHandlerBase, Args... &gt; AbstractHandler template &lt;typename HandlerFn ,typename... Args&gt; using BasicHandlerImpl&lt; HandlerFn, DefaultHandlerBase, Args... &gt; HandlerImpl template &lt;typename Base ,typename... Args&gt; using boost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Args... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt; &gt; BasicHandlerList template &lt;typename... Args&gt; using BasicHandlerList&lt; DefaultHandlerBase, Args... &gt; HandlerList using boost::system::error_code ErrorCode using BasicMCSMutex&lt; false &gt; MCSMutex using BasicRateLimiter&lt; std::chrono::steady_clock &gt; RateLimiter using BasicReadWriteLock&lt; WatchAtomic &gt; ReadWriteLock template &lt;typename T &gt; using ScopedReadWriteLockImpl&lt; const T, ReadWriteLock::Reader &gt; ScopedReadLock template &lt;typename T &gt; using ScopedReadWriteLockImpl&lt; T, ReadWriteLock::Writer &gt; ScopedWriteLock using BasicExecutor&lt; SimpleExecutionContext, boost::asio::execution::outstanding_work_t::untracked_t, boost::asio::execution::blocking_t::never_t, boost::asio::execution::relationship_t::fork_t &gt; SimpleExecutor using ::batt::StrongType&lt; usize, TaskCount_TAG &gt; TaskCount using ::batt::StrongType&lt; usize, InputSize_TAG &gt; InputSize using ::batt::StrongType&lt; usize, TaskSize_TAG &gt; TaskSize using ::batt::StrongType&lt; usize, TaskIndex_TAG &gt; TaskIndex using ::batt::StrongType&lt; isize, TaskOffset_TAG &gt; TaskOffset using boost::asio::const_buffer ConstBuffer using boost::asio::mutable_buffer MutableBuffer using BasicHttpClientConnection&lt; TcpTransport &gt; HttpClientConnection using BasicHttpClientConnection&lt; SslTransport &gt; HttpsClientConnection using ::batt::StrongType&lt; bool, IncludeHttpTrailer_TAG &gt; IncludeHttpTrailer using ::pico_http::MessageHeader HttpHeader using SmallFn&lt; Status(HttpRequest &amp;request, HttpResponse &amp;response)&gt; HttpRequestDispatcherFn One request dispatcher is created per accepted connection; it is reused in the context of that connection until the connection is closed. using SmallFn&lt; StatusOr&lt; HttpRequestDispatcherFn &gt;()&gt; HttpRequestDispatcherFactoryFn Called once per accepted connection. template &lt;typename T &gt; using BasicInterval&lt; IClosedOpen&lt; T &gt; &gt; Interval A half-open interval (like STL iterator ranges). template &lt;typename T &gt; using BasicInterval&lt; IClosed&lt; T &gt; &gt; CInterval A closed interval. template &lt;typename T &gt; using std::function&lt; T()&gt; DerivedMetric using std::vector&lt; MetricLabel &gt; MetricLabelSet template &lt;typename T &gt; using ScalarMetricExporter&lt; CountMetric&lt; T &gt; &gt; CountMetricExporter Exports a CountMetric. template &lt;typename T &gt; using ScalarMetricExporter&lt; GaugeMetric&lt; T &gt; &gt; GaugeMetricExporter Exports a GaugeMetric. template &lt;typename T &gt; using typename detail::NullableImpl&lt; T &gt;::type Nullable template &lt;typename T &gt; using std::unique_ptr&lt; T, NoopDeleter &gt; UniqueNonOwningPtr using void(*)(std::ostream &amp;) PrintToStreamFunctionPointer template &lt;typename T &gt; using decltype(detail::has_seq_requirements_impl&lt; T &gt;(nullptr)) HasSeqRequirements template &lt;typename T &gt; using std::enable_if_t&lt; has_seq_requirements&lt; T &gt;()&gt; EnableIfSeq template &lt;typename T &gt; using typename SeqItem_Impl&lt; T &gt;::type SeqItem template &lt;typename T &gt; using boost::intrusive_ref_counter&lt; std::decay_t&lt; T &gt; &gt; RefCounted template &lt;typename T &gt; using decltype(detail::is_ref_counted_impl&lt; std::decay_t&lt; T &gt; &gt;(nullptr)) IsRefCounted template &lt;typename T &gt; using typename SharedPtrImpl&lt; T &gt;::type SharedPtr template &lt;typename T &gt; using boost::iterator_range&lt; T * &gt; Slice template &lt;typename Signature ,usize kMaxSize =kCpuCacheLineSize - sizeof(void*),bool kAllowAlloc =false&gt; using SmallFn&lt; Signature, kMaxSize, true, kAllowAlloc &gt; UniqueSmallFn A type-erased container for a move-only callable function-like object. template &lt;typename T ,usize kStaticSize =kDefaultSmallVecSize&gt; using boost::container::small_vector&lt; T, kStaticSize &gt; SmallVec template &lt;typename T &gt; using boost::container::small_vector_base&lt; T &gt; SmallVecBase using BasicStateMachineEntropySource&lt; std::function&lt; usize(usize min_value, usize max_value)&gt; &gt; StateMachineEntropySource template &lt;typename T &gt; using detail::IsStatusOrImpl&lt; std::decay_t&lt; T &gt; &gt; IsStatusOr template &lt;typename T &gt; using typename RemoveStatusOrImpl&lt; std::decay_t&lt; T &gt; &gt;::type RemoveStatusOr using boost::flyweights::flyweight&lt; std::string, boost::flyweights::no_tracking &gt; Token template &lt;template&lt; typename... &gt; class TemplateT,typename TupleT &gt; using typename MorphTuple&lt; TemplateT, std::decay_t&lt; TupleT &gt; &gt;::type MorphTuple_t template &lt;template&lt; typename &gt; class PerTypeT,typename TupleT &gt; using typename MapTuple&lt; PerTypeT, std::decay_t&lt; TupleT &gt; &gt;::type MapTuple_t template &lt;typename Fn ,typename... Args&gt; using decltype(detail::is_callable_impl&lt; Fn, Args... &gt;(nullptr)) IsCallable template &lt;typename T &gt; using decltype(detail::is_printable_impl&lt; T &gt;(nullptr)) IsPrintable template &lt;typename T &gt; using decltype(detail::is_range_impl&lt; T &gt;(nullptr)) IsRange template &lt;typename T ,typename... Args&gt; using std::enable_if_t&lt;!std::is_same&lt; std::tuple&lt; std::decay_t&lt; T &gt; * &gt;, std::tuple&lt; std::decay_t&lt; Args &gt; ... &gt; &gt;{} &amp;&amp;!std::is_same&lt; std::tuple&lt;&gt;, std::tuple&lt; std::decay_t&lt; Args &gt; ... &gt; &gt;{} &gt; EnableIfNoShadow template &lt;typename T &gt; using typename DecayRValueRefImpl&lt; T &gt;::type DecayRValueRef template &lt;typename T ,typename U  =T&gt; using decltype(detail::can_be_eq_compared_helper&lt; T, U &gt;(nullptr, nullptr)) CanBeEqCompared template &lt;typename T &gt; using decltype(unwrap_ref(std::declval&lt; T &gt;())) UnwrapRefType"},{"location":"_autogen/Namespaces/namespacebatt/#functions","title":"Functions","text":"Name template &lt;typename Iter ,typename T ,typename BinaryOp &gt; Slice&lt; T &gt; parallel_accumulate_partial(WorkContext &amp; context, Iter first, Iter last, T init, const BinaryOp &amp; binary_op, T identity, const Slice&lt; T &gt; &amp; task_result_buffer, const WorkSliceParams &amp; params) template &lt;typename Iter ,typename T ,typename BinaryOp &gt; T parallel_accumulate(WorkerPool &amp; worker_pool, Iter first, Iter last, T init, const BinaryOp &amp; binary_op, T identity, TaskSize min_task_size =TaskSize{4096}, TaskCount max_tasks =TaskCount{std::thread::hardware_concurrency()}) template &lt;typename Src ,typename Dst &gt; void parallel_copy(WorkContext &amp; work_context, Src src_begin, Src src_end, Dst dst_begin, TaskSize min_task_size, TaskCount max_tasks) template &lt;typename Src0 ,typename Src1 ,typename Dst ,typename Compare &gt; void parallel_merge(WorkerPool &amp; worker_pool, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare &amp;&amp; compare, usize min_task_size =1400, usize max_tasks =std::thread::hardware_concurrency()/2) template &lt;typename Src0 ,typename Src1 ,typename Dst ,typename Compare &gt; void parallel_merge(WorkContext &amp; context, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare &amp;&amp; compare, usize min_task_size =1400, usize max_tasks =std::thread::hardware_concurrency()/2) template &lt;typename Iter ,typename Fn ,typename ValueT  =std::decay_t::reference&gt;&gt;&gt; BasicRunningTotal&lt; ValueT &gt; parallel_running_total(WorkerPool &amp; worker_pool, Iter first, Iter last, const Fn &amp; fn, const WorkSliceParams &amp; params) template &lt;typename Iter ,typename ValueT  =typename std::iterator_traits::value_type&gt; BasicRunningTotal&lt; ValueT &gt; parallel_running_total(WorkerPool &amp; worker_pool, Iter first, Iter last, const WorkSliceParams &amp; params) template &lt;typename Src ,typename Dst ,typename TransformFn &gt; void parallel_transform(WorkContext &amp; work_context, Src src_begin, Src src_end, Dst dst_begin, const TransformFn &amp; transform_fn, TaskSize min_task_size, TaskCount max_tasks) constexpr usize strong_typedef_default_value(PartsCount_TAG * ) constexpr usize strong_typedef_default_value(PartSize_TAG * ) void fail_check_exit() std::atomic&lt; bool &gt; &amp; fail_check_exit_entered() std::atomic&lt; bool &gt; &amp; fail_check_spin_lock() template &lt;typename... Ts&gt; bool ignore(Ts &amp;&amp; ...) bool lock_fail_check_mutex() template &lt;typename BodyFn  =void(),typename... TaskArgsAndHandler&gt; Task * async_run_task(const boost::asio::any_io_executor &amp; ex, StackSize stack_byte_size, BodyFn &amp;&amp; body_fn, TaskArgsAndHandler &amp;&amp;... task_args_and_handler)Creates and starts (default) a new batt::Task, the memory for which (including stack) is allocated as a single contiguous memory region using the allocated associated with the final arg passed to this function, the completion handler. template &lt;typename RetryPolicy ,typename ActionFn ,typename Result  =std::invoke_result_t,typename SleepImpl  =TaskSleepImpl,typename StatusIsRetryableImpl  =DefaultStatusIsRetryableImpl&gt; Result with_retry_policy(RetryPolicy &amp;&amp; policy, std::string_view action_name, ActionFn &amp;&amp; action_fn, SleepImpl &amp;&amp; sleep_impl ={}, StatusIsRetryableImpl &amp;&amp; status_is_retryable_impl ={}) void update_retry_state(RetryState &amp; state, const ExponentialBackoff &amp; policy) template &lt;typename T &gt; constexpr bool has_const_buffer_sequence_requirements(StaticType&lt; T &gt;  ={}) template &lt;typename T &gt; constexpr bool has_buffer_source_requirements(StaticType&lt; T &gt;  ={}) template &lt;typename Src ,typename  =EnableIfBufferSource&gt; TakeNSource&lt; Src &gt; **[operator template &lt;typename Src ,typename  =EnableIfBufferSource&gt; void **[operator template &lt;typename Src ,typename Fn ,typename  =EnableIfBufferSource&gt; StatusOr&lt; seq::LoopControl &gt; **[operator template &lt;typename Src ,typename  =EnableIfBufferSource&gt; StatusOr&lt; std::vector&lt; char &gt; &gt; **[operator template &lt;typename Src ,typename  =EnableIfBufferSource&gt; Status **[operator template &lt;typename Src ,typename  =EnableIfBufferSource&gt; Status **[operator template &lt;typename Src ,typename AsyncWriteStream ,typename  =EnableIfBufferSource&gt; StatusOr&lt; usize &gt; **[operator template &lt;typename Src ,typename ConstBufferSequence ,typename  =EnableIfBufferSource,typename  =EnableIfConstBufferSequence&gt; auto **[operator usize hash_value(const CancelToken &amp; cancel_token)CancelToken is hashed by its impl pointer. bool operator==(const CancelToken &amp; l, const CancelToken &amp; r)Returns true iff the two objects are copies of the same CancelToken. bool operator!=(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&lt;(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&gt;(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&lt;=(const CancelToken &amp; l, const CancelToken &amp; r) bool operator&gt;=(const CancelToken &amp; l, const CancelToken &amp; r) template &lt;typename T &gt; bool is_cancelled(const CancelToken::HandlerImpl&lt; T &gt; &amp; handler) template &lt;typename T &gt; bool is_cancelled(const CustomAllocHandler&lt; CancelToken::HandlerImpl&lt; T &gt;&gt; &amp; handler) BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion&lt; decltype(sizeof(void ) 2), decltype(sizeof(boost::context::stack_context)),(sizeof(void ) 2), ::batt::Eq,(sizeof(boost::context::stack_context)),((sizeof(void ) 2)==(sizeof(boost::context::stack_context)))&gt; BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, LINE) , COUNTER ) constexpr usize strong_typedef_default_value(StackSize_TAG * ) template &lt;typename T &gt; const StackAllocator &amp; get_stack_allocator_with_type(StackSize stack_size) const StackAllocator &amp; get_stack_allocator(StackSize stack_size, StackType stack_type) template &lt;typename Fn &gt; Continuation callcc(StackAllocator &amp;&amp; stack_allocator, Fn &amp;&amp; fn) template &lt;typename Fn &gt; Continuation callcc(StackSize stack_size, StackType stack_type, Fn &amp;&amp; fn) void this_task_debug_info(std::ostream &amp; out) void print_debug_info(DebugInfoFrame * p, std::ostream &amp; out) void print_all_threads_debug_info(std::ostream &amp; out) const char * shortened_source_file(const char * raw) bool enable_dump_tasks() template &lt;typename OutstandingWorkP &gt; constexpr bool operator==(const BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; l, const BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; r) template &lt;typename OutstandingWorkP &gt; constexpr bool operator!=(const BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; l, const BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; r) bool operator&lt;(const FakeTimeService::TimerInstance &amp; l, const FakeTimeService::TimerInstance &amp; r) bool operator&gt;(const FakeTimeService::TimerInstance &amp; l, const FakeTimeService::TimerInstance &amp; r) bool operator&lt;=(const FakeTimeService::TimerInstance &amp; l, const FakeTimeService::TimerInstance &amp; r) bool operator&gt;=(const FakeTimeService::TimerInstance &amp; l, const FakeTimeService::TimerInstance &amp; r) template &lt;typename AsyncFetchStreamT ,typename ScopedChunk  =BasicScopedChunk,typename ConstBufferSequence  =typename AsyncFetchStreamT::const_buffers_type&gt; batt::StatusOr&lt; ScopedChunk &gt; fetch_chunk(AsyncFetchStreamT &amp; stream, usize min_size)Awaits the result of an async_fetch on the passed stream with the given minimum chunk size. template &lt;typename From ,typename To &gt; StatusOr&lt; usize &gt; transfer_chunked_data(From &amp; from, To &amp; to, TransferStep &amp; step) template &lt;typename From ,typename To &gt; StatusOr&lt; usize &gt; transfer_chunked_data(From &amp; from, To &amp; to)Fetches data from the first arg and writes it to the second arg, until an error or end-of-file/stream occurs. int futex_wait(std::atomic&lt; u32 &gt; * , u32 ) int futex_notify(std::atomic&lt; u32 &gt; * , u32  =1) void spin_yield() template &lt;typename T &gt; Future&lt; T &gt; get_future(const Promise&lt; T &gt; &amp; promise)Returns the Future object corresponding to the Promise. BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion&lt; decltype(sizeof(UniqueHandler&lt;&gt;)), decltype(sizeof(void )),(sizeof(UniqueHandler&lt;&gt;)), ::batt::Eq,(sizeof(void )),((sizeof(UniqueHandler&lt;&gt;))==(sizeof(void *)))&gt; BOOST_PP_CAT(BOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, LINE) , COUNTER ) template &lt;typename Base ,typename... Args&gt; void push_handler_prealloc(boost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Args... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt;&gt; * list, BasicAbstractHandler&lt; Base, Args... &gt; * handler) template &lt;typename... Args,typename Base ,typename HandlerFn &gt; void push_handler(boost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Args... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt;&gt; * list, HandlerFn &amp;&amp; fn) template &lt;typename... Params,typename... Args,typename Base &gt; void invoke_all_handlers(boost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Params... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt;&gt; * handlers, Args &amp;&amp;... args) template &lt;typename InnerFn ,typename OuterFn &gt; HandlerBinder&lt; std::decay_t&lt; InnerFn &gt;, std::decay_t&lt; OuterFn &gt; &gt; bind_handler(InnerFn &amp;&amp; inner, OuterFn &amp;&amp; outer) template &lt;typename T ,typename U &gt; bool operator==(const HandlerAllocator&lt; T &gt; &amp; left, const HandlerAllocator&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator!=(const HandlerAllocator&lt; T &gt; &amp; left, const HandlerAllocator&lt; U &gt; &amp; right) template &lt;typename Handler &gt; CustomAllocHandler&lt; std::decay_t&lt; Handler &gt; &gt; make_custom_alloc_handler(HandlerMemoryBase &amp; m, Handler &amp;&amp; h)Helper function to wrap a handler object to add custom allocation. template &lt;typename Handler ,typename... Args&gt; void post_handler(Handler &amp;&amp; handler, Args &amp;&amp;... args)Posts a handler using its associated executor, binding its arguments. template &lt;typename... Ts&gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const IOResult&lt; Ts... &gt; &amp; t) template &lt;typename... Ts&gt; bool is_ok_status(const IOResult&lt; Ts... &gt; &amp; io_result) bool is_ok_status(const ErrorCode &amp; ec) template &lt;typename... Ts&gt; Status to_status(const IOResult&lt; Ts... &gt; &amp; io_result) template &lt;typename T &gt; void pin_object(T * object) template &lt;typename T &gt; void unpin_object(T * object) template &lt;typename T &gt; Pin&lt; T &gt; make_pin(T * object) template &lt;typename T ,typename U &gt; bool operator==(const Pin&lt; T &gt; &amp; l, const Pin&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const Pin&lt; T &gt; &amp; l, const Pin&lt; U &gt; &amp; r) template &lt;typename T &gt; bool operator==(const Pin&lt; T &gt; &amp; l, std::nullptr_t ) template &lt;typename T &gt; bool operator!=(const Pin&lt; T &gt; &amp; l, std::nullptr_t ) template &lt;typename U &gt; bool operator==(std::nullptr_t , const Pin&lt; U &gt; &amp; r) template &lt;typename U &gt; bool operator!=(std::nullptr_t , const Pin&lt; U &gt; &amp; r) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const DumpReadWriteLockState &amp; dump) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, ReadWriteLockQueueNodeClass t) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const ScalableGrant &amp; t) constexpr usize strong_typedef_default_value(TaskCount_TAG * ) constexpr usize strong_typedef_default_value(InputSize_TAG * ) constexpr usize strong_typedef_default_value(TaskSize_TAG * ) constexpr usize strong_typedef_default_value(TaskIndex_TAG * ) constexpr isize strong_typedef_default_value(TaskOffset_TAG * ) template &lt;typename Iter &gt; InputSize get_input_size(const Iter &amp; first, const Iter &amp; last) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const WorkSliceParams &amp; t) TaskSize get_task_size(const WorkSliceParams &amp; params, InputSize input_size) TaskCount get_task_count(InputSize input_size, TaskSize task_size) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const WorkSlicePlan &amp; t) template &lt;typename WorkFnGenerator &gt; Status slice_work(WorkContext &amp; context, const WorkSlicePlan &amp; plan, WorkFnGenerator &amp;&amp; gen_work_fn) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const SpinGrant &amp; t) template &lt;typename T &gt; StatusOr&lt; std::reference_wrapper&lt; StreamBuffer &gt; &gt; operator&lt;&lt;(StatusOr&lt; std::reference_wrapper&lt; StreamBuffer &gt;&gt; stream_buffer, T &amp;&amp; obj) i32 next_thread_id()Returns the lowest unused global thread id number; repeated calls to <code>next_thread_id()</code> will return monotonically increasing values. i32 &amp; this_thread_id()Returns a reference to the thread-local id for the current thread. std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, WaitForResource t) template &lt;typename T &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Watch&lt; T &gt; &amp; w)Support for printing Watch to ostream. template &lt;typename T &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const WatchAtomic&lt; T &gt; &amp; w)Support for printing WatchAtomic to ostream. constexpr BoolStatus bool_status_from(bool b)Constructs a BoolStatus value from a bool. constexpr BoolStatus **[operator constexpr BoolStatus operator&amp;&amp;(BoolStatus left, BoolStatus right)Performs a logical-and (conjunction) between two BoolStatus values. constexpr BoolStatus operator!(BoolStatus b)Performs a logical-not (negation) for the given BoolStatus value. std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const BoolStatus &amp; t)Prints a BoolStatus value. i8 least_upper_bound(i8 n) i8 greatest_lower_bound(i8 n) i16 least_upper_bound(i16 n) i16 greatest_lower_bound(i16 n) i32 least_upper_bound(i32 n) i32 greatest_lower_bound(i32 n) i64 least_upper_bound(i64 n) i64 greatest_lower_bound(i64 n) u8 least_upper_bound(u8 n) u8 greatest_lower_bound(u8 n) u16 least_upper_bound(u16 n) u16 greatest_lower_bound(u16 n) u32 least_upper_bound(u32 n) u32 greatest_lower_bound(u32 n) u64 least_upper_bound(u64 n) u64 greatest_lower_bound(u64 n) template &lt;typename T &gt; LeastUpperBound&lt; std::decay_t&lt; T &gt; &gt; least_upper_bound(T &amp;&amp; value) template &lt;typename T ,typename U &gt; bool operator&lt;(const T &amp; left, const LeastUpperBound&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator&lt;(const LeastUpperBound&lt; T &gt; &amp; left, const U &amp; right) template &lt;typename T ,typename U &gt; bool operator&lt;(const LeastUpperBound&lt; T &gt; &amp; left, const LeastUpperBound&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator==(const T &amp; , const LeastUpperBound&lt; U &gt; &amp; ) template &lt;typename T ,typename U &gt; bool operator==(const LeastUpperBound&lt; T &gt; &amp; , const U &amp; ) template &lt;typename T ,typename U &gt; bool operator==(const LeastUpperBound&lt; T &gt; &amp; left, const LeastUpperBound&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator&gt;(const T &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&lt;=(const T &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;=(const T &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;(const LeastUpperBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator&lt;=(const LeastUpperBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;=(const LeastUpperBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;(const LeastUpperBound&lt; T &gt; &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&lt;=(const LeastUpperBound&lt; T &gt; &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;=(const LeastUpperBound&lt; T &gt; &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const T &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const LeastUpperBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const LeastUpperBound&lt; T &gt; &amp; l, const LeastUpperBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; GreatestLowerBound&lt; std::decay_t&lt; T &gt; &gt; greatest_lower_bound(T &amp;&amp; value) template &lt;typename T ,typename U &gt; bool operator&lt;(const T &amp; left, const GreatestLowerBound&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator&lt;(const GreatestLowerBound&lt; T &gt; &amp; left, const U &amp; right) template &lt;typename T ,typename U &gt; bool operator&lt;(const GreatestLowerBound&lt; T &gt; &amp; left, const GreatestLowerBound&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator==(const T &amp; , const GreatestLowerBound&lt; U &gt; &amp; ) template &lt;typename T ,typename U &gt; bool operator==(const GreatestLowerBound&lt; T &gt; &amp; , const U &amp; ) template &lt;typename T ,typename U &gt; bool operator==(const GreatestLowerBound&lt; T &gt; &amp; left, const GreatestLowerBound&lt; U &gt; &amp; right) template &lt;typename T ,typename U &gt; bool operator&gt;(const T &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&lt;=(const T &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;=(const T &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;(const GreatestLowerBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator&lt;=(const GreatestLowerBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;=(const GreatestLowerBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;(const GreatestLowerBound&lt; T &gt; &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&lt;=(const GreatestLowerBound&lt; T &gt; &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator&gt;=(const GreatestLowerBound&lt; T &gt; &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const T &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const GreatestLowerBound&lt; T &gt; &amp; l, const U &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const GreatestLowerBound&lt; T &gt; &amp; l, const GreatestLowerBound&lt; U &gt; &amp; r) template &lt;typename... Args&gt; decltype(auto) make_buffer(Args &amp;&amp;... args) template &lt;typename T &gt; ConstBuffer buffer_from_struct(const T &amp; val) std::string_view as_str(const ConstBuffer &amp; buffer)Converts a ConstBuffer into an equivalent std::string_view. template &lt;typename T &gt; std::string_view bytes_from_struct(const T &amp; val)Returns a std::string_view with the same size and data address as the passed object, as if the address of <code>val</code> had been reinterpret_cast to type <code>const char*</code>. template &lt;typename T &gt; MutableBuffer mutable_buffer_from_struct(T &amp; val) ConstBuffer resize_buffer(const ConstBuffer &amp; b, usize s) MutableBuffer resize_buffer(const MutableBuffer &amp; b, usize s) template &lt;typename SizeT &gt; ConstBuffer slice_buffer(const ConstBuffer &amp; b, const Interval&lt; SizeT &gt; &amp; slice)Select a subset of the passed buffer according to the passed interval. template &lt;typename SizeT &gt; MutableBuffer slice_buffer(const MutableBuffer &amp; b, const Interval&lt; SizeT &gt; &amp; slice)Select a subset of the passed buffer according to the passed interval. template &lt;typename VecT &gt; void consume_buffers(VecT &amp; buffers, usize count) template &lt;typename Iter &gt; std::pair&lt; Iter, usize &gt; consume_buffers_iter(const std::pair&lt; Iter, usize &gt; &amp; pos, const Iter &amp; last, usize count) template &lt;typename VecT &gt; VecT consume_buffers_copy(const VecT &amp; buffers, usize count) template &lt;usize kLength,usize... kIndex&gt; constexpr std::array&lt; char, kLength - 1 &gt; array_from_c_str(const char(&amp;) c_str[kLength], std::index_sequence&lt; kIndex... &gt; )Converts a compile-time string constant to std::array, automatically inferring the string length (without the null-terminator). template &lt;usize kLength&gt; constexpr std::array&lt; char, kLength - 1 &gt; array_from_c_str(const char(&amp;) c_str[kLength])Converts a compile-time string constant to std::array, automatically inferring the string length (without the null-terminator). ConstBuffer as_const_buffer(const ConstBuffer &amp; buffer) ConstBuffer as_const_buffer(const MutableBuffer &amp; buffer) ConstBuffer as_const_buffer(const std::string_view &amp; str) ConstBuffer as_const_buffer(const std::string &amp; str) template &lt;usize kSize&gt; ConstBuffer as_const_buffer(const std::array&lt; char, kSize &gt; &amp; arr) template &lt;usize kSize&gt; ConstBuffer as_const_buffer(const std::array&lt; u8, kSize &gt; &amp; arr) ConstBuffer as_const_buffer(const std::vector&lt; char &gt; &amp; vec) ConstBuffer as_const_buffer(const std::vector&lt; u8 &gt; &amp; vec) ConstBuffer as_const_buffer(const SmallVecBase&lt; char &gt; &amp; vec) ConstBuffer as_const_buffer(const SmallVecBase&lt; u8 &gt; &amp; vec) template &lt;usize kLength&gt; ConstBuffer as_const_buffer(const char(&amp;) c_str[kLength]) template &lt;typename... Cases&gt; CaseOfVisitor&lt; Cases &amp;&amp;... &gt; make_case_of_visitor(Cases &amp;&amp;... cases)Constructs and returns a single overloaded callable function object that forwards its arguments on to the first object in <code>cases</code> that is callable with those arguments. template &lt;typename VarType ,typename... Cases&gt; decltype(auto) case_of(VarType &amp;&amp; v, Cases &amp;&amp;... cases)Matches a variant against a list of callables and apply the first one that will accept the current value. template &lt;typename T ,typename Var &gt; bool is_case(Var &amp;&amp; v) template &lt;typename ToType ,typename FromType ,typename  =std::enable_if_t == std::is_signed_v\\&gt;&gt; ToType checked_cast(FromType val, const char * file =\"\", int line =0) template &lt;typename ToType ,typename FromType ,typename  =std::enable_if_t &amp;&amp; !std::is_signed_v\\&gt;,typename  =void&gt; ToType checked_cast(FromType val, const char * file =\"\", int line =0) template &lt;typename ToType ,typename FromType ,typename  =std::enable_if_t&lt;!std::is_signed_v &amp;&amp; std::is_signed_v&gt;,typename  =void,typename  =void&gt; ToType checked_cast(FromType val, const char * file =\"\", int line =0) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, Order t) Order compare(const std::string_view &amp; a, const std::string_view &amp; b) template &lt;typename T &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const CpuCacheLineIsolated&lt; T &gt; &amp; t) Status pin_thread_to_cpu(usize cpu_i) template &lt;typename IntRange &gt; Status pin_thread_to_cpu_set(const IntRange &amp; cpu_i_set) Status pin_thread_i_of_config(usize i, const ThreadPoolConfig &amp; config, const std::string_view &amp; pool_name =\"\") template &lt;typename... Args&gt; constexpr void do_nothing(Args &amp;&amp; ...) bool big_endian_less_than(BOOST_PP_CAT(u, 16) a, BOOST_PP_CAT(u, 16) b) bool big_endian_less_than(BOOST_PP_CAT(u, 32) a, BOOST_PP_CAT(u, 32) b) bool big_endian_less_than(BOOST_PP_CAT(u, 64) a, BOOST_PP_CAT(u, 64) b) template &lt;typename T &gt; Optional&lt; T &gt; getenv_as(const char * var_name)Parse environment variable as a given type <code>T</code>. template &lt;typename Fn &gt; auto finally(Fn &amp;&amp; fn) usize hash() template &lt;typename T &gt; usize hash(T &amp;&amp; obj) template &lt;typename T ,typename HashT  =typename std::decay_t::Hash&gt; usize hash_value(T &amp;&amp; obj) template &lt;typename First ,typename... Rest&gt; usize hash(First &amp;&amp; first, Rest &amp;&amp;... rest) StatusOr&lt; SmallVec&lt; boost::asio::ip::tcp::endpoint &gt; &gt; await_resolve(boost::asio::ip::tcp::resolver &amp; resolver, const HostAddress &amp; host_address) StatusOr&lt; SmallVec&lt; boost::asio::ip::tcp::endpoint &gt; &gt; await_resolve(boost::asio::io_context &amp; io, const HostAddress &amp; host_address) usize hash_value(const HostAddress &amp; host_key) bool operator==(const HostAddress &amp; l, const HostAddress &amp; r) bool operator!=(const HostAddress &amp; l, const HostAddress &amp; r) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const HostAddress &amp; t) template &lt;typename Src ,typename AsyncWriteStream &gt; Status http_encode_chunked(Src &amp;&amp; src, AsyncWriteStream &amp;&amp; dst, IncludeHttpTrailer include_trailer =IncludeHttpTrailer{false}) template &lt;typename... Params&gt; StatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_request(std::string_view method, std::string_view url, Params &amp;&amp;... params)Submits an HTTP request, returning the response object. template &lt;typename... Params&gt; StatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_get(std::string_view url, Params &amp;&amp;... params) template &lt;typename... Params&gt; StatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_post(std::string_view url, Params &amp;&amp;... params) template &lt;typename... Params&gt; StatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_put(std::string_view url, Params &amp;&amp;... params) template &lt;typename... Params&gt; StatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_delete(std::string_view url, Params &amp;&amp;... params) constexpr bool strong_typedef_default_value(IncludeHttpTrailer_TAG * ) Optional&lt; std::string_view &gt; find_header(const SmallVecBase&lt; HttpHeader &gt; &amp; headers, const std::string_view &amp; name) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const HttpMessageInfo &amp; t) template &lt;typename TraitsT ,typename DeltaT &gt; BasicInterval&lt; TraitsT &gt; push_back(const BasicInterval&lt; TraitsT &gt; &amp; i, DeltaT delta) template &lt;typename TraitsT ,typename DeltaT &gt; BasicInterval&lt; TraitsT &gt; push_front(const BasicInterval&lt; TraitsT &gt; &amp; i, DeltaT delta) template &lt;typename TraitsT ,typename DeltaT &gt; BasicInterval&lt; TraitsT &gt; pop_back(const BasicInterval&lt; TraitsT &gt; &amp; i, DeltaT delta) template &lt;typename TraitsT ,typename DeltaT &gt; BasicInterval&lt; TraitsT &gt; pop_front(const BasicInterval&lt; TraitsT &gt; &amp; i, DeltaT delta) template &lt;typename T ,typename U &gt; BasicInterval&lt; IClosedOpen&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; U &gt; &gt; &gt; make_interval(T &amp;&amp; lower, U &amp;&amp; upper) template &lt;typename TraitsL ,typename TraitsR &gt; bool operator==(const BasicInterval&lt; TraitsL &gt; &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) template &lt;typename TraitsL ,typename TraitsR &gt; bool operator!=(const BasicInterval&lt; TraitsL &gt; &amp; l, const BasicInterval&lt; TraitsR &gt; &amp; r) template &lt;typename Traits &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const BasicInterval&lt; Traits &gt; &amp; t) template &lt;typename Traits0 ,typename Traits1 &gt; constexpr bool interval_traits_compatible() template &lt;typename T ,typename  =std::enable_if_t{}&gt;&gt; decltype(auto) make_printable(T &amp;&amp; obj)Returns a std::ostream-printable representation of the argument, <code>obj</code>. template &lt;typename T ,typename  =std::enable_if_t&lt;!IsPrintable{}&gt;,typename  =void&gt; std::string make_printable(T &amp;&amp; obj)Returns a std::ostream-printable representation of the argument, <code>obj</code>. constexpr i32 log2_ceil(u64 i)Returns log_2(i), rounded down to the nearest integer. constexpr i32 log2_floor(u64 i)Returns log_2(i), rounded down to the nearest integer. template &lt;typename IntT &gt; constexpr IntT lsb_mask(i32 bits)Least Significant Bits Mask. template &lt;typename IntT &gt; constexpr IntT round_down_bits(i32 bits, IntT n)Rounds an integer value down to the nearest multiple of 2^bits. template &lt;typename IntT &gt; constexpr IntT round_up_bits(i32 bits, IntT n)Rounds an integer value up to the nearest multiple of 2^bits. template &lt;typename IntT &gt; constexpr IntT round_down_to(IntT unit, IntT n)Rounds <code>n</code> down to the nearest multiple of <code>unit</code>. template &lt;typename IntT &gt; constexpr IntT round_up_to(IntT unit, IntT n)Rounds <code>n</code> up to the nearest multiple of <code>unit</code>. template &lt;typename IntT &gt; constexpr IntT ipow(IntT base, IntT exponent, IntT accumulator =static_cast&lt; IntT &gt;(1))Compile-time integer exponentiation. i32 bit_count(u64 n)Returns the number of set (1) bits in the passed integer. std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const LatencyMetric &amp; t) MetricLabelSet normalize_labels(MetricLabelSet &amp;&amp; labels) MetricRegistry &amp; global_metric_registry() template &lt;typename T &gt; auto make_nullable(T &amp;&amp; obj) bool operator==(const NoneType &amp; , const NoneType &amp; ) bool operator!=(const NoneType &amp; , const NoneType &amp; ) template &lt;typename T0 ,typename T1 &gt; bool operator==(const Optional&lt; T0 &gt; &amp; v0, const Optional&lt; T1 &gt; &amp; v1) template &lt;typename T0 ,typename T1 &gt; bool operator!=(const Optional&lt; T0 &gt; &amp; v0, const Optional&lt; T1 &gt; &amp; v1) template &lt;typename T0 ,typename T1 &gt; bool operator==(const Optional&lt; T0 &gt; &amp; v0, const T1 &amp; v1) template &lt;typename T0 ,typename T1 &gt; bool operator!=(const Optional&lt; T0 &gt; &amp; v0, const T1 &amp; v1) template &lt;typename T0 ,typename T1 &gt; bool operator==(const T0 &amp; v0, const Optional&lt; T1 &gt; &amp; v1) template &lt;typename T0 ,typename T1 &gt; bool operator!=(const T0 &amp; v0, const Optional&lt; T1 &gt; &amp; v1) template &lt;typename T &gt; bool operator==(NoneType , const Optional&lt; T &gt; &amp; v) template &lt;typename T &gt; bool operator!=(NoneType , const Optional&lt; T &gt; &amp; v) template &lt;typename T &gt; bool operator==(const Optional&lt; T &gt; &amp; v, NoneType ) template &lt;typename T &gt; bool operator!=(const Optional&lt; T &gt; &amp; v, NoneType ) template &lt;typename T &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Optional&lt; T &gt; &amp; t) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const NoneType &amp; ) template &lt;typename T &gt; Optional&lt; std::decay_t&lt; T &gt; &gt; make_optional(T &amp;&amp; val) template &lt;typename T &gt; decltype(auto) get_or_panic(Optional&lt; T &gt; &amp; opt) template &lt;typename T &gt; decltype(auto) get_or_panic(const Optional&lt; T &gt; &amp; opt) template &lt;typename T &gt; decltype(auto) get_or_panic(Optional&lt; T &gt; &amp;&amp; opt) template &lt;usize N_&gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const RadixQueue&lt; N_ &gt; &amp; t) template &lt;typename T &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Ref&lt; T &gt; &amp; t) template &lt;typename T &gt; Ref&lt; T &gt; as_ref(T &amp; obj_ref) template &lt;typename T &gt; Ref&lt; const T &gt; as_cref(const T &amp; obj_ref) template &lt;typename T &gt; Ref&lt; T &gt; into_ref(T * ptr) template &lt;typename T &gt; Ref&lt; const T &gt; into_cref(const T * ptr) template &lt;typename T &gt; decltype(auto) unwrap_ref(Ref&lt; T &gt; &amp; wrapper) template &lt;typename T &gt; decltype(auto) unwrap_ref(Ref&lt; T &gt; const &amp; wrapper) template &lt;typename T &gt; decltype(auto) unwrap_ref(Ref&lt; T &gt; &amp;&amp; wrapper) template &lt;typename T &gt; decltype(auto) unwrap_ref(Ref&lt; T &gt; const &amp;&amp; wrapper) std::atomic&lt; PrintToStreamFunctionPointer &gt; &amp; extra_segv_debug_info_callback() void print_stack_trace() bool &amp; print_stack_trace_atexit_enabled() void print_stack_trace_atexit() template &lt;typename T &gt; constexpr bool has_seq_requirements(StaticType&lt; T &gt;  ={}) SkipNBinder skip_n(usize n) template &lt;typename Seq ,typename  =EnableIfSeq&gt; SkipN&lt; Seq &gt; **[operator template &lt;typename T ,typename  =decltype(std::declval().front()),typename  =decltype(std::declval().drop_front())&gt; SubRangeSeq&lt; T &gt; as_seq(T &amp;&amp; sub_range) template &lt;typename ForwardIter &gt; auto as_seq(ForwardIter &amp;&amp; begin, ForwardIter &amp;&amp; end) template &lt;typename VectorLike ,typename  =decltype(std::declval().data()),typename  =decltype(std::declval().size())&gt; auto as_seq(VectorLike &amp;&amp; v) template &lt;typename T ,typename Begin  =decltype(std::declval().data()),typename End  =decltype(std::declval() + std::declval().size()),typename  =std::enable_if_t&gt;&gt; auto vec_range(const T &amp; vec) template &lt;typename T &gt; auto into_seq(std::vector&lt; T &gt; &amp;&amp; v) template &lt;typename SeqT &gt; SeqRef&lt; SeqT &gt; seq_ref(SeqT &amp; seq) template &lt;typename T ,typename... Args,typename  =std::enable_if_t{}&gt;&gt; SharedPtr&lt; T &gt; make_shared(Args &amp;&amp;... args) template &lt;typename T ,typename... Args,typename  =std::enable_if_t&lt;!IsRefCounted{}&gt;,typename  =void&gt; SharedPtr&lt; T &gt; make_shared(Args &amp;&amp;... args) template &lt;typename T &gt; SharedPtr&lt; T &gt; into_shared(std::unique_ptr&lt; T &gt; &amp;&amp; ptr) template &lt;typename T ,typename  =std::enable_if_t&lt;                          std::is_same_v, std::shared_ptr\\&gt;&gt;&gt;&gt; SharedPtr&lt; T &gt; shared_ptr_from(T * that) template &lt;typename T ,typename  =std::enable_if_t&lt;              std::is_same_v, boost::intrusive_ptr\\&gt;&gt;&gt;,typename  =void&gt; SharedPtr&lt; T &gt; shared_ptr_from(T * that) template &lt;typename T ,typename DataT  =decltype(std::declval().data()),typename  =std::enable_if_t&gt;,typename ElementT  =typename std::pointer_traits::element_type&gt; Slice&lt; ElementT &gt; as_slice(T &amp;&amp; container) template &lt;typename ElementT &gt; Slice&lt; ElementT &gt; as_slice(ElementT * begin, ElementT * end) template &lt;typename ElementT &gt; Slice&lt; ElementT &gt; as_slice(ElementT * begin, usize size) template &lt;typename ElementT &gt; Slice&lt; ElementT &gt; as_slice(const Slice&lt; ElementT &gt; &amp; slice) template &lt;typename ElementT &gt; Slice&lt; const ElementT &gt; as_const_slice(const ElementT * begin, const ElementT * end) template &lt;typename ElementT &gt; Slice&lt; const ElementT &gt; as_const_slice(const ElementT * begin, usize size) template &lt;typename T ,typename DataT  =decltype(std::declval().data()),typename  =std::enable_if_t&gt;,typename ElementT  =typename std::pointer_traits::element_type&gt; Slice&lt; const ElementT &gt; as_const_slice(const T &amp; container) template &lt;typename ElementT &gt; Slice&lt; ElementT &gt; empty_slice(StaticType&lt; ElementT &gt;  ={}) template &lt;typename T &gt; SubRangeSeq&lt; Slice&lt; T &gt; &gt; as_seq(const Slice&lt; T &gt; &amp; s) template &lt;typename T &gt; auto as_seq(Slice&lt; T &gt; &amp; s) template &lt;typename T &gt; auto as_seq(Slice&lt; T &gt; &amp;&amp; s) template &lt;typename T &gt; auto as_seq(const Slice&lt; T &gt; &amp;&amp; s) template &lt;typename Iter &gt; boost::iterator_range&lt; Iter &gt; as_range(const std::pair&lt; Iter, Iter &gt; &amp; p) template &lt;typename RangeT ,typename Iter  =std::decay_t()))&gt;,typename OffsetT ,typename  =std::enable_if_t&gt;&gt; boost::iterator_range&lt; Iter &gt; slice_range(RangeT &amp;&amp; range, const Interval&lt; OffsetT &gt; &amp; i) void copy_string(SmallVecBase&lt; char &gt; &amp; dst, const std::string_view &amp; src) std::string_view as_str(const SmallVecBase&lt; char &gt; &amp; v) template &lt;typename StateT ,typename StateHash ,typename StateEqual &gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; t) template &lt;typename StateT ,typename StateHash ,typename StateEqual &gt; bool operator==(const StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; l, const StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; r) template &lt;typename StateT ,typename StateHash ,typename StateEqual &gt; usize hash_value(const StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; branch) StateMachineResult combine_results(const StateMachineResult &amp; a, const StateMachineResult &amp; b) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const StateMachineResult &amp; r) template &lt;typename IntT ,IntT kBegin,IntT kEnd,typename Fn ,typename R  =decltype(std::declval()(std::integral_constant{}))&gt; R static_dispatch(IntT i, Fn &amp;&amp; fn) template &lt;typename Fn &gt; decltype(auto) static_dispatch(bool b, Fn &amp;&amp; fn) template &lt;typename Tuple ,typename Fn &gt; decltype(auto) static_dispatch(std::size_t i, Fn &amp;&amp; fn) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Status &amp; t) bool operator==(const Status &amp; l, const Status &amp; r) bool operator!=(const Status &amp; l, const Status &amp; r) Status OkStatus() template &lt;typename T ,typename U ,typename  =std::enable_if_t{}&gt;&gt; bool operator==(const StatusOr&lt; T &gt; &amp; l, const StatusOr&lt; U &gt; &amp; r) template &lt;typename T ,typename U ,typename  =std::enable_if_t&lt;!CanBeEqCompared{}&gt;,typename  =void&gt; bool operator==(const StatusOr&lt; T &gt; &amp; l, const StatusOr&lt; U &gt; &amp; r) template &lt;typename T ,typename U &gt; bool operator!=(const StatusOr&lt; T &gt; &amp; l, const StatusOr&lt; U &gt; &amp; r) bool is_ok_status(const std::error_code &amp; ec) template &lt;typename T &gt; bool is_ok_status(const T &amp; val) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, LogLevel t) std::atomic&lt; LogLevel &gt; &amp; require_fail_global_default_log_level() Optional&lt; LogLevel &gt; &amp; require_fail_thread_default_log_level() Status status_from_errno(int code) template &lt;typename T ,typename  =std::enable_if_t{} &amp;&amp; !std::is_same_v\\, StatusOr\\&gt;&gt;&gt; decltype(auto) to_status(T &amp;&amp; v) template &lt;typename T ,typename  =std::enable_if_t&lt;std::is_same_v, Status&gt; template &lt;typename EnumT &gt; bool register_error_category(const boost::system::error_category &amp; category, const std::vector&lt; EnumT &gt; &amp; codes, batt::StaticType&lt; EnumT &gt;  ={})Registers a custom error_category so that error_code objects that use it can be converted to batt::Status via batt::to_status. Status status_from_error_category(const boost::system::error_category &amp; category, int code)Constructs and returns a batt::Status equivalent to the given code in the given category. Status status_from_error_code(const boost::system::error_code &amp; ec)Constructs and returns a batt::Status equivalent to the given error_code. Status error_code_to_status(const std::error_code &amp; ec) Status error_code_to_status(const boost::system::error_code &amp; ec) template &lt;typename T ,typename  =std::enable_if_t&lt;std::is_same_v, std::error_code&gt; template &lt;typename T ,typename  =std::enable_if_t&lt;std::is_same_v, boost::asio::error::basic_errors&gt; template &lt;typename T &gt; Status status_from_retval(T retval) template &lt;typename T &gt; T &amp;&amp; ok_result_or_panic(StatusOr&lt; T &gt; &amp;&amp; result) template &lt;typename T ,typename  =std::enable_if_t&gt;{} &amp;&amp;                                                  !std::is_same_v\\, StatusOr\\&gt;&gt;&gt; std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, T &amp;&amp; status_or) bool status_is_retryable(const Status &amp; s) std::ostream &amp; print_all(std::ostream &amp; out) template &lt;typename First ,typename... Rest&gt; std::ostream &amp; print_all(std::ostream &amp; out, First &amp;&amp; first, Rest &amp;&amp;... rest) std::istream &amp; extract_all(std::istream &amp; in) template &lt;typename First ,typename... Rest&gt; std::istream &amp; extract_all(std::istream &amp; in, First &amp;&amp; first, Rest &amp;&amp;... rest) template &lt;typename... Args&gt; std::string to_string(Args &amp;&amp;... args) template &lt;typename T ,typename... FormatArgs&gt; std::optional&lt; T &gt; from_string(const std::string &amp; str, FormatArgs &amp;&amp;... format_args) EscapedStringLiteral c_str_literal(const std::string_view &amp; str) template &lt;typename T ,typename  =std::enable_if_t&gt;&gt; Optional&lt; EscapedStringLiteral &gt; c_str_literal(const Optional&lt; T &gt; &amp; maybe_str) Optional&lt; EscapedStringLiteral &gt; c_str_literal(const NoneType &amp; ) decltype(auto) make_printable(std::string &amp; str) decltype(auto) make_printable(std::string &amp;&amp; str) decltype(auto) make_printable(const std::string &amp; str) decltype(auto) make_printable(const std::string &amp;&amp; str) decltype(auto) make_printable(std::string_view &amp; str) decltype(auto) make_printable(std::string_view &amp;&amp; str) decltype(auto) make_printable(const std::string_view &amp; str) decltype(auto) make_printable(const std::string_view &amp;&amp; str) const std::string_view &amp; StringUpperBound() std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const EscapedStringLiteral &amp; t) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const HexByteDumper &amp; t) HexByteDumper dump_hex(const void * ptr, usize size) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, SizeDumper t) SizeDumper dump_size(usize n) SizeDumper dump_size_exact(usize n) Optional&lt; usize &gt; parse_byte_size(std::string_view s)Parse a byte size string with optional units. template &lt;typename T &gt; RangeDumper&lt; const T &amp; &gt; dump_range(const T &amp; value, Pretty pretty =Pretty::Default) auto pretty_print_indent() template &lt;typename T ,typename Tag ,typename  =std::enable_if_t&gt; constexpr StrongType&lt; T, Tag &gt; operator+(StrongType&lt; T, Tag &gt; a, StrongType&lt; T, Tag &gt; b) template &lt;typename T ,typename Tag ,typename  =std::enable_if_t&gt; constexpr StrongType&lt; T, Tag &gt; operator-(StrongType&lt; T, Tag &gt; a, StrongType&lt; T, Tag &gt; b) template &lt;typename T ,typename Tag ,typename  =std::enable_if_t&gt; constexpr StrongType&lt; T, Tag &gt; operator*(StrongType&lt; T, Tag &gt; a, StrongType&lt; T, Tag &gt; b) template &lt;typename T ,typename Tag ,typename  =std::enable_if_t&gt; constexpr StrongType&lt; T, Tag &gt; operator/(StrongType&lt; T, Tag &gt; a, StrongType&lt; T, Tag &gt; b) template &lt;typename Op &gt; auto syscall_retry(Op &amp;&amp; op) template &lt;typename L ,typename R &gt; constexpr bool operator==(StaticType&lt; L &gt; , StaticType&lt; R &gt; ) template &lt;typename L ,typename R &gt; constexpr bool operator!=(StaticType&lt; L &gt; , StaticType&lt; R &gt; ) constexpr bool is_any_true()Returns true iff any of the passed arguments evaluates to true (base case; always returns false). template &lt;typename... Rest&gt; constexpr bool is_any_true(bool first, Rest &amp;&amp;... rest)Returns true iff any of the passed arguments evaluates to true (recursive case; short circuits if <code>first</code> is true.). constexpr bool are_all_true()Returns true iff all of the passed arguments evaluate to true (base case; always returns false). template &lt;typename... Rest&gt; constexpr bool are_all_true(bool first, Rest &amp;&amp;... rest)Returns true iff any of the passed arguments evaluates to true (recursive case; short circuits if <code>first</code> is true.). const char * name_of(const std::type_index &amp; index)Calculates and returns the demangled name of the given type as a null-terminated C-string. const char * name_of(const std::type_info &amp; info)Calculates and returns the demangled name of the given type as a null-terminated C-string. template &lt;typename T &gt; const char * name_of(batt::StaticType&lt; T &gt;  ={})Calculates and returns the demangled name of the given type as a null-terminated C-string. template &lt;typename T &gt; const char * unqualified_name_of(batt::StaticType&lt; T &gt;  ={})Calculates and returns the demangled name of the given type, without the namespace qualifier. template &lt;typename T ,typename  =std::enable_if_t&gt;&gt; constexpr auto can_be_empty_base(StaticType&lt; T &gt;  ={})Returns true iff the specified type can be optimized to zero size via empty base class optimization. template &lt;typename T ,typename  =std::enable_if_t&lt;!std::is_class_v&gt;,typename  =void&gt; constexpr std::false_type can_be_empty_base(StaticType&lt; T &gt;  ={}) bool operator==(const UrlParse &amp; left, const UrlParse &amp; right) bool operator!=(const UrlParse &amp; left, const UrlParse &amp; right) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const UrlParse &amp; t) StatusOr&lt; UrlParse &gt; parse_url(std::string_view url) template &lt;typename T &gt; T make_copy(const T &amp; value)Return a copy of <code>value</code>. template &lt;typename T ,typename  =std::enable_if_t&gt;&gt;&gt; T &amp;&amp; sink(T &amp;&amp; value) template &lt;typename T &gt; T sink(const T &amp; value) template &lt;typename T ,typename  =std::enable_if_t&lt;!std::is_same_v&gt;&gt; T make_default()Return a default-constructed instance of type <code>T</code>. template &lt;typename T ,typename  =std::enable_if_t&gt;,typename  =void&gt; void make_default() template &lt;typename T &gt; decltype(auto) unwrap_ref(T &amp;&amp; obj) template &lt;typename T &gt; decltype(auto) unwrap_ref(std::reference_wrapper&lt; T &gt; &amp; wrapper) template &lt;typename T &gt; decltype(auto) unwrap_ref(std::reference_wrapper&lt; T &gt; const &amp; wrapper) template &lt;typename T &gt; decltype(auto) unwrap_ref(std::reference_wrapper&lt; T &gt; &amp;&amp; wrapper) template &lt;typename T &gt; decltype(auto) unwrap_ref(std::reference_wrapper&lt; T &gt; const &amp;&amp; wrapper) template &lt;typename Fn ,typename... Args&gt; decltype(auto) rotate_args_right(Fn &amp;&amp; fn, Args &amp;&amp;... args) template &lt;typename Fn ,typename... Args&gt; decltype(auto) rotate_args_left(Fn &amp;&amp; fn, Args &amp;&amp;... args)"},{"location":"_autogen/Namespaces/namespacebatt/#attributes","title":"Attributes","text":"Name constexpr usize kMinStackSizeLog2 constexpr usize kMaxStackSizeLog2 constexpr usize kMaxDebugInfoThreads const bool kTaskDebugInfoSegvCallbackInstalled constexpr auto kCpuCacheLineSize const bool kSigSegvHandlerInstalled constexpr usize kDefaultSmallVecSize constexpr bool IsStatusEnum constexpr auto TupleIndexOf_v constexpr bool IsOneOf Trait that evaluates to true iff <code>T</code> is the same as one of the MatchTs. constexpr bool DecaysToOneOf Trait that evaluates to true iff <code>T</code> decays to one of the MatchTs."},{"location":"_autogen/Namespaces/namespacebatt/#types-documentation","title":"Types Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt/#enum-stacktype","title":"enum StackType","text":"Enumerator Value Description kFixedSize 0 kProtectedFixedSize 1 kPooledFixedSize 2 kMaxValue"},{"location":"_autogen/Namespaces/namespacebatt/#enum-transferstep","title":"enum TransferStep","text":"Enumerator Value Description kNone kFetch kWrite"},{"location":"_autogen/Namespaces/namespacebatt/#enum-readwritelockqueuenodeclass","title":"enum ReadWriteLockQueueNodeClass","text":"Enumerator Value Description kReading 0 kWriting 1"},{"location":"_autogen/Namespaces/namespacebatt/#enum-waitforresource","title":"enum WaitForResource","text":"Enumerator Value Description kFalse false kTrue true"},{"location":"_autogen/Namespaces/namespacebatt/#enum-boolstatus","title":"enum BoolStatus","text":"Enumerator Value Description kUnknown -1 kFalse 0 kTrue 1 <p>An enumeration that models boolean (true/false) values plus unknown. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#enum-inclusivelowerbound","title":"enum InclusiveLowerBound","text":"Enumerator Value Description kFalse false kTrue true"},{"location":"_autogen/Namespaces/namespacebatt/#enum-inclusiveupperbound","title":"enum InclusiveUpperBound","text":"Enumerator Value Description kFalse false kTrue true"},{"location":"_autogen/Namespaces/namespacebatt/#enum-order","title":"enum Order","text":"Enumerator Value Description Less -1 Equal 0 Greater 1"},{"location":"_autogen/Namespaces/namespacebatt/#enum-statuscode","title":"enum StatusCode","text":"Enumerator Value Description kOk 0 kCancelled 1 kUnknown 2 kInvalidArgument 3 kDeadlineExceeded 4 kNotFound 5 kAlreadyExists 6 kPermissionDenied 7 kResourceExhausted 8 kFailedPrecondition 9 kAborted 10 kOutOfRange 11 kUnimplemented 12 kInternal 13 kUnavailable 14 kDataLoss 15 kUnauthenticated 16 kClosed 100 kGrantUnavailable 101 kLoopBreak 102 kEndOfStream 103 kClosedBeforeEndOfStream 104 kGrantRevoked 105 kPoke 106"},{"location":"_autogen/Namespaces/namespacebatt/#enum-errnovalue","title":"enum ErrnoValue","text":"Enumerator Value Description"},{"location":"_autogen/Namespaces/namespacebatt/#enum-stdgenericerrorcode","title":"enum StdGenericErrorCode","text":"Enumerator Value Description"},{"location":"_autogen/Namespaces/namespacebatt/#enum-stdfutureerrorcode","title":"enum StdFutureErrorCode","text":"Enumerator Value Description"},{"location":"_autogen/Namespaces/namespacebatt/#enum-stdsystemerrorcode","title":"enum StdSystemErrorCode","text":"Enumerator Value Description"},{"location":"_autogen/Namespaces/namespacebatt/#enum-stdiostreamerrorcode","title":"enum StdIostreamErrorCode","text":"Enumerator Value Description"},{"location":"_autogen/Namespaces/namespacebatt/#enum-loglevel","title":"enum LogLevel","text":"Enumerator Value Description kFatal kError kWarning kInfo kDebug kVerbose"},{"location":"_autogen/Namespaces/namespacebatt/#enum-pretty","title":"enum Pretty","text":"Enumerator Value Description True False Default"},{"location":"_autogen/Namespaces/namespacebatt/#using-partscount","title":"using PartsCount","text":"<pre><code>using batt::PartsCount = typedef ::batt::StrongType&lt; usize , PartsCount_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-partsize","title":"using PartSize","text":"<pre><code>using batt::PartSize = typedef ::batt::StrongType&lt; usize , PartSize_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-runningtotal","title":"using RunningTotal","text":"<pre><code>using batt::RunningTotal = typedef BasicRunningTotal&lt;usize&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-hasconstbuffersequencerequirements","title":"using HasConstBufferSequenceRequirements","text":"<pre><code>template &lt;typename T &gt;\nusing batt::HasConstBufferSequenceRequirements = typedef decltype(detail::has_const_buffer_sequence_requirements_impl&lt;T&gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifconstbuffersequence","title":"using EnableIfConstBufferSequence","text":"<pre><code>template &lt;typename T &gt;\nusing batt::EnableIfConstBufferSequence = typedef std::enable_if_t&lt;has_const_buffer_sequence_requirements&lt;T&gt;()&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-hasbuffersourcerequirements","title":"using HasBufferSourceRequirements","text":"<pre><code>template &lt;typename T &gt;\nusing batt::HasBufferSourceRequirements = typedef decltype(detail::has_buffer_source_requirements_impl&lt;T&gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifbuffersource","title":"using EnableIfBufferSource","text":"<pre><code>template &lt;typename T &gt;\nusing batt::EnableIfBufferSource = typedef std::enable_if_t&lt;has_buffer_source_requirements&lt;T&gt;()&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-continuation","title":"using Continuation","text":"<pre><code>using batt::Continuation = typedef boost::context::continuation;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-stacksize","title":"using StackSize","text":"<pre><code>using batt::StackSize = typedef ::batt::StrongType&lt; usize , StackSize_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-fakeexecutor","title":"using FakeExecutor","text":"<pre><code>using batt::FakeExecutor = typedef BasicFakeExecutor&lt;boost::asio::execution::outstanding_work_t::untracked_t&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-grant","title":"using Grant","text":"<pre><code>using batt::Grant = typedef ScalableGrant;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-defaulthandlerbase","title":"using DefaultHandlerBase","text":"<pre><code>using batt::DefaultHandlerBase = typedef boost::intrusive::slist_base_hook&lt;boost::intrusive::cache_last&lt;true&gt;, boost::intrusive::constant_time_size&lt;true&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-abstracthandler","title":"using AbstractHandler","text":"<pre><code>template &lt;typename... Args&gt;\nusing batt::AbstractHandler = typedef BasicAbstractHandler&lt;DefaultHandlerBase, Args...&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-handlerimpl","title":"using HandlerImpl","text":"<pre><code>template &lt;typename HandlerFn ,\ntypename... Args&gt;\nusing batt::HandlerImpl = typedef BasicHandlerImpl&lt;HandlerFn, DefaultHandlerBase, Args...&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-basichandlerlist","title":"using BasicHandlerList","text":"<pre><code>template &lt;typename Base ,\ntypename... Args&gt;\nusing batt::BasicHandlerList = typedef boost::intrusive::slist&lt;BasicAbstractHandler&lt;Base, Args...&gt;, boost::intrusive::cache_last&lt;true&gt;, boost::intrusive::constant_time_size&lt;true&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-handlerlist","title":"using HandlerList","text":"<pre><code>template &lt;typename... Args&gt;\nusing batt::HandlerList = typedef BasicHandlerList&lt;DefaultHandlerBase, Args...&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-errorcode","title":"using ErrorCode","text":"<pre><code>using batt::ErrorCode = typedef boost::system::error_code;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-mcsmutex","title":"using MCSMutex","text":"<pre><code>using batt::MCSMutex = typedef BasicMCSMutex&lt;false&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-ratelimiter","title":"using RateLimiter","text":"<pre><code>using batt::RateLimiter = typedef BasicRateLimiter&lt;std::chrono::steady_clock&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-readwritelock","title":"using ReadWriteLock","text":"<pre><code>using batt::ReadWriteLock = typedef BasicReadWriteLock&lt;WatchAtomic&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-scopedreadlock","title":"using ScopedReadLock","text":"<pre><code>template &lt;typename T &gt;\nusing batt::ScopedReadLock = typedef ScopedReadWriteLockImpl&lt;const T, ReadWriteLock::Reader&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-scopedwritelock","title":"using ScopedWriteLock","text":"<pre><code>template &lt;typename T &gt;\nusing batt::ScopedWriteLock = typedef ScopedReadWriteLockImpl&lt;T, ReadWriteLock::Writer&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-simpleexecutor","title":"using SimpleExecutor","text":"<pre><code>using batt::SimpleExecutor = typedef BasicExecutor&lt;SimpleExecutionContext, boost::asio::execution::outstanding_work_t::untracked_t, boost::asio::execution::blocking_t::never_t, boost::asio::execution::relationship_t::fork_t&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-taskcount","title":"using TaskCount","text":"<pre><code>using batt::TaskCount = typedef ::batt::StrongType&lt; usize , TaskCount_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-inputsize","title":"using InputSize","text":"<pre><code>using batt::InputSize = typedef ::batt::StrongType&lt; usize , InputSize_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-tasksize","title":"using TaskSize","text":"<pre><code>using batt::TaskSize = typedef ::batt::StrongType&lt; usize , TaskSize_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-taskindex","title":"using TaskIndex","text":"<pre><code>using batt::TaskIndex = typedef ::batt::StrongType&lt; usize , TaskIndex_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-taskoffset","title":"using TaskOffset","text":"<pre><code>using batt::TaskOffset = typedef ::batt::StrongType&lt; isize , TaskOffset_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-constbuffer","title":"using ConstBuffer","text":"<pre><code>using batt::ConstBuffer = typedef boost::asio::const_buffer;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-mutablebuffer","title":"using MutableBuffer","text":"<pre><code>using batt::MutableBuffer = typedef boost::asio::mutable_buffer;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-httpclientconnection","title":"using HttpClientConnection","text":"<pre><code>using batt::HttpClientConnection = typedef BasicHttpClientConnection&lt;TcpTransport&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-httpsclientconnection","title":"using HttpsClientConnection","text":"<pre><code>using batt::HttpsClientConnection = typedef BasicHttpClientConnection&lt;SslTransport&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-includehttptrailer","title":"using IncludeHttpTrailer","text":"<pre><code>using batt::IncludeHttpTrailer = typedef ::batt::StrongType&lt; bool , IncludeHttpTrailer_TAG &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-httpheader","title":"using HttpHeader","text":"<pre><code>using batt::HttpHeader = typedef ::pico_http::MessageHeader;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-httprequestdispatcherfn","title":"using HttpRequestDispatcherFn","text":"<pre><code>using batt::HttpRequestDispatcherFn = typedef SmallFn&lt;Status(HttpRequest&amp; request, HttpResponse&amp; response)&gt;;\n</code></pre> <p>One request dispatcher is created per accepted connection; it is reused in the context of that connection until the connection is closed. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#using-httprequestdispatcherfactoryfn","title":"using HttpRequestDispatcherFactoryFn","text":"<pre><code>using batt::HttpRequestDispatcherFactoryFn = typedef SmallFn&lt;StatusOr&lt;HttpRequestDispatcherFn&gt;()&gt;;\n</code></pre> <p>Called once per accepted connection. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#using-interval","title":"using Interval","text":"<pre><code>template &lt;typename T &gt;\nusing batt::Interval = typedef BasicInterval&lt;IClosedOpen&lt;T&gt; &gt;;\n</code></pre> <p>A half-open interval (like STL iterator ranges). </p> <p>For this type of interval, <code>lower_bound</code> is the smallest value in the set, and <code>upper_bound</code> is the value right after the largest value in the set.</p> <p>Example:</p> <pre><code>#include &lt;batteries/assert.hpp&gt;\n#include &lt;batteries/interval.hpp&gt;\nint main()\n{\nbatt::Interval&lt;int&gt; i{3, 7};\nBATT_CHECK_EQ(i.size(), 4);\nBATT_CHECK(i.contains(3));\nBATT_CHECK(i.contains(6));\nBATT_CHECK(!i.contains(2));\nBATT_CHECK(!i.contains(7));\nBATT_CHECK((batt::Interval&lt;int&gt;{5, 5}).empty());\nreturn 0;\n}\n</code></pre> <p>Filename: examples/interval.cpp</p> <p>\\ </p>"},{"location":"_autogen/Namespaces/namespacebatt/#using-cinterval","title":"using CInterval","text":"<pre><code>template &lt;typename T &gt;\nusing batt::CInterval = typedef BasicInterval&lt;IClosed&lt;T&gt; &gt;;\n</code></pre> <p>A closed interval. </p> <p>For this type of interval, <code>lower_bound</code> is the smallest value in the set, and <code>upper_bound</code> is the largest value in the set.</p> <p>Example: </p>"},{"location":"_autogen/Namespaces/namespacebatt/#using-derivedmetric","title":"using DerivedMetric","text":"<pre><code>template &lt;typename T &gt;\nusing batt::DerivedMetric = typedef std::function&lt;T()&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-metriclabelset","title":"using MetricLabelSet","text":"<pre><code>using batt::MetricLabelSet = typedef std::vector&lt;MetricLabel&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-countmetricexporter","title":"using CountMetricExporter","text":"<pre><code>template &lt;typename T &gt;\nusing batt::CountMetricExporter = typedef ScalarMetricExporter&lt;CountMetric&lt;T&gt; &gt;;\n</code></pre> <p>Exports a CountMetric."},{"location":"_autogen/Namespaces/namespacebatt/#using-gaugemetricexporter","title":"using GaugeMetricExporter","text":"<pre><code>template &lt;typename T &gt;\nusing batt::GaugeMetricExporter = typedef ScalarMetricExporter&lt;GaugeMetric&lt;T&gt; &gt;;\n</code></pre> <p>Exports a GaugeMetric."},{"location":"_autogen/Namespaces/namespacebatt/#using-nullable","title":"using Nullable","text":"<pre><code>template &lt;typename T &gt;\nusing batt::Nullable = typedef typename detail::NullableImpl&lt;T&gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-uniquenonowningptr","title":"using UniqueNonOwningPtr","text":"<pre><code>template &lt;typename T &gt;\nusing batt::UniqueNonOwningPtr = typedef std::unique_ptr&lt;T, NoopDeleter&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-printtostreamfunctionpointer","title":"using PrintToStreamFunctionPointer","text":"<pre><code>using batt::PrintToStreamFunctionPointer = typedef void (*)(std::ostream&amp;);\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-hasseqrequirements","title":"using HasSeqRequirements","text":"<pre><code>template &lt;typename T &gt;\nusing batt::HasSeqRequirements = typedef decltype(detail::has_seq_requirements_impl&lt;T&gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifseq","title":"using EnableIfSeq","text":"<pre><code>template &lt;typename T &gt;\nusing batt::EnableIfSeq = typedef std::enable_if_t&lt;has_seq_requirements&lt;T&gt;()&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-seqitem","title":"using SeqItem","text":"<pre><code>template &lt;typename T &gt;\nusing batt::SeqItem = typedef typename SeqItem_Impl&lt;T&gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-refcounted","title":"using RefCounted","text":"<pre><code>template &lt;typename T &gt;\nusing batt::RefCounted = typedef boost::intrusive_ref_counter&lt;std::decay_t&lt;T&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-isrefcounted","title":"using IsRefCounted","text":"<pre><code>template &lt;typename T &gt;\nusing batt::IsRefCounted = typedef decltype(detail::is_ref_counted_impl&lt;std::decay_t&lt;T&gt; &gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-sharedptr","title":"using SharedPtr","text":"<pre><code>template &lt;typename T &gt;\nusing batt::SharedPtr = typedef typename SharedPtrImpl&lt;T&gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-slice","title":"using Slice","text":"<pre><code>template &lt;typename T &gt;\nusing batt::Slice = typedef boost::iterator_range&lt;T*&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-uniquesmallfn","title":"using UniqueSmallFn","text":"<pre><code>template &lt;typename Signature ,\nusize kMaxSize =kCpuCacheLineSize - sizeof(void*),\nbool kAllowAlloc =false&gt;\nusing batt::UniqueSmallFn = typedef SmallFn&lt;Signature, kMaxSize, true, kAllowAlloc&gt;;\n</code></pre> <p>A type-erased container for a move-only callable function-like object. </p> <p>This type can be used to hold copyable functions, but is itself move-only, therefore does not require copy semantics from erased types. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#using-smallvec","title":"using SmallVec","text":"<pre><code>template &lt;typename T ,\nusize kStaticSize =kDefaultSmallVecSize&gt;\nusing batt::SmallVec = typedef boost::container::small_vector&lt;T, kStaticSize&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-smallvecbase","title":"using SmallVecBase","text":"<pre><code>template &lt;typename T &gt;\nusing batt::SmallVecBase = typedef boost::container::small_vector_base&lt;T&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-statemachineentropysource","title":"using StateMachineEntropySource","text":"<pre><code>using batt::StateMachineEntropySource = typedef BasicStateMachineEntropySource&lt;std::function&lt;usize(usize min_value, usize max_value)&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-isstatusor","title":"using IsStatusOr","text":"<pre><code>template &lt;typename T &gt;\nusing batt::IsStatusOr = typedef detail::IsStatusOrImpl&lt;std::decay_t&lt;T&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-removestatusor","title":"using RemoveStatusOr","text":"<pre><code>template &lt;typename T &gt;\nusing batt::RemoveStatusOr = typedef typename RemoveStatusOrImpl&lt;std::decay_t&lt;T&gt; &gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-token","title":"using Token","text":"<pre><code>using batt::Token = typedef boost::flyweights::flyweight&lt;std::string, boost::flyweights::no_tracking&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-morphtuple_t","title":"using MorphTuple_t","text":"<pre><code>template &lt;template&lt; typename... &gt; class TemplateT,\ntypename TupleT &gt;\nusing batt::MorphTuple_t = typedef typename MorphTuple&lt;TemplateT, std::decay_t&lt;TupleT&gt; &gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-maptuple_t","title":"using MapTuple_t","text":"<pre><code>template &lt;template&lt; typename &gt; class PerTypeT,\ntypename TupleT &gt;\nusing batt::MapTuple_t = typedef typename MapTuple&lt;PerTypeT, std::decay_t&lt;TupleT&gt; &gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-iscallable","title":"using IsCallable","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args&gt;\nusing batt::IsCallable = typedef decltype(detail::is_callable_impl&lt;Fn, Args...&gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-isprintable","title":"using IsPrintable","text":"<pre><code>template &lt;typename T &gt;\nusing batt::IsPrintable = typedef decltype(detail::is_printable_impl&lt;T&gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-isrange","title":"using IsRange","text":"<pre><code>template &lt;typename T &gt;\nusing batt::IsRange = typedef decltype(detail::is_range_impl&lt;T&gt;(nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-enableifnoshadow","title":"using EnableIfNoShadow","text":"<pre><code>template &lt;typename T ,\ntypename... Args&gt;\nusing batt::EnableIfNoShadow = typedef std::enable_if_t&lt;!std::is_same&lt;std::tuple&lt;std::decay_t&lt;T&gt;*&gt;, std::tuple&lt;std::decay_t&lt;Args&gt;*...&gt; &gt;{} &amp;&amp; !std::is_same&lt;std::tuple&lt;&gt;, std::tuple&lt;std::decay_t&lt;Args&gt;*...&gt; &gt;{} &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-decayrvalueref","title":"using DecayRValueRef","text":"<pre><code>template &lt;typename T &gt;\nusing batt::DecayRValueRef = typedef typename DecayRValueRefImpl&lt;T&gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-canbeeqcompared","title":"using CanBeEqCompared","text":"<pre><code>template &lt;typename T ,\ntypename U  =T&gt;\nusing batt::CanBeEqCompared = typedef decltype(detail::can_be_eq_compared_helper&lt;T, U&gt;(nullptr, nullptr));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#using-unwrapreftype","title":"using UnwrapRefType","text":"<pre><code>template &lt;typename T &gt;\nusing batt::UnwrapRefType = typedef decltype(unwrap_ref(std::declval&lt;T&gt;()));\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_accumulate_partial","title":"function parallel_accumulate_partial","text":"<pre><code>template &lt;typename Iter ,\ntypename T ,\ntypename BinaryOp &gt;\nSlice&lt; T &gt; parallel_accumulate_partial(\nWorkContext &amp; context,\nIter first,\nIter last,\nT init,\nconst BinaryOp &amp; binary_op,\nT identity,\nconst Slice&lt; T &gt; &amp; task_result_buffer,\nconst WorkSliceParams &amp; params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_accumulate","title":"function parallel_accumulate","text":"<pre><code>template &lt;typename Iter ,\ntypename T ,\ntypename BinaryOp &gt;\nT parallel_accumulate(\nWorkerPool &amp; worker_pool,\nIter first,\nIter last,\nT init,\nconst BinaryOp &amp; binary_op,\nT identity,\nTaskSize min_task_size =TaskSize{4096},\nTaskCount max_tasks =TaskCount{std::thread::hardware_concurrency()}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_copy","title":"function parallel_copy","text":"<pre><code>template &lt;typename Src ,\ntypename Dst &gt;\nvoid parallel_copy(\nWorkContext &amp; work_context,\nSrc src_begin,\nSrc src_end,\nDst dst_begin,\nTaskSize min_task_size,\nTaskCount max_tasks\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_merge","title":"function parallel_merge","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 ,\ntypename Dst ,\ntypename Compare &gt;\nvoid parallel_merge(\nWorkerPool &amp; worker_pool,\nSrc0 src_0_begin,\nSrc0 src_0_end,\nSrc1 src_1_begin,\nSrc1 src_1_end,\nDst dst_begin,\nCompare &amp;&amp; compare,\nusize min_task_size =1400,\nusize max_tasks =std::thread::hardware_concurrency()/2\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_merge_1","title":"function parallel_merge","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 ,\ntypename Dst ,\ntypename Compare &gt;\nvoid parallel_merge(\nWorkContext &amp; context,\nSrc0 src_0_begin,\nSrc0 src_0_end,\nSrc1 src_1_begin,\nSrc1 src_1_end,\nDst dst_begin,\nCompare &amp;&amp; compare,\nusize min_task_size =1400,\nusize max_tasks =std::thread::hardware_concurrency()/2\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_running_total","title":"function parallel_running_total","text":"<pre><code>template &lt;typename Iter ,\ntypename Fn ,\ntypename ValueT  =std::decay_t&lt;std::invoke_result_t&lt;Fn, typename std::iterator_traits&lt;Iter&gt;::reference&gt;&gt;&gt;\nBasicRunningTotal&lt; ValueT &gt; parallel_running_total(\nWorkerPool &amp; worker_pool,\nIter first,\nIter last,\nconst Fn &amp; fn,\nconst WorkSliceParams &amp; params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_running_total_1","title":"function parallel_running_total","text":"<pre><code>template &lt;typename Iter ,\ntypename ValueT  =typename std::iterator_traits&lt;Iter&gt;::value_type&gt;\nBasicRunningTotal&lt; ValueT &gt; parallel_running_total(\nWorkerPool &amp; worker_pool,\nIter first,\nIter last,\nconst WorkSliceParams &amp; params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parallel_transform","title":"function parallel_transform","text":"<pre><code>template &lt;typename Src ,\ntypename Dst ,\ntypename TransformFn &gt;\nvoid parallel_transform(\nWorkContext &amp; work_context,\nSrc src_begin,\nSrc src_end,\nDst dst_begin,\nconst TransformFn &amp; transform_fn,\nTaskSize min_task_size,\nTaskCount max_tasks\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nPartsCount_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_1","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nPartSize_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-fail_check_exit","title":"function fail_check_exit","text":"<pre><code>void fail_check_exit()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-fail_check_exit_entered","title":"function fail_check_exit_entered","text":"<pre><code>std::atomic&lt; bool &gt; &amp; fail_check_exit_entered()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-fail_check_spin_lock","title":"function fail_check_spin_lock","text":"<pre><code>std::atomic&lt; bool &gt; &amp; fail_check_spin_lock()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-ignore","title":"function ignore","text":"<pre><code>template &lt;typename... Ts&gt;\ninline bool ignore(\nTs &amp;&amp; ...\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-lock_fail_check_mutex","title":"function lock_fail_check_mutex","text":"<pre><code>bool lock_fail_check_mutex()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-async_run_task","title":"function async_run_task","text":"<pre><code>template &lt;typename BodyFn  =void(),\ntypename... TaskArgsAndHandler&gt;\nTask * async_run_task(\nconst boost::asio::any_io_executor &amp; ex,\nStackSize stack_byte_size,\nBodyFn &amp;&amp; body_fn,\nTaskArgsAndHandler &amp;&amp;... task_args_and_handler\n)\n</code></pre> <p>Creates and starts (default) a new batt::Task, the memory for which (including stack) is allocated as a single contiguous memory region using the allocated associated with the final arg passed to this function, the completion handler. </p> <p>The completion handler will automatically be called when the task completes; the memory associated with the task will also be automatically freed before (a copy of) the completion handler is invoked. The completion handler signature is <code>void()</code>. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-with_retry_policy","title":"function with_retry_policy","text":"<pre><code>template &lt;typename RetryPolicy ,\ntypename ActionFn ,\ntypename Result  =std::invoke_result_t&lt;ActionFn&gt;,\ntypename SleepImpl  =TaskSleepImpl,\ntypename StatusIsRetryableImpl  =DefaultStatusIsRetryableImpl&gt;\nResult with_retry_policy(\nRetryPolicy &amp;&amp; policy,\nstd::string_view action_name,\nActionFn &amp;&amp; action_fn,\nSleepImpl &amp;&amp; sleep_impl ={},\nStatusIsRetryableImpl &amp;&amp; status_is_retryable_impl ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-update_retry_state","title":"function update_retry_state","text":"<pre><code>inline void update_retry_state(\nRetryState &amp; state,\nconst ExponentialBackoff &amp; policy\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-has_const_buffer_sequence_requirements","title":"function has_const_buffer_sequence_requirements","text":"<pre><code>template &lt;typename T &gt;\ninline constexpr bool has_const_buffer_sequence_requirements(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-has_buffer_source_requirements","title":"function has_buffer_source_requirements","text":"<pre><code>template &lt;typename T &gt;\ninline constexpr bool has_buffer_source_requirements(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\nTakeNSource&lt; Src &gt; operator|(\nSrc &amp;&amp; src,\nseq::TakeNBinder binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_1","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\nvoid operator|(\nSrc &amp;&amp; ,\nSkipNBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_2","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename Fn ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\ninline StatusOr&lt; seq::LoopControl &gt; operator|(\nSrc &amp;&amp; src,\nseq::ForEachBinder&lt; Fn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_3","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\ninline StatusOr&lt; std::vector&lt; char &gt; &gt; operator|(\nSrc &amp;&amp; src,\nseq::CollectVec )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_4","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\ninline Status operator|(\nSrc &amp;&amp; src,\nseq::PrintOut p\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_5","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\ninline Status operator|(\nSrc &amp;&amp; src,\nseq::Consume )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_6","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename AsyncWriteStream ,\ntypename  =EnableIfBufferSource&lt;Src&gt;&gt;\nStatusOr&lt; usize &gt; operator|(\nSrc &amp;&amp; src,\nseq::WriteToBinder&lt; AsyncWriteStream &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_7","title":"function operator|","text":"<pre><code>template &lt;typename Src ,\ntypename ConstBufferSequence ,\ntypename  =EnableIfBufferSource&lt;Src&gt;,\ntypename  =EnableIfConstBufferSequence&lt;ConstBufferSequence&gt;&gt;\ninline auto operator|(\nSrc &amp;&amp; src,\nseq::PrependBinder&lt; ConstBufferSequence &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value","title":"function hash_value","text":"<pre><code>inline usize hash_value(\nconst CancelToken &amp; cancel_token\n)\n</code></pre> <p>CancelToken is hashed by its impl pointer. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_8","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n)\n</code></pre> <p>Returns true iff the two objects are copies of the same CancelToken. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_9","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_10","title":"function operator&lt;","text":"<pre><code>inline bool operator&lt;(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_11","title":"function operator&gt;","text":"<pre><code>inline bool operator&gt;(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_12","title":"function operator&lt;=","text":"<pre><code>inline bool operator&lt;=(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_13","title":"function operator&gt;=","text":"<pre><code>inline bool operator&gt;=(\nconst CancelToken &amp; l,\nconst CancelToken &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_cancelled","title":"function is_cancelled","text":"<pre><code>template &lt;typename T &gt;\ninline bool is_cancelled(\nconst CancelToken::HandlerImpl&lt; T &gt; &amp; handler\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_cancelled_1","title":"function is_cancelled","text":"<pre><code>template &lt;typename T &gt;\ninline bool is_cancelled(\nconst CustomAllocHandler&lt; CancelToken::HandlerImpl&lt; T &gt;&gt; &amp; handler\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-boost_pp_cat","title":"function BOOST_PP_CAT","text":"<pre><code>static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion&lt; decltype(sizeof(void *) *2), decltype(sizeof(boost::context::stack_context)),(sizeof(void *) *2), ::batt::Eq,(sizeof(boost::context::stack_context)),((sizeof(void *) *2)==(sizeof(boost::context::stack_context)))&gt; BOOST_PP_CAT(\nBOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__) ,\n__COUNTER__ )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_2","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nStackSize_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_stack_allocator_with_type","title":"function get_stack_allocator_with_type","text":"<pre><code>template &lt;typename T &gt;\ninline const StackAllocator &amp; get_stack_allocator_with_type(\nStackSize stack_size\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_stack_allocator","title":"function get_stack_allocator","text":"<pre><code>inline const StackAllocator &amp; get_stack_allocator(\nStackSize stack_size,\nStackType stack_type\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-callcc","title":"function callcc","text":"<pre><code>template &lt;typename Fn &gt;\ninline Continuation callcc(\nStackAllocator &amp;&amp; stack_allocator,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-callcc_1","title":"function callcc","text":"<pre><code>template &lt;typename Fn &gt;\ninline Continuation callcc(\nStackSize stack_size,\nStackType stack_type,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-this_task_debug_info","title":"function this_task_debug_info","text":"<pre><code>inline void this_task_debug_info(\nstd::ostream &amp; out\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_debug_info","title":"function print_debug_info","text":"<pre><code>inline void print_debug_info(\nDebugInfoFrame * p,\nstd::ostream &amp; out\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_all_threads_debug_info","title":"function print_all_threads_debug_info","text":"<pre><code>inline void print_all_threads_debug_info(\nstd::ostream &amp; out\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-shortened_source_file","title":"function shortened_source_file","text":"<pre><code>inline const char * shortened_source_file(\nconst char * raw\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-enable_dump_tasks","title":"function enable_dump_tasks","text":"<pre><code>inline bool enable_dump_tasks()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_14","title":"function operator==","text":"<pre><code>template &lt;typename OutstandingWorkP &gt;\nconstexpr bool operator==(\nconst BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; l,\nconst BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_15","title":"function operator!=","text":"<pre><code>template &lt;typename OutstandingWorkP &gt;\nconstexpr bool operator!=(\nconst BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; l,\nconst BasicFakeExecutor&lt; OutstandingWorkP &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_16","title":"function operator&lt;","text":"<pre><code>inline bool operator&lt;(\nconst FakeTimeService::TimerInstance &amp; l,\nconst FakeTimeService::TimerInstance &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_17","title":"function operator&gt;","text":"<pre><code>inline bool operator&gt;(\nconst FakeTimeService::TimerInstance &amp; l,\nconst FakeTimeService::TimerInstance &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_18","title":"function operator&lt;=","text":"<pre><code>inline bool operator&lt;=(\nconst FakeTimeService::TimerInstance &amp; l,\nconst FakeTimeService::TimerInstance &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_19","title":"function operator&gt;=","text":"<pre><code>inline bool operator&gt;=(\nconst FakeTimeService::TimerInstance &amp; l,\nconst FakeTimeService::TimerInstance &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-fetch_chunk","title":"function fetch_chunk","text":"<pre><code>template &lt;typename AsyncFetchStreamT ,\ntypename ScopedChunk  =BasicScopedChunk&lt;AsyncFetchStreamT&gt;,\ntypename ConstBufferSequence  =typename AsyncFetchStreamT::const_buffers_type&gt;\nbatt::StatusOr&lt; ScopedChunk &gt; fetch_chunk(\nAsyncFetchStreamT &amp; stream,\nusize min_size\n)\n</code></pre> <p>Awaits the result of an async_fetch on the passed stream with the given minimum chunk size. </p> <p>The returned chunk object will cause the fetched data to be consumed from the stream by default when it goes out of scope. Some of the fetched data can be left in the stream by calling BasicScopedChunk::back_up.</p> <p>This function blocks the current task until min_size bytes are available on the stream, or an error occurs (e.g., end-of-stream). </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-transfer_chunked_data","title":"function transfer_chunked_data","text":"<pre><code>template &lt;typename From ,\ntypename To &gt;\ninline StatusOr&lt; usize &gt; transfer_chunked_data(\nFrom &amp; from,\nTo &amp; to,\nTransferStep &amp; step\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-transfer_chunked_data_1","title":"function transfer_chunked_data","text":"<pre><code>template &lt;typename From ,\ntypename To &gt;\ninline StatusOr&lt; usize &gt; transfer_chunked_data(\nFrom &amp; from,\nTo &amp; to\n)\n</code></pre> <p>Fetches data from the first arg and writes it to the second arg, until an error or end-of-file/stream occurs. </p> <p>Return: The number of bytes transferred if successful, error Status otherwise </p> <p>In this overload, From should have a public member function <code>fetch_chunk</code> which returns batt::StatusOr. To should have a public member function <code>write</code> which takes a boost::asio::const_buffer (batt::ConstBuffer) and returns batt::StatusOr, indicating the number of bytes actually written to the destination stream."},{"location":"_autogen/Namespaces/namespacebatt/#function-futex_wait","title":"function futex_wait","text":"<pre><code>inline int futex_wait(\nstd::atomic&lt; u32 &gt; * ,\nu32 )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-futex_notify","title":"function futex_notify","text":"<pre><code>inline int futex_notify(\nstd::atomic&lt; u32 &gt; * ,\nu32  =1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-spin_yield","title":"function spin_yield","text":"<pre><code>inline void spin_yield()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_future","title":"function get_future","text":"<pre><code>template &lt;typename T &gt;\nFuture&lt; T &gt; get_future(\nconst Promise&lt; T &gt; &amp; promise\n)\n</code></pre> <p>Returns the Future object corresponding to the Promise. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-boost_pp_cat_1","title":"function BOOST_PP_CAT","text":"<pre><code>static BATT_MAYBE_UNUSED ::batt::StaticBinaryAssertion&lt; decltype(sizeof(UniqueHandler&lt;&gt;)), decltype(sizeof(void *)),(sizeof(UniqueHandler&lt;&gt;)), ::batt::Eq,(sizeof(void *)),((sizeof(UniqueHandler&lt;&gt;))==(sizeof(void *)))&gt; BOOST_PP_CAT(\nBOOST_PP_CAT(BATTERIES_StaticAssert_Instance_, __LINE__) ,\n__COUNTER__ )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_handler_prealloc","title":"function push_handler_prealloc","text":"<pre><code>template &lt;typename Base ,\ntypename... Args&gt;\ninline void push_handler_prealloc(\nboost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Args... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt;&gt; * list,\nBasicAbstractHandler&lt; Base, Args... &gt; * handler\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_handler","title":"function push_handler","text":"<pre><code>template &lt;typename... Args,\ntypename Base ,\ntypename HandlerFn &gt;\ninline void push_handler(\nboost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Args... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt;&gt; * list,\nHandlerFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-invoke_all_handlers","title":"function invoke_all_handlers","text":"<pre><code>template &lt;typename... Params,\ntypename... Args,\ntypename Base &gt;\ninline void invoke_all_handlers(\nboost::intrusive::slist&lt; BasicAbstractHandler&lt; Base, Params... &gt;, boost::intrusive::cache_last&lt; true &gt;, boost::intrusive::constant_time_size&lt; true &gt;&gt; * handlers,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-bind_handler","title":"function bind_handler","text":"<pre><code>template &lt;typename InnerFn ,\ntypename OuterFn &gt;\nHandlerBinder&lt; std::decay_t&lt; InnerFn &gt;, std::decay_t&lt; OuterFn &gt; &gt; bind_handler(\nInnerFn &amp;&amp; inner,\nOuterFn &amp;&amp; outer\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_20","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\nbool operator==(\nconst HandlerAllocator&lt; T &gt; &amp; left,\nconst HandlerAllocator&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_21","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\nbool operator!=(\nconst HandlerAllocator&lt; T &gt; &amp; left,\nconst HandlerAllocator&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_custom_alloc_handler","title":"function make_custom_alloc_handler","text":"<pre><code>template &lt;typename Handler &gt;\ninline CustomAllocHandler&lt; std::decay_t&lt; Handler &gt; &gt; make_custom_alloc_handler(\nHandlerMemoryBase &amp; m,\nHandler &amp;&amp; h\n)\n</code></pre> <p>Helper function to wrap a handler object to add custom allocation. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-post_handler","title":"function post_handler","text":"<pre><code>template &lt;typename Handler ,\ntypename... Args&gt;\nvoid post_handler(\nHandler &amp;&amp; handler,\nArgs &amp;&amp;... args\n)\n</code></pre> <p>Posts a handler using its associated executor, binding its arguments. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_22","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename... Ts&gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst IOResult&lt; Ts... &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status","title":"function is_ok_status","text":"<pre><code>template &lt;typename... Ts&gt;\nbool is_ok_status(\nconst IOResult&lt; Ts... &gt; &amp; io_result\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status_1","title":"function is_ok_status","text":"<pre><code>inline bool is_ok_status(\nconst ErrorCode &amp; ec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status","title":"function to_status","text":"<pre><code>template &lt;typename... Ts&gt;\nStatus to_status(\nconst IOResult&lt; Ts... &gt; &amp; io_result\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pin_object","title":"function pin_object","text":"<pre><code>template &lt;typename T &gt;\nvoid pin_object(\nT * object\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unpin_object","title":"function unpin_object","text":"<pre><code>template &lt;typename T &gt;\nvoid unpin_object(\nT * object\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_pin","title":"function make_pin","text":"<pre><code>template &lt;typename T &gt;\ninline Pin&lt; T &gt; make_pin(\nT * object\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_23","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst Pin&lt; T &gt; &amp; l,\nconst Pin&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_24","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst Pin&lt; T &gt; &amp; l,\nconst Pin&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_25","title":"function operator==","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator==(\nconst Pin&lt; T &gt; &amp; l,\nstd::nullptr_t )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_26","title":"function operator!=","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator!=(\nconst Pin&lt; T &gt; &amp; l,\nstd::nullptr_t )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_27","title":"function operator==","text":"<pre><code>template &lt;typename U &gt;\ninline bool operator==(\nstd::nullptr_t ,\nconst Pin&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_28","title":"function operator!=","text":"<pre><code>template &lt;typename U &gt;\ninline bool operator!=(\nstd::nullptr_t ,\nconst Pin&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_29","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst DumpReadWriteLockState &amp; dump\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_30","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nReadWriteLockQueueNodeClass t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_31","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst ScalableGrant &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_3","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nTaskCount_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_4","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nInputSize_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_5","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nTaskSize_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_6","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr usize strong_typedef_default_value(\nTaskIndex_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_7","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr isize strong_typedef_default_value(\nTaskOffset_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_input_size","title":"function get_input_size","text":"<pre><code>template &lt;typename Iter &gt;\ninline InputSize get_input_size(\nconst Iter &amp; first,\nconst Iter &amp; last\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_32","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst WorkSliceParams &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_task_size","title":"function get_task_size","text":"<pre><code>inline TaskSize get_task_size(\nconst WorkSliceParams &amp; params,\nInputSize input_size\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_task_count","title":"function get_task_count","text":"<pre><code>inline TaskCount get_task_count(\nInputSize input_size,\nTaskSize task_size\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_33","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst WorkSlicePlan &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-slice_work","title":"function slice_work","text":"<pre><code>template &lt;typename WorkFnGenerator &gt;\nStatus slice_work(\nWorkContext &amp; context,\nconst WorkSlicePlan &amp; plan,\nWorkFnGenerator &amp;&amp; gen_work_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_34","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst SpinGrant &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_35","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\nStatusOr&lt; std::reference_wrapper&lt; StreamBuffer &gt; &gt; operator&lt;&lt;(\nStatusOr&lt; std::reference_wrapper&lt; StreamBuffer &gt;&gt; stream_buffer,\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-next_thread_id","title":"function next_thread_id","text":"<pre><code>inline i32 next_thread_id()\n</code></pre> <p>Returns the lowest unused global thread id number; repeated calls to <code>next_thread_id()</code> will return monotonically increasing values. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-this_thread_id","title":"function this_thread_id","text":"<pre><code>inline i32 &amp; this_thread_id()\n</code></pre> <p>Returns a reference to the thread-local id for the current thread. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_36","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nWaitForResource t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_37","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Watch&lt; T &gt; &amp; w\n)\n</code></pre> <p>Support for printing Watch to ostream."},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_38","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst WatchAtomic&lt; T &gt; &amp; w\n)\n</code></pre> <p>Support for printing WatchAtomic to ostream."},{"location":"_autogen/Namespaces/namespacebatt/#function-bool_status_from","title":"function bool_status_from","text":"<pre><code>inline constexpr BoolStatus bool_status_from(\nbool b\n)\n</code></pre> <p>Constructs a BoolStatus value from a bool. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_39","title":"function operator||","text":"<pre><code>inline constexpr BoolStatus operator||(\nBoolStatus left,\nBoolStatus right\n)\n</code></pre> <p>Performs a logical-or (disjunction) between two BoolStatus values. </p> <p>If one of the arguments is BoolStatus::kTrue, then the result is BoolStatus::kTrue. If both arguments are BoolStatus::kFalse, then the result is BoolStatus::kFalse. Otherwise, at least one argument is BoolStatus::kUnknown, and the result is BoolStatus::kUnknown. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_40","title":"function operator&amp;&amp;","text":"<pre><code>inline constexpr BoolStatus operator&amp;&amp;(\nBoolStatus left,\nBoolStatus right\n)\n</code></pre> <p>Performs a logical-and (conjunction) between two BoolStatus values. </p> <p>If one of the arguments is BoolStatus::kFalse, then the result is BoolStatus::kFalse. If both arguments are BoolStatus::kTrue, then the result is BoolStatus::kTrue. Otherwise, at least one argument is BoolStatus::kUnknown, and the result is BoolStatus::kUnknown. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_41","title":"function operator!","text":"<pre><code>inline constexpr BoolStatus operator!(\nBoolStatus b\n)\n</code></pre> <p>Performs a logical-not (negation) for the given BoolStatus value. </p> <p>If b is kUnknown, then the result is also kUnknown. Otherwise kFalse becomes kTrue and vice versa. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_42","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst BoolStatus &amp; t\n)\n</code></pre> <p>Prints a BoolStatus value. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound","title":"function least_upper_bound","text":"<pre><code>inline i8 least_upper_bound(\ni8 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound","title":"function greatest_lower_bound","text":"<pre><code>inline i8 greatest_lower_bound(\ni8 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_1","title":"function least_upper_bound","text":"<pre><code>inline i16 least_upper_bound(\ni16 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_1","title":"function greatest_lower_bound","text":"<pre><code>inline i16 greatest_lower_bound(\ni16 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_2","title":"function least_upper_bound","text":"<pre><code>inline i32 least_upper_bound(\ni32 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_2","title":"function greatest_lower_bound","text":"<pre><code>inline i32 greatest_lower_bound(\ni32 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_3","title":"function least_upper_bound","text":"<pre><code>inline i64 least_upper_bound(\ni64 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_3","title":"function greatest_lower_bound","text":"<pre><code>inline i64 greatest_lower_bound(\ni64 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_4","title":"function least_upper_bound","text":"<pre><code>inline u8 least_upper_bound(\nu8 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_4","title":"function greatest_lower_bound","text":"<pre><code>inline u8 greatest_lower_bound(\nu8 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_5","title":"function least_upper_bound","text":"<pre><code>inline u16 least_upper_bound(\nu16 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_5","title":"function greatest_lower_bound","text":"<pre><code>inline u16 greatest_lower_bound(\nu16 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_6","title":"function least_upper_bound","text":"<pre><code>inline u32 least_upper_bound(\nu32 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_6","title":"function greatest_lower_bound","text":"<pre><code>inline u32 greatest_lower_bound(\nu32 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_7","title":"function least_upper_bound","text":"<pre><code>inline u64 least_upper_bound(\nu64 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_7","title":"function greatest_lower_bound","text":"<pre><code>inline u64 greatest_lower_bound(\nu64 n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-least_upper_bound_8","title":"function least_upper_bound","text":"<pre><code>template &lt;typename T &gt;\nLeastUpperBound&lt; std::decay_t&lt; T &gt; &gt; least_upper_bound(\nT &amp;&amp; value\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_43","title":"function operator&lt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;(\nconst T &amp; left,\nconst LeastUpperBound&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_44","title":"function operator&lt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;(\nconst LeastUpperBound&lt; T &gt; &amp; left,\nconst U &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_45","title":"function operator&lt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;(\nconst LeastUpperBound&lt; T &gt; &amp; left,\nconst LeastUpperBound&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_46","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst T &amp; ,\nconst LeastUpperBound&lt; U &gt; &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_47","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst LeastUpperBound&lt; T &gt; &amp; ,\nconst U &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_48","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst LeastUpperBound&lt; T &gt; &amp; left,\nconst LeastUpperBound&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_49","title":"function operator&gt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;(\nconst T &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_50","title":"function operator&lt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;=(\nconst T &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_51","title":"function operator&gt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;=(\nconst T &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_52","title":"function operator&gt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_53","title":"function operator&lt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;=(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_54","title":"function operator&gt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;=(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_55","title":"function operator&gt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_56","title":"function operator&lt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;=(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_57","title":"function operator&gt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;=(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_58","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst T &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_59","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_60","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst LeastUpperBound&lt; T &gt; &amp; l,\nconst LeastUpperBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-greatest_lower_bound_8","title":"function greatest_lower_bound","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\nGreatestLowerBound&lt; std::decay_t&lt; T &gt; &gt; greatest_lower_bound(\nT &amp;&amp; value\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_61","title":"function operator&lt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;(\nconst T &amp; left,\nconst GreatestLowerBound&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_62","title":"function operator&lt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;(\nconst GreatestLowerBound&lt; T &gt; &amp; left,\nconst U &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_63","title":"function operator&lt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;(\nconst GreatestLowerBound&lt; T &gt; &amp; left,\nconst GreatestLowerBound&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_64","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst T &amp; ,\nconst GreatestLowerBound&lt; U &gt; &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_65","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst GreatestLowerBound&lt; T &gt; &amp; ,\nconst U &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_66","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator==(\nconst GreatestLowerBound&lt; T &gt; &amp; left,\nconst GreatestLowerBound&lt; U &gt; &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_67","title":"function operator&gt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;(\nconst T &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_68","title":"function operator&lt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;=(\nconst T &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_69","title":"function operator&gt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;=(\nconst T &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_70","title":"function operator&gt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_71","title":"function operator&lt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;=(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_72","title":"function operator&gt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;=(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_73","title":"function operator&gt;","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_74","title":"function operator&lt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&lt;=(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_75","title":"function operator&gt;=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator&gt;=(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_76","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst T &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_77","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst U &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_78","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst GreatestLowerBound&lt; T &gt; &amp; l,\nconst GreatestLowerBound&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_buffer","title":"function make_buffer","text":"<pre><code>template &lt;typename... Args&gt;\ndecltype(auto) make_buffer(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-buffer_from_struct","title":"function buffer_from_struct","text":"<pre><code>template &lt;typename T &gt;\ninline ConstBuffer buffer_from_struct(\nconst T &amp; val\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_str","title":"function as_str","text":"<pre><code>inline std::string_view as_str(\nconst ConstBuffer &amp; buffer\n)\n</code></pre> <p>Converts a ConstBuffer into an equivalent std::string_view. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-bytes_from_struct","title":"function bytes_from_struct","text":"<pre><code>template &lt;typename T &gt;\ninline std::string_view bytes_from_struct(\nconst T &amp; val\n)\n</code></pre> <p>Returns a std::string_view with the same size and data address as the passed object, as if the address of <code>val</code> had been reinterpret_cast to type <code>const char*</code>. </p> <p>Should only be used for types used to define serialized data layouts. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-mutable_buffer_from_struct","title":"function mutable_buffer_from_struct","text":"<pre><code>template &lt;typename T &gt;\ninline MutableBuffer mutable_buffer_from_struct(\nT &amp; val\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-resize_buffer","title":"function resize_buffer","text":"<pre><code>inline ConstBuffer resize_buffer(\nconst ConstBuffer &amp; b,\nusize s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-resize_buffer_1","title":"function resize_buffer","text":"<pre><code>inline MutableBuffer resize_buffer(\nconst MutableBuffer &amp; b,\nusize s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-slice_buffer","title":"function slice_buffer","text":"<pre><code>template &lt;typename SizeT &gt;\ninline ConstBuffer slice_buffer(\nconst ConstBuffer &amp; b,\nconst Interval&lt; SizeT &gt; &amp; slice\n)\n</code></pre> <p>Select a subset of the passed buffer according to the passed interval. </p> <p>Parameters: </p> <ul> <li>b The buffer to slice </li> <li>slice Defines the start (inclusive) and end (non-inclusive) of the slice within buffer </li> </ul>"},{"location":"_autogen/Namespaces/namespacebatt/#function-slice_buffer_1","title":"function slice_buffer","text":"<pre><code>template &lt;typename SizeT &gt;\ninline MutableBuffer slice_buffer(\nconst MutableBuffer &amp; b,\nconst Interval&lt; SizeT &gt; &amp; slice\n)\n</code></pre> <p>Select a subset of the passed buffer according to the passed interval. </p> <p>Parameters: </p> <ul> <li>b The buffer to slice </li> <li>slice Defines the start (inclusive) and end (non-inclusive) of the slice within buffer </li> </ul>"},{"location":"_autogen/Namespaces/namespacebatt/#function-consume_buffers","title":"function consume_buffers","text":"<pre><code>template &lt;typename VecT &gt;\ninline void consume_buffers(\nVecT &amp; buffers,\nusize count\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-consume_buffers_iter","title":"function consume_buffers_iter","text":"<pre><code>template &lt;typename Iter &gt;\ninline std::pair&lt; Iter, usize &gt; consume_buffers_iter(\nconst std::pair&lt; Iter, usize &gt; &amp; pos,\nconst Iter &amp; last,\nusize count\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-consume_buffers_copy","title":"function consume_buffers_copy","text":"<pre><code>template &lt;typename VecT &gt;\ninline VecT consume_buffers_copy(\nconst VecT &amp; buffers,\nusize count\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-array_from_c_str","title":"function array_from_c_str","text":"<pre><code>template &lt;usize kLength,\nusize... kIndex&gt;\nconstexpr std::array&lt; char, kLength - 1 &gt; array_from_c_str(\nconst char(&amp;) c_str[kLength],\nstd::index_sequence&lt; kIndex... &gt; )\n</code></pre> <p>Converts a compile-time string constant to std::array, automatically inferring the string length (without the null-terminator)."},{"location":"_autogen/Namespaces/namespacebatt/#function-array_from_c_str_1","title":"function array_from_c_str","text":"<pre><code>template &lt;usize kLength&gt;\nconstexpr std::array&lt; char, kLength - 1 &gt; array_from_c_str(\nconst char(&amp;) c_str[kLength]\n)\n</code></pre> <p>Converts a compile-time string constant to std::array, automatically inferring the string length (without the null-terminator)."},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst ConstBuffer &amp; buffer\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_1","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst MutableBuffer &amp; buffer\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_2","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst std::string_view &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_3","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst std::string &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_4","title":"function as_const_buffer","text":"<pre><code>template &lt;usize kSize&gt;\ninline ConstBuffer as_const_buffer(\nconst std::array&lt; char, kSize &gt; &amp; arr\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_5","title":"function as_const_buffer","text":"<pre><code>template &lt;usize kSize&gt;\ninline ConstBuffer as_const_buffer(\nconst std::array&lt; u8, kSize &gt; &amp; arr\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_6","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst std::vector&lt; char &gt; &amp; vec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_7","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst std::vector&lt; u8 &gt; &amp; vec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_8","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst SmallVecBase&lt; char &gt; &amp; vec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_9","title":"function as_const_buffer","text":"<pre><code>inline ConstBuffer as_const_buffer(\nconst SmallVecBase&lt; u8 &gt; &amp; vec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_buffer_10","title":"function as_const_buffer","text":"<pre><code>template &lt;usize kLength&gt;\ninline ConstBuffer as_const_buffer(\nconst char(&amp;) c_str[kLength]\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_case_of_visitor","title":"function make_case_of_visitor","text":"<pre><code>template &lt;typename... Cases&gt;\nCaseOfVisitor&lt; Cases &amp;&amp;... &gt; make_case_of_visitor(\nCases &amp;&amp;... cases\n)\n</code></pre> <p>Constructs and returns a single overloaded callable function object that forwards its arguments on to the first object in <code>cases</code> that is callable with those arguments. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-case_of","title":"function case_of","text":"<pre><code>template &lt;typename VarType ,\ntypename... Cases&gt;\ndecltype(auto) case_of(\nVarType &amp;&amp; v,\nCases &amp;&amp;... cases\n)\n</code></pre> <p>Matches a variant against a list of callables and apply the first one that will accept the current value. </p> <p>Example: ```cpp</p> <p>std::variant var = Bar{}; <p>int result = batt::case_of(   var,    {       return 1;   },    {       return 2;   });</p> <p>BATT_CHECK_EQ(result, 2); <pre><code>### function is_case\n\n```cpp\ntemplate &lt;typename T ,\ntypename Var &gt;\nbool is_case(\n    Var &amp;&amp; v\n)\n</code></pre></p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-checked_cast","title":"function checked_cast","text":"<pre><code>template &lt;typename ToType ,\ntypename FromType ,\ntypename  =std::enable_if_t&lt;std::is_signed_v&lt;ToType&gt; == std::is_signed_v&lt;FromType&gt;&gt;&gt;\nToType checked_cast(\nFromType val,\nconst char * file =\"\",\nint line =0\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-checked_cast_1","title":"function checked_cast","text":"<pre><code>template &lt;typename ToType ,\ntypename FromType ,\ntypename  =std::enable_if_t&lt;std::is_signed_v&lt;ToType&gt; &amp;&amp; !std::is_signed_v&lt;FromType&gt;&gt;,\ntypename  =void&gt;\nToType checked_cast(\nFromType val,\nconst char * file =\"\",\nint line =0\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-checked_cast_2","title":"function checked_cast","text":"<pre><code>template &lt;typename ToType ,\ntypename FromType ,\ntypename  =std::enable_if_t&lt;!std::is_signed_v&lt;ToType&gt; &amp;&amp; std::is_signed_v&lt;FromType&gt;&gt;,\ntypename  =void,\ntypename  =void&gt;\nToType checked_cast(\nFromType val,\nconst char * file =\"\",\nint line =0\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_79","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nOrder t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-compare","title":"function compare","text":"<pre><code>inline Order compare(\nconst std::string_view &amp; a,\nconst std::string_view &amp; b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_80","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst CpuCacheLineIsolated&lt; T &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pin_thread_to_cpu","title":"function pin_thread_to_cpu","text":"<pre><code>inline Status pin_thread_to_cpu(\nusize cpu_i\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pin_thread_to_cpu_set","title":"function pin_thread_to_cpu_set","text":"<pre><code>template &lt;typename IntRange &gt;\ninline Status pin_thread_to_cpu_set(\nconst IntRange &amp; cpu_i_set\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pin_thread_i_of_config","title":"function pin_thread_i_of_config","text":"<pre><code>inline Status pin_thread_i_of_config(\nusize i,\nconst ThreadPoolConfig &amp; config,\nconst std::string_view &amp; pool_name =\"\"\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-do_nothing","title":"function do_nothing","text":"<pre><code>template &lt;typename... Args&gt;\nconstexpr void do_nothing(\nArgs &amp;&amp; ...\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-big_endian_less_than","title":"function big_endian_less_than","text":"<pre><code>inline bool big_endian_less_than(\nBOOST_PP_CAT(u, 16) a,\nBOOST_PP_CAT(u, 16) b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-big_endian_less_than_1","title":"function big_endian_less_than","text":"<pre><code>inline bool big_endian_less_than(\nBOOST_PP_CAT(u, 32) a,\nBOOST_PP_CAT(u, 32) b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-big_endian_less_than_2","title":"function big_endian_less_than","text":"<pre><code>inline bool big_endian_less_than(\nBOOST_PP_CAT(u, 64) a,\nBOOST_PP_CAT(u, 64) b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-getenv_as","title":"function getenv_as","text":"<pre><code>template &lt;typename T &gt;\nOptional&lt; T &gt; getenv_as(\nconst char * var_name\n)\n</code></pre> <p>Parse environment variable as a given type <code>T</code>. </p> <p>Parameters: </p> <ul> <li>var_name The environment variable name</li> </ul> <p>Return: The parsed value if <code>var_name</code> is found and it parses correctly, else batt::None. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-finally","title":"function finally","text":"<pre><code>template &lt;typename Fn &gt;\nauto finally(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash","title":"function hash","text":"<pre><code>inline usize hash()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_1","title":"function hash","text":"<pre><code>template &lt;typename T &gt;\nusize hash(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value_1","title":"function hash_value","text":"<pre><code>template &lt;typename T ,\ntypename HashT  =typename std::decay_t&lt;T&gt;::Hash&gt;\nusize hash_value(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_2","title":"function hash","text":"<pre><code>template &lt;typename First ,\ntypename... Rest&gt;\nusize hash(\nFirst &amp;&amp; first,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-await_resolve","title":"function await_resolve","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; boost::asio::ip::tcp::endpoint &gt; &gt; await_resolve(\nboost::asio::ip::tcp::resolver &amp; resolver,\nconst HostAddress &amp; host_address\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-await_resolve_1","title":"function await_resolve","text":"<pre><code>inline StatusOr&lt; SmallVec&lt; boost::asio::ip::tcp::endpoint &gt; &gt; await_resolve(\nboost::asio::io_context &amp; io,\nconst HostAddress &amp; host_address\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value_2","title":"function hash_value","text":"<pre><code>inline usize hash_value(\nconst HostAddress &amp; host_key\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_81","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst HostAddress &amp; l,\nconst HostAddress &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_82","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst HostAddress &amp; l,\nconst HostAddress &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_83","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst HostAddress &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_encode_chunked","title":"function http_encode_chunked","text":"<pre><code>template &lt;typename Src ,\ntypename AsyncWriteStream &gt;\ninline Status http_encode_chunked(\nSrc &amp;&amp; src,\nAsyncWriteStream &amp;&amp; dst,\nIncludeHttpTrailer include_trailer =IncludeHttpTrailer{false}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_request","title":"function http_request","text":"<pre><code>template &lt;typename... Params&gt;\nStatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_request(\nstd::string_view method,\nstd::string_view url,\nParams &amp;&amp;... params\n)\n</code></pre> <p>Submits an HTTP request, returning the response object. </p> <p><code>params</code> must be from the following set:</p> <ul> <li>HttpHeader: sets a custom Http message header name/value pair</li> <li>HttpData: (PUT/POST requests) sets a BufferSource containing the message body</li> <li>HttpClient: specifies the HttpClient to use (default is DefaultHttpClient::get())</li> <li>HttpResponse*: sets the HttpResponse object to use (default is to allocate a new HttpResponse object); if this option is set, then this function will return <code>nullptr</code> on success.</li> <li>HttpVersion: sets the HTTP protocol version to use. Must be &lt;= 1.1 </li> </ul>"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_get","title":"function http_get","text":"<pre><code>template &lt;typename... Params&gt;\nStatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_get(\nstd::string_view url,\nParams &amp;&amp;... params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_post","title":"function http_post","text":"<pre><code>template &lt;typename... Params&gt;\nStatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_post(\nstd::string_view url,\nParams &amp;&amp;... params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_put","title":"function http_put","text":"<pre><code>template &lt;typename... Params&gt;\nStatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_put(\nstd::string_view url,\nParams &amp;&amp;... params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-http_delete","title":"function http_delete","text":"<pre><code>template &lt;typename... Params&gt;\nStatusOr&lt; std::unique_ptr&lt; HttpResponse &gt; &gt; http_delete(\nstd::string_view url,\nParams &amp;&amp;... params\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-strong_typedef_default_value_8","title":"function strong_typedef_default_value","text":"<pre><code>inline constexpr bool strong_typedef_default_value(\nIncludeHttpTrailer_TAG * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-find_header","title":"function find_header","text":"<pre><code>inline Optional&lt; std::string_view &gt; find_header(\nconst SmallVecBase&lt; HttpHeader &gt; &amp; headers,\nconst std::string_view &amp; name\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_84","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst HttpMessageInfo &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_back","title":"function push_back","text":"<pre><code>template &lt;typename TraitsT ,\ntypename DeltaT &gt;\nBasicInterval&lt; TraitsT &gt; push_back(\nconst BasicInterval&lt; TraitsT &gt; &amp; i,\nDeltaT delta\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-push_front","title":"function push_front","text":"<pre><code>template &lt;typename TraitsT ,\ntypename DeltaT &gt;\nBasicInterval&lt; TraitsT &gt; push_front(\nconst BasicInterval&lt; TraitsT &gt; &amp; i,\nDeltaT delta\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pop_back","title":"function pop_back","text":"<pre><code>template &lt;typename TraitsT ,\ntypename DeltaT &gt;\nBasicInterval&lt; TraitsT &gt; pop_back(\nconst BasicInterval&lt; TraitsT &gt; &amp; i,\nDeltaT delta\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pop_front","title":"function pop_front","text":"<pre><code>template &lt;typename TraitsT ,\ntypename DeltaT &gt;\nBasicInterval&lt; TraitsT &gt; pop_front(\nconst BasicInterval&lt; TraitsT &gt; &amp; i,\nDeltaT delta\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_interval","title":"function make_interval","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\nBasicInterval&lt; IClosedOpen&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; U &gt; &gt; &gt; make_interval(\nT &amp;&amp; lower,\nU &amp;&amp; upper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_85","title":"function operator==","text":"<pre><code>template &lt;typename TraitsL ,\ntypename TraitsR &gt;\ninline bool operator==(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_86","title":"function operator!=","text":"<pre><code>template &lt;typename TraitsL ,\ntypename TraitsR &gt;\ninline bool operator!=(\nconst BasicInterval&lt; TraitsL &gt; &amp; l,\nconst BasicInterval&lt; TraitsR &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_87","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename Traits &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst BasicInterval&lt; Traits &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-interval_traits_compatible","title":"function interval_traits_compatible","text":"<pre><code>template &lt;typename Traits0 ,\ntypename Traits1 &gt;\ninline constexpr bool interval_traits_compatible()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable","title":"function make_printable","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;IsPrintable&lt;T&gt;{}&gt;&gt;\ndecltype(auto) make_printable(\nT &amp;&amp; obj\n)\n</code></pre> <p>Returns a std::ostream-printable representation of the argument, <code>obj</code>. </p> <p>This overload is selected for types that support an overloaded <code>operator&lt;&lt;</code> for std::ostream. It simply forwards the argument as the return value. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_1","title":"function make_printable","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;!IsPrintable&lt;T&gt;{}&gt;,\ntypename  =void&gt;\nstd::string make_printable(\nT &amp;&amp; obj\n)\n</code></pre> <p>Returns a std::ostream-printable representation of the argument, <code>obj</code>. </p> <p>This overload is selected for all types that do not support an overloaded <code>operator&lt;&lt;</code> for std::ostream. It prints the name of the type (demangled), and a hex representation of the bytes of the object itself. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-log2_ceil","title":"function log2_ceil","text":"<pre><code>inline constexpr i32 log2_ceil(\nu64 i\n)\n</code></pre> <p>Returns log_2(i), rounded down to the nearest integer. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-log2_floor","title":"function log2_floor","text":"<pre><code>inline constexpr i32 log2_floor(\nu64 i\n)\n</code></pre> <p>Returns log_2(i), rounded down to the nearest integer. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-lsb_mask","title":"function lsb_mask","text":"<pre><code>template &lt;typename IntT &gt;\ninline constexpr IntT lsb_mask(\ni32 bits\n)\n</code></pre> <p>Least Significant Bits Mask. </p> <p>Returns a value of type IntT with <code>bits</code> ones as the least significant bits, and zeros for all other bits. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-round_down_bits","title":"function round_down_bits","text":"<pre><code>template &lt;typename IntT &gt;\ninline constexpr IntT round_down_bits(\ni32 bits,\nIntT n\n)\n</code></pre> <p>Rounds an integer value down to the nearest multiple of 2^bits. </p> <p>For example, round_down_bits(8, n) will round n down to the nearest multiple of 256; if n is already a multiple of 256, it will return n. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-round_up_bits","title":"function round_up_bits","text":"<pre><code>template &lt;typename IntT &gt;\ninline constexpr IntT round_up_bits(\ni32 bits,\nIntT n\n)\n</code></pre> <p>Rounds an integer value up to the nearest multiple of 2^bits. </p> <p>For example, round_up_bits(8, n) will round n up to the nearest multiple of 256; if n is already a multiple of 256, it will return n. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-round_down_to","title":"function round_down_to","text":"<pre><code>template &lt;typename IntT &gt;\ninline constexpr IntT round_down_to(\nIntT unit,\nIntT n\n)\n</code></pre> <p>Rounds <code>n</code> down to the nearest multiple of <code>unit</code>. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-round_up_to","title":"function round_up_to","text":"<pre><code>template &lt;typename IntT &gt;\ninline constexpr IntT round_up_to(\nIntT unit,\nIntT n\n)\n</code></pre> <p>Rounds <code>n</code> up to the nearest multiple of <code>unit</code>. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-ipow","title":"function ipow","text":"<pre><code>template &lt;typename IntT &gt;\ninline constexpr IntT ipow(\nIntT base,\nIntT exponent,\nIntT accumulator =static_cast&lt; IntT &gt;(1)\n)\n</code></pre> <p>Compile-time integer exponentiation. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-bit_count","title":"function bit_count","text":"<pre><code>inline i32 bit_count(\nu64 n\n)\n</code></pre> <p>Returns the number of set (1) bits in the passed integer. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_88","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst LatencyMetric &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-normalize_labels","title":"function normalize_labels","text":"<pre><code>inline MetricLabelSet normalize_labels(\nMetricLabelSet &amp;&amp; labels\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-global_metric_registry","title":"function global_metric_registry","text":"<pre><code>inline MetricRegistry &amp; global_metric_registry()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_nullable","title":"function make_nullable","text":"<pre><code>template &lt;typename T &gt;\nauto make_nullable(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_89","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst NoneType &amp; ,\nconst NoneType &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_90","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst NoneType &amp; ,\nconst NoneType &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_91","title":"function operator==","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\ninline bool operator==(\nconst Optional&lt; T0 &gt; &amp; v0,\nconst Optional&lt; T1 &gt; &amp; v1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_92","title":"function operator!=","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\ninline bool operator!=(\nconst Optional&lt; T0 &gt; &amp; v0,\nconst Optional&lt; T1 &gt; &amp; v1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_93","title":"function operator==","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\ninline bool operator==(\nconst Optional&lt; T0 &gt; &amp; v0,\nconst T1 &amp; v1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_94","title":"function operator!=","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\ninline bool operator!=(\nconst Optional&lt; T0 &gt; &amp; v0,\nconst T1 &amp; v1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_95","title":"function operator==","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\ninline bool operator==(\nconst T0 &amp; v0,\nconst Optional&lt; T1 &gt; &amp; v1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_96","title":"function operator!=","text":"<pre><code>template &lt;typename T0 ,\ntypename T1 &gt;\ninline bool operator!=(\nconst T0 &amp; v0,\nconst Optional&lt; T1 &gt; &amp; v1\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_97","title":"function operator==","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator==(\nNoneType ,\nconst Optional&lt; T &gt; &amp; v\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_98","title":"function operator!=","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator!=(\nNoneType ,\nconst Optional&lt; T &gt; &amp; v\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_99","title":"function operator==","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator==(\nconst Optional&lt; T &gt; &amp; v,\nNoneType )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_100","title":"function operator!=","text":"<pre><code>template &lt;typename T &gt;\ninline bool operator!=(\nconst Optional&lt; T &gt; &amp; v,\nNoneType )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_101","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Optional&lt; T &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_102","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst NoneType &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_optional","title":"function make_optional","text":"<pre><code>template &lt;typename T &gt;\nOptional&lt; std::decay_t&lt; T &gt; &gt; make_optional(\nT &amp;&amp; val\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_or_panic","title":"function get_or_panic","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) get_or_panic(\nOptional&lt; T &gt; &amp; opt\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_or_panic_1","title":"function get_or_panic","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) get_or_panic(\nconst Optional&lt; T &gt; &amp; opt\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-get_or_panic_2","title":"function get_or_panic","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) get_or_panic(\nOptional&lt; T &gt; &amp;&amp; opt\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_103","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;usize N_&gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst RadixQueue&lt; N_ &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_104","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Ref&lt; T &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_ref","title":"function as_ref","text":"<pre><code>template &lt;typename T &gt;\nRef&lt; T &gt; as_ref(\nT &amp; obj_ref\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_cref","title":"function as_cref","text":"<pre><code>template &lt;typename T &gt;\nRef&lt; const T &gt; as_cref(\nconst T &amp; obj_ref\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_ref","title":"function into_ref","text":"<pre><code>template &lt;typename T &gt;\nRef&lt; T &gt; into_ref(\nT * ptr\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_cref","title":"function into_cref","text":"<pre><code>template &lt;typename T &gt;\nRef&lt; const T &gt; into_cref(\nconst T * ptr\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nRef&lt; T &gt; &amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_1","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nRef&lt; T &gt; const &amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_2","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nRef&lt; T &gt; &amp;&amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_3","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nRef&lt; T &gt; const &amp;&amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-extra_segv_debug_info_callback","title":"function extra_segv_debug_info_callback","text":"<pre><code>inline std::atomic&lt; PrintToStreamFunctionPointer &gt; &amp; extra_segv_debug_info_callback()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_stack_trace","title":"function print_stack_trace","text":"<pre><code>inline void print_stack_trace()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_stack_trace_atexit_enabled","title":"function print_stack_trace_atexit_enabled","text":"<pre><code>inline bool &amp; print_stack_trace_atexit_enabled()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_stack_trace_atexit","title":"function print_stack_trace_atexit","text":"<pre><code>inline void print_stack_trace_atexit()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-has_seq_requirements","title":"function has_seq_requirements","text":"<pre><code>template &lt;typename T &gt;\ninline constexpr bool has_seq_requirements(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-skip_n","title":"function skip_n","text":"<pre><code>inline SkipNBinder skip_n(\nusize n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_105","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename  =EnableIfSeq&lt;Seq&gt;&gt;\nSkipN&lt; Seq &gt; operator|(\nSeq &amp;&amp; seq,\nconst SkipNBinder &amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq","title":"function as_seq","text":"<pre><code>template &lt;typename T ,\ntypename  =decltype(std::declval&lt;T&gt;().front()),\ntypename  =decltype(std::declval&lt;T&gt;().drop_front())&gt;\nSubRangeSeq&lt; T &gt; as_seq(\nT &amp;&amp; sub_range\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_1","title":"function as_seq","text":"<pre><code>template &lt;typename ForwardIter &gt;\nauto as_seq(\nForwardIter &amp;&amp; begin,\nForwardIter &amp;&amp; end\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_2","title":"function as_seq","text":"<pre><code>template &lt;typename VectorLike ,\ntypename  =decltype(std::declval&lt;VectorLike&gt;().data()),\ntypename  =decltype(std::declval&lt;VectorLike&gt;().size())&gt;\nauto as_seq(\nVectorLike &amp;&amp; v\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-vec_range","title":"function vec_range","text":"<pre><code>template &lt;typename T ,\ntypename Begin  =decltype(std::declval&lt;const T&amp;&gt;().data()),\ntypename End  =decltype(std::declval&lt;Begin&gt;() + std::declval&lt;const T&amp;&gt;().size()),\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;Begin, End&gt;&gt;&gt;\nauto vec_range(\nconst T &amp; vec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_seq","title":"function into_seq","text":"<pre><code>template &lt;typename T &gt;\nauto into_seq(\nstd::vector&lt; T &gt; &amp;&amp; v\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-seq_ref","title":"function seq_ref","text":"<pre><code>template &lt;typename SeqT &gt;\nSeqRef&lt; SeqT &gt; seq_ref(\nSeqT &amp; seq\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_shared","title":"function make_shared","text":"<pre><code>template &lt;typename T ,\ntypename... Args,\ntypename  =std::enable_if_t&lt;IsRefCounted&lt;T&gt;{}&gt;&gt;\nSharedPtr&lt; T &gt; make_shared(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_shared_1","title":"function make_shared","text":"<pre><code>template &lt;typename T ,\ntypename... Args,\ntypename  =std::enable_if_t&lt;!IsRefCounted&lt;T&gt;{}&gt;,\ntypename  =void&gt;\nSharedPtr&lt; T &gt; make_shared(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-into_shared","title":"function into_shared","text":"<pre><code>template &lt;typename T &gt;\nSharedPtr&lt; T &gt; into_shared(\nstd::unique_ptr&lt; T &gt; &amp;&amp; ptr\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-shared_ptr_from","title":"function shared_ptr_from","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;                          std::is_same_v&lt;SharedPtr&lt;T&gt;, std::shared_ptr&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;&gt;&gt;\nSharedPtr&lt; T &gt; shared_ptr_from(\nT * that\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-shared_ptr_from_1","title":"function shared_ptr_from","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;              std::is_same_v&lt;SharedPtr&lt;T&gt;, boost::intrusive_ptr&lt;std::remove_reference_t&lt;T&gt;&gt;&gt;&gt;,\ntypename  =void&gt;\nSharedPtr&lt; T &gt; shared_ptr_from(\nT * that\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice","title":"function as_slice","text":"<pre><code>template &lt;typename T ,\ntypename DataT  =decltype(std::declval&lt;T&gt;().data()),\ntypename  =std::enable_if_t&lt;std::is_pointer_v&lt;DataT&gt;&gt;,\ntypename ElementT  =typename std::pointer_traits&lt;DataT&gt;::element_type&gt;\nSlice&lt; ElementT &gt; as_slice(\nT &amp;&amp; container\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice_1","title":"function as_slice","text":"<pre><code>template &lt;typename ElementT &gt;\nSlice&lt; ElementT &gt; as_slice(\nElementT * begin,\nElementT * end\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice_2","title":"function as_slice","text":"<pre><code>template &lt;typename ElementT &gt;\nSlice&lt; ElementT &gt; as_slice(\nElementT * begin,\nusize size\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_slice_3","title":"function as_slice","text":"<pre><code>template &lt;typename ElementT &gt;\nSlice&lt; ElementT &gt; as_slice(\nconst Slice&lt; ElementT &gt; &amp; slice\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_slice","title":"function as_const_slice","text":"<pre><code>template &lt;typename ElementT &gt;\nSlice&lt; const ElementT &gt; as_const_slice(\nconst ElementT * begin,\nconst ElementT * end\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_slice_1","title":"function as_const_slice","text":"<pre><code>template &lt;typename ElementT &gt;\nSlice&lt; const ElementT &gt; as_const_slice(\nconst ElementT * begin,\nusize size\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_const_slice_2","title":"function as_const_slice","text":"<pre><code>template &lt;typename T ,\ntypename DataT  =decltype(std::declval&lt;const T&amp;&gt;().data()),\ntypename  =std::enable_if_t&lt;std::is_pointer_v&lt;DataT&gt;&gt;,\ntypename ElementT  =typename std::pointer_traits&lt;DataT&gt;::element_type&gt;\nSlice&lt; const ElementT &gt; as_const_slice(\nconst T &amp; container\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-empty_slice","title":"function empty_slice","text":"<pre><code>template &lt;typename ElementT &gt;\nSlice&lt; ElementT &gt; empty_slice(\nStaticType&lt; ElementT &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_3","title":"function as_seq","text":"<pre><code>template &lt;typename T &gt;\nSubRangeSeq&lt; Slice&lt; T &gt; &gt; as_seq(\nconst Slice&lt; T &gt; &amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_4","title":"function as_seq","text":"<pre><code>template &lt;typename T &gt;\nauto as_seq(\nSlice&lt; T &gt; &amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_5","title":"function as_seq","text":"<pre><code>template &lt;typename T &gt;\nauto as_seq(\nSlice&lt; T &gt; &amp;&amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_seq_6","title":"function as_seq","text":"<pre><code>template &lt;typename T &gt;\nauto as_seq(\nconst Slice&lt; T &gt; &amp;&amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_range","title":"function as_range","text":"<pre><code>template &lt;typename Iter &gt;\nboost::iterator_range&lt; Iter &gt; as_range(\nconst std::pair&lt; Iter, Iter &gt; &amp; p\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-slice_range","title":"function slice_range","text":"<pre><code>template &lt;typename RangeT ,\ntypename Iter  =std::decay_t&lt;decltype(boost::begin(std::declval&lt;RangeT&gt;()))&gt;,\ntypename OffsetT ,\ntypename  =std::enable_if_t&lt;std::is_integral_v&lt;OffsetT&gt;&gt;&gt;\nboost::iterator_range&lt; Iter &gt; slice_range(\nRangeT &amp;&amp; range,\nconst Interval&lt; OffsetT &gt; &amp; i\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-copy_string","title":"function copy_string","text":"<pre><code>inline void copy_string(\nSmallVecBase&lt; char &gt; &amp; dst,\nconst std::string_view &amp; src\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-as_str_1","title":"function as_str","text":"<pre><code>inline std::string_view as_str(\nconst SmallVecBase&lt; char &gt; &amp; v\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_106","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename StateT ,\ntypename StateHash ,\ntypename StateEqual &gt;\ninline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_107","title":"function operator==","text":"<pre><code>template &lt;typename StateT ,\ntypename StateHash ,\ntypename StateEqual &gt;\ninline bool operator==(\nconst StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; l,\nconst StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-hash_value_3","title":"function hash_value","text":"<pre><code>template &lt;typename StateT ,\ntypename StateHash ,\ntypename StateEqual &gt;\ninline usize hash_value(\nconst StateMachineBranch&lt; StateT, StateHash, StateEqual &gt; &amp; branch\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-combine_results","title":"function combine_results","text":"<pre><code>inline StateMachineResult combine_results(\nconst StateMachineResult &amp; a,\nconst StateMachineResult &amp; b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_108","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst StateMachineResult &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-static_dispatch","title":"function static_dispatch","text":"<pre><code>template &lt;typename IntT ,\nIntT kBegin,\nIntT kEnd,\ntypename Fn ,\ntypename R  =decltype(std::declval&lt;Fn&gt;()(std::integral_constant&lt;IntT, kBegin&gt;{}))&gt;\nR static_dispatch(\nIntT i,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-static_dispatch_1","title":"function static_dispatch","text":"<pre><code>template &lt;typename Fn &gt;\ndecltype(auto) static_dispatch(\nbool b,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-static_dispatch_2","title":"function static_dispatch","text":"<pre><code>template &lt;typename Tuple ,\ntypename Fn &gt;\ndecltype(auto) static_dispatch(\nstd::size_t i,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_109","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Status &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_110","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst Status &amp; l,\nconst Status &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_111","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst Status &amp; l,\nconst Status &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-okstatus","title":"function OkStatus","text":"<pre><code>inline Status OkStatus()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_112","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U ,\ntypename  =std::enable_if_t&lt;CanBeEqCompared&lt;T, U&gt;{}&gt;&gt;\ninline bool operator==(\nconst StatusOr&lt; T &gt; &amp; l,\nconst StatusOr&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_113","title":"function operator==","text":"<pre><code>template &lt;typename T ,\ntypename U ,\ntypename  =std::enable_if_t&lt;!CanBeEqCompared&lt;T, U&gt;{}&gt;,\ntypename  =void&gt;\ninline bool operator==(\nconst StatusOr&lt; T &gt; &amp; l,\nconst StatusOr&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_114","title":"function operator!=","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\ninline bool operator!=(\nconst StatusOr&lt; T &gt; &amp; l,\nconst StatusOr&lt; U &gt; &amp; r\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status_2","title":"function is_ok_status","text":"<pre><code>inline bool is_ok_status(\nconst std::error_code &amp; ec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_ok_status_3","title":"function is_ok_status","text":"<pre><code>template &lt;typename T &gt;\nbool is_ok_status(\nconst T &amp; val\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_115","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nLogLevel t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-require_fail_global_default_log_level","title":"function require_fail_global_default_log_level","text":"<pre><code>inline std::atomic&lt; LogLevel &gt; &amp; require_fail_global_default_log_level()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-require_fail_thread_default_log_level","title":"function require_fail_thread_default_log_level","text":"<pre><code>inline Optional&lt; LogLevel &gt; &amp; require_fail_thread_default_log_level()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_from_errno","title":"function status_from_errno","text":"<pre><code>inline Status status_from_errno(\nint code\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_1","title":"function to_status","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;IsStatusOr&lt;T&gt;{} &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusOr&lt;Status&gt;&gt;&gt;&gt;\ninline decltype(auto) to_status(\nT &amp;&amp; v\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_2","title":"function to_status","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, Status&gt; ||                                      std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusOr&lt;Status&gt;&gt;&gt;,\ntypename  =void&gt;\ninline decltype(auto) to_status(\nT &amp;&amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-register_error_category","title":"function register_error_category","text":"<pre><code>template &lt;typename EnumT &gt;\nbool register_error_category(\nconst boost::system::error_category &amp; category,\nconst std::vector&lt; EnumT &gt; &amp; codes,\nbatt::StaticType&lt; EnumT &gt;  ={}\n)\n</code></pre> <p>Registers a custom error_category so that error_code objects that use it can be converted to batt::Status via batt::to_status. </p> <p>Parameters: </p> <ul> <li>category The category to register </li> <li>codes A list of error code values (int or enum type) to register</li> </ul> <p>Return: true (to indicate the registration was successful) </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_from_error_category","title":"function status_from_error_category","text":"<pre><code>inline Status status_from_error_category(\nconst boost::system::error_category &amp; category,\nint code\n)\n</code></pre> <p>Constructs and returns a batt::Status equivalent to the given code in the given category. </p> <p>Return: the registered batt::Status value if code is valid; batt::StatusCode::kUnknown otherwise </p> <p>The passed category must have been registered via batt::register_error_category prior to calling this function.</p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_from_error_code","title":"function status_from_error_code","text":"<pre><code>inline Status status_from_error_code(\nconst boost::system::error_code &amp; ec\n)\n</code></pre> <p>Constructs and returns a batt::Status equivalent to the given error_code. </p> <p>Return: the registered batt::Status value if code is valid; batt::StatusCode::kUnknown otherwise </p> <p>The error_category of the passed object must have been registered via batt::register_error_category prior to calling this function.</p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-error_code_to_status","title":"function error_code_to_status","text":"<pre><code>inline Status error_code_to_status(\nconst std::error_code &amp; ec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-error_code_to_status_1","title":"function error_code_to_status","text":"<pre><code>inline Status error_code_to_status(\nconst boost::system::error_code &amp; ec\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_3","title":"function to_status","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, std::error_code&gt; ||                                      std::is_same_v&lt;std::decay_t&lt;T&gt;, boost::system::error_code&gt;&gt;,\ntypename  =void,\ntypename  =void&gt;\ninline Status to_status(\nconst T &amp; ec\n)\n</code></pre> <p>Converts an error_code (boost::system:: or std::) to a batt::Status value. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_status_4","title":"function to_status","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::basic_errors&gt; ||                                      std::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::netdb_errors&gt; ||                                      std::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::addrinfo_errors&gt; ||                                      std::is_same_v&lt;std::decay_t&lt;T&gt;, boost::asio::error::misc_errors&gt;&gt;,\ntypename  =void,\ntypename  =void,\ntypename  =void&gt;\ninline Status to_status(\nT &amp;&amp; code_value\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_from_retval","title":"function status_from_retval","text":"<pre><code>template &lt;typename T &gt;\ninline Status status_from_retval(\nT retval\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-ok_result_or_panic","title":"function ok_result_or_panic","text":"<pre><code>template &lt;typename T &gt;\ninline T &amp;&amp; ok_result_or_panic(\nStatusOr&lt; T &gt; &amp;&amp; result\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_116","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;IsStatusOr&lt;std::decay_t&lt;T&gt;&gt;{} &amp;&amp;                                                  !std::is_same_v&lt;std::decay_t&lt;T&gt;, StatusOr&lt;Status&gt;&gt;&gt;&gt;\nstd::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nT &amp;&amp; status_or\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-status_is_retryable","title":"function status_is_retryable","text":"<pre><code>inline bool status_is_retryable(\nconst Status &amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_all","title":"function print_all","text":"<pre><code>inline std::ostream &amp; print_all(\nstd::ostream &amp; out\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-print_all_1","title":"function print_all","text":"<pre><code>template &lt;typename First ,\ntypename... Rest&gt;\nstd::ostream &amp; print_all(\nstd::ostream &amp; out,\nFirst &amp;&amp; first,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-extract_all","title":"function extract_all","text":"<pre><code>inline std::istream &amp; extract_all(\nstd::istream &amp; in\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-extract_all_1","title":"function extract_all","text":"<pre><code>template &lt;typename First ,\ntypename... Rest&gt;\nstd::istream &amp; extract_all(\nstd::istream &amp; in,\nFirst &amp;&amp; first,\nRest &amp;&amp;... rest\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-to_string","title":"function to_string","text":"<pre><code>template &lt;typename... Args&gt;\nstd::string to_string(\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-from_string","title":"function from_string","text":"<pre><code>template &lt;typename T ,\ntypename... FormatArgs&gt;\nstd::optional&lt; T &gt; from_string(\nconst std::string &amp; str,\nFormatArgs &amp;&amp;... format_args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-c_str_literal","title":"function c_str_literal","text":"<pre><code>inline EscapedStringLiteral c_str_literal(\nconst std::string_view &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-c_str_literal_1","title":"function c_str_literal","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_convertible_v&lt;T, std::string_view&gt;&gt;&gt;\ninline Optional&lt; EscapedStringLiteral &gt; c_str_literal(\nconst Optional&lt; T &gt; &amp; maybe_str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-c_str_literal_2","title":"function c_str_literal","text":"<pre><code>inline Optional&lt; EscapedStringLiteral &gt; c_str_literal(\nconst NoneType &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_2","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nstd::string &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_3","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nstd::string &amp;&amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_4","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nconst std::string &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_5","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nconst std::string &amp;&amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_6","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nstd::string_view &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_7","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nstd::string_view &amp;&amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_8","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nconst std::string_view &amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_printable_9","title":"function make_printable","text":"<pre><code>inline decltype(auto) make_printable(\nconst std::string_view &amp;&amp; str\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-stringupperbound","title":"function StringUpperBound","text":"<pre><code>inline const std::string_view &amp; StringUpperBound()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_117","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst EscapedStringLiteral &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_118","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst HexByteDumper &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-dump_hex","title":"function dump_hex","text":"<pre><code>inline HexByteDumper dump_hex(\nconst void * ptr,\nusize size\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_119","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nSizeDumper t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-dump_size","title":"function dump_size","text":"<pre><code>inline SizeDumper dump_size(\nusize n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-dump_size_exact","title":"function dump_size_exact","text":"<pre><code>inline SizeDumper dump_size_exact(\nusize n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parse_byte_size","title":"function parse_byte_size","text":"<pre><code>inline Optional&lt; usize &gt; parse_byte_size(\nstd::string_view s\n)\n</code></pre> <p>Parse a byte size string with optional units. </p> <p>Return: The parse size in bytes if successful, None otherwise. </p> <p>Units can be any of:</p> <ul> <li>'b': bytes</li> <li>'kb': kilobytes (=1024 bytes)</li> <li>'mb': megabytes (=1024 kilobytes)</li> <li>'gb': gigabytes (=1024 megabytes)</li> <li>'tb': terabytes (=1024 gigabytes)</li> <li>'pb': petabytes (=1024 terabtyes)</li> <li>'eb': eitabytes (=1024 petabytes) The unit string may be upper or lower case, and only the first character is considered, so the string \"45k\" will parse the same as \"45KILOBYTES\" or \"45Kb\", etc.</li> </ul> <p>Simple addition and subtraction will also be evaluated, so for example, the string \"16mb-1\" will parse to the value <code>16 * 1024 * 1024 - 1</code>. No space is allowed between additive terms when using this notation.</p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-dump_range","title":"function dump_range","text":"<pre><code>template &lt;typename T &gt;\nRangeDumper&lt; const T &amp; &gt; dump_range(\nconst T &amp; value,\nPretty pretty =Pretty::Default\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-pretty_print_indent","title":"function pretty_print_indent","text":"<pre><code>inline auto pretty_print_indent()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_120","title":"function operator+","text":"<pre><code>template &lt;typename T ,\ntypename Tag ,\ntypename  =std::enable_if_t&lt;batt_strong_typedef_supports_numerics((Tag*)nullptr)&gt;&gt;\nconstexpr StrongType&lt; T, Tag &gt; operator+(\nStrongType&lt; T, Tag &gt; a,\nStrongType&lt; T, Tag &gt; b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator-","title":"function operator-","text":"<pre><code>template &lt;typename T ,\ntypename Tag ,\ntypename  =std::enable_if_t&lt;batt_strong_typedef_supports_numerics((Tag*)nullptr)&gt;&gt;\nconstexpr StrongType&lt; T, Tag &gt; operator-(\nStrongType&lt; T, Tag &gt; a,\nStrongType&lt; T, Tag &gt; b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_121","title":"function operator*","text":"<pre><code>template &lt;typename T ,\ntypename Tag ,\ntypename  =std::enable_if_t&lt;batt_strong_typedef_supports_numerics((Tag*)nullptr)&gt;&gt;\nconstexpr StrongType&lt; T, Tag &gt; operator*(\nStrongType&lt; T, Tag &gt; a,\nStrongType&lt; T, Tag &gt; b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_122","title":"function operator/","text":"<pre><code>template &lt;typename T ,\ntypename Tag ,\ntypename  =std::enable_if_t&lt;batt_strong_typedef_supports_numerics((Tag*)nullptr)&gt;&gt;\nconstexpr StrongType&lt; T, Tag &gt; operator/(\nStrongType&lt; T, Tag &gt; a,\nStrongType&lt; T, Tag &gt; b\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-syscall_retry","title":"function syscall_retry","text":"<pre><code>template &lt;typename Op &gt;\nauto syscall_retry(\nOp &amp;&amp; op\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_123","title":"function operator==","text":"<pre><code>template &lt;typename L ,\ntypename R &gt;\ninline constexpr bool operator==(\nStaticType&lt; L &gt; ,\nStaticType&lt; R &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_124","title":"function operator!=","text":"<pre><code>template &lt;typename L ,\ntypename R &gt;\ninline constexpr bool operator!=(\nStaticType&lt; L &gt; ,\nStaticType&lt; R &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_any_true","title":"function is_any_true","text":"<pre><code>inline constexpr bool is_any_true()\n</code></pre> <p>Returns true iff any of the passed arguments evaluates to true (base case; always returns false). </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-is_any_true_1","title":"function is_any_true","text":"<pre><code>template &lt;typename... Rest&gt;\ninline constexpr bool is_any_true(\nbool first,\nRest &amp;&amp;... rest\n)\n</code></pre> <p>Returns true iff any of the passed arguments evaluates to true (recursive case; short circuits if <code>first</code> is true.). </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-are_all_true","title":"function are_all_true","text":"<pre><code>inline constexpr bool are_all_true()\n</code></pre> <p>Returns true iff all of the passed arguments evaluate to true (base case; always returns false). </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-are_all_true_1","title":"function are_all_true","text":"<pre><code>template &lt;typename... Rest&gt;\ninline constexpr bool are_all_true(\nbool first,\nRest &amp;&amp;... rest\n)\n</code></pre> <p>Returns true iff any of the passed arguments evaluates to true (recursive case; short circuits if <code>first</code> is true.). </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-name_of","title":"function name_of","text":"<pre><code>inline const char * name_of(\nconst std::type_index &amp; index\n)\n</code></pre> <p>Calculates and returns the demangled name of the given type as a null-terminated C-string. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-name_of_1","title":"function name_of","text":"<pre><code>inline const char * name_of(\nconst std::type_info &amp; info\n)\n</code></pre> <p>Calculates and returns the demangled name of the given type as a null-terminated C-string. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-name_of_2","title":"function name_of","text":"<pre><code>template &lt;typename T &gt;\nconst char * name_of(\nbatt::StaticType&lt; T &gt;  ={}\n)\n</code></pre> <p>Calculates and returns the demangled name of the given type as a null-terminated C-string. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unqualified_name_of","title":"function unqualified_name_of","text":"<pre><code>template &lt;typename T &gt;\nconst char * unqualified_name_of(\nbatt::StaticType&lt; T &gt;  ={}\n)\n</code></pre> <p>Calculates and returns the demangled name of the given type, without the namespace qualifier. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-can_be_empty_base","title":"function can_be_empty_base","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_class_v&lt;T&gt;&gt;&gt;\ninline constexpr auto can_be_empty_base(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre> <p>Returns true iff the specified type can be optimized to zero size via empty base class optimization. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-can_be_empty_base_1","title":"function can_be_empty_base","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;!std::is_class_v&lt;T&gt;&gt;,\ntypename  =void&gt;\ninline constexpr std::false_type can_be_empty_base(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_125","title":"function operator==","text":"<pre><code>inline bool operator==(\nconst UrlParse &amp; left,\nconst UrlParse &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_126","title":"function operator!=","text":"<pre><code>inline bool operator!=(\nconst UrlParse &amp; left,\nconst UrlParse &amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-operator_127","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst UrlParse &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-parse_url","title":"function parse_url","text":"<pre><code>inline StatusOr&lt; UrlParse &gt; parse_url(\nstd::string_view url\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_copy","title":"function make_copy","text":"<pre><code>template &lt;typename T &gt;\nT make_copy(\nconst T &amp; value\n)\n</code></pre> <p>Return a copy of <code>value</code>. </p> <p>Supports the \"sunk arguments idiom\" of always declaring function arguments whose value is copied/retained by the callee as rvalue-references. This idiom maintains optimal efficiency in most cases while providing a signal-boost at call sites that an arg is being copied or moved. Examples:</p> <pre><code>struct MyStruct {\nstd::shared_ptr&lt;bool&gt; p_flag;\nexplicit MyStruct(std::shared_ptr&lt;bool&gt; &amp;&amp;arg) : p_flag{std::move(arg)} {}\n};\n// These are allowed:\n//\nMyStruct ex1{std::make_shared&lt;bool&gt;(true)};\nauto flag_arg = std::make_shared&lt;bool&gt;(false);\nMyStruct ex2{batt::make_copy(flag_arg)};\nMyStruct ex3{std::move(flag_arg)};\n// This is not allowed (the caller must declare intent loudly):\n//\nauto flag_arg2 = std::make_shared&lt;bool&gt;(true);\nMyStruct ex4_BAD{flag_arg2};\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-sink","title":"function sink","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;T, std::decay_t&lt;T&gt;&gt;&gt;&gt;\nT &amp;&amp; sink(\nT &amp;&amp; value\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-sink_1","title":"function sink","text":"<pre><code>template &lt;typename T &gt;\nT sink(\nconst T &amp; value\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_default","title":"function make_default","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;!std::is_same_v&lt;T, void&gt;&gt;&gt;\nT make_default()\n</code></pre> <p>Return a default-constructed instance of type <code>T</code>. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#function-make_default_1","title":"function make_default","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;std::is_same_v&lt;T, void&gt;&gt;,\ntypename  =void&gt;\nvoid make_default()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_4","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nT &amp;&amp; obj\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_5","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nstd::reference_wrapper&lt; T &gt; &amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_6","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nstd::reference_wrapper&lt; T &gt; const &amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_7","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nstd::reference_wrapper&lt; T &gt; &amp;&amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-unwrap_ref_8","title":"function unwrap_ref","text":"<pre><code>template &lt;typename T &gt;\ndecltype(auto) unwrap_ref(\nstd::reference_wrapper&lt; T &gt; const &amp;&amp; wrapper\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-rotate_args_right","title":"function rotate_args_right","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args&gt;\ndecltype(auto) rotate_args_right(\nFn &amp;&amp; fn,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#function-rotate_args_left","title":"function rotate_args_left","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args&gt;\ndecltype(auto) rotate_args_left(\nFn &amp;&amp; fn,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt/#variable-kminstacksizelog2","title":"variable kMinStackSizeLog2","text":"<pre><code>constexpr usize kMinStackSizeLog2 = 10u;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kmaxstacksizelog2","title":"variable kMaxStackSizeLog2","text":"<pre><code>constexpr usize kMaxStackSizeLog2 = 32u;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kmaxdebuginfothreads","title":"variable kMaxDebugInfoThreads","text":"<pre><code>constexpr usize kMaxDebugInfoThreads = 32;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-ktaskdebuginfosegvcallbackinstalled","title":"variable kTaskDebugInfoSegvCallbackInstalled","text":"<pre><code>const bool kTaskDebugInfoSegvCallbackInstalled = [] {\nextra_segv_debug_info_callback() = &amp;this_task_debug_info;\nreturn true;\n}();\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kcpucachelinesize","title":"variable kCpuCacheLineSize","text":"<pre><code>constexpr auto kCpuCacheLineSize = usize{64};\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-ksigsegvhandlerinstalled","title":"variable kSigSegvHandlerInstalled","text":"<pre><code>const bool kSigSegvHandlerInstalled = [] {\nsignal(SIGSEGV, &amp;detail::handle_segv);\nsignal(SIGABRT, &amp;detail::handle_segv);\nstd::atexit(&amp;print_stack_trace_atexit);\nreturn true;\n}();\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-kdefaultsmallvecsize","title":"variable kDefaultSmallVecSize","text":"<pre><code>constexpr usize kDefaultSmallVecSize = 4;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-isstatusenum","title":"variable IsStatusEnum","text":"<pre><code>constexpr bool IsStatusEnum = std::is_enum_v&lt;T&gt; &amp;&amp;                                  !boost::system::is_error_code_enum&lt;T&gt;::value &amp;&amp;       !boost::system::is_error_condition_enum&lt;T&gt;::value &amp;&amp;  !std::is_error_code_enum_v&lt;T&gt; &amp;&amp;                      !std::is_error_condition_enum_v&lt;T&gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-tupleindexof_v","title":"variable TupleIndexOf_v","text":"<pre><code>constexpr auto TupleIndexOf_v = TupleIndexOf&lt;std::decay_t&lt;TupleT&gt;, T&gt;::value;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-isoneof","title":"variable IsOneOf","text":"<pre><code>constexpr bool IsOneOf = is_any_true(std::is_same_v&lt;T, MatchTs&gt;...);\n</code></pre> <p>Trait that evaluates to true iff <code>T</code> is the same as one of the MatchTs. </p>"},{"location":"_autogen/Namespaces/namespacebatt/#variable-decaystooneof","title":"variable DecaysToOneOf","text":"<pre><code>constexpr bool DecaysToOneOf = IsOneOf&lt;std::decay_t&lt;T&gt;, MatchTs...&gt;;\n</code></pre> <p>Trait that evaluates to true iff <code>T</code> decays to one of the MatchTs. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1_0d121/","title":"batt::@121","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1_0d197/","title":"batt::@197","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/","title":"batt::constants","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#attributes","title":"Attributes","text":"Name constexpr u64 kKB constexpr u64 kMB constexpr u64 kGB constexpr u64 kTB constexpr u64 kPB constexpr u64 kEB constexpr u64 kKiB constexpr u64 kMiB constexpr u64 kGiB constexpr u64 kTiB constexpr u64 kPiB constexpr u64 kEiB"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kkb","title":"variable kKB","text":"<pre><code>constexpr u64 kKB = 1000ull;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kmb","title":"variable kMB","text":"<pre><code>constexpr u64 kMB = 1000ull * kKB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kgb","title":"variable kGB","text":"<pre><code>constexpr u64 kGB = 1000ull * kMB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-ktb","title":"variable kTB","text":"<pre><code>constexpr u64 kTB = 1000ull * kGB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kpb","title":"variable kPB","text":"<pre><code>constexpr u64 kPB = 1000ull * kTB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-keb","title":"variable kEB","text":"<pre><code>constexpr u64 kEB = 1000ull * kPB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kkib","title":"variable kKiB","text":"<pre><code>constexpr u64 kKiB = 1024ull;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kmib","title":"variable kMiB","text":"<pre><code>constexpr u64 kMiB = 1024ull * kKiB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kgib","title":"variable kGiB","text":"<pre><code>constexpr u64 kGiB = 1024ull * kMiB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-ktib","title":"variable kTiB","text":"<pre><code>constexpr u64 kTiB = 1024ull * kGiB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-kpib","title":"variable kPiB","text":"<pre><code>constexpr u64 kPiB = 1024ull * kTiB;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1constants/#variable-keib","title":"variable kEiB","text":"<pre><code>constexpr u64 kEiB = 1024ull * kPiB;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/","title":"batt::detail","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#classes","title":"Classes","text":"Name struct batt::detail::FirstPhase struct batt::detail::SecondPhase struct batt::detail::ThirdPhase class batt::detail::SigInfoHandler class batt::detail::FutureImpl class batt::detail::PriorityHeap class batt::detail::PriorityHeapItem class batt::detail::PriorityHeapItemList struct batt::detail::FirstMatchImpl struct batt::detail::FirstMatchImpl&lt; std::tuple&lt; CaseFirst, CaseRest... &gt;, std::tuple&lt; Args... &gt; &gt; struct batt::detail::FirstMatchImpl&lt; std::tuple&lt;&gt;, std::tuple&lt; Args... &gt; &gt; struct batt::detail::VisitorResult struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; &amp;&amp; &gt; struct batt::detail::VisitorResult&lt; Visitor, std::variant&lt; Ts... &gt; const &amp;&amp; &gt; class batt::detail::HttpClientRequestContext struct batt::detail::NullableImpl struct batt::detail::NullableImpl&lt; std::optional&lt; T &gt; &gt; struct batt::detail::NullableImpl&lt; std::unique_ptr&lt; T &gt; &gt; struct batt::detail::NullableImpl&lt; std::shared_ptr&lt; T &gt; &gt; struct batt::detail::NullableImpl&lt; T * &gt; class batt::detail::OptionalBase class batt::detail::OptionalEmptyBase class batt::detail::AbstractMoveFn class batt::detail::AbstractCopyFn class batt::detail::MoveFnImpl class batt::detail::CopyFnImpl class batt::detail::AllocFnWrapper struct batt::detail::ModelCheckShardMetrics class batt::detail::ParallelModelCheckState class batt::detail::StatusBase class batt::detail::StatusOrValueContainer class batt::detail::StatusOrValueContainer&lt; T &amp; &gt; struct batt::detail::IsStatusOrImpl struct batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &gt; &gt; struct batt::detail::IsStatusOrImpl&lt; StatusOr&lt; T &amp; &gt; &gt; class batt::detail::NotOkStatusWrapper struct batt::detail::EmptyBaseHelper struct batt::detail::EmptyBaseTestCase struct batt::detail::EmptyBaseTestCase2"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#types","title":"Types","text":"Name template &lt;typename Visitor ,typename VariantArg &gt; using typename VisitorResult&lt; Visitor, VariantArg &gt;::type VisitorResultT template &lt;bool kMoveOnly,typename Result ,typename... Args&gt; using std::conditional_t&lt; kMoveOnly, AbstractMoveFn&lt; true, Result, Args... &gt;, AbstractCopyFn&lt; Result, Args... &gt; &gt; AbstractFn template &lt;typename Fn ,bool kMoveOnly,typename Result ,typename... Args&gt; using std::conditional_t&lt; kMoveOnly, MoveFnImpl&lt; Fn, kMoveOnly, Result, Args... &gt;, CopyFnImpl&lt; Fn, Result, Args... &gt; &gt; FnImpl template &lt;typename Arg ,typename Result &gt; using Result(*)(Arg) AbstractCaseHandler"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#functions","title":"Functions","text":"Name template &lt;typename Fixed ,typename Search ,typename Dst ,typename Compare ,typename Phase &gt; void parallel_merge_fanout(WorkContext &amp; context, Fixed fixed_begin, Fixed fixed_end, Search search_begin, Search search_end, Dst dst_begin, Compare &amp;&amp; compare, usize min_task_size, usize max_tasks, batt::StaticType&lt; Phase &gt; ) template &lt;typename Src0 ,typename Src1 ,typename Dst ,typename Compare ,typename Phase &gt; void parallel_merge_impl(WorkContext &amp; context, Src0 src_0_begin, Src0 src_0_end, Src1 src_1_begin, Src1 src_1_end, Dst dst_begin, Compare &amp;&amp; compare, usize min_task_size, usize max_tasks, batt::StaticType&lt; Phase &gt; phase) template &lt;typename Fixed ,typename Search ,typename Dst ,typename Compare ,typename Phase &gt; void parallel_merge_fanout(WorkContext &amp; context, Fixed fixed_begin, Fixed fixed_end, Fixed fixed_part_begin, Fixed fixed_part_end, Search search_begin, Search search_end, Dst dst_begin, Compare &amp;&amp; compare, usize min_task_size, usize max_tasks, batt::StaticType&lt; Phase &gt; ) template &lt;typename T &gt; std::false_type has_const_buffer_sequence_requirements_impl(... ) template &lt;typename T ,typename ElementT  =decltype(*boost::asio::buffer_sequence_begin(std::declval()))&gt; std::true_type has_const_buffer_sequence_requirements_impl(std::decay_t&lt; T &gt; * ) template &lt;typename T &gt; std::false_type has_buffer_source_requirements_impl(... ) template &lt;typename T &gt; std::true_type has_buffer_source_requirements_impl(std::decay_t&lt; T &gt; * ) template &lt;typename BufferT ,typename SizeT &gt; BufferT slice_buffer_impl(const BufferT &amp; buffer, const Interval&lt; SizeT &gt; &amp; slice) std::string escape_otel_metric_name(const std::string_view name) void print_nothing(std::ostream &amp; ) void handle_segv(int sig) void exit_impl(int code) template &lt;typename T &gt; std::false_type has_seq_requirements_impl(... ) template &lt;typename T ,typename ItemT  =typename std::decay_t::Item&gt; std::true_type has_seq_requirements_impl(std::decay_t&lt; T &gt; * ) template &lt;typename T ,typename  =decltype(intrusive_ptr_add_ref((T)nullptr)),typename  =decltype(intrusive_ptr_release((T)nullptr))&gt; std::true_type is_ref_counted_impl(void * ) template &lt;typename T &gt; std::false_type is_ref_counted_impl(... ) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const ModelCheckShardMetrics &amp; t) template &lt;typename IntT ,IntT I,typename Fn ,typename R &gt; R CaseHandlerImpl(Fn &amp;&amp; fn) template &lt;typename IntT ,IntT I,typename Fn ,typename R &gt; void initialize_case_handlers(std::integral_constant&lt; IntT, I &gt; , std::integral_constant&lt; IntT, I &gt; , AbstractCaseHandler&lt; Fn, R &gt; * , AbstractCaseHandler&lt; Fn, R &gt; * ) template &lt;typename IntT ,IntT kBegin,IntT kEnd,typename Fn ,typename R &gt; void initialize_case_handlers(std::integral_constant&lt; IntT, kBegin &gt; , std::integral_constant&lt; IntT, kEnd &gt; , AbstractCaseHandler&lt; Fn, R &gt; * begin, AbstractCaseHandler&lt; Fn, R &gt; * end) template &lt;typename T &gt; void emplace_none(StatusOrValueContainer&lt; T &gt; &amp; ) void emplace_none(StatusOrValueContainer&lt; NoneType &gt; &amp; s) std::unordered_map&lt; const boost::system::error_category *, const std::unordered_map&lt; int, Status &gt; &gt; &amp; thread_local_error_category_status_map()Returns a reference to a thread-local hash map from error_category* to another hash map from code value (int) to equivalent batt::Status. std::mutex &amp; global_error_category_status_map_mutex() std::unordered_map&lt; const boost::system::error_category *, const std::unordered_map&lt; int, Status &gt; &gt; &amp; global_error_category_status_map()Returns a reference to a global-scoped hash map from error_category* to another hash map from code value (int) to equivalent batt::Status. template &lt;typename T ,typename... FormatArgs&gt; std::optional&lt; T &gt; from_string_impl(StaticType&lt; T &gt; , const std::string &amp; str, FormatArgs &amp;&amp;... format_args) template &lt;typename... FormatArgs&gt; std::optional&lt; bool &gt; from_string_impl(StaticType&lt; bool &gt; , const std::string &amp; str, FormatArgs &amp;&amp; ...) Pretty &amp; range_dump_pretty() int &amp; range_dump_depth() template &lt;typename T ,typename  =std::enable_if_t&lt;!std::is_same, u8&gt;{}&gt;,typename  =std::enable_if_t&lt;!IsRange{}&gt;&gt; std::ostream &amp; dump_item(std::ostream &amp; out, T &amp;&amp; item) std::ostream &amp; dump_item(std::ostream &amp; out, const std::string &amp; s) std::ostream &amp; dump_item(std::ostream &amp; out, const std::string_view &amp; s) std::ostream &amp; dump_item(std::ostream &amp; out, const std::filesystem::path &amp; p) template &lt;typename T ,typename  =std::enable_if_t{}&gt;&gt; std::ostream &amp; dump_item(std::ostream &amp; out, T &amp;&amp; item) std::ostream &amp; dump_item(std::ostream &amp; out, u8 byte_val) template &lt;typename FirstT ,typename SecondT &gt; std::ostream &amp; dump_item(std::ostream &amp; out, const std::pair&lt; FirstT, SecondT &gt; &amp; p) template &lt;typename Fn ,typename... Args,typename Result  =std::invoke_result_t&gt; std::true_type is_callable_impl(void * ) template &lt;typename Fn ,typename... Args&gt; std::false_type is_callable_impl(... ) template &lt;typename T ,typename Result  =decltype(std::declval() &lt;&lt; std::declval())&gt; std::true_type is_printable_impl(void * ) template &lt;typename Fn ,typename... Args&gt; std::false_type is_printable_impl(... ) template &lt;typename T ,typename BeginIter  =decltype(std::begin(std::declval())),typename EndIter  =decltype(std::end(std::declval())),typename  =std::enable_if_t{}&gt;&gt; std::true_type is_range_impl(void * ) template &lt;typename T &gt; std::false_type is_range_impl(... ) template &lt;typename T ,typename U ,typename  =decltype(std::declval() == std::declval())&gt; std::true_type can_be_eq_compared_helper(const T * , const U * ) template &lt;typename T ,typename U &gt; std::false_type can_be_eq_compared_helper(... ) template &lt;typename T ,typename  =std::enable_if_t) == 16&gt;&gt; constexpr std::true_type class_can_be_empty_base(StaticType&lt; T &gt;  ={}) template &lt;typename T ,typename  =std::enable_if_t) != 16&gt;,typename  =void&gt; constexpr std::false_type class_can_be_empty_base(StaticType&lt; T &gt;  ={}) StatusOr&lt; UrlParse &gt; parse_url_auth(std::string_view url, UrlParse &amp;&amp; parse) StatusOr&lt; UrlParse &gt; parse_url_host(std::string_view url, UrlParse &amp;&amp; parse) StatusOr&lt; UrlParse &gt; parse_url_port(std::string_view url, UrlParse &amp;&amp; parse) StatusOr&lt; UrlParse &gt; parse_url_path(std::string_view url, UrlParse &amp;&amp; parse) StatusOr&lt; UrlParse &gt; parse_url_query(std::string_view url, UrlParse &amp;&amp; parse) StatusOr&lt; UrlParse &gt; parse_url_fragment(std::string_view url, UrlParse &amp;&amp; parse) template &lt;typename Fn ,typename ArgsTuple ,usize... kIndex&gt; decltype(auto) rotate_args_right_impl(Fn &amp;&amp; fn, ArgsTuple &amp;&amp; args_tuple, std::index_sequence&lt; kIndex... &gt; ) template &lt;typename Fn ,typename ArgsTuple ,usize... kIndex&gt; decltype(auto) rotate_args_left_impl(Fn &amp;&amp; fn, ArgsTuple &amp;&amp; args_tuple, std::index_sequence&lt; kIndex... &gt; )"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#attributes","title":"Attributes","text":"Name constexpr isize kThreshold constexpr isize kMaxShards"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#types-documentation","title":"Types Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-visitorresultt","title":"using VisitorResultT","text":"<pre><code>template &lt;typename Visitor ,\ntypename VariantArg &gt;\nusing batt::detail::VisitorResultT = typedef typename VisitorResult&lt;Visitor, VariantArg&gt;::type;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-abstractfn","title":"using AbstractFn","text":"<pre><code>template &lt;bool kMoveOnly,\ntypename Result ,\ntypename... Args&gt;\nusing batt::detail::AbstractFn = typedef std::conditional_t&lt;kMoveOnly, AbstractMoveFn&lt;true, Result, Args...&gt;, AbstractCopyFn&lt;Result, Args...&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-fnimpl","title":"using FnImpl","text":"<pre><code>template &lt;typename Fn ,\nbool kMoveOnly,\ntypename Result ,\ntypename... Args&gt;\nusing batt::detail::FnImpl = typedef std::conditional_t&lt;kMoveOnly, MoveFnImpl&lt;Fn, kMoveOnly, Result, Args...&gt;, CopyFnImpl&lt;Fn, Result, Args...&gt; &gt;;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#using-abstractcasehandler","title":"using AbstractCaseHandler","text":"<pre><code>template &lt;typename Arg ,\ntypename Result &gt;\nusing batt::detail::AbstractCaseHandler = typedef Result (*)(Arg);\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parallel_merge_fanout","title":"function parallel_merge_fanout","text":"<pre><code>template &lt;typename Fixed ,\ntypename Search ,\ntypename Dst ,\ntypename Compare ,\ntypename Phase &gt;\nvoid parallel_merge_fanout(\nWorkContext &amp; context,\nFixed fixed_begin,\nFixed fixed_end,\nSearch search_begin,\nSearch search_end,\nDst dst_begin,\nCompare &amp;&amp; compare,\nusize min_task_size,\nusize max_tasks,\nbatt::StaticType&lt; Phase &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parallel_merge_impl","title":"function parallel_merge_impl","text":"<pre><code>template &lt;typename Src0 ,\ntypename Src1 ,\ntypename Dst ,\ntypename Compare ,\ntypename Phase &gt;\nvoid parallel_merge_impl(\nWorkContext &amp; context,\nSrc0 src_0_begin,\nSrc0 src_0_end,\nSrc1 src_1_begin,\nSrc1 src_1_end,\nDst dst_begin,\nCompare &amp;&amp; compare,\nusize min_task_size,\nusize max_tasks,\nbatt::StaticType&lt; Phase &gt; phase\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parallel_merge_fanout_1","title":"function parallel_merge_fanout","text":"<pre><code>template &lt;typename Fixed ,\ntypename Search ,\ntypename Dst ,\ntypename Compare ,\ntypename Phase &gt;\nvoid parallel_merge_fanout(\nWorkContext &amp; context,\nFixed fixed_begin,\nFixed fixed_end,\nFixed fixed_part_begin,\nFixed fixed_part_end,\nSearch search_begin,\nSearch search_end,\nDst dst_begin,\nCompare &amp;&amp; compare,\nusize min_task_size,\nusize max_tasks,\nbatt::StaticType&lt; Phase &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_const_buffer_sequence_requirements_impl","title":"function has_const_buffer_sequence_requirements_impl","text":"<pre><code>template &lt;typename T &gt;\ninline std::false_type has_const_buffer_sequence_requirements_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_const_buffer_sequence_requirements_impl_1","title":"function has_const_buffer_sequence_requirements_impl","text":"<pre><code>template &lt;typename T ,\ntypename ElementT  =decltype(*boost::asio::buffer_sequence_begin(std::declval&lt;T&gt;()))&gt;\ninline std::true_type has_const_buffer_sequence_requirements_impl(\nstd::decay_t&lt; T &gt; * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_buffer_source_requirements_impl","title":"function has_buffer_source_requirements_impl","text":"<pre><code>template &lt;typename T &gt;\ninline std::false_type has_buffer_source_requirements_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_buffer_source_requirements_impl_1","title":"function has_buffer_source_requirements_impl","text":"<pre><code>template &lt;typename T &gt;\ninline std::true_type has_buffer_source_requirements_impl(\nstd::decay_t&lt; T &gt; * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-slice_buffer_impl","title":"function slice_buffer_impl","text":"<pre><code>template &lt;typename BufferT ,\ntypename SizeT &gt;\ninline BufferT slice_buffer_impl(\nconst BufferT &amp; buffer,\nconst Interval&lt; SizeT &gt; &amp; slice\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-escape_otel_metric_name","title":"function escape_otel_metric_name","text":"<pre><code>inline std::string escape_otel_metric_name(\nconst std::string_view name\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-print_nothing","title":"function print_nothing","text":"<pre><code>inline void print_nothing(\nstd::ostream &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-handle_segv","title":"function handle_segv","text":"<pre><code>inline void handle_segv(\nint sig\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-exit_impl","title":"function exit_impl","text":"<pre><code>inline void exit_impl(\nint code\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_seq_requirements_impl","title":"function has_seq_requirements_impl","text":"<pre><code>template &lt;typename T &gt;\ninline std::false_type has_seq_requirements_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-has_seq_requirements_impl_1","title":"function has_seq_requirements_impl","text":"<pre><code>template &lt;typename T ,\ntypename ItemT  =typename std::decay_t&lt;T&gt;::Item&gt;\ninline std::true_type has_seq_requirements_impl(\nstd::decay_t&lt; T &gt; * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_ref_counted_impl","title":"function is_ref_counted_impl","text":"<pre><code>template &lt;typename T ,\ntypename  =decltype(intrusive_ptr_add_ref((T*)nullptr)),\ntypename  =decltype(intrusive_ptr_release((T*)nullptr))&gt;\nstd::true_type is_ref_counted_impl(\nvoid * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_ref_counted_impl_1","title":"function is_ref_counted_impl","text":"<pre><code>template &lt;typename T &gt;\nstd::false_type is_ref_counted_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst ModelCheckShardMetrics &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-casehandlerimpl","title":"function CaseHandlerImpl","text":"<pre><code>template &lt;typename IntT ,\nIntT I,\ntypename Fn ,\ntypename R &gt;\nR CaseHandlerImpl(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-initialize_case_handlers","title":"function initialize_case_handlers","text":"<pre><code>template &lt;typename IntT ,\nIntT I,\ntypename Fn ,\ntypename R &gt;\nvoid initialize_case_handlers(\nstd::integral_constant&lt; IntT, I &gt; ,\nstd::integral_constant&lt; IntT, I &gt; ,\nAbstractCaseHandler&lt; Fn, R &gt; * ,\nAbstractCaseHandler&lt; Fn, R &gt; * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-initialize_case_handlers_1","title":"function initialize_case_handlers","text":"<pre><code>template &lt;typename IntT ,\nIntT kBegin,\nIntT kEnd,\ntypename Fn ,\ntypename R &gt;\nvoid initialize_case_handlers(\nstd::integral_constant&lt; IntT, kBegin &gt; ,\nstd::integral_constant&lt; IntT, kEnd &gt; ,\nAbstractCaseHandler&lt; Fn, R &gt; * begin,\nAbstractCaseHandler&lt; Fn, R &gt; * end\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-emplace_none","title":"function emplace_none","text":"<pre><code>template &lt;typename T &gt;\nvoid emplace_none(\nStatusOrValueContainer&lt; T &gt; &amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-emplace_none_1","title":"function emplace_none","text":"<pre><code>inline void emplace_none(\nStatusOrValueContainer&lt; NoneType &gt; &amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-thread_local_error_category_status_map","title":"function thread_local_error_category_status_map","text":"<pre><code>inline std::unordered_map&lt; const boost::system::error_category *, const std::unordered_map&lt; int, Status &gt; &gt; &amp; thread_local_error_category_status_map()\n</code></pre> <p>Returns a reference to a thread-local hash map from error_category* to another hash map from code value (int) to equivalent batt::Status. </p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-global_error_category_status_map_mutex","title":"function global_error_category_status_map_mutex","text":"<pre><code>inline std::mutex &amp; global_error_category_status_map_mutex()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-global_error_category_status_map","title":"function global_error_category_status_map","text":"<pre><code>inline std::unordered_map&lt; const boost::system::error_category *, const std::unordered_map&lt; int, Status &gt; &gt; &amp; global_error_category_status_map()\n</code></pre> <p>Returns a reference to a global-scoped hash map from error_category* to another hash map from code value (int) to equivalent batt::Status. </p> <p>MUST be called while holding a lock on the mutex returned by batt::detail::global_error_category_status_map_mutex(). </p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-from_string_impl","title":"function from_string_impl","text":"<pre><code>template &lt;typename T ,\ntypename... FormatArgs&gt;\nstd::optional&lt; T &gt; from_string_impl(\nStaticType&lt; T &gt; ,\nconst std::string &amp; str,\nFormatArgs &amp;&amp;... format_args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-from_string_impl_1","title":"function from_string_impl","text":"<pre><code>template &lt;typename... FormatArgs&gt;\nstd::optional&lt; bool &gt; from_string_impl(\nStaticType&lt; bool &gt; ,\nconst std::string &amp; str,\nFormatArgs &amp;&amp; ...\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-range_dump_pretty","title":"function range_dump_pretty","text":"<pre><code>inline Pretty &amp; range_dump_pretty()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-range_dump_depth","title":"function range_dump_depth","text":"<pre><code>inline int &amp; range_dump_depth()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item","title":"function dump_item","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;!std::is_same&lt;std::decay_t&lt;T&gt;, u8&gt;{}&gt;,\ntypename  =std::enable_if_t&lt;!IsRange&lt;T&gt;{}&gt;&gt;\ninline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nT &amp;&amp; item\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_1","title":"function dump_item","text":"<pre><code>inline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nconst std::string &amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_2","title":"function dump_item","text":"<pre><code>inline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nconst std::string_view &amp; s\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_3","title":"function dump_item","text":"<pre><code>inline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nconst std::filesystem::path &amp; p\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_4","title":"function dump_item","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;IsRange&lt;T&gt;{}&gt;&gt;\ninline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nT &amp;&amp; item\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_5","title":"function dump_item","text":"<pre><code>inline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nu8 byte_val\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-dump_item_6","title":"function dump_item","text":"<pre><code>template &lt;typename FirstT ,\ntypename SecondT &gt;\ninline std::ostream &amp; dump_item(\nstd::ostream &amp; out,\nconst std::pair&lt; FirstT, SecondT &gt; &amp; p\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_callable_impl","title":"function is_callable_impl","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args,\ntypename Result  =std::invoke_result_t&lt;Fn, Args...&gt;&gt;\nstd::true_type is_callable_impl(\nvoid * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_callable_impl_1","title":"function is_callable_impl","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args&gt;\nstd::false_type is_callable_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_printable_impl","title":"function is_printable_impl","text":"<pre><code>template &lt;typename T ,\ntypename Result  =decltype(std::declval&lt;std::ostream&amp;&gt;() &lt;&lt; std::declval&lt;T&gt;())&gt;\nstd::true_type is_printable_impl(\nvoid * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_printable_impl_1","title":"function is_printable_impl","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args&gt;\nstd::false_type is_printable_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_range_impl","title":"function is_range_impl","text":"<pre><code>template &lt;typename T ,\ntypename BeginIter  =decltype(std::begin(std::declval&lt;T&gt;())),\ntypename EndIter  =decltype(std::end(std::declval&lt;T&gt;())),\ntypename  =std::enable_if_t&lt;std::is_same&lt;BeginIter, EndIter&gt;{}&gt;&gt;\nstd::true_type is_range_impl(\nvoid * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-is_range_impl_1","title":"function is_range_impl","text":"<pre><code>template &lt;typename T &gt;\nstd::false_type is_range_impl(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-can_be_eq_compared_helper","title":"function can_be_eq_compared_helper","text":"<pre><code>template &lt;typename T ,\ntypename U ,\ntypename  =decltype(std::declval&lt;const T&amp;&gt;() == std::declval&lt;const U&amp;&gt;())&gt;\nstd::true_type can_be_eq_compared_helper(\nconst T * ,\nconst U * )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-can_be_eq_compared_helper_1","title":"function can_be_eq_compared_helper","text":"<pre><code>template &lt;typename T ,\ntypename U &gt;\nstd::false_type can_be_eq_compared_helper(\n... )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-class_can_be_empty_base","title":"function class_can_be_empty_base","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;sizeof(detail::EmptyBaseHelper&lt;T&gt;) == 16&gt;&gt;\ninline constexpr std::true_type class_can_be_empty_base(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-class_can_be_empty_base_1","title":"function class_can_be_empty_base","text":"<pre><code>template &lt;typename T ,\ntypename  =std::enable_if_t&lt;sizeof(detail::EmptyBaseHelper&lt;T&gt;) != 16&gt;,\ntypename  =void&gt;\ninline constexpr std::false_type class_can_be_empty_base(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_auth","title":"function parse_url_auth","text":"<pre><code>inline StatusOr&lt; UrlParse &gt; parse_url_auth(\nstd::string_view url,\nUrlParse &amp;&amp; parse\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_host","title":"function parse_url_host","text":"<pre><code>inline StatusOr&lt; UrlParse &gt; parse_url_host(\nstd::string_view url,\nUrlParse &amp;&amp; parse\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_port","title":"function parse_url_port","text":"<pre><code>inline StatusOr&lt; UrlParse &gt; parse_url_port(\nstd::string_view url,\nUrlParse &amp;&amp; parse\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_path","title":"function parse_url_path","text":"<pre><code>inline StatusOr&lt; UrlParse &gt; parse_url_path(\nstd::string_view url,\nUrlParse &amp;&amp; parse\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_query","title":"function parse_url_query","text":"<pre><code>inline StatusOr&lt; UrlParse &gt; parse_url_query(\nstd::string_view url,\nUrlParse &amp;&amp; parse\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-parse_url_fragment","title":"function parse_url_fragment","text":"<pre><code>StatusOr&lt; UrlParse &gt; parse_url_fragment(\nstd::string_view url,\nUrlParse &amp;&amp; parse\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-rotate_args_right_impl","title":"function rotate_args_right_impl","text":"<pre><code>template &lt;typename Fn ,\ntypename ArgsTuple ,\nusize... kIndex&gt;\ndecltype(auto) rotate_args_right_impl(\nFn &amp;&amp; fn,\nArgsTuple &amp;&amp; args_tuple,\nstd::index_sequence&lt; kIndex... &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#function-rotate_args_left_impl","title":"function rotate_args_left_impl","text":"<pre><code>template &lt;typename Fn ,\ntypename ArgsTuple ,\nusize... kIndex&gt;\ndecltype(auto) rotate_args_left_impl(\nFn &amp;&amp; fn,\nArgsTuple &amp;&amp; args_tuple,\nstd::index_sequence&lt; kIndex... &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#variable-kthreshold","title":"variable kThreshold","text":"<pre><code>static constexpr isize kThreshold = 1400;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1detail/#variable-kmaxshards","title":"variable kMaxShards","text":"<pre><code>static constexpr isize kMaxShards = 8;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1features/","title":"batt::features","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#classes","title":"Classes","text":"Name struct batt::features::State Captures the normative feature mask plus the stack trace where the global singleton instance of this type was initialized."},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#types","title":"Types","text":"Name enum Feature { kHeaderOnly = 0, kSeqSpecializeAlgorithms, kWithGlog, kWithProtobuf, kCompilerGCC, kCompilerClang, kWithAsserts, kNumFeatures}The list of build-time features that can potentially affect ABI. using unsigned long long mask_type"},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#functions","title":"Functions","text":"Name constexpr mask_type get_feature_mask()Computes and returns the build-time feature mask for the current configuration. const State &amp; get_global_state()Computes and returns the normative feature mask for the program. bool check_local_feature_state()Returns true if the computed feature mask for the current compilation unit is the same as the global mask; otherwise prints a diagnostic message and panics."},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#types-documentation","title":"Types Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#enum-feature","title":"enum Feature","text":"Enumerator Value Description kHeaderOnly 0 kSeqSpecializeAlgorithms kWithGlog kWithProtobuf kCompilerGCC kCompilerClang kWithAsserts kNumFeatures <p>The list of build-time features that can potentially affect ABI. </p> <p>Each of these should have a section in this file (see above) that describes the feature in more detail. </p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#using-mask_type","title":"using mask_type","text":"<pre><code>using batt::features::mask_type = typedef unsigned long long;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#function-get_feature_mask","title":"function get_feature_mask","text":"<pre><code>inline constexpr mask_type get_feature_mask()\n</code></pre> <p>Computes and returns the build-time feature mask for the current configuration. </p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#function-get_global_state","title":"function get_global_state","text":"<pre><code>inline const State &amp; get_global_state()\n</code></pre> <p>Computes and returns the normative feature mask for the program. </p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1features/#function-check_local_feature_state","title":"function check_local_feature_state","text":"<pre><code>inline bool check_local_feature_state()\n</code></pre> <p>Returns true if the computed feature mask for the current compilation unit is the same as the global mask; otherwise prints a diagnostic message and panics. </p> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/","title":"batt::int_types","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#types","title":"Types","text":"Name using std::uint8_t u8 using std::int8_t i8 using std::uint16_t u16 using std::int16_t i16 using std::uint32_t u32 using std::int32_t i32 using std::uint64_t u64 using std::int64_t i64 using std::size_t usize using std::ptrdiff_t isize"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#types-documentation","title":"Types Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u8","title":"using u8","text":"<pre><code>using batt::int_types::u8 = typedef std::uint8_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i8","title":"using i8","text":"<pre><code>using batt::int_types::i8 = typedef std::int8_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u16","title":"using u16","text":"<pre><code>using batt::int_types::u16 = typedef std::uint16_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i16","title":"using i16","text":"<pre><code>using batt::int_types::i16 = typedef std::int16_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u32","title":"using u32","text":"<pre><code>using batt::int_types::u32 = typedef std::uint32_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i32","title":"using i32","text":"<pre><code>using batt::int_types::i32 = typedef std::int32_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-u64","title":"using u64","text":"<pre><code>using batt::int_types::u64 = typedef std::uint64_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-i64","title":"using i64","text":"<pre><code>using batt::int_types::i64 = typedef std::int64_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-usize","title":"using usize","text":"<pre><code>using batt::int_types::usize = typedef std::size_t;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1int__types/#using-isize","title":"using isize","text":"<pre><code>using batt::int_types::isize = typedef std::ptrdiff_t;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/","title":"batt::seq","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#namespaces","title":"Namespaces","text":"Name batt::seq::detail"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#classes","title":"Classes","text":"Name struct batt::seq::WriteToBinder struct batt::seq::Addition struct batt::seq::AllBinder struct batt::seq::AnyBinder struct batt::seq::ApplyBinder class batt::seq::Attach struct batt::seq::AttachBinder struct batt::seq::BoxedBinder class batt::seq::CacheNext struct batt::seq::CacheNextBinder class batt::seq::Chain struct batt::seq::ChainBinder struct batt::seq::Collect struct batt::seq::CollectVec struct batt::seq::Consume struct batt::seq::CountBinder struct batt::seq::DecayItem struct batt::seq::Deref class batt::seq::Empty class batt::seq::Filter struct batt::seq::FilterBinder struct batt::seq::IsNotFalse class batt::seq::FilterMap struct batt::seq::FilterMapBinder struct batt::seq::FirstBinder class batt::seq::Flatten struct batt::seq::FlattenBinder struct batt::seq::ForEachBinder class batt::seq::Fuse struct batt::seq::FuseBinder class batt::seq::GroupBy struct batt::seq::GroupByBinder struct batt::seq::InnerReduceBinder class batt::seq::InspectAdjacent struct batt::seq::InspectAdjacentBinder struct batt::seq::IsSortedBinder class batt::seq::KMergeBy struct batt::seq::KMergeByBinder struct batt::seq::LastBinder class batt::seq::Lazy class batt::seq::Map struct batt::seq::MapBinder class batt::seq::MapAdjacent struct batt::seq::MapAdjacentBinder class batt::seq::MapFold struct batt::seq::MapFoldBinder class batt::seq::MapPairwise struct batt::seq::MapPairwiseBinder class batt::seq::MergeBy struct batt::seq::MergeByBinder struct batt::seq::NaturalEquals struct batt::seq::NaturalOrder struct batt::seq::PrependBinder struct batt::seq::PrintOut class batt::seq::Printable struct batt::seq::PrintableBinder struct batt::seq::ProductBinder struct batt::seq::ReduceBinder struct batt::seq::Reverse struct batt::seq::RollingBinder struct batt::seq::RollingSumBinder class batt::seq::Splice struct batt::seq::SpliceBinder class batt::seq::StatusOk struct batt::seq::StatusOkBinder struct batt::seq::SumBinder struct batt::seq::TakeNBinder class batt::seq::TakeN class batt::seq::TakeWhile struct batt::seq::TakeWhileBinder class batt::seq::Zip struct batt::seq::ZipBinder class batt::seq::SingleItem"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#types","title":"Types","text":"Name enum LoopControl { kContinue = 0, kBreak = 1}"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#functions","title":"Functions","text":"Name template &lt;typename AsyncWriteStream &gt; auto write_to(AsyncWriteStream &amp;&amp; dst) AllBinder all_true() template &lt;typename Seq &gt; auto **[operator AnyBinder any_true() template &lt;typename Seq &gt; auto **[operator template &lt;typename SeqFn &gt; ApplyBinder&lt; SeqFn &gt; apply(SeqFn &amp;&amp; seq_fn) template &lt;typename Seq ,typename SeqFn &gt; decltype(auto) **[operator template &lt;typename D &gt; AttachBinder&lt; D &gt; attach(D &amp;&amp; data) template &lt;typename Seq ,typename D &gt; auto **[operator BoxedBinder boxed() template &lt;typename Seq ,typename  =EnableIfSeq,typename Item  =typename std::conditional_t(),                                                   SeqItem_Impl\\,  StaticType\\&gt;::type&gt; BoxedSeq&lt; Item &gt; **[operator CacheNextBinder cache_next() template &lt;typename Seq &gt; auto **[operator template &lt;typename Seq2 &gt; ChainBinder&lt; Seq2 &gt; chain(Seq2 &amp;&amp; seq2) template &lt;typename Seq1 ,typename Seq2 &gt; Chain&lt; Seq1, Seq2 &gt; **[operator template &lt;typename T &gt; Collect&lt; T &gt; collect(StaticType&lt; T &gt;  ={}) template &lt;typename Seq ,typename T &gt; auto **[operator CollectVec collect_vec() template &lt;typename Seq ,typename  =EnableIfSeq&gt; auto **[operator auto consume() template &lt;typename Seq ,typename  =EnableIfSeq&gt; void **[operator CountBinder count() template &lt;typename Seq &gt; BATT_MAYBE_UNUSED usize **[operator auto decayed() auto deref() template &lt;typename Container &gt; auto emplace_back(Container * dst) template &lt;typename Predicate &gt; FilterBinder&lt; Predicate &gt; filter(Predicate &amp;&amp; predicate) template &lt;typename Seq ,typename Predicate &gt; Filter&lt; Seq, Predicate &gt; **[operator template &lt;typename Seq ,typename Fn &gt; auto filter_map_impl(Seq &amp;&amp; seq, Fn &amp;&amp; fn) template &lt;typename Fn &gt; FilterMapBinder&lt; Fn &gt; filter_map(Fn &amp;&amp; fn) template &lt;typename Seq ,typename Fn &gt; FilterMap&lt; Seq, Fn &gt; **[operator FirstBinder first() template &lt;typename Seq &gt; auto **[operator FlattenBinder flatten() template &lt;typename OuterSeq &gt; Flatten&lt; OuterSeq &gt; **[operator template &lt;typename Fn &gt; ForEachBinder&lt; Fn &gt; for_each(Fn &amp;&amp; fn) template &lt;typename Seq ,typename Fn ,typename  =EnableIfSeq&gt; LoopControl **[operator FuseBinder fuse() template &lt;typename Seq &gt; Fuse&lt; Seq &gt; **[operator template &lt;typename GroupEq &gt; GroupByBinder&lt; GroupEq &gt; group_by(GroupEq &amp;&amp; group_eq) template &lt;typename Seq ,typename GroupEq &gt; GroupBy&lt; Seq, GroupEq &gt; **[operator template &lt;typename ReduceFn &gt; InnerReduceBinder&lt; ReduceFn &gt; inner_reduce(ReduceFn &amp;&amp; reduce_fn) template &lt;typename Seq ,typename ReduceFn &gt; Optional&lt; std::decay_t&lt; SeqItem&lt; Seq &gt; &gt; &gt; **[operator template &lt;typename Fn &gt; auto inspect(Fn &amp;&amp; fn) template &lt;typename Fn &gt; InspectAdjacentBinder&lt; Fn &gt; inspect_adjacent(Fn &amp;&amp; fn) template &lt;typename Seq ,typename Fn &gt; InspectAdjacent&lt; Seq, Fn &gt; **[operator template &lt;typename Compare &gt; IsSortedBinder&lt; Compare &gt; is_sorted_by(Compare &amp;&amp; compare) auto is_sorted() template &lt;typename Seq ,typename Compare &gt; bool **[operator template &lt;typename Compare &gt; KMergeByBinder&lt; Compare &gt; kmerge_by(Compare &amp;&amp; compare) auto kmerge() template &lt;typename KSeqs ,typename Compare &gt; KMergeBy&lt; SeqItem&lt; KSeqs &gt;, Compare &gt; **[operator LastBinder last() template &lt;typename Seq &gt; auto **[operator template &lt;typename Fn &gt; auto lazy(Fn &amp;&amp; fn) template &lt;typename Fn ,typename... Args,typename  =std::enable_if_t, LoopControl&gt;&gt;&gt; LoopControl run_loop_fn(Fn &amp;&amp; fn, Args &amp;&amp;... args) template &lt;typename Fn ,typename... Args,typename  =std::enable_if_t&lt;!std::is_convertible_v, LoopControl&gt;&gt;,typename  =void&gt; LoopControl run_loop_fn(Fn &amp;&amp; fn, Args &amp;&amp;... args) template &lt;typename MapFn &gt; MapBinder&lt; MapFn &gt; map(MapFn &amp;&amp; map_fn) template &lt;typename Seq ,typename MapFn &gt; Map&lt; Seq, MapFn &gt; **[operator template &lt;typename Fn &gt; MapAdjacentBinder&lt; Fn &gt; map_adjacent(Fn &amp;&amp; fn) template &lt;typename Seq ,typename Fn &gt; MapAdjacent&lt; Seq, Fn &gt; **[operator template &lt;typename State ,typename MapFn &gt; MapFoldBinder&lt; State, MapFn &gt; map_fold(State &amp;&amp; state, MapFn &amp;&amp; map_fn) template &lt;typename Seq ,typename State ,typename MapFn &gt; MapFold&lt; Seq, State, MapFn &gt; **[operator template &lt;typename RightSeq ,typename MapFn &gt; MapPairwiseBinder&lt; RightSeq, MapFn &gt; map_pairwise(RightSeq &amp;&amp; right, MapFn &amp;&amp; map_fn) template &lt;typename LeftSeq ,typename RightSeq ,typename MapFn &gt; MapPairwise&lt; LeftSeq, RightSeq, MapFn &gt; **[operator template &lt;typename Compare ,typename RightSeq &gt; MergeByBinder&lt; RightSeq, Compare &gt; merge_by(Compare &amp;&amp; compare, RightSeq &amp;&amp; right) template &lt;typename RightSeq &gt; auto merge(RightSeq &amp;&amp; right) template &lt;typename LeftSeq ,typename RightSeq ,typename Compare &gt; MergeBy&lt; LeftSeq, RightSeq, Compare &gt; **[operator template &lt;typename Item &gt; auto prepend(Item &amp;&amp; item) auto print_out(std::ostream &amp; out, std::string_view sep =\" \") template &lt;typename Seq ,typename  =EnableIfSeq&gt; auto **[operator auto debug_out(std::ostream &amp; out, std::string_view sep =\" \") PrintableBinder printable() template &lt;typename Seq &gt; auto **[operator ProductBinder product() template &lt;typename Seq &gt; auto **[operator template &lt;typename State ,typename ReduceFn &gt; ReduceBinder&lt; State, ReduceFn &gt; reduce(State &amp;&amp; state, ReduceFn &amp;&amp; reduce_fn) template &lt;typename Seq ,typename State ,typename ReduceFn &gt; State **[operator template &lt;typename T ,typename BinaryFn &gt; RollingBinder&lt; T, BinaryFn &gt; rolling(BinaryFn &amp;&amp; binary_fn, T &amp;&amp; initial =T{}) template &lt;typename Seq ,typename T ,typename BinaryFn &gt; auto **[operator RollingSumBinder rolling_sum() template &lt;typename Seq &gt; auto **[operator auto running_total() template &lt;typename InnerSeq &gt; SpliceBinder&lt; InnerSeq &gt; splice(usize n, InnerSeq &amp;&amp; inner_seq) template &lt;typename OuterSeq ,typename InnerSeq &gt; auto **[operator auto status_ok() template &lt;typename SeqT &gt; StatusOk&lt; SeqT &gt; **[operator SumBinder sum() template &lt;typename Seq &gt; auto **[operator TakeNBinder take_n(usize n) template &lt;typename Seq ,typename  =EnableIfSeq&gt; TakeN&lt; Seq &gt; **[operator template &lt;typename Predicate &gt; TakeWhileBinder&lt; Predicate &gt; take_while(Predicate &amp;&amp; predicate) template &lt;typename Seq ,typename Predicate &gt; TakeWhile&lt; Seq, Predicate &gt; **[operator template &lt;typename... OtherSeqs&gt; ZipBinder&lt; OtherSeqs &amp;&amp;... &gt; zip(OtherSeqs &amp;&amp;... other_seqs) template &lt;typename Seq ,typename... OtherSeqs&gt; Zip&lt; Seq, OtherSeqs... &gt; **[operator template &lt;typename T &gt; SingleItem&lt; T &gt; single_item(T &amp;&amp; item)"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#types-documentation","title":"Types Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#enum-loopcontrol","title":"enum LoopControl","text":"Enumerator Value Description kContinue 0 kBreak 1"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-write_to","title":"function write_to","text":"<pre><code>template &lt;typename AsyncWriteStream &gt;\ninline auto write_to(\nAsyncWriteStream &amp;&amp; dst\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-all_true","title":"function all_true","text":"<pre><code>inline AllBinder all_true()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nAllBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-any_true","title":"function any_true","text":"<pre><code>inline AnyBinder any_true()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_1","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nAnyBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-apply","title":"function apply","text":"<pre><code>template &lt;typename SeqFn &gt;\ninline ApplyBinder&lt; SeqFn &gt; apply(\nSeqFn &amp;&amp; seq_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_2","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename SeqFn &gt;\ninline decltype(auto) operator|(\nSeq &amp;&amp; seq,\nApplyBinder&lt; SeqFn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-attach","title":"function attach","text":"<pre><code>template &lt;typename D &gt;\ninline AttachBinder&lt; D &gt; attach(\nD &amp;&amp; data\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_3","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename D &gt;\ninline auto operator|(\nSeq &amp;&amp; seq,\nAttachBinder&lt; D &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-boxed","title":"function boxed","text":"<pre><code>inline BoxedBinder boxed()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_4","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename  =EnableIfSeq&lt;Seq&gt;,\ntypename Item  =typename std::conditional_t&lt;has_seq_requirements&lt;Seq&gt;(),                                                   SeqItem_Impl&lt;Seq&gt;,  StaticType&lt;void&gt;&gt;::type&gt;\ninline BoxedSeq&lt; Item &gt; operator|(\nSeq &amp;&amp; seq,\nBoxedBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-cache_next","title":"function cache_next","text":"<pre><code>inline CacheNextBinder cache_next()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_5","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nCacheNextBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-chain","title":"function chain","text":"<pre><code>template &lt;typename Seq2 &gt;\nChainBinder&lt; Seq2 &gt; chain(\nSeq2 &amp;&amp; seq2\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_6","title":"function operator|","text":"<pre><code>template &lt;typename Seq1 ,\ntypename Seq2 &gt;\nChain&lt; Seq1, Seq2 &gt; operator|(\nSeq1 &amp;&amp; seq1,\nChainBinder&lt; Seq2 &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-collect","title":"function collect","text":"<pre><code>template &lt;typename T &gt;\ninline Collect&lt; T &gt; collect(\nStaticType&lt; T &gt;  ={}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_7","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename T &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nCollect&lt; T &gt; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-collect_vec","title":"function collect_vec","text":"<pre><code>inline CollectVec collect_vec()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_8","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename  =EnableIfSeq&lt;Seq&gt;&gt;\nauto operator|(\nSeq &amp;&amp; seq,\nCollectVec )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-consume","title":"function consume","text":"<pre><code>inline auto consume()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_9","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename  =EnableIfSeq&lt;Seq&gt;&gt;\nvoid operator|(\nSeq &amp;&amp; seq,\nConsume &amp;&amp; )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-count","title":"function count","text":"<pre><code>inline CountBinder count()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_10","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nBATT_MAYBE_UNUSED usize operator|(\nSeq &amp;&amp; seq,\nCountBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-decayed","title":"function decayed","text":"<pre><code>inline auto decayed()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-deref","title":"function deref","text":"<pre><code>inline auto deref()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-emplace_back","title":"function emplace_back","text":"<pre><code>template &lt;typename Container &gt;\ninline auto emplace_back(\nContainer * dst\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-filter","title":"function filter","text":"<pre><code>template &lt;typename Predicate &gt;\nFilterBinder&lt; Predicate &gt; filter(\nPredicate &amp;&amp; predicate\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_11","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Predicate &gt;\nFilter&lt; Seq, Predicate &gt; operator|(\nSeq &amp;&amp; seq,\nFilterBinder&lt; Predicate &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-filter_map_impl","title":"function filter_map_impl","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nauto filter_map_impl(\nSeq &amp;&amp; seq,\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-filter_map","title":"function filter_map","text":"<pre><code>template &lt;typename Fn &gt;\nFilterMapBinder&lt; Fn &gt; filter_map(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_12","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nFilterMap&lt; Seq, Fn &gt; operator|(\nSeq &amp;&amp; seq,\nFilterMapBinder&lt; Fn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-first","title":"function first","text":"<pre><code>inline FirstBinder first()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_13","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nFirstBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-flatten","title":"function flatten","text":"<pre><code>inline FlattenBinder flatten()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_14","title":"function operator|","text":"<pre><code>template &lt;typename OuterSeq &gt;\nFlatten&lt; OuterSeq &gt; operator|(\nOuterSeq &amp;&amp; seq,\nFlattenBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-for_each","title":"function for_each","text":"<pre><code>template &lt;typename Fn &gt;\nForEachBinder&lt; Fn &gt; for_each(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_15","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn ,\ntypename  =EnableIfSeq&lt;Seq&gt;&gt;\nLoopControl operator|(\nSeq &amp;&amp; seq,\nForEachBinder&lt; Fn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-fuse","title":"function fuse","text":"<pre><code>inline FuseBinder fuse()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_16","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nFuse&lt; Seq &gt; operator|(\nSeq &amp;&amp; seq,\nFuseBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-group_by","title":"function group_by","text":"<pre><code>template &lt;typename GroupEq &gt;\nGroupByBinder&lt; GroupEq &gt; group_by(\nGroupEq &amp;&amp; group_eq\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_17","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename GroupEq &gt;\nGroupBy&lt; Seq, GroupEq &gt; operator|(\nSeq &amp;&amp; seq,\nGroupByBinder&lt; GroupEq &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-inner_reduce","title":"function inner_reduce","text":"<pre><code>template &lt;typename ReduceFn &gt;\nInnerReduceBinder&lt; ReduceFn &gt; inner_reduce(\nReduceFn &amp;&amp; reduce_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_18","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename ReduceFn &gt;\nOptional&lt; std::decay_t&lt; SeqItem&lt; Seq &gt; &gt; &gt; operator|(\nSeq &amp;&amp; seq,\nInnerReduceBinder&lt; ReduceFn &gt; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-inspect","title":"function inspect","text":"<pre><code>template &lt;typename Fn &gt;\nauto inspect(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-inspect_adjacent","title":"function inspect_adjacent","text":"<pre><code>template &lt;typename Fn &gt;\nInspectAdjacentBinder&lt; Fn &gt; inspect_adjacent(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_19","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nInspectAdjacent&lt; Seq, Fn &gt; operator|(\nSeq &amp;&amp; seq,\nInspectAdjacentBinder&lt; Fn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-is_sorted_by","title":"function is_sorted_by","text":"<pre><code>template &lt;typename Compare &gt;\nIsSortedBinder&lt; Compare &gt; is_sorted_by(\nCompare &amp;&amp; compare\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-is_sorted","title":"function is_sorted","text":"<pre><code>inline auto is_sorted()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_20","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Compare &gt;\ninline bool operator|(\nSeq &amp;&amp; seq,\nIsSortedBinder&lt; Compare &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-kmerge_by","title":"function kmerge_by","text":"<pre><code>template &lt;typename Compare &gt;\nKMergeByBinder&lt; Compare &gt; kmerge_by(\nCompare &amp;&amp; compare\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-kmerge","title":"function kmerge","text":"<pre><code>inline auto kmerge()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_21","title":"function operator|","text":"<pre><code>template &lt;typename KSeqs ,\ntypename Compare &gt;\nKMergeBy&lt; SeqItem&lt; KSeqs &gt;, Compare &gt; operator|(\nKSeqs &amp;&amp; k_seqs,\nKMergeByBinder&lt; Compare &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-last","title":"function last","text":"<pre><code>inline LastBinder last()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_22","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nLastBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-lazy","title":"function lazy","text":"<pre><code>template &lt;typename Fn &gt;\nauto lazy(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-run_loop_fn","title":"function run_loop_fn","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args,\ntypename  =std::enable_if_t&lt;std::is_convertible_v&lt;std::invoke_result_t&lt;Fn&amp;&amp;, Args&amp;&amp;...&gt;, LoopControl&gt;&gt;&gt;\nLoopControl run_loop_fn(\nFn &amp;&amp; fn,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-run_loop_fn_1","title":"function run_loop_fn","text":"<pre><code>template &lt;typename Fn ,\ntypename... Args,\ntypename  =std::enable_if_t&lt;!std::is_convertible_v&lt;std::invoke_result_t&lt;Fn&amp;&amp;, Args&amp;&amp;...&gt;, LoopControl&gt;&gt;,\ntypename  =void&gt;\nLoopControl run_loop_fn(\nFn &amp;&amp; fn,\nArgs &amp;&amp;... args\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map","title":"function map","text":"<pre><code>template &lt;typename MapFn &gt;\nMapBinder&lt; MapFn &gt; map(\nMapFn &amp;&amp; map_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_23","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename MapFn &gt;\nMap&lt; Seq, MapFn &gt; operator|(\nSeq &amp;&amp; seq,\nMapBinder&lt; MapFn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map_adjacent","title":"function map_adjacent","text":"<pre><code>template &lt;typename Fn &gt;\nMapAdjacentBinder&lt; Fn &gt; map_adjacent(\nFn &amp;&amp; fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_24","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Fn &gt;\nMapAdjacent&lt; Seq, Fn &gt; operator|(\nSeq &amp;&amp; seq,\nMapAdjacentBinder&lt; Fn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map_fold","title":"function map_fold","text":"<pre><code>template &lt;typename State ,\ntypename MapFn &gt;\nMapFoldBinder&lt; State, MapFn &gt; map_fold(\nState &amp;&amp; state,\nMapFn &amp;&amp; map_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_25","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename State ,\ntypename MapFn &gt;\nMapFold&lt; Seq, State, MapFn &gt; operator|(\nSeq &amp;&amp; seq,\nMapFoldBinder&lt; State, MapFn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-map_pairwise","title":"function map_pairwise","text":"<pre><code>template &lt;typename RightSeq ,\ntypename MapFn &gt;\nMapPairwiseBinder&lt; RightSeq, MapFn &gt; map_pairwise(\nRightSeq &amp;&amp; right,\nMapFn &amp;&amp; map_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_26","title":"function operator|","text":"<pre><code>template &lt;typename LeftSeq ,\ntypename RightSeq ,\ntypename MapFn &gt;\nMapPairwise&lt; LeftSeq, RightSeq, MapFn &gt; operator|(\nLeftSeq &amp;&amp; left,\nMapPairwiseBinder&lt; RightSeq, MapFn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-merge_by","title":"function merge_by","text":"<pre><code>template &lt;typename Compare ,\ntypename RightSeq &gt;\nMergeByBinder&lt; RightSeq, Compare &gt; merge_by(\nCompare &amp;&amp; compare,\nRightSeq &amp;&amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-merge","title":"function merge","text":"<pre><code>template &lt;typename RightSeq &gt;\nauto merge(\nRightSeq &amp;&amp; right\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_27","title":"function operator|","text":"<pre><code>template &lt;typename LeftSeq ,\ntypename RightSeq ,\ntypename Compare &gt;\nMergeBy&lt; LeftSeq, RightSeq, Compare &gt; operator|(\nLeftSeq &amp;&amp; left,\nMergeByBinder&lt; RightSeq, Compare &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-prepend","title":"function prepend","text":"<pre><code>template &lt;typename Item &gt;\ninline auto prepend(\nItem &amp;&amp; item\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-print_out","title":"function print_out","text":"<pre><code>inline auto print_out(\nstd::ostream &amp; out,\nstd::string_view sep =\" \"\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_28","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename  =EnableIfSeq&lt;Seq&gt;&gt;\ninline auto operator|(\nSeq &amp;&amp; seq,\nPrintOut p\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-debug_out","title":"function debug_out","text":"<pre><code>inline auto debug_out(\nstd::ostream &amp; out,\nstd::string_view sep =\" \"\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-printable","title":"function printable","text":"<pre><code>inline PrintableBinder printable()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_29","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\ninline auto operator|(\nSeq &amp;&amp; seq,\nPrintableBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-product","title":"function product","text":"<pre><code>inline ProductBinder product()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_30","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nProductBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-reduce","title":"function reduce","text":"<pre><code>template &lt;typename State ,\ntypename ReduceFn &gt;\nReduceBinder&lt; State, ReduceFn &gt; reduce(\nState &amp;&amp; state,\nReduceFn &amp;&amp; reduce_fn\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_31","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename State ,\ntypename ReduceFn &gt;\nState operator|(\nSeq &amp;&amp; seq,\nReduceBinder&lt; State, ReduceFn &gt; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-rolling","title":"function rolling","text":"<pre><code>template &lt;typename T ,\ntypename BinaryFn &gt;\ninline RollingBinder&lt; T, BinaryFn &gt; rolling(\nBinaryFn &amp;&amp; binary_fn,\nT &amp;&amp; initial =T{}\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_32","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename T ,\ntypename BinaryFn &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nRollingBinder&lt; T, BinaryFn &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-rolling_sum","title":"function rolling_sum","text":"<pre><code>inline RollingSumBinder rolling_sum()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_33","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nRollingSumBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-running_total","title":"function running_total","text":"<pre><code>inline auto running_total()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-splice","title":"function splice","text":"<pre><code>template &lt;typename InnerSeq &gt;\ninline SpliceBinder&lt; InnerSeq &gt; splice(\nusize n,\nInnerSeq &amp;&amp; inner_seq\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_34","title":"function operator|","text":"<pre><code>template &lt;typename OuterSeq ,\ntypename InnerSeq &gt;\nauto operator|(\nOuterSeq &amp;&amp; outer_seq,\nSpliceBinder&lt; InnerSeq &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-status_ok","title":"function status_ok","text":"<pre><code>inline auto status_ok()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_35","title":"function operator|","text":"<pre><code>template &lt;typename SeqT &gt;\ninline StatusOk&lt; SeqT &gt; operator|(\nSeqT &amp;&amp; seq,\nStatusOkBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-sum","title":"function sum","text":"<pre><code>inline SumBinder sum()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_36","title":"function operator|","text":"<pre><code>template &lt;typename Seq &gt;\nauto operator|(\nSeq &amp;&amp; seq,\nSumBinder )\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-take_n","title":"function take_n","text":"<pre><code>inline TakeNBinder take_n(\nusize n\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_37","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename  =EnableIfSeq&lt;Seq&gt;&gt;\nTakeN&lt; Seq &gt; operator|(\nSeq &amp;&amp; seq,\nconst TakeNBinder &amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-take_while","title":"function take_while","text":"<pre><code>template &lt;typename Predicate &gt;\nTakeWhileBinder&lt; Predicate &gt; take_while(\nPredicate &amp;&amp; predicate\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_38","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename Predicate &gt;\nTakeWhile&lt; Seq, Predicate &gt; operator|(\nSeq &amp;&amp; seq,\nTakeWhileBinder&lt; Predicate &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-zip","title":"function zip","text":"<pre><code>template &lt;typename... OtherSeqs&gt;\nZipBinder&lt; OtherSeqs &amp;&amp;... &gt; zip(\nOtherSeqs &amp;&amp;... other_seqs\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-operator_39","title":"function operator|","text":"<pre><code>template &lt;typename Seq ,\ntypename... OtherSeqs&gt;\nZip&lt; Seq, OtherSeqs... &gt; operator|(\nSeq &amp;&amp; seq,\nZipBinder&lt; OtherSeqs &amp;&amp;... &gt; &amp;&amp; binder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq/#function-single_item","title":"function single_item","text":"<pre><code>template &lt;typename T &gt;\nSingleItem&lt; T &gt; single_item(\nT &amp;&amp; item\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq_1_1detail/","title":"batt::seq::detail","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1seq_1_1detail/#classes","title":"Classes","text":"Name struct batt::seq::detail::HeapOrderBase struct batt::seq::detail::HeapOrderEmptyBase struct batt::seq::detail::HeapOrder"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq_1_1detail/#functions","title":"Functions","text":"Name void zip_seqs_static_asserts() template &lt;typename First ,typename... Rest&gt; void zip_seqs_static_asserts(StaticType&lt; First &gt; , StaticType&lt; Rest &gt;... rest)"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq_1_1detail/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacebatt_1_1seq_1_1detail/#function-zip_seqs_static_asserts","title":"function zip_seqs_static_asserts","text":"<pre><code>inline void zip_seqs_static_asserts()\n</code></pre>"},{"location":"_autogen/Namespaces/namespacebatt_1_1seq_1_1detail/#function-zip_seqs_static_asserts_1","title":"function zip_seqs_static_asserts","text":"<pre><code>template &lt;typename First ,\ntypename... Rest&gt;\ninline void zip_seqs_static_asserts(\nStaticType&lt; First &gt; ,\nStaticType&lt; Rest &gt;... rest\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacebatteries/","title":"batteries","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespaceboost/","title":"boost","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacepico__http/","title":"pico_http","text":""},{"location":"_autogen/Namespaces/namespacepico__http/#namespaces","title":"Namespaces","text":"Name pico_http::detail"},{"location":"_autogen/Namespaces/namespacepico__http/#classes","title":"Classes","text":"Name struct pico_http::MessageHeader struct pico_http::Request struct pico_http::Response struct pico_http::ChunkedDecoder struct pico_http::DecodeResult"},{"location":"_autogen/Namespaces/namespacepico__http/#functions","title":"Functions","text":"Name std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const MessageHeader &amp; t) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const batt::SmallVecBase&lt; MessageHeader &gt; &amp; t) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Request &amp; t) std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Response &amp; t) int parse_headers(const char * buf, usize len, batt::SmallVecBase&lt; MessageHeader &gt; * headers, usize last_len =0) batt::StatusOr&lt; DecodeResult &gt; decode_chunked(ChunkedDecoder * decoder, const batt::ConstBuffer &amp; input, batt::SmallVecBase&lt; batt::ConstBuffer &gt; * output) int decode_chunked_is_in_data(ChunkedDecoder * decoder)"},{"location":"_autogen/Namespaces/namespacepico__http/#attributes","title":"Attributes","text":"Name constexpr usize kDefaultNumHeaders constexpr int kParseOk constexpr int kParseFailed constexpr int kParseIncomplete"},{"location":"_autogen/Namespaces/namespacepico__http/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst MessageHeader &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst batt::SmallVecBase&lt; MessageHeader &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Request &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#function-operator_3","title":"function operator&lt;&lt;","text":"<pre><code>inline std::ostream &amp; operator&lt;&lt;(\nstd::ostream &amp; out,\nconst Response &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#function-parse_headers","title":"function parse_headers","text":"<pre><code>int parse_headers(\nconst char * buf,\nusize len,\nbatt::SmallVecBase&lt; MessageHeader &gt; * headers,\nusize last_len =0\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#function-decode_chunked","title":"function decode_chunked","text":"<pre><code>inline batt::StatusOr&lt; DecodeResult &gt; decode_chunked(\nChunkedDecoder * decoder,\nconst batt::ConstBuffer &amp; input,\nbatt::SmallVecBase&lt; batt::ConstBuffer &gt; * output\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#function-decode_chunked_is_in_data","title":"function decode_chunked_is_in_data","text":"<pre><code>inline int decode_chunked_is_in_data(\nChunkedDecoder * decoder\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kdefaultnumheaders","title":"variable kDefaultNumHeaders","text":"<pre><code>constexpr usize kDefaultNumHeaders = 16;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kparseok","title":"variable kParseOk","text":"<pre><code>constexpr int kParseOk = 0;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kparsefailed","title":"variable kParseFailed","text":"<pre><code>constexpr int kParseFailed = -1;\n</code></pre>"},{"location":"_autogen/Namespaces/namespacepico__http/#variable-kparseincomplete","title":"variable kParseIncomplete","text":"<pre><code>constexpr int kParseIncomplete = -2;\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail/","title":"pico_http::detail","text":"<p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d201/","title":"pico_http::detail::@201","text":""},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d201/#types","title":"Types","text":"Name enum @0 { }"},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d201/#types-documentation","title":"Types Documentation","text":""},{"location":"_autogen/Namespaces/namespacepico__http_1_1detail_1_1_0d201/#enum-0","title":"enum @0","text":"Enumerator Value Description <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Namespaces/namespacestd/","title":"std","text":""},{"location":"_autogen/Namespaces/namespacestd/#functions","title":"Functions","text":"Name template &lt;typename T &gt; ostream &amp; operator&lt;&lt;(ostream &amp; out, const optional&lt; T &gt; &amp; t) template &lt;typename Fn ,typename  =enable_if_t&lt;::batt::IsCallable{}&gt;&gt; ostream &amp; operator&lt;&lt;(ostream &amp; out, Fn &amp;&amp; fn)"},{"location":"_autogen/Namespaces/namespacestd/#functions-documentation","title":"Functions Documentation","text":""},{"location":"_autogen/Namespaces/namespacestd/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename T &gt;\ninline ostream &amp; operator&lt;&lt;(\nostream &amp; out,\nconst optional&lt; T &gt; &amp; t\n)\n</code></pre>"},{"location":"_autogen/Namespaces/namespacestd/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template &lt;typename Fn ,\ntypename  =enable_if_t&lt;::batt::IsCallable&lt;Fn, ostream&amp;&gt;{}&gt;&gt;\ninline ostream &amp; operator&lt;&lt;(\nostream &amp; out,\nFn &amp;&amp; fn\n)\n</code></pre> <p>Updated on 25 September 2024 at 19:11:57 UTC</p>"},{"location":"_autogen/Pages/","title":"Pages","text":"<ul> <li>page NOTICE </li> </ul> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"_autogen/Pages/md_batteries_pico_http_README/","title":"NOTICE","text":"<p>The contents of this directory were copied and modified from the Pico HTTP Parser project under the terms of the MIT License.</p> <p>The original copyright notice is preserved in the source files, and also quoted here:</p> <pre><code>/*\n * Copyright (c) 2009-2014 Kazuho Oku, Tokuhiro Matsuno, Daisuke Murase,\n *                         Shigeo Mitsunari\n *\n * The software is licensed under either the MIT License (below) or the Perl\n * license.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n</code></pre> <p>DO NOT remove this notice from the files in this directory!</p> <p>The Pico HTTP Parser and H2O projects are amazing and awesome; you should definitely support the authors and the project!!! </p> <p>Updated on 25 September 2024 at 19:11:58 UTC</p>"},{"location":"how-to/configure-ci-pipelines/","title":"How to Configure CI Pipelines for Batteries in GitLab","text":"<p>[[TOC]]</p>"},{"location":"how-to/configure-ci-pipelines/#create-a-deploy-token-for-the-repository","title":"Create a Deploy Token for the Repository","text":"<p>This step is necessary to allow Conan to access the Package Registry for your project so releases can be published.</p> <p>Navigate to your repo on GitLab.  Go to  Settings &gt; Repository &gt; Deploy Tokens</p> <p>Enter the following:</p> <ul> <li>Name: gitlab-deploy-token</li> <li>Expiration date (optional):  <li>Username (optional):  <p>For the \"Scopes\" section, click the checkbox next to <code>write_package_registry</code> (this is the only required capability).</p> <p>NOTE: The name \"gitlab-deploy-token\" MUST be entered exactly as shown; this is a special magic token name that GitLab uses to infer that the token should be injected via environment variables to CI/CD pipelines.</p> <p>Click \"Create deploy token.\"  You can save the token value if you want, but you don't have to; it will be automatically injected into your pipeline jobs from now on.</p>"},{"location":"how-to/configure-ci-pipelines/#set-cicd-variables","title":"Set CI/CD Variables","text":"<p>This step is necessary to tell Conan where to push released packages, and under what username and channel.</p> <p>NOTE: The instructions for this step assume that any Conan remote you are going to use have been configured in <code>docker/Dockerfile</code>.  For example:</p> <pre><code>...\n\n# Point at various release package repos.\n#\nRUN conan remote add gitlab https://gitlab.com/api/v4/packages/conan\n\n...\n</code></pre> <p>Navigate to your repo on GitLab.  Go to  Settings &gt; CI/CD &gt; Variables &gt; Expand</p> <p>You must create three variables:</p> <ul> <li><code>RELEASE_CONAN_USER</code>: The user under which to release packages; this should be the name of your repo on GitLab, with '+' substituted for '/'.  For example, if your project lives at <code>https://gitlab.com/janedoe/batteries_fork</code>, the Conan user should be <code>janedoe+batteries_fork</code></li> <li><code>RELEASE_CONAN_CHANNEL</code>: The channel under which to release packages (for example, \"stable\", \"unstable\", or \"testing\")</li> <li><code>RELEASE_CONAN_REMOTE</code>: The Conan remote name for the package registry to which releases should be published</li> </ul> <p>When you publish a release (e.g., 1.7.3), the Conan \"recipe name\" will be <code>batteries/1.7.3@$RELEASE_CONAN_USER/$RELEASE_CONAN_CHANNEL</code>.</p> <p>For each variable, leave the Type as \"Variable\" and the Environment scope as \"All (default)\".  Under \"Flags\", \"Protect variable\" and \"Mask variable\" should both be unchecked.</p>"},{"location":"how-to/configure-ci-pipelines/#build-the-pipeline-docker-image-and-upload-to-gitlab","title":"Build the Pipeline Docker Image and Upload to GitLab","text":"<ol> <li>Clone a local repo:    <pre><code>git clone https://gitlab.com/tonyastolfi/batteries\n</code></pre></li> <li>Enter the local repo directory:    <pre><code>cd batteries/\n</code></pre></li> <li>Build the docker image:    <pre><code>make docker-build\n</code></pre></li> <li>Create an Access Token to login to the GitLab Docker Container Registry:</li> <li>Go to (Your Profile Picture in the upper-right corner) &gt; Edit profile (in the drop-down) &gt; Access Tokens (in the left-sidebar)</li> <li>Enter a token name and expiration date (can be anything)</li> <li>Select scope \"api\"</li> <li>Click \"Create personal access token\"</li> <li>IMPORTANT: Write down the access token value (or copy-paste it somewhere)  Otherwise you will need to do these steps over again!</li> <li>(first time only) Log in to the GitLab Container Registry using the access token you just created (you can retrieve the correct command for your GitLab instance by going to (your repo) &gt; Packages &amp; Registries &gt; Container Registry and clicking the CLI Commands drop down button in the upper-right):    <pre><code>docker login registry.gitlab.com\n</code></pre></li> <li>Upload the container image you built in step 3:    <pre><code>make docker-push\n</code></pre></li> </ol> <p>If you want to check to see if this succeeded, you can go to (your repo) &gt; Packages &amp; Registries &gt; Container Registry to see a list of the containers that have been added to your registry.</p>"},{"location":"how-to/configure-ci-pipelines/#configure-gitlab-runners","title":"Configure GitLab Runners","text":"<p>NOTE: This step is optional if your GitLab instance already has CI Runners configured in the scope of your project.  You can check whether this is the case by navigating to (your repo) &gt; Settings &gt; CI/CD &gt; Runners &gt; Expand.</p>"},{"location":"how-to/configure-ci-pipelines/#install-gitlab-runner-on-your-hardware","title":"Install GitLab Runner on your hardware","text":""},{"location":"how-to/configure-ci-pipelines/#gnulinux-x86_64","title":"GNU/Linux (x86_64)","text":""},{"location":"how-to/configure-ci-pipelines/#download","title":"Download","text":"<p>Follow the instructions at Linux Manual Install option (Linux x86-64) to download the gitlab-runner binary:</p> <pre><code>sudo curl -L --output /usr/local/bin/gitlab-runner \"https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64\"\n</code></pre>"},{"location":"how-to/configure-ci-pipelines/#make-runnable","title":"Make runnable","text":"<pre><code>sudo chmod +x /usr/local/bin/gitlab-runner\n</code></pre>"},{"location":"how-to/configure-ci-pipelines/#create-gitlab-runner-user","title":"Create gitlab-runner user","text":"<p>You can put the home directory for this user wherever you want; it was convenient for my setup to place it under <code>/local/home</code>.</p> <pre><code>mkdir -p /local/home/ &amp;&amp; sudo useradd gitlab-runner --comment 'GitLab Runner' --home /local/home/gitlab-runner --create-home --shell /bin/bash\n</code></pre>"},{"location":"how-to/configure-ci-pipelines/#install-the-runner","title":"\"Install\" the runner","text":"<pre><code>sudo gitlab-runner install --user=gitlab-runner --working-directory=/local/home/gitlab-runner\n</code></pre>"},{"location":"how-to/configure-ci-pipelines/#start-the-runner","title":"Start the runner","text":"<pre><code>sudo gitlab-runner start\n</code></pre>"},{"location":"how-to/configure-ci-pipelines/#register-the-runner-with-gitlab","title":"Register the runner with GitLab","text":"<p>Go to (your repo) &gt; Settings &gt; CI/CD &gt; Runners &gt; Expand.</p> <p>Under the column \"Specific runners,\" copy the registration token string.</p> <p>On the machine where you installed gitlab-runner:</p> <pre><code>sudo gitlab-runner register\n</code></pre> <p>This will prompt you for various pieces of information.  Paste the registration token string you copied above when prompted.</p> <p>NOTE: When asked for executor type, choose <code>docker</code>.  When it asks you about the default Docker image, enter <code>registry.gitlab.com/tonyastolfi/batteries</code>.  Do not enter any tags/labels when prompted.</p> <p>If this step is successful, you will see your runner show up on the Settings &gt; CI/CD &gt; Runners page in GitLab.</p>"},{"location":"how-to/write-the-docs/","title":"Writing Documentation for Batteries C++","text":"<p>Batteries is a work in progress, but our aim is to provide the best documentation possible for our users.  This guide desecribes the tools and process we use to write, build, and deploy documentation.</p>"},{"location":"how-to/write-the-docs/#quick-start","title":"Quick Start","text":"<p>From the Git repo root, run the shell command:</p> <pre><code>make serve-docs\n</code></pre> <p>Expected output:</p> <pre><code>...\nINFO     -  [17:56:51] Serving on http://127.0.0.1:8000/\n</code></pre> <p>Now you should be able to navigate to http://localhost:8000/ and view the documentation site served by your development machine.  Any changes made to the source files will be reflected automatically be reflected after running:</p> <pre><code>make mkdocs\n</code></pre> <p>_ NOTE:  The shell commands in this document assume you have the documentation tools installed.  If you want to install them on your machine natively, you can check <code>batteries/docker/Dockerfile</code> to see how they are installed for CI pipelines.  The recommended method, however, is to run all commands inside a Docker container using the <code>batteries/script/run-with-docker.sh</code> script.  Example:</p> <pre><code>script/run-with-docker.sh make serve-docs\n</code></pre>"},{"location":"how-to/write-the-docs/#what-to-edit","title":"What to Edit","text":"<ul> <li>src/  Doxygen-style comments in C++ source files</li> <li>config/  Doc tool configuration and customization<ul> <li>mkdocs.yml  Site navigation tree</li> <li>mkdocs_overrides/  General HTML layout customization</li> <li>doxybook_templates/  Generated API Reference HTML layout customization</li> </ul> </li> <li>doc/  Handwritten markdown files (subdirs are OK too!)<ul> <li>images/  Static image assets</li> <li>stylesheets/  Handwritten CSS</li> </ul> </li> </ul>"},{"location":"how-to/write-the-docs/#overview","title":"Overview","text":"<p>The documentation site of Batteries C++ is hosted by GitHub Pages.  There are many source materials that go into building the site:</p> <ul> <li>Hand-written MarkDown files (such as this one)</li> <li>Doxygen-style Doc Comments in the C++ Source Code</li> <li>Static Web Assets (e.g., images, css, etc.)</li> <li>Metadata that describes the site structure and the build process</li> </ul>"},{"location":"how-to/write-the-docs/#mkdocs","title":"MkDocs","text":"<p>At the top level, the site is statically generated using MkDocs.  The MkDocs project is constructed from files gathered from various places in the Git repo, as well as automatically generated content produced by scraping the source code.  The basic structure of a MkDocs project is:</p> <ul> <li>project/   The project root directory<ul> <li>mkdocs.yml   The MkDocs config file</li> <li>docs/   The site source files<ul> <li>images/   Base directory for image files</li> <li>stylesheets/   Base directory for CSS style sheets</li> </ul> </li> <li>overrides/   Theme partial layout overrides</li> </ul> </li> </ul> <p>The MkDocs project for Batteries is generated inside <code>batteries/build/mkdocs/</code> by the Makefile target <code>mkdocs</code>:</p> <pre><code>make mkdocs\n</code></pre> <p> NOTE:  The <code>mkdocs</code> target depends on the <code>doxygen</code> and <code>doxybook2</code> targets, so you don't need to run those separately.</p>"},{"location":"how-to/write-the-docs/#mkdocsyml","title":"mkdocs.yml","text":"<p>The source file for <code>mkdocs.yml</code> lives at <code>batteries/config/mkdocs.yml</code>.  This is where you configure:</p> <ul> <li>The site name (\"Batteries C++\")</li> <li>The theme (we currently use a customized version of Material)</li> <li>The locations of any extra .css files</li> <li>The site navigation tree (which appears on the right sidebar)</li> <li>Plugins and MarkDown language extensions</li> </ul>"},{"location":"how-to/write-the-docs/#docs","title":"docs/","text":"<p>All handwritten files inside the MkDocs <code>docs/</code> dir are copied from <code>batteries/doc/</code>.  In addition, the Makefile creates a subdir called <code>_autogen/</code> under <code>docs/</code> containing all content generated by Doxygen and Doxybook2 (see below).</p>"},{"location":"how-to/write-the-docs/#overrides","title":"overrides/","text":"<p>This directory is copied from <code>batteries/config/mkdocs_overrides/</code>.  It contains all HTML layout customizations to the Material theme.  For more information, read this document.</p>"},{"location":"how-to/write-the-docs/#doxygendoxybook2","title":"Doxygen/Doxybook2","text":"<p>We scrape the C++ source code inside <code>batteries/src/</code> using Doxygen to extract API documentation.  The Doxygen config file lives at <code>batteries/config/doxygen.config</code>, and the corresponding output is produced in `batteries/build/doxygen/'.</p> <p>To run just the Doxygen tool, you can run the Makefile like this:</p> <pre><code>make doxygen\n</code></pre> <p> NOTE:  The <code>doxygen</code> target depends on the <code>doxybook2</code> target, so you don't need to run it separately.</p> <p>The default Doxygen HTML output looks much worse than what MkDocs produces, and it isn't styled according to the Material theme.  To bridge the gap, we use Doxybook2.  Doxybook2 takes the XML output of Doxygen and produces MarkDown files which can be formatted and styled in a manner consistent with the rest of the site.</p> <p>The Doxybook2 config file lives at <code>batteries/config/doxybook_config.json</code>.  The templates used to generate MarkDown live inside <code>batteries/config/doxybook_templates/</code>.  You can read about how to modify these here.</p> <p>Doxybook2 output is generated inside <code>batteries/build/doxybook2/</code>.  You can regenerate this output using:</p> <pre><code>make doxybook2\n</code></pre>"}]}